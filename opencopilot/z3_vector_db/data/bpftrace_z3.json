[{
    "kretprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">= 0",
            "nbits": ">= 0"
        }
    }
},
{
    "kprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">0",
            "dst_size": "==nbits",
            "src_size": "==nbits",
            "shift": "<nbits"
        }
    }
},
{
    "kretprobe:__bitmap_shift_left": {
        "description": "Logical left shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:__bitmap_shift_left": {
        "description": "Logical left shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": ">=0",
            "cut": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": ">=0",
            "cut": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": ">=0",
            "align_offset": ">=0",
            "align_mask": "is one less than a power of 2"
        }
    }
},
{
    "kprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": ">=0",
            "align_offset": ">=0",
            "align_mask": "is one less than a power of 2"
        }
    }
},
{
    "kretprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string",
        "pre": {
            "list": "bool",
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": "int"
        },
        "post": {
            "return": "int",
            "buf": "!=null",
            "buf_length": "int"
        }
    }
},
{
    "kprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string",
        "pre": {
            "list": "bool",
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:bitmap_print_bitmask_to_buf": {
        "description": "Prints the bitmask to the buffer.",
        "pre": {
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": ">=0",
            "off": ">=0",
            "count": ">=0"
        }
    }
},

{
    "kretprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit",
        "pre": {
            "oldbit": "!=null",
            "old": "!=null",
            "new": "!=null",
            "bits": "!=null"
        }
    }
},
{
    "kprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit.",
        "pre": {
            "oldbit": "!=null",
            "old": "!=null",
            "new": "!=null",
            "bits": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_find_free_region": {
        "description": "Find a contiguous aligned mem region",
        "pre": {
            "bitmap": "!=null",
            "bits": "!=null",
            "order": "!=null",
            "order": "is a power of 2",
            "order": ">= 0",
            "bits": ">= order",
            "bitmap": "has at least (bits / 8) elements"
        }
    }
},
{
    "kprobe:bitmap_find_free_region": {
        "description": "Find a contiguous aligned mem region",
        "pre": {
            "bitmap": "!=null",
            "bits": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap.",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap.",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": "% BITS_PER_LONG == 0"
        }
    }
},
{
    "kprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": "% BITS_PER_LONG == 0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:sg_split": {
        "description": "Split a scatterlist into several scatterlists",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_split": {
        "description": "Split a scatterlist into several scatterlists",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:unlikely(val.t - m->s[2].t > win))": {
        "description": "Check if the difference between val.t and m->s[2].t is greater than win.",
        "pre": {
            "val.t": "!=null",
            "m->s[2].t": "!=null",
            "win": "!=null"
        }
    }
},

{
    "kretprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL]"
        }
    }
},
{
    "kprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL]"
        }
    }
},
{
    "kretprobe:cpu_rmap_put": {
        "description": "Release reference on a cpu_rmap",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_put": {
        "description": "Release ref on a cpu_rmap",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kretprobe:cpu_rmap_add": {
        "description": "Add object to a rmap",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
        "post": {
            "return_value": ">= -ENOSPC"
        }
    }
},
{
    "kprobe:cpu_rmap_add": {
        "description": "Add object to a rmap",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
        "post": {
            "return": "int",
            "return_conditions": {
                "value": ">= -ENOSPC"
            }
        }
    }
},
{
    "kretprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "pre": {
            "rmap": "!=null",
            "index": "!=null",
            "affinity": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "pre": {
            "rmap": "!=null",
            "index": "!=null",
            "affinity": "!=null"
        }
    }
},
{
    "kretprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs.",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs.",
        "pre": {
            "rmap": "in [null, not null]",
            "context": "in [process context]",
            "irqs": "must be freed before calling this function"
        }
    }
},
{
    "kretprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map.",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:___ratelimit": {
        "description": "Paired with WRITE_ONCE() in .proc_handler(). Changing two values separately could be inconsistent and some message could be lost. (See: net_ratelimit_state).",
        "pre": {
            "rs": "!=null",
            "func": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:string_get_size": {
        "description": "get the size in the specified units",
        "pre": {
            "size": "!=null",
            "blk_size": "!=null",
            "units": "in [1000, 1024]",
            "buf": "!=null",
            "len": ">=9"
        }
    }
},
{
    "kprobe:string_get_size": {
        "description": "get the size in the specified units",
        "pre": {
            "size": "!=null",
            "blk_size": "!=null",
            "units": "in [1000, 1024]",
            "buf": "!=null",
            "len": ">=9"
        }
    }
},
{
    "kretprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        }
    }
},
{
    "kprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        }
    }
},
{
    "kretprobe:string_unescape": {
        "description": "Unquote characters in the given string.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": ">=0",
            "flags": "& [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:string_unescape": {
        "description": "Unquote characters in the given string.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": ">=0",
            "flags": "in [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:string_escape_mem": {
        "description": "quote characters in the given memory buffer",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": ">=0",
            "only": "!=null"
        }
    }
},
{
    "kprobe:string_escape_mem": {
        "description": "Quote characters in the given memory buffer.",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": ">=0",
            "only": "!=null"
        }
    }
},
{
    "kretprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "count": ">0"
        }
    }
},
{
    "kprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "count": ">0"
        }
    }
},
{
    "kretprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str.",
        "pre": {
            "str": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str.",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strim": {
        "description": "Removes leading and trailing whitespace from the given string.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:strim": {
        "description": "Removes leading and trailing whitespace from the given string.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "string": "!=null"
        },
        "post": {
            "return": ">= -22"
        }
    }
},
{
    "kprobe:match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "string": "!=null"
        }
    }
},
{
    "kretprobe:__sysfs_match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "str": "!=null"
        },
        "post": {
            "return": ">= -EINVAL",
            "return": "<= n",
            "return": "!= -1"
        }
    }
},
{
    "kprobe:__sysfs_match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">=0",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strreplace": {
        "description": "Replace all occurrences of character in string.",
        "pre": {
            "str": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
        "post": {
            "return": "==str"
        }
    }
},
{
    "kprobe:strreplace": {
        "description": "Replace all occurrences of character in string.",
        "pre": {
            "str": "!=null",
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding",
        "pre": {
            "dest": "!=null",
            "dest_len": ">= count",
            "src": "!=null",
            "count": ">= 0",
            "pad": ">= 0"
        }
    }
},
{
    "kprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding",
        "pre": {
            "dest": "!=null",
            "dest_len": ">= count",
            "src": "!=null",
            "count": ">= 0",
            "pad": ">= 0"
        }
    }
},


{
    "kretprobe:kstrtoull": {
        "description": "convert a string to an unsigned long long",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoull": {
        "description": "Convert a string to an unsigned long long.",
        "pre": {
            "s": "!=null",
            "base": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:kstrtoll": {
        "description": "Converts a string to a long long.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoll": {
        "description": "Convert a string to a long long",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtouint": {
        "description": "Convert a string to an unsigned int.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:noinlineint kstrtouint": {
        "description": "Convert a string to an unsigned int.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtoint": {
        "description": "Converts a string to an integer.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoint": {
        "description": "Convert a string to an int",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values.",
        "pre": {
            "s": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "==0",
            "res": "!=null"
        }
    }
},
{
    "kprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values.",
        "pre": {
            "s": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:kstrtobool_from_user": {
        "description": "Converts a string to a boolean value from user space.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [-EFAULT, 0, 1]",
            "buf": "!=null",
            "buf[count]": "= '\\0'"
        }
    }
},
{
    "kprobe:kstrtobool_from_user": {
        "description": "Converts a string from user space to a boolean value.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign \"-\". Radix 0 means autodetection: leading \"0x\" implies radix 16, leading \"0\" implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign \"-\". Radix 0 means autodetection: leading \"0x\" implies radix 16, leading \"0\" implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        }
    }
},



{
    "kprobe:_find_first_and_bit": {
        "description": "Find the first bit set in the bitwise AND of addr1[idx] and addr2[idx].",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "size": "!=null"
        }
    }
},

{
    "kprobe:find_first_zero_bit": {
        "description": "Find the first zero bit in the memory range starting at *addr* with size *size*.",
        "pre": {
            "addr": "!=null",
            "size": "!=null"
        }
    }
},










{
    "kretprobe:if (strnlen( maxlen) < maxlen)return false;/* Don't dirty result unless string is valid MAC. `": {
        "description": "Check if the string is a valid MAC address.",
        "pre": {
            "s": "!=null",
            "maxlen": ">=0",
            "mac": "!=null",
            "mac[0]": ">=0",
            "mac[1]": ">=0",
            "mac[2]": ">=0",
            "mac[3]": ">=0",
            "mac[4]": ">=0",
            "mac[5]": ">=0"
        }
    }
},
{
    "kprobe:if (strnlen( maxlen) < maxlen)return false;/* Don't dirty result unless string is valid MAC. `": {
        "description": "Check if the string `s` represents a valid MAC address.",
        "pre": {
            "s": "!=null",
            "maxlen": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_iov_iter_readable": {
        "description": "Fault in iov iterator for reading",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_iov_iter_readable": {
        "description": "Fault in iov iterator for reading",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_iov_iter_writeable": {
        "description": "Fault in iov iterator for writing",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_iov_iter_writeable": {
        "description": "Fault in iov iterator for writing",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_iovec_advance": {
        "description": "Advance the iov_iter by the specified size when it is of type iovec.",
        "pre": {
            "i": "!=null",
            "size": "!=null",
            "i->count": "!=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_iov(i)": "!=null",
            "i->__iov": "!=null"
        }
    },
    "kretprobe:iov_iter_is_bvec": {
        "description": "Check if the iov_iter is of type bvec.",
        "pre": {
            "i": "!=null"
        }
    }
},
{
    "kprobe:iov_iter_iovec_advance": {
        "description": "Advance the iov_iter by the specified size when using bvec.",
        "pre": {
            "i": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:iov_iter_is_bvec": {
        "description": "Check if the iov_iter is using bvec.",
        "pre": {
            "i": "!=null"
        }
    }
},


{
    "kretprobe:iov_iter_xarray": {
        "description": "Initialise an IO iterator to use the pages in an xarray",
        "pre": {
            "i": "!=null",
            "direction": "!=null",
            "xarray": "!=null",
            "start": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:iov_iter_xarray": {
        "description": "Initialise an IO iterator to use the pages in an xarray",
        "pre": {
            "i": "!=null",
            "direction": "!=null",
            "xarray": "!=null",
            "start": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data",
        "pre": {
            "i": "!=null",
            "direction": "in [READ]",
            "count": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data",
        "pre": {
            "i": "!=null",
            "direction": "in [READ]",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_alignment": {
        "description": "Calculate the alignment value for the given iov_iter.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_ubuf(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_iovec": {
        "description": "Calculate the alignment value for the given iov_iter using iovec.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_iovec(i) || iov_iter_is_kvec(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_bvec": {
        "description": "Calculate the alignment value for the given iov_iter using bvec.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iov_iter_is_bvec(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_xarray": {
        "description": "Calculate the alignment value for the given iov_iter using xarray.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iov_iter_is_xarray(i)": "==true"
        }
    }
},
{
    "kprobe:iov_iter_alignment": {
        "description": "Calculate the alignment value for the given iov_iter.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_ubuf(i)": "==true",
            "i->ubuf": "!=null"
        }
    }
},
{
    "kretprobe:iov_iter_npages": {
        "description": "Calculate the number of pages in the iov_iter.",
        "pre": {
            "i": "!=null",
            "maxpages": "!=null",
            "i->count": "!=0",
            "iter_is_ubuf(i)": "==true",
            "offset_in_page(i->ubuf + i->iov_offset)": ">=0",
            "DIV_ROUND_UP(offs + i->count, PAGE_SIZE)": ">=0",
            "min(npage maxpages)": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_npages": {
        "description": "Calculate the number of pages in the iov_iter.",
        "pre": {
            "i": "!=null",
            "maxpages": "!=null",
            "i->count": "!=0",
            "iter_is_ubuf(i)": "==true",
            "offset_in_page(i->ubuf + i->iov_offset)": ">=0",
            "npages": ">=min(0, maxpages)"
        }
    }
},
{
    "kretprobe:return_new_kmemdup": {
        "description": "Allocate memory for new->__iov using kmemdup and return NULL.",
        "pre": {
            "new->__iov": "!=null",
            "new->nr_segs": ">0",
            "sizeof(struct iovec)": ">0",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:dup_iter": {
        "description": "Duplicating an iov_iter structure.",
        "pre": {
            "new": "!=null",
            "new->__iov": "!=null",
            "new->nr_segs": ">0",
            "flags": "!=null"
        }
    }
},
{
    "for (seg = 0; seg < nr_segs; seg++)": {
        "description": "Loop over segments",
        "pre": {
            "type": "any",
            "uvec": "!=null",
            "iovp": "!=null",
            "i": "any",
            "compat": "any"
        },
        "post": {
            "return_value": "any"
        }
    }
},
{
    "for (seg = 0; seg < nr_segs; seg++)": {
        "pre": {
            "nr_segs": ">0",
            "seg": "int",
            "seg_init": "0",
            "seg_increment": "1",
            "loop_condition": "seg < nr_segs"
        }
    }
},
{
    "kretprobe:BUG_ON": {
        "description": "Check if count is greater than num_queued - dql->num_completed",
        "pre": {
            "count": "> num_queued - dql->num_completed"
        }
    },
    "kretprobe:dql_completed": {
        "description": "Update various variables in dql_completed function",
        "pre": {
            "inprogress": "num_queued - completed",
            "prev_inprogress": "dql->prev_num_queued - dql->num_completed",
            "limit": "dql->limit",
            "ovlimit": "POSDIFF(num_queued - dql->num_completed, limit)",
            "completed": "dql->num_completed + count",
            "all_prev_completed": "AFTER_EQ(completed, dql->prev_num_queued)",
            "ovlimit && !inprogress || dql->prev_ovlimit && all_prev_completed": "true"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if count is greater than num_queued - dql->num_completed",
        "pre": {
            "count": "> num_queued - dql->num_completed"
        }
    },
    "kprobe:dql_completed": {
        "description": "Perform various calculations and checks",
        "pre": {
            "completed": "= dql->num_completed + count",
            "limit": "= dql->limit",
            "ovlimit": "= POSDIFF(num_queued - dql->num_completed, limit)",
            "inprogress": "= num_queued - completed",
            "prev_inprogress": "= dql->prev_num_queued - dql->num_completed",
            "all_prev_completed": "= AFTER_EQ(completed, dql->prev_num_queued)",
            "ovlimit_and_no_inprogress": "= (ovlimit && !inprogress)",
            "prev_ovlimit_and_all_prev_completed": "= (dql->prev_ovlimit && all_prev_completed)"
        }
    }
},
{
    "kretprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "pre": {
            "dql->limit": "= 0",
            "dql->num_queued": "= 0",
            "dql->num_completed": "= 0",
            "dql->last_obj_cnt": "= 0",
            "dql->prev_num_queued": "= 0",
            "dql->prev_last_obj_cnt": "= 0",
            "dql->prev_ovlimit": "= 0",
            "dql->lowest_slack": "= UINT_MAX",
            "dql->slack_start_time": "= jiffies"
        }
    }
},
{
    "kprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "pre": {
            "dql->limit": "= 0",
            "dql->num_queued": "= 0",
            "dql->num_completed": "= 0",
            "dql->last_obj_cnt": "= 0",
            "dql->prev_num_queued": "= 0",
            "dql->prev_last_obj_cnt": "= 0",
            "dql->prev_ovlimit": "= 0",
            "dql->lowest_slack": "= UINT_MAX",
            "dql->slack_start_time": "= jiffies"
        }
    }
},
{
    "kretprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap",
        "pre": {
            "n": ">=0",
            "mask": "!=null",
            "start": ">=0",
            "wrap": "bool"
        },
        "post": {
            "return": ">= nr_cpu_ids"
        }
    }
},
{
    "kprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap",
        "pre": {
            "n": ">= 0",
            "mask": "!= null",
            "start": ">= 0",
            "wrap": "boolean"
        },
        "post": {
            "return": ">= nr_cpu_ids"
        }
    }
},
{
    "kretprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node",
        "pre": {
            "mask": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",  // Please provide the complete list of GFP_ flags
            "node": "in [NUMA_NO_NODE, ...]"  // Please provide the complete list of memory nodes
        },
        "post": {
            "return": "in [TRUE, FALSE]",
            "mask": "null if return == FALSE"
        }
    }
},
{
    "kprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node",
        "pre": {
            "mask": "!=null",
            "flags": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask.",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask.",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_local_spread": {
        "description": "Select the i'th CPU based on NUMA distances",
        "pre": {
            "i": ">= 0",
            "node": ">= 0"
        }
    }
},
{
    "kprobe:cpumask_local_spread": {
        "description": "Select the i'th cpu based on NUMA distances",
        "pre": {
            "i": ">= 0",
            "node": ">= 0"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kretprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p.",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        },
        "post": {
            "return_value": ">= nr_cpu_ids"
        }
    }
},
{
    "kprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p.",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_any_distribute": {
        "description": "Find the next bit set in the cpumask after the previous position and update the distribute_cpu_mask_prev with the new value.",
        "pre": {
            "srcp": "!=null",
            "next": ">=0",
            "prev": ">=0",
            "distribute_cpu_mask_prev": "!=null",
            "nr_cpumask_bits": ">=0",
            "nr_cpu_ids": ">=0"
        }
    }
},
{
    "kprobe:cpumask_any_distribute": {
        "description": "Selects the next CPU from the given CPU mask for distribution.",
        "pre": {
            "__this_cpu_read(distribute_cpu_mask_prev)": "!=null",
            "find_next_bit_wrap(cpumask_bits(srcp), nr_cpumask_bit prev + 1)": "!=null",
            "next < nr_cpu_ids": "true",
            "__this_cpu_write(distribute_cpu_mask_prev, next)": "true"
        }
    }
},
{
    "kretprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR",
        "pre": {
            "dev": "!=null",
            "bar": ">=0",
            "offset": ">=0",
            "maxlen": ">=0"
        }
    }
},
{
    "kprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR",
        "pre": {
            "dev": "!=null",
            "bar": "!=null",
            "offset": "!=null",
            "maxlen": ">=0"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmap I/O or memory space for a PCI device.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmap I/O memory previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_raw": {
        "description": "Retrieve the raw object associated with the objagg_obj.",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_raw": {
        "description": "Get the raw object pointer from the objagg_obj structure.",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:if (!objagg->hints)": {
        "description": "Check if `objagg->hints` is not null.",
        "pre": {
            "objagg": {
                "hints": "==null"
            }
        }
    }
},
{
    "kprobe:if (!objagg->hints)": {
        "description": "Check if the `objagg` structure does not have any hints.",
        "pre": {
            "objagg": {
                "hints": "==null"
            }
        }
    }
},
{
    "kretprobe:objagg_create": {
        "description": "Creates a new objagg instance",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "any",
            "priv": "any"
        }
    }
},
{
    "kprobe:objagg_create": {
        "description": "Creates a new objagg instance",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "null or !=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance.",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kretprobe:objagg_hints_get": {
        "description": "Obtains hints instance",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "in [OBJAGG_OPT_ALGO_TYPE_1, OBJAGG_OPT_ALGO_TYPE_2, OBJAGG_OPT_ALGO_TYPE_3]"
        }
    }
},
{
    "kprobe:objagg_hints_get": {
        "description": "Obtains hints instance",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "in [OBJAGG_OPT_ALGO_TYPE_1, OBJAGG_OPT_ALGO_TYPE_2, OBJAGG_OPT_ALGO_TYPE_3]"
        }
    }
},
{
    "kretprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance",
        "pre": {
            "objagg_hints": "!=null"
        }
    }
},
{
    "kprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance",
        "pre": {
            "objagg_hints": "!=null"
        }
    }
},




{
    "kretprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1.",
        "pre": {
            "r": "!=null",
            "*r": "!=null",
            "*r != 1": true
        }
    }
},
{
    "kprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1",
        "pre": {
            "r": "!=null",
            "*r": "!=null",
            "*r != 1": true
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:refcount_dec_and_mutex_lock": {
        "description": "Return holding mutex if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_and_mutex_lock": {
        "description": "Return holding mutex if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_and_lock": {
        "description": "Return holding spinlock if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_and_lock": {
        "description": "Return holding spinlock if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:parman_create": {
        "description": "creates a new parman instance",
        "pre": {
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:parman_create": {
        "description": "creates a new parman instance",
        "pre": {
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:parman_destroy": {
        "description": "Destroys an existing parman instance.",
        "pre": {
            "parman": "!=null"
        }
    }
},

{
    "kretprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": ">=0"
        }
    }
},
{
    "kprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": ">=0"
        }
    }
},


{
    "kretprobe:parman_item_add": {
        "description": "Adds a parman item under defined priority",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:parman_item_add": {
        "description": "Adds a parman item under defined priority.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:parman_item_remove": {
        "description": "Deletes a parman item",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:parman_item_remove": {
        "description": "Deletes a parman item",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:packing": {
        "description": "Convert numbers between a packed and an unpacked format.",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">=0",
            "endbit": "<=startbit",
            "pbuflen": ">=0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        }
    }
},
{
    "kprobe:packing": {
        "description": "Convert numbers (currently u64) between a packed and an unpacked format.",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">=0",
            "endbit": "<=startbit",
            "pbuflen": ">0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        }
    }
},
{
    "kretprobe:ucs2_strncmp": {
        "description": "Compares two UCS2 strings up to a specified length.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": "!=null"
        },
        "post": {
            "return": "in [-1, 0, 1]",
            "a": "==0 implies b==0"
        }
    }
},
{
    "kprobe:ucs2_strncmp": {
        "description": "Compare two UCS2 strings up to a specified length.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:crc32c": {
        "description": "Calculate the CRC32C checksum.",
        "pre": {
            "crc": "!=null",
            "address": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kprobe:crc32c": {
        "description": "Calculate the CRC32C checksum.",
        "pre": {
            "crc": "!=null",
            "address": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their clas as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-type enforce relative levels by bitpos.",
        "pre": {
            "instr": "!=null",
            "kp": {
                "arg": {
                    "bitslvl": "!=null",
                    "map": "!=null",
                    "map_type": "!=null"
                }
            }
        },
        "post": {
            "return_value": "in [0, <0]"
        }
    }
},
{
    "kprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their clas as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-type enforce relative levels by bitpos.",
        "pre": {
            "instr": "!=null",
            "kp": {
                "arg": {
                    "bitslvl": "!=null",
                    "map": "!=null",
                    "map_type": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:param_get_dyndbg_classes": {
        "description": "classes reader",
        "pre": {
            "buffer": "!=null",
            "kp": "!=null",
            "kp->arg->state": "!=null",
            "kp->arg->state->bits": "!=null",
            "kp->arg->state->map": "!=null"
        }
    }
},
{
    "kprobe:param_get_dyndbg_classes": {
        "description": "classes reader",
        "pre": {
            "buffer": "!=null",
            "kp": {
                "arg": {
                    "state": "!=null",
                    "bits": "!=null",
                    "map": "!=null"
                }
            }
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range into kernel virtual memory.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},



{
    "kretprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": ">=0",
            "end": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": ">=0",
            "end": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kretprobe:idr_for_each": {
        "description": "Iterate through all stored pointers in the IDR.",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:idr_for_each": {
        "description": "Iterate through all stored pointers.",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:idr_get_next_ul": {
        "description": "Find next populated entry.",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null",
            "*nextid": ">=0"
        }
    }
},
{
    "kprobe:idr_get_next_ul": {
        "description": "Find next populated entry.",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null",
            "*nextid": ">=0"
        }
    }
},
{
    "kretprobe:idr_replace": {
        "description": "Replace pointer for given ID.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:idr_replace": {
        "description": "Replace pointer for given ID.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": "!=null"
        }
    }
},


{
    "kretprobe:lockref_get": {
        "description": "Increments reference count unconditionally",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_get": {
        "description": "Increments reference count unconditionally",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement",
        "pre": {
            "lockref": "!=null",
            "count": ">1"
        }
    }
},
{
    "kretprobe:lockref_put_return": {
        "description": "Decrement reference count if possible",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_put_return": {
        "description": "Decrement reference count if possible",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement.",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "count": "<=1",
            "lock": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement.",
        "pre": {
            "lockref": "!=null",
            "count": ">1"
        }
    }
},
{
    "kretprobe:lockref_mark_dead": {
        "description": "mark lockref dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_mark_dead": {
        "description": "Mark lockref dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},


{
    "kretprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "pre": {
            "table": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "pre": {
            "table": "!=null",
            "polynomial": "!=null"
        }
    }
},


{
    "kretprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject.",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject.",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kretprobe:kobject_add_internal": {
        "description": "Add a kobject internally.",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "!=null"
        }
    }
},
{
    "kprobe:if (kobj->kset)": {
        "description": "Check if the kobj has a kset.",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "!=null"
        }
    }
},
{
    "kretprobe:kobject_del": {
        "description": "Remove a kobject",
        "pre": {
            "kobj->state_add_uevent_sent": "==true",
            "kobj->state_remove_uevent_sent": "==false"
        }
    }
},
{
    "kprobe:kobject_del": {
        "description": "Delete a kernel object and send a 'remove' event if the caller did not do it but sent 'add'.",
        "pre": {
            "kobj->state_add_uevent_sent": "!=0",
            "!kobj->state_remove_uevent_sent": "!=0"
        }
    }
},
{
    "kretprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj.",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj.",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},


{
    "kretprobe:kset_register": {
        "description": "Initialize and add a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_register": {
        "description": "Initialize and add a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:kset_unregister": {
        "description": "Remove a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_unregister": {
        "description": "Remove a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value",
        "pre": {
            "ch": "!=null",
            "ch": "is_hex_digit"
        },
        "post": {
            "return": "in [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
        }
    }
},
{
    "kprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value",
        "pre": {
            "ch": "in [0x30 ... 0x39, 0x41 ... 0x46, 0x61 ... 0x66]"
        }
    }
},
{
    "kretprobe:hex2bin": {
        "description": "Convert an ASCII hexadecimal string to its binary representation.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:hex2bin": {
        "description": "Convert an ASCII hexadecimal string to its binary representation.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:bin2hex": {
        "description": "Convert binary data to an ASCII hexadecimal string.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:bin2hex": {
        "description": "Convert binary data to an ASCII hexadecimal string.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kretprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [DUMP_PREFIX_OFFSET, DUMP_PREFIX_ADDRES DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [DUMP_PREFIX_OFFSET, DUMP_PREFIX_ADDRES DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "boolean"
        }
    }
},

{
    "kprobe:siphash_1u64": {
        "description": "Compute 64-bit siphash PRF value of a u64",
        "pre": {
            "first": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},


{
    "kretprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32.",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_register": {
        "description": "Register a textsearch module",
        "pre": {
            "ops": "!=null",
            "ops.name": "!=null",
            "ops.find": "!=null",
            "ops.init": "!=null",
            "ops.get_pattern": "!=null",
            "ops.get_pattern_len": "!=null"
        }
    }
},
{
    "kprobe:textsearch_register": {
        "description": "Register a textsearch module",
        "pre": {
            "ops": "!=null",
            "ops.name": "!=null",
            "ops.find": "!=null",
            "ops.init": "!=null",
            "ops.get_pattern": "!=null",
            "ops.get_pattern_len": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module",
        "pre": {
            "ops": "!=null"
        },
        "post": {
            "return_value": "in [0, -ENOENT]"
        }
    }
},
{
    "kprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module",
        "pre": {
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_destroy": {
        "description": "Notifies the algorithm to destroy algorithm-specific allocations.",
        "pre": {
            "conf": "!=null"
        }
    }
},

{
    "kretprobe:glob_match": {
        "description": "Shell-style pattern matching, like !fnmatch(pat, str, 0)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kprobe:glob_match": {
        "description": "Shell-style pattern matching, like !fnmatch(pat, str, 0)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "len": "!=null",
            "tab": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "len": "!=null",
            "tab": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kretprobe:gf2_multiply": {
        "description": "This multiplies the polynomials x and y modulo the given modulus.",
        "pre": {
            "x": "!=null",
            "y": "!=null",
            "modulus": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Perform IO operation with conditions.",
        "pre": {
            "addr": "!=null",
            "outb(val,port)": "!=null",
            "writeb(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite16": {
        "description": "Write 16-bit value to IO memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=0"
        }
    },
    "kprobe:IO_COND": {
        "description": "Perform IO operation conditionally.",
        "pre": {
            "addr": "!=null",
            "outb(val,port)": "!=null",
            "writeb(val, addr)": "!=null"
        }
    },
    "kprobe:iowrite16": {
        "description": "Write 16-bit value to IO address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite16be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "==u16",
            "addr_type": "==void __iomem *",
            "val_uninitialized": "==false"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check memory for uninitialized values.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "sizeof(u16)"
        }
    },
    "kprobe:IO_COND": {
        "description": "Perform IO operation conditionally.",
        "pre": {
            "addr": "!=null",
            "outw(val,port)": "initialized",
            "writew(val, addr)": "initialized"
        }
    },
    "kprobe:iowrite16be": {
        "description": "Write 16-bit value to IO memory.",
        "pre": {
            "val": "initialized",
            "addr": "!=null",
            "typeof(val)": "u16",
            "typeof(addr)": "void __iomem *"
        }
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Condition for IO operation.",
        "pre": {
            "addr": "!=null",
            "pio_write16be(val,port)": "!=null",
            "mmio_write16be(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite32": {
        "description": "Write 32-bit value to a memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "initialized",
            "addr": "used"
        }
    },
    "kretprobe:iowrite32be": {
        "description": "No specific conditions mentioned in the provided documentation."
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u32",
            "addr_type": "void __iomem *",
            "sizeof_val": ">0"
        }
    }
},


{
    "kretprobe:iowrite64_hi_lo": {
        "description": "Ensure uninitialized memory is not copied to devices using the iowrite64_lo_hi helper function.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "initialized"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Conditionally execute pio_write64_hi_lo(val, port) or writeq(val, addr).",
        "pre": {
            "condition": "placeholder"
        }
    },
    "kretprobe:iowrite64be_lo_hi": {
        "description": "",
        "pre": {
            "condition": "true"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:iowrite64_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:IO_COND": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "addr": "!=null",
            "val": "!=null",
            "port": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *",
            "port_type": "unknown"
        }
    },
    "kprobe:writeq": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:iowrite64be_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Perform IO conditional operation.",
        "pre": {
            "addr": "!=null",
            "pio_write64be_lo_hi(val, port)": "!=null",
            "mmio_write64be(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite64be_hi_lo": {
        "description": "Write 64-bit value to a memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null"
        }
    },
    "kprobe:pio_write64be_hi_lo": {
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null",
            "port": "!=null"
        }
    },
    "kprobe:mmio_write64be": {
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null"
        }
    },
    "EXPORT_SYMBOL:iowrite64_lo_hi": {},
    "EXPORT_SYMBOL:iowrite64_hi_lo": {},
    "EXPORT_SYMBOL:iowrite64be_lo_hi": {},
    "EXPORT_SYMBOL:iowrite64be_hi_lo": {}
},





{
    "kprobe:kmsan_unpoison_memory": {
        "description": "Unpoison the memory range specified by *dst* and *count*.",
        "pre": {
            "dst": "!=null",
            "count": "!=null",
            "count * 4": ">=0"
        }
    }
},




{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": "!=null",
            "addr": "is a valid memory address",
            "src": "is a valid memory address",
            "count": "is a positive integer"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "src": "!=null",
            "count": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(ioport_map)": {
        "description": "Maps an I/O port to a memory address.",
        "pre": {
            "port": "!=null",
            "nr": "!=null",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(ioport_map)": {
        "description": "Map an I/O port to a memory-mapped I/O pointer.",
        "pre": {
            "port": "!=null",
            "nr": "!=null",
            "return_value": "!=null"
        }
    }
},


{
    "kretprobe:pci_iounmap": {
        "description": "Unmap an I/O memory region previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmap an I/O memory region previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kprobe:unsafe_get_user": {
        "description": "Copy a string from user space to kernel space, ensuring NUL termination.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:xxh32_reset": {
        "description": "Reset the xxh32 state with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        },
        "post": {
            "statePtr": "contains valid xxh32_state data"
        }
    }
},
{
    "kprobe:xxh32_reset": {
        "description": "Reset the state of xxh32_state using the provided seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},
{
    "kretprobe:xxh64_reset": {
        "description": "Reset the xxh64_state structure with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},
{
    "kprobe:xxh64_reset": {
        "description": "Reset the xxh64_state structure with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},




{
    "kretprobe:memcpy": {
        "description": "Copy `len` bytes from `input` to `((uint8_t *)state->mem64) + state->memsize` and update `state->memsize`.",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": "!=null",
            "state->mem64": "!=null",
            "state->memsize": "!=null",
            "state->memsize + len < 32": "true"
        },
        "post": {
            "state->memsize": "state->memsize + len"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy `len` bytes from `input` to `state->mem64 + state->memsize`.",
        "pre": {
            "state": "!=null",
            "state->mem64": "!=null",
            "state->memsize": "!=null",
            "input": "!=null",
            "len": "!=null",
            "len": ">0"
        }
    }
},
{
    "kretprobe:memweight": {
        "description": "Count the total number of bits set in memory area",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:memweight": {
        "description": "Count the total number of bits set in memory area.",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "pre": {
            "node": "!=null",
            "tag": "unsigned int"
        }
    }
},
{
    "kprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "pre": {
            "node": "!=null",
            "tag": ">=0"
        }
    }
},
{
    "kretprobe:radix_tree_maybe_preload": {
        "description": "Preload radix tree if gfp_mask allows blocking.",
        "pre": {
            "gfp_mask": "!=null",
            "gfp_mask": "in [gfpflags_allow_blocking(gfp_mask)]",
            "return_value": "==0"
        }
    }
},
{
    "kprobe:radix_tree_maybe_preload": {
        "description": "Preload radix tree if `gfp_mask` allows blocking, otherwise skip preloading.",
        "pre": {
            "gfp_mask": "!=null",
            "gfpflags_allow_blocking(gfp_mask)": "true",
            "__radix_tree_preload(gfp_mask, RADIX_TREE_PRELOAD_SIZE)": "!=null",
            "return value": "0"
        }
    }
},
{
    "kretprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_lookup_slot": {
        "description": "Look up a slot in a radix tree based on the given index.",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:radix_tree_lookup_slot": {
        "description": "Look up a slot in the radix tree based on the given index.",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "nodep": "!=null",
            "slotp": "!=null"
        }
    }
},
{
    "kprobe:__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "nodep": "!=null",
            "slotp": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tag_set": {
        "description": "Set a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "in [0, RADIX_TREE_MAX_TAGS)"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tag_set": {
        "description": "Set a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "in [0, RADIX_TREE_MAX_TAGS)"
        }
    }
},
{
    "kretprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:radix_tree_next_chunk": {
        "description": "Find next chunk of slots for iteration",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "in [RADIX_TREE_ITER_]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_next_chunk": {
        "description": "Find the next chunk of slots for iteration.",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_replace_slot": {
        "description": "Replace a slot in a radix tree with a new item.",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        },
        "post": {
            "root": "unchanged",
            "slot": "unchanged",
            "item": "changed"
        }
    }
},
{
    "kprobe:radix_tree_replace_slot": {
        "description": "Replace the slot in the radix tree.",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        },
        "post": {
            "success": true
        }
    }
},
{
    "kretprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at this iterator position",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at this iterator position.",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_delete_item": {
        "description": "Delete an item from a radix tree",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_delete_item": {
        "description": "Delete an item from a radix tree",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "pre": {
            "root": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "pre": {
            "root": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:idr_preload": {
        "description": "Preload for idr_alloc()",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:idr_preload": {
        "description": "Preload for idr_alloc().",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR",
        "pre": {
            "idr": "!=null"
        }
    }
},
{
    "kprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR",
        "pre": {
            "idr": "!=null"
        }
    }
},


{
    "kretprobe:argv_free": {
        "description": "Free an argv and the strings it points to.",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kprobe:argv_free": {
        "description": "Free an argv",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kretprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv",
        "pre": {
            "gfp": "!=null",
            "str": "!=null",
            "argcp": "!=null"
        }
    }
},
{
    "kprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv",
        "pre": {
            "gfp": "!=null",
            "str": "!=null",
            "argcp": "!=null"
        }
    }
},
{
    "kretprobe:xa_load": {
        "description": "Load an entry from an XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:xa_load": {
        "description": "Load an entry from an XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:__xa_store": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_store": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "old": "!=null",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // Add more possible values for gfp_t if needed
        }
    }
},
{
    "kprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "old": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENOMEM]"
        }
    }
},
{
    "kprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray.",
        "pre": {
            "xa": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray.",
        "pre": {
            "xa": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:xa_get_order": {
        "description": "Get the order of an entry.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "index": "<=63"
        }
    }
},
{
    "kprobe:xa_get_order": {
        "description": "Get the order of an entry.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "index": "<=63"
        }
    }
},
{
    "kretprobe:__xa_alloc": {
        "description": "__xa_alloc() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_alloc": {
        "description": "__xa_alloc() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_alloc_cyclic": {
        "description": "Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "next": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_alloc_cyclic": {
        "description": "__xa_alloc_cyclic() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "next": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:xa_find": {
        "description": "Search the XArray for an entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kprobe:xa_find": {
        "description": "Search the XArray for an entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kretprobe:xa_find_after": {
        "description": "Search the XArray for a present entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kprobe:xa_find_after": {
        "description": "Search the XArray for a present entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": "!=null",
            "filter": "!=null"
        }
    }
},
{
    "kretprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array.",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=0",
            "n": ">=0",
            "filter": ">=0"
        }
    }
},
{
    "kprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array.",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=start",
            "n": ">=0",
            "filter": "in [XA_PRESENT, xa_mark_t]"
        }
    }
},
{
    "kretprobe:xa_destroy": {
        "description": "Free all internal data structures.",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kprobe:xa_destroy": {
        "description": "Free all internal data structures.",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kretprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes.",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes.",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again",
        "pre": {
            "iop": "!=null",
            "interrupts_disabled": "true"
        }
    }
},
{
    "kprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again",
        "pre": {
            "iop": "!=null",
            "interrupts_disabled": "true"
        }
    }
},
{
    "kretprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "pre": {
            "iop": "!=null",
            "weight": "!=null",
            "poll_fn": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "pre": {
            "iop": "!=null",
            "weight": ">=0",
            "poll_fn": "!=null"
        }
    }
},


{
    "kretprobe:memparse": {
        "description": "Parse a string with mem suffixes into a number",
        "pre": {
            "ptr": "!=null",
            "retptr": "!=null"
        }
    }
},
{
    "kprobe:memparse": {
        "description": "Parse a string with mem suffixes into a number",
        "pre": {
            "ptr": "!=null",
            "retptr": "!=null"
        }
    }
},
{
    "kretprobe:if (**val == '\"')": {
        "description": "Check if the value pointed to by val is equal to '\"'.",
        "pre": {
            "val": "== '\"'"
        }
    }
},
{
    "kprobe:if (**val == '\"')": {
        "description": "Check if the value pointed to by val is equal to '\"'.",
        "pre": {
            "val": "== '\"'"
        }
    }
},
{
    "kretprobe:generate_random_uuid": {
        "description": "Generate a random UUID",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kprobe:generate_random_uuid": {
        "description": "Generate a random UUID",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:generate_random_guid": {
        "description": "Set GUID version to 4 - truly random generation",
        "pre": {
            "guid": "!=null"
        }
    }
},
{
    "kprobe:generate_random_guid": {
        "description": "Set GUID version to 4 - truly random generation",
        "pre": {
            "guid": "!=null"
        }
    }
},
{
    "kretprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid",
        "pre": {
            "uuid": "!=null",
            "uuid_format": "matches regex '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'"
        },
        "post": {
            "return_value": "==true"
        }
    }
},
{
    "kprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid",
        "pre": {
            "uuid": "!=null",
            "uuid_format": "matches regex: ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list.",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list.",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:sg_nents_for_len": {
        "description": "Return total count of entries in scatterlist needed to satisfy the supplied length.",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:sg_nents_for_len": {
        "description": "Return total count of entries in scatterlist needed to satisfy the supplied length.",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list",
        "pre": {
            "sgl": "!=null",
            "nents": "!=null"
        }
    }
},
{
    "kretprobe:sg_init_table": {
        "description": "Initialize SG table",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kprobe:sg_init_table": {
        "description": "Initialize SG table",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kretprobe:sg_init_one": {
        "description": "Initialize a single entry sg list",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_init_one": {
        "description": "Initialize a single entry sg list",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},

{
    "kprobe:__sg_free_table": {
        "description": "Free the scatterlist table and associated resources.",
        "pre": {
            "table": "!=null",
            "max_ents": "!=null",
            "nents_first_chunk": "!=null",
            "free_fn": "!=null",
            "num_ents": "!=null",
            "max_ents": "== previously used value with __sg_alloc_table()"
        }
    }
},
{
    "kretprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kretprobe:sg_kmalloc": {
        "description": "Allocate memory for scatterlist entries.",
        "pre": {
            "nents": ">= 0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},

{
    "kretprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "left_pages": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "left_pages": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": ">=1",
            "order": ">=0",
            "chainable": "in [true, false]",
            "gfp": "not null",
            "nent_p": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": ">=1",
            "order": ">=0",
            "chainable": "bool",
            "gfp": "valid memory allocation flags",
            "nent_p": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kretprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": "!=null",
            "gfp": "!=null",
            "nent_p": "!=null"
        }
    }
},
{
    "kprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": "!=null",
            "gfp": "!=null",
            "nent_p": "!=null"
        }
    }
},
{
    "kretprobe:sg_miter_start": {
        "description": "Start mapping iteration over a sg list",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:sg_miter_start": {
        "description": "Start mapping iteration over a sg list",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:sg_miter_skip": {
        "description": "This function stops the sg_mapping_iter at the specified offset.",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:sg_miter_skip": {
        "description": "Stops the sg_mapping_iter and checks if it contains a valid mapping.",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping.",
        "pre": {
            "miter": "!=null",
            "miter->page": "!=null",
            "miter->addr": "!=null",
            "miter->length": "!=null"
        }
    }
},
{
    "kprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping.",
        "pre": {
            "miter": "!=null",
            "miter->page": "!=null",
            "miter->addr": "!=null",
            "miter->length": "!=null"
        }
    }
},
{
    "kretprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:stmp_clear_poll_bit": {
        "description": "Clear and poll the SFTRST bit in the reset address.",
        "pre": {
            "reset_addr": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:stmp_clear_poll_bit": {
        "description": "Clear and poll the SFTRST bit in the reset address.",
        "pre": {
            "reset_addr": "!=null"
        }
    }
},
{
    "kretprobe:stack_depot_set_extra_bits": {
        "description": "Set extra bits on a stack depot handle.",
        "pre": {
            "handle": "!=null",
            "extra_bits": "unsigned int"
        }
    }
},
{
    "kprobe:stack_depot_set_extra_bits": {
        "description": "Set extra bits for stack depot handle",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:mtee_store_range": {
        "description": "Store an entry at a given range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:mtee_store_range": {
        "description": "Store an entry at a given range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtee_insert_range": {
        "description": "Insert an entry at a given range if there is no value.",
        "pre": {
            "mt": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null",
            "mt": "is struct maple_tree",
            "first": "is unsigned long",
            "last": "is unsigned long",
            "entry": "is void*",
            "gfp": "is gfp_t"
        },
        "post": {
            "return": "in [0, -EEXIST -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:mtee_insert_range": {
        "description": "Insert an entry at a given range if there is no value.",
        "pre": {
            "mt": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_alloc_range": {
        "description": "Allocate a range in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mtree_alloc_range": {
        "description": "Allocate a range in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_alloc_rrange": {
        "description": "Allocate a range of memory in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mtree_alloc_rrange": {
        "description": "Allocate a range of memory in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_erase": {
        "description": "Find an index and erase the entire range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:mtree_erase": {
        "description": "Find an index and erase the entire range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:mtree_destroy": {
        "description": "Destroy a maple tree",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kprobe:mtree_destroy": {
        "description": "Destroy a maple tree",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kretprobe:mt_find": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:mt_find": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:errseq_set": {
        "description": "Set an errseq_t for later reporting.",
        "pre": {
            "eseq": "!=null",
            "err": ">= -1",
            "err": "<= -MAX_ERRNO"
        },
        "post": {
            "return": ">= -MAX_ERRNO",
            "return": "<= -1"
        }
    }
},
{
    "kprobe:errseq_set": {
        "description": "Set a errseq_t for later reporting",
        "pre": {
            "eseq": "!=null",
            "err": ">= -1",
            "err": "<= -MAX_ERRNO"
        }
    }
},
{
    "kretprobe:errseq_sample": {
        "description": "Grab current errseq_t value.",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kprobe:errseq_sample": {
        "description": "Grab current errseq_t value.",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kretprobe:errseq_check": {
        "description": "Has an error occurred since a particular sample point?",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [0, !=since]"
        }
    }
},
{
    "kprobe:errseq_check": {
        "description": "Has an error occurred since a particular sample point?",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value.",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value.",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        }
    }
},
{
    "kretprobe:lc_create": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on succes or NULL on (allocation) failure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">=0",
            "e_off": ">=0"
        }
    }
},
{
    "kprobe:lc_create": {
        "description": "Creates a new lru_cache structure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">=0",
            "e_off": ">=0"
        }
    }
},
{
    "kretprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots.",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots.",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create()",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create().",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_del": {
        "description": "Removes an element from the cache",
        "pre": {
            "lc": "!=null",
            "e": "!=null",
            "e.refcnt": "==0",
            "e.lru": "!=null",
            "e.free": "!=null",
            "e.enr": "==LC_FREE"
        }
    }
},
{
    "kprobe:lc_del": {
        "description": "Removes an element from the cache.",
        "pre": {
            "lc": "!=null",
            "e": "!=null",
            "e->refcnt": "==0",
            "e->enr": "==LC_FREE"
        }
    }
},
{
    "kretprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return": {
                "constraints": "in [null, not in active set, pointer to element with requested element number]",
                "description": "The return value can be null if the cache is marked as LC_STARVING, or if the requested label is not in the active set. Otherwise, it should be a pointer to the element with the requested element number."
            }
        }
    }
},
{
    "kprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return": "in [null, !=null]"
        }
    }
},
{
    "kretprobe:lc_find": {
        "description": "Find element by label, if present in the hash table.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null",
            "include_changing": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:lc_find": {
        "description": "Find element by label, if present in the hash table.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null",
            "include_changing": "!=null"
        }
    }
},
{
    "kretprobe:seq_printf": {
        "description": "Print formatted output to a sequence file.",
        "pre": {
            "seq": "!=null",
            "lc": "!=null",
            "lc->name": "!=null",
            "lc->used": "!=null",
            "lc->nr_elements": "!=null",
            "lc->hits": "!=null",
            "lc->misses": "!=null",
            "lc->starving": "!=null",
            "lc->locked": "!=null",
            "lc->changed": "!=null"
        }
    }
},
{
    "kprobe:seq_printf": {
        "description": "Prints formatted output to a sequence file.",
        "pre": {
            "seq": "!=null",
            "lc": {
                "name": "!=null",
                "used": ">=0",
                "nr_elements": ">=0",
                "hits": ">=0",
                "misses": ">=0",
                "starving": ">=0",
                "locked": ">=0",
                "changed": ">=0"
            },
            "enr": ">=0"
        }
    }
},
{
    "kretprobe:lc_put": {
        "description": "Give up refcnt of @e",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        }
    }
},
{
    "kprobe:lc_put": {
        "description": "Give up refcnt of @e",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        }
    }
},


{
    "kretprobe:lc_element_by_index": {
        "description": "Return the element at the specified index in the LRU cache.",
        "pre": {
            "lc": "!=null",
            "i": ">=0"
        }
    }
},
{
    "kprobe:lc_element_by_index": {
        "description": "Return the element at the specified index in the lru cache.",
        "pre": {
            "lc": "!=null",
            "i": ">=0"
        }
    }
},
{
    "kretprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "pre": {
            "lc": "!=null"
        },
        "post": {
            "val": "==0"
        }
    }
},
{
    "kprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "pre": {
            "lc": "!=null"
        }
    },
    "kprobe:return 0 == val;}/** * lc_create - prepares to track objects in an active set * @name: descriptive name only used in lc_seq_printf_stats and lc_seq_dump_details * @cache: cache root pointer * @max_pending_changes: maximum changes to accumulate until a transaction is required * @e_count: number of elements allowed to be active simultaneously * @e_size: size of the tracked objects * @e_off: offset to the &struct lc_element member in a tracked object * * Returns a pointer to a newly initialized struct lru_cache on succes * or NULL on (allocation) failure.": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on succes or NULL on (allocation) failure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": "!=null",
            "e_count": "!=null",
            "e_size": "!=null",
            "e_off": "!=null"
        }
    }
},
{
    "kretprobe:lc_is_used": {
        "description": "Find element by label",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kprobe:lc_is_used": {
        "description": "Find element by label",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kretprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return_value": "!=null",
            "to_be_changed_element": "!=null"
        }
    }
},
{
    "kprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kretprobe:__acquire(once_lock);return false;}return true;}EXPORT_SYMBOL(__do_once_start": {
        "description": "__do_once_start function with __acquire(once_lock) helper",
        "pre": {
            "done": "==false",
            "flags": ">=0",
            "once_lock": "!=null"
        }
    }
},
{
    "kprobe:__acquire(once_lock);return false;}return true;}EXPORT_SYMBOL(__do_once_start": {
        "description": "__do_once_start function with acquire once_lock",
        "pre": {
            "done": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:__do_once_done": {
        "description": "__do_once_done but return early in the DO_ONCE() macro.",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null",
            "once_lock": "!=null"
        },
        "post": {
            "return": "in [false, true]"
        }
    }
},
{
    "kprobe:__do_once_done": {
        "description": "Return early in the DO_ONCE() macro.",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null",
            "once_lock": "!=null"
        }
    }
},
{
    "kretprobe:__do_once_sleepable_start": {
        "description": "__do_once_sleepable_start function",
        "pre": {
            "__acquire(once_mutex)": "true",
            "return": "false"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:__acquire(once_mutex);return false;}return true;}EXPORT_SYMBOL(__do_once_sleepable_start": {
        "description": "This function acquires the once_mutex and returns false. If the 'done' parameter is true, it unlocks the once_mutex and restores an even lock count. If the 'done' parameter is false, it returns true.",
        "pre": {
            "once_mutex": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_create": {
        "description": "Create a new special memory pool",
        "pre": {
            "min_alloc_order": "!=null",
            "nid": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_create": {
        "description": "Create a new special memory pool",
        "pre": {
            "min_alloc_order": "!=null",
            "nid": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the specified pool.",
        "pre": {
            "pool": "!=null",
            "virt": "!=null",
            "phys": "!=null",
            "size": "!=null",
            "nid": "int",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the specified pool.",
        "pre": {
            "pool": "!=null",
            "virt": "!=null",
            "phys": "!=null",
            "size": "!=null",
            "nid": "int",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_virt_to_phys": {
        "description": "Return the physical address of memory",
        "pre": {
            "pool": "!=null",
            "addr": "!=null"
        },
        "post": {
            "return": ">=0 || ==-1"
        }
    }
},
{
    "kprobe:gen_pool_virt_to_phys": {
        "description": "Return the physical address of memory.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_destroy": {
        "description": "destroy a special memory pool",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_destroy": {
        "description": "Destroy the specified special memory pool. Verifies that there are no outstanding allocations.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate special memory from the pool",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "algo": "!=null",
            "data": "!=null",
            "owner": "optional"
        }
    }
},
{
    "kprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate special memory from the pool",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "algo": "!=null",
            "data": "!=null",
            "owner": "optional"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate special memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "align": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate special memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "align": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc": {
        "description": "Allocate special zeroed memory from the pool for DMA usage.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc": {
        "description": "Allocate special zeroed memory from the pool for DMA usage.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "align": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "align": ">=0"
        }
    }
},
{
    "kretprobe:gen_pool_free_owner": {
        "description": "Free allocated special memory back to the pool.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_free_owner": {
        "description": "Free allocated special memory back to the pool.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_for_each_chunk": {
        "description": "Call func for every chunk of generic memory pool",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_for_each_chunk": {
        "description": "Call func for every chunk of generic memory pool.",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_has_addr": {
        "description": "Checks if an address falls within the range of a pool",
        "pre": {
            "pool": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_has_addr": {
        "description": "Checks if an address falls within the range of a pool.",
        "pre": {
            "pool": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm for the pool.",
        "pre": {
            "pool": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm for the pool.",
        "pre": {
            "pool": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "!=null",
            "pool": "!=null",
            "start_addr": "not used in this function"
        }
    }
},
{
    "kprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "!=null",
            "pool": "!=null",
            "start_addr": "not used in this function"
        }
    }
},
{
    "kretprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kretprobe:gen_pool_best_fit": {
        "description": "Find the best fitting region of memory matching the size requirement (no alignment constraint).",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kprobe:gen_pool_best_fit": {
        "description": "Find the best fitting region of memory matching the size requirement (no alignment constraint).",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kretprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmalloc/free interface. The pool will be automatically destroyed by the device management code.",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmalloc/free interface. The pool will be automatically destroyed by the device management code.",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:match_token": {
        "description": "Find a token (and optional args) in a string",
        "pre": {
            "s": "!=null",
            "table": "!=null",
            "args": "!=null",
            "table.pattern": "!=null",
            "table.pattern[MAX_OPT_ARGS]": "!=null",
            "args[MAX_OPT_ARGS]": "!=null"
        }
    }
},
{
    "kprobe:match_token": {
        "description": "Find a token (and optional args) in a string",
        "pre": {
            "s": "!=null",
            "table": "!=null",
            "args": "!=null",
            "table.pattern": "==null",
            "table.pattern[MAX_OPT_ARGS]": "==null"
        }
    }
},
{
    "kretprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is_integer"
        }
    }
},
{
    "kprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "==0"
        }
    }
},
{
    "kprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_u64int": {
        "description": "scan a number in the given base from a substring_t",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "!=null"
        },
        "post": {
            "result": "=0 if successful, =-EINVAL or =-ERANGE on failure",
            "result": ">=INT_MIN",
            "result": "<=INT_MAX"
        }
    }
},
{
    "kprobe:match_u64int": {
        "description": "scan a number in the given base from a substring_t",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "in [2, 8, 10, 16]"
        }
    }
},
{
    "kretprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is an integer",
            "return": "in [0, -EINVAL, -ERANGE]"
        }
    }
},
{
    "kprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is an integer",
            "return": "in [0, -EINVAL, -ERANGE]"
        }
    }
},
{
    "kprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_wildcard": {
        "description": "Parse the string @str to check if it matches the wildcard pattern @pattern.",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:match_wildcard": {
        "description": "Parse the string @str to check if it matches the wildcard pattern @pattern.",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:match_strdup": {
        "description": "Allocate a new string with the contents of a substring_t",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:match_strdup": {
        "description": "Allocate a new string with the contents of a substring_t",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kretprobe:debug_percpu_counter_activate": {
        "description": "Activate the debug object for the percpu_counter",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:debug_percpu_counter_activate": {
        "description": "Activates the debug object for the percpu_counter.",
        "pre": {
            "fbc": "!=null"
        }
    }
},


{
    "kretprobe:size = roundup_pow_of_two(size);fifo->in = 0;fifo->out = 0;fifo->esize = esize;if (size < 2)": {
        "description": "Allocate memory for a FIFO buffer and initialize its properties.",
        "pre": {
            "fifo": "!=null",
            "size": "!=null",
            "esize": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:size = roundup_pow_of_two(size);fifo->in = 0;fifo->out = 0;fifo->esize = esize;if (size < 2)": {
        "description": "Allocate memory for a FIFO buffer and initialize its properties.",
        "pre": {
            "size": "!=null",
            "fifo->in": "= 0",
            "fifo->out": "= 0",
            "fifo->esize": "= esize",
            "size < 2": "true"
        }
    }
},
{
    "kretprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copy the string pointed to by `src` to `dest`.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "tmp": "!=null"
        }
    }
},
{
    "kprobe:strcpy": {
        "description": "Copy the string from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:unalign_check": {
        "description": "Check if the source address is unaligned",
        "pre": {
            "src": "!=null",
            "(long)src & (sizeof(long) - 1)": "!= 0"
        }
    }
},
{
    "kprobe:if ((long)src & (sizeof(long) - 1))": {
        "description": "Check if the source address is aligned to the size of a long integer.",
        "pre": {
            "src": "!=null",
            "sizeof(long)": "!=null",
            "((long)src & (sizeof(long) - 1))": "!=0"
        }
    }
},
{
    "kretprobe:stpcpy": {
        "description": "Copy a string from src to dest, returning a pointer to the new end of dest, including src's %NUL-terminator. May overrun dest.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest_size": ">=": "strlen(src) + 1"
        }
    }
},
{
    "kprobe:stpcpy": {
        "description": "Copy a string from src to dest, returning a pointer to the new end of dest.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest_size": ">=": "strlen(src) + 1"
        }
    }
},
{
    "kretprobe:strlcat": {
        "description": "Concatenate two strings with a size limit.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "dsize": ">=0",
            "len": ">=0",
            "res": ">=0",
            "BUG_ON(dsize >= count)": "true",
            "dest += dsize": "true",
            "count -= dsize": "true",
            "len >= count": "true",
            "len = count-1": "true",
            "__builtin_memcpy(dest, src, len)": "true",
            "dest[len] = 0": "true"
        }
    }
},
{
    "kprobe:strlcat": {
        "description": "Concatenates the source string to the destination string with a size limit.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "dsize": ">=0",
            "len": ">=0",
            "res": ">=0",
            "dsize": "<=count",
            "len": "<=count-1"
        }
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:strchr": {
        "description": "Find the first occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strchr": {
        "description": "Find the first occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": ">=0"
        }
    }
},
{
    "kprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": ">=0"
        }
    }
},
{
    "kretprobe:strnlen": {
        "description": "Calculate the length of a string, up to a maximum count.",
        "pre": {
            "s": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": ">=0",
            "return": "<=count"
        }
    }
},
{
    "kprobe:strnlen": {
        "description": "Calculate the length of a string, up to a maximum count.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "sc": "!=null",
            "sc != '\\0'": true
        }
    }
},
{
    "kretprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contains letters in @accept.",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contains letters in @accept.",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kretprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject.",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kretprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strsep": {
        "description": "Split a string into tokens",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strsep": {
        "description": "Split a string into tokens",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Fill a region of memory with the given value",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Fill a region of memory with the given value",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:memset16": {
        "description": "Fill a memory area with a uint16_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memset16": {
        "description": "Fill a memory area with a uint16_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memset32": {
        "description": "Fill a memory area with a uint32_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memset32": {
        "description": "Fill a memory area with a uint32_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memset64": {
        "description": "Fill a memory area with a uint64_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memset64": {
        "description": "Fill a memory area with a uint64_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memmove": {
        "description": "Copy one area of memory to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memmove": {
        "description": "Copy one area of memory to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">0"
        }
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "addr": "!=null",
            "c": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [addr, addr + size]"
        }
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "addr": "!=null",
            "c": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory.",
        "pre": {
            "start": "!=null",
            "c": "!=null",
            "bytes": "!=null"
        }
    }
},
{
    "kprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory.",
        "pre": {
            "start": "!=null",
            "c": "!=null",
            "bytes": "!=null"
        }
    }
},
{
    "kretprobe:check_signature": {
        "description": "Perform a signature comparison with the mmio address io_addr. Returns 1 on a match.",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:check_signature": {
        "description": "Perform a signature comparison with the mmio address io_addr. Returns 1 on a match.",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:bsearch": {
        "description": "Binary search an array of elements.",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp": "!=null"
        }
    }
},
{
    "kprobe:bsearch": {
        "description": "Binary search an array of elements.",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp": "!=null"
        }
    }
},
{
    "kretprobe:atomic_add_unless": {
        "description": "Subtract 1 from counter unless that drops it to 0 (i.e., it was 1)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:atomic_add_unless": {
        "description": "Subtract 1 from counter unless that drops it to 0 (i.e., it was 1)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:__sum16 ip_fast_csum": {
        "description": "Checksum computation optimized for IP headers on 4 octet boundaries.",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0"
        }
    }
},
{
    "kprobe:__sum16 ip_fast_csum": {
        "description": "Compute the checksum for IP headers on 4 octet boundaries.",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0"
        }
    }
},
{
    "kretprobe:result += sum;if (sum > result)result += 1;return (__force __wsum)result;}EXPORT_SYMBOL(csum_partial": {
        "description": "Calculate the checksum of a buffer and update the result.",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": "!=null"
        }
    }
},
{
    "kprobe:result += sum;if (sum > result)result += 1;return (__force __wsum)result;}EXPORT_SYMBOL(csum_partial": {
        "description": "Calculate the checksum of a buffer and update the result.",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": ">=0",
            "sum": ">=0",
            "result": ">=0"
        }
    }
},
{
    "kretprobe:from64to32": {
        "description": "Add up 32-bit and 32-bit for 32+c bit.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:x = (x & 0xffffffff) + (x >> 32);/* add up carry.. */": {
        "description": "Add up the carry of 32-bit and 32-bit for 32+c bit.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:sibling = parent->rb_right;if (node != sibling)": {
        "description": "This condition checks if the 'node' is not equal to 'sibling' in the given function.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "node": "!=null",
            "sibling": "!=null",
            "tmp1": "!=null",
            "tmp2": "!=null",
            "node_color": "in [BLACK, NULL]",
            "parent_color": "in [BLACK, NULL]",
            "sibling_color": "in [BLACK, NULL]",
            "tmp1_color": "in [BLACK, NULL]",
            "tmp2_color": "in [BLACK, NULL]",
            "root_color": "in [BLACK, NULL]",
            "node_is_root": "in [true, false]",
            "node_is_leaf": "in [true, false]",
            "sibling_is_root": "in [true, false]",
            "sibling_is_leaf": "in [true, false]",
            "tmp1_is_root": "in [true, false]",
            "tmp1_is_leaf": "in [true, false]",
            "tmp2_is_root": "in [true, false]",
            "tmp2_is_leaf": "in [true, false]",
            "root_is_root": "in [true, false]",
            "root_is_leaf": "in [true, false]",
            "node_black_count": "is 1 lower than other leaf paths",
            "sibling_black_count": "is 1 lower than other leaf paths",
            "tmp1_black_count": "is 1 lower than other leaf paths",
            "tmp2_black_count": "is 1 lower than other leaf paths",
            "root_black_count": "is 1 lower than other leaf paths"
        }
    }
},
{
    "kprobe:sibling = parent->rb_right;if (node != sibling)": {
        "description": "Check if the node is not equal to its right sibling in the red-black tree.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "node": "!=null",
            "sibling": "!=null",
            "tmp1": "!=null",
            "tmp2": "!=null",
            "node_color": "in [BLACK, RED]",
            "sibling_color": "in [BLACK, RED]",
            "root_color": "in [BLACK, RED]",
            "parent_color": "in [BLACK, RED]",
            "node_parent": "==parent",
            "sibling_parent": "==parent",
            "root_parent": "==NULL",
            "parent_root": "==root",
            "node_left": "==NULL",
            "node_right": "==NULL",
            "sibling_left": "==NULL",
            "sibling_right": "==NULL",
            "root_left": "==NULL",
            "root_right": "==NULL",
            "parent_left": "==NULL",
            "parent_right": "==NULL",
            "node_left_color": "==BLACK",
            "node_right_color": "==BLACK",
            "sibling_left_color": "==BLACK",
            "sibling_right_color": "==BLACK",
            "root_left_color": "==BLACK",
            "root_right_color": "==BLACK",
            "parent_left_color": "==BLACK",
            "parent_right_color": "==BLACK",
            "node_parent_color": "==BLACK",
            "sibling_parent_color": "==BLACK",
            "root_parent_color": "==BLACK",
            "parent_root_color": "==BLACK",
            "node_parent_left": "==NULL",
            "node_parent_right": "==NULL",
            "sibling_parent_left": "==NULL",
            "sibling_parent_right": "==NULL",
            "root_parent_left": "==NULL",
            "root_parent_right": "==NULL",
            "parent_root_left": "==NULL",
            "parent_root_right": "==NULL",
            "node_parent_left_color": "==BLACK",
            "node_parent_right_color": "==BLACK",
            "sibling_parent_left_color": "==BLACK",
            "sibling_parent_right_color": "==BLACK",
            "root_parent_left_color": "==BLACK",
            "root_parent_right_color": "==BLACK",
            "parent_root_left_color": "==BLACK",
            "parent_root_right_color": "==BLACK",
            "node_parent_color_left": "==BLACK",
            "node_parent_color_right": "==BLACK",
            "sibling_parent_color_left": "==BLACK",
            "sibling_parent_color_right": "==BLACK",
            "root_parent_color_left": "==BLACK",
            "root_parent_color_right": "==BLACK",
            "parent_root_color_left": "==BLACK",
            "parent_root_color_right": "==BLACK",
            "node_parent_left_color_left": "==BLACK",
            "node_parent_left_color_right": "==BLACK",
            "sibling_parent_left_color_left": "==BLACK",
            "sibling_parent_left_color_right": "==BLACK",
            "root_parent_left_color_left": "==BLACK",
            "root_parent_left_color_right": "==BLACK",
            "parent_root_left_color_left": "==BLACK",
            "parent_root_left_color_right": "==BLACK",
            "node_parent_right_color_left": "==BLACK",
            "node_parent_right_color_right": "==BLACK",
            "sibling_parent_right_color_left": "==BLACK",
            "sibling_parent_right_color_right": "==BLACK",
            "root_parent_right_color_left": "==BLACK",
            "root_parent_right_color_right": "==BLACK",
            "parent_root_right_color_left": "==BLACK",
            "parent_root_right_color_right": "==BLACK",
            "node_parent_color_left_color": "==BLACK",
            "node_parent_color_right_color": "==BLACK",
            "sibling_parent_color_left_color": "==BLACK",
            "sibling_parent_color_right_color": "==BLACK",
            "root_parent_color_left_color": "==BLACK",
            "root_parent_color_right_color": "==BLACK",
            "parent_root_color_left_color": "==BLACK",
            "parent_root_color_right_color": "==BLACK",
            "node_parent_left_color_left_color": "==BLACK",
            "node_parent_left_color_right_color": "==BLACK",
            "sibling_parent_left_color_left_color": "==BLACK",
            "sibling_parent_left_color_right_color": "==BLACK",
            "root_parent_left_color_left_color": "==BLACK",
            "root_parent_left_color_right_color": "==BLACK",
            "parent_root_left_color_left_color": "==BLACK",
            "parent_root_left_color_right_color": "==BLACK",
            "node_parent_right_color_left_color": "==BLACK",
            "node_parent_right_color_right_color": "==BLACK",
            "sibling_parent_right_color_left_color": "==BLACK",
            "sibling_parent_right_color_right_color": "==BLACK",
            "root_parent_right_color_left_color": "==BLACK",
            "root_parent_right_color_right_color": "==BLACK",
            "parent_root_right_color_left_color": "==BLACK",
            "parent_root_right_color_right_color": "==BLACK"
        }
    }
},


{
    "kretprobe:____rb_erase_color": {
        "description": "This function is used for erasing a node from a red-black tree and maintaining the color balance.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null"
        }
    }
},
{
    "kprobe:____rb_erase_color": {
        "description": "Function for erasing a node from a red-black tree.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "augment_rotate": "inline",
            "dummy_rotate": "eliminated"
        }
    }
},





{
    "kprobe:rb_replace_node_rcu": {
        "description": "Copy the pointers' color from the victim to the replacement.",
        "pre": {
            "victim": "!=null",
            "new": "!=null",
            "root": "!=null"
        }
    }
},




{
    "kretprobe:if (bf->selector & ~valid_flags_mask)": {
        "description": "Disallow invalid bit values",
        "pre": {
            "bf": "!=null",
            "valid_flags_mask": "!=0"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if (bf->selector & ~valid_flags_mask)return -EINVAL;/*disallow invalid bit values `": {
        "description": "Disallow invalid bit values",
        "pre": {
            "bf->selector": "& ~valid_flags_mask",
            "return": "-EINVAL"
        }
    }
},
{
    "kretprobe:intnla_policy_len": {
        "description": "Determine the max. length of a policy",
        "pre": {
            "p": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},

{
    "kretprobe:__nla_parse": {
        "description": "Parse a stream of attributes into a tb buffer",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": ">=0",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:__nla_parse": {
        "description": "Parse a stream of attributes into a tb buffer",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": ">=0",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:nla_find": {
        "description": "Find a specific attribute in a stream of attributes",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        }
    }
},
{
    "kprobe:nla_find": {
        "description": "Find a specific attribute in a stream of attributes",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        }
    }
},
{
    "kretprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "!=null",
            "dstsize": "<= U16_MAX",
            "dstsize": ">= 0",
            "nla length": "<= dstsize",
            "srclen": ">= 0",
            "srclen": "<= dstsize - 1",
            "return value": "in [srclen, -E2BIG]"
        }
    }
},
{
    "kprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "!=null",
            "dstsize": "<=U16_MAX",
            "strlen(nla) + 1": "<=dstsize"
        },
        "post": {
            "return_value": ">=-E2BIG"
        }
    }
},
{
    "kretprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:nla_strcmp": {
        "description": "Compare a string attribute against another string.",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kprobe:nla_strcmp": {
        "description": "Compare a string attribute against another string.",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:__nla_reserve": {
        "description": "Reserve room for attribute on the skb.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int"
        }
    }
},
{
    "kprobe:__nla_reserve": {
        "description": "Reserve room for attribute on the skb.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int"
        }
    }
},
{
    "kretprobe:__nla_reserve_64bit": {
        "description": "Reserve room for attribute on the skb and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kprobe:__nla_reserve_64bit": {
        "description": "Reserve room for attribute on the skb and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kretprobe:__nla_reserve_nohdr": {
        "description": "Reserve room for attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0"
        }
    }
},
{
    "kprobe:__nla_reserve_nohdr": {
        "description": "Reserve room for attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0"
        }
    }
},
{
    "kretprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int",
            "data": "!=null",
            "padattr": "int"
        }
    }
},
{
    "kretprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        },
        "post": {
            "return": "in [-EMSGSIZE]"
        }
    }
},
{
    "kprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtoull": {
        "description": "Convert a string to an unsigned long long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:noinlineunsigned long long simple_strtoull": {
        "description": "Convert a string to an unsigned long long.",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtol": {
        "description": "Convert a string to a signed long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:simple_strtol": {
        "description": "Convert a string to a signed long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long.",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},




{
    "kretprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:align": {
        "description": "Calculate alignment and perform operations on src and max.",
        "pre": {
            "src": "!=null",
            "count": "!=null",
            "max": "!=null",
            "align": ">= 0",
            "c": "!=null",
            "constants": "!=null",
            "constants.word_size": "== sizeof(unsigned long)",
            "res": ">= 0",
            "efault": "!=null"
        }
    }
},
{
    "kprobe:align": {
        "description": "Calculate the alignment of the source address.",
        "pre": {
            "src": "!=null",
            "sizeof(unsigned long)": "!=null",
            "align": "((sizeof(unsigned long) - 1) & (unsigned long)src)",
            "src": "src - align",
            "max": "max + align",
            "c": "unsafe_get_user(c, (unsigned long __user *)src, efault)",
            "c": "c | aligned_byte_mask(align)"
        }
    }
},
{
    "kretprobe:sort_r": {
        "description": "Sort an array of elements using heapsort.",
        "pre": {
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp_func": "!=null",
            "swap_func": "in [!=null, null]",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:sort_r": {
        "description": "Sort an array of elements using heapsort.",
        "pre": {
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp_func": "!=null",
            "swap_func": "in [!=null, null]",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:is_aligned": {
        "description": "Check if the pointer and size are suitable for word-wide copying.",
        "pre": {
            "base": "!=null",
            "size": "!=null",
            "align": "in [4, 8]",
            "size % align": "== 0",
            "base % align": "== 0"
        }
    }
},

{
    "kretprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace.",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},
{
    "kprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace.",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},


{
    "kretprobe:_copy_from_user": {
        "description": "Copy data from user space to kernel space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
            "should_fail_usercopy": "==0",
            "access_ok(from, n)": "==true"
        },
        "post": {
            "res": ">=0",
            "memset(to + (n - res), 0, res)": "executes if res is unlikely",
            "return res": "executes always"
        }
    }
},
{
    "kprobe:_copy_from_user": {
        "description": "Copy data from user space to kernel space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
            "should_fail_usercopy": "==0",
            "access_ok(from, n)": "==true"
        }
    }
},
{
    "kretprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes.",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EFAULT]"
        }
    }
},
{
    "kprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes.",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EFAULT]"
        }
    }
},
{
    "kretprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_UC, DEVM_IOREMAP_WC, DEVM_IOREMAP_NP]"
        }
    }
},
{
    "kretprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_iounmap": {
        "description": "Managed iounmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:devm_iounmap": {
        "description": "Managed iounmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:devm_ioremap_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region, and ioremaps it. All operations are managed and will be undone on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_NP]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap_resource": {
        "description": "Check, request region, and ioremap resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_NP]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device. This is to be used when a device requests maps resources described by other device tree nodes (children or otherwise).",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device. This is to be used when a device requests maps resources described by other device tree nodes (children or otherwise).",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": ">=0 or ==null"
        }
    }
},
{
    "kretprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kretprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table for @dev. If iomap table doesn't exist and @pdev is managed, it will be allocated. All iomaps recorded in the iomap table are automatically unmapped on driver detach.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). Unmaps the address @addr for the PCI device @pdev.",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). Unmaps the address @addr for the PCI device @pdev.",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_regions_request_all": {
        "description": "Request all BARs and iomap specified ones",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_regions_request_all": {
        "description": "Request all BARs and iomap specified ones",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:devm_arch_phys_wc_add": {
        "description": "Managed arch_phys_wc_add()",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_arch_phys_wc_add": {
        "description": "Managed arch_phys_wc_add()",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback.",
        "pre": {
            "dev": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback.",
        "pre": {
            "dev": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter.",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter.",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kretprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kretprobe:key->key.r[0] = (get_unaligned_le32(&raw_key[0])) & 0x3ffffff;key->key.r[1] = (get_unaligned_le32(&raw_key[3]) >> 2) & 0x3ffff03;key->key.r[2] = (get_unaligned_le32(&raw_key[6]) >> 4) & 0x3ffc0ff;key->key.r[3] = (get_unaligned_le32(&raw_key[9]) >> 6) & 0x3f03fff;key->key.r[4] = (get_unaligned_le32(&raw_key[12]) >> 8) & 0x00fffff;/* s = 5*r `": {
        "description": "Set the values of key->key.r[0] to key->key.r[4] based on the given raw_key.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "!=null",
            "raw_key[3]": "!=null",
            "raw_key[6]": "!=null",
            "raw_key[9]": "!=null",
            "raw_key[12]": "!=null",
            "key->key.r[0]": ">= 0 && <= 0x3ffffff",
            "key->key.r[1]": ">= 0 && <= 0x3ffff03",
            "key->key.r[2]": ">= 0 && <= 0x3ffc0ff",
            "key->key.r[3]": ">= 0 && <= 0x3f03fff",
            "key->key.r[4]": ">= 0 && <= 0x00fffff"
        }
    }
},
{
    "kprobe:key->key.r[0] = (get_unaligned_le32(&raw_key[0])) & 0x3ffffff;key->key.r[1] = (get_unaligned_le32(&raw_key[3]) >> 2) & 0x3ffff03;key->key.r[2] = (get_unaligned_le32(&raw_key[6]) >> 4) & 0x3ffc0ff;key->key.r[3] = (get_unaligned_le32(&raw_key[9]) >> 6) & 0x3f03fff;key->key.r[4] = (get_unaligned_le32(&raw_key[12]) >> 8) & 0x00fffff;/* s = 5*r `": {
        "description": "Set the values of key->key.r[0] to key->key.r[4] based on the given raw_key.",
        "pre": {
            "key->key.r[0]": ">= 0 && <= 0x3ffffff",
            "key->key.r[1]": ">= 0 && <= 0x3ffff03",
            "key->key.r[2]": ">= 0 && <= 0x3ffc0ff",
            "key->key.r[3]": ">= 0 && <= 0x3f03fff",
            "key->key.r[4]": ">= 0 && <= 0x00fffff"
        }
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "Helper function for poly1305_core_blocks",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">0",
            "hibit": ">=0"
        }
    }
},
{
    "kprobe:h0 += (get_unaligned_le32(&input[0])) & 0x3ffffff;h1 += (get_unaligned_le32(&input[3]) >> 2) & 0x3ffffff;h2 += (get_unaligned_le32(&input[6]) >> 4) & 0x3ffffff;h3 += (get_unaligned_le32(&input[9]) >> 6) & 0x3ffffff;h4 += (get_unaligned_le32(&input[12]) >> 8) | hibit;/* h *= r": {
        "description": "Update the values of h0, h1, h2, h3, and h4 based on the input and hibit.",
        "pre": {
            "input": "!=null",
            "hibit": "!=null",
            "h0": "!=null",
            "h1": "!=null",
            "h2": "!=null",
            "h3": "!=null",
            "h4": "!=null"
        }
    }
},
{
    "h0": "!=null",
    "h1": "!=null",
    "h2": "!=null",
    "h3": "!=null",
    "h4": "!=null",
    "c": "!=null"
},
{
    "kprobe:h0_state_h1_state_h2_state_h3_state_h4_c": {
        "description": "Compute h + -p",
        "pre": {
            "state": "!=null",
            "h0": "is int",
            "h1": "is int",
            "h2": "is int",
            "h3": "is int",
            "h4": "is int",
            "c": "is int",
            "h1": ">> 26",
            "h1": "& 0x3ffffff",
            "h2": "+= c",
            "c": ">> 26",
            "h2": "& 0x3ffffff",
            "h3": "+= c",
            "c": ">> 26",
            "h3": "& 0x3ffffff",
            "h4": "+= c",
            "c": ">> 26",
            "h4": "& 0x3ffffff",
            "h0": "+= c * 5",
            "c": ">> 26",
            "h0": "& 0x3ffffff",
            "h1": "+= c"
        }
    }
},
{
    "kretprobe:while (size > 0)": {
        "description": "Loop while size is greater than 0.",
        "pre": {
            "size": ">0"
        }
    }
},
{
    "while (size > 0)": {
        "description": "Loop until size becomes zero",
        "pre": {
            "size": "> 0"
        },
        "post": {
            "size": "== 0"
        },
        "loop_body": {
            "neq": "|= get_unaligned((unsigned long)a) ^ get_unaligned((unsigned long)b)",
            "a": "+= sizeof(unsigned long)",
            "b": "+= sizeof(unsigned long)",
            "size": "-= sizeof(unsigned long)"
        }
    }
},
{
    "kretprobe:get_unaligned_le64": {
        "description": "Read an unaligned 64-bit little-endian value from memory.",
        "pre": {
            "raw_key": "!=null"
        }
    },
    "kretprobe:poly1305_core_setkey": {
        "description": "Set the key for the Poly1305 core function.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null"
        }
    }
},
{
    "kprobe:poly1305_core_setkey": {
        "description": "Set the key for the poly1305_core function.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "!=null",
            "raw_key[8]": "!=null",
            "t0": "!=null",
            "t1": "!=null",
            "key->key.r64[0]": "t0 & 0xffc0fffffffULL",
            "key->key.r64[1]": "((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffffULL",
            "key->key.r64[2]": "((t1 >> 24)) & 0x00ffffffc0fULL",
            "s": "20 * r"
        }
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "Perform poly1305 core blocks computation.",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">0",
            "hibit": ">=0"
        },
        "post": {
            "h0": ">=0",
            "h1": ">=0",
            "h2": ">=0"
        }
    }
},
{
    "kprobe:poly1305_core_blocks": {
        "description": "Perform poly1305 core blocks operation.",
        "pre": {
            "input": "!=null"
        }
    }
},
{
    "kretprobe:h0 = state->h64[0];h1 = state->h64[1];h2 = state->h64[2];c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;/* compute h + -p `": {
        "description": "Compute h + -p",
        "pre": {
            "h0": "!=null",
            "h0": "<= 0xfffffffffffULL",
            "h1": "!=null",
            "h1": "<= 0xfffffffffffULL",
            "h2": "!=null",
            "h2": "<= 0x3ffffffffffULL",
            "c": "!=null"
        }
    }
},
{
    "kprobe:h0 = state->h64[0];h1 = state->h64[1];h2 = state->h64[2];c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;/* compute h + -p `": {
        "description": "Compute h + -p",
        "pre": {
            "state": "!=null",
            "state->h64[0]": "!=null",
            "state->h64[1]": "!=null",
            "state->h64[2]": "!=null",
            "h1": ">= 0",
            "h1": "<= 0xfffffffffffULL",
            "h2": ">= 0",
            "h2": "<= 0x3ffffffffffULL",
            "c": ">= 0",
            "c": "<= 0xfffffffffffULL",
            "h0": ">= 0",
            "h0": "<= 0xfffffffffffULL"
        }
    }
},


{
    "kretprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule.",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": ">= 0",
            "authsize": ">= 0"
        }
    }
},
{
    "kprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule.",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": ">=0",
            "authsize": ">=0"
        }
    }
},
{
    "kretprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kretprobe:aes_encrypt": {
        "description": "Encrypt data using the AES algorithm.",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    },
    "kretprobe:local_irq_restore": {
        "description": "Restore the interrupt state to the value saved by local_irq_save.",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kprobe:aes_encrypt": {
        "description": "Encrypt data using the AES algorithm.",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    },
    "kprobe:local_irq_restore": {
        "description": "Restore the interrupt state to the value saved by local_irq_save.",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null",
            "iv_size": "==12",
            "authtag": "!=null"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null",
            "iv_size": "12",
            "authtag": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},


{
    "kretprobe:chacha_crypt_generic": {
        "description": "Perform generic ChaCha encryption.",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": ">= CHACHA_BLOCK_SIZE",
            "nrounds": "!=null"
        }
    }
},
{
    "kprobe:chacha_crypt_generic": {
        "description": "aligned to potentially speed up crypto_xor()",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": ">=CHACHA_BLOCK_SIZE",
            "nrounds": "any"
        }
    }
},
{
    "kretprobe:blake2s_compress": {
        "description": "Compresses the input state using the Blake2s algorithm.",
        "pre": {
            "state": "!=null",
            "state->buf": "!=null",
            "state->buflen": "==1",
            "state->h": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kprobe:blake2s_compress": {
        "description": "Compresses the state using the Blake2s algorithm.",
        "pre": {
            "state": "!=null",
            "state->buf": "!=null",
            "state->buflen": "==1",
            "state->h": "!=null",
            "ARRAY_SIZE(state->h)": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kretprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": ">=16 && <=256"
        }
    }
},
{
    "kprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": "!=null"
        }
    }
},
{
    "kretprobe:aes_encrypt": {
        "description": "Encrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_encrypt": {
        "description": "Encrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:aes_decrypt": {
        "description": "Decrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_decrypt": {
        "description": "Decrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:sha1_transform": {
        "description": "Single block SHA1 transform (deprecated)",
        "pre": {
            "digest": "!=null",
            "data": "!=null",
            "array": "!=null"
        }
    }
},
{
    "kprobe:sha1_transform": {
        "description": "Single block SHA1 transform (deprecated)",
        "pre": {
            "digest": "!=null",
            "data": "!=null",
            "array": "!=null"
        }
    }
},
{
    "kretprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "pre": {
            "buf": "!=null"
        }
    }
},
{
    "kprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "pre": {
            "buf": "!=null"
        }
    }
},


{
    "kretprobe:dim_on_top": {
        "description": "Check if the dimension is on top.",
        "pre": {
            "dim": "!=null",
            "dim->tune_state": "in [DIM_PARKING_ON_TOP, DIM_PARKING_TIRED, DIM_GOING_RIGHT, DIM_GOING_LEFT]",
            "dim->steps_right": "> 1",
            "dim->steps_left": "== 1"
        }
    }
},
{
    "kprobe:return (dim->steps_right > 1) && (dim->steps_left == 1);}}EXPORT_SYMBOL(dim_on_top": {
        "description": "Helper function to determine if the dimension is on top.",
        "pre": {
            "dim->steps_right": "> 1",
            "dim->steps_left": "== 1"
        }
    }
},
{
    "kretprobe:dim_calc_stats": {
        "description": "Calculate statistics for DIM samples.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "curr_stats": "!=null"
        },
        "post": {
            "delta_us": "!=0",
            "npkts": ">=0",
            "nbytes": ">=0",
            "ncomps": ">=0",
            "curr_stats.ppms": ">=0",
            "curr_stats.bpms": ">=0",
            "curr_stats.epms": ">=0",
            "curr_stats.cpms": ">=0",
            "curr_stats.cpe_ratio": ">=0"
        }
    }
},
{
    "kprobe:dim_calc_stats": {
        "description": "Calculate statistics using the given start and end samples.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "curr_stats": "!=null"
        }
    }
},
{
    "kretprobe:rdma_dim_decision": {
        "description": "Helper function for rdma_dim_decision.",
        "pre": {
            "dim->tune_state": "== DIM_GOING_RIGHT || dim->tune_state == DIM_GOING_LEFT",
            "dim->profile_ix": ">= 0 && dim->profile_ix <= RDMA_DIM_PARAMS_NUM_PROFILES - 1",
            "dim->steps_right": ">= 0",
            "dim->steps_left": ">= 0"
        }
    },
    "kretprobe:rdma_dim_stats_compare": {
        "description": "Helper function for rdma_dim_stats_compare.",
        "pre": {
            "curr.cpms": "!= null",
            "prev.cpms": "!= null",
            "curr.cpe_ratio": "!= null",
            "prev.cpe_ratio": "!= null"
        }
    }
},
{
    "kprobe:rdma_dim_decision": {
        "description": "Helper function for making decisions based on dim statistics.",
        "pre": {
            "curr_stats": "!=null",
            "dim": "!=null"
        }
    },
    "kprobe:rdma_dim_step": {
        "description": "Helper function for stepping through dim profiles.",
        "pre": {
            "dim": "!=null",
            "dim->tune_state": "in [DIM_GOING_RIGHT, DIM_GOING_LEFT]",
            "dim->profile_ix": "in [0, RDMA_DIM_PARAMS_NUM_PROFILES - 1]"
        }
    },
    "kprobe:rdma_dim_stats_compare": {
        "description": "Helper function for comparing dim statistics.",
        "pre": {
            "curr": "!=null",
            "prev": "!=null"
        }
    }
},


{
    "kretprobe:LZ4_decompress_safe_continue": {
        "description": "Decompress multiple blocks in streaming mode.",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        }
    }
},
{
    "kprobe:LZ4_decompress_safe_continue": {
        "description": "Decompress multiple blocks in streaming mode.",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        }
    }
},
{
    "kretprobe:assert": {
        "description": "Assert that lz4sd->extDictSize is equal to 0",
        "pre": {
            "lz4sd->extDictSize": "== 0"
        }
    },
    "kretprobe:LZ4_decompress_safe": {
        "description": "Decompress data using LZ4_decompress_safe function",
        "pre": {
            "source": "!= null",
            "dest": "!= null",
            "compressedSize": "!= null",
            "maxOutputSize": "!= null"
        },
        "post": {
            "result": "> 0"
        }
    },
    "kretprobe:return": {
        "description": "Update lz4sd->prefixSize and lz4sd->prefixEnd",
        "pre": {
            "lz4sd->prefixEnd": "== dest"
        }
    }
},
{
    "kprobe:assert": {
        "description": "Assert that lz4sd->extDictSize is equal to 0.",
        "pre": {
            "lz4sd->extDictSize": "== 0"
        }
    },
    "kprobe:LZ4_decompress_safe": {
        "description": "Decompress the source data to the destination buffer using LZ4_decompress_safe.",
        "pre": {
            "source": "!= null",
            "dest": "!= null",
            "compressedSize": ">= 0",
            "maxOutputSize": ">= 0"
        }
    },
    "kprobe:return": {
        "description": "Return the result of LZ4_decompress_safe.",
        "pre": {
            "result": "<= 0"
        }
    },
    "kprobe:lz4sd->prefixSize": {
        "description": "Set lz4sd->prefixSize to the result of LZ4_decompress_safe.",
        "pre": {
            "lz4sd->prefixSize": "= result"
        }
    },
    "kprobe:lz4sd->prefixEnd": {
        "description": "Set lz4sd->prefixEnd to the destination buffer plus the result of LZ4_decompress_safe.",
        "pre": {
            "lz4sd->prefixEnd": "= (BYTE *)dest + result"
        }
    },
    "kprobe:else if (lz4sd->prefixEnd == (BYTE *)dest)": {
        "description": "Check if lz4sd->prefixEnd is equal to the destination buffer.",
        "pre": {
            "lz4sd->prefixEnd": "== (BYTE *)dest"
        }
    }
},



{
    "kprobe:- 8 /* because 8 + MINMATCH == MFLIMIT */": {
        "description": "Function description goes here.",
        "pre": {
            "ctx": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "srcSizePtr": ">=0",
            "targetDstSize": ">=0",
            "tableType": "valid table type"
        }
    }
},

{
    "kprobe:LZ4_resetStream": {
        "description": "Reset the LZ4 stream state.",
        "pre": {
            "LZ4_dict": "!=null",
            "dictSize": "< HASH_UNIT"
        }
    }
},
{
    "kretprobe:LZ4_saveDict": {
        "description": "Save the LZ4 dictionary.",
        "pre": {
            "LZ4_dict": "!=null",
            "safeBuffer": "!=null",
            "dictSize": "> 0",
            "dictSize": "<= 64 * KB",
            "dict->dictSize": ">= (U32)dictSize",
            "safeBuffer": "points to valid memory",
            "dict->dictionary": "points to valid memory",
            "dict->dictSize": "is updated to (U32)dictSize",
            "return value": "is equal to dictSize"
        }
    }
},



{
    "kretprobe:zstd_init_cstream": {
        "description": "Initialize a zstd compression stream.",
        "pre": {
            "parameters": "!=null",
            "pledged_src_size": "==0",
            "workspace": "!=null",
            "workspace_size": "!=0"
        }
    }
},
{
    "kprobe:zstd_init_cstream": {
        "description": "Initialize a zstd compression stream.",
        "pre": {
            "parameters": "!=null",
            "pledged_src_size": "==0",
            "workspace": "!=null",
            "workspace_size": "!=0"
        }
    }
},
{
    "kretprobe:find_font": {
        "description": "Find a specified font with string name @name. Returns %NULL if no font found, or a pointer to the specified font.",
        "pre": {
            "name": "!=null"
        }
    }
},

{
    "kretprobe:get_default_font": {
        "description": "Get the default font for a specified screen size.",
        "pre": {
            "xres": "!=null",
            "yres": "!=null",
            "font_w": "!=null",
            "font_h": "!=null"
        }
    }
},
{
    "kprobe:get_default_font": {
        "description": "Get the default font for a specified screen size.",
        "pre": {
            "xres": "!=null",
            "yres": "!=null",
            "font_w": "!=null",
            "font_h": "!=null"
        }
    }
},
{
    "kretprobe:rational_best_approximation": {
        "description": "Find the best rational approximation for a given fixed-point number.",
        "pre": {
            "given_numerator": "!=null",
            "given_denominator": "!=null",
            "max_numerator": "!=null",
            "max_denominator": "!=null",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},
{
    "kprobe:rational_best_approximation": {
        "description": "Calculate the rational best approximation for a given numerator and denominator.",
        "pre": {
            "given_numerator": "!=null",
            "given_denominator": "!=null",
            "max_numerator": "!=null",
            "max_denominator": "!=null",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},


{
    "kretprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for a given angle",
        "pre": {
            "theta": "!=null"
        },
        "post": {
            "coord": "!=null",
            "coord.x": ">=0",
            "coord.y": ">=0"
        }
    }
},
{
    "kprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for a given angle.",
        "pre": {
            "theta": "!=null",
            "coord": "!=null"
        }
    }
},

{
    "kprobe:__div64_32": {
        "description": "__div64_32() can be overridden by linking arch-specific assembly versions such as archppclibdiv64.S and archshlibdiv64.S or by defining a preprocessor macro in archincludeasmdiv64.h.",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null"
        }
    }
},
{
    "kretprobe:div64_u64_rem": {
        "description": "Unsigned 64bit divide with 64bit divisor and remainder",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null",
            "remainder": "!=null"
        }
    }
},
{
    "kprobe:div64_u64_rem": {
        "description": "Unsigned 64-bit divide with 64-bit divisor and remainder.",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null",
            "remainder": "!=null"
        }
    }
},


{
    "kretprobe:is_prime_number": {
        "description": "Checks if a number is prime.",
        "pre": {
            "x": "!=null"
        }
    },
    "kretprobe:slow_next_prime_number": {
        "description": "Finds the next prime number greater than the given number.",
        "pre": {
            "x": "!=null"
        }
    },
    "kretprobe:clear_multiples": {
        "description": "Clears the multiples of a prime number within a given range.",
        "pre": {
            "x": "!=null",
            "p": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    },
    "kretprobe:expand_to_next_prime": {
        "description": "Expands the number to the next prime number.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:is_prime_number": {
        "description": "Checks if a number is prime.",
        "pre": {
            "x": "!=null"
        }
    },
    "kprobe:slow_next_prime_number": {
        "description": "Finds the next prime number greater than the given number.",
        "pre": {
            "x": "!=null"
        }
    },
    "kprobe:clear_multiples": {
        "description": "Clears the multiples of a prime number within a given range.",
        "pre": {
            "x": "!=null",
            "p": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    },
    "kprobe:expand_to_next_prime": {
        "description": "Expands the number to the next prime number.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:int_sqrt": {
        "description": "Computes the integer square root of x.",
        "pre": {
            "x": ">= 0"
        }
    }
},
{
    "kprobe:int_sqrt": {
        "description": "Computes the integer square root of x.",
        "pre": {
            "x": ">= 0"
        }
    }
},
{
    "kretprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        }
    }
},
{
    "kprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        }
    }
},
{
    "kretprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        }
    }
},

{
    "kprobe:dfltcc_can_inflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "strm->state": "!=null",
            "GET_DFLTCC_STATE(state)": "!=null"
        }
    }
},


{
    "kretprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "zlib_dfltcc_support": "in [ZLIB_DFLTCC_DISABLED, ZLIB_DFLTCC_INFLATE_ONLY]"
        }
    }
},
{
    "kprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null"
        }
    }
},
{
    "kretprobe:dfltcc_reset_deflate_state": {
        "description": "Reset the deflate state and initialize tuning parameters.",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "= DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "= DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": ">= DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},
{
    "kprobe:dfltcc_reset_deflate_state": {
        "description": "Reset the deflate state and initialize tuning parameters.",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "= DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "= DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": ">= DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},




{
    "kretprobe:crypto_sha256_arm_update": {
        "description": "Make sure casting to sha256_block_fn() is safe.",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:crypto_sha256_arm_update": {
        "description": "Update the SHA256 state with the given data.",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},


{
    "kretprobe:pfn_valid": {
        "description": "Check if the physical frame number (PFN) is valid.",
        "pre": {
            "pfn": "!=null",
            "addr": "!=null",
            "pageblock_size": "!=null",
            "__phys_to_pfn(addr)": "==pfn",
            "memblock_overlaps_region(&memblock.memory, ALIGN_DOWN(addr, pageblock_size), pageblock_size)": "==1"
        }
    }
},
{
    "kprobe:memblock_overlaps_region": {
        "description": "Check if the memory block overlaps with a region.",
        "pre": {
            "memblock.memory": "!=null",
            "addr": "!=null",
            "pageblock_size": "!=null",
            "pageblock_nr_pages": "!=null"
        }
    }
},


{
    "kretprobe:empty_zero_page": {
        "description": "Special page used for zero-initialized data and COW.",
        "pre": {
            "empty_zero_page": "!=null",
            "usage": "in [ZERO_INITIALIZED_DATA, COW]"
        }
    }
},
{
    "kprobe:struct_page_empty_zero_page": {
        "description": "empty_zero_page is a special page that is used for zero-initialized data and COW.",
        "pre": {
            "empty_zero_page": "!=null"
        }
    }
},

{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Bounds checking against the kernel image only.",
        "pre": {
            "x": ">= (unsigned long)KERNEL_START",
            "x": "<= (unsigned long)KERNEL_END"
        }
    }
},





{
    "kprobe:unmap_area_sections": {
        "description": "Unmap and remap a region using iounmap and ioremap.",
        "pre": {
            "virt": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:jornada_ssp_reverse": {
        "description": "Reverses the input byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return_value": "in [0, 255]"
        }
    }
},
{
    "kprobe:jornada_ssp_reverse": {
        "description": "Reverses the input byte",
        "pre": {
            "byte": "!=null"
        }
    }
},
{
    "kretprobe:jornada_ssp_byte": {
        "description": "Waits for ready ssp bus and sends byte",
        "pre": {
            "byte": "!=null",
            "fifo_buffer": "==0",
            "mcu_running": "==true"
        },
        "post": {
            "return_value": "!=null",
            "return_value": "in [%mcu_output, %-ETIMEDOUT]"
        }
    }
},
{
    "kprobe:jornada_ssp_byte": {
        "description": "Waits for the ready ssp bus and sends a byte.",
        "pre": {
            "byte": "!=null",
            "fifo_buffer": "empty",
            "mcu_running": "true"
        },
        "post": {
            "output": "!=null",
            "output": "on success",
            "output": "-ETIMEDOUT on timeout"
        }
    }
},
{
    "kretprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return": {
                "constraints": [
                    "in [jornada_ssp_byte(byte), %-ETIMEDOUT]"
                ]
            }
        }
    }
},
{
    "kprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return": "in [jornada_ssp_byte(byte), %-ETIMEDOUT]"
        }
    }
},
{
    "kretprobe:jornada_ssp_start": {
        "description": "Enable MCU",
        "pre": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:jornada_ssp_start": {
        "description": "enable mcu",
        "pre": {}
    }
},
{
    "kretprobe:jornada_ssp_end": {
        "description": "disable mcu and turn off lock",
        "pre": {
            "mcu": "disabled",
            "lock": "off"
        }
    }
},
{
    "kprobe:jornada_ssp_end": {
        "description": "Disable mcu and turn off lock",
        "pre": {}
    }
},
{
    "kretprobe:ssp_write_word": {
        "description": "Write a word to the SSP port",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "in [0, -ETIMEDOUT]"
        }
    }
},
{
    "kprobe:ssp_write_word": {
        "description": "Write a word to the SSP port",
        "pre": {
            "data": "!=null",
            "SSP_transmit_FIFO": "has_free_entry"
        },
        "post": {
            "SSP_port": "sending_data"
        },
        "returns": {
            "timeout": "%-ETIMEDOUT",
            "success": "0"
        }
    }
},
{
    "kretprobe:ssp_read_word": {
        "description": "Read a word from the SSP port",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is 16-bit data"
        }
    }
},
{
    "kprobe:ssp_read_word": {
        "description": "Read a word from the SSP port.",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs. Wait for the SSP to idle and ensure that the receive FIFO is empty.",
        "pre": {
            "return_value": "in [-ETIMEDOUT, 0]"
        }
    }
},
{
    "kprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs of the SSP.",
        "pre": {
            "receive_fifo_empty": true,
            "ssp_idle": true
        }
    }
},
{
    "kretprobe:ssp_enable": {
        "description": "Enable the SSP port",
        "pre": {},
        "post": {
            "return_value": ">= 0"
        }
    }
},

{
    "kretprobe:ssp_disable": {
        "description": "Shut down the SSP port and optionally power it down.",
        "pre": {},
        "post": {
            "return_value": "0"
        }
    }
},

{
    "kretprobe:ssp_save_state": {
        "description": "Save the SSP configuration",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kprobe:ssp_save_state": {
        "description": "Save the configured SSP state for suspend.",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kretprobe:ssp_restore_state": {
        "description": "Restore a previously saved SSP configuration",
        "pre": {
            "ssp": "!=null",
            "(*ssp).field1": "!=null",
            "(*ssp).field2": "!=null",
            "(*ssp).field3": "!=null",
            ...
        }
    }
},



{
    "kretprobe:ssp_exit": {
        "description": "Undo the effects of ssp_init, release and free resources for the SSP port.",
        "pre": {
            "none": "none"
        }
    }
},









{
    "kretprobe:ep93xx_i2s_acquire": {
        "description": "This is potentially racy with the clock api for i2s_mclk, sclk and lrclk. Since the i2s driver is the only user of those clocks we rely on it to prevent parallel use of this function and the clock api for the i2s clocks.",
        "pre": {
            "__raw_readl(EP93XX_SYSCON_I2SCLKDIV)": "!=null",
            "val": "!=null",
            "EP93XX_I2SCLKDIV_MASK": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_ORIDE": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_SPOL": "!=null",
            "ep93xx_syscon_swlocked_write(val, EP93XX_SYSCON_I2SCLKDIV)": "!=null"
        }
    }
},
{
    "kprobe:ep93xx_i2s_acquire": {
        "description": "This function acquires the EP93xx I2S interface.",
        "pre": {
            "val": "!=null",
            "ep93xx_devcfg_set_clear": "!=null",
            "EP93XX_SYSCON_DEVCFG_I2SONAC97": "!=null",
            "EP93XX_SYSCON_DEVCFG_I2S_MASK": "!=null"
        }
    }
},

{
    "kprobe:ep93xx_devcfg_clear_bits": {
        "description": "Clears the specified bits in the EP93XX_SYSCON_DEVCFG register.",
        "pre": {
            "pdev": "!=null",
            "err": "int",
            "i": "int",
            "EP93XX_GPIO_LINE_EGPIO2": "int",
            "EP93XX_GPIO_LINE_EGPIO15": "int",
            "EP93XX_GPIO_LINE_E": "int[8]",
            "EP93XX_GPIO_LINE_G": "int[8]",
            "EP93XX_GPIO_LINE_H": "int[8]"
        }
    }
},


{
    "iowrite16": {
        "description": "Write the value 0x0000 to the address calculated as sdev->base + SCOOP_CDR.",
        "pre": {
            "arg1": "0x0000",
            "arg2": "sdev->base + SCOOP_CDR"
        }
    }
},
{
    "kprobe:iowrite16": {
        "description": "Write the value 0x0000 to the address sdev->base + SCOOP_CDR.",
        "pre": {
            "sdev": "!=null",
            "sdev->base": "!=null",
            "SCOOP_CDR": "!=null"
        }
    }
},


{
    "kretprobe:krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:asm volatile (\"mcr p15, 3, %0, c15, c0, 6 @ l2cpselr\" : : \"r\" (addr));isb();asm volatile (\"mcr p15, 3, %0, c15, c0, 7 @ l2cpdr\" : : \"r\" (val));isb();raw_spin_unlock_irqrestore(&krait_l2_lock, flags);}EXPORT_SYMBOL(krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:asm volatile (\"mcr p15, 3, %0, c15, c0, 6 @ l2cpselr\" : : \"r\" (addr));isb();asm volatile (\"mrc p15, 3, %0, c15, c0, 7 @ l2cpdr\" : \"=r\" (val));raw_spin_unlock_irqrestore(&krait_l2_lock, flags);return val;}EXPORT_SYMBOL(krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "pre": {
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency.",
        "pre": {
            "sachip": "!=null"
        }
    }
},
{
    "sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_select_audio_mode": {
        "description": "Select I2S or AC link mode.",
        "pre": {
            "sadev": "!=null",
            "mode": "in [SA1111_AUDIO_ACLINK, SA1111_AUDIO_I2S]"
        }
    }
},
{
    "kprobe:sa1111_select_audio_mode": {
        "description": "Select I2S or AC link mode",
        "pre": {
            "sadev": "!=null",
            "mode": "in [SA1111_AUDIO_ACLINK, SA1111_AUDIO_I2S]"
        }
    }
},
{
    "kretprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate.",
        "pre": {
            "sadev": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate.",
        "pre": {
            "sadev": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "if (info->dma && sachip->dev->dma_mask)": {
        "description": "Check if info->dma and sachip->dev->dma_mask are not null.",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        }
    }
},
{
    "kprobe:if (info->dma && sachip->dev->dma_mask)": {
        "description": "Check if the parent device has a DMA mask associated with it and if this child supports DMA.",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        }
    }
},
{
    "kretprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "pre": {
            "bus": "!=null"
        }
    }
},






{
    "kretprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "pre": {
            "x->e_machine": "!= EM_ARM"
        }
    }
},
{
    "kprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "pre": {
            "x->e_machine": "!= EM_ARM"
        }
    }
},
{
    "kretprobe:elf_set_personality": {
        "description": "Set the personality of the current process based on the ELF header flags.",
        "pre": {
            "x": "!=null",
            "eflags": "!=null",
            "personality": "!=null",
            "current": "!=null",
            "PER_LINUX": "defined",
            "PER_MASK": "defined"
        }
    }
},
{
    "kprobe:elf_set_personality": {
        "description": "Set the personality of the current process based on the ELF executable.",
        "pre": {
            "x": "!=null",
            "eflags": "!=null",
            "personality": "!=null",
            "personality & PER_MASK": "==0",
            "personality |= PER_LINUX": "true"
        }
    }
},
{
    "kretprobe:omap_readl": {
        "description": "Read the value of OCPI_PROT register and store it in val.",
        "pre": {
            "OCPI_PROT": "!=null"
        },
        "post": {
            "val": "!=null",
            "val": "&= ~0xff"
        }
    }
},
{
    "kprobe:omap_readl": {
        "description": "Read a 32-bit value from the OCPI_PROT register and perform a bitwise AND operation with ~0xff.",
        "pre": {
            "val": "!=null",
            "cpu_is_omap16xx()": "true"
        }
    }
},
{
    "kretprobe:static struct omap_id omap_ids[] __initdata": {
        "description": "Register values to detect the OMAP version",
        "pre": {
            "omap_revision": "!=null"
        }
    }
},

{
    "kretprobe:omap_readb": {
        "description": "Read a byte from the memory location specified by pa.",
        "pre": {
            "pa": "!=null"
        }
    }
},







{
    "kretprobe:break;}}if (free_ch == -1)": {
        "description": "Condition for the break statement in the given function",
        "pre": {
            "free_ch": "== -1"
        }
    }
},
{
    "kprobe:omap_request_dma": {
        "description": "Request DMA channel for OMAP devices.",
        "pre": {
            "dev_id": "!=null",
            "dev_name": "!=null",
            "callback": "!=null",
            "data": "!=null",
            "dma_ch_out": "!=null",
            "free_ch": "== -1"
        }
    }
},
{
    "kretprobe:omap_disable_channel_irq": {
        "description": "Disable all DMA interrupts for the channel.",
        "pre": {
            "lch": "!=null",
            "dma_chan[lch].dev_id": "!= -1"
        }
    }
},

{
    "kretprobe:omap_clear_dma": {
        "description": "Clears the DMA channel specified by *lch*.",
        "pre": {
            "lch": "!=null"
        }
    }
},
{
    "kprobe:omap_clear_dma": {
        "description": "Clears the DMA channel specified by *lch*.",
        "pre": {
            "lch": "!=null"
        }
    }
},
{
    "kretprobe:omap_disable_channel_irq": {
        "description": "Disable all interrupts on the channel",
        "pre": {
            "lch": "!=null",
            "l": "!=null",
            "p": "!=null",
            "DMA_ERRATA_i541": "defined",
            "OMAP_DMA_CCR_SEL_SRC_DST_SYNC": "defined",
            "IS_DMA_ERRATA(DMA_ERRATA_i541)": "true",
            "(l & OMAP_DMA_CCR_SEL_SRC_DST_SYNC)": "true"
        }
    }
},
{
    "kprobe:omap_disable_channel_irq": {
        "description": "Disable all interrupts on the channel",
        "pre": {
            "lch": "!=null",
            "l": "!=null",
            "p": "!=null",
            "DMA_ERRATA_i541": "defined",
            "OMAP_DMA_CCR_SEL_SRC_DST_SYNC": "defined",
            "IS_DMA_ERRATA(DMA_ERRATA_i541)": "true",
            "(l & OMAP_DMA_CCR_SEL_SRC_DST_SYNC)": "true"
        }
    }
},
{
    "kretprobe:omap_get_dma_src_pos": {
        "description": "Helper function to get the source position for DMA transfer.",
        "pre": {
            "lch": "!=null",
            "offset": "!=null",
            "dma_omap15xx()": "in [true, false]",
            "IS_DMA_ERRATA(DMA_ERRATA_3_3)": "in [true, false]"
        }
    }
},
{
    "kprobe:omap_get_dma_src_pos": {
        "description": "This function retrieves the DMA source position.",
        "pre": {
            "lch": "!=null",
            "p": "!=null",
            "CDAC": "!=null",
            "CSAC": "!=null",
            "CSSA": "!=null",
            "offset": "!=null",
            "dma_omap15xx()": "returns true or false",
            "IS_DMA_ERRATA(DMA_ERRATA_3_3)": "returns true or false"
        },
        "post": {
            "offset": "is updated and returned"
        }
    }
},
{
    "kretprobe:omap_get_dma_dst_pos": {
        "description": "Get the DMA destination position.",
        "pre": {
            "!dma_omap15xx()": true,
            "offset": 0
        }
    }
},
{
    "kprobe:if (!dma_omap15xx() && offset == 0)": {
        "description": "Check if dma_omap15xx() is false and offset is equal to 0.",
        "pre": {
            "dma_omap15xx()": "== false",
            "offset": "== 0"
        }
    }
},


{
    "kretprobe:sx1_setbacklight": {
        "description": "Set the LCD backlight intensity.",
        "pre": {
            "backlight": "!=null"
        }
    }
},

{
    "kretprobe:sx1_getbacklight": {
        "description": "Get the current LCD backlight intensity.",
        "pre": {
            "backlight": "!=null",
            "backlight_value": ">=0",
            "backlight_value": "<=SOFIA_MAX_LIGHT_VAL"
        }
    }
},
{
    "kprobe:sx1_getbacklight": {
        "description": "Get current LCD backlight intensity",
        "pre": {
            "backlight": ">=0",
            "backlight": "<=255"
        }
    }
},


{
    "kretprobe:sx1_setusbpower": {
        "description": "set USB power on/off",
        "pre": {
            "onoff": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sx1_setusbpower": {
        "description": "set USB power on/off",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},

{
    "kprobe:if (fmrx(FPEXC) & FPEXC_EN)pr_crit(\"BUG: unsupported FP instruction in kernel mode\\n\");elsepr_crit(\"BUG: FP instruction issued in kernel mode with FP unit disabled\\n\");pr_crit(\"FPEXC == 0x%08x\\n\", fmrx(FPEXC));return 1;}static struct undef_hook vfp_kmode_exception_hook[] = ": {
        "description": "Kernel function for handling VFP mode exceptions in kernel mode.",
        "pre": {
            "fmrx(FPEXC) & FPEXC_EN": "!= 0",
            "fmrx(FPEXC)": "!= 0",
            "vfp_kmode_exception_hook": "!= null"
        }
    }
},
{
    "kretprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "pre": {
            "fmxr": {
                "arg1": "FPEXC",
                "arg2": "fmrx(FPEXC) & ~FPEXC_EN"
            },
            "local_bh_enable": "null"
        }
    }
},
{
    "kprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "pre": {
            "none": "none"
        }
    }
},

{
    "kprobe:index = c_start(&excd);continue;}if (c_id(&excd) == 0x80)": {
        "description": "Function to generate conditions for",
        "pre": {
            "cd": "!=null",
            "ec": "!=null",
            "id": "!=null",
            "num": "!=null"
        }
    }
},


{
    "kretprobe:wb977_open;__gpio_modify_io": {
        "description": "Close up the EFER gate",
        "pre": {
            "mask": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:wb977_open;__gpio_modify_io": {
        "description": "Open up the EFER gate",
        "pre": {
            "mask": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:ndelay": {
        "description": "Perform a delay for the specified number of nanoseconds.",
        "pre": {
            "nsecs": "!=null",
            "ncycles": "!=null",
            "ncycles >> NDELAY_SHIFT": "!=null"
        }
    }
},

{
    "kretprobe:WARN(!is_linear_mapping && !is_kernel_mapping)": {
        "description": "virt_to_phys used for non-linear address",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "__va_to_pa_nodebug(x)"
        }
    }
},
{
    "kprobe:WARN": {
        "description": "Check if virt_to_phys is used for a non-linear address",
        "pre": {
            "!is_linear_mapping(x) && !is_kernel_mapping(x)": "true"
        }
    },
    "kprobe:__va_to_pa_nodebug": {
        "description": "Return the physical address corresponding to the virtual address",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:VIRTUAL_BUG_ON": {
        "description": "Boundary checking against the kernel image mapping. __pa_symbol should only be used on kernel symbol addresses.",
        "pre": {
            "x": "!= null",
            "kernel_start": "!= null",
            "kernel_end": "!= null"
        },
        "post": {
            "return_value": "__va_to_pa_nodebug(x)"
        }
    }
},
{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Boundary checking against the kernel image mapping.",
        "pre": {
            "x": ">= kernel_start",
            "x": "<= kernel_end"
        }
    },
    "kretprobe:__va_to_pa_nodebug": {
        "description": "Convert virtual address to physical address without debugging information.",
        "pre": {
            "x": "!= null"
        }
    }
},
{
    "kretprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "pre": {
            "ch": "!=null"
        }
    }
},
{
    "kprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "pre": {
            "ch": "!=null"
        }
    }
},
{
    "kretprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device.",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "pre": {}
    }
},
{
    "kprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "pre": {}
    }
},


{
    "kretprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts.",
        "pre": {
            "cpu_mask": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts.",
        "pre": {
            "cpu_mask": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, error_code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        },
        "post": {
            "return": "in [0, error_code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "vmid": "!=null"
        },
        "post": {
            "return": "in [0, Error]"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "vmid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not.",
        "pre": {
            "extid": "!=null"
        }
    }
},
{
    "kprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not.",
        "pre": {
            "extid": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "skip ACPI PCI scan and IRQ initialization",
        "pre": {
            "return_value": "any"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "skip ACPI PCI scan and IRQ initialization",
        "pre": {}
    }
},
{
    "kretprobe:__udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "!=null"
        },
        "helper": {
            "function": "__const_udelay",
            "arguments": {
                "usecs": "!=null"
            }
        },
        "additional_info": {
            "constant_value": "0x10C7UL",
            "extra_info": "2  32  1000000 (rounded up)"
        }
    }
},
{
    "kprobe:__udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "!=null"
        }
    }
},



{
    "kprobe:flush_dcache_page": {
        "description": "Write back any data associated with the kernel mapping of the given page.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:addi": {
        "description": "Copy byte by byte for small copies and if src^dst != 0",
        "pre": {
            "r6": "!=null",
            "r2": "!=null",
            "r6": "!=r2",
            "r2": "!=0"
        }
    }
},
{
    "kprobe:raw_copy_to_user": {
        "description": "Copy byte by byte for small copies and if src^dst != 0",
        "pre": {
            "r2": "-1",
            "r6": "!= -1",
            "r4": "!= null",
            "r5": "!= null",
            "r2": ">= r6",
            "r2 ^ r4": "!= 0"
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range to a virtual address.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "size": ">0",
            "last_addr": ">=phys_addr",
            "return": "null if size==0 or last_addr<phys_addr"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Remap a memory area",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=0",
            "last_addr": ">=phys_addr",
            "last_addr": "<=MAX_ADDRESS_LIMIT",
            "remapped_area": "not overlapping with existing memory areas"
        }
    }
},
{
    "kretprobe:iounmap": {
        "description": "Unmaps the given I/O memory address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "Unmaps the given I/O memory address.",
        "pre": {
            "addr": "!=null"
        }
    }
},

{
    "kprobe:get_cycles": {
        "description": "Only read timer if it has been initialized",
        "pre": {
            "nios2_cs.timer.base": "!=null"
        }
    }
},


{
    "kretprobe:aes_ecb_encrypt": {
        "description": "AES ECB encryption",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    }
},
{
    "kprobe:aes_ecb_encrypt": {
        "description": "AES ECB encryption",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    }
},


{
    "kretprobe:vm_get_page_prot": {
        "description": "Returns the page protection value based on the given vm_flags.",
        "pre": {
            "vm_flags": "!=null",
            "vm_flags & VM_MTE": "== VM_MTE",
            "vma->vm_flags & VM_MTE_ALLOWED": "== VM_MTE_ALLOWED"
        }
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "Get the page protection value based on vm_flags.",
        "pre": {
            "vm_flags": "!=null",
            "prot": "!=null",
            "vm_flags & VM_MTE": "!=0",
            "prot |= PTE_ATTRINDX(MT_NORMAL_TAGGED)": "true",
            "return": "__pgprot(prot)"
        }
    }
},
{
    "kretprobe:memstart_addr": {
        "description": "Variable that holds the start address before initialization.",
        "pre": {
            "memstart_addr": "-1"
        }
    }
},
{
    "kprobe:memstart_addr": {
        "description": "Helper function to retrieve the start address of memory before initialization.",
        "pre": {
            "memstart_addr": "== -1"
        }
    }
},
{
    "kretprobe:pfn_is_map_memory": {
        "description": "Avoid false positives for bogus PFN see comment in pfn_valid().",
        "pre": {
            "pfn": "!=null"
        }
    }
},
{
    "kprobe:pfn_is_map_memory": {
        "description": "Check if the physical frame number (PFN) is associated with map memory.",
        "pre": {
            "addr": "!=null",
            "pfn": "!=null",
            "PHYS_PFN(addr)": "!=pfn",
            "memblock_is_map_memory(addr)": "==1"
        }
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "Flush the dcache for a page",
        "pre": {
            "PageHuge(page)": true,
            "compound_head(page)": "page != null",
            "test_bit(PG_dcache_clean, &page->flags)": true,
            "clear_bit(PG_dcache_clean, &page->flags)": true
        }
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "Flush the data cache for a given page.",
        "pre": {
            "page": "!=null",
            "PageHuge(page)": "true",
            "compound_head(page)": "!=null",
            "test_bit(PG_dcache_clean, &page->flags)": "true",
            "clear_bit(PG_dcache_clean, &page->flags)": "true"
        }
    }
},


{
    "kretprobe:WARN_ON_ONCE(!try_page_mte_tagging)": {
        "description": "Check if try_page_mte_tagging(to) returns false and trigger a warning if it does.",
        "pre": {
            "to": "!=null"
        }
    },
    "kretprobe:mte_copy_page_tags": {
        "description": "Copy the memory tags from page 'from' to page 'to'.",
        "pre": {
            "kto": "!=null",
            "kfrom": "!=null"
        }
    },
    "kretprobe:set_page_mte_tagged": {
        "description": "Set the MTE tag for page 'to'.",
        "pre": {
            "to": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(copy_highpage)": {
        "description": "Export the 'copy_highpage' function symbol.",
        "pre": {}
    }
},
{
    "kprobe:WARN_ON_ONCE(!try_page_mte_tagging)": {
        "description": "Check if try_page_mte_tagging(to) returns false and raise a warning if it does.",
        "pre": {
            "to": "!=null"
        }
    },
    "kprobe:mte_copy_page_tags": {
        "description": "Copy the memory tags from page 'from' to page 'to'.",
        "pre": {
            "kto": "!=null",
            "kfrom": "!=null"
        }
    },
    "kprobe:set_page_mte_tagged": {
        "description": "Set the MTE tag for page 'to'.",
        "pre": {
            "to": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(copy_highpage)": {
        "description": "Export the 'copy_highpage' function symbol.",
        "pre": {}
    }
},

{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Bounds checking against the kernel image only.",
        "pre": {
            "x": ">= (unsigned long) KERNEL_START",
            "x": "<= (unsigned long) KERNEL_END"
        }
    }
},
{
    "kretprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header for architecture-specific operations.",
        "pre": {
            "addr": "!=null",
            "max_size": ">= sizeof(struct arch_hibernate_hdr)",
            "hdr": {
                "invariants": "valid",
                "ttbr1_el1": "__pa_symbol(swapper_pg_dir)",
                "reenter_kernel": "_cpu_resume"
            }
        }
    }
},
{
    "kprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header for architecture-specific operations.",
        "pre": {
            "addr": "!=null",
            "max_size": ">=sizeof(struct arch_hibernate_hdr)",
            "hdr->invariants": "valid",
            "hdr->ttbr1_el1": "__pa_symbol(swapper_pg_dir)",
            "hdr->reenter_kernel": "_cpu_resume"
        }
    }
},


{
    "kretprobe:arch_local_irq_disable": {
        "description": "Disables local interrupts on the current CPU.",
        "pre": {
            "preempt_disable_notrace": "called",
            "__asm__ __volatile__": "contains '.setpush', '.setnoat', 'mfc0$1,$12', 'ori$1,0x1f', 'xori$1,0x1f', '.setnoreorder', 'mtc0$1,$12', '__irq_disable_hazard', '.setpop'",
            "no outputs": "true"
        }
    }
},

{
    "kretprobe:arch_local_irq_save": {
        "description": "Save the value of the flags register.",
        "pre": {
            "preempt_disable_notrace": true,
            "inline_asm_save_flags": true,
            "inline_asm_set_flags": true
        },
        "post": {
            "flags": "!=null"
        }
    }
},

{
    "kretprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:EXPORT_SYMBOL(shm_align_mask)": {
        "description": "Helper function to calculate the alignment mask for shared memory.",
        "pre": {
            "shm_align_mask": "= PAGE_SIZE - 1",
            "PAGE_SIZE": "> 0",
            "shm_align_mask": "<= PAGE_SIZE - 1"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(shm_align_mask)": {
        "description": "Calculate the alignment mask for shared memory.",
        "pre": {
            "PAGE_SIZE": "!=null",
            "result": ">=0",
            "result": "<=PAGE_SIZE - 1"
        }
    }
},


{
    "kretprobe:has_transparent_hugepage": {
        "description": "Check if transparent huge pages are enabled.",
        "pre": {
            "mask": "== -1"
        },
        "post": {
            "mask": "== PM_HUGE_MASK"
        }
    }
},
{
    "kprobe:has_transparent_hugepage": {
        "description": "Check if transparent huge pages are enabled.",
        "pre": {
            "flags": "!=null",
            "mask": "!=null",
            "PM_HUGE_MASK": "!=null",
            "PM_DEFAULT_MASK": "!=null"
        }
    }
},




{
    "kretprobe:__flush_dcache_page": {
        "description": "__flush_dcache_page function",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "addr": "!=null",
            "!mapping_mapped(mapping)": "true",
            "PageHighMem(page)": "true"
        }
    }
},
{
    "kprobe:__flush_dcache_page": {
        "description": "__flush_dcache_page function",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space with control over cache coherency attributes (CCA).",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot_val": "!=null"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot_val": "!=null"
        }
    }
},
{
    "kretprobe:for (e1 = bcm47xx_board_list_melco_id; e1->value1; e1++)": {
        "description": "Iterate over the bcm47xx_board_list_melco_id array.",
        "pre": {
            "e1": "!=null",
            "e1->value1": "!=null"
        }
    }
},
{
    "kprobe:bcm47xx_board_list_melco_id": {
        "description": "Iterate over the bcm47xx_board_list_melco_id and perform operations on each element.",
        "pre": {
            "e1": "!=null",
            "e1->value1": "!=null"
        }
    }
},


{
    "kretprobe:octeon_is_simulation": {
        "description": "Return non-zero if running in the Octeon simulator, 0 otherwise.",
        "pre": {},
        "ret": "in [0, !=0]"
    }
},
{
    "kprobe:octeon_is_simulation": {
        "description": "Return non-zero if we are currently running in the Octeon simulator.",
        "pre": {
            "return_value": "!=0"
        }
    }
},
{
    "kretprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon",
        "pre": {},
        "post": {
            "return": ">0"
        }
    }
},
{
    "kprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon",
        "pre": {
            "return": "!=null"
        }
    }
},


{
    "kretprobe:octeon_ndelay_factor": {
        "description": "Calculate the octeon_ndelay_factor",
        "pre": {
            "octeon_udelay_factor": "!=null",
            "octeon_get_clock_rate()": "!=null",
            "HZ": "!=0",
            "current_cpu_type()": "==CPU_CAVIUM_OCTEON2"
        }
    }
},
{
    "kprobe:octeon_ndelay_factor": {
        "description": "Calculate the ndelay factor based on the udelay factor and clock rate.",
        "pre": {
            "octeon_udelay_factor": "!=null",
            "octeon_get_clock_rate()": "!=null",
            "HZ": "!=null",
            "current_cpu_type()": "== CPU_CAVIUM_OCTEON2"
        }
    }
},
{
    "kretprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass.",
        "pre": {
            "count": ">= 0"
        }
    }
},
{
    "kprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass.",
        "pre": {
            "count": ">=0"
        }
    }
},


{
    "kretprobe:if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))": {
        "description": "Condition for the given if statement",
        "pre": {
            "device": "PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        }
    }
},
{
    "kprobe:if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))": {
        "description": "_wrmsr() to access the registers PCI_MSR_ADDR, PCI_MSR_DATA_LO, PCI_MSR_DATA_HI, which is bigger than PCI_MSR_CTRL, so it will not go this branch, but the others. So, no calling dead loop here.",
        "pre": {
            "device": "== PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        }
    }
},


{
    "kretprobe:outb": {
        "description": "Write the value 0x0B to the PIC_MASTER_ISR register.",
        "pre": {
            "PIC_MASTER_ISR": "!=null",
            "PIC_MASTER_CMD": "!=null",
            "PIC_MASTER_IMR": "!=null",
            "PIC_CASCADE_IR": "!=null"
        }
    }
},
{
    "kprobe:outb": {
        "description": "Write the value 0x0B to the PIC_MASTER_ISR register.",
        "pre": {
            "PIC_MASTER_ISR": "!=null"
        }
    }
},
{
    "kretprobe:loongson_uart_base": {
        "description": "Ioremapped base address for Loongson UART",
        "pre": {
            "_loongson_uart_base": "!=null"
        }
    }
},
{
    "kprobe:loongson_uart_base": {
        "description": "Ioremapped base address for Loongson UART",
        "pre": {
            "base_address": "!=null"
        }
    }
},
{
    "kretprobe:mips_io_port_base": {
        "description": "mips_io_port_base is the begin of the address space to which x86 style IO ports are mapped.",
        "pre": {
            "mips_io_port_base": "!=null"
        }
    }
},
{
    "kprobe:mips_io_port_base": {
        "description": "mips_io_port_base is the begin of the address space to which x86 style IO ports are mapped.",
        "pre": {
            "mips_io_port_base": "!=null"
        }
    }
},




{
    "kretprobe:unwind_stack_by_address": {
        "description": "Unwind the stack by address.",
        "pre": {
            "stack_page": "!=null",
            "sp": "!=null",
            "pc": "!=null",
            "ra": "!=null",
            "low": "!=null",
            "high": "!=null",
            "irq_stack_high": "!=null",
            "info": "!=null",
            "size": "!=null",
            "ofs": "!=null",
            "regs": "!=null",
            "leaf": "!=null",
            "preemptible()": "false",
            "on_irq_stack(raw_smp_processor_id(), *sp)": "true"
        }
    }
},
{
    "kprobe:unwind_stack_by_address": {
        "description": "Unwind the stack by address.",
        "pre": {
            "stack_page": "!=null",
            "sp": "!=null",
            "pc": "!=null",
            "ra": "!=null",
            "low": "!=null",
            "preemptible()": "false",
            "on_irq_stack(raw_smp_processor_id(), *sp)": "true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical CPU numbers to logical CPU numbers.",
        "pre": {
            "map": "!=null",
            "key": ">=0 && <NR_CPUS",
            "value": ">=0",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical CPU numbers to logical CPU numbers.",
        "pre": {
            "map": "!=null",
            "key": ">=0",
            "key": "<NR_CPUS",
            "value": ">=0",
            "value": "<NR_CPUS"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical CPUs to physical CPUs",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical CPUs to physical CPUs.",
        "pre": {
            "map": "!=null",
            "key": ">=0",
            "key": "<NR_CPUS",
            "value": ">=0",
            "value": "<NR_CPUS"
        }
    }
},
{
    "kretprobe:flush_tlb_one_ipi": {
        "description": "Flushes the TLB for a specific page.",
        "pre": {
            "cpu": "!= smp_processor_id()",
            "cpu_context(cpu, vma->vm_mm)": "true",
            "set_cpu_context(cpu, vma->vm_mm, 1)": "true",
            "local_flush_tlb_page(vma, page)": "true",
            "preempt_enable()": "true"
        }
    }
},
{
    "kprobe:flush_tlb_one_ipi": {
        "description": "Flush the TLB for a specific page using an IPI (Inter-Processor Interrupt).",
        "pre": {
            "cpu": "!= smp_processor_id()",
            "cpu_context(cpu, vma->vm_mm)": "true",
            "set_cpu_context(cpu, vma->vm_mm, 1)": "true",
            "local_flush_tlb_page(vma, page)": "true",
            "preempt_enable()": "true"
        }
    }
},


{
    "kretprobe:request_au1000_dma": {
        "description": "Request AU1000 DMA channel",
        "pre": {
            "dev_id": ">= 0",
            "dev_str": "!= null",
            "irqhandler": "null or valid function",
            "irqflags": "valid flags",
            "irq_dev_id": "valid value"
        },
        "post": {
            "chan->io": "(void __iomem *)(KSEG1ADDR(AU1000_DMA_PHYS_ADDR) + i * DMA_CHANNEL_LEN)",
            "chan->dev_id": "dev_id",
            "chan->dev_str": "dev_str",
            "chan->fifo_addr": "dev->fifo_addr",
            "chan->mode": "dev->dma_mode"
        }
    }
},
{
    "kprobe:chan->io": {
        "description": "Assign the value of (void __iomem *)(KSEG1ADDR(AU1000_DMA_PHYS_ADDR) +i * DMA_CHANNEL_LEN) to chan->io.",
        "pre": {
            "i": ">= 0",
            "dev_id": ">= 0",
            "dev_str": "!= null",
            "dev->fifo_addr": "!= null",
            "dev->dma_mode": "!= null"
        }
    },
    "kprobe:chan->dev_id": {
        "description": "Assign the value of dev_id to chan->dev_id.",
        "pre": {
            "dev_id": ">= 0"
        }
    },
    "kprobe:chan->dev_str": {
        "description": "Assign the value of dev_str to chan->dev_str.",
        "pre": {
            "dev_str": "!= null"
        }
    },
    "kprobe:chan->fifo_addr": {
        "description": "Assign the value of dev->fifo_addr to chan->fifo_addr.",
        "pre": {
            "dev->fifo_addr": "!= null"
        }
    },
    "kprobe:chan->mode": {
        "description": "Assign the value of dev->dma_mode to chan->mode.",
        "pre": {
            "dev->dma_mode": "!= null"
        }
    }
},

{
    "kprobe:if (!dbdma_initialized)return 0;stp = find_dbdev_id(srcid);if (stp == NULL)return 0;dtp = find_dbdev_id(destid);if (dtp == NULL)return 0;used = 0;/* Check to see if we can get both channels. `": {
        "description": "Function if (!dbdma_initialized)return 0;stp = find_dbdev_id(srcid);if (stp == NULL)return 0;dtp = find_dbdev_id(destid);if (dtp == NULL)return 0;used = 0;/* Check to see if we can get both channels. `",
        "pre": {
            "dbdma_initialized": "==false",
            "srcid": "!=null",
            "find_dbdev_id(srcid)": "!=null",
            "destid": "!=null",
            "find_dbdev_id(destid)": "!=null",
            "used": "==0"
        }
    }
},


{
    "kretprobe:ctp = *((chan_tab_t **)chanid);stp = ctp->chan_src;dtp = ctp->chan_dest;/* * The descriptors must be 32-byte aligned.  There is a * possibility the allocation will give us such an addres * and if we try that first we are likely to not waste larger * slabs of memory. ": {
        "description": "Allocate a ring buffer for the specified channel ID.",
        "pre": {
            "chanid": "!=null",
            "entries": ">= 0"
        },
        "post": {
            "ctp": "!=null",
            "stp": "!=null",
            "dtp": "!=null",
            "ctp->chan_src": "32-byte aligned",
            "ctp->chan_dest": "32-byte aligned"
        }
    }
},
{
    "kprobe:au1xxx_dbdma_ring_alloc": {
        "description": "Allocate a ring buffer for the specified channel ID.",
        "pre": {
            "chanid": "!=null",
            "entries": "!=null",
            "ctp": "!=null",
            "stp": "!=null",
            "dtp": "!=null",
            "ctp->chan_src": "!=null",
            "ctp->chan_dest": "!=null",
            "ctp->chan_src % 32": "==0",
            "ctp->chan_dest % 32": "==0"
        }
    }
},








{
    "kretprobe:bcm63xx_set_cs_base": {
        "description": "bcm63xx_set_cs_base(unsigned int c u32 base, unsigned int size) - sanity check on size",
        "pre": {
            "cs": "!=null",
            "base": "!=null",
            "size": "!=null",
            "size != roundup_pow_of_two(size)": true,
            "size < 8 * 1024 || size > 256 * 1024 * 1024": true,
            "val = (base & MPI_CSBASE_BASE_MASK)": true
        }
    }
},
{
    "kprobe:bcm63xx_set_cs_base": {
        "description": "bcm63xx_set_cs_base(unsigned int c u32 base, unsigned int size) - sanity check on size",
        "pre": {
            "cs": "!=null",
            "base": "!=null",
            "size": "!=null",
            "size != roundup_pow_of_two(size)": true,
            "size < 8 * 1024 || size > 256 * 1024 * 1024": true,
            "val = (base & MPI_CSBASE_BASE_MASK)": true
        }
    }
},
{
    "kretprobe:bcm63xx_set_cs_param": {
        "description": "Set the parameters for the given cs.",
        "pre": {
            "cs": "in [MPI_CS_PCMCIA_COMMON, MPI_CS_PCMCIA_ATTR, MPI_CS_PCMCIA_IO]",
            "params": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:bcm63xx_set_cs_param": {
        "description": "Set the parameters for the cs in bcm63xx.",
        "pre": {
            "cs": "in [MPI_CS_PCMCIA_COMMON, MPI_CS_PCMCIA_ATTR, MPI_CS_PCMCIA_IO]",
            "params": "!=null"
        }
    }
},
{
    "kretprobe:enet_misc_set": {
        "description": "Ethernet MAC \"misc\" clock: dma clocks and main clock on 6348",
        "pre": {
            "clk": "!=null",
            "enable": "!=null"
        }
    }
},



{
    "kretprobe:r4030_read_reg32": {
        "description": "Reads the value from the register at address JAZZ_R4030_CHNL_ENABLE + (channel << 5).",
        "pre": {
            "status": "!=null",
            "status": "& 0x400 != 0",
            "status": "& 0x200 != 0"
        }
    }
},
{
    "kprobe:r4030_read_reg32": {
        "description": "Read a 32-bit value from the register at the specified address.",
        "pre": {
            "channel": "is_integer"
        },
        "post": {
            "status": "is_integer",
            "status & 0x400": "!= 0",
            "status & 0x200": "!= 0"
        }
    }
},
{
    "kretprobe:vdma_disable": {
        "description": "Disable a DMA channel",
        "pre": {
            "channel": "!=null",
            "vdma_debug": "==true"
        },
        "post": {
            "r4030_read_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_MODE + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_ADDR + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_COUNT + (channel << 5))": "==0"
        }
    }
},
{
    "kprobe:vdma_disable": {
        "description": "Disable a DMA channel and ensure completion of the current DMA acknowledge cycle.",
        "pre": {
            "channel": "!=null"
        }
    }
},






{
    "kretprobe:smp_wmb();}EXPORT_SYMBOL(copy_user_highpage": {
        "description": "Make sure this page is cleared on other CPU's too before using it",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "!=null",
            "vma": "!=null",
            "vfrom": "!=null",
            "vto": "!=null",
            "boot_cpu_data.dcache.n_aliases": "==true",
            "page_mapcount(from)": "!=0",
            "test_bit(PG_dcache_clean, &from->flags)": "==true",
            "pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK)": "==true",
            "(vma->vm_flags & VM_EXEC)": "==true"
        }
    }
},
{
    "kprobe:smp_wmb();}EXPORT_SYMBOL(copy_user_highpage": {
        "description": "Make sure this page is cleared on other CPU's too before using it",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "!=null",
            "vma": "!=null",
            "vfrom": "!=null",
            "vto": "!=null",
            "boot_cpu_data.dcache.n_aliases": "==true",
            "page_mapcount(from)": "!=0",
            "test_bit(PG_dcache_clean, &from->flags)": "==true",
            "pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK)": "==true",
            "(vma->vm_flags & VM_EXEC)": "==true"
        }
    }
},


{
    "kretprobe:__ioremap_caller": {
        "description": "Remap an I/O memory range into the kernel's virtual memory space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=0",
            "pgprot": "!=null",
            "caller": "!=null"
        },
        "post": {
            "last_addr": "= phys_addr + size - 1",
            "!size || last_addr < phys_addr": "return null"
        }
    }
},
{
    "kprobe:__ioremap_caller": {
        "description": "Remap an I/O memory range into the kernel's virtual memory space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "pgprot": "!=null",
            "caller": "!=null",
            "area": "!=null",
            "offset": "!=null",
            "last_addr": "!=null",
            "addr": "!=null",
            "orig_addr": "!=null",
            "mapped": "!=null"
        },
        "post": {
            "mapped": "!=null"
        },
        "additional_conditions": [
            "size != 0",
            "last_addr >= phys_addr"
        ]
    }
},



{
    "kprobe:list_for_each_entry": {
        "description": "Iterate over a list of dma_info objects",
        "pre": {
            "info": "!=null",
            "&registered_dmac_list": "!=null",
            "list": "!=null",
            "chan": "unsigned int"
        }
    }
},
{
    "kretprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:register_dmac": {
        "description": "Check if DMAC_CHANNELS_CONFIGURED flag is not set",
        "pre": {
            "info->flags": "& ~DMAC_CHANNELS_CONFIGURED == 0"
        }
    }
},
{
    "kprobe:register_dmac": {
        "description": "Register DMAC handler.",
        "pre": {
            "info->flags": "& DMAC_CHANNELS_CONFIGURED == 0"
        }
    }
},

{
    "kprobe:pcibios_scanbus": {
        "description": "Scan the PCI bus and initialize the PCI controller.",
        "pre": {
            "hose_head": "!=null",
            "hose_tail": "!=null",
            "pci_initialized": "!=null"
        }
    }
},

{
    "kprobe:sh_machine_vector": {
        "description": "Initialization of sh_machine_vector structure",
        "pre": {
            "sh_mv": "=null"
        }
    }
},




{
    "kretprobe:memcpy_fromio": {
        "description": "Copy data from an I/O memory location to a regular memory location.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">= 0x20",
            "to & 0x1f": "== 0",
            "from & 0x3": "== 0"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Copy data from an I/O memory location to a regular memory location.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">= 0x20",
            "to & 0x1f": "== 0",
            "from & 0x3": "== 0"
        }
    }
},
{
    "kretprobe:sq_flush_range": {
        "description": "Flush (prefetch) a specific SQ range",
        "pre": {
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:sq_flush_range": {
        "description": "Flush (prefetch) a specific SQ range",
        "pre": {
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:sq_remap": {
        "description": "Map a physical address through the Store Queues.",
        "pre": {
            "map": "!=null",
            "prot": "!=null",
            "map->size": ">0",
            "map->sq_addr": "!=null",
            "map->addr": "!=null",
            "map->addr >> 26": ">=0",
            "((map->addr >> 26) << 2) & 0x1c": ">=0",
            "SQ_QACR0": "!=null",
            "SQ_QACR1": "!=null"
        }
    }
},
{
    "kprobe:sq_remap": {
        "description": "Map a physical address through the Store Queues",
        "pre": {
            "map": "!=null",
            "prot": "!=null",
            "map->size": ">0",
            "map->sq_addr": "!=null",
            "map->addr": "!=null"
        }
    }
},
{
    "kretprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kretprobe:kasan_map_memory": {
        "description": "The kasan_map_memory function maps all of the required address space and the host machine will allocate physical memory as necessary.",
        "pre": {
            "address": "== (void *)KASAN_SHADOW_START",
            "size": "== KASAN_SHADOW_SIZE"
        },
        "post": {
            "kasan_um_is_ready": "== true"
        }
    }
},
{
    "kprobe:kasan_map_memory": {
        "description": "The kasan_map_memory function maps all of the required address space and the host machine will allocate physical memory as necessary.",
        "pre": {
            "address": "== (void *)KASAN_SHADOW_START",
            "size": "== KASAN_SHADOW_SIZE"
        }
    }
},
{
    "kretprobe:free_irq_by_fd": {
        "description": "Free the interrupt request line associated with the given file descriptor.",
        "pre": {
            "fd": "!=null"
        }
    }
},

{
    "kretprobe:setup_physmem": {
        "description": "Setup physical memory for UML",
        "pre": {
            "start": "!=null",
            "reserve_end": "!=null",
            "len": "!=null",
            "highmem": "!=null"
        }
    }
},
{
    "kprobe:setup_physmem": {
        "description": "Setup physical memory for UML",
        "pre": {
            "start": "!=null",
            "reserve_end": "!=null",
            "len": "!=null",
            "highmem": "!=null"
        }
    }
},
{
    "kretprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "pre": {
            "op": "!=null",
            "oparg": "!=null",
            "oval": "!=null",
            "uaddr": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN, -ENOSYS]"
        }
    }
},
{
    "kprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "pre": {
            "op": "!=null",
            "oparg": "!=null",
            "oval": "!=null",
            "uaddr": "!=null"
        }
    }
},
{
    "kretprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval.",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "!=null",
            "newval": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN]"
        }
    }
},
{
    "kprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval.",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "!=null",
            "newval": "!=null"
        }
    }
},
{
    "kretprobe:__raw_readsw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__raw_readsw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__raw_writesw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__raw_writesw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:csum_tcpudp_nofold": {
        "description": "Calculate the checksum for TCP/UDP packets without folding.",
        "pre": {
            "saddr": "!=null",
            "daddr": "!=null",
            "len": "!=null",
            "proto": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:csum_tcpudp_nofold": {
        "description": "Calculate the checksum for TCP/UDP packets without folding down to 32-bits.",
        "pre": {
            "saddr": "!=null",
            "daddr": "!=null",
            "len": "!=null",
            "proto": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:while (count--)": {
        "description": "Iterate `count` number of times and perform operations on the source if it is not 32-bit aligned.",
        "pre": {
            "count": ">= 0",
            "src": "!= null",
            "port": "!= null"
        },
        "post": {
            "src": {
                "if": "(unsigned long)src & 0x3 != 0",
                "then": "src += 4"
            },
            "port": {
                "if": "(unsigned long)src & 0x3 != 0",
                "then": "iowrite32(((struct S)src)->x, port)"
            }
        }
    }
},
{
    "while (count--)": {
        "pre": {
            "count": ">= 0",
            "src": "!= null",
            "src": "32-bit aligned"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmap I/O memory previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Nothing to do",
        "pre": {
            "dev": "any",
            "addr": "any"
        }
    }
},
{
    "kretprobe:__prom_getchild": {
        "description": "Helper function that does not alter return values.",
        "pre": {},
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__prom_getchild": {
        "description": "prom_getchild that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:__prom_getsibling": {
        "description": "Function that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:__prom_getsibling": {
        "description": "Helper function that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:prom_nodeops->no_getprop": {
        "description": "Get a property value from a device tree node.",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": ">0"
        }
    },
    "kretprobe:restore_current": {
        "description": "Restore the current task.",
        "pre": {}
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Return the value of 'ret' variable.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Lock the spinlock and save the IRQ state.",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": "!=null"
        }
    }
},
{
    "kretprobe:prom_searchsiblings": {
        "description": "Search for siblings of a given node in the device tree.",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null",
            "thisnode": "!=null",
            "error": "int",
            "promlib_buf": "char[128]"
        },
        "post": {
            "return": "int",
            "error": "== -1",
            "nodename": "== promlib_buf"
        }
    }
},
{
    "kprobe:prom_searchsiblings": {
        "description": "Search for siblings of a given node in the device tree.",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null",
            "error": "== -1",
            "promlib_buf": "!=null"
        }
    }
},
{
    "kretprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        }
    }
},
{
    "kretprobe:prom_getchild": {
        "description": "Get the child node of the given node.",
        "pre": {
            "node": "!=null"
        }
    },
    "kretprobe:prom_searchsiblings": {
        "description": "Search for the sibling node of the given node with the specified name.",
        "pre": {
            "node": "!=null",
            "nbuf": "!=null"
        }
    },
    "kretprobe:return_0": {
        "description": "Return 0 if the node is null.",
        "pre": {
            "node": "==null"
        }
    },
    "kretprobe:return_1": {
        "description": "Return 1 if the character at the current position is '@'.",
        "pre": {
            "s": "==\"@\""
        }
    }
},
{
    "kprobe:prom_getchild": {
        "description": "Get the child node of the given node.",
        "pre": {
            "node": "!=null"
        }
    },
    "kprobe:prom_searchsiblings": {
        "description": "Search for siblings of the given node using the provided name.",
        "pre": {
            "node": "!=null",
            "nbuf": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return statement.",
        "pre": {
            "node": "==null"
        }
    },
    "kprobe:prom_finddevice": {
        "description": "Find a device with the given name.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'.",
        "pre": {
            "node": "!=null",
            "buffer": "!=null",
            "buffer_length": ">=32"
        }
    }
},
{
    "kprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'.",
        "pre": {
            "node": "!=null",
            "buffer": "!=null",
            "buffer_length": ">=32"
        }
    }
},








{
    "kretprobe:mmu_info": {
        "description": "Print MMU information",
        "pre": {
            "m": "!=null",
            "tlb_type": "in [cheetah, cheetah_plu spitfire, hypervisor]",
            "pgsz_strings": "!=null",
            "cpu_pgsz_mask": "!=null",
            "CONFIG_DEBUG_DCFLUSH": "defined",
            "dcpage_flushes": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:#endif /* CONFIG_DEBUG_DCFLUSH `": {
        "description": "Flush the instruction cache.",
        "pre": {
            "tlb_type": "in [cheetah, cheetah_plu spitfire, hypervisor]",
            "cpu_pgsz_mask": "!=null",
            "dcpage_flushes": "!=null"
        }
    }
},




{
    "kretprobe:reduce_memory": {
        "description": "Reduce memory and exclude reserved regions",
        "pre": {
            "limit_ram": "!=null",
            "exclude_regions": ["vmlinux", "initrd"],
            "lower_limit": "initrd_size"
        }
    }
},





{
    "kretprobe:vio_vdev_node": {
        "description": "Find VDEV node in MD",
        "pre": {
            "hp": "!=null",
            "vdev": "!=null"
        }
    }
},





{
    "kretprobe:ent->err_handle = 0;wmb();put_cpu();if (local_copy.err_type == SUN4V_ERR_TYPE_SHUTDOWN_RQST)": {
        "description": "Check if the err_type field of local_copy is equal to SUN4V_ERR_TYPE_SHUTDOWN_RQST",
        "pre": {},
        "post": {
            "local_copy.err_type": "== SUN4V_ERR_TYPE_SHUTDOWN_RQST"
        }
    }
},
{
    "kprobe:ent->err_handle = 0;wmb();put_cpu();if (local_copy.err_type == SUN4V_ERR_TYPE_SHUTDOWN_RQST)": {
        "description": "Set err_handle to 0, perform a write memory barrier, release the CPU, and check if err_type is SUN4V_ERR_TYPE_SHUTDOWN_RQST.",
        "pre": {
            "local_copy.err_type": "== SUN4V_ERR_TYPE_SHUTDOWN_RQST"
        }
    }
},
{
    "kretprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "pre": {
            "vio": "!=null",
            "tp": "!=null",
            "tp->type": "== VIO_TYPE_CTRL",
            "tp->stype": "== VIO_SUBTYPE_INFO",
            "tp->stype_env": "== VIO_VER_INFO"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "pre": {
            "vio": "!=null",
            "tp": "!=null",
            "tp->type": "== VIO_TYPE_CTRL",
            "tp->stype": "== VIO_SUBTYPE_INFO",
            "tp->stype_env": "== VIO_VER_INFO"
        },
        "post": {
            "return": "== 0"
        }
    }
},






{
    "kretprobe:floppy_irq": {
        "description": "Set the value of floppy_irq to irq and calculate cpu_irq.",
        "pre": {
            "irq": "!=null",
            "NR_IRQS": "!=null",
            "floppy_irq": "irq",
            "cpu_irq": "(irq & (NR_IRQS - 1))"
        }
    }
},
{
    "kprobe:floppy_irq": {
        "description": "Assign the value of 'irq' to 'floppy_irq' and calculate 'cpu_irq' based on 'irq' and 'NR_IRQS'.",
        "pre": {
            "irq": "!=null",
            "NR_IRQS": "!=null",
            "floppy_irq": "!=null",
            "cpu_irq": "!=null"
        }
    }
},
{
    "kretprobe:atomic_t_nmi_active": {
        "description": "Initialize the atomic_t variable nmi_active with the value 0.",
        "pre": {
            "nmi_active": "==0"
        }
    }
},
{
    "kprobe:atomic_t_nmi_active": {
        "description": "Helper for the atomic_t nmi_active variable.",
        "pre": {
            "nmi_active": ">0 or <0 or 0"
        }
    }
},
{
    "kretprobe:__ldc_channel_exists": {
        "description": "Check if a channel with a given ID already exists in the ldc_channel_list.",
        "pre": {
            "ldc_channel_list": "!=null",
            "id": "unsigned long",
            "mutex": "exists",
            "spinlock": "exists"
        }
    }
},
{
    "kprobe:__ldc_channel_exists": {
        "description": "Check if a channel with the given ID exists in ldc_channel_list.",
        "pre": {
            "ldc_channel_list": "initialized",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:ldc_bind": {
        "description": "Bind an LDC channel",
        "pre": {
            "lp": {
                "state": "== LDC_STATE_INIT"
            }
        },
        "post": {
            "lp": {
                "hs_state": "== LDC_HS_COMPLETE"
            },
            "flags": "&= ~LDC_FLAG_REGISTERED_QUEUES",
            "cfg": {
                "rx_irq": "enable_irq",
                "tx_irq": "enable_irq",
                "mode": "!= LDC_MODE_RAW"
            }
        }
    }
},
{
    "kprobe:ldc_bind": {
        "description": "Binds an LDC channel",
        "pre": {
            "lp": {
                "state": "== LDC_STATE_INIT"
            }
        }
    }
},






{
    "kretprobe:if (lp->hs_state == LDC_HS_COMPLETE)": {
        "description": "Check if the value of lp->hs_state is equal to LDC_HS_COMPLETE.",
        "pre": {
            "lp": "!=null",
            "lp->hs_state": "== LDC_HS_COMPLETE"
        }
    }
},

{
    "kretprobe:ldc_copy": {
        "description": "Copy data using the ldc_copy helper function.",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": "!=null",
            "offset": "!=null",
            "cookies": "!=null",
            "ncookies": "!=null",
            "ra": "aligned to 8 bytes",
            "lp->hs_state": "== LDC_HS_COMPLETE",
            "lp->flags": "not set LDC_FLAG_RESET"
        },
        "post": {
            "return": "orig_len - len"
        }
    }
},
{
    "kprobe:return orig_len - len;}EXPORT_SYMBOL(ldc_copy": {
        "description": "Calculate the difference between orig_len and len and return the result.",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": "!=null",
            "offset": "!=null",
            "cookies": "!=null",
            "ncookies": "!=null"
        }
    }
},
{
    "kretprobe:set_auxio": {
        "description": "Set the AUXIO register with the given bits on and off.",
        "pre": {
            "bits_on": "!=null",
            "bits_off": "!=null",
            "auxio_register": "!=null",
            "sparc_cpu_model": "==sun4m"
        }
    }
},
{
    "kprobe:set_auxio": {
        "description": "Set the AUXIO register with the given bits.",
        "pre": {
            "bits_on": "!=null",
            "bits_off": "!=null"
        }
    }
},
{
    "kretprobe:get_area": {
        "description": "Get the unmapped area for a file.",
        "pre": {
            "filp": "!=null",
            "orig_addr": "==null",
            "len": "!=null",
            "pgoff": "!=null",
            "flags": "!=null",
            "align_goal": "in [PAGE_SIZE, 4UL * 1024 * 1024, 512UL * 1024, 64UL * 1024]"
        }
    }
},
{
    "kprobe:get_area": {
        "description": "Helper function to get the unmapped area for a file.",
        "pre": {
            "filp": "!=null",
            "orig_addr": "==null",
            "len": "!=null",
            "pgoff": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:_map_to_cpu": {
        "description": "This function maps an index to a CPU.",
        "pre": {
            "index": "!=null",
            "num_online_cpus()": "<= num_possible_cpus()",
            "cpu_online(cpu_rover)": "true",
            "cpu_rover": "< end",
            "cpu_rover": ">= 0",
            "cpu_rover": "< num_possible_cpus()",
            "cpu_rover": "!= null",
            "end": "<= num_online_cpus()",
            "i": ">= 0",
            "i": "< num_possible_cpus()"
        }
    }
},
{
    "kprobe:return cpumask_first(cpu_online_mask);}static int _map_to_cpu(unsigned int index)": {
        "description": "This function maps an index to a CPU.",
        "pre": {
            "index": "!=null",
            "index": ">= 0",
            "index": "< num_possible_cpus()",
            "num_online_cpus()": "<= num_possible_cpus()"
        }
    }
},
{
    "kretprobe:pci_set_master": {
        "description": "Set the master bit for the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->class": "PCI_CLASS_STORAGE_IDE << 8",
            "dev->current_state": "PCI_UNKNOWN"
        }
    }
},
{
    "kprobe:pci_set_master": {
        "description": "Set the master bit for the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->class": "PCI_CLASS_STORAGE_IDE << 8",
            "dev->current_state": "PCI_UNKNOWN"
        }
    }
},


{
    "kretprobe:mdesc_get_node_ops": {
        "description": "Find the get_info op for the given node name",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        }
    }
},
{
    "kprobe:mdesc_get_node_ops": {
        "description": "Find the get_info op for the given node name",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        }
    }
},
{
    "kretprobe:idp = mdesc_get_property": {
        "description": "Get the value of the 'id' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "idp": "!=null"
        }
    },
    "kretprobe:name = mdesc_get_property": {
        "description": "Get the value of the 'name' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "name": "!=null"
        }
    },
    "kretprobe:parent_cfg_hdlp = parent_cfg_handle": {
        "description": "Get the value of the 'parent_cfg_hdl' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "parent_cfg_hdlp": "!=null"
        }
    },
    "kretprobe:!idp || !name || !parent_cfg_hdlp": {
        "description": "Check if any of the variables 'idp', 'name', or 'parent_cfg_hdlp' is null.",
        "pre": {
            "idp": "!=null",
            "name": "!=null",
            "parent_cfg_hdlp": "!=null"
        },
        "post": {
            "return": "-1"
        }
    },
    "kretprobe:node_info->vdev_port.id = *idp": {
        "description": "Assign the value of 'idp' to 'node_info->vdev_port.id'.",
        "pre": {
            "idp": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:node_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL)": {
        "description": "Assign the value of 'name' to 'node_info->vdev_port.name' using 'kstrdup_const' function.",
        "pre": {
            "name": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:!node_info->vdev_port.name": {
        "description": "Check if 'node_info->vdev_port.name' is null.",
        "pre": {
            "node_info": "!=null"
        },
        "post": {
            "return": "-1"
        }
    },
    "kretprobe:node_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp": {
        "description": "Assign the value of 'parent_cfg_hdlp' to 'node_info->vdev_port.parent_cfg_hdl'.",
        "pre": {
            "parent_cfg_hdlp": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:return 0": {
        "description": "Return 0 to indicate successful execution of the function."
    },
    "kretprobe:rel_vdev_port_node_info": {
        "description": "Release the memory allocated for 'node_info'.",
        "pre": {
            "node_info": "!=null"
        }
    }
},
{
    "kprobe:idp = mdesc_get_property(md, node, \"id\", NULL);name = mdesc_get_property(md, node, \"name\", NULL);parent_cfg_hdlp = parent_cfg_handle(md, node);if (!idp || !name || !parent_cfg_hdlp)return -1;node_info->vdev_port.id = *idp;node_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);if (!node_info->vdev_port.name)return -1;node_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;return 0;}static void rel_vdev_port_node_info(union md_node_info *node_info)":{
        "description": "This function retrieves information about a virtual device port node.",
        "pre": {
            "md": "!=null",
            "node": "!=null",
            "idp": "!=null",
            "name": "!=null",
            "parent_cfg_hdlp": "!=null",
            "node_info->vdev_port.id": "!=null",
            "node_info->vdev_port.name": "!=null",
            "node_info->vdev_port.parent_cfg_hdl": "!=null"
        }
    }
},


{
    "kretprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},
{
    "kprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},


{
    "movl_%%ecx_%%edx": {
        "description": "String comparison using cmpsb instruction",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first occurrence of the substring ct in the string cs.",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},


{
    "kretprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is being copied to devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">0"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is being copied to devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">0"
        }
    }
},
{
    "kretprobe:memset_io": {
        "description": "The memset_io function sets the value of each byte in the memory range pointed to by 'a' to the value of 'b'.",
        "pre": {
            "a": "!=null",
            "b": "any",
            "c": ">=0"
        }
    }
},
{
    "kprobe:memset_io": {
        "description": "Set the value of the memory region starting at address *a* to *b* for *c* bytes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:clear_user": {
        "description": "Zero a block of memory in user space.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:clear_user": {
        "description": "Zero a block of memory in user space.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:unsigned_long__clear_user": {
        "description": "Zero a block of memory in user space, with less checking.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:unsigned_long__clear_user": {
        "description": "Zero a block of memory in user space, with less checking.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:csum_partial": {
        "description": "Calculate the checksum of a partial buffer.",
        "pre": {
            "buff": "!=null",
            "len": "==40",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:csum_partial": {
        "description": "Calculate the checksum of a partial buffer.",
        "pre": {
            "buff": "!=null",
            "len": "==40",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:alloc_p2m_pmd": {
        "description": "Allocate a new PMD level if it is missing.",
        "pre": {
            "addr": "!=null",
            "pte_pg": "!=null"
        },
        "post": {
            "ptep": "!=null"
        }
    },
    "kretprobe:p2m_top_mfn": {
        "description": "Check if p2m_top_mfn is not null.",
        "pre": {},
        "post": {
            "p2m_top_mfn": "!=null"
        }
    },
    "kretprobe:pfn": {
        "description": "Check if pfn is less than MAX_P2M_PFN.",
        "pre": {},
        "post": {
            "pfn": "< MAX_P2M_PFN"
        }
    }
},
{
    "kprobe:alloc_p2m_pmd": {
        "description": "Allocate a new pmd entry for the given address.",
        "pre": {
            "addr": "!=null",
            "pte_pg": "!=null"
        }
    },
    "kprobe:lookup_address": {
        "description": "Look up the address and retrieve the corresponding pte entry.",
        "pre": {
            "addr": "!=null",
            "level": "==PG_LEVEL_4K"
        }
    },
    "kprobe:p2m_missing_pte": {
        "description": "Check if the pte_pg is equal to p2m_missing_pte.",
        "pre": {
            "pte_pg": "==p2m_missing_pte"
        }
    },
    "kprobe:p2m_identity_pte": {
        "description": "Check if the pte_pg is equal to p2m_identity_pte.",
        "pre": {
            "pte_pg": "==p2m_identity_pte"
        }
    },
    "kprobe:p2m_top_mfn": {
        "description": "Check if p2m_top_mfn is not null.",
        "pre": {
            "p2m_top_mfn": "!=null"
        }
    },
    "kprobe:pfn": {
        "description": "Check if pfn is less than MAX_P2M_PFN.",
        "pre": {
            "pfn": "<MAX_P2M_PFN"
        }
    }
},
{
    "kretprobe:BUILD_BUG_ON": {
        "description": "Build-time check to ensure SZ_4K / BLAKE2S_BLOCK_SIZE >= 8",
        "pre": {},
        "post": {}
    },
    "kretprobe:static_branch_likely": {
        "description": "Check if static branch blake2s_use_ssse3 is likely",
        "pre": {},
        "post": {}
    },
    "kretprobe:may_use_simd": {
        "description": "Check if SIMD instructions can be used",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:BUILD_BUG_ON": {
        "description": "Check if the size of SZ_4K divided by BLAKE2S_BLOCK_SIZE is less than 8.",
        "pre": {
            "SZ_4K / BLAKE2S_BLOCK_SIZE": "< 8"
        }
    },
    "kprobe:static_branch_likely": {
        "description": "Check if the static branch 'blake2s_use_ssse3' is likely to be true.",
        "pre": {
            "&blake2s_use_ssse3": "== true"
        }
    },
    "kprobe:may_use_simd": {
        "description": "Check if SIMD (Single Instruction, Multiple Data) instructions can be used.",
        "pre": {
            "may_use_simd()": "== true"
        }
    }
},
{
    "kretprobe:cpuid_eax": {
        "description": "Get the value of the EAX register using the cpuid instruction.",
        "pre": {
            "eax": "==0x80000000"
        }
    },
    "kretprobe:IBS_CPUID_FEATURES": {
        "description": "Check if the IBS CPUID feature is supported.",
        "pre": {
            "max_level": ">= IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:IBS_CAPS_DEFAULT": {
        "description": "Return the default value for IBS capabilities.",
        "pre": {
            "max_level": "< IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:cpuid_eax": {
        "description": "Get the value of the EAX register using the cpuid instruction.",
        "pre": {
            "eax": "==IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:IBS_CAPS_AVAIL": {
        "description": "Check if IBS capabilities are available.",
        "pre": {
            "caps": "& IBS_CAPS_AVAIL"
        }
    }
},
{
    "kprobe:cpuid_eax": {
        "description": "Get the value of the CPUID register with input argument 0x80000000.",
        "pre": {
            "max_level": "< IBS_CPUID_FEATURES"
        }
    },
    "kprobe:IBS_CPUID_FEATURES": {
        "description": "Check if IBS CPUID feature is available.",
        "pre": {
            "caps": "& IBS_CAPS_AVAIL"
        }
    }
},
{
    "kretprobe:setup_node_to_cpumask_map": {
        "description": "Initialize the node to cpumask map.",
        "pre": {
            "CONFIG_DEBUG_PER_CPU_MAPS": "enabled"
        }
    }
},
{
    "kprobe:setup_node_to_cpumask_map": {
        "description": "Initialize the node to cpumask map.",
        "pre": {
            "CONFIG_DEBUG_PER_CPU_MAPS": "enabled"
        }
    }
},


{
    "kretprobe:return ret;}EXPORT_SYMBOL(register_kmmio_probe": {
        "description": "Registers a kmmio probe.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "ret": "!=null",
            "size": ">=0",
            "addr": ">=0",
            "size_lim": ">=0",
            "l": ">=0",
            "pte": "!=null"
        }
    }
},
{
    "kprobe:return ret;}EXPORT_SYMBOL(register_kmmio_probe": {
        "description": "Registers a kmmio probe.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "ret": "!=null",
            "size": ">=0",
            "addr": "!=null",
            "size_lim": ">=0",
            "l": "!=null",
            "pte": "!=null"
        }
    }
},
{
    "kretprobe:call_rcu(&drelease->rcu, remove_kmmio_fault_pages);}EXPORT_SYMBOL(unregister_kmmio_probe": {
        "description": "This function unregisters a kmmio probe and performs some cleanup operations.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "size": ">=0",
            "addr": "!=null",
            "size_lim": ">=0",
            "release_list": "==null",
            "drelease": "!=null",
            "l": ">=0",
            "pte": "!=null",
            "kmmio_count": ">0"
        }
    }
},
{
    "kprobe:call_rcu(&drelease->rcu, remove_kmmio_fault_pages);}EXPORT_SYMBOL(unregister_kmmio_probe": {
        "description": "Unregister a kmmio probe and remove associated fault pages.",
        "pre": {
            "p": "!=null",
            "p->addr": "!=null",
            "p->len": "!=null",
            "p->addr & PAGE_MASK": "==p->addr & PAGE_MASK",
            "size_lim": "p->len + (p->addr & ~PAGE_MASK)",
            "release_list": "==NULL",
            "drelease": "!=NULL",
            "drelease->release_list": "==release_list"
        }
    }
},
{
    "kretprobe:vm_get_page_prot": {
        "description": "Generate Z3 conditions for vm_get_page_prot function",
        "pre": {
            "vm_flags": "!=null",
            "val": "!=null",
            "val & _PAGE_PRESENT": "==0",
            "__supported_pte_mask": "!=null"
        }
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "Get the page protection flags based on the vm_flags.",
        "pre": {
            "vm_flags": "!=null"
        }
    }
},


{
    "kretprobe:__phys_addr_symbol": {
        "description": "__phys_addr_symbol(unsigned long x) - Calculate the physical address corresponding to a given virtual address.",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "y": ">= __START_KERNEL_map",
            "y": "<= KERNEL_IMAGE_SIZE",
            "return_value": ">= y + phys_base"
        }
    }
},



"post": {
    "return_value": "!=null"
},
{
    "kprobe:ioremap_uc": {
        "description": "map bus memory into CPU space as strongly uncachable",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "pcm": "==_PAGE_CACHE_MODE_UC_MINUS",
            "__builtin_return_address(0)": "!=null",
            "false": "==false"
        }
    }
},
{
    "kretprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:fix_addr": {
        "description": "Fix the top bit of the address if needed, otherwise it is a no-op.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:fix_addr": {
        "description": "Fix the top bit of the address if needed, otherwise it is a no-op.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:set_memory_wb": {
        "description": "Set memory cache mode to Write-Back (WB)",
        "pre": {
            "addr": "!=null",
            "numpages": "!=null"
        }
    }
},
{
    "kprobe:set_memory_wb": {
        "description": "Set the memory write-back cache mode for the specified address range.",
        "pre": {
            "addr": "!=null",
            "numpages": "!=null"
        }
    }
},
{
    "kretprobe:cpa_clear_pages_array": {
        "description": "Clear the pages array with write-back cache mode.",
        "pre": {
            "pages": "!=null",
            "numpages": ">=0",
            "__pgprot(_PAGE_CACHE_MASK)": "!=null"
        },
        "post": {
            "retval": "==0",
            "i": ">=0",
            "i": "<numpages"
        }
    }
},
{
    "kprobe:cpa_clear_pages_array": {
        "description": "Clears the pages array",
        "pre": {
            "pages": "!=null",
            "numpages": "any integer"
        }
    }
},
{
    "kretprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it.",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it.",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state()",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state().",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:scx200_probe": {
        "description": "Probe function for scx200",
        "pre": {
            "pdev": "!=null",
            "ent": "!=null"
        }
    }
},
{
    "kprobe:scx200_probe": {
        "description": "Probe function for scx200",
        "pre": {
            "bank": ">= 0 and < 2",
            "scx200_gpio_shadow[bank]": "= inl(scx200_gpio_base + 0x10 * bank)",
            "pdev": "!= null",
            "ent": "!= null"
        }
    }
},


{
    "kretprobe:iosf_mbi_available": {
        "description": "Mbi isn't hot-pluggable. No remove routine is provided.",
        "pre": {}
    }
},
{
    "kprobe:return_mbi_pdev": {
        "description": "Check if Mbi is available.",
        "pre": {}
    }
},

{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "&iosf_mbi_pmic_access_mutex"
        }
    },
    "kprobe:while": {
        "description": "Loop while a condition is true.",
        "pre": {
            "condition": "iosf_mbi_pmic_i2c_access_count != 0"
        }
    }
},


{
    "kretprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering the notifier block.",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:iosf_mbi_punit_acquire": {
        "description": "Acquire the P-Unit lock.",
        "pre": {},
        "post": {
            "ret": ">= 0"
        }
    },
    "kretprobe:iosf_mbi_unregister_pmic_bus_access_notifier_unlocked": {
        "description": "Unregister the PMIC bus access notifier.",
        "pre": {
            "nb": "!= null"
        },
        "post": {
            "ret": ">= 0"
        }
    },
    "kretprobe:iosf_mbi_punit_release": {
        "description": "Release the P-Unit lock.",
        "pre": {},
        "post": {}
    },
    "kretprobe:iosf_mbi_assert_punit_acquired": {
        "description": "Assert that the P-Unit is acquired.",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:iosf_mbi_punit_acquire": {
        "description": "Acquire the punit.",
        "pre": {}
    },
    "kprobe:iosf_mbi_unregister_pmic_bus_access_notifier_unlocked": {
        "description": "Unregister the PMIC bus access notifier.",
        "pre": {
            "nb": "!=null"
        }
    },
    "kprobe:iosf_mbi_punit_release": {
        "description": "Release the punit.",
        "pre": {}
    },
    "kprobe:return": {
        "description": "Return the value.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(iosf_mbi_unregister_pmic_bus_access_notifier)": {
        "description": "Export the symbol iosf_mbi_unregister_pmic_bus_access_notifier.",
        "pre": {}
    },
    "kprobe:void iosf_mbi_assert_punit_acquired(void)": {
        "description": "Assert that the punit is acquired.",
        "pre": {}
    }
},


{
    "kretprobe:pcibios_align_resource": {
        "description": "Align the PCI resource according to the specified size and alignment.",
        "pre": {
            "data": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "dev": "!=null",
            "start": "!=null",
            "flags": "in [IORESOURCE_IO, IORESOURCE_MEM]"
        },
        "post": {
            "start": ">= BIOS_END"
        }
    }
},




{
    "kprobe:/* * outb_pic - this has to work on a wide range of PC hardware. ": {
        "description": "This function is responsible for handling the outb_pic operation on a wide range of PC hardware.",
        "pre": {
            "legacy_pic": "==null",
            "i8259A_lock": "!=null",
            "auto_eoi": "in [0, 1]",
            "PIC_MASTER_IMR": "==0xff"
        }
    }
},


{
    "kretprobe:profile_pc": {
        "description": "Profile the program counter",
        "pre": {
            "regs": "!=null",
            "pc": "!=null",
            "user_mode(regs)": "==false",
            "in_lock_functions(pc)": "==true",
            "sp[0] >> 22": "==true",
            "sp[1] >> 22": "==true"
        }
    }
},
{
    "kprobe:profile_pc": {
        "description": "Profile the program counter.",
        "pre": {
            "regs": "!=null",
            "pc": "!=null",
            "user_mode(regs)": "false",
            "in_lock_functions(pc)": "true",
            "sp[0] >> 22": "true",
            "sp[1] >> 22": "true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(cpu_khz)": {
        "description": "Returns the TSC clocks in microseconds.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(cpu_khz)": {
        "description": "Measure TSC clocks in microseconds (not used here).",
        "pre": {
            "usec": "not used"
        }
    }
},
{
    "kretprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC.",
        "pre": {
            "art_ns": "!=null",
            "tsc_khz": "!=null",
            "X86_FEATURE_TSC_KNOWN_FREQ": "==true"
        },
        "post": {
            "cycles": "!=null",
            "cs": "!=null"
        }
    }
},
{
    "kprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC.",
        "pre": {
            "art_ns": "!=null",
            "tsc_khz": "!=null",
            "X86_FEATURE_TSC_KNOWN_FREQ": "==true"
        },
        "post": {
            "cycles": "!=null",
            "cs": "!=null"
        }
    }
},
{
    "kretprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id.",
        "pre": {
            "phys_pkg": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= -1"
        }
    }
},
{
    "kprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id.",
        "pre": {
            "phys_pkg": "!=null",
            "phys_pkg": "unsigned int",
            "return_value": "int"
        },
        "post": {
            "return_value": "in [-1, 0, 1, 2, ...]"
        }
    }
},
{
    "kretprobe:spin_lock(&rtc_lock);CMOS_WRITE(0x00, 0x8f);spin_unlock(&rtc_lock);/* * Switch to the trampoline page table.`": {
        "description": "Reboot the machine and switch to the trampoline page table.",
        "pre": {
            "rtc_lock": "locked"
        },
        "post": {
            "rtc_lock": "unlocked",
            "CMOS_WRITE": {
                "register": "0x00",
                "value": "0x8f"
            }
        }
    }
},
{
    "kprobe:spin_lock": {
        "description": "Acquire the spin lock associated with rtc_lock.",
        "pre": {
            "rtc_lock": "!=null"
        }
    },
    "kprobe:CMOS_WRITE": {
        "description": "Write the value 0x8f to CMOS register number 0x00.",
        "pre": {
            "register": "0x00",
            "value": "0x8f"
        }
    },
    "kprobe:spin_unlock": {
        "description": "Release the spin lock associated with rtc_lock.",
        "pre": {
            "rtc_lock": "!=null"
        }
    }
},
{
    "kretprobe:native_io_delay": {
        "description": "The native_io_delay function should be a constant.",
        "pre": {
            "native_io_delay": "==constant"
        }
    }
},
{
    "kprobe:native_io_delay": {
        "description": "The native_io_delay function should be a constant.",
        "pre": {
            "native_io_delay": "==constant"
        }
    }
},
{
    "kretprobe:pin_2_irq": {
        "description": "Converts pin number to IRQ number.",
        "pre": {
            "i": "!=null",
            "ioapic_idx": "!=null",
            "mp_irqs[i].dstirq": "!=null",
            "0": "!=null"
        },
        "post": {
            "irq": ">0",
            "!IO_APIC_IRQ(irq)": "true",
            "pin": "== (mp_irqs[i].srcbusirq & 3)"
        }
    }
},
{
    "kprobe:pin_2_irq": {
        "description": "Converts a pin number to an IRQ number.",
        "pre": {
            "i": "!=null",
            "ioapic_idx": "!=null",
            "mp_irqs[i].dstirq": "!=null",
            "pin": "!=null",
            "irq": ">0",
            "!IO_APIC_IRQ(irq)": "true",
            "pin": "== (mp_irqs[i].srcbusirq & 3)"
        }
    }
},


{
    "kretprobe:native_write_cr0": {
        "description": "Write the value to the CR0 register and warn if the WP bit is missing.",
        "pre": {
            "val": "!=null",
            "bits_missing": "!=null",
            "static_branch_likely(&cr_pinning)": "true",
            "unlikely((val & X86_CR0_WP) != X86_CR0_WP)": "true"
        }
    }
},
{
    "kprobe:native_write_cr0": {
        "description": "Write the value to the CR0 register and set the missing bits if necessary.",
        "pre": {
            "bits_missing": "!=null"
        }
    }
},
{
    "kretprobe:reserve_perfctr_nmi": {
        "description": "Reserve performance counter for non-maskable interrupt (NMI).",
        "pre": {
            "counter": "> NMI_MAX_COUNTER_BITS",
            "!test_and_set_bit(counter, perfctr_nmi_owner)": "true"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:reserve_perfctr_nmi": {
        "description": "Reserve a performance counter for non-maskable interrupt (NMI) handling.",
        "pre": {
            "msr": "!=null",
            "counter": "!=null",
            "counter > NMI_MAX_COUNTER_BITS": "return 1",
            "!test_and_set_bit(counter, perfctr_nmi_owner)": "return 1",
            "return 0": ""
        }
    }
},


{
    "kretprobe:reserve_evntsel_nmi": {
        "description": "Reserve event select for non-maskable interrupt (NMI).",
        "pre": {
            "counter": "> NMI_MAX_COUNTER_BITS",
            "!test_and_set_bit(counter, evntsel_nmi_owner)": "== 0"
        }
    }
},
{
    "kprobe:reserve_evntsel_nmi": {
        "description": "Reserve an event select MSR for NMI.",
        "pre": {
            "msr": "!=null",
            "counter": "!=null",
            "counter > NMI_MAX_COUNTER_BITS": "true",
            "!test_and_set_bit(counter, evntsel_nmi_owner)": "true"
        },
        "post": {
            "return": "0"
        }
    }
},


{
    "kretprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids",
        "pre": {
            "match": "!=null"
        },
        "post": {
            "return": "in [null, !=null]"
        }
    }
},
{
    "kprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids.",
        "pre": {
            "match": "!=null"
        }
    }
},


{
    "kretprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:irq_fpu_usable": {
        "description": "Check if the in-kernel FPU usage is already active.",
        "pre": {
            "in_nmi()": "==false"
        },
        "post": {
            "return": "==true"
        }
    }
},
{
    "kprobe:if (this_cpu_read(in_kernel_fpu))return false;/* * When not in NMI or hard interrupt context, FPU can be used in: * * - Task context except from within fpregs_lock()'ed critical *   regions. * * - Soft interrupt processing context which cannot happen *   while in a fpregs_lock()'ed critical region. */": {
        "description": "Check if the in_kernel_fpu is readable on the current CPU and return false if it is.",
        "pre": {
            "in_nmi()": "false"
        }
    }
},


{
    "kretprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:memmove": {
        "description": "Move a block of memory from one location to another.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">0",
            "v_dst + c": "<= v_src",
            "v_src + c": "<= v_dst"
        }
    }
},
{
    "memmove": {
        "description": "Move a block of memory from one location to another.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">0"
        },
        "post": {
            "success": "true"
        }
    }
},

{
    "memset": {
        "description": "Set a block of memory to a specified value.",
        "pre": {
            "v_src": "!=null",
            "c": "any",
            "n": "valid_size"
        },
        "post": {
            "memory_block": {
                "start_address": "v_src",
                "size": "n",
                "value": "c"
            }
        }
    }
},

{
    "kprobe:if (mapping && !mapping_mapped(mapping))": {
        "description": "Check if the mapping exists and the page is not mapped to user-space.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:local_flush_cache_page": {
        "description": "Flushes the cache page for a given virtual address and physical address.",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kprobe:local_flush_cache_page": {
        "description": "Flushes the cache for a specific page.",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},

{
    "kprobe:EXPORT_SYMBOL(ccount_freq)": {
        "description": "Count the frequency of events at a specific frequency.",
        "pre": {
            "freq": ">=0"
        }
    }
},

{
    "kprobe:xtensa_backtrace_user": {
        "description": "Look through the register window for the previous PCs in the call trace.",
        "pre": {
            "regs": "!=null",
            "depth": ">= 0",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:spill_registers": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:spill_registers": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:return_address": {
        "description": "Returns the return address from the caller of this function.",
        "pre": {
            "level": "== 0"
        }
    }
},
{
    "kprobe:return_address": {
        "description": "Get the return address from the caller of the function.",
        "pre": {
            "level": ">= 0"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy a byte at a time until the destination is aligned.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">= MIN_THRESHOLD",
            "distance": "== 0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy a byte at a time until the destination is aligned.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0",
            "count": "<=MIN_THRESHOLD",
            "distance": "==0"
        }
    }
},






{
    "kretprobe:result += (__force u32)sum;/* 32+c bits -> 32 bits `": {
        "description": "Add the value of sum to the result variable.",
        "pre": {
            "result": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:result += (__force u32)sum;/* 32+c bits -> 32 bits `": {
        "description": "Add the value of sum to the result variable.",
        "pre": {
            "result": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:flush_tlb_range": {
        "description": "Flush the Translation Lookaside Buffer (TLB) for a given range of virtual memory addresses.",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "end": "!=null",
            "mm": "!=null",
            "size": "end - start",
            "nbits": "ia64_fls(size + 0xfff)",
            "mm == current->active_mm": true,
            "nbits < purge.max_bits": true,
            "nbits > purge.max_bits": false,
            "start &= ~((1UL << nbits) - 1)": true,
            "cpumask_weight(mm_cpumask(mm)) == 1": true
        }
    }
},
{
    "kprobe:flush_tlb_range": {
        "description": "Flush the TLB entries for a given range of virtual memory addresses.",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    }
},
{
    "kretprobe:kern_mem_attribute": {
        "description": "Get the memory attribute for the given physical address and size.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        },
        "post": {
            "attr": "!=null"
        }
    },
    "kretprobe:phys_to_virt": {
        "description": "Convert the given physical address to a virtual address.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:attr & EFI_MEMORY_WB": {
        "description": "Check if the attribute has EFI_MEMORY_WB flag set.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:attr & EFI_MEMORY_UC": {
        "description": "Check if the attribute has EFI_MEMORY_UC flag set.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__IA64_UNCACHED_OFFSET | phys_addr": {
        "description": "Calculate the virtual address by adding the uncached offset to the physical address.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:phys_to_virt(phys_addr)": {
        "description": "Convert the given physical address to a virtual address using phys_to_virt helper.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__ioremap_uc(phys_addr)": {
        "description": "Remap the given physical address with uncached attribute using __ioremap_uc helper.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kern_mem_attribute": {
        "description": "Get the memory attribute for the given physical address and size.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:phys_to_virt": {
        "description": "Convert the given physical address to a virtual address.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:__ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:__ioremap": {
        "description": "Remap the given physical address with default attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:ioremap": {
        "description": "Remap the given physical address with default attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},


{
    "kretprobe:node_cpuid[cpu].phys_id": {
        "description": "Set the physical ID of the CPU.",
        "pre": {
            "cpu": "!=null",
            "physid": "!=null",
            "handle": "!=null"
        }
    },
    "kretprobe:node_cpuid[cpu].nid": {
        "description": "Set the NUMA node ID of the CPU.",
        "pre": {
            "cpu": "!=null",
            "handle": "!=null"
        }
    },
    "kretprobe:additional_cpus": {
        "description": "Set the value of additional CPUs.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:node_cpuid[cpu].phys_id = physid;node_cpuid[cpu].nid = acpi_get_node(handle);#endifreturn 0;}int additional_cpus __initdata = -1;static __init int setup_additional_cpus(char *s)": {
        "description": "Set the physical ID and NUMA node ID for the specified CPU.",
        "pre": {
            "cpu": "!=null",
            "physid": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:acpi_unmap_cpu": {
        "description": "Unmap the CPU and perform NUMA specific cleanup.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:acpi_unmap_cpu": {
        "description": "Unmap the CPU and perform NUMA specific cleanup.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:acpi_register_ioapic": {
        "description": "Registers an IOAPIC device with ACPI.",
        "pre": {
            "handle": "!=null",
            "phys_addr": "!=null",
            "gsi_base": "!=null"
        }
    }
},
{
    "kprobe:acpi_register_ioapic": {
        "description": "Registers an IOAPIC device with ACPI.",
        "pre": {
            "handle": "!=null",
            "phys_addr": "!=null",
            "gsi_base": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(ia64_iobase)": {
        "description": "virtual address for IO accesses",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(ia64_iobase)": {
        "description": "virtual address for IO accesses",
        "pre": {
            "arg0": "!=null"
        }
    }
},
{
    "kretprobe:ia64_itc_udelay": {
        "description": "Delays execution for the specified number of microseconds using the ITC values.",
        "pre": {
            "usecs": ">= 0"
        }
    }
},
{
    "kprobe:ia64_itc_udelay": {
        "description": "Delays the execution for the specified number of microseconds.",
        "pre": {
            "usecs": ">= 0"
        }
    }
},
{
    "kretprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable.",
        "pre": {
            "can_cpei_retarget() || !is_cpu_cpei_target(num)": true,
            "sysfs_cpus[num].cpu.hotpluggable": 1,
            "map_cpu_to_node(num, node_cpuid[num].nid)": true,
            "return register_cpu(&sysfs_cpus[num].cpu, num)": true
        }
    }
},
{
    "kprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable",
        "pre": {
            "can_cpei_retarget() || !is_cpu_cpei_target(num)": true,
            "sysfs_cpus[num].cpu.hotpluggable": 1,
            "map_cpu_to_node(num, node_cpuid[num].nid)": true,
            "register_cpu(&sysfs_cpus[num].cpu, num)": true
        }
    }
},


{
    "kretprobe:static DEFINE_SPINLOCK(mlogbuf_rlock)": {
        "description": "Defines a spinlock named mlogbuf_rlock for normal contexts.",
        "pre": {
            "mlogbuf_rlock": "!=null"
        }
    }
},



{
    "kretprobe:nat = 0; return 0;": {
        "description": "Set `nat` to 0 and return 0.",
        "pre": {
            "nat": "== 0"
        }
    }
},



{
    "kretprobe:if (!unw_valid(info, info->rp_loc))": {
        "description": "Check if the return IP pointer is valid",
        "pre": {
            "info": "!=null",
            "info->rp_loc": "!=null"
        }
    }
},
{
    "kprobe:if (!unw_valid(info, info->rp_loc))": {
        "description": "Check if the return IP pointer is valid in the unw_frame_info structure.",
        "pre": {
            "info": "!=null",
            "info->rp_loc": "!=null"
        }
    }
},
{
    "kretprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node.",
        "pre": {
            "starting_nid": "!=null",
            "n_pages": "!=null"
        }
    }
},
{
    "kprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node.",
        "pre": {
            "starting_nid": "!=null",
            "n_pages": "!=null"
        }
    }
},
{
    "kretprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">=0"
        }
    }
},
{
    "kprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">=0"
        }
    }
},
O,

{
    "kretprobe:udelay": {
        "description": "Use only for very small delays (< 1 msec).",
        "pre": {
            "smp_processor_id": "!=null"
        }
    }
},
{
    "kprobe:udelay": {
        "description": "Use only for very small delays (< 1 msec).",
        "pre": {
            "smp_processor_id": "!=null"
        }
    }
},
{
    "kretprobe:FIXUP_MEMADDR_VGA": {
        "description": "Adjust the address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:FIXUP_MEMADDR_VGA": {
        "description": "Adjust the address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:return ~0;}voidmarvel_iowrite8": {
        "description": "This function writes the value `~0` to the I/O address specified by `xaddr`.",
        "pre": {
            "b": "!=null",
            "xaddr": "!=null"
        }
    }
},
{
    "kprobe:return ~0;}voidmarvel_iowrite8": {
        "description": "This function writes the value `~0` to the I/O address specified by `xaddr`.",
        "pre": {
            "b": "!=null",
            "xaddr": "!=null"
        }
    }
},
O,

{
    "kretprobe:irongate_iounmap": {
        "description": "Free the memory associated with the given address if it is not equal to zero.",
        "pre": {
            "addr": "!=0"
        }
    }
},
{
    "kprobe:irongate_iounmap": {
        "description": "Free the virtual memory associated with the given physical address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dump_elf_thread": {
        "description": "dump_elf_thread(elf_greg_t dest, struct pt_regs pt, struct thread_info ti). Switch stack follows right below pt_regs.",
        "pre": {
            "dest": "!=null",
            "pt": "!=null",
            "ti": "!=null"
        },
        "post": {
            "dest[0]": "== pt->r0",
            "dest[1]": "== pt->r1",
            "dest[2]": "== pt->r2",
            "dest[3]": "== pt->r3",
            "dest[4]": "== pt->r4",
            "dest[5]": "== pt->r5",
            "dest[6]": "== pt->r6",
            "dest[7]": "== pt->r7",
            "dest[8]": "== pt->r8",
            "dest[9]": "== ((struct switch_stack *) pt) - 1)->r9",
            "dest[10]": "== ((struct switch_stack *) pt) - 1)->r10",
            "dest[11]": "== ((struct switch_stack *) pt) - 1)->r11",
            "dest[12]": "== ((struct switch_stack *) pt) - 1)->r12",
            "dest[13]": "== ((struct switch_stack *) pt) - 1)->r13",
            "dest[14]": "== ((struct switch_stack *) pt) - 1)->r14",
            "dest[15]": "== ((struct switch_stack *) pt) - 1)->r15",
            "dest[16]": "== pt->r16",
            "dest[17]": "== pt->r17",
            "dest[18]": "== pt->r18",
            "dest[19]": "== pt->r19",
            "dest[20]": "== pt->r20",
            "dest[21]": "== pt->r21",
            "dest[22]": "== pt->r22",
            "dest[23]": "== pt->r23",
            "dest[24]": "== pt->r24",
            "dest[25]": "== pt->r25",
            "dest[26]": "== pt->r26",
            "dest[27]": "== pt->r27",
            "dest[28]": "== pt->r28",
            "dest[29]": "== pt->gp",
            "dest[30]": "== (ti == current_thread_info() ? rdusp() : ti->pcb.usp)",
            "dest[31]": "== pt->pc"
        }
    }
},
{
    "kprobe:dump_elf_thread": {
        "description": "Dump the ELF thread",
        "pre": {
            "dest": "!=null",
            "pt": "!=null",
            "ti": "!=null",
            "sw": "!=null",
            "sw == ((struct switch_stack *) pt) - 1": true,
            "dest[0] == pt->r0": true,
            "dest[1] == pt->r1": true,
            "dest[2] == pt->r2": true,
            "dest[3] == pt->r3": true,
            "dest[4] == pt->r4": true,
            "dest[5] == pt->r5": true,
            "dest[6] == pt->r6": true,
            "dest[7] == pt->r7": true,
            "dest[8] == pt->r8": true,
            "dest[9] == sw->r9": true,
            "dest[10] == sw->r10": true,
            "dest[11] == sw->r11": true,
            "dest[12] == sw->r12": true,
            "dest[13] == sw->r13": true,
            "dest[14] == sw->r14": true,
            "dest[15] == sw->r15": true,
            "dest[16] == pt->r16": true,
            "dest[17] == pt->r17": true,
            "dest[18] == pt->r18": true,
            "dest[19] == pt->r19": true,
            "dest[20] == pt->r20": true,
            "dest[21] == pt->r21": true,
            "dest[22] == pt->r22": true,
            "dest[23] == pt->r23": true,
            "dest[24] == pt->r24": true,
            "dest[25] == pt->r25": true,
            "dest[26] == pt->r26": true,
            "dest[27] == pt->r27": true,
            "dest[28] == pt->r28": true,
            "dest[29] == pt->gp": true,
            "dest[30] == (ti == current_thread_info() ? rdusp() : ti->pcb.usp)": true,
            "dest[31] == pt->pc": true
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "pre": {
            "smp_num_cpus": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "pre": {
            "smp_num_cpus": "==1"
        }
    }
},
{
    "kretprobe:on_each_cpu(ipi_imb, NULL, 1);}EXPORT_SYMBOL(smp_imb": {
        "description": "Must wait for other processors to flush their icache before continuing.",
        "pre": {
            "ipi_imb": "!=null"
        }
    }
},
{
    "kprobe:on_each_cpu(ipi_imb, NULL, 1);}EXPORT_SYMBOL(smp_imb": {
        "description": "Must wait for other processors to flush their icache before continuing.",
        "pre": {
            "ipi_imb": "null",
            "NULL": "null",
            "1": "null"
        }
    }
},
{
    "kretprobe:flush_tlb_mm": {
        "description": "Flush the TLB entries for a given memory mapping.",
        "pre": {
            "vma": "!=null",
            "start": "valid_memory_address",
            "end": "valid_memory_address",
            "vma_mapping": "valid_memory_mapping",
            "memory_range": "valid_memory_range"
        }
    }
},
{
    "kprobe:flush_tlb_mm": {
        "description": "Flush the TLB range for the given vm_area_struct.",
        "pre": {
            "vma": "!=null",
            "start": "unsigned long",
            "end": "unsigned long"
        },
        "post": "Flushes the TLB range specified by start and end for the given vma."
    }
},
{
    "kretprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "count": ">= 8",
            "to": "& 7 == 0",
            "from": "& 7 == 0"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "count": ">= 8",
            "to": "& 7 == 0",
            "from": "& 7 == 0"
        }
    }
},
{
    "kretprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},




{
    "kretprobe:readb_relaxed": {
        "description": "Read a byte from the given I/O memory address in a relaxed manner.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:readb_relaxed": {
        "description": "Read a byte from the given I/O memory address using relaxed ordering.",
        "pre": {
            "addr": "!=null"
        }
    }
},




{
    "kretprobe:min_high_pfn = PFN_DOWN(high_mem_start);max_high_pfn = PFN_DOWN(high_mem_start + high_mem_sz);/* * max_high_pfn should be ok here for both HIGHMEM and HIGHMEM+PAE. * For HIGHMEM without PAE max_high_pfn should be less than * min_low_pfn to guarantee that these two regions don't overlap. * For PAE case highmem is greater than lowmem, so it is natural * to use max_high_pfn. * * In both case holes should be handled by pfn_valid(). ": {
        "description": "Generate conditions for min_high_pfn and max_high_pfn",
        "pre": {
            "high_mem_start": "!=null",
            "high_mem_sz": "!=null",
            "min_low_pfn": "!=null",
            "max_high_pfn": "!=null",
            "pfn_valid()": "handles the hole in the memory map."
        },
        "post": {
            "max_high_pfn": "< min_low_pfn"
        }
    }
},
{
    "kprobe:min_high_pfn = PFN_DOWN(high_mem_start);max_high_pfn = PFN_DOWN(high_mem_start + high_mem_sz);/* * max_high_pfn should be ok here for both HIGHMEM and HIGHMEM+PAE. * For HIGHMEM without PAE max_high_pfn should be less than * min_low_pfn to guarantee that these two regions don't overlap. * For PAE case highmem is greater than lowmem, so it is natural * to use max_high_pfn. * * In both case holes should be handled by pfn_valid(). ": {
        "description": "Generate conditions for min_high_pfn and max_high_pfn",
        "pre": {
            "min_high_pfn": "!=null",
            "max_high_pfn": "!=null",
            "max_high_pfn < min_low_pfn": "when high_mem_sz > 0",
            "pfn_valid()": "should handle holes in the memory map"
        }
    }
},


{
    "kretprobe:read_decode_cache_bcr_arcv2": {
        "description": "Read the Cache Build Configuration Register Decode them, and save into the cpuinfo structure for later use.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:read_decode_cache_bcr_arcv2": {
        "description": "Read the Cache Build Configuration Register decode them, and save into the cpuinfo structure for later use.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:flush_icache_range": {
        "description": "Shortcut for bigger flush ranges. Here we don't care if this was kernel virtual or phy addr",
        "pre": {
            "kstart": "!=null",
            "kend": "!=null",
            "tot_sz": "!=null",
            "kstart < TASK_SIZE": true
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Shortcut for bigger flush ranges. Here we don't care if this was kernel virtual or phy addr",
        "pre": {
            "kstart": "!=null",
            "kend": "!=null",
            "tot_sz": "kend - kstart",
            "tot_sz > PAGE_SIZE": true
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range into kernel virtual memory.",
        "pre": {
            "paddr": "!=null",
            "size": "!=0",
            "end": "!=null",
            "end < paddr": "true"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Map the physical address range specified by *paddr* and *size* into virtual memory.",
        "pre": {
            "paddr": "!=null",
            "size": "!=0",
            "end": "= paddr + size - 1",
            "end < paddr": "return NULL",
            "return": "!=NULL"
        }
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "Remap a physical address range into the kernel's virtual address space with specified protection flags.",
        "pre": {
            "paddr": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Remap physical addresses to virtual addresses with specific access flags.",
        "pre": {
            "paddr": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:arch_local_irq_enable": {
        "description": "Enable interrupts.",
        "pre": {
            "called_from": "in [hard-ISR, soft-ISR]",
            "interrupt_priorities": "not inverted when called_from == hard-ISR",
            "interrupts_enabled": "all when called_from == soft-ISR",
            "L1_interrupts_enabled": "not re-enabled when flow == L1 ISR ==> interrupted by L2 ISR ==> L2 soft ISR"
        }
    }
},
{
    "kprobe:arch_local_irq_enable": {
        "description": "Enable interrupts.",
        "pre": {
            "called_from": {
                "in": ["hard-ISR", "soft-ISR"]
            },
            "interrupt_priorities": {
                "if": "called_from == 'hard-ISR'",
                "then": {
                    "inverted": false
                }
            },
            "interrupts_enabled": {
                "if": "called_from == 'soft-ISR'",
                "then": true
            },
            "re_enable_L1": {
                "if": "called_from == 'soft-ISR' && flow == 'L1 ISR ==> interrupted by L2 ISR ==> L2 soft ISR'",
                "then": false
            }
        }
    }
},


{
    "kretprobe:ioread8_rep": {
        "description": "Read 8-bit values from memory and repeat the operation count times.",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:ioread8_rep": {
        "description": "Read `count` bytes from `addr` and store them in `dst`.",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},


{
    "kretprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at SRC.",
        "pre": {
            "port": "!=null",
            "dst": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at SRC. SRC must be at least short aligned. This is used by the IDE driver to read disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the inw() breaks things.",
        "pre": {
            "port": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},




{
    "kretprobe:outsw": {
        "description": "Write data from source to the specified port in the opposite direction.",
        "pre": {
            "port": "!=null",
            "src": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:outsw": {
        "description": "Write data from source buffer to the specified port.",
        "pre": {
            "port": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},


{
    "kretprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path.",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path.",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},


{
    "kretprobe:pdc_iodc_read": {
        "description": "Read data from the modules IODC.",
        "pre": {
            "actcnt": "!=null",
            "hpa": "!=null",
            "index": "!=null",
            "iodc_data": "!=null",
            "iodc_data_size": "!=null"
        }
    }
},
{
    "kprobe:pdc_iodc_read": {
        "description": "Read data from the modules IODC.",
        "pre": {
            "actcnt": "!=null",
            "hpa": "!=null",
            "index": "!=null",
            "iodc_data": "!=null",
            "iodc_data_size": "!=null"
        }
    }
},
{
    "kretprobe:pdc_lan_station_id": {
        "description": "Get the LAN address.",
        "pre": {
            "lan_addr": "!=null",
            "hpa": "!=null"
        }
    }
},
{
    "kprobe:pdc_lan_station_id": {
        "description": "Get the LAN address.",
        "pre": {
            "lan_addr": "!=null",
            "hpa": "!=null"
        }
    }
},
{
    "kretprobe:pdc_stable_read": {
        "description": "Read data from Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kprobe:pdc_stable_read": {
        "description": "Read data from Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kretprobe:pdc_stable_write": {
        "description": "Write data to Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kprobe:pdc_stable_write": {
        "description": "Write data to Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kretprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "pre": {
            "void": "pdc_stable_verify_contents()",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "pre": {
            "void": "null"
        }
    }
},
{
    "kretprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator. This PDC call will erase all contents of Stable Storage. Use with care!",
        "pre": {
            "void": "pdc_stable_initialize()",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kretprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kretprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock.",
        "pre": {
            "sec": "!=null",
            "usec": "!=null"
        }
    }
},
{
    "kprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock.",
        "pre": {
            "sec": ">=0",
            "usec": ">=0"
        }
    }
},

{
    "kprobe:if (btlb_info.max_size==0)": {
        "description": "Check if btlb_info.max_size is equal to 0.",
        "pre": {
            "btlb_info.max_size": "==0"
        }
    }
},

{
    "kprobe:asm_syncdma": {
        "description": "Ensure DMA is complete",
        "pre": {
            "!IS_ENABLED(CONFIG_SMP)": true,
            "!arch_irqs_disabled()": true,
            "size": ">= parisc_cache_flush_threshold"
        }
    }
},


{
    "kretprobe:fb_is_primary_device": {
        "description": "Check if the given framebuffer is the primary device.",
        "pre": {
            "info": "!=null",
            "sti": "==null"
        }
    }
},
{
    "kprobe:if (!sti)return true;/* return true if it's the default built-in framebuffer driver `": {
        "description": "Check if it's the default built-in framebuffer driver",
        "pre": {
            "sti": "!=null"
        }
    }
},
{
    "kretprobe:__delay": {
        "description": "Loop 'loops' times. Callers must not assume a specific amount of time passes before this function returns.",
        "pre": {
            "loops": "!=null",
            "loops": ">=0",
            "loops": "is_integer"
        }
    }
},




{
    "kprobe:__atomic_add_const": {
        "description": "Put the reader into the wait queue",
        "pre": {
            "rw": "arch_rwlock_t",
            "in_interrupt()": false,
            "rw->cnts & 0x10000": 0
        }
    }
},
{
    "kretprobe:__atomic_add": {
        "description": "Put the writer into the wait queue",
        "pre": {
            "rw": "!=null",
            "__atomic_add(0x20000, &rw->cnts)": "!=null"
        }
    }
},
{
    "kprobe:__atomic_add": {
        "description": "Add 0x20000 to the value of rw->cnts.",
        "pre": {
            "rw": "!=null",
            "rw->cnts": "!=null",
            "__atomic_add(0x20000, &rw->cnts)": "true"
        }
    }
},
{
    "kretprobe:return result + size;/* Nope. ": {
        "description": "This function returns the sum of 'result' and 'size'.",
        "pre": {
            "result": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:return result + size;/* Nope. `": {
        "description": "Calculate the sum of result and size.",
        "pre": {
            "result": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:strlen": {
        "description": "Find the length of a string",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:strlen": {
        "description": "Find the length of a string",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:strnlen": {
        "description": "Find the length of a length-limited string",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "<=min(strlen(s), n)"
        }
    }
},
{
    "kprobe:strnlen": {
        "description": "Find the length of a length-limited string",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copy a %NUL terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "dest"
        }
    }
},
{
    "kprobe:strcpy": {
        "description": "Copy a %NUL terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strcat": {
        "description": "Append one %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "is the same as dest"
        }
    }
},
{
    "kprobe:strcat": {
        "description": "Append one %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "dest"
        }
    }
},
{
    "kretprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "is a pointer to dest"
        }
    }
},
{
    "kprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return_value": "==0 if s1 and s2 are equal, <0 if s1 is less than s2, >0 if s1 is greater than s2"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return": "is an integer"
        }
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        },
        "post": {
            "return": "in [ s + n]"
        }
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:_copy_from_user_key": {
        "description": "Copy data from user space to kernel space with key",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "size": "!=null",
            "key": "!=null",
            "rem": "((from + 4095) & -4096)",
            "val": "nr%[val]"
        }
    }
},
{
    "kprobe:nr%[rem],%[val]": {
        "description": "Function: nr%[rem],%[val]\nrem = (from + 4095) & -4096",
        "pre": {
            "from": "!=null",
            "rem": "((from + 4095) & -4096)"
        }
    }
},
{
    "kretprobe:nr%[rem],%[val]": {
        "description": "Description of the function nr%[rem],%[val]",
        "pre": {
            "to": "!=null",
            "size": "!=null",
            "rem": "!=null",
            "val": "!=null"
        },
        "post": {
            "rem": "(to + 4095) & -4096"
        }
    }
},
{
    "kprobe:nr%[rem],%[val]": {
        "description": "Helper function to calculate rem = (to + 4095) & -4096",
        "pre": {
            "to": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:chacha_crypt_arch": {
        "description": "chacha_crypt_arch helper function",
        "pre": {
            "bytes": "<= CHACHA_BLOCK_SIZE",
            "nrounds": "!= 20",
            "MACHINE_HAS_VX": "== false"
        }
    }
},
{
    "kprobe:chacha_crypt_arch": {
        "description": "Perform chacha20 encryption/decryption using the s390 implementation.",
        "pre": {
            "bytes": "<= CHACHA_BLOCK_SIZE || nrounds != 20 || !MACHINE_HAS_VX"
        }
    }
},
{
    "kretprobe:set_pte": {
        "description": "Reset the protection bits of a page table entry.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null",
            "ptep": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:set_pte": {
        "description": "Reset the protection bits of a page table entry.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null",
            "ptep": "!=null",
            "new": "!=null"
        }
    }
},




{
    "kretprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "orc": "in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
            "oldpte": "!=null",
            "oldpgste": "!=null"
        },
        "post": {
            "return": "in [1, 0, < 0]",
            "return_description": "1 if the page is to be added to the CBRL, otherwise 0, or < 0 in case of error.",
            "return_constraints": {
                "1": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
                "0": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
                "< 0": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]"
            }
        }
    }
},
{
    "kprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "orc": "in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
            "oldpte": "null or !=null",
            "oldpgste": "null or !=null"
        },
        "return": "in [1, 0, < 0]"
    }
},
{
    "kretprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "bits": "!=null",
            "value": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "bits": "!=null",
            "value": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "pgstep": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "pgstep": "!=null"
        },
        "return": "< 0"
    }
},
{
    "kretprobe:__segment_load": {
        "description": "Load a segment",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is an integer",
            "addr": "!=null",
            "end": "!=null"
        },
        "post": {
            "return": "< 0 || >= 0"
        }
    }
},
{
    "kprobe:__segment_load": {
        "description": "Load a segment",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is int",
            "addr": "!=null",
            "end": "!=null",
            "return": "< 0 || >= 0"
        }
    }
},
{
    "kretprobe:segment_save": {
        "description": "Save segment content permanently",
        "pre": {
            "name": "!=null",
            "MACHINE_IS_VM": "true",
            "seg": "!=null",
            "ref_count": "==0",
            "seg->res": "!=null",
            "seg->start_addr": "!=null",
            "seg->end - seg->start_addr + 1": ">0"
        }
    }
},
{
    "kprobe:segment_save": {
        "description": "Save segment content permanently.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:segment_warning": {
        "description": "Print appropriate error message for segment_load()segment_type() return code.",
        "pre": {
            "rc": "!=null",
            "seg_name": "!=null"
        }
    }
},
{
    "kprobe:segment_warning": {
        "description": "Print appropriate error message for segment_load()segment_type() return code.",
        "pre": {
            "rc": "is_int",
            "seg_name": "is_valid_char_pointer"
        }
    }
},
{
    "kretprobe:function_name": {
        "description": "Description of the function",
        "pre": {
            "qin->qopcode": "DCSS_FINDSEGA",
            "qin->qoutptr": "!=null",
            "qin->qoutlen": "sizeof(struct qout64)",
            "qin->qname": "seg->dcss_name",
            "diag_cc": "< 0"
        }
    }
},
{
    "kprobe:qin->qopcode": {
        "description": "Set qopcode to DCSS_FINDSEGA",
        "pre": {
            "qopcode": "DCSS_FINDSEGA"
        }
    },
    "kprobe:qin->qoutptr": {
        "description": "Set qoutptr to the address of qout",
        "pre": {
            "qoutptr": "address of qout"
        }
    },
    "kprobe:qin->qoutlen": {
        "description": "Set qoutlen to the size of struct qout64",
        "pre": {
            "qoutlen": "sizeof(struct qout64)"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy seg->dcss_name to qin->qname with a length of 8",
        "pre": {
            "qname": "copy of seg->dcss_name with length 8"
        }
    },
    "kprobe:dcss_diag": {
        "description": "Call dcss_diag with segext_scode, qin, dummy, and vmrc",
        "pre": {
            "segext_scode": "no specific constraints",
            "qin": "no specific constraints",
            "dummy": "no specific constraints",
            "vmrc": "no specific constraints"
        }
    },
    "kprobe:if (diag_cc < 0)": {
        "description": "Check if diag_cc is less than 0"
    }
},
{
    "kretprobe:segment_unload": {
        "description": "Decrease the use count of a DCSS segment and remove it from the address space if nobody is using it any longer.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:voidsegment_unload": {
        "description": "Decrease the use count of a DCSS segment and remove it from the address space if nobody is using it any longer.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pci_iomap_range_mio": {
        "description": "Detect overrun",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null",
            "offset": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:WARN_ON(!++zpci_iomap_start[idx].count);zpci_iomap_start[idx].fh = zdev->fh;zpci_iomap_start[idx].bar = bar;spin_unlock(&zpci_iomap_lock);return (void __iomem *) ZPCI_ADDR(idx) + offset;}static void __iomem *pci_iomap_range_mio(struct pci_dev *pdev, int bar, unsigned long offset, unsigned long max)": {
        "description": "pci_iomap_range_mio function with WARN_ON check and return value calculation",
        "pre": {
            "pdev": "!=null",
            "bar": "int",
            "offset": "unsigned long",
            "max": "unsigned long",
            "zpci_iomap_start[idx].count": "int",
            "zdev->fh": "!=null",
            "zpci_iomap_start[idx].bar": "int",
            "zpci_iomap_lock": "spinlock_t"
        }
    }
},




{
    "kretprobe:stsi": {
        "description": "Store system information. Returns the current configuration level if function code 0 was specified. Otherwise returns 0 on success or a negative value on error.",
        "pre": {
            "sysinfo": "!=null",
            "fc": "!=null",
            "sel1": "!=null",
            "sel2": "!=null",
            "lvl": "!=null"
        }
    }
},
{
    "kprobe:stsi": {
        "description": "Store system information",
        "pre": {
            "sysinfo": "!=null",
            "fc": "!=null",
            "sel1": "!=null",
            "sel2": "!=null",
            "lvl": "!=null"
        }
    }
},
{
    "kretprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "pre": {
            "num": "!=null"
        }
    }
},
{
    "kprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "pre": {
            "num": "!=null"
        }
    }
},


{
    "kretprobe:debug_register_mode": {
        "description": "Creates and initializes a debug area.",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">=0",
            "nr_areas": ">=0",
            "buf_size": ">=0",
            "mode": ">=0",
            "uid": "==0",
            "gid": "==0"
        }
    }
},
{
    "kprobe:debug_register_mode": {
        "description": "Creates and initializes a debug area.",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">=0",
            "nr_areas": ">=0",
            "buf_size": ">=0",
            "mode": ">=0",
            "uid": "==0",
            "gid": "==0"
        }
    }
},


{
    "kretprobe:debug_unregister": {
        "description": "Give back debug area.",
        "pre": {
            "id": "!=null",
            "loop": {
                "index": "i",
                "range": {
                    "start": 0,
                    "end": "DEBUG_MAX_VIEWS - 1"
                },
                "body": {
                    "if": {
                        "condition": "id->views[i] != null",
                        "body": {
                            "debugfs_remove": "id->debugfs_entries[i]"
                        }
                    }
                }
            },
            "debugfs_remove": "id->debugfs_root_entry",
            "assignments": [
                {
                    "condition": "id == debug_area_first",
                    "assignment": "debug_area_first = id->next"
                },
                {
                    "condition": "id == debug_area_last",
                    "assignment": "debug_area_last = id->prev"
                },
                {
                    "condition": "id->prev",
                    "assignment": "id->prev->next = id->next"
                },
                {
                    "condition": "id->next",
                    "assignment": "id->next->prev = id->prev"
                }
            ]
        },
        "post": {
            "return": "none"
        }
    }
},
{
    "kprobe:debug_unregister": {
        "description": "Give back debug area.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "pre": {
            "id": "!=null",
            "new_level": "int"
        },
        "post": {
            "return": "none"
        }
    }
},
{
    "kprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "pre": {
            "id": "!=null",
            "new_level": "!=null"
        }
    }
},
{
    "kretprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed.",
        "pre": {},
        "post": {
            "return": "null"
        }
    }
},
{
    "kprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed.",
        "pre": {
            "none": "true"
        }
    }
},
{
    "kretprobe:debug_event_common": {
        "description": "Write debug entry with given size",
        "pre": {
            "id": "!=null",
            "level": "any",
            "buf": "!=null",
            "len": ">0"
        }
    }
},

{
    "kretprobe:debug_exception_common": {
        "description": "write debug entry with given size and switch to next debug area",
        "pre": {
            "id": "!=null",
            "level": "any integer value",
            "buf": "!=null",
            "len": "any integer value"
        },
        "return_value": "!=null"
    }
},
{
    "kprobe:debug_exception_common": {
        "description": "write debug entry with given size and switch to next debug area",
        "pre": {
            "id": "!=null",
            "level": "is an integer",
            "buf": "!=null",
            "len": "is an integer"
        }
    }
},
{
    "kretprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs directory entry.",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs directory entry.",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        }
    }
},
{
    "kretprobe:debug_feature_version": {
        "description": "Used by dump analysis tools to determine the version of debug feature.",
        "pre": {
            "__used debug_feature_version": "!=null"
        }
    }
},
{
    "kprobe:debug_feature_version": {
        "description": "Static global variable representing the debug feature version.",
        "pre": {
            "debug_feature_version": "= __DEBUG_FEATURE_VERSION"
        }
    }
},
{
    "kretprobe:get_phys_clock": {
        "description": "Helper function to get the physical clock.",
        "pre": {
            "clock": "!=null",
            "sw_ptr": "!=null",
            "sw0": "!=null",
            "sw1": "!=null"
        },
        "post": {
            "return": "in [0, -EOPNOTSUPP, -EACCE -EAGAIN]",
            "!test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": true,
            "!test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": true,
            "sw0": "sw1",
            "(sw0 & 0x80000000U)": true
        }
    }
},
{
    "kprobe:return_0_if_not_supported": {
        "description": "Return 0 if the clock synchronization has STP and STP is set, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "true",
            "test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": "true"
        }
    },
    "kprobe:return_0_if_synced": {
        "description": "Return 0 if the clock synchronization has STP and STP is not set, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "true",
            "test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": "false"
        }
    },
    "kprobe:return_error": {
        "description": "Return -EAGAIN if the clock synchronization does not have STP, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "false"
        }
    }
},
{
    "kretprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null"
        }
    }
},
{
    "kprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null"
        }
    }
},
{
    "kretprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Save floating point control": {
        "description": "Limit the save to the FPUvector registers already in use by the previous context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Save floating point control `": {
        "description": "Limit the save to the FPUvector registers already in use by the previous context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Restore floating-point controls": {
        "description": "Limit the restore to the FPUvector registers of the previous context that have been overwritten by the current context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Restore floating-point controls": {
        "description": "Limit the restore to the FPUvector registers of the previous context that have been overwritten by the current context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},






{
    "kretprobe:diag14": {
        "description": "Diagnose 14: Input spool file manipulation",
        "pre": {
            "rx": "!=null",
            "ry1": "!=null",
            "subcode": "!=null"
        }
    }
},
{
    "kprobe:diag14": {
        "description": "Diagnose 14: Input spool file manipulation",
        "pre": {
            "rx": "!=null",
            "ry1": "!=null",
            "subcode": "!=null"
        }
    }
},

{
    "kprobe:struct_uv_info___bootdata_preserved": {
        "description": "Function to preserve uv_info structure",
        "pre": {
            "uv_info": "!=null",
            "module": "in [KVM, PV guest]"
        },
        "post": {
            "sysfs_interface": "readable"
        }
    }
},


{
    "kretprobe:csum_partial_copy_from_user": {
        "description": "Computes a partial checksum for TCP/UDP fragments.",
        "pre": {
            "skb": "!=null",
            "off": ">=0",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},
{
    "kprobe:csum_partial_copy_from_user": {
        "description": "Computes a partial checksum for TCP/UDP fragments.",
        "pre": {
            "skb": "!=null",
            "off": ">=0",
            "len": ">=0",
            "sum": "!=null"
        }
    }
},


{
    "kretprobe:cache_clear": {
        "description": "Clear cache entries for the area defined by a physical address.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address"
        }
    }
},
{
    "kprobe:cache_clear": {
        "description": "Clear any cache entries for the area defined by the physical address.",
        "pre": {
            "paddr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:cache_push": {
        "description": "Write back dirty cache data in the given area and invalidate the range in the instruction cache.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address",
            "range": "within_valid_memory_range",
            "cache_data": "dirty",
            "instruction_cache_range": "invalidated"
        }
    }
},
{
    "kprobe:cache_push": {
        "description": "Write back dirty cache data and invalidate instruction cache for a given physical address range.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address",
            "len": "<=max_allowed_length"
        }
    }
},
{
    "kretprobe:mm_cachebits": {
        "description": "Bits to add to page descriptors for 'normal' caching mode.",
        "pre": {
            "mm_cachebits": "!=null",
            "mm_cachebits": "in [0, _PAGE_CACHE040]"
        }
    }
},
{
    "kprobe:mm_cachebits": {
        "description": "Bits to add to page descriptors for 'normal' caching mode.",
        "pre": {
            "mm_cachebits": "!=null"
        }
    }
},
{
    "kretprobe:if (!size || physaddr > (unsigned long)(-size))return NULL;#ifdef CONFIG_AMIGAif (MACH_IS_AMIGA)": {
        "description": "The condition for the given function",
        "pre": {
            "size": "!=null",
            "physaddr": "> (unsigned long)(-size)",
            "CONFIG_AMIGA": "defined",
            "MACH_IS_AMIGA": "defined"
        }
    }
},
{
    "kprobe:if (!size || physaddr > (unsigned long)(-size))return NULL;#ifdef CONFIG_AMIGAif (MACH_IS_AMIGA)": {
        "description": "Helper function for mapping physical addresses to virtual addresses.",
        "pre": {
            "size": "!=null",
            "physaddr": "!=null",
            "size or physaddr": "!=null",
            "physaddr > (unsigned long)(-size)": "true",
            "CONFIG_AMIGA": "defined",
            "MACH_IS_AMIGA": "defined"
        }
    }
},
{
    "kretprobe:__free_io_area": {
        "description": "Map some physical address range into the kernel address space.",
        "pre": {
            "tmp->addr": "!=null",
            "tmp->size - IO_SIZE": ">=0"
        }
    }
},
{
    "kprobe:__free_io_area": {
        "description": "Map some physical address range into the kernel address space.",
        "pre": {
            "tmp->addr": "!=null",
            "tmp->size - IO_SIZE": ">0"
        }
    }
},
{
    "kretprobe:offset = phys & (PAGE_SIZE-1);phys &= ~(PAGE_SIZE-1);size += offset;size = PAGE_ALIGN(size);if((area = get_vm_area(size, VM_IOREMAP)) == NULL)return NULL;#ifdef SUN3_KMAP_DEBUGpr_info(\"ioremap: got virt %p size %lx(%lx)\\n\", area->addr, size,area->size);#endifpages = size / PAGE_SIZE;virt = (unsigned long)area->addr;ret = virt + offset;while(pages)": {
        "description": "The kretprobe function",
        "pre": {
            "phys": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:offset = phys & (PAGE_SIZE-1);phys &= ~(PAGE_SIZE-1);size += offset;size = PAGE_ALIGN(size);if((area = get_vm_area(size, VM_IOREMAP)) == NULL)return NULL;#ifdef SUN3_KMAP_DEBUGpr_info(\"ioremap: got virt %p size %lx(%lx)\\n\", area->addr, size,area->size);#endifpages = size / PAGE_SIZE;virt = (unsigned long)area->addr;ret = virt + offset;while(pages)": {
        "description": "The given function performs ioremap operation on a physical address range.",
        "pre": {
            "phys": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:hwreg_write": {
        "description": "Write a value to a hardware register.",
        "pre": {
            "regp": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:hwreg_write": {
        "description": "Write a value to a hardware register.",
        "pre": {
            "regp": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(amiga_audio_min_period)": {
        "description": "Helper function for amiga_audio_min_period",
        "pre": {
            "amiga_audio_min_period": "==124"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(amiga_audio_min_period)": {
        "description": "Helper function for amiga_audio_min_period",
        "pre": {
            "amiga_audio_min_period": "==124"
        }
    }
},
{
    "kretprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'",
        "pre": {
            "handler": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'.",
        "pre": {
            "handler": "!=null",
            "data": "!=null"
        }
    }
},




{
    "kretprobe:stdma_is_locked_by": {
        "description": "Allow lock holder to check whether it needs to release.",
        "pre": {
            "handler": "!=null"
        }
    }
},

{
    "kretprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked.",
        "pre": {
            "ints_disabled": "==true"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked.",
        "pre": {
            "ints_disabled": "==true"
        }
    }
},






{
    "kretprobe:size = PAGE_ALIGN(size);res = kzalloc(sizeof(struct resource), GFP_KERNEL);if (!res)return NULL;res->name = owner;error = allocate_resource(&stram_pool, re size, 0, UINT_MAX,  PAGE_SIZE, NULL, NULL);if (error < 0)": {
        "description": "Allocate memory for a resource and assign a name to it.",
        "pre": {
            "size": "!=null",
            "res": "!=null",
            "owner": "!=null",
            "error": "< 0"
        }
    }
},
{
    "kprobe:size = PAGE_ALIGN(size);res = kzalloc(sizeof(struct resource), GFP_KERNEL);if (!res)return NULL;res->name = owner;error = allocate_resource(&stram_pool, re size, 0, UINT_MAX,  PAGE_SIZE, NULL, NULL);if (error < 0)": {
        "description": "Allocate a resource for Atari stram",
        "pre": {
            "size": "!=null",
            "owner": "!=null"
        }
    }
},




{
    "kretprobe:__mcfgpio_direction_output": {
        "description": "Set the direction of GPIO to output.",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START",
            "gpio_type": "== unsigned",
            "value": "!= null"
        }
    }
},
{
    "kprobe:__mcfgpio_direction_output": {
        "description": "Set the direction of GPIO pin to output.",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START"
        }
    }
},
{
    "kretprobe:clk_disable0": {
        "description": "Disable the clock specified by `clk`.",
        "pre": {
            "clk": "!=null"
        }
    }
},
{
    "kprobe:clk_disable0": {
        "description": "Disable the clock specified by `clk`.",
        "pre": {
            "clk": "!=null"
        }
    }
},
{
    "kretprobe:macintosh_config": {
        "description": "Macintosh Table: hardcoded model configuration data.",
        "pre": {
            "macintosh_config->ident": "== MAC_MODEL_IICI",
            "mach_l2_flush": "== via_l2_flush",
            "register_platform_power_off(mac_poweroff)": ""
        }
    }
},



{
    "kretprobe:crash_shutdown_register": {
        "description": "Register a crash shutdown handler.",
        "pre": {
            "handler": "!=null",
            "crash_handlers_lock": "locked",
            "crash_shutdown_handles[i]": "==null",
            "i": "< CRASH_HANDLER_MAX"
        },
        "post": {
            "crash_shutdown_handles[i]": "==handler",
            "rc": "==0"
        }
    }
},



{
    "kretprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "pre": {
            "start": "!=null",
            "stop": "!=null"
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "pre": {
            "start": "!=null",
            "stop": "!=null",
            "start < stop": true
        }
    }
},


{
    "kretprobe:__node_distance": {
        "description": "Calculate the distance between two nodes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "i": ">=0",
            "distance": "!=null",
            "affinity_form": "in [FORM2_AFFINITY, FORM0_AFFINITY]",
            "numa_distance_table": "!=null when affinity_form == FORM2_AFFINITY",
            "distance_ref_points_depth": ">=0",
            "distance_lookup_table": "!=null",
            "LOCAL_DISTANCE": "!=null",
            "REMOTE_DISTANCE": "!=null"
        },
        "post": {
            "distance": "distance * 2"
        }
    }
},
{
    "kprobe:__node_distance": {
        "description": "Calculate the distance between two nodes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "i": ">=0",
            "distance": "!=null",
            "affinity_form": "in [FORM2_AFFINITY, FORM0_AFFINITY]",
            "numa_distance_table": "!=null",
            "distance_ref_points_depth": ">=0",
            "distance_lookup_table": "!=null"
        }
    }
},
{
    "kretprobe:of_node_to_nid": {
        "description": "Walk the device tree upward looking for an associativity id",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:of_node_to_nid": {
        "description": "Walk the device tree upward looking for an associativity id",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:iounmap": {
        "description": "Unmap an I/O memory region.",
        "pre": {
            "addr": "!= null",
            "v_block_mapped((unsigned long)addr)": "false",
            "addr > high_memory": "false",
            "(unsigned long)addr < ioremap_bot": "false"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "Unmap an I/O memory address.",
        "pre": {
            "addr": "not mapped by BATs"
        }
    }
},
{
    "kretprobe:if (pte_write(pte)) pte = pte_mkdirty(pte);": {
        "description": "Check if the given page table entry is writable and update it to be dirty if it is.",
        "pre": {
            "pte": "!=null",
            "pte_write(pte)": true,
            "pte_mkdirty(pte)": "!=null"
        }
    }
},
{
    "kprobe:if (pte_write(pte))pte = pte_mkdirty(pte);/* we don't want to let _PAGE_USER and _PAGE_EXEC leak out `": {
        "description": "Check if pte is writable and update it to be dirty if true.",
        "pre": {
            "pte": "!=null",
            "pte_write(pte)": "true",
            "pte_mkdirty(pte)": "!=null"
        }
    }
},


{
    "kretprobe:if (radix_enabled() && ((vm_flags & VM_ACCESS_FLAGS) == VM_EXEC))": {
        "description": "Check if radix is enabled and if the VM flags indicate executable access.",
        "pre": {
            "radix_enabled()": true,
            "vm_flags & VM_ACCESS_FLAGS": "VM_EXEC"
        }
    }
},
{
    "kprobe:radix_enabled": {
        "description": "Check if radix is enabled.",
        "pre": {}
    },
    "kprobe:vm_flags": {
        "description": "Get the value of vm_flags.",
        "pre": {}
    },
    "kprobe:VM_ACCESS_FLAGS": {
        "description": "Get the value of VM_ACCESS_FLAGS.",
        "pre": {}
    },
    "kprobe:VM_EXEC": {
        "description": "Get the value of VM_EXEC.",
        "pre": {}
    },
    "kprobe:if_condition": {
        "description": "Check if radix is enabled and vm_flags & VM_ACCESS_FLAGS == VM_EXEC.",
        "pre": {
            "radix_enabled()": "true",
            "vm_flags & VM_ACCESS_FLAGS": "VM_EXEC"
        }
    }
},
{
    "kretprobe:radix__local_flush_tlb_page_psize": {
        "description": "Flush the TLB page for a specific page size in the local radix tree.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        }
    }
},
{
    "kprobe:radix__local_flush_tlb_page_psize": {
        "description": "Flush the TLB page for a specific page size in the local radix tree.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        }
    }
},
{
    "kretprobe:smp_mb": {
        "description": "Memory barrier that ensures that all memory operations before the barrier are completed before any memory operations after the barrier.",
        "pre": {
            "mm": "!=null",
            "type": "in [FLUSH_TYPE_LOCAL, FLUSH_TYPE_GLOBAL]"
        }
    },
    "kretprobe:flush_type_needed": {
        "description": "Determines the type of flush needed for the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "flush_type": "in [FLUSH_TYPE_LOCAL, FLUSH_TYPE_GLOBAL]"
        }
    }
},

{
    "kretprobe:flush_type_needed": {
        "description": "Determines the flush type needed for a given memory management structure.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        },
        "post": {
            "type": "==FLUSH_TYPE_LOCAL"
        }
    }
},

{
    "kretprobe:flush_type_needed": {
        "description": "Check the flush type needed for the given mm struct.",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "end": "!=null",
            "pid": "!=MMU_NO_CONTEXT",
            "nr_pages": "> (end - start) >> page_shift",
            "flush_pid": "true",
            "flush_pwc": "false",
            "type": "in [FLUSH_TYPE_NONE, FLUSH_TYPE_GLOBAL]"
        }
    }
},
{
    "flush_type_needed": {
        "description": "Determines the type of flush needed for the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "false": "boolean"
        }
    },
    "FLUSH_TYPE_NONE": {
        "description": "Constant representing no flush type.",
        "pre": {}
    },
    "FLUSH_TYPE_GLOBAL": {
        "description": "Constant representing global flush type.",
        "pre": {}
    },
    "flush_pid": {
        "description": "Flag indicating whether to flush the PID.",
        "pre": {
            "nr_pages": "> tlb_single_page_flush_ceiling",
            "nr_pages": "> tlb_local_single_page_flush_ceiling"
        }
    },
    "tlb_single_page_flush_ceiling": {
        "description": "Constant representing the ceiling value for single page flush.",
        "pre": {}
    },
    "tlb_local_single_page_flush_ceiling": {
        "description": "Constant representing the ceiling value for local single page flush.",
        "pre": {}
    },
    "pid": {
        "description": "Process ID associated with the mm_struct.",
        "pre": {
            "mm": "!=null",
            "mm->context.id": "!=MMU_NO_CONTEXT"
        }
    },
    "MMU_NO_CONTEXT": {
        "description": "Constant representing no context for the mm_struct.",
        "pre": {}
    },
    "end": {
        "description": "End address of the range to flush.",
        "pre": {
            "end": "!=TLB_FLUSH_ALL"
        }
    },
    "preempt_disable": {
        "description": "Disables preemption.",
        "pre": {}
    },
    "smp_mb": {
        "description": "Performs a memory barrier.",
        "pre": {}
    }
},
{
    "kretprobe:isync();}EXPORT_SYMBOL(switch_mmu_context": {
        "description": "Switches the MMU context and performs an isync operation.",
        "pre": {
            "prev": "!=null",
            "next": "!=null",
            "tsk": "!=null",
            "next->context.id": ">= 0",
            "next->context.sr0": "!=null",
            "IS_ENABLED(CONFIG_BDI_SWITCH)": "true",
            "mmu_has_feature(MMU_FTR_HPTE_TABLE)": "true"
        }
    }
},
{
    "kprobe:isync();}EXPORT_SYMBOL(switch_mmu_context": {
        "description": "Switches the MMU context and performs an isync operation.",
        "pre": {
            "prev": "!=null",
            "next": "!=null",
            "tsk": "!=null",
            "next->context.id": "< 0",
            "next->context.sr0": "!=null",
            "IS_ENABLED(CONFIG_BDI_SWITCH)": "true",
            "mmu_has_feature(MMU_FTR_HPTE_TABLE)": "false"
        }
    }
},
{
    "kretprobe:for_each_vma": {
        "description": "Flush the TLB for each virtual memory area (vma) in the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "mp": "!=null",
            "vmi": "!=null",
            "mmap_lock": "held",
            "vmtruncate": "not called on SMP",
            "dup_mmap": "called"
        }
    }
},
{
    "kprobe:for_each_vma(vmi, mp)hash__flush_range(mp->vm_mm, mp->vm_start, mp->vm_end);}EXPORT_SYMBOL(hash__flush_tlb_mm": {
        "description": "Flush the TLB entries for a given memory range in the specified mm_struct.",
        "pre": {
            "mm": "!=null",
            "mp": "!=null",
            "vmi": "!=null",
            "vm_start": "!=null",
            "vm_end": "!=null"
        }
    }
},
{
    "kretprobe:cpm_setbrg": {
        "description": "Set the value of the BRG counter for SMCs.",
        "pre": {
            "bp": "!=null",
            "brg": "!=null"
        }
    }
},
{
    "kprobe:cpm_setbrg": {
        "description": "Set the baud rate generator (BRG) for SMCs.",
        "pre": {
            "brg": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:ps3_irq_plug_destroy": {
        "description": "Destroy the plugged IRQ associated with the given virtual IRQ.",
        "pre": {
            "virq": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ps3_irq_plug_destroy": {
        "description": "Destroy the IRQ plug associated with the given virtual IRQ.",
        "pre": {
            "virq": "!=null"
        }
    }
},


{
    "kretprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a Linux physical address to LPAR address.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a Linux physical address to LPAR address.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes",
        "pre": {
            "new_entitlement": "!=null",
            "new_entitlement": ">=0",
            "new_entitlement": "<=MAX_SIZE_T"
        },
        "post": {
            "return_value": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes",
        "pre": {
            "new_entitlement": "!=null"
        }
    }
},
{
    "kretprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device",
        "pre": {
            "viodev": "!=null",
            "desired": ">=0"
        }
    }
},
{
    "kprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device",
        "pre": {
            "viodev": "!=null",
            "desired": "!=null"
        }
    }
},
{
    "kretprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation",
        "pre": {
            "vdev": "!=null",
            "op": "!=null",
            "op->hcall_ret": "is int",
            "op->hcall_ret": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCE -EPERM]"
        }
    }
},
{
    "kprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation",
        "pre": {
            "vdev": "!=null",
            "op": "!=null",
            "op->hcall_ret": "!=null",
            "op->hcall_ret": "int",
            "op->hcall_ret": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCE -EPERM]",
            "op->timeout": "int",
            "op->timeout": ">=0"
        }
    }
},
{
    "kretprobe:__vio_register_driver": {
        "description": "__vio_register_driver function",
        "pre": {
            "viodrv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null",
            "viodrv->driver.name": "viodrv->name",
            "viodrv->driver.pm": "viodrv->pm",
            "viodrv->driver.bus": "&vio_bus_type",
            "viodrv->driver.owner": "owner",
            "viodrv->driver.mod_name": "mod_name"
        }
    }
},
{
    "kprobe:__vio_register_driver": {
        "description": "__vio_register_driver(struct vio_driver viodrv, struct module owner, const char mod_name)",
        "pre": {
            "viodrv": {
                "driver": {
                    "name": "!=null",
                    "pm": "!=null",
                    "bus": "&vio_bus_type",
                    "owner": "owner",
                    "mod_name": "mod_name"
                }
            }
        }
    }
},
{
    "kretprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kretprobe:vio_register_device_node": {
        "description": "Register a new vio device.",
        "pre": {
            "of_node": "!=null",
            "of_node.device_type": "!=null",
            "of_node.compatible": "!=null"
        }
    }
},
{
    "kprobe:vio_register_device_node": {
        "description": "Register a new vio device.",
        "pre": {
            "of_node": "!=null",
            "of_node.device_type": "!=null",
            "of_node.compatible": "!=null"
        }
    }
},
{
    "kretprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev",
        "pre": {
            "vnode": "!=null"
        }
    }
},
{
    "kprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev",
        "pre": {
            "vnode": "!=null"
        }
    }
},


{
    "kretprobe:ibmebus_matches": {
        "description": "These devices will automatically be added to the bus during init",
        "pre": {
            "ibmebus_bus_type": "!=null"
        }
    }
},

{
    "kretprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter.",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=16"
        }
    }
},
{
    "kprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:h_get_mpp": {
        "description": "Returns info in 7 parameters",
        "pre": {},
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:h_get_mpp": {
        "description": "Helper function h_get_mpp returns info in 7 parameters.",
        "pre": {
            "mpp_data": "!=null"
        }
    }
},

{
    "kprobe:data->drc_type = (char *)p;p = of_prop_next_string(*prop, p);if (!p)return -EINVAL;": {
        "description": "Set the value of data->drc_type and update p using of_prop_next_string. Return -EINVAL if p is null.",
        "pre": {
            "data": "!=null",
            "prop": "!=null",
            "p": "!=null",
            "of_prop_next_string(*prop, p)": "!=null",
            "return": "-EINVAL if p is null"
        }
    }
},

{
    "kprobe:hvcs_free_partner_info": {
        "description": "Free the partner info list returned by hvcs_get_partner_info()",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty.",
        "pre": {
            "unit_address": "!=null",
            "p_partition_ID": "!=null",
            "p_unit_address": "!=null"
        }
    }
},
{
    "kprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty.",
        "pre": {
            "unit_address": "!=null",
            "p_partition_ID": "!=null",
            "p_unit_address": "!=null"
        }
    }
},
{
    "kretprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty",
        "pre": {
            "unit_address": "!=null"
        }
    }
},
{
    "kprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty.",
        "pre": {
            "unit_address": "!=null"
        }
    }
},


{
    "kretprobe:opal_pci_set_xive_pe": {
        "description": "Assign XIVE to PE",
        "pre": {
            "phb->opal_id": "!=null",
            "pe->pe_number": "!=null",
            "xive_num": "!=null"
        }
    }
},
{
    "kprobe:opal_pci_set_xive_pe": {
        "description": "Assign XIVE to PE",
        "pre": {
            "phb->opal_id": "!=null",
            "pe->pe_number": "!=null",
            "xive_num": "!=null"
        }
    }
},


{
    "kretprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number",
        "pre": {
            "irq": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number",
        "pre": {
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer",
        "pre": {
            "gpt": "!=null",
            "period": ">=0",
            "continuous": "in [0, 1]"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer",
        "pre": {
            "gpt": "!=null",
            "period": ">=0",
            "continuous": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt",
        "pre": {
            "gpt": "!=null"
        },
        "post": {
            "return_value": "is_error_when_attempting_to_stop_wdt"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt",
        "pre": {
            "gpt": "!=null",
            "gpt->wdt": "==null"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "!=null"
        }
    }
},


{
    "kretprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_chan": {
        "description": "Allocate a DMA channel",
        "pre": {
            "type": "in [PASEMI_DMA_RX, PASEMI_DMA_TX]",
            "total_size": ">=0",
            "offset": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_chan": {
        "description": "Allocate a DMA channel",
        "pre": {
            "type": "in [RX, TX]",
            "total_size": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_chan": {
        "description": "Free a previously allocated channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_chan": {
        "description": "Free a previously allocated channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate descriptor ring for a channel",
        "pre": {
            "chan": "!=null",
            "ring_size": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate descriptor ring for a channel",
        "pre": {
            "chan": "!=null",
            "ring_size": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel",
        "pre": {
            "chan": "!=null",
            "cmdsta": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel",
        "pre": {
            "chan": "!=null",
            "cmdsta": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel",
        "pre": {
            "chan": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to use for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to use for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_buf": {
        "description": "Free a buffer used for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_buf": {
        "description": "Free a buffer used for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization",
        "pre": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization",
        "pre": {
            "return_value": ">= -1",
            "return_value": "<= 63"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event)",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event)",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine to use for cryptochecksum offload",
        "pre": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine to use for cryptochecksum offload.",
        "pre": {
            "return_value": ">= -8",
            "return_value": "<= 8"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine",
        "pre": {
            "fun": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine",
        "pre": {
            "fun": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library",
        "pre": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library",
        "pre": {
            "return_value": "==0"
        }
    }
},


{
    "kretprobe:mpc512x_cs_config": {
        "description": "Setup chip select configuration",
        "pre": {
            "cs": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mpc512x_cs_config": {
        "description": "Setup chip select configuration",
        "pre": {
            "cs": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "Check whether a transfer is in progress",
        "pre": {
            "lpbfifo.regs": "!=null",
            "lpbfifo.req": "true"
        }
    }
},
{
    "kprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "",
        "pre": {
            "lpbfifo.req": "!=null",
            "lpbfifo.wait_lpbfifo_irq": "true",
            "lpbfifo.wait_lpbfifo_callback": "true",
            "lpbfifo.req": "req",
            "ret": "!=0"
        }
    }
},
{
    "kretprobe:mpic_start_timer": {
        "description": "Start hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_start_timer": {
        "description": "Start hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_stop_timer": {
        "description": "Stop hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_stop_timer": {
        "description": "Stop hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:mpic_free_timer": {
        "description": "Free hardware timer",
        "pre": {
            "handle": "!=null",
            "context": "not in interrupt context"
        }
    }
},
{
    "kprobe:mpic_free_timer": {
        "description": "Free hardware timer",
        "pre": {
            "handle": "!=null",
            "context": "not in interrupt context"
        }
    }
},
{
    "kretprobe:mpic_request_timer": {
        "description": "Get a hardware timer.",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:mpic_request_timer": {
        "description": "Get a hardware timer.",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:gtm_put_timer16": {
        "description": "Release 16 bits GTM timer",
        "pre": {
            "tmr": "!=null"
        },
        "context": "any"
    }
},
{
    "kprobe:gtm_put_timer16": {
        "description": "Release 16 bits GTM timer",
        "pre": {
            "tmr": "!=null"
        },
        "context": "any"
    }
},
{
    "kretprobe:gtm_set_timer16": {
        "description": "(Re)set 16 bit timer with arbitrary precision.",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},
{
    "kprobe:gtm_set_timer16": {
        "description": "(re)set 16 bit timer with arbitrary precision",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},

{
    "kprobe:gtm_set_exact_timer16": {
        "description": "quite obviou frequency which is enough for µSec precision",
        "pre": {
            "tmr": "!=null",
            "usec": "!=null",
            "reload": "!=null"
        }
    }
},


{
    "kretprobe:gtm_ack_timer16": {
        "description": "Acknowledge timer event (free-run timers only)",
        "pre": {
            "tmr": "!=null",
            "events": "!=null"
        },
        "context": "any"
    }
},
{
    "kprobe:gtm_ack_timer16": {
        "description": "Acknowledge timer event (free-run timers only).",
        "pre": {
            "tmr": "!=null",
            "events": "!=null"
        }
    }
},


{
    "kretprobe:fsl_lbc_addr": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kprobe:fsl_lbc_addr": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null",
            "addr_base": "is a valid physical address",
            "addr_base": "is a base address of the memory bank",
            "addr_base": "is in the correct format for the BR register",
            "addr_base": "is a 32-bit physical address if the SOC has eLBC",
            "addr_base": "is a 34-bit local bus physical address if the SOC does not have eLBC"
        }
    }
},
{
    "kretprobe:fsl_lbc_find": {
        "description": "Find Localbus bank",
        "pre": {
            "addr_base": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:fsl_lbc_find": {
        "description": "Find Localbus bank",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        }
    }
},
{
    "kprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_run_pattern": {
        "description": "Actually run an UPM pattern",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "!=null"
        }
    }
},
{
    "kprobe:fsl_upm_run_pattern": {
        "description": "Actually run an UPM pattern",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "\"cpm\""
        }
    },
    "kretprobe:of_find_compatible_node": {
        "description": "Find a device tree node compatible with a given device.",
        "pre": {
            "compatible": "\"fsl,qe\""
        }
    },
    "kretprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "\"qe\""
        }
    }
},
{
    "kprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "!=null"
        }
    },
    "kprobe:of_find_compatible_node": {
        "description": "Find a device tree node by its compatible string.",
        "pre": {
            "type": "!=null",
            "compatible": "!=null"
        }
    },
    "kprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "!=null"
        }
    },
    "kprobe:of_property_read_u32": {
        "description": "Read a 32-bit unsigned integer property from a device tree node.",
        "pre": {
            "node": "!=null",
            "property": "\"clock-frequency\"",
            "value": "!=null"
        }
    },
    "kprobe:of_node_put": {
        "description": "Decrement the reference count of a device tree node.",
        "pre": {
            "node": "!=null"
        }
    }
},

{
    "kprobe:pci_io_base": {
        "description": "The base address from which IO bars are offsets.",
        "pre": {
            "pci_io_base": "!=null",
            "pci_io_base": ">=0",
            "pci_io_base": "<=65535"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "Returns the base address of the ISA bus or NULL if no ISA bus is present.",
        "pre": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "Check if ISA bus is available",
        "pre": {
            "isa_bus": "==null"
        }
    }
},


{
    "kretprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE",
        "pre": {
            "pdev": "!=null"
        }
    }
},

{
    "kprobe:struct_machdep_calls_ppc_md": {
        "description": "Main machine-dep calls structure",
        "pre": {
            "ppc_md": "!=null",
            "machine_id": "!=null",
            "boot_cpuid": "-1",
            "boot_cpu_hwid": "-1 (if CONFIG_PPC64 is defined)"
        }
    }
},
{
    "kretprobe:if (!np)np = of_find_node_by_name(NULL, \"8042\");if (np)": {
        "description": "Check if the variable np is null. If it is null, assign the result of of_find_node_by_name(NULL, \"8042\") to np.",
        "pre": {
            "np": "==null"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if np is NULL and find node by name",
        "pre": {
            "np": "==null",
            "of_find_node_by_name(NULL, \"8042\")": "!=null"
        }
    }
},
{
    "kretprobe:if ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))goto out_unlock;/* If everything fails then fallback to dynamic PHB numbering. `": {
        "description": "This function checks if the phb_id is greater than or equal to 0 and if the bit at phb_id in phb_bitmap is not set. If both conditions are true, it goes to the out_unlock label.",
        "pre": {
            "phb_id": ">= 0",
            "!test_and_set_bit(phb_id, phb_bitmap)": "true"
        }
    }
},
{
    "kprobe:if ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))goto out_unlock;/* If everything fails then fallback to dynamic PHB numbering. `": {
        "description": "Condition for the given function",
        "pre": {
            "phb_id": ">= 0",
            "!test_and_set_bit(phb_id, phb_bitmap)": "true"
        }
    }
},




{
    "kretprobe:btext_update_display": {
        "description": "Update the display with the given parameters.",
        "pre": {
            "phys": "!=null",
            "width": "!=null",
            "height": "!=null",
            "depth": "!=null",
            "pitch": "!=null",
            "dispDeviceBase": "!=null",
            "(phys ^ (unsigned long)dispDeviceBase) & 0xf0000000": "==0",
            "dispDeviceRect[0]": "==0",
            "dispDeviceRect[1]": "==0",
            "dispDeviceRect[2]": "==width",
            "dispDeviceRect[3]": "==height",
            "dispDeviceDepth": "==depth",
            "dispDeviceRowBytes": "==pitch",
            "boot_text_mapped": "==true"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the condition is met for the given function.",
        "pre": {
            "phys": "!=null",
            "dispDeviceBase": "!=null",
            "dispDeviceBase ^ (unsigned long)phys": "& 0xf0000000 == 0",
            "dispDeviceBase": "= (__u8 *) phys",
            "dispDeviceRect[0]": "= 0",
            "dispDeviceRect[1]": "= 0",
            "dispDeviceRect[2]": "= width",
            "dispDeviceRect[3]": "= height",
            "dispDeviceDepth": "= depth",
            "dispDeviceRowBytes": "= pitch",
            "boot_text_mapped": "= true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(tb_ticks_per_usec)": {
        "description": "Helper function to get the number of ticks per microsecond.",
        "pre": {
            "tb_ticks_per_usec": "==100"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(tb_ticks_per_usec)": {
        "description": "Helper function to get the number of ticks per microsecond.",
        "pre": {
            "tb_ticks_per_usec": "==100"
        }
    }
},


{
    "kretprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows with interrupts disabled.",
        "pre": {
            "interrupts_disabled": "true",
            "decrementer_overflow": "true"
        }
    }
},
{
    "kprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows with interrupts disabled.",
        "pre": {
            "interrupts_disabled": "true",
            "decrementer_overflow": "true"
        }
    }
},





{
    "kprobe:enable_kernel_vsx": {
        "description": "Enable kernel VSX.",
        "pre": {
            "cpumsr": "!=null",
            "current->thread.regs->msr": "MSR_VSX && MSR_VEC && MSR_FP"
        }
    }
},


{
    "kretprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:cpu_to_chip_id": {
        "description": "Return the cpus chip-id",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:cpu_to_chip_id": {
        "description": "Return the cpus chip-id",
        "pre": {
            "cpu": "!=null"
        }
    }
},

{
    "pci_device_from_OF_node": {
        "description": "Check if it might have a chance to be a PCI device",
        "pre": {
            "!pci_find_hose_for_OF_device(node)": true,
            "reg": "!=null",
            "size": ">= 5 * sizeof(u32)",
            "!reg || size < 5 * sizeof(u32)": "-ENODEV",
            "*bus": "(be32_to_cpup(&reg[0]) >> 16) & 0xff",
            "*devfn": "(be32_to_cpup(&reg[0]) >> 8) & 0xff",
            "#ifndef CONFIG_PPC_PCI_OF_BUS_MAP": 0,
            "#else": {
                "dev": "NULL",
                "pci_device_from_OF_node": "node, bu devfn"
            }
        }
    }
},

{
    "kprobe:__replay_soft_interrupts();irq_exit();}#if defined(CONFIG_PPC_BOOK3S_64) && defined(CONFIG_PPC_KUAP)static inline __no_kcsan void replay_soft_interrupts_irqrestore(void)": {
        "description": "Replay soft interrupts and restore IRQ state.",
        "pre": {
            "arg1": "!=null",
            "arg2": "!=null",
            "arg3": "!=null",
            "arg4": "!=null"
        }
    }
},
{
    "kretprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bu create a pci_dev",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bu create a pci_dev",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:in_xmon": {
        "description": "The value of in_xmon variable.",
        "pre": {
            "in_xmon": "==0"
        }
    },
    "kretprobe:xmon_on": {
        "description": "The value of xmon_on variable.",
        "pre": {
            "xmon_on": "IS_ENABLED(CONFIG_XMON_DEFAULT)"
        }
    },
    "kretprobe:xmon_is_ro": {
        "description": "The value of xmon_is_ro variable.",
        "pre": {
            "xmon_is_ro": "IS_ENABLED(CONFIG_XMON_DEFAULT_RO_MODE)"
        }
    },
    "kretprobe:adrs": {
        "description": "The value of adrs variable."
    },
    "kretprobe:size": {
        "description": "The value of size variable.",
        "pre": {
            "size": "==1"
        }
    },
    "kretprobe:ndump": {
        "description": "The value of ndump variable.",
        "pre": {
            "ndump": "==64"
        }
    },
    "kretprobe:nidump": {
        "description": "The value of nidump variable.",
        "pre": {
            "nidump": "==16"
        }
    },
    "kretprobe:ncsum": {
        "description": "The value of ncsum variable.",
        "pre": {
            "ncsum": "==4096"
        }
    },
    "kretprobe:termch": {
        "description": "The value of termch variable."
    },
    "kretprobe:tmpstr": {
        "description": "The value of tmpstr variable."
    },
    "kretprobe:tracing_enabled": {
        "description": "The value of tracing_enabled variable."
    },
    "kretprobe:bus_error_jmp": {
        "description": "The value of bus_error_jmp variable."
    },
    "kretprobe:catch_memory_errors": {
        "description": "The value of catch_memory_errors variable."
    },
    "kretprobe:catch_spr_faults": {
        "description": "The value of catch_spr_faults variable."
    },
    "kretprobe:xmon_fault_jmp": {
        "description": "The value of xmon_fault_jmp variable."
    }
},

{
    "kretprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Get page shift, work out hash and AVPN etc.",
        "pre": {
            "kvm": "!=null",
            "eaddr": "!=null",
            "slb_v": "& SLB_VSID_L != 0",
            "valid": "!=null",
            "mask": "SLB_VSID_B | HPTE_V_AVPN | HPTE_V_SECONDARY",
            "val": "0",
            "pshift": "12"
        }
    }
},
{
    "kprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Get page shift, work out hash and AVPN etc.",
        "pre": {
            "slb_v": "& SLB_VSID_L != 0",
            "mask": "SLB_VSID_B | HPTE_V_AVPN | HPTE_V_SECONDARY",
            "val": "0",
            "pshift": "12"
        }
    }
},





{
    "kprobe:if_unlikely_unsigned_long_addr_gt_FIXADDR_START": {
        "description": "Check if the address is greater than FIXADDR_START.",
        "pre": {
            "addr": ">FIXADDR_START"
        }
    }
},
{
    "kretprobe:default_power_off": {
        "description": "Power off the system when pm_power_off is not set by a power management driver.",
        "pre": {
            "pm_power_off": "==null"
        }
    }
},
{
    "kprobe:default_power_off": {
        "description": "Simulate power off on a simulator",
        "pre": {
            "pm_power_off": "not set",
            "instruction": "l.nop 1"
        }
    }
},





{
    "kprobe:sysctl_vfs_cache_pressure": {
        "description": "The sysctl_vfs_cache_pressure function",
        "pre": {
            "sysctl_vfs_cache_pressure": "==100"
        }
    },
    "kprobe:rename_lock": {
        "description": "The rename_lock function",
        "pre": {
            "rename_lock": "!=null"
        }
    },
    "kprobe:dentry_cache": {
        "description": "The dentry_cache function",
        "pre": {
            "dentry_cache": "!=null"
        }
    },
    "kprobe:empty_name": {
        "description": "The empty_name function",
        "pre": {
            "empty_name": "==\"\""
        }
    },
    "kprobe:slash_name": {
        "description": "The slash_name function",
        "pre": {
            "slash_name": "==\"/\""
        }
    },
    "kprobe:dotdot_name": {
        "description": "The dotdot_name function",
        "pre": {
            "dotdot_name": "==\"..\""
        }
    }
},
{
    "kretprobe:fast_dput": {
        "description": "Call dput() and return whether the operation was successful.",
        "pre": {
            "dentry": "!=null",
            "rcu_read_lock_held": "true"
        }
    }
},
{
    "kprobe:fast_dput": {
        "description": "Perform dput() and return whether it was successful.",
        "pre": {
            "dentry": "!=null",
            "rcu_read_lock_held": true
        }
    }
},


{
    "kretprobe:d_find_any_alias": {
        "description": "Find any alias for a given inode",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:d_find_any_alias": {
        "description": "find any alias for a given inode",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:d_find_alias": {
        "description": "Grab a hashed alias of an inode",
        "pre": {
            "inode": "!=null",
            "inode->i_mode": "!=null",
            "inode->i_mode": "S_ISDIR",
            "inode->i_dentry": "!=null",
            "alias": "!=null",
            "alias->d_lock": "!=null",
            "alias->d_u.d_alias": "!=null",
            "alias->d_lock": "spin_lock",
            "!d_unhashed(alias)": true,
            "__dget_dlock(alias)": true
        },
        "post": {
            "return": "alias"
        }
    }
},
{
    "kprobe:d_find_alias": {
        "description": "grab a hashed alias of inode",
        "pre": {
            "inode": "!=null",
            "alias": "!=null",
            "S_ISDIR(inode->i_mode)": "true",
            "__d_find_any_alias(inode)": "!=null"
        }
    }
},
{
    "kretprobe:shrink_dcache_sb": {
        "description": "Shrink dcache for a superblock",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_sb": {
        "description": "Shrink dcache for a superblock",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:d_set_mounted": {
        "description": "Set the 'mounted' flag for the given dentry.",
        "pre": {
            "dentry": "!=null",
            "rename_lock": "held",
            "d_lock": "held"
        }
    }
},
{
    "kprobe:d_set_mounted": {
        "description": "Set the 'mounted' flag for the given dentry.",
        "pre": {
            "dentry": "!=null",
            "rename_lock": "held",
            "d_lock": "held"
        }
    }
},
{
    "kretprobe:__d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:__d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:d_instantiate": {
        "description": "Fill in inode information for a dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "dentry->d_flags": "& DCACHE_LRU_LIST",
            "nr_dentry_negative": "this_cpu_dec",
            "dentry->d_u.d_alias": "hlist_add_head(&dentry->d_u.d_alia &inode->i_dentry)",
            "dentry->d_seq": "raw_write_seqcount_begin(&dentry->d_seq)",
            "__d_set_inode_and_type": "__d_set_inode_and_type(dentry, inode, add_flags)",
            "fsnotify_update_flags": "fsnotify_update_flags(dentry)",
            "dentry->d_lock": "spin_unlock(&dentry->d_lock)"
        }
    }
},
{
    "kprobe:d_instantiate": {
        "description": "Fill in inode information for a dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "add_flags": "unsigned",
            "d_flags_for_inode": "function",
            "d_in_lookup": "function",
            "spin_lock": "function",
            "Decrement negative dentry count if it was in the LRU list.": "comment"
        }
    }
},
{
    "d_instantiate_anon": {
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "false",
            "add_flags": "d_flags_for_inode(inode) | DCACHE_DISCONNECTED",
            "dentry->d_lock": "locked",
            "__d_set_inode_and_type": {
                "dentry": "!=null",
                "inode": "!=null",
                "add_flags": "!=null"
            },
            "hlist_add_head": {
                "dentry->d_u.d_alias": "!=null",
                "inode->i_dentry": "!=null"
            }
        }
    }
},
{
    "kprobe:d_instantiate_anon": {
        "description": "Attach a disconnected dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "bool"
        }
    }
},
{
    "kretprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode.",
        "pre": {
            "inode": "!=null",
            "disconnected": "bool"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode.",
        "pre": {
            "inode": "!=null",
            "disconnected": "boolean"
        }
    }
},

{
    "kprobe:__d_drop": {
        "description": "Drop a dentry from its hash table.",
        "pre": {
            "dentry": {
                "IS_ROOT": true
            },
            "b": "&dentry->d_sb->s_roots"
        }
    }
},
{
    "kretprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name",
        "pre": {
            "dentry": "!=null",
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name.",
        "pre": {
            "dentry": "<dentry_constraints>",
            "parent": "<parent_constraints>",
            "name": "<name_constraints>"
        }
    }
},
{
    "kretprobe:d_drop": {
        "description": "Invalidate a dentry for some reason.",
        "pre": {
            "dentry": "!=null",
            "dentry->d_lock": "acquired"
        }
    }
},
{
    "kprobe:d_drop": {
        "description": "Invalidate a dentry for some reason.",
        "pre": {
            "dentry": "!=null",
            "dentry->d_lock": "acquired",
            "dentry->d_hash.pprev": "!=NULL"
        }
    }
},
{
    "kretprobe:d_rehash": {
        "description": "Add an entry back to the hash.",
        "pre": {
            "entry": "!=null",
            "entry->d_name.hash": "!=null",
            "b": "!=null",
            "hlist_bl_lock(b)": "called",
            "hlist_bl_add_head_rcu(&entry->d_hash, b)": "called",
            "hlist_bl_unlock(b)": "called"
        }
    }
},
{
    "kprobe:d_rehash": {
        "description": "Add an entry back to the hash.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias.",
        "pre": {
            "entry": "!=null",
            "inode": "!=null",
            "entry->d_name.name": "!=null",
            "entry->d_parent": "!=null",
            "inode->i_ino": "!=null",
            "inode->i_sb": "!=null",
            "inode->i_sb->s_root": "!=null",
            "inode->i_sb->s_root->d_inode": "!=null",
            "inode->i_sb->s_root->d_inode->i_ino": "!=null"
        }
    }
},
{
    "kprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias.",
        "pre": {
            "entry": "!=null",
            "inode": "!=null",
            "entry->d_name.name": "!=null",
            "entry->d_parent": "!=null",
            "inode->i_ino": "!=null",
            "inode->i_sb": "!=null",
            "inode->i_sb->s_type": "==DT_UNKNOWN || ==DT_DIR || ==DT_REG",
            "inode->i_sb->s_op": "!=null",
            "inode->i_sb->s_op->lookup": "!=null",
            "inode->i_sb->s_op->lookup->dentry": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_name.name": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_name.name": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_ino": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_sb": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_sb->s_type": "==DT_UNKNOWN || ==DT_DIR || ==DT_REG"
        }
    }
},


{
    "kretprobe:is_subdir": {
        "description": "Check if new_dentry is a subdirectory of old_dentry.",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        }
    }
},
{
    "kprobe:is_subdir": {
        "description": "Check if new_dentry is a subdirectory of old_dentry.",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        }
    }
},


{
    "kretprobe:simple_setattr": {
        "description": "setattr for simple filesystem",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:simple_setattr": {
        "description": "setattr for simple filesystem",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        }
    }
},
{
    "kretprobe:simple_fill_super": {
        "description": "Function to fill the super block with the given parameters.",
        "pre": {
            "s": "!=null",
            "magic": "!=null",
            "files": "!=null",
            "s->s_blocksize": "==PAGE_SIZE",
            "s->s_blocksize_bits": "==PAGE_SHIFT",
            "s->s_magic": "==magic",
            "s->s_op": "==&simple_super_operations",
            "s->s_time_gran": "==1",
            "inode": "!=null",
            "root": "!=null",
            "dentry": "!=null",
            "i": ">=0",
            "files[i].name": "!=null",
            "files[i].name[0]": "!=null",
            "inode->i_ino": "==1",
            "inode->i_mode": "==S_IFDIR | 0755",
            "inode->i_atime": "==current_time(inode)",
            "inode->i_mtime": "==current_time(inode)",
            "inode->i_ctime": "==current_time(inode)",
            "inode->i_op": "==&simple_dir_inode_operations",
            "inode->i_fop": "==&simple_dir_operations",
            "set_nlink(inode, 2)": "true",
            "root": "==d_make_root(inode)",
            "!root": "==null"
        }
    }
},
{
    "kprobe:simple_fill_super": {
        "description": "Function to fill the super block with the given parameters.",
        "pre": {
            "s": {
                "s_blocksize": 4096,
                "s_blocksize_bits": 12,
                "s_magic": 1234567890,
                "s_op": "!=null",
                "s_time_gran": 1
            },
            "magic": 1234567890,
            "files": {
                "name": [
                    "!=null",
                    "!=1"
                ]
            },
            "inode": {
                "i_ino": 1,
                "i_mode": "S_IFDIR | 0755",
                "i_atime": "current_time(inode)",
                "i_mtime": "current_time(inode)",
                "i_ctime": "current_time(inode)",
                "i_op": "&simple_dir_inode_operations",
                "i_fop": "&simple_dir_operations"
            },
            "root": "!=null"
        }
    }
},
{
    "kretprobe:simple_read_from_buffer": {
        "description": "Copy data from the buffer to user space",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kprobe:simple_read_from_buffer": {
        "description": "Copy data from the buffer to user space",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kretprobe:simple_write_to_buffer": {
        "description": "Copy data from user space to the buffer",
        "pre": {
            "to": "!=null",
            "available": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:simple_write_to_buffer": {
        "description": "Copy data from user space to the buffer",
        "pre": {
            "to": "!=null",
            "available": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memory_read_from_buffer": {
        "description": "Copy data from the buffer",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kprobe:memory_read_from_buffer": {
        "description": "Copy data from the buffer",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kretprobe:simple_transaction_set": {
        "description": "Set the size of the simple transaction argument response structure.",
        "pre": {
            "file": "!=null",
            "n": ">=0",
            "ar": "!=null",
            "ar->size": "==0",
            "ar->data": "not ready for reading"
        }
    }
},
{
    "kprobe:smp_mb();ar->size = n;}EXPORT_SYMBOL(simple_transaction_set": {
        "description": "Set the value of `ar->size` to `n` in the `simple_transaction_set` function.",
        "pre": {
            "file": "!=null",
            "n": ">=0",
            "ar": "!=null",
            "ar->data": "ready for reading",
            "ar->size": "0"
        }
    }
},
{
    "kretprobe:if (file->private_data)": {
        "description": "Check if the private_data field of the file structure is not null.",
        "pre": {
            "file": {
                "private_data": "!=null"
            }
        }
    }
},
{
    "kprobe:if (file->private_data)": {
        "description": "Check if the private_data field of the file structure is not null.",
        "pre": {
            "file": {
                "private_data": "!=null"
            }
        }
    }
},
{
    "kretprobe:__generic_file_fsync": {
        "description": "Generic fsync implementation for simple filesystems",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:__generic_file_fsync": {
        "description": "Generic fsync implementation for simple filesystems.",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:generic_check_addressable": {
        "description": "Check addressability of file system",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        }
    }
},
{
    "kprobe:generic_check_addressable": {
        "description": "Check addressability of file system",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        }
    }
},
{
    "kretprobe:pseudo_fs_get_tree": {
        "description": "Get the tree for the pseudo filesystem.",
        "pre": {
            "root->i_ino": "== 1",
            "root->i_mode": "& (S_IFDIR | S_IRUSR | S_IWUSR)",
            "root->i_atime": "== root->i_mtime",
            "root->i_atime": "== root->i_ctime",
            "s->s_root": "!= null",
            "ctx->dops": "!= null"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:pseudo_fs_get_tree": {
        "description": "Get the tree for the pseudo filesystem.",
        "pre": {
            "root->i_ino": "== 1",
            "root->i_mode": "& (S_IFDIR | S_IRUSR | S_IWUSR)",
            "root->i_atime": "== root->i_mtime",
            "root->i_atime": "== root->i_ctime",
            "s->s_root": "!= null",
            "ctx->dops": "!= null"
        }
    }
},
{
    "kretprobe:alloc_anon_inode": {
        "description": "Allocate an anonymous inode",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "inode->i_state": "I_DIRTY",
            "inode->i_mode": "S_IRUSR | S_IWUSR",
            "inode->i_uid": "current_fsuid()",
            "inode->i_gid": "current_fsgid()",
            "inode->i_flags": "inode->i_flags | S_PRIVATE",
            "inode->i_atime": "current_time(inode)",
            "inode->i_mtime": "current_time(inode)",
            "inode->i_ctime": "current_time(inode)",
            "return": "inode"
        }
    }
},
{
    "kprobe:alloc_anon_inode": {
        "description": "Allocate an anonymous inode in the given super block.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:intsimple_nosetlease": {
        "description": "Generic helper for prohibiting leases",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:intsimple_nosetlease": {
        "description": "Generic helper for prohibiting leases",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:simple_get_link": {
        "description": "Generic helper to get the target of 'fast' symlinks",
        "pre": {
            "dentry": "==null",
            "inode": "!=null",
            "done": "==null"
        }
    }
},
{
    "kprobe:simple_get_link": {
        "description": "Generic helper to get the target of 'fast' symlinks",
        "pre": {
            "dentry": "==null",
            "inode": "!=null",
            "done": "==null"
        }
    }
},
{
    "kretprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:inode_maybe_inc_iversion": {
        "description": "Increments i_version of the given inode if necessary.",
        "pre": {
            "inode": "!=null",
            "force": "in [true, false]"
        }
    }
},
{
    "kprobe:inode_maybe_inc_iversion": {
        "description": "Increments i_version of the given inode.",
        "pre": {
            "inode": "!=null",
            "force": "in [true, false]"
        }
    }
},
{
    "kretprobe:smp_mb();cur = inode_peek_iversion_raw(inode);do": {
        "description": "Query the inode's i_version field",
        "pre": {
            "smp_mb": "called",
            "cur": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:smp_mb();cur = inode_peek_iversion_raw(inode);do": {
        "description": "Perform a memory barrier, then assign the current value of the inode's i_version field to the variable 'cur' using the helper function 'inode_peek_iversion_raw'.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "any"
        }
    }
},
{
    "kprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "any"
        }
    }
},


{
    "kretprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "unsigned int",
            "_path": "!=null"
        }
    }
},
{
    "kprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "!=null",
            "_path": "!=null"
        }
    }
},
{
    "kretprobe:return handler->set": {
        "description": "Set extended attribute value for a file.",
        "pre": {
            "handler": "!=null",
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null",
            "size": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:return handler->set": {
        "description": "Set the value of the entry using the provided handler.",
        "pre": {
            "handler": "!=null",
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null",
            "size": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:generic_listxattr": {
        "description": "Run through a dentry's xattr list() operations",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buffer_size": "!=null"
        }
    }
},
{
    "kprobe:ssize_tgeneric_listxattr": {
        "description": "Run through a dentry's xattr list() operations.",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buffer_size": "!=null"
        }
    }
},
{
    "kretprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},


{
    "kretprobe:vfs_setpos": {
        "description": "Update the file offset for lseek",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "maxsize": "!=null"
        }
    }
},
{
    "kprobe:vfs_setpos": {
        "description": "Update the file offset for lseek",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "maxsize": "!=null"
        }
    }
},
{
    "kretprobe:loff_tgeneric_file_llseek_size": {
        "description": "Generic llseek implementation for regular files",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        }
    }
},
{
    "kprobe:loff_tgeneric_file_llseek_size": {
        "description": "Generic llseek implementation for regular files.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        }
    }
},
{
    "kretprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null"
        }
    }
},
{
    "kprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null"
        }
    }
},
{
    "kretprobe:if (offset >= inode->i_size)": {
        "description": "Check if the offset is greater than or equal to the size of the inode.",
        "pre": {
            "offset": ">= inode->i_size"
        }
    }
},
{
    "kprobe:default_llseek": {
        "description": "Check if offset is greater than or equal to inode->i_size",
        "pre": {
            "file": "is_instance_of(struct file)",
            "offset": "is_instance_of(loff_t)",
            "whence": "is_instance_of(int)",
            "inode": "is_instance_of(struct inode)",
            "inode->i_size": ">= offset"
        }
    }
},
{
    "kretprobe:return -EOVERFLOW;} else if (unlikely((loff_t) (pos + count) < 0)": {
        "description": "This condition checks if the return value is -EOVERFLOW and if the sum of pos and count is less than 0.",
        "pre": {
            "pos": "!=null",
            "count": "!=null",
            "return_value": "-EOVERFLOW",
            "pos + count": "< 0"
        }
    }
},
{
    "kprobe:return -EOVERFLOW;} else if (unlikely((loff_t) (pos + count) < 0)": {
        "description": "Check for overflow in the addition of pos and count.",
        "pre": {
            "read_write": "in [0, 1]",
            "file": "!=null",
            "ppos": ">=0",
            "count": ">=0",
            "pos": ">=0",
            "unsigned_offsets(file)": "==true",
            "count >= -pos": "==true",
            "pos + count": "<0"
        }
    }
},
{
    "kretprobe:kernel_read": {
        "description": "Read data from a file.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "pos": ">=0",
            "file->f_op->read_iter": "!=null",
            "file->f_op->read": "!=null"
        }
    }
},
{
    "kprobe:kernel_read": {
        "description": "Read data from a file in the kernel.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "count": "!=null",
            "pos": "!=null",
            "file->f_op->read_iter": "!=null",
            "file->f_op->read": "!=null"
        }
    }
},
{
    "kretprobe:kernel_write_iter": {
        "description": "Kernel write iterator function",
        "pre": {
            "file": "!=null",
            "from": "!=null",
            "pos": "!=null",
            "file->f_op->write_iter": "!=null",
            "file->f_op->write": "!=null",
            "!file->f_op->write_iter || file->f_op->write": "true",
            "init_sync_kiocb(&kiocb, file)": "no condition specified",
            "kiocb.ki_pos": "pos ? *pos : 0",
            "ret": "no condition specified",
            "ret > 0": "true"
        }
    }
},
{
    "kprobe:kernel_write_iter": {
        "description": "Kernel function for writing data to a file.",
        "pre": {
            "file": "!=null",
            "from": "!=null",
            "pos": "!=null",
            "file->f_op->write_iter": "!=null",
            "file->f_op->write": "!=null"
        }
    }
},
{
    "kretprobe:generic_copy_file_range": {
        "description": "Copy data between two files",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:generic_copy_file_range": {
        "description": "Copy data between two files",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": "unsigned int",
            "return": "ssize_t"
        }
    }
},
{
    "kretprobe:if (!splice && file_out->f_op->copy_file_range)": {
        "description": "Check conditions for the given function",
        "pre": {
            "splice": false,
            "file_out->f_op": {
                "copy_file_range": true
            }
        }
    }
},
{
    "kprobe:if (!splice && file_out->f_op->copy_file_range)": {
        "description": "Condition for the if statement: if (!splice && file_out->f_op->copy_file_range)",
        "pre": {
            "splice": false,
            "file_out->f_op->copy_file_range": "!=null"
        }
    }
},
{
    "kretprobe:generic_write_checks_count": {
        "description": "Performs generic write checks for a given count.",
        "pre": {
            "iocb": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:generic_write_checks_count": {
        "description": "Performs generic write checks for the given iocb and count.",
        "pre": {
            "iocb": "!=null",
            "count": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kretprobe:sync_mapping_buffers": {
        "description": "Write out and wait upon a mapping's associated buffers",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:sync_mapping_buffers": {
        "description": "Write out and wait upon a mapping's associated buffers.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:generic_buffers_fsync_noflush": {
        "description": "Generic buffer fsync implementation for simple filesystems with no inode lock.",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [true, false]"
        }
    }
},
{
    "kprobe:generic_buffers_fsync_noflush": {
        "description": "generic buffer fsync implementation for simple filesystems with no inode lock",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [true, false]"
        }
    }
},
{
    "kretprobe:mark_buffer_dirty_inode": {
        "description": "Mark the buffer dirty for the inode.",
        "pre": {
            "address_space": "!=null",
            "address_space.private_lock": "held",
            "inode": "!=null",
            "inode.on_list": "not in [true, false]"
        }
    }
},
{
    "kprobe:/* * The buffer's backing address_space's private_lock must be held */": {
        "description": "The buffer's backing address_space's private_lock must be held.",
        "pre": {
            "address_space": "!=null",
            "private_lock": "held"
        }
    }
},
{
    "kretprobe:folio_memcg_lock": {
        "description": "Locks the memcg migration of a page and synchronizes PageDirty with per-memcg dirty page counters.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        },
        "post": {
            "newly_dirty": "==true",
            "mapping->host": "!=null",
            "mapping->host->i_state": "& I_DIRTY_PAGES"
        }
    }
},
{
    "kprobe:folio_memcg_lock": {
        "description": "Locks the memcg of a folio and marks it as dirty if necessary.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__bread_gfp": {
        "description": "Reads a specified block and returns the buffer head that contains it.",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__bread_gfp": {
        "description": "Reads a specified block and returns the buffer head that contains it.",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:set_bh_page": {
        "description": "Set the page associated with the buffer head and calculate the data pointer.",
        "pre": {
            "bh": "!=null",
            "page": "!=null",
            "offset": "!=null",
            "offset": "< PAGE_SIZE",
            "PageHighMem(page)": "== false"
        },
        "post": {
            "bh->b_data": "((char *)(0 + offset)) || (page_address(page) + offset)"
        }
    }
},
{
    "kprobe:bh->b_data": {
        "description": "Set the value of bh->b_data based on the offset and page.",
        "pre": {
            "bh": {
                "b_page": "!=null",
                "b_data": "!=null"
            },
            "page": "!=null",
            "offset": "!=null"
        }
    }
},


{
    "kretprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio.",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio.",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__block_write_full_folio": {
        "description": "Write a full folio to disk.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "get_block": "!=null",
            "wbc": "!=null",
            "handler": "!=null",
            "block": "sector_t",
            "last_block": "sector_t",
            "bh": "struct buffer_head",
            "head": "struct buffer_head",
            "blocksize": "unsigned int",
            "bbits": "unsigned int",
            "nr_underway": "int",
            "write_flags": "blk_opf_t"
        }
    }
},
{
    "kprobe:__block_write_full_folio": {
        "description": "Write a full folio to disk.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "get_block": "!=null",
            "wbc": "!=null",
            "handler": "!=null",
            "block": "sector_t",
            "last_block": "sector_t",
            "bh": "struct buffer_head",
            "head": "struct buffer_head",
            "blocksize": "unsigned int",
            "bbits": "unsigned int",
            "nr_underway": "int",
            "write_flags": "blk_opf_t"
        }
    }
},


{
    "kretprobe:folio_test_uptodate": {
        "description": "Check if the folio is up-to-date.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_zero_new_buffers": {
        "description": "Zero out new buffers in the folio.",
        "pre": {
            "folio": "!=null",
            "start+copied": ">=0",
            "start+len": ">=0"
        }
    },
    "kretprobe:flush_dcache_folio": {
        "description": "Flush the data cache for the folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_uptodate": {
        "description": "Check if the folio is up-to-date.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_zero_new_buffers": {
        "description": "Zero out new buffers in the folio.",
        "pre": {
            "folio": "!=null",
            "start+copied": ">=0",
            "start+len": ">=0"
        }
    },
    "kprobe:flush_dcache_folio": {
        "description": "Flush the data cache for the folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:if (pos + copied > inode->i_size)": {
        "description": "Check if the sum of 'pos' and 'copied' is greater than 'inode->i_size'.",
        "pre": {
            "pos": "!=null",
            "copied": "!=null",
            "inode": "!=null",
            "inode->i_size": "!=null",
            "pos + copied": "> inode->i_size"
        }
    }
},
{
    "kprobe:if (pos + copied > inode->i_size)": {
        "description": "Check if the sum of pos and copied is greater than the size of the inode.",
        "pre": {
            "pos": "!=null",
            "copied": "!=null",
            "inode": "!=null",
            "inode->i_size": "> pos + copied"
        }
    }
},
{
    "kretprobe:block_is_partially_uptodate": {
        "description": "Checks whether buffers within a folio are uptodate or not.",
        "pre": {
            "folio": "!=null",
            "from": ">=0",
            "count": ">0"
        }
    }
},
{
    "kprobe:block_is_partially_uptodate": {
        "description": "Checks whether buffers within a folio are uptodate or not. Returns true if all buffers which correspond to the specified part of the folio are uptodate.",
        "pre": {
            "folio": "!=null",
            "from": ">= 0",
            "count": ">= 0"
        }
    }
},


{
    "kretprobe:block_commit_write": {
        "description": "Handles the basic task of block allocation and bringing partial write blocks uptodate.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "from": ">=0",
            "to": ">=0",
            "partial": "false",
            "blocksize": ">=0",
            "bh": "!=null",
            "head": "!=null",
            "block_start": ">=0",
            "block_end": ">=0",
            "buffer_uptodate(bh)": "true if block_end <= from or block_start >= to, false otherwise",
            "set_buffer_uptodate(bh)": "called if block_end > from and block_start < to",
            "mark_buffer_dirty(bh)": "called if block_end > from and block_start < to",
            "buffer_new(bh)": "false if buffer is not new, true otherwise",
            "clear_buffer_new(bh)": "called if buffer is new",
            "bh->b_this_page": "!=null",
            "buffer_uptodate(bh->b_this_page)": "true if block_end <= from or block_start >= to, false otherwise"
        }
    }
},
{
    "kprobe:block_commit_write": {
        "description": "The block_commit_write function handles the basic task of block allocation and bringing partial write blocks up to date.",
        "pre": {
            "inode": "any",
            "folio": "any",
            "from": "any",
            "to": "any"
        }
    }
},

{
    "kprobe:block_page_mkwrite": {
        "description": "block_page_mkwrite() is not allowed to change the file size as it gets called from a page fault handler when a page is first dirtied. Hence we must be careful to check for EOF conditions here. We set the page up correctly for a written page which means we get ENOSPC checking when writing into holes and correct delalloc and unwritten extent mapping on filesystems that support these features. We are not allowed to take the i_mutex here so we have to play games to protect against truncate races as the page could now be beyond EOF. Because truncate writes the inode size before removing page once we have the page lock we can determine safely if the page is beyond EOF. If it is not beyond EOF, then the page is guaranteed safe against truncation until we unlock the page. Direct callers of this function should protect against filesystem freezing using sb_start_pagefault() - sb_end_pagefault() functions.",
        "pre": {
            "vma": "!=null",
            "vmf": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check if length is zero. If true, return 0. Otherwise, perform the following operations.",
        "pre": {
            "length": "==0",
            "blocksize": "!=null",
            "index": "!=null",
            "mapping": "!=null",
            "inode": "!=null",
            "folio": "!=null",
            "bh": "!=null"
        }
    }
},
{
    "kprobe:if (!length)return 0;length = blocksize - length;iblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);folio = filemap_grab_folio(mapping, index);if (IS_ERR(folio))return PTR_ERR(folio);bh = folio_buffers(folio);if (!bh)": {
        "description": "Condition for the given function",
        "pre": {
            "length": "==0",
            "blocksize": "!=null",
            "index": "!=null",
            "inode->i_blkbits": "!=null",
            "mapping": "!=null",
            "folio": "!=null",
            "bh": "!=null"
        }
    }
},
{
    "kretprobe:end_buffer_async_write": {
        "description": "Performs asynchronous write of buffer head and updates uptodate flag.",
        "pre": {
            "bh": "!=null",
            "uptodate": "==1"
        }
    }
},
{
    "kprobe:end_buffer_async_write": {
        "description": "Pages which are unlocked during IO and have PageWriteback cleared upon IO completion.",
        "pre": {
            "bh": "!=null",
            "uptodate": "is an integer"
        }
    }
},
{
    "kretprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers. If all the buffers are unlocked and clean, then the folio_test_dirty information is stale. If any of the buffers are locked, it is assumed they are locked for IO.",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        }
    }
},
{
    "kprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers.",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        }
    }
},


{
    "kretprobe:buffer_mapped": {
        "description": "Check if the buffer head is mapped.",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kprobe:buffer_mapped": {
        "description": "Check if the buffer head is mapped.",
        "pre": {
            "bh": "!=null"
        }
    }
},



{
    "kprobe:folio_init_buffers": {
        "description": "Initialise the state of a blockdev folio's buffers.",
        "pre": {
            "folio": "!=null",
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kretprobe:__bh_read": {
        "description": "Submit read for a locked buffer",
        "pre": {
            "bh": "!=null",
            "op_flags": "in [REQ_OP_...]",
            "wait": "bool"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kprobe:__bh_read": {
        "description": "Submit read for a locked buffer",
        "pre": {
            "bh": "!=null",
            "op_flags": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:__bh_read_batch": {
        "description": "Submit read for a batch of unlocked buffers",
        "pre": {
            "nr": "!=null",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE]",
            "force_lock": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kprobe:__bh_read_batch": {
        "description": "Submit read for a batch of unlocked buffers",
        "pre": {
            "nr": "!=null",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROE REQ_OP_ZONE_APPEND, REQ_OP_ZONE_RESET_ALL, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_RESET_WRITE_PTR, REQ_OP_ZONE_RESET_ZONE_PTR, REQ_OP_ZONE_APPEND_WRITE_PTR, REQ_OP_ZONE_APPEND_ZONE_PTR, REQ_OP_ZONE_RESET_ALL_WRITE_PTR, REQ_OP_ZONE_RESET_ALL_ZONE_PTR, REQ_OP_ZONE_FINISH_WRITE_PTR, REQ_OP_ZONE_FINISH_ZONE_PTR, REQ_OP_WRITE_SAME_WRITE_PTR, REQ_OP_WRITE_SAME_ZONE_PTR, REQ_OP_WRITE_ZEROES_WRITE_PTR, REQ_OP_WRITE_ZEROES_ZONE_PTR, REQ_OP_ZONE_APPEND_WRITE_PTR, REQ_OP_ZONE_APPEND_ZONE_PTR, REQ_OP_ZONE_RESET_ALL_WRITE_PTR, REQ_OP_ZONE_RESET_ALL_ZONE_PTR, REQ_OP_ZONE_FINISH_WRITE_PTR, REQ_OP_ZONE_FINISH_ZONE_PTR, REQ_OP_WRITE_SAME_WRITE_PTR, REQ_OP_WRITE_SAME_ZONE_PTR, REQ_OP_WRITE_ZEROES_WRITE_PTR, REQ_OP_WRITE_ZEROES_ZONE_PTR]",
            "force_lock": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kretprobe:pipe_lock_nested": {
        "description": "Locks the mutex associated with the pipe if pipe->files is not null.",
        "pre": {
            "pipe": "!=null",
            "subclass": "any",
            "pipe->files": "!=null",
            "pipe->mutex": "locked"
        }
    }
},
{
    "kprobe:pipe_lock_nested": {
        "description": "Nests non-pipe inode locks (for writing to a file)",
        "pre": {
            "pipe": "!=null",
            "subclass": "int"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_try_steal": {
        "description": "Attempt to take ownership of a pipe buffer",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_try_steal": {
        "description": "Attempt to take ownership of a pipe buffer.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_get": {
        "description": "get a reference to a &struct pipe_buffer",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_get": {
        "description": "Get a reference to a struct pipe_buffer.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},


{
    "kretprobe:vfs_fsync_range": {
        "description": "Helper to sync a range of data & metadata to disk",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:vfs_fsync_range": {
        "description": "Helper to sync a range of data & metadata to disk",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:smp_mb": {
        "description": "__mark_inode_dirty(). This allows __mark_inode_dirty() to test i_state without grabbing i_lock - either they see the I_DIRTY bits cleared or we see the dirtied inode. I_DIRTY_PAGES is always cleared together above even if @mapping still has dirty pages. The flag is reinstated after smp_mb() if necessary. This guarantees that either __mark_inode_dirty() sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.",
        "pre": {
            "mapping": "!=null",
            "inode": "!=null",
            "inode->i_state": "& I_DIRTY_PAGES == 0 || mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)"
        }
    }
},
{
    "kprobe:smp_mb": {
        "description": "Memory barrier function.",
        "pre": {
            "mapping_tagged": {
                "mapping": "!=null",
                "tag": "PAGECACHE_TAG_DIRTY"
            },
            "inode_i_state_set": {
                "inode": "!=null",
                "state": "|= I_DIRTY_PAGES"
            },
            "inode_i_state_check": {
                "inode": "!=null",
                "state": "& I_PINNING_FSCACHE_WB"
            }
        }
    }
},
{
    "kretprobe:writeback_inodes_sb_nr": {
        "description": "Writeback dirty inodes from the given super_block.",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_FS_FREE_SPACE, WB_REASON_FS_INODE, WB_REASON_FS_SINGLE]"
        }
    }
},
{
    "kprobe:writeback_inodes_sb_nr": {
        "description": "Write back dirty inodes from a given super_block.",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_FS_FREE_SPACE, WB_REASON_SYNC, WB_REASON_PERIODIC]"
        }
    }
},
{
    "kretprobe:try_to_writeback_inodes_sb": {
        "description": "Try to start writeback if none underway",
        "pre": {
            "sb": "!=null",
            "reason": "!=null"
        }
    }
},
{
    "kprobe:try_to_writeback_inodes_sb": {
        "description": "Try to start writeback if none underway.",
        "pre": {
            "sb": "!=null",
            "reason": "!=null"
        }
    }
},


{
    "kretprobe:write_inode_now": {
        "description": "Write an inode to disk",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kprobe:write_inode_now": {
        "description": "Write an inode to disk",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion.",
        "pre": {
            "inode": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion.",
        "pre": {
            "inode": "!=null",
            "wait": "!=null"
        }
    }
},


{
    "kretprobe:get_file_rcu": {
        "description": "Check if the file pointer obtained from get_file_rcu is valid.",
        "pre": {
            "file": "==null"
        }
    },
    "kretprobe:continue": {
        "description": "Continue execution if the file table entry has changed.",
        "pre": {}
    }
},
{
    "kprobe:if (unlikely(!get_file_rcu(file)))continue;/* *  (b) the file table entry has changed under us. *       Note that we don't need to re-check the 'fdt->fd' *       pointer having changed, because it always goes *       hand-in-hand with 'fdt'. * * If so, we need to put our ref and try again. */": {
        "description": "Check if the file table entry has changed and handle the race condition.",
        "pre": {
            "file": "!=null",
            "fd": "< fdt->max_fds",
            "fdt->fd + array_index_nospec(fd, fdt->max_fds)": "!=null",
            "file->f_mode & mask": "==0"
        }
    }
},


{
    "kretprobe:vfs_parse_fs_param_source": {
        "description": "Handle setting \"source\" via parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null"
        },
        "post": {
            "return": "in [0, -ENOPARAM, -EINVAL]"
        }
    }
},
{
    "kprobe:vfs_parse_fs_param_source": {
        "description": "Handle setting \"source\" via parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null"
        }
    }
},
{
    "kretprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">=0"
        }
    }
},
{
    "kprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">=0"
        }
    }
},
{
    "kretprobe:generic_parse_monolithic": {
        "description": "Parse key[=val][,key[=val]] mount data.",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:generic_parse_monolithic": {
        "description": "Parse key[=val][,key[=val]] mount data.",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicates the file system context.",
        "pre": {
            "src_fc": "!=null",
            "src_fc->ops->dup": "!=null",
            "ret": ">= -EOPNOTSUPP",
            "fc": "!=null",
            "fc->uapi_mutex": "initialized",
            "fc->fs_private": "== NULL",
            "fc->s_fs_info": "== NULL",
            "fc->source": "== NULL",
            "fc->security": "== NULL",
            "fc->fs_type": "!=null",
            "fc->net_ns": "!=null",
            "fc->user_ns": "!=null",
            "fc->cred": "!=null",
            "fc->log.log": "!=null",
            "fc->log.log->usage": "incremented"
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicate the file system context.",
        "pre": {
            "src_fc": "!=null",
            "src_fc->ops->dup": "!=null",
            "ret": "int",
            "fc": "!=null",
            "!fc->ops->dup": "false",
            "fc = kmemdup(src_fc, sizeof(struct fs_context), GFP_KERNEL)": "fc != null",
            "mutex_init(&fc->uapi_mutex)": "true",
            "fc->fs_private": "null",
            "fc->s_fs_info": "null",
            "fc->source": "null",
            "fc->security": "null",
            "get_filesystem(fc->fs_type)": "true",
            "get_net(fc->net_ns)": "true",
            "get_user_ns(fc->user_ns)": "true",
            "get_cred(fc->cred)": "true",
            "fc->log.log": "null",
            "ret < 0": "false"
        }
    }
},
{
    "kretprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "in ['DEBUG', 'INFO', 'WARNING', 'ERROR']",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "in ['DEBUG', 'INFO', 'WARNING', 'ERROR']",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "pre": {
            "src_fc": "!=null"
        }
    }
},
{
    "kretprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kretprobe:generic_fill_statx_attr": {
        "description": "Fill in the statx attributes from the inode flags",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fill_statx_attr": {
        "description": "Fill in the statx attributes from the inode flags",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kretprobe:vfs_getattr_nosec": {
        "description": "getattr without security checks",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "is an integer",
            "query_flags": "is an integer"
        }
    }
},
{
    "kprobe:vfs_getattr_nosec": {
        "description": "getattr without security checks",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "is an integer",
            "query_flags": "is an integer"
        }
    }
},

{
    "kprobe:inode_set_bytes": {
        "description": "Set the number of bytes and blocks for an inode.",
        "pre": {
            "inode": "!=null",
            "bytes": ">=0",
            "inode->i_lock": "locked"
        }
    }
},


{
    "kretprobe:inode_init_always": {
        "description": "Perform inode structure initialization",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_init_always": {
        "description": "Perform inode structure initialization",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:drop_nlink": {
        "description": "Directly drop an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:drop_nlink": {
        "description": "Directly drop an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:clear_nlink": {
        "description": "Directly zero an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:clear_nlink": {
        "description": "Directly zero an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:set_nlink": {
        "description": "Directly set an inode's link count",
        "pre": {
            "inode": "!=null",
            "nlink": "!=null",
            "nlink": ">0"
        }
    }
},
{
    "kprobe:set_nlink": {
        "description": "Directly set an inode's link count",
        "pre": {
            "inode": "!=null",
            "nlink": "!=null",
            "nlink": ">0"
        }
    }
},
{
    "kretprobe:inc_nlink": {
        "description": "Directly increment an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inc_nlink": {
        "description": "Directly increment an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:__insert_inode_hash": {
        "description": "Hash an inode and add it to the inode hash for this superblock.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null"
        }
    }
},
{
    "kprobe:__insert_inode_hash": {
        "description": "Hash an inode and add it to the inode hash for this superblock.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null"
        }
    }
},
{
    "kretprobe:__remove_inode_hash": {
        "description": "Remove an inode from the hash",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:__remove_inode_hash": {
        "description": "Remove an inode from the hash",
        "pre": {
            "inode": "!=null"
        }
    }
},


{
    "kretprobe:get_next_ino": {
        "description": "Function to get the next inode number",
        "pre": {
            "p": "!=null",
            "res": "!=null",
            "res & (LAST_INO_BATCH-1)": "!=0",
            "next": "!=null",
            "next - LAST_INO_BATCH": "!=0",
            "res + 1": "!=0"
        }
    }
},
{
    "kprobe:get_next_ino": {
        "description": "Function to get the next inode number",
        "pre": {
            "p": "!=null",
            "res": "isUnsignedInt",
            "res & (LAST_INO_BATCH-1)": "!=0",
            "shared_last_ino": "isAtomicInt",
            "next": "isInt",
            "next - LAST_INO_BATCH": "isInt",
            "get_next_ino": "!=0"
        }
    }
},
{
    "kretprobe:new_inode_pseudo": {
        "description": "Obtain an inode for the given superblock.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:new_inode_pseudo": {
        "description": "Obtain an inode for the given superblock.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:lockdep_annotate_inode_mutex_key": {
        "description": "Annotate the mutex key of an inode if it is a directory.",
        "pre": {
            "inode": "!=null",
            "S_ISDIR(inode->i_mode)": "true",
            "type": "!=null"
        }
    }
},
{
    "kprobe:lockdep_match_class": {
        "description": "Check if the lock class of inode's i_rwsem matches the lock class of type's i_mutex_key.",
        "pre": {
            "inode": "!=null",
            "type": "!=null",
            "inode->i_rwsem": "!=null",
            "type->i_mutex_key": "!=null"
        }
    }
},
{
    "kretprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters for the new inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters for the new inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null",
            "inode1_is_directory": "==false",
            "inode2_is_directory": "==false"
        }
    }
},
{
    "kprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects.",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null",
            "inode1_is_directory": "==false",
            "inode2_is_directory": "==false"
        }
    }
},
{
    "kretprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kretprobe:inode_insert5": {
        "description": "Insert a pre-allocated inode into cache and return it locked, hashed, and with the I_NEW flag set.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "set": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:inode_insert5": {
        "description": "Insert a pre-allocated inode into the cache and return it locked, hashed, and with the I_NEW flag set.",
        "pre": {
            "inode": "!=null",
            "hashval": ">=0",
            "test": "!=null",
            "set": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_fast": {
        "description": "Find an inode quickly in a given super block using the inode number.",
        "pre": {
            "sb": "!=null",
            "head": "!=null",
            "ino": "!=null"
        }
    }
},


{
    "kprobe:iunique_lock": {
        "description": "Lock the inode hash lock.",
        "pre": {
            "inode_hash_lock": "!=null"
        }
    }
},
{
    "kretprobe:igrab": {
        "description": "Handle the case where s_op->clear_inode is not been called yet, and somebody is calling igrab while the inode is getting freed.",
        "pre": {
            "inode": "==null"
        }
    }
},
{
    "kprobe:igrab": {
        "description": "Handle the case where s_op->clear_inode is not been called yet, and somebody is calling igrab while the inode is getting freed.",
        "pre": {
            "inode": "==null"
        }
    }
},
{
    "kretprobe:ilookup5_nowait": {
        "description": "Search for an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ilookup5_nowait": {
        "description": "Search for an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_nowait": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "match": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:find_inode_nowait": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "match": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_rcu": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:find_inode_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},


{
    "kretprobe:bmap": {
        "description": "Find a block number in a file",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "block": "in [0, !=0] when return == 0"
        }
    }
},
{
    "kprobe:bmap": {
        "description": "Find a block number in a file",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "block": "in [0, !=0] when return == 0"
        }
    }
},
{
    "kretprobe:touch_atime": {
        "description": "Update the access time of a file.",
        "pre": {
            "path": "!=null",
            "mnt": "=path->mnt",
            "inode": "=d_inode(path->dentry)",
            "now": "=current_time(inode)",
            "atime_needs_update(path, inode)": "=true",
            "sb_start_write_trylock(inode->i_sb)": "=true",
            "__mnt_want_write(mnt)": "=0"
        },
        "post": {
            "sb_end_write(inode->i_sb)": "called"
        }
    }
},
{
    "kprobe:now = current_time(inode);inode_update_time(inode, &now, S_ATIME);__mnt_drop_write(mnt);skip_update:sb_end_write(inode->i_sb);}EXPORT_SYMBOL(touch_atime": {
        "description": "Updates the access time of a file.",
        "pre": {
            "path": "!=null",
            "path->mnt": "!=null",
            "path->dentry": "!=null",
            "d_inode(path->dentry)": "!=null",
            "atime_needs_update(path, d_inode(path->dentry))": "true",
            "sb_start_write_trylock(d_inode(path->dentry)->i_sb)": "true",
            "__mnt_want_write(path->mnt)": "== 0"
        }
    }
},
{
    "kretprobe:file_remove_privs": {
        "description": "Remove special file privileges (suid, capabilities) from a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "file": "!=null"
},


{
    "kretprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null",
            "flags": "in [IOCB_NOWAIT]",
            "file_inode_lock": "held"
        },
        "post": {
            "return_value": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null",
            "flags": "in [IOCB_NOWAIT]",
            "file_inode_lock": "held"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kretprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device.",
        "pre": {
            "inode": "!=null",
            "mode": "!=null",
            "rdev": "!=null",
            "inode->i_mode": "==mode",
            "S_ISCHR(mode)": "implies (inode->i_fop == &def_chr_fops && inode->i_rdev == rdev)",
            "S_ISBLK(mode)": "implies (IS_ENABLED(CONFIG_BLOCK) && inode->i_fop == &def_blk_fops && inode->i_rdev == rdev)",
            "S_ISFIFO(mode)": "implies (inode->i_fop == &pipefifo_fops)",
            "S_ISSOCK(mode)": "implies (inode->i_fop == &no_open_fops)"
        }
    }
},
{
    "kprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device.",
        "pre": {
            "inode": {
                "i_mode": "mode",
                "i_fop": {
                    "def_chr_fops": "S_ISCHR(mode)",
                    "def_blk_fops": "S_ISBLK(mode) && IS_ENABLED(CONFIG_BLOCK)",
                    "pipefifo_fops": "S_ISFIFO(mode)",
                    "no_open_fops": "S_ISSOCK(mode)"
                },
                "i_rdev": "rdev"
            }
        }
    }
},
{
    "kretprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "bool",
            "constraints": [
                "current has CAP_FOWNER in a namespace with the inode owner uid mapped",
                "current owns the file"
            ]
        }
    }
},
{
    "kprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_dio_wait": {
        "description": "wait for outstanding DIO requests to finish",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_dio_wait": {
        "description": "Wait for outstanding DIO requests to finish.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_set_flags": {
        "description": "Atomically set some inode flags.",
        "pre": {
            "inode": "!=null",
            "flags": "!=null",
            "mask": "!=null",
            "i_mutex": "held",
            "i_flags": "unchanged during execution"
        }
    }
},
{
    "kprobe:inode_set_flags": {
        "description": "Atomically set some inode flags.",
        "pre": {
            "inode": "!=null",
            "flags": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:timestamp_truncate": {
        "description": "Truncate timespec to a granularity",
        "pre": {
            "t": "!=null",
            "inode": "!=null",
            "gran": "!=0",
            "gran": "<=1000000000"
        }
    }
},
{
    "kprobe:timestamp_truncate": {
        "description": "Truncate timespec to a granularity",
        "pre": {
            "t": "!=null",
            "inode": "!=null",
            "gran": "!=0",
            "gran": "<=1000000000"
        }
    }
},
{
    "kretprobe:touch_atime": {
        "description": "Return mask of changes for notify_change() that need to be done as a response to write or truncate. Return 0 if nothing has to be changed. Negative value on error (change should be denied).",
        "pre": {
            "path": "!=null",
            "inode": "!=null",
            "now": "!=null",
            "relatime_need_update(mnt, inode, now)": "return false",
            "timespec64_equal(&inode->i_atime, &now)": "return false",
            "return true"
        }
    }
},
{
    "kprobe:touch_atime": {
        "description": "Return mask of changes for notify_change() that need to be done as a response to write or truncate. Return 0 if nothing has to be changed. Negative value on error (change should be denied).",
        "pre": {
            "path": "!=null",
            "inode": "!=null",
            "now": "!=null",
            "mnt": "!=null",
            "atime_needs_update(path, inode)": "true",
            "sb_start_write_trylock(inode->i_sb)": "true",
            "__mnt_want_write(mnt)": "== 0"
        }
    }
},
{
    "kretprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "!=null",
            "mode & S_ISGID": "==1",
            "mode & S_IXGRP": "==1",
            "dir & S_ISGID": "==1",
            "caller in group of parent directory or CAP_FSETID in user namespace and privileged over parent directory": "true"
        },
        "post": {
            "new mode": "mode & ~S_ISGID"
        }
    }
},
{
    "kprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "!=null",
            "mode & S_ISGID": "!=0",
            "mode & S_IXGRP": "!=0",
            "dir & S_ISGID": "!=0",
            "caller in group of parent directory or CAP_FSETID in user namespace and privileged over parent directory": "true"
        },
        "post": {
            "new mode to use for the file": "!=null"
        }
    }
},
{
    "kretprobe:__dump_emit": {
        "description": "Core dumping helper function.",
        "pre": {
            "cprm": "!=null",
            "addr": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kprobe:__dump_emit": {
        "description": "Core dumping helper function.",
        "pre": {
            "cprm": "!=null",
            "addr": "!=null",
            "nr": "!=null"
        }
    }
},


{
    "kretprobe:vfs_ioctl": {
        "description": "Call filesystem specific ioctl methods",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:vfs_ioctl": {
        "description": "Call filesystem specific ioctl methods",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function",
        "pre": {
            "fieinfo": "!=null",
            "logical": "!=null",
            "phys": "!=null",
            "len": "!=null",
            "flags": "in [FIEMAP_EXTENT flags]"
        }
    }
},
{
    "kprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function",
        "pre": {
            "fieinfo": "!=null",
            "logical": "!=null",
            "phys": "!=null",
            "len": "!=null",
            "flags": "in [FIEMAP_EXTENT]"
        }
    }
},
{
    "kretprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": "!=null",
            "len": "!=null",
            "supported_flags": "!=null"
        }
    }
},
{
    "kprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": "!=null",
            "len": "!=null",
            "supported_flags": "!=null"
        }
    }
},
{
    "kretprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags",
        "pre": {
            "fa": "!=null",
            "xflags": "!=null"
        }
    }
},
{
    "kprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags",
        "pre": {
            "fa": "!=null",
            "xflags": "!=null"
        }
    }
},
{
    "kretprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags",
        "pre": {
            "fa": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags",
        "pre": {
            "fa": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kretprobe:copy_fsxattr_to_user": {
        "description": "Copy fsxattr to userspace.",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT]"
        }
    }
},
{
    "kprobe:copy_fsxattr_to_user": {
        "description": "copy fsxattr to userspace.",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        }
    }
},
{
    "kretprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kretprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation",
        "pre": {
            "file": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        },
        "post": {
            "return_value": "is_valid_long"
        }
    }
},
{
    "kprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation",
        "pre": {
            "file": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:generic_remap_file_range_prep": {
        "description": "Prepare for generic remap file range operation.",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "remap_flags": "!=null",
            "dax_read_ops": "!=null",
            "inode_in": "!=null",
            "inode_out": "!=null",
            "same_inode": "in [true, false]",
            "ret": "!=null"
        },
        "post": {
            "ret": "in [-EPERM, -ETXTBSY]"
        }
    }
},
{
    "kprobe:generic_remap_file_range_prep": {
        "description": "Prepare for generic remap file range operation.",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "remap_flags": "!=null",
            "dax_read_ops": "!=null",
            "inode_in": "!=null",
            "inode_out": "!=null",
            "same_inode": "in [true, false]",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:remap_verify_area": {
        "description": "Verify the area for remapping.",
        "pre": {
            "src_file": "!=null",
            "src_pos": "!=null",
            "len": "!=null",
            "false": "true"
        }
    },
    "kretprobe:remap_verify_area": {
        "description": "Verify the area for remapping.",
        "pre": {
            "dst_file": "!=null",
            "dst_pos": "!=null",
            "len": "!=null",
            "true": "true"
        }
    },
    "kretprobe:allow_file_dedupe": {
        "description": "Check if file deduplication is allowed.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:file_inode": {
        "description": "Get the inode of a file.",
        "pre": {
            "src_file": "!=null",
            "dst_file": "!=null"
        }
    },
    "kretprobe:S_ISDIR": {
        "description": "Check if the file is a directory.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:dst_file->f_op->remap_file_range": {
        "description": "Check if remap_file_range is supported by the file.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:len": {
        "description": "Check if len is equal to 0.",
        "pre": {
            "len": "0"
        }
    }
},
{
    "kprobe:remap_verify_area": {
        "description": "Verify the area to be remapped.",
        "pre": {
            "src_file": "!=null",
            "src_pos": "!=null",
            "len": "!=null",
            "false": "true"
        }
    },
    "kprobe:remap_verify_area": {
        "description": "Verify the area to be remapped.",
        "pre": {
            "dst_file": "!=null",
            "dst_pos": "!=null",
            "len": "!=null",
            "true": "true"
        }
    },
    "kprobe:allow_file_dedupe": {
        "description": "Check if file deduplication is allowed.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:file_inode": {
        "description": "Get the inode of a file.",
        "pre": {
            "src_file": "!=null",
            "dst_file": "!=null"
        }
    },
    "kprobe:S_ISDIR": {
        "description": "Check if the file is a directory.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:dst_file->f_op->remap_file_range": {
        "description": "Check if the file has the remap_file_range operation.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:len": {
        "description": "Check if the length is zero.",
        "pre": {
            "len": "0"
        }
    }
},
{
    "kretprobe:vfs_dedupe_file_range_compare": {
        "description": "Compare file ranges for deduplication.",
        "pre": {
            "!folio_test_uptodate(src_folio)": true,
            "!folio_test_uptodate(dst_folio)": true,
            "src_folio->mapping": "!= src->f_mapping",
            "dst_folio->mapping": "!= dest->f_mapping"
        }
    }
},
{
    "kprobe:vfs_dedupe_file_range_compare": {
        "description": "Compare file ranges for deduplication.",
        "pre": {
            "!folio_test_uptodate(src_folio)": true,
            "!folio_test_uptodate(dst_folio)": true,
            "src_folio->mapping": "!= src->f_mapping",
            "dst_folio->mapping": "!= dest->f_mapping"
        }
    }
},


{
    "kretprobe:WARN_ON_ONCE": {
        "description": "Check if the fl_ops field of the new lock is not null.",
        "pre": {
            "new->fl_ops": "!=null"
        }
    },
    "kretprobe:locks_copy_conflock": {
        "description": "Copy the contents of the fl lock to the new lock.",
        "pre": {
            "new": "freshly-initialized lock",
            "fl": "lock"
        }
    },
    "kretprobe:new->fl_file": {
        "description": "Assign the fl_file field of the fl lock to the new lock.",
        "pre": {
            "new->fl_file": "= fl->fl_file"
        }
    },
    "kretprobe:new->fl_ops": {
        "description": "Assign the fl_ops field of the fl lock to the new lock.",
        "pre": {
            "new->fl_ops": "= fl->fl_ops"
        }
    },
    "kretprobe:if (fl->fl_ops)": {
        "description": "Check if the fl_ops field of the fl lock is not null.",
        "pre": {
            "fl->fl_ops": "!=null"
        }
    }
},
{
    "kprobe:locks_copy_lock": {
        "description": "Copy the contents of the file lock 'fl' to the newly initialized file lock 'new'.",
        "pre": {
            "new": {
                "fl_ops": "==null"
            },
            "fl": {
                "fl_ops": "!=null"
            }
        }
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Stop waiting for a file lock",
        "pre": {
            "waiter": "!=null",
            "waiter->fl_blocker": "==null"
        }
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Store NULL in the fl_blocker field of the waiter structure.",
        "pre": {
            "waiter": "!=null"
        }
    }
},
{
    "kretprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file.",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        }
    }
},
{
    "kprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        }
    }
},
{
    "kretprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "pre": {
            "filp": "!=null",
            "type": "is a valid long value",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "pre": {
            "filp": "!=null",
            "type": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:__break_lease": {
        "description": "__break_lease - revoke all outstanding leases on file",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        }
    }
},
{
    "kprobe:__break_lease": {
        "description": "__break_lease-revoke all outstanding leases on file",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        }
    }
},
{
    "kretprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease.",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease.",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:generic_setlease": {
        "description": "Sets a lease on an open file.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null",
            "flp->fl_lmops->lm_break": "!=null"
        }
    }
},
{
    "kprobe:generic_setlease": {
        "description": "Sets a lease on an open file.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null",
            "flp->fl_lmops->lm_break": "!=null"
        }
    }
},
{
    "kretprobe:locks_lock_inode_wait": {
        "description": "Apply a lock to an inode",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:locks_lock_inode_wait": {
        "description": "Apply a lock to an inode",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:locks_remove_posix": {
        "description": "Remove POSIX locks from a file.",
        "pre": {
            "filp": "!=null",
            "owner": "!=null",
            "inode": "!=null",
            "lock": "!=null",
            "ctx": "!=null",
            "error": "!=null"
        }
    }
},
{
    "kprobe:locks_remove_posix": {
        "description": "Remove POSIX locks from a file.",
        "pre": {
            "filp": "!=null",
            "owner": "!=null",
            "inode": "!=null",
            "ctx": "!=null",
            "list_empty(&ctx->flc_posix)": "true",
            "locks_init_lock(&lock)": "true",
            "lock.fl_type": "F_UNLCK",
            "lock.fl_flags": "FL_POSIX | FL_CLOSE",
            "lock.fl_start": "0",
            "lock.fl_end": "OFFSET_MAX",
            "lock.fl_owner": "owner",
            "lock.fl_pid": "current->tgid",
            "lock.fl_file": "filp",
            "lock.fl_ops": "NULL",
            "lock.fl_lmops": "NULL",
            "vfs_lock_file(filp, F_SETLK, &lock, NULL)": "error",
            "lock.fl_ops && lock.fl_ops->fl_release_private": "true",
            "lock.fl_ops->fl_release_private(&lock)": "true",
            "trace_locks_remove_posix(inode, &lock, error)": "true"
        }
    }
},
{
    "kretprobe:finish_open": {
        "description": "Finish opening a file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null"
        }
    }
},
{
    "kprobe:finish_open": {
        "description": "Finish opening a file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kretprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:dentry_open": {
        "description": "Open a dentry",
        "pre": {
            "f": {
                "f_path": {
                    "mnt": "!=null"
                },
                "f_inode": "!=null",
                "f_mapping": "!=null",
                "f_flags": "in [O_PATH, O_RDWR, O_WRONLY, O_RDONLY]"
            },
            "inode": {
                "i_mode": "!=null"
            }
        }
    }
},
{
    "inode": {
        "i_mode": {
            "constraints": [
                "S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)"
            ]
        }
    }
},
{
    "kretprobe:dentry_create": {
        "description": "Create and open a file",
        "pre": {
            "path": "!=null",
            "flags": "!=null",
            "mode": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:dentry_create": {
        "description": "Create and open a file",
        "pre": {
            "path": "!=null",
            "flags": "!=null",
            "mode": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kretprobe:filp_open": {
        "description": "Open file and return file pointer",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:filp_open": {
        "description": "Open file and return file pointer",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors.",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors.",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:get_cached_acl": {
        "description": "Get the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null",
            "ret": "!=null",
            "acl": "==ret",
            "IS_ERR(ret)": "==false",
            "is_uncached_acl(acl)": "==false",
            "IS_POSIXACL(inode)": "==true",
            "sentinel": "==uncached_acl_sentinel(current)",
            "p": "==acl_by_type(inode, type)"
        },
        "post": {
            "return": "==acl"
        }
    }
},
{
    "kprobe:get_cached_acl": {
        "description": "Get the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:IS_POSIXACL": {
        "description": "Check if the inode has POSIX ACL enabled.",
        "pre": {
            "inode": "!=null"
        }
    },
    "kprobe:uncached_acl_sentinel": {
        "description": "Get the uncached ACL sentinel for the current task.",
        "pre": {
            "current": "!=null"
        }
    },
    "kprobe:acl_by_type": {
        "description": "Get the ACL by type for the given inode.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:get_inode_acl": {
        "description": "Get the inode ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:posix_acl_dup": {
        "description": "Duplicate the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:posix_acl_release": {
        "description": "Release the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:xchg": {
        "description": "Exchange the value of the given variable with a new value.",
        "pre": {
            "p": "!=null",
            "acl": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:posix_acl_release": {
        "description": "Release the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:__forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "p": "!=null"
        }
    },
    "kprobe:forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:__forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "p": "!=null"
        }
    },
    "kprobe:forget_all_cached_acls": {
        "description": "Forget all the cached ACLs for the given inode.",
        "pre": {
            "inode": "!=null"
        }
    },
    "kprobe:__get_acl": {
        "description": "Get the ACL for the given inode, dentry, and type.",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "sentinel": "!=null"
        }
    }
},
{
    "kretprobe:posix_acl_equiv_mode": {
        "description": "Check if the given ACL is equivalent to the mode bits.",
        "pre": {
            "acl": "==null",
            "pa": "!=null",
            "pe": "!=null"
        }
    }
},



{
    "kretprobe:posix_acl_update_mode": {
        "description": "Update the file mode when setting an ACL: compute the new file permission bits based on the ACL.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        }
    }
},
{
    "kprobe:posix_acl_update_mode": {
        "description": "Update mode in set_acl",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        }
    }
},
{
    "kretprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file.",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file.",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:splice_direct_to_actor": {
        "description": "Splices data directly between two non-pipes.",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_direct_to_actor": {
        "description": "Splices data directly between two non-pipes.",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:do_splice_direct": {
        "description": "Splices data directly between two files.",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:do_splice_direct": {
        "description": "splices data directly between two files",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:copy_string_kernel": {
        "description": "Copy a string from user space to kernel space.",
        "pre": {
            "arg": "!=null",
            "bprm": "!=null",
            "bprm->p": "!=null",
            "len": "==0",
            "valid_arg_len(bprm, len)": "==true"
        }
    }
},
{
    "kprobe:copy_string_kernel": {
        "description": "Copy a string from user space to kernel space.",
        "pre": {
            "pos": "any",
            "len": "== 0",
            "arg": "any",
            "bprm": "!= null"
        }
    }
},

{
    "kprobe:bprm_mm_init": {
        "description": "Initialize the memory map for the binary being executed.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kretprobe:open_exec": {
        "description": "Open and execute a file.",
        "pre": {
            "fd": "!=null",
            "name": "!=null",
            "flags": "!=null",
            "flags": "in [AT_SYMLINK_NOFOLLOW, AT_EMPTY_PATH]"
        }
    }
},
{
    "kprobe:open_exec": {
        "description": "Open and execute a file.",
        "pre": {
            "err": "== -EACCES",
            "file": {
                "inode": {
                    "i_mode": "& S_IFREG != 0"
                },
                "f_path": {
                    "path_noexec": "== false"
                }
            }
        }
    }
},
{
    "kretprobe:bprm_creds_from_file": {
        "description": "Compute the credentials for the given binary file.",
        "pre": {
            "bprm": "!=null"
        },
        "post": {
            "retval": "!=null",
            "retval": "!=0"
        }
    }
},
{
    "kprobe:bprm_creds_from_file": {
        "description": "Ensure all future errors are fatal.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "acct_arg_size": {
        "description": "Calculate the size of the accounting arguments for the given bprm.",
        "pre": {
            "bprm": "!=null"
        },
        "post": {
            "retval": ">=0"
        }
    }
},
{
    "kprobe:acct_arg_size": {
        "description": "Calculate the size of the accounting arguments for the given bprm.",
        "pre": {
            "bprm": "!=null"
        }
    },
    "kprobe:exec_mmap": {
        "description": "Execute mmap on the given mm.",
        "pre": {
            "mm": "!=null"
        }
    },
    "kprobe:exec_task_namespaces": {
        "description": "Execute task namespaces.",
        "pre": {}
    },
    "kprobe:spin_lock_irq": {
        "description": "Acquire the spinlock for the siglock of the current process.",
        "pre": {
            "me": "!=null",
            "me->sighand": "!=null",
            "me->sighand->siglock": "!=null"
        }
    },
    "kprobe:posix_cpu_timers_exit": {
        "description": "Exit the POSIX CPU timers for the given process.",
        "pre": {
            "me": "!=null"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release the spinlock for the siglock of the current process.",
        "pre": {
            "me": "!=null",
            "me->sighand": "!=null",
            "me->sighand->siglock": "!=null"
        }
    },
    "kprobe:exit_itimers": {
        "description": "Exit the interval timers for the given process.",
        "pre": {
            "me": "!=null"
        }
    },
    "kprobe:flush_itimer_signals": {
        "description": "Flush the itimer signals for the current process.",
        "pre": {}
    }
},


{
    "kretprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "pre": {
            "current": {
                "group_leader": "!=null"
            },
            "current->signal": {
                "rlim[RLIMIT_STACK]": "!=null"
            },
            "bprm": {
                "rlim_stack": "!=null"
            }
        }
    }
},
{
    "kprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kretprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "pre": {
            "interp": "!=null",
            "bprm": {
                "interp": "!=bprm->filename"
            }
        },
        "post": {
            "interp": "=kstrdup(interp, GFP_KERNEL)",
            "!interp": "return -ENOMEM",
            "return": "0"
        }
    }
},
{
    "kprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "pre": {
            "bprm->interp": "!= bprm->filename",
            "kfree(bprm->interp)": "called",
            "bprm->interp": "= kstrdup(interp, GFP_KERNEL)",
            "!bprm->interp": "return -ENOMEM",
            "return": "0"
        }
    }
},
{
    "kretprobe:register_chrdev_region": {
        "description": "Register a range of device numbers",
        "pre": {
            "from": "!=null",
            "count": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:register_chrdev_region": {
        "description": "Register a range of device numbers",
        "pre": {
            "from": "!=null",
            "count": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:alloc_chrdev_region": {
        "description": "Register a range of char device numbers",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kprobe:alloc_chrdev_region": {
        "description": "Register a range of char device numbers",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:cdev_init": {
        "description": "Initialize a cdev structure",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kprobe:cdev_init": {
        "description": "Initialize a cdev structure",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kretprobe:unregister_chrdev_region": {
        "description": "Unregister a range of device numbers.",
        "pre": {
            "from": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:unregister_chrdev_region": {
        "description": "Unregister a range of device numbers.",
        "pre": {
            "from": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:chrdev_open": {
        "description": "Called every time a character special file is opened",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:chrdev_open": {
        "description": "Called every time a character special file is opened",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:cdev_set_parent": {
        "description": "Set the parent kobject for a char device",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:cdev_set_parent": {
        "description": "Set the parent kobject for a char device.",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kretprobe:cdev_device_add": {
        "description": "Add a char device and its corresponding struct device.",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kprobe:cdev_device_add": {
        "description": "Add a char device and its corresponding struct device.",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kretprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add",
        "pre": {
            "dev": "!=null",
            "cdev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add",
        "pre": {
            "dev": "!=null",
            "cdev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kretprobe:make_bad_inode": {
        "description": "Mark an inode as bad due to an I/O error",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:make_bad_inode": {
        "description": "Mark an inode as bad due to an I/O error.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:is_bad_inode": {
        "description": "Check if the inode has been marked as bad.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:is_bad_inode": {
        "description": "Check if the inode has been marked as bad.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it.",
        "pre": {
            "inode": "!=null"
        }
    }
},

{
    "kprobe:map_buffer_to_folio": {
        "description": "Map a buffer into a page to avoid adding new buffers.",
        "pre": {
            "folio": "!=null",
            "bh": "!=null",
            "page_block": "!=null"
        }
    }
},
{
    "kretprobe:intmpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space and writepage() all of them.",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kprobe:intmpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space & writepage() all of them.",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:setattr_should_drop_sgid": {
        "description": "Check if the setgid bit needs to be removed from the inode.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [ATTR_KILL_SGID, 0]"
        }
    }
},
{
    "kprobe:setattr_should_drop_sgid": {
        "description": "Check if the setgid bit needs to be removed from the inode.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "retval": "in [ATTR_KILL_SGID, 0]"
        }
    }
},
{
    "kretprobe:setattr_should_drop_suidgid": {
        "description": "Determine whether the set{g,u}id bit needs to be dropped.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [0, ATTR_KILL_SUID, ATTR_KILL_SGID, ATTR_KILL_SUID | ATTR_KILL_SGID]"
        }
    }
},
{
    "kprobe:setattr_should_drop_suidgid": {
        "description": "Determine whether the set{g,u}id bit needs to be dropped.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [ATTR_KILL_SUID, ATTR_KILL_SGID, 0]"
        }
    }
},

{
    "kprobe:if (ia_valid & ATTR_FORCE)goto kill_priv;/* Make sure a caller can chown. */": {
        "description": "Check if a caller can chown.",
        "pre": {
            "ia_valid": "!=0",
            "ATTR_FORCE": "!=0"
        },
        "goto": "kill_priv"
    }
},
{
    "kretprobe:ia_valid & ATTR_TOUCH": {
        "description": "Check if the `ia_valid` bitmask includes the `ATTR_TOUCH` flag.",
        "pre": {
            "ia_valid": "&= ATTR_TOUCH"
        }
    }
},
{
    "kprobe:if (ia_valid & ATTR_TOUCH)": {
        "description": "Check if the `ia_valid` bitmask includes the `ATTR_TOUCH` flag.",
        "pre": {
            "ia_valid": "& ATTR_TOUCH != 0"
        }
    }
},
{
    "kretprobe:notify_change": {
        "description": "Modify attributes of a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},
{
    "kprobe:notify_change": {
        "description": "Modify attributes of a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},


{
    "kretprobe:generic_permission": {
        "description": "Check for access rights on a Posix-like filesystem",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [MAY_READ, MAY_WRITE, MAY_EXEC, MAY_NOT_BLOCK]"
        }
    }
},
{
    "kprobe:generic_permission": {
        "description": "Check for access rights on a Posix-like filesystem",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:do_inode_permission": {
        "description": "UNIX permission checking",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC]"
        }
    }
},
{
    "kprobe:do_inode_permission": {
        "description": "UNIX permission checking",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC]"
        }
    }
},
{
    "kretprobe:path_get": {
        "description": "Get a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_get": {
        "description": "Get a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:path_put": {
        "description": "Put a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_put": {
        "description": "Put a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount",
        "pre": {
            "path": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:lookup_one_qstr_excl": {
        "description": "Lookup a dentry with the given name in the base directory, excluding certain flags.",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "flags": "unsigned int",
            "base->d_inode": "!=null",
            "IS_DEADDIR(base->d_inode)": "==false",
            "lookup_dcache(name, base, flags)": "==null"
        },
        "post": {
            "return": "dentry",
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:lookup_one_qstr_excl": {
        "description": "Lookup a dentry with the given name and base directory, excluding certain flags.",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "flags": "!=null",
            "base->d_inode": "!=null",
            "IS_DEADDIR(base->d_inode)": "==false",
            "dentry": "==null"
        }
    }
},
{
    "kretprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        }
    }
},
{
    "kprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair.",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        }
    }
},
{
    "kretprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair.",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair.",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:try_lookup_one_len": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:try_lookup_one_len": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:inode_lock_nested": {
        "description": "Lock the inode of the given dentry with the specified mutex.",
        "pre": {
            "p2->d_inode": "!=null",
            "I_MUTEX_PARENT": "!=null"
        }
    }
},
{
    "kprobe:inode_lock_nested": {
        "description": "Lock the inode of p2's dentry with I_MUTEX_PARENT.",
        "pre": {
            "p2->d_inode": "!=null",
            "I_MUTEX_PARENT": "!=null",
            "c1->d_parent": "==p2"
        }
    }
},
{
    "kretprobe:vfs_create": {
        "description": "Create a new file.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "want_excl": "!=null"
        }
    }
},
{
    "kprobe:vfs_create": {
        "description": "Create a new file.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "want_excl": "!=null"
        }
    }
},
{
    "kretprobe:kernel_tmpfile_open": {
        "description": "Open a tmpfile for kernel internal use",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "!=null",
            "open_flag": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:kernel_tmpfile_open": {
        "description": "Open a tmpfile for kernel internal use",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "!=null",
            "open_flag": "!=null",
            "cred": "!=null"
        }
    }
},


{
    "kretprobe:vfs_mkdir": {
        "description": "Create a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:vfs_mkdir": {
        "description": "Create a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:vfs_rmdir": {
        "description": "Remove a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:vfs_rmdir": {
        "description": "Remove a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:vfs_unlink": {
        "description": "Unlink a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "delegated_inode": "!=null",
            "dir->i_mutex": "held",
            "delegated_inode": "returns -EWOULDBLOCK if delegation is discovered",
            "delegated_inode": "returns reference to inode if delegation is discovered",
            "delegated_inode": "caller should break delegation and retry",
            "dir->i_mutex": "should be dropped before breaking delegation",
            "delegated_inode": "can be NULL for non-NFS exported filesystems",
            "idmap": "required if inode found through idmapped mount",
            "idmap": "used to map the inode according to idmap before checking permissions",
            "idmap": "pass nop_mnt_idmap for non-idmapped mounts or raw inode permission checking"
        }
    }
},
{
    "kprobe:vfs_unlink": {
        "description": "Unlink a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},
{
    "kretprobe:vfs_symlink": {
        "description": "Create a symlink.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null"
        }
    }
},
{
    "kprobe:vfs_symlink": {
        "description": "Create a symlink.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null"
        }
    }
},
{
    "kretprobe:vfs_link": {
        "description": "Create a new link",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "!=null or ==null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:vfs_link": {
        "description": "create a new link",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "in [null, !=null]"
        }
    }
},


{
    "kretprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:vfs_get_link": {
        "description": "Get symlink body",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kprobe:vfs_get_link": {
        "description": "Get symlink body",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_create": {
        "description": "Create entry in cache",
        "pre": {
            "cache": "!=null",
            "mask": "!=null",
            "key": "!=null",
            "value": "!=null",
            "reusable": "in [true, false]"
        },
        "post": {
            "return": "in [-EBUSY, 0]"
        }
    }
},
{
    "kprobe:mb_cache_entry_create": {
        "description": "Create entry in cache",
        "pre": {
            "cache": "!=null",
            "mask": "!=null",
            "key": "!=null",
            "value": "!=null",
            "reusable": "in [true, false]"
        }
    }
},
{
    "kretprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_first": {
        "description": "Find the first reusable entry with the given key",
        "pre": {
            "cache": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_find_first": {
        "description": "Find the first reusable entry with the given key",
        "pre": {
            "cache": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_next": {
        "description": "Find next reusable entry with the same key",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_find_next": {
        "description": "Find next reusable entry with the same key",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key).",
        "pre": {
            "cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key).",
        "pre": {
            "cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:struct_mb_cache": {
        "description": "Used for deduplication of extended attribute blocks and xattr values stored in inodes.",
        "pre": {
            "entry": "!=null",
            "key": "!=null",
            "value": "!=null",
            "operation": "in [CREATE, REMOVE, SEARCH, DELETE]",
            "hash_table": "fixed-size"
        }
    }
},
{
    "kprobe:struct_mb_cache_create": {
        "description": "Create a new entry in the mb_cache.",
        "pre": {
            "mb_cache": "!=null"
        }
    },
    "kprobe:struct_mb_cache_remove": {
        "description": "Remove an entry from the mb_cache.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:struct_mb_cache_search": {
        "description": "Search for an entry in the mb_cache by key.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null"
        }
    },
    "kprobe:struct_mb_cache_delete_entry": {
        "description": "Delete an entry from the mb_cache with a given key-value pair.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "pre": {
            "bucket_bits": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "pre": {
            "bucket_bits": ">=0"
        }
    }
},
{
    "kretprobe:mb_cache_destroy": {
        "description": "Destroy cache",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_destroy": {
        "description": "Destroy cache",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:seq_open": {
        "description": "Initialize sequential file",
        "pre": {
            "file": "!=null",
            "op": "!=null",
            "op->start": "!=null",
            "op->stop": "!=null",
            "op->next": "!=null",
            "op->show": "!=null",
            "op->start()": "returns !ERR_PTR",
            "op->next()": "returns !ERR_PTR",
            "op->show()": "returns >=0 or SEQ_SKIP",
            "@file->private_data": "unchanged"
        }
    }
},
{
    "kprobe:seq_open": {
        "description": "Initialize sequential file",
        "pre": {
            "file": "!=null",
            "op": "!=null",
            "op->start": "!=null",
            "op->stop": "!=null",
            "op->next": "!=null",
            "op->show": "!=null",
            "op->start()": "returns != ERR_PTR(error)",
            "op->next()": "returns != ERR_PTR(error)",
            "op->show()": "returns >= 0",
            "op->show()": "returns != SEQ_SKIP"
        }
    }
},
{
    "kretprobe:seq_read": {
        "description": "read() method for sequential files.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_read": {
        "description": "read() method for sequential files.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_read_iter": {
        "description": "Read data from a sequence file into a buffer.",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb.ki_pos": ">=0",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:seq_read_iter": {
        "description": "Read data from a sequential file into a buffer.",
        "pre": {
            "iocb": "!=null",
            "iocb.ki_pos": "any value",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:seq_lseek": {
        "description": "llseek() method for sequential files.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [0, 1]"
        }
    }
},
{
    "kprobe:seq_lseek": {
        "description": "llseek() method for sequential files.",
        "pre": {
            "file": "!=null",
            "whence": "in [0, 1]"
        }
    }
},
{
    "kretprobe:seq_release": {
        "description": "Free the structures associated with sequential file.",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:seq_release": {
        "description": "Free the structures associated with sequential file.",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kretprobe:seq_escape_mem": {
        "description": "Print data into buffer, escaping some characters",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_escape_mem": {
        "description": "Print data into buffer, escaping some characters",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:mangle_path": {
        "description": "Mangle and copy path to buffer",
        "pre": {
            "s": "!=null",
            "p": "!=null",
            "esc": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mangle_path": {
        "description": "Mangle and copy path to buffer",
        "pre": {
            "s": "!=null",
            "p": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_path": {
        "description": "seq_file interface to print a pathname",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_path": {
        "description": "seq_file interface to print a pathname",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_file_path": {
        "description": "Prints the absolute path of a file using the seq_file interface.",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_file_path": {
        "description": "Prints the absolute path of a file using the seq_file interface.",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf().",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "!=null",
            "width": ">=0"
        }
    }
},
{
    "kprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf().",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "!=null",
            "width": ">=0"
        }
    }
},
{
    "kretprobe:goto overflow;if (delimiter && delimiter[0])": {
        "description": "Conditional statement to check if delimiter is not null and delimiter[0] is not null.",
        "pre": {
            "delimiter": "!=null",
            "delimiter[0]": "!=null"
        }
    }
},

{
    "kretprobe:seq_write": {
        "description": "Write arbitrary data to buffer",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:seq_write": {
        "description": "Write arbitrary data to buffer.",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:seq_pad": {
        "description": "Write padding spaces to buffer",
        "pre": {
            "m": "!=null",
            "c": ">=0"
        }
    }
},
{
    "kprobe:seq_pad": {
        "description": "Write padding spaces to buffer",
        "pre": {
            "m": "!=null",
            "c": "is_char"
        }
    }
},
{
    "kretprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist.",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist.",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array.",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array.",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:f_setown": {
        "description": "Set the owner of a file to a specified process ID.",
        "pre": {
            "filp": "!=null",
            "pid": "!=null",
            "type": "in [PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_TGID]",
            "force": "in [0, 1]",
            "arg": "!=null",
            "ret": "!=null",
            "who": "!=null",
            "type": "in [PIDTYPE_TGID, PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID]",
            "ret": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:if": {
        "description": "Condition for the 'if' statement in the function.",
        "pre": {
            "who": "== INT_MIN"
        }
    },
    "kprobe:return": {
        "description": "Condition for the 'return' statement in the function.",
        "pre": {
            "return": "== -EINVAL"
        }
    },
    "kprobe:type": {
        "description": "Condition for the 'type' assignment in the function.",
        "pre": {
            "type": "== PIDTYPE_PGID"
        }
    },
    "kprobe:who": {
        "description": "Condition for the 'who' assignment in the function.",
        "pre": {
            "who": "== -who"
        }
    },
    "kprobe:rcu_read_lock": {
        "description": "Condition for the 'rcu_read_lock' function call in the function.",
        "pre": {
            "rcu_read_lock": "()"
        }
    },
    "kprobe:if_2": {
        "description": "Condition for the second 'if' statement in the function.",
        "pre": {
            "who": "!= 0"
        }
    }
},
{
    "kretprobe:fasync_helper": {
        "description": "Used by almost all character device drivers to set up the fasync queue, and for regular files by the file lease code.",
        "pre": {
            "fd": "!=null",
            "filp": "!=null",
            "on": "!=null",
            "fapp": "!=null"
        },
        "post": {
            "return_value": "<=0"
        }
    }
},
{
    "kprobe:fasync_helper": {
        "description": "Used by character device drivers and file lease code to set up the fasync queue.",
        "pre": {
            "fd": "!=null",
            "filp": "!=null",
            "on": "!=null",
            "fapp": "!=null"
        }
    }
},
{
    "kretprobe:kill_fasync": {
        "description": "Kill the fasync_struct by sending a signal.",
        "pre": {
            "fa": "!=null",
            "sig": "!=SIGURG",
            "fown->signum": "!=0"
        }
    }
},
{
    "kill_fasync": {
        "pre": {
            "sig": "!= SIGURG",
            "fown->signum": "!= 0"
        },
        "post": {
            "send_sigio(fown, fa->fa_fd, band)": "called",
            "read_unlock_irqrestore(&fa->fa_lock, flags)": "called",
            "fa = rcu_dereference(fa->fa_next)": "called"
        }
    }
},
{
    "kretprobe:deactivate_locked_super": {
        "description": "Drops an active reference to superblock, converting it into a temporary one if there is no other active references left.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_locked_super": {
        "description": "Drop an active reference to superblock.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:deactivate_super": {
        "description": "Drop an active reference to superblock",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_super": {
        "description": "Drop an active reference to superblock",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:retire_super": {
        "description": "Retire the superblock and mark it for re-use.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:retire_super": {
        "description": "Retire the superblock and mark it for re-use.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:sget_fc": {
        "description": "Find or create a superblock",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kprobe:sget_fc": {
        "description": "Find or create a superblock",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},


{
    "kretprobe:iterate_supers_type": {
        "description": "Call function for superblocks of given type",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:iterate_supers_type": {
        "description": "Call function for superblocks of given type",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one.",
        "pre": {
            "p": "!=null"
        },
        "post": {
            "return": "in [0, -EMFILE, -ENOMEM]"
        }
    }
},
{
    "kprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one.",
        "pre": {
            "p": "!=null"
        },
        "context": "Any context. Frequently called while holding sb_lock.",
        "return": {
            "success": "0",
            "failure": {
                "-EMFILE": "if there are no anonymous bdevs left",
                "-ENOMEM": "if memory allocation failed"
            }
        }
    }
},
{
    "kretprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "kprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "mount_bdev": {
        "pre": {
            "mutex_lock": "bd_fsfreeze_mutex",
            "bd_fsfreeze_count": "> 0"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Lock the specified mutex.",
        "pre": {
            "mutex": "!=null",
            "mutex->count": "> 0",
            "bdev": "!=null",
            "bdev->bd_fsfreeze_count": "> 0"
        }
    }
},
{
    "kretprobe:compare_single": {
        "description": "mount_single(), then a chunk of this can be removed. [Bollocks -- AV] Better yet, reconfiguration shouldn't happen, but rather the second mount should be rejected if the parameters are not compatible.",
        "pre": {
            "s->s_root": "!=null",
            "flags": "!=null",
            "MS_RMT_MASK": "!=null",
            "fc": "!=null",
            "data": "!=null",
            "ret": "!=null",
            "s": "!=null",
            "p": "!=null"
        },
        "post": {}
    }
},

{
    "kretprobe:vfs_get_tree": {
        "description": "Get the mountable root",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_get_tree": {
        "description": "Get the mountable root",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state.",
        "pre": {
            "sb": "!=null",
            "sb->s_writers.frozen": "in [SB_UNFROZEN, SB_FREEZE_WRITE, SB_FREEZE_PAGEFAULT, SB_FREEZE_F SB_FREEZE_COMPLETE]"
        }
    }
},
{
    "kprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state.",
        "pre": {
            "sb": "!=null",
            "sb->s_writers.frozen": "in [SB_UNFROZEN, SB_FREEZE_WRITE, SB_FREEZE_PAGEFAULT, SB_FREEZE_F SB_FREEZE_COMPLETE]"
        }
    }
},
{
    "kretprobe:super_cache_scan": {
        "description": "Function for scanning the super cache.",
        "pre": {
            "shrink": "!=null",
            "sc": "!=null"
        }
    }
},
{
    "kprobe:super_cache_scan": {
        "description": "Scan the superblock cache and perform shrinking operations.",
        "pre": {
            "shrink": "!=null",
            "sc": "!=null",
            "sb": "!=null",
            "super_blocks": "is a list",
            "sb_lock": "is a spinlock",
            "sb_writers_name": "is an array",
            "shrinker_rwsem": "is a semaphore"
        }
    }
},
{
    "kretprobe:__mnt_want_write_file": {
        "description": "Check if the __mnt_want_write_file function returns a non-zero value, indicating a successful write operation.",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kprobe:__mnt_want_write_file": {
        "description": "Helper function to indicate if the file should be writable.",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kretprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:return -1;}/* call under rcu_read_lock": {
        "description": "Call under rcu_read_lock",
        "pre": {
            "bastard": "!=null",
            "mnt": "!=null",
            "mount_lock": "unknown",
            "seq": "unknown",
            "bastard->mnt_flags & MNT_SYNC_UMOUNT": "unknown",
            "bastard->mnt_flags & MNT_DOOMED": "unknown"
        }
    }
},
{
    "kprobe:return -1;}/* call under rcu_read_lock ": {
        "description": "Helper function for mntput_no_expire().",
        "pre": {
            "read_seqretry(&mount_lock, seq)": "false",
            "bastard->mnt_flags & MNT_SYNC_UMOUNT": "false",
            "bastard->mnt_flags & MNT_DOOMED": "false"
        }
    }
},


{
    "kretprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace.",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace.",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        }
    }
},
{
    "kprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        }
    }
},
{
    "kretprobe:s = path.mnt->mnt_sb;atomic_inc(&s->s_active);mntput(path.mnt);/* lock the sucker `": {
        "description": "Lock the super block and increment the active count.",
        "pre": {
            "path.mnt": "!=null",
            "path.mnt->mnt_sb": "!=null",
            "s": "!=null",
            "s->s_active": "!=null"
        }
    }
},
{
    "kprobe:s = path.mnt->mnt_sb;atomic_inc(&s->s_active);mntput(path.mnt);/* lock the sucker `": {
        "description": "Increment the reference count of the superblock associated with the given mount point.",
        "pre": {
            "path.mnt": "!=null",
            "name": "!=null"
        }
    }
},


{
    "kretprobe:fscache_end_volume_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "volume": "!=null",
            "cookie": "!=null",
            "why": "in [fscache_access_unlive]"
        }
    }
},
{
    "kprobe:fscache_end_volume_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "volume": "!=null",
            "cookie": "!=null",
            "why": "in [fscache_access_unlive]"
        }
    }
},
{
    "kretprobe:fscache_withdraw_volume": {
        "description": "Withdraw a volume from being cached",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_volume": {
        "description": "Withdraw a volume from being cached",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kretprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_ACCESS_TRACE_READ, FSCACHE_ACCESS_TRACE_WRITE, FSCACHE_ACCESS_TRACE_TRUNCATE, FSCACHE_ACCESS_TRACE_OTHER]"
        }
    }
},
{
    "kprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_ACCESS_TRACE_READ, FSCACHE_ACCESS_TRACE_WRITE, FSCACHE_ACCESS_TRACE_TRUNCATE, FSCACHE_ACCESS_TRACE_OTHER]"
        }
    }
},
{
    "kretprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:__fscache_use_cookie": {
        "description": "__fscache_use_cookie function",
        "pre": {
            "cookie": "!=null",
            "will_modify": "bool"
        }
    }
},
{
    "kprobe:__fscache_use_cookie": {
        "description": "__fscache_use_cookie function",
        "pre": {
            "cookie": "!=null",
            "will_modify": "bool"
        }
    }
},
{
    "kretprobe:atomic_fetch_add_unless": {
        "description": "Atomically fetches the value at the address of cookie->n_active, adds -1 to it, and stores the result back. If the original value is not 1, the condition is satisfied.",
        "pre": {
            "cookie->n_active": "!=null",
            "cookie->n_active": "is_integer",
            "cookie->n_active": "!=1"
        }
    }
},
{
    "kprobe:atomic_fetch_add_unless": {
        "description": "Atomically fetches the value at the memory location specified by &cookie->n_active, adds -1 to it, and stores the result back to the same memory location, unless the original value was 1.",
        "pre": {
            "&cookie->n_active": "!=null",
            "-1": "!=null",
            "1": "!=null",
            "c": "!=null",
            "c": "!=1"
        }
    }
},
{
    "kretprobe:fscache_begin_lookup": {
        "description": "Begin the process of looking up a cookie. We offload the actual process to a worker thread.",
        "pre": {
            "cookie": "!=null",
            "cookie->volume": "!=null",
            "trace": "!=null"
        }
    }
},

{
    "kretprobe:fscache_init_access_gate": {
        "description": "Initializes the access gate on a cookie by setting a flag to prevent the state machine from being queued when the access counter transitions to 0.",
        "pre": {
            "cookie": "!=null",
            "where": "!=null"
        }
    }
},

{
    "kretprobe:__fscache_invalidate": {
        "description": "Invalidate a fscache cookie",
        "pre": {
            "cookie": "!=null",
            "aux_data": "!=null",
            "new_size": ">=0",
            "flags": "unsigned int",
            "FSCACHE_COOKIE_RELINQUISHED": "!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)",
            "FSCACHE_INVAL_DIO_WRITE": "!(flags & FSCACHE_INVAL_DIO_WRITE) || !test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags)",
            "FSCACHE_COOKIE_NO_DATA_TO_READ": "set_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags)",
            "cookie->inval_counter": "++",
            "cookie->state": "in [FSCACHE_COOKIE_STATE_INVALIDATING, FSCACHE_COOKIE_STATE_LOOKING_UP, FSCACHE_COOKIE_STATE_CREATING, FSCACHE_COOKIE_STATE_ACTIVE]",
            "is_caching": "fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie)",
            "__fscache_set_cookie_state": "if (is_caching) __fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING)",
            "wake_up_cookie_state": "wake_up_cookie_state(cookie)",
            "fscache_queue_cookie": "if (is_caching) fscache_queue_cookie(cookie, fscache_cookie_get_inval_work)"
        }
    }
},

{
    "kretprobe:fscache_wait_for_operation": {
        "description": "Wait for an object to become accessible",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_UNAVAILABLE, FSCACHE_WANT_AVAILABLE]"
        }
    }
},
{
    "kprobe:fscache_wait_for_operation": {
        "description": "Wait for an object to become accessible",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_UNAVAILABLE, FSCACHE_WANT_AVAILABLE, FSCACHE_WANT_COMPLETE]"
        }
    }
},
{
    "kretprobe:fscache_dirty_folio": {
        "description": "Mark folio dirty and pin a cache object for writeback",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:fscache_dirty_folio": {
        "description": "Mark folio dirty and pin a cache object for writeback",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:iov_iter_xarray": {
        "description": "Perform an operation on the iov_iter using the xarray.",
        "pre": {
            "iter": "!=null",
            "source": "ITER_SOURCE",
            "mapping->i_pages": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    },
    "kretprobe:fscache_write": {
        "description": "Write data to the fscache.",
        "pre": {
            "cres": "!=null",
            "start": "!=null",
            "&iter": "!=null",
            "fscache_wreq_done": "!=null",
            "wreq": "!=null"
        }
    },
    "kretprobe:abandon_end": {
        "description": "Handle the abandon end case.",
        "pre": {
            "wreq": "!=null",
            "ret": "!=null",
            "false": "!=null"
        }
    },
    "kretprobe:abandon_free": {
        "description": "Free resources in the abandon case.",
        "pre": {
            "wreq": "!=null"
        }
    },
    "kretprobe:abandon": {
        "description": "Handle the abandon case.",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "len": "!=null",
            "cond": "!=null"
        }
    },
    "kretprobe:if (term_func)term_func(term_func_priv, ret, false);}EXPORT_SYMBOL(__fscache_write_to_cache": {
        "description": "Call the term_func if it exists.",
        "pre": {
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "ret": "!=null",
            "false": "!=null"
        }
    }
},
{
    "kprobe:__fscache_write_to_cache": {
        "description": "Write data to the cache",
        "pre": {
            "cookie": "!=null",
            "mapping": "!=null",
            "start": ">=0",
            "len": ">=0",
            "i_size": ">=0",
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "cond": "boolean"
        }
    }
},


{
    "kretprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_add_cache": {
        "description": "Declare a cache as being open for business",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "!=null"
        }
    }
},
{
    "kprobe:fscache_add_cache": {
        "description": "Declare a cache as being open for business",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "!=null"
        }
    }
},
{
    "kretprobe:fscache_io_error": {
        "description": "Note a cache IO error",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_io_error": {
        "description": "Note a cache IO error",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_withdraw_cache": {
        "description": "Withdraw a cache from the active service",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_cache": {
        "description": "Withdraw a cache from the active service",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a bio",
        "pre": {
            "bio": "!=null",
            "bio->bi_size": ">0",
            "bio->bi_end_io": "!=null",
            "bio->bi_status": "not in [EIO, EAGAIN, EINTR]",
            "bio->bi_rw": "==READ",
            "bio->bi_io_vec": "!=null",
            "bio->bi_io_vec->bv_len": ">0",
            "bio->bi_io_vec->bv_page": "!=null",
            "bio->bi_io_vec->bv_page->mapping": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb->s_cop": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb->s_cop->s_cop_decrypt_bio": "!=null"
        },
        "post": {
            "return": "==true",
            "bio->bi_status": "==0"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a bio",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:bio_alloc": {
        "description": "Allocate a bio structure for I/O operations.",
        "pre": {
            "inode": "!=null",
            "inode->i_sb->s_bdev": "!=null",
            "BIO_MAX_VECS": "!=null",
            "REQ_OP_WRITE": "!=null",
            "GFP_NOFS": "!=null",
            "len": "!=null"
        }
    },
    "kretprobe:fscrypt_zeroout_range_inline_crypt": {
        "description": "Zero out a range of blocks for inline encryption.",
        "pre": {
            "inode": "!=null",
            "lblk": "!=null",
            "pblk": "!=null",
            "len": "!=null",
            "blockbits": "!=null",
            "blocks_per_page": "!=null",
            "bio": "!=null",
            "ret": "!=null",
            "err": "!=null",
            "num_pages": "!=null"
        }
    }
},

{
    "kretprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_free_inode": {
        "description": "Free an inode's fscrypt data requiring RCU delay",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_free_inode": {
        "description": "Free an inode's fscrypt data requiring RCU delay",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_ioctl_set_policy": {
        "description": "Set the policy for fscrypt using ioctl.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "policy.version": "!=null",
            "size": ">0",
            "inode": "!=null",
            "nop_mnt_idmap": "!=null",
            "ret": "!=null",
            "existing_policy": "!=null"
        },
        "post": {
            "ret": "in [-EFAULT, -EACCE -ENODATA]"
        }
    }
},
{
    "kprobe:fscrypt_ioctl_set_policy": {
        "description": "Set the policy for fscrypt ioctl.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "policy.version": "!=null",
            "size": ">0",
            "inode": "!=null",
            "ret": "!=null",
            "existing_policy": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_has_permitted_context": {
        "description": "Check if a file's encryption policy is permitted within its directory.",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_has_permitted_context": {
        "description": "Check if a file's encryption policy is permitted within its directory.",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        }
    }
},
{
    "kretprobe:fname_decrypt": {
        "description": "Decrypts the filename",
        "pre": {
            "inode": "!=null",
            "iname": "!=null",
            "oname": "!=null"
        },
        "post": {
            "return_value": "in [0, -errno]"
        }
    }
},

{
    "kretprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer for presented filenames",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer for presented filenames",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form",
        "pre": {
            "inode": "!=null",
            "hash": "optional",
            "minor_hash": "optional",
            "iname": "!=null",
            "oname": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form.",
        "pre": {
            "inode": "!=null",
            "hash": ">=0",
            "minor_hash": ">=0",
            "iname": "!=null",
            "oname": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        }
    }
},


{
    "kretprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0",
            "gfp_flags": "valid memory allocation flags"
        }
    }
},
{
    "kprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0",
            "gfp_flags": "valid memory allocation flags"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio",
        "pre": {
            "folio": "!=null",
            "len": "!=null",
            "offs": "!=null",
            "len": "multiple of filesystem's block size",
            "offs": "multiple of filesystem's block size"
        },
        "post": {
            "return value": "0 on success; -errno on failure"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio",
        "pre": {
            "folio": "!=null",
            "len": "!=null",
            "offs": "!=null",
            "len": "% filesystem_block_size == 0",
            "offs": "% filesystem_block_size == 0"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0"
        }
    }
},


{
    "kretprobe:o2quo_disk_timeout": {
        "description": "Post condition for o2quo_disk_timeout()",
        "post": {
            "return_value": "(failed << 1) < quorum"
        }
    }
},
{
    "kprobe:o2hb_arm_timeout": {
        "description": "Arm the timeout for the o2hb region.",
        "pre": {
            "failed": "<< 1 < quorum",
            "quorum": "!= null"
        }
    }
},




{
    "kretprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        }
    }
},
{
    "kretprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        }
    }
},
{
    "kprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group.",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        }
    }
},
{
    "kretprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:config_item_set_name": {
        "description": "Set the name of an item",
        "pre": {
            "item": "!=null",
            "fmt": "!=null",
            "name": "!=null",
            "strlen(name)": "< CONFIGFS_ITEM_NAME_LEN",
            "item->ci_name": "points to dynamically allocated string if strlen(name) >= CONFIGFS_ITEM_NAME_LEN",
            "item->ci_namebuf": "points to static array if strlen(name) < CONFIGFS_ITEM_NAME_LEN"
        }
    }
},
{
    "kprobe:config_item_set_name": {
        "description": "Set the name of an item.",
        "pre": {
            "item": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:config_item_put": {
        "description": "Decrement the refcount, and if 0, call config_item_cleanup().",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kprobe:config_item_put": {
        "description": "Decrement refcount for item and call config_item_cleanup if 0.",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kretprobe:config_group_find_item": {
        "description": "Search for an item in a group.",
        "pre": {
            "group": "!=null",
            "name": "!=null",
            "group->cg_list": "!=null",
            "group->cg_subsys->su_mtx": "locked"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:config_group_find_item": {
        "description": "Search for an item in a group.",
        "pre": {
            "group": "!=null",
            "name": "!=null",
            "group->cg_list": "!=null",
            "group->cg_subsys->su_mtx": "locked"
        }
    }
},
{
    "kretprobe:netfs_readahead": {
        "description": "Helper to manage a read request",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kprobe:netfs_readahead": {
        "description": "Helper to manage a read request",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kretprobe:netfs_read_folio": {
        "description": "Helper to manage a read_folio request",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:netfs_read_folio": {
        "description": "Helper to manage a read_folio request",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:netfs_write_begin": {
        "description": "Helper to prepare for writing",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},
{
    "kprobe:netfs_write_begin": {
        "description": "Helper to prepare for writing",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},


{
    "kretprobe:jbd2_journal_start": {
        "description": "Return a pointer to a newly allocated handle, or an ERR_PTR() value on failure.",
        "pre": {
            "journal": "!=null",
            "nblocks": ">=0"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_start": {
        "description": "Start a journal transaction in the jbd2 filesystem journaling layer.",
        "pre": {
            "journal": "!=null",
            "nblocks": ">=0"
        }
    }
},
{
    "kretprobe:jbd2_journal_free_reserved": {
        "description": "Free the reserved handle in the jbd2 journal.",
        "pre": {
            "handle": {
                "type": "handle_t"
            },
            "journal": {
                "type": "journal_t",
                "value": "handle->h_journal"
            },
            "journal->j_state_lock": "locked with read_lock()",
            "journal->j_running_transaction": "exists and pinned by acquiring j_state_lock",
            "journal->j_state_lock": "unlocked with read_unlock()",
            "handle": "freed with jbd2_free_handle()"
        }
    }
},
{
    "kprobe:jbd2_journal_free_reserved": {
        "description": "Free the reserved journal handle.",
        "pre": {
            "handle": "!=null",
            "handle->h_journal": "!=null",
            "handle->h_journal->j_state_lock": "locked",
            "handle->h_journal->j_running_transaction": "exists"
        }
    }
},
{
    "kretprobe:jbd2__journal_restart": {
        "description": "Commit the handle's transaction and reattach to a new transaction with requested number of credits.",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:jbd2__journal_restart": {
        "description": "Commit the handle's transaction and reattach it to a new transaction with the requested number of credits.",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:jbd2_trans_will_send_data_barrier": {
        "description": "Check if the transaction will send a data barrier.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "ret": "==0",
            "commit_trans": "!=null",
            "journal->j_flags": "& JBD2_BARRIER",
            "journal->j_state_lock": "read_locked"
        }
    }
},
{
    "kprobe:jbd2_trans_will_send_data_barrier": {
        "description": "Check if the transaction will send a data barrier in the journal.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "journal->j_flags": "& JBD2_BARRIER != 0",
            "commit_trans": "!=null",
            "commit_trans->t_tid": "== tid"
        }
    }
},
{
    "kretprobe:jbd2_fc_begin_commit": {
        "description": "Begin a fast commit in the journal.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "is_journal_aborted(journal)": "==false",
            "j_commit_sequence": "<= tid",
            "j_stats.ts_tid": "==0"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},

{
    "kretprobe:jbd2_transaction_committed": {
        "description": "Check if a transaction with the given tid has already committed.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kprobe:jbd2_transaction_committed": {
        "description": "Check if the transaction with the given tid has already been committed.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null"
        }
    }
},




{
    "kretprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal.",
        "pre": {
            "journal": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal.",
        "pre": {
            "journal": "!=null"
        }
    }
},
{
    "kretprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock",
        "pre": {
            "journal": "!=null",
            "compat": "!=null",
            "ro": "!=null",
            "incompat": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock",
        "pre": {
            "journal": "!=null",
            "compat": "!=null",
            "ro": "!=null",
            "incompat": "!=null"
        }
    }
},

{
    "kprobe:/* * Give a buffer_head a journal_head. * * May sleep. */": {
        "description": "Attach a journal_head to a buffer_head and manage references.",
        "pre": {
            "bh": "!=null",
            "jh": "!=null",
            "b_jcount": ">=0",
            "b_transaction": "!=null"
        },
        "post": {
            "bh": "!=null",
            "jh": "!=null",
            "b_jcount": ">=0",
            "b_transaction": "!=null"
        }
    }
},
{
    "kretprobe:proc_symlink": {
        "description": "Create a symbolic link in the proc file system.",
        "pre": {
            "parent": "!=null",
            "name": "!=null",
            "mode": "!=null",
            "nlink": "!=null"
        }
    }
},
{
    "kprobe:proc_symlink": {
        "description": "Create a symbolic link in the proc filesystem.",
        "pre": {
            "parent": "!=null",
            "name": "!=null",
            "mode": "!=null",
            "nlink": "!=null"
        }
    }
},
{
    "kretprobe:__xlate_proc_name": {
        "description": "This function parses a name such as 'ttydriverserial', and returns the struct proc_dir_entry for 'procttydriver', and returns 'serial' in residual.",
        "pre": {
            "name": "!=null",
            "ret": "!=null",
            "residual": "!=null"
        }
    }
},
{
    "kprobe:__xlate_proc_name": {
        "description": "Translate a name to a proc_dir_entry and residual name.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:register_sysctl": {
        "description": "Register a sysctl table.",
        "pre": {
            "path": "!=null",
            "table": "!=null",
            "table_is_filled": "true",
            "table_termination": "true"
        }
    }
},
{
    "kprobe:register_sysctl": {
        "description": "Register a sysctl table.",
        "pre": {
            "path": "!=null",
            "table": "!=null"
        }
    }
},
{
    "kretprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kretprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem",
        "pre": {
            "name": "!=null",
            "parent": "!=null",
            "parent_type": "==dentry",
            "f": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem",
        "pre": {
            "name": "!=null",
            "parent": "is_directory(parent) || parent == null",
            "f": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:continue;}if (inlen <= 0)break;v = get_utf16(*pwc endian);if ((v & SURROGATE_MASK) != SURROGATE_PAIR ||!(v & SURROGATE_LOW))": {
        "description": "Helper function to convert UTF-16 characters to UTF-8 characters.",
        "pre": {
            "pwcs": "!=null",
            "inlen": "<= 0",
            "endian": "in [utf16_endian]",
            "s": "!=null",
            "maxout": "!=null"
        }
    }
},
{
    "kprobe:continue;}if (inlen <= 0)break;v = get_utf16(*pwc endian);if ((v & SURROGATE_MASK) != SURROGATE_PAIR ||!(v & SURROGATE_LOW))": {
        "description": "Helper function to convert UTF-16 characters to UTF-8 characters.",
        "pre": {
            "pwcs": "!=null",
            "inlen": "<= 0",
            "endian": "in [utf16_endian]",
            "s": "!=null",
            "maxout": "!=null"
        }
    }
},


{
    "kretprobe:qid_eq": {
        "description": "Test to see if two kqid values are the same.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kprobe:qid_eq": {
        "description": "Test to see if two kqid values are the same.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kretprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kretprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kretprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kretprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid.",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid.",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kretprobe:if (!dquot->dq_off)": {
        "description": "Check if the value of dq_off is zero.",
        "pre": {
            "dquot": {
                "dq_off": "==0"
            }
        }
    }
},
{
    "kprobe:if (!dquot->dq_off)": {
        "description": "Condition for the if statement: if (!dquot->dq_off)",
        "pre": {
            "dquot": {
                "dq_off": "==0"
            }
        }
    }
},
{
    "kretprobe:qtree_delete_dquot": {
        "description": "Delete a dquot from the qtree.",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "tmp": "not in [QT_TREEOFF]",
            "dquot->dq_off": "==0"
        }
    }
},
{
    "kprobe:return 0;return remove_tree(info, dquot, &tmp, 0);}EXPORT_SYMBOL(qtree_delete_dquot": {
        "description": "Delete a dquot from the qtree.",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "dquot->dq_off": "==0"
        }
    }
},
{
    "kretprobe:if (!sb_dqopt(dquot->dq_sb)->files[type])": {
        "description": "Check if the files array at index 'type' is null",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_sb": "!=null",
            "sb_dqopt(dquot->dq_sb)": "!=null",
            "sb_dqopt(dquot->dq_sb)->files[type]": "==null"
        }
    }
},
{
    "if (!sb_dqopt(dquot->dq_sb)->files[type])": {
        "description": "Check if a specific file type is present in the files array of the sb_dqopt structure.",
        "pre": {
            "dquot": "!= null",
            "dquot->dq_sb": "!= null",
            "sb_dqopt(dquot->dq_sb)->files[type]": "== null"
        }
    }
},
{
    "kretprobe:DEFINE_SPINLOCK": {
        "description": "Defines a spinlock for protecting the specified resource.",
        "pre": {
            "spinlock_name": "dq_data_lock",
            "ordering": "dq_data_lock > dq_list_lock > i_lock > dquot->dq_dqb_lock",
            "flags": "S_NOQUOTA is not set"
        }
    },
    "kretprobe:EXPORT_SYMBOL": {
        "description": "Exports the specified symbol.",
        "pre": {
            "symbol_name": "dq_data_lock"
        }
    }
},

{
    "kretprobe:static LIST_HEAD(inuse_list);static LIST_HEAD(free_dquots);static unsigned int dq_hash_bit dq_hash_mask;static struct hlist_head *dquot_hash;struct dqstats dqstats;EXPORT_SYMBOL(dqstats)": {
        "description": "dqstats.free_dquots gives the number of dquots on the list. When dquot is invalidated it's completely released from memory. Dirty dquots are added to the dqi_dirty_list of quota_info when mark dirtied, and this list is searched when writing dirty dquots back to quota file. Note that some filesystems do dirty dquot tracking on their own (e.g. in a journal) and thus don't use dqi_dirty_list. Dquots with a specific identity (device, type and id) are placed on one of the dquot_hash[] hash chains. The provides an efficient search mechanism to locate a specific dquot.",
        "pre": {
            "dqstats.free_dquots": "!=null",
            "dquot": "invalidated => released from memory",
            "dquots": "dirty => added to dqi_dirty_list of quota_info",
            "dquots": "dirty => searched when writing dirty dquots back to quota file",
            "filesystems": "do dirty dquot tracking on their own (e.g. in a journal) => don't use dqi_dirty_list",
            "dquots": "specific identity (device, type, id) => placed on dquot_hash[] hash chains"
        }
    }
},
{
    "kprobe:static LIST_HEAD(inuse_list);static LIST_HEAD(free_dquots);static unsigned int dq_hash_bit dq_hash_mask;static struct hlist_head *dquot_hash;struct dqstats dqstats;EXPORT_SYMBOL(dqstats)": {
        "description": "dqstats.free_dquots gives the number of dquots on the list. When dquot is invalidated it's completely released from memory. Dirty dquots are added to the dqi_dirty_list of quota_info when mark dirtied, and this list is searched when writing dirty dquots back to quota file. Note that some filesystems do dirty dquot tracking on their own (e.g. in a journal) and thus don't use dqi_dirty_list. Dquots with a specific identity (device, type and id) are placed on one of the dquot_hash[] hash chains. The provides an efficient search mechanism to locate a specific dquot.",
        "pre": {
            "inuse_list": "!=null",
            "free_dquots": "!=null",
            "dq_hash_bits": "!=null",
            "dq_hash_mask": "!=null",
            "dquot_hash": "!=null",
            "dqstats": "!=null"
        }
    }
},
{
    "kretprobe:dquot_mark_dquot_dirty": {
        "description": "Mark the dquot as dirty.",
        "pre": {
            "dquot": "!=null",
            "ret": "==1",
            "DQ_ACTIVE_B": "is set in dquot->dq_flags",
            "DQUOT_NOLIST_DIRTY": "is not set in sb_dqopt(dquot->dq_sb)->flags"
        },
        "post": {
            "DQ_MOD_B": "is set in dquot->dq_flags"
        }
    }
},
{
    "kprobe:if (test_bit(DQ_MOD_B, &dquot->dq_flags))return 1;spin_lock(&dq_list_lock);if (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags))": {
        "description": "Check if the DQ_MOD_B bit is set in the dq_flags of the dquot structure. If it is set, return 1. Otherwise, acquire the dq_list_lock spin lock and set the DQ_MOD_B bit in the dq_flags.",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_flags": "!=null",
            "test_bit(DQ_MOD_B, &dquot->dq_flags)": "==1",
            "!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)": "==1"
        }
    }
},
{
    "kretprobe:smp_mb__before_atomic": {
        "description": "Ensure that flags update is visible after dquot has been filled.",
        "pre": {
            "dquot": "!=null",
            "dq_flags": "!=null",
            "DQ_READ_B": "in [0, 1]"
        }
    },
    "kretprobe:set_bit": {
        "description": "Instantiate dquot if needed.",
        "pre": {
            "DQ_READ_B": "in [0, 1]",
            "dquot": "!=null",
            "&dquot->dq_flags": "!=null"
        }
    }
},
{
    "kprobe:smp_mb__before_atomic": {
        "description": "Ensure memory ordering before setting the bit DQ_READ_B in the dq_flags of the dquot structure.",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_flags": "!=null",
            "DQ_READ_B": "!=null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the specified bit in the given memory location.",
        "pre": {
            "bit": "!=null",
            "memory_location": "!=null"
        }
    }
},
{
    "kretprobe:dquot_commit": {
        "description": "Commit the dquot structure",
        "pre": {
            "dquot": "!=null",
            "ret": "int",
            "memalloc": "unsigned int",
            "dqopt": "struct quota_info",
            "dqopt->dq_sb": "!=null",
            "dquot->dq_lock": "mutex",
            "memalloc_nofs_save": "function",
            "clear_dquot_dirty": "function"
        },
        "post": {
            "ret": "int",
            "memalloc": "unsigned int",
            "dqopt": "struct quota_info",
            "dqopt->dq_sb": "!=null",
            "dquot->dq_lock": "mutex",
            "memalloc_nofs_save": "function",
            "clear_dquot_dirty": "function"
        }
    }
},



{
    "kretprobe:dquot_scan_active": {
        "description": "Scan active dquot and increase use count",
        "pre": {
            "sb": "!=null",
            "fn": "!=null",
            "priv": "!=null",
            "dquot": "!=null",
            "old_dquot": "!=null",
            "ret": "0",
            "sb->s_umount": "locked",
            "dq_list_lock": "locked",
            "dquot->dq_flags": "has DQ_ACTIVE_B bit set",
            "dquot->dq_sb": "same as sb"
        },
        "post": {
            "old_dquot": "updated to dquot"
        }
    }
},
{
    "kprobe:atomic_inc(&dquot->dq_count);spin_unlock(&dq_list_lock);dqput(old_dquot);old_dquot = dquot;/* * ->release_dquot() can be racing with us. Our reference * protects us from new calls to it so just wait for any * outstanding call and recheck the DQ_ACTIVE_B after that. `": {
        "description": "Increase the use count of dquot and release dq_list_lock.",
        "pre": {
            "dquot": "!=null",
            "dq_count": "!=null",
            "dq_list_lock": "!=null",
            "old_dquot": "!=null",
            "dq_flags": "has bit DQ_ACTIVE_B set",
            "dq_sb": "== sb"
        }
    }
},

{
    "kprobe:list_replace_init": {
        "description": "Replace the list `dqopt->info[cnt].dqi_dirty_list` with the list `dirty`.",
        "pre": {
            "dqopt->info[cnt].dqi_dirty_list": "!=null",
            "dirty": "!=null"
        }
    },
    "kprobe:list_empty": {
        "description": "Check if the list `dirty` is empty.",
        "pre": {
            "dirty": "!=null",
            "!list_empty(&dirty)": "true"
        }
    }
},
{
    "kretprobe:if (sb->s_op->sync_fs)": {
        "description": "Check if the `sync_fs` function pointer is not null.",
        "pre": {
            "sb": "!=null",
            "sb->s_op": "!=null",
            "sb->s_op->sync_fs": "!=null"
        }
    }
},
{
    "kprobe:if (sb->s_op->sync_fs)": {
        "description": "Check if the `sync_fs` function is called for the given `sb`.",
        "pre": {
            "sb": "!=null",
            "sb->s_op": "!=null",
            "sb->s_op->sync_fs": "!=null"
        }
    }
},


{
    "kretprobe:insert_dquot_hash": {
        "description": "Insert a dquot into the hash table.",
        "pre": {
            "dquot": "!=null"
        }
    }
},
{
    "kprobe:insert_dquot_hash": {
        "description": "Insert a dquot into the hash table.",
        "pre": {
            "dquot": "!=null"
        }
    }
},
{
    "kretprobe:dquot_drop": {
        "description": "Drop the dquot structures associated with the given inode.",
        "pre": {
            "inode": "!=null",
            "dquots": "!=null",
            "cnt": ">=0",
            "cnt": "<MAXQUOTAS"
        }
    }
},
{
    "kprobe:dquot_drop": {
        "description": "Drop the dquot associated with the inode.",
        "pre": {
            "inode": "!=null",
            "dquots": "!=null",
            "cnt": ">=0",
            "cnt": "<MAXQUOTAS",
            "put": "!=null",
            "dq_data_lock": "locked",
            "IS_NOQUOTA(inode)": "false"
        }
    }
},
{
    "kretprobe:for (cnt--; cnt >= 0; cnt--)": {
        "description": "Decrement cnt and loop while cnt is greater than or equal to 0.",
        "pre": {
            "cnt": ">= 0"
        }
    }
},
{
    "kprobe:__dquot_alloc_space": {
        "description": "Allocate space for dquot",
        "pre": {
            "inode": "!=null",
            "number": "!=null",
            "flags": "in [DQUOT_SPACE_RESERVE, <other values>]"
        }
    }
},

{
    "kprobe:dquot_alloc_inode": {
        "description": "Allocate a dquot for an inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Loop over the quotas for each cnt from 0 to MAXQUOTAS.",
        "pre": {
            "cnt": ">= 0",
            "cnt": "< MAXQUOTAS"
        }
    }
},
{
    "for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Iterate over cnt from 0 to MAXQUOTAS",
        "pre": {
            "inode": "!= null",
            "transfer_to": "!= null"
        }
    }
},

{
    "kprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);/* Cannot turn off usage accounting without turning off limit or * suspend quotas and simultaneously turn quotas off. */": {
        "description": "Disable quotas for a specific type in the given super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "flags": "unsigned int",
            "dqopt": "struct quota_info",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kretprobe:dquot_load_quota_sb": {
        "description": "Check if flags & DQUOT_SUSPENDED is true",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "flags": "& DQUOT_SUSPENDED != 0"
        }
    }
},
{
    "kprobe:BUG_ON(flags & DQUOT_SUSPENDED)": {
        "description": "Check if the DQUOT_SUSPENDED flag is set in the flags variable.",
        "pre": {
            "flags": "& DQUOT_SUSPENDED == DQUOT_SUSPENDED"
        }
    }
},
{
    "kretprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Resume dquot operations for a specific type on a super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "dqopt": "!=null",
            "ret": "int",
            "cnt": "int",
            "flags": "unsigned int",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Resume dquot operations for a specific type on a super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "dqopt": "!=null",
            "ret": "int",
            "cnt": "int",
            "flags": "unsigned int",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kretprobe:dquot_quota_on": {
        "description": "Enable quota on a filesystem.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "path": "!=null",
            "path->dentry": "!=null",
            "path->dentry->d_sb": "!=sb",
            "error": "int"
        },
        "post": {
            "error": "int"
        }
    }
},
{
    "kprobe:dquot_quota_on": {
        "description": "Enable quota on a filesystem.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "path": "!=null"
        }
    }
},


{
    "kretprobe:dquot_set_dqinfo": {
        "description": "Set quota information for a given super block and type.",
        "pre": {
            "ii->i_fieldmask & QC_WARNS_MASK": "!= true",
            "ii->i_fieldmask & QC_RT_SPC_TIMER": "!= true",
            "sb_has_quota_active(sb, type)": "== true",
            "ii->i_fieldmask & QC_FLAGS": "== true",
            "ii->i_flags & QCI_ROOT_SQUASH && mi->dqi_format->qf_fmt_id != QFMT_VFS_OLD": "!= true",
            "ii->i_fieldmask & QC_SPC_TIMER": "== true",
            "ii->i_fieldmask & QC_INO_TIMER": "== true",
            "ii->i_fieldmask & QC_FLAGS": "== true",
            "ii->i_flags & QCI_ROOT_SQUASH": "== true",
            "mi->dqi_flags": "|= DQF_ROOT_SQUASH",
            "mi->dqi_flags": "&= ~DQF_ROOT_SQUASH"
        },
        "post": {
            "unlock(dq_data_lock)": "true",
            "mark_info_dirty(sb, type)": "true"
        }
    }
},
{
    "kprobe:return_sb_dq_op_write_info": {
        "description": "Write quota information to disk for a given super block and type.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "ii": {
                "i_fieldmask": "int",
                "i_flags": "int",
                "i_spc_timelimit": "int",
                "i_ino_timelimit": "int"
            },
            "sb_has_quota_active(sb, type)": "true",
            "mi": {
                "dqi_format": {
                    "qf_fmt_id": "int"
                }
            }
        }
    }
},
{
    "kretprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kretprobe:crypto_kdf108_setkey": {
        "description": "Check according to SP800-108 section 7.2",
        "pre": {
            "ikm": "!=null",
            "ikmlen": "!=null"
        }
    }
},
{
    "kprobe:crypto_kdf108_setkey": {
        "description": "Check according to SP800-108 section 7.2",
        "pre": {
            "ikm": "!=null",
            "ikmlen": "!=null"
        }
    }
},
{
    "kretprobe:ecc_is_key_valid": {
        "description": "Check if the private key is valid for the given ECC curve.",
        "pre": {
            "curve": "!=null",
            "private_key": "!=null",
            "ndigits": "!=null",
            "private_key": "in [2, curve->n-3]",
            "curve->g.ndigits": "== ndigits"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:ecc_is_key_valid": {
        "description": "Check if the private key is valid for the given ECC curve.",
        "pre": {
            "curve": {
                "g": {
                    "ndigits": "==ndigits"
                }
            },
            "private_key": "!=null",
            "ndigits": "!=null",
            "private_key_range": "[2, n-3]"
        }
    }
},
{
    "kretprobe:if (nbits < 160 || ndigits > ARRAY_SIZE(priv))return -EINVAL;/* * FIPS 186-4 recommends that the private key should be obtained from a * RBG with a security strength equal to or greater than the security * strength associated with N. * * The maximum security strength identified by NIST SP800-57pt1r4 for * ECC is 256 (N >= 512). * * This condition is met by the default RNG because it selects a favored * DRBG with a security strength of 256. */": {
        "description": "Check if the private key generation conditions are met.",
        "pre": {
            "nbits": "< 160 || ndigits > ARRAY_SIZE(priv)"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the private key meets the security strength requirements.",
        "pre": {
            "nbits": "< 160 || ndigits > ARRAY_SIZE(priv)",
            "return": "-EINVAL"
        }
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_full": {
        "description": "Check if the public key is valid for the given curve.",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kprobe:ecc_is_pubkey_valid_full": {
        "description": "Check if the given public key is valid for the specified curve.",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kretprobe:if (ecc_point_is_zero(pk))return -EINVAL;/* Check 2: Verify key is in the range [1, p-1]. */": {
        "description": "Check if the given ECC point is zero. If it i return -EINVAL.",
        "pre": {
            "pk": "!=null",
            "pk->ndigits": "==curve->g.ndigits"
        }
    }
},
{
    "kprobe:ecc_point_is_zero": {
        "description": "Check if the given ECC point is zero.",
        "pre": {
            "pk": "!=null"
        }
    },
    "kprobe:ecc_is_pubkey_valid_partial": {
        "description": "Check if the given ECC public key is valid (partial check).",
        "pre": {
            "curve": "!=null",
            "pk": "!=null",
            "pk->ndigits": "==curve->g.ndigits"
        }
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_partial": {
        "description": "Partial verification: ephemeral keys only",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        },
        "post": {
            "ret": "== -EAGAIN",
            "pk->x": "== public_key[ndigits]",
            "pk->y": "== &public_key[ndigits]"
        }
    }
},
{
    "ecc_is_pubkey_valid_partial": {
        "description": "Partial verification: ephemeral keys only",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kretprobe:dma_pool_create": {
        "description": "Create a DMA allocation pool with the requested characteristics.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": ">0",
            "boundary": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:dma_pool_create": {
        "description": "Create a DMA allocation pool with the requested characteristics.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "boundary": ">=0"
        }
    }
},


{
    "kretprobe:dma_pool_free": {
        "description": "Put block back into dma pool",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:dma_pool_free": {
        "description": "Put block back into dma pool",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "allocation": ">=0"
        }
    }
},
{
    "kprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "allocation": ">=0"
        }
    }
},
{
    "kretprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy().",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy().",
        "pre": {
            "pool": "!=null"
        }
    }
},


{
    "kretprobe:movable_zone": {
        "description": "The 'movable_zone' function returns the 'real' zone pages taken from ZONE_MOVABLE.",
        "pre": {
            "movable_zone": "!=null"
        }
    }
},
{
    "kprobe:movable_zone": {
        "description": "The 'movable_zone' function represents the 'real' zone from which pages in ZONE_MOVABLE are taken.",
        "pre": {
            "movable_zone": "!=null"
        }
    }
},
{
    "kretprobe:__alloc_pages_may_oom": {
        "description": "Allocate pages and handle out-of-memory (OOM) situations.",
        "pre": {
            "page": "==null",
            "gfp_mask": "!=null",
            "order": "!=null",
            "alloc_flags": "!=null",
            "ac": "!=null"
        }
    }
},
{
    "kprobe:__alloc_pages_cpuset_fallback": {
        "description": "Allocate pages with cpuset fallback",
        "pre": {
            "gfp_mask": "!=null",
            "order": "!=null",
            "alloc_flags": "!=null",
            "ac": "!=null"
        },
        "post": {
            "page": "!=null"
        }
    }
},


{
    "kretprobe:free_pages": {
        "description": "Free the allocated pages.",
        "pre": {
            "pages": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:free_pages": {
        "description": "Free the allocated pages.",
        "pre": {
            "pages": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:size = nc->size": {
        "description": "Assign the value of nc->size to size.",
        "pre": {
            "nc": "!=null",
            "nc->size": "!=null"
        }
    }
},
{
    "kprobe:size = nc->size;#endif/* Even if we own the page, we do not use atomic_set(). * This would break get_page_unless_zero() users. */": {
        "description": "Helper function for allocating page fragments with alignment.",
        "pre": {
            "nc": "!=null"
        }
    }
},
{
    "kretprobe:alloc_pages_exact": {
        "description": "Allocate pages of exact size",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:alloc_pages_exact": {
        "description": "Allocate exact pages with specified size and flags.",
        "pre": {
            "size": ">0",
            "gfp_mask": ">=0"
        },
        "post": {
            "return": "!=NULL"
        }
    }
},


{
    "kretprobe:high_memory": {
        "description": "Defines the upper bound on direct map memory, then end of ZONE_NORMAL.",
        "pre": {
            "max_low_pfn": "== highstart_pfn",
            "ZONE_NORMAL": "!= null",
            "ZONE_HIGHMEM": "!= null",
            "gap_between_zones": "== 0"
        }
    }
},
{
    "kprobe:void *high_memory;EXPORT_SYMBOL(high_memory)": {
        "description": "Defines the upper bound on direct map memory, then end of ZONE_NORMAL.",
        "pre": {
            "max_low_pfn": "== highstart_pfn",
            "ZONE_NORMAL": "!= null",
            "ZONE_HIGHMEM": "!= null",
            "gap_between_zones": "== 0"
        }
    }
},
{
    "kretprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pages": "!=null",
            "num": "!=null"
        }
    }
},
{
    "kprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pages": "!=null",
            "num": "!=null"
        }
    }
},
{
    "kretprobe:__vm_map_pages": {
        "description": "Maps a range of kernel pages into a user vma.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:__vm_map_pages": {
        "description": "Maps a range of kernel pages into a user vma.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starting with zero offset.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starts with zero offset",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pfn": "!=null",
            "pgprot": "!=null"
        }
    }
},
{
    "kprobe:vm_fault_t vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:vm_normal_page": {
        "description": "This function returns the struct page corresponding to the given virtual address in the specified vm_area_struct.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pte": "!=null",
            "vma->vm_flags": "not in [VM_PFNMAP, VM_MIXEDMAP]",
            "vma->vm_pgoff + ((addr - vma->vm_start) >> PAGE_SHIFT)": "== pfn_of_page"
        }
    }
},
{
    "kprobe:vm_normal_page": {
        "description": "This function returns a struct page pointer for the given virtual memory area (vma), address (addr), and page table entry (pte).",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pte": "!=null"
        }
    }
},
{
    "kretprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "VIRTUAL_BUG_ON": {
        "description": "Check if vmalloc_addr is a valid virtual address for vmalloc or module space",
        "pre": {
            "vmalloc_addr": "is_vmalloc_or_module_addr(vmalloc_addr)"
        }
    }
},
{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Check if the given address is a valid vmalloc or module address.",
        "pre": {
            "is_vmalloc_or_module_addr(vmalloc_addr)": "!= false",
            "pgd_none(*pgd)": "!= true",
            "WARN_ON_ONCE(pgd_leaf(*pgd))": "!= true"
        }
    }
},
{
    "kretprobe:addr_to_vb_xa": {
        "description": "Helper function for vm_unmap_ram",
        "pre": {
            "addr": "!=null",
            "addr_zone": "in [CPU0, CPU1, CPU2]",
            "vmap_blocks_access": {
                "CPU0": "CPU0INDEX0 -> vmap_blocks -> xa_lock",
                "CPU1": "CPU1INDEX1 -> vmap_blocks -> xa_lock",
                "CPU2": "CPU2INDEX2 -> vmap_blocks -> xa_lock"
            },
            "xa_lock_contention": "exists"
        }
    }
},
{
    "kprobe:addr_to_vb_xa": {
        "description": "Converts an address to a virtual block xarray.",
        "pre": {
            "addr": "!=null",
            "addr": "belongs to CPU0 zone when CPU == 0",
            "addr": "belongs to CPU1 zone when CPU == 1",
            "addr": "belongs to CPU2 zone when CPU == 2",
            "addr": "not in [6, 11, 20] when CPU != 0, 1, 2"
        }
    }
},




{
    "kretprobe:__get_vm_area_caller": {
        "description": "This condition represents the post condition for the __get_vm_area_caller function.",
        "pre": {
            "flags": "not in [VM_ALLOC]",
            "area.addr": "!=null",
            "requested_size": "!=null",
            "KASAN_VMALLOC_PROT_NORMAL": "!=null"
        }
    }
},
{
    "kprobe:__get_vm_area_caller": {
        "description": "Allocate a virtual memory area.",
        "pre": {
            "flags": "!(flags & VM_ALLOC)"
        }
    }
},
{
    "kretprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill.",
        "pre": {
            "size": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill.",
        "pre": {
            "size": ">0",
            "node": ">=0"
        }
    }
},
{
    "kretprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable)",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable)",
        "pre": {
            "size": "!=null"
        }
    }
},


{
    "kretprobe:remap_vmalloc_range_partial": {
        "description": "Map vmalloc pages to userspace",
        "pre": {
            "vma": "!=null",
            "uaddr": "!=null",
            "kaddr": "!=null",
            "pgoff": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:remap_vmalloc_range_partial": {
        "description": "Map vmalloc pages to userspace",
        "pre": {
            "vma": "!=null",
            "uaddr": "!=null",
            "kaddr": "!=null",
            "pgoff": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, -Exxx]"
        }
    }
},




{
    "kretprobe:vm_brk_flags": {
        "description": "The vm_brk_flags function is used to handle memory allocation and deallocation with specific flags.",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "mm": "!=null",
            "vma": "null",
            "len": "PAGE_ALIGN(request)",
            "ret": "not in [EINVAL, ENOMEM, EINTR]",
            "populate": "((mm->def_flags & VM_LOCKED) != 0)"
        },
        "post": {
            "ret": "ret",
            "mm": "mm",
            "vma": "vma",
            "uf": "uf",
            "populate": "populate"
        }
    }
},
{
    "kprobe:vm_brk_flags": {
        "description": "Function to handle brk flags in the virtual memory area.",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "ret": "in [0, -EINVAL, -ENOMEM, -EINTR]"
        }
    }
},
{
    "kretprobe:vm_brk_flags": {
        "description": "Function to handle vm_brk_flags",
        "pre": {
            "flags": "& (~VM_EXEC) != 0",
            "ret": "check_brk_limits(addr, len) == 0",
            "ret": "do_vmi_munmap(&vmi, mm, addr, len, &uf, 0) == 0",
            "vma": "vma_prev(&vmi) != NULL",
            "ret": "do_brk_flags(&vmi, vma, addr, len, flags) == 0",
            "populate": "(mm->def_flags & VM_LOCKED) != 0",
            "ret": "mm_populate(addr, len) == 0"
        },
        "post": {
            "ret": "ret"
        }
    }
},
{
    "kprobe:vm_brk_flags": {
        "description": "Function to handle vm_brk_flags",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "mm": "!=null",
            "vma": "null",
            "len": "PAGE_ALIGN(request)",
            "ret": "int",
            "populate": "((mm->def_flags & VM_LOCKED) != 0)"
        }
    }
},
{
    "kretprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete.",
        "pre": {
            "none": "none"
        }
    }
},


{
    "kretprobe:VM_BUG_ON": {
        "description": "Check if migrate is not null.",
        "pre": {
            "migrate": "!=null"
        }
    },
    "kretprobe:addr = migrate->start + i*PAGE_SIZE": {
        "description": "Calculate the address based on migrate->start and i.",
        "pre": {
            "migrate": "!=null",
            "i": ">=0"
        }
    },
    "kretprobe:if (!notified)": {
        "description": "Check if notified is false.",
        "pre": {
            "notified": "==false"
        }
    }
},
{
    "VM_BUG_ON(!migrate); addr = migrate->start + i*PAGE_SIZE; if (!notified)": {
        "description": "Perform a VM bug check and calculate the address based on migrate->start and i*PAGE_SIZE if notified is false.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null",
            "migrate": "!=null"
        }
    }
},
{
    "kretprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kretprobe:migrate_device_pages": {
        "description": "Migrate struct page meta-data from source struct page to destination.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kprobe:migrate_device_pages": {
        "description": "Migrate struct page meta-data from source struct page to destination.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kretprobe:balance_dirty_pages_ratelimited": {
        "description": "Checks if writeback or throttling needs to be forced.",
        "pre": {
            "ratelimit_pages": "==32"
        }
    }
},

{
    "kretprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag.",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag.",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kretprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},



{
    "kprobe:folio_account_redirty": {
        "description": "De-account the dirty counters when redirtying a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},

{
    "kprobe:WARN_ON_ONCE": {
        "description": "Check if 'warn' is true and 'folio' is not up-to-date.",
        "pre": {
            "warn": "==true",
            "folio_test_uptodate(folio)": "==false"
        }
    },
    "kprobe:folio_account_dirtied": {
        "description": "Account for dirtying the 'folio' in the 'mapping'.",
        "pre": {
            "folio": "!=null",
            "mapping": "!=null"
        }
    },
    "kprobe:__xa_set_mark": {
        "description": "Set the 'folio' as dirty in the 'mapping' at the specified index.",
        "pre": {
            "mapping->i_pages": "!=null",
            "folio_index(folio)": ">=0",
            "PAGECACHE_TAG_DIRTY": "!=null"
        }
    },
    "kprobe:xa_unlock_irqrestore": {
        "description": "Unlock the 'mapping->i_pages' with the given 'flags'.",
        "pre": {
            "mapping->i_pages": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:filemap_dirty_folio": {
        "description": "Mark the 'folio' as dirty for filesystems that do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:if (error == AOP_WRITEPAGE_ACTIVATE)": {
        "description": "Check if the error value is equal to AOP_WRITEPAGE_ACTIVATE.",
        "pre": {
            "error": "== AOP_WRITEPAGE_ACTIVATE"
        }
    }
},
{
    "folio": "!=null",
    "wbc": "!=null",
    "mapping": "!=null",
    "data": "!=null",
    "error": "==AOP_WRITEPAGE_ACTIVATE"
},
{
    "kretprobe:__folio_start_writeback": {
        "description": "Starts the writeback process for a folio",
        "pre": {
            "folio": {
                "host": "!=null"
            },
            "on_wblist": false
        },
        "post": {
            "folio_test_dirty(folio)": false,
            "xas_clear_mark(&xa PAGECACHE_TAG_DIRTY)": true,
            "xas_clear_mark(&xa PAGECACHE_TAG_TOWRITE)": true,
            "keep_write": false
        }
    }
},
{
    "kprobe:__folio_start_writeback": {
        "description": "Starts the writeback process for a folio",
        "pre": {
            "folio": {
                "host": "!=null"
            },
            "on_wblist": false
        }
    }
},
{
    "kretprobe:unpin_user_page": {
        "description": "Unpin a user page",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:unpin_user_page": {
        "description": "Unpin a user page",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range",
        "pre": {
            "page": "!=null",
            "npages": ">= 0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range",
        "pre": {
            "page": "!=null",
            "npages": ">= 0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_subpage_writeable": {
        "description": "Fault in an address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_subpage_writeable": {
        "description": "Fault in an address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_safe_writeable": {
        "description": "Fault in an address range for writing.",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_safe_writeable": {
        "description": "Fault in an address range for writing.",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading.",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": ">=0",
            "gup_flags": ">=0",
            "pages": "!=null",
            "locked": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": ">=0",
            "gup_flags": ">=0",
            "pages": "!=null",
            "locked": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:try_grab_folio": {
        "description": "Increment the refcount and pincount of the folio based on the provided parameters.",
        "pre": {
            "page": "!=null",
            "refs": ">=0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        },
        "post": {
            "return": {
                "type": "struct folio",
                "constraints": {
                    "if return == null": "failure",
                    "if flags == FOLL_GET": "refcount == old(refcount) + refs",
                    "if flags == FOLL_PIN and folio is large": "refcount == old(refcount) + refs and pincount == old(pincount) + refs",
                    "if flags == FOLL_PIN and folio is single-page": "refcount == old(refcount) + refs * GUP_PIN_COUNTING_BIAS"
                }
            }
        }
    }
},
{
    "kprobe:try_grab_folio": {
        "description": "The folio containing @page (with refcount appropriately incremented) for succes or NULL upon failure. If neither FOLL_GET nor FOLL_PIN was set, that's considered failure, and furthermore, a likely bug in the caller, so a warning is also emitted.",
        "pre": {
            "page": "!=null",
            "refs": ">=0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        }
    }
},
{
    "kretprobe:get_user_pages_unlocked": {
        "description": "Replaces the form: mmap_read_lock(mm); get_user_pages(mm, ..., page NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages). Functionally equivalent to get_user_pages_fast if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_FORCE, ...]"
        }
    }
},
{
    "kprobe:get_user_pages_unlocked": {
        "description": "Replaces the form: mmap_read_lock(mm); get_user_pages(mm, ..., page NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages). Functionally equivalent to get_user_pages_fast if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_FORCE, ...]"
        }
    }
},
{
    "kretprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": "!=null",
            "gup_flags": "!=null",
            "pages": "!=null",
            "locked": "!=null"
        }
    }
},
{
    "kprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": "!=null",
            "gup_flags": "!=null",
            "pages": "!=null",
            "locked": "!=null"
        }
    }
},
{
    "kretprobe:pin_user_pages_unlocked": {
        "description": "The FOLL_PIN variant of get_user_pages_unlocked(). Sets FOLL_PIN and rejects FOLL_GET.",
        "pre": {
            "start": "!=null",
            "nr_pages": ">=0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN]"
        }
    }
},
{
    "kprobe:pin_user_pages_unlocked": {
        "description": "The FOLL_PIN variant of get_user_pages_unlocked(). Sets FOLL_PIN and rejects FOLL_GET.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN]"
        }
    }
},
{
    "kretprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and CPUs of the node are removed.",
        "pre": {
            "nid": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and cpus of the node are removed.",
        "pre": {
            "nid": "!=null"
        }
    }
},
{
    "kretprobe:mempool_exit": {
        "description": "Free all reserved elements in pool and pool itself. This function only sleeps if the free_fn() function sleeps.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_exit": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null",
            "free_fn()": "does not sleep"
        }
    }
},
{
    "kretprobe:while (pool->curr_nr < pool->min_nr)": {
        "description": "Loop until the current number of buffers is less than the minimum number of buffers.",
        "pre": {
            "pool->curr_nr": "< pool->min_nr"
        }
    }
},
{
    "kprobe:while (pool->curr_nr < pool->min_nr)": {
        "description": "Loop while the current number of elements in the pool is less than the minimum number.",
        "pre": {
            "pool->curr_nr": "< pool->min_nr"
        }
    }
},
{
    "kretprobe:mempool_resize": {
        "description": "Resize an existing memory pool",
        "pre": {
            "pool": "!=null",
            "new_min_nr": "int"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:mempool_resize": {
        "description": "Resize an existing memory pool",
        "pre": {
            "pool": "!=null",
            "new_min_nr": "int"
        }
    }
},
{
    "kretprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "pre": {
            "pool": "!=null",
            "pool->pool_data": "!=null",
            "element": "!=null",
            "PAGE_SHIFT": "!=null",
            "order": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "pre": {
            "pool->pool_data": "!=null",
            "element": "!=null"
        }
    }
},




{
    "kretprobe:__put_devmap_managed_page_refs": {
        "description": "__put_devmap_managed_page_refs(struct page page, int refs) - If the page's pgmap type is not MEMORY_DEVICE_FS_DAX, return false.",
        "pre": {
            "page->pgmap->type": "== MEMORY_DEVICE_FS_DAX",
            "refs": ">= 0"
        },
        "post": {
            "return": "== 1",
            "wake_up_var(&page->_refcount)": "called"
        }
    }
},
{
    "kprobe:__put_devmap_managed_page_refs": {
        "description": "__put_devmap_managed_page_refs(struct page page, int refs)",
        "pre": {
            "page->pgmap->type": "== MEMORY_DEVICE_FS_DAX",
            "refs": ">= 0"
        }
    }
},


{
    "kretprobe:readahead_expand": {
        "description": "Expand a readahead request",
        "pre": {
            "ractl": "!=null",
            "new_start": "!=null",
            "new_len": "!=null"
        }
    }
},
{
    "kprobe:readahead_expand": {
        "description": "Expand a readahead request",
        "pre": {
            "ractl": "!=null",
            "new_start": "!=null",
            "new_len": "!=null"
        }
    }
},

{
    "kprobe:hmm_range_need_fault": {
        "description": "Check if a fault is needed for the given range in the hmm_vma_walk function.",
        "pre": {
            "hmm_vma_walk": "!=null",
            "range->hmm_pfns + ((start - range->start) >> PAGE_SHIFT)": "!=null",
            "(end - start) >> PAGE_SHIFT": "!=null"
        }
    },
    "kprobe:hmm_pfns_fill": {
        "description": "Fill the hmm_pfns array with HMM_PFN_ERROR for the given range.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "range": "!=null"
        }
    }
},
{
    "kretprobe:folio_migrate_mapping": {
        "description": "Migrate the mapping of a folio to a new folio.",
        "pre": {
            "mapping": "!=null",
            "newfolio": "!=null",
            "folio": "!=null",
            "extra_count": "int",
            "xas": "XA_STATE",
            "oldzone": "struct zone",
            "newzone": "struct zone",
            "dirty": "int",
            "expected_count": "int",
            "nr": "long"
        },
        "post": {
            "return": "-EAGAIN",
            "conditions": [
                "folio_ref_count(folio) != expected_count"
            ]
        }
    }
},
{
    "kprobe:folio_ref_count": {
        "description": "Check if the reference count of the folio is equal to the expected count.",
        "pre": {
            "folio": "!=null",
            "expected_count": "!=null",
            "folio_ref_count(folio)": "!= expected_count"
        },
        "return": "-EAGAIN"
    }
},
{
    "kretprobe:folio_test_mappedtodisk": {
        "description": "Check if the folio is mapped to disk.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_set_mappedtodisk": {
        "description": "Set the mappedtodisk flag for the new folio.",
        "pre": {
            "newfolio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_mappedtodisk": {
        "description": "Check if the folio is mapped to disk.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_set_mappedtodisk": {
        "description": "Set the mappedtodisk flag for the new folio.",
        "pre": {
            "newfolio": "!=null"
        }
    }
},
{
    "kretprobe:folio_migrate_mapping": {
        "description": "Simple folio migration.",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC_NO_COPY, ...]", // Add other possible values for the enum
            "extra_count": ">=0"
        }
    }
},
{
    "kprobe:folio_migrate_mapping": {
        "description": "Migrate a single LRU folio",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC_NO_COPY, ...]", // Add other valid modes here
            "extra_count": ">=0"
        }
    }
},
{
    "kretprobe:expected_count = folio_expected_refs": {
        "description": "Check if the expected reference count of the folio is equal to the reference count of the source folio.",
        "pre": {
            "mapping": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]",
            "check_refs": "bool"
        },
        "post": {
            "expected_count": "== folio_expected_refs(mapping, src)",
            "return": "-EAGAIN if folio_ref_count(src) != expected_count",
            "return": "-EAGAIN if !buffer_migrate_lock_buffers(head, mode)",
            "return": "success otherwise"
        }
    }
},
{
    "kprobe:expected_count": {
        "description": "Check if the reference count of src folio matches the expected count.",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]",
            "check_refs": "bool"
        }
    },
    "kprobe:buffer_migrate_lock_buffers": {
        "description": "Lock the buffers of the head folio for migration.",
        "pre": {
            "head": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]"
        }
    },
    "kprobe:check_refs": {
        "description": "Check if the reference count is enabled.",
        "pre": {}
    }
},
{
    "kretprobe:cgwb_release_wq": {
        "description": "Allocate a workqueue named 'cgwb_release' with 0 flags and 1 maximum concurrency. If the allocation fail return -ENOMEM. Otherwise, return 0.",
        "pre": {
            "cgwb_release_wq": "==null"
        },
        "post": {
            "cgwb_release_wq": "!=null"
        }
    }
},
{
    "kprobe:cgwb_release_wq": {
        "description": "Allocate a workqueue named 'cgwb_release' with 0 flags and 1 maximum concurrency. If the allocation fail return -ENOMEM. Otherwise, return 0.",
        "pre": {
            "cgwb_release_wq": "==null"
        }
    }
},
{
    "kretprobe:cleanup_offline_cgwbs_workfn": {
        "description": "Try to release dying cgwbs by switching attached inodes to the nearest living ancestor's writeback. Processed wbs are placed at the end of the list to guarantee forward progress.",
        "pre": {
            "bdi": "!=null"
        }
    }
},
{
    "kprobe:cleanup_offline_cgwbs_workfn": {
        "description": "Try to release dying cgwbs by switching attached inodes to the nearest living ancestor's writeback. Processed wbs are placed at the end of the list to guarantee forward progress.",
        "pre": {
            "bdi": "!=null",
            "iter": "!=null",
            "slot": "!=null",
            "wb": "!=null",
            "WB_registered": "0",
            "cgwb_lock": "unlocked",
            "list_empty(&bdi->wb_list)": "true"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and save the IRQ state.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:radix_tree_lookup": {
        "description": "Look up an entry in a radix tree.",
        "pre": {
            "tree": "!=null",
            "key": "!=null"
        },
        "post": {
            "wb": "!=null",
            "wb.blkcg_css": "!=null",
            "wb.blkcg_css": "!=blkcg_css"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:radix_tree_lookup": {
        "description": "Look up an entry in a radix tree.",
        "pre": {
            "tree": "!=null",
            "key": "!=null"
        }
    },
    "kprobe:wb->blkcg_css": {
        "description": "Check if wb->blkcg_css is equal to blkcg_css.",
        "pre": {
            "wb": "!=null",
            "wb->blkcg_css": "==blkcg_css"
        }
    }
},
{
    "kretprobe:generic_error_remove_page": {
        "description": "Remove a page from the address space mapping if it is not a regular file.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null",
            "PageTail(page)": "false",
            "!S_ISREG(mapping->host->i_mode)": "true"
        },
        "post": {
            "return": "-EIO",
            "truncate_inode_folio(mapping, page_folio(page))": "return value"
        }
    }
},
{
    "kprobe:generic_error_remove_page": {
        "description": "Remove a page from the address space mapping if it is not a regular file.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null",
            "PageTail(page)": "false",
            "!S_ISREG(mapping->host->i_mode)": "true"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_range": {
        "description": "Truncate range of pages specified by start & end byte offsets",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:truncate_inode_pages_range": {
        "description": "Truncate range of pages specified by start & end byte offsets",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies",
        "pre": {
            "mapping": "!=null"
        }
    }
},


{
    "kretprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null",
            "inode->i_size": "written"
        }
    }
},
{
    "kprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated.",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null",
            "inode->i_size": "newsize"
        }
    }
},
{
    "kretprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null"
        }
    }
},
{
    "kprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null"
        }
    }
},
{
    "kretprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size",
        "pre": {
            "inode": "!=null",
            "from": "!=null",
            "to": "!=null"
        }
    }
},
{
    "kprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size",
        "pre": {
            "inode": "!=null",
            "from": "!=null",
            "to": "!=null"
        }
    }
},
{
    "kretprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched.",
        "pre": {
            "inode": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched",
        "pre": {
            "inode": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kretprobe:__kmap_to_page": {
        "description": "kmap_local_page() mappings",
        "pre": {
            "vaddr": "!=null",
            "base": "unsigned long",
            "kctrl": "struct kmap_ctrl",
            "addr": "unsigned long",
            "i": "int"
        },
        "post": {
            "return": "pte_page(ptep_get(&pkmap_page_table[PKMAP_NR(addr)]))"
        }
    }
},

{
    "kretprobe:#ifdef ARCH_NEEDS_KMAP_HIGH_GET#define lock_kmap()             spin_lock_irq(&kmap_lock)#define unlock_kmap()           spin_unlock_irq(&kmap_lock)#define lock_kmap_any(flags)    spin_lock_irqsave(&kmap_lock, flags)#define unlock_kmap_any(flags)  spin_unlock_irqrestore(&kmap_lock, flags)#else#define lock_kmap()             spin_lock(&kmap_lock)#define unlock_kmap()           spin_unlock(&kmap_lock)#define lock_kmap_any(flags)    \\do": {
        "description": "The function abstracts the disabling of IRQ out of the locking in the case of kmap_high_get().",
        "pre": {
            "kmap_lock": "!=null",
            "flags": "in [null, BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        }
    }
},

{
    "kretprobe:kmap_high_get": {
        "description": "Get the high virtual address mapping for a given page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:kmap_high_get": {
        "description": "Condition for the kmap_high_get function",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:__kmap_local_page_prot": {
        "description": "To broaden the usage of the actual kmap_local() machinery always map pages when debugging is enabled and the architecture has no problems with alias mappings.",
        "pre": {
            "!IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": true,
            "!PageHighMem(page)": true
        }
    }
},
{
    "kprobe:__kmap_local_page_prot": {
        "description": "To broaden the usage of the actual kmap_local() machinery always map pages when debugging is enabled and the architecture has no problems with alias mappings.",
        "pre": {
            "!IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": true,
            "!PageHighMem(page)": true
        }
    }
},

{
    "kprobe:WARN_ON_ONCE": {
        "description": "Handle mappings which were obtained by kmap_high_get() first as the virtual address of such mappings is below PAGE_OFFSET. Warn for all other addresses which are in the user space part of the virtual address space.",
        "pre": {
            "vaddr": "!=null",
            "addr": ">= __fix_to_virt(FIX_KMAP_END)",
            "addr": "<= __fix_to_virt(FIX_KMAP_BEGIN)",
            "IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": "true"
        }
    }
},




{
    "kretprobe:static_branch_likely": {
        "description": "Check if the static branch is likely to be taken.",
        "pre": {
            "!static_branch_likely(&vm_numa_stat_key)": true
        },
        "post": {
            "return": {
                "page": "!=null",
                "page_to_nid(page)": "nid"
            }
        }
    }
},
{
    "kprobe:static_branch_likely_page_to_nid": {
        "description": "Allocate pages with the given GFP flag order, and NUMA node ID. Skip NUMA_INTERLEAVE_HIT counter update if NUMA statistics is disabled.",
        "pre": {
            "gfp": "!=null",
            "order": "!=null",
            "nid": "!=null",
            "Fourth Parameter": "==null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:get_hwpoison_page": {
        "description": "The function to get a hardware poisoned page.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "p->flags": "& PG_hwpoison",
            "return": "in [0, 1, -EIO, -EBUSY, -EHWPOISON]"
        }
    }
},
{
    "kprobe:get_hwpoison_page": {
        "description": "Retrieve a hardware-poisoned page.",
        "pre": {
            "p": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:is_migrate_cma_page": {
        "description": "Check if the given page is a CMA (Contiguous Memory Allocator) page that can be migrated.",
        "pre": {
            "page": "!=null"
        }
    },
    "kretprobe:page_folio": {
        "description": "Get the folio structure associated with the given page.",
        "pre": {
            "page": "!=null"
        }
    },
    "kretprobe:PageCompound": {
        "description": "Check if the given page is a compound page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:is_migrate_cma_page": {
        "description": "Check if the given page is a CMA (Contiguous Memory Allocator) page that can be migrated.",
        "pre": {
            "page": "!=null"
        }
    },
    "kprobe:page_folio": {
        "description": "Get the folio structure associated with the given page.",
        "pre": {
            "page": "!=null"
        }
    },
    "kprobe:PageCompound": {
        "description": "Check if the given page is a compound page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:generic_fadvise": {
        "description": "Generic file advisory information.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "len": "!=null",
            "advice": "!=null",
            "inode": "!=null",
            "mapping": "!=null",
            "bdi": "!=null",
            "endbyte": "!=null"
        },
        "post": {
            "return": "in [-ESPIPE, -EINVAL]"
        }
    }
},
{
    "kprobe:generic_fadvise": {
        "description": "Generic file advisory information.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "len": "!=null",
            "advice": "!=null",
            "inode": "!=null",
            "mapping": "!=null",
            "bdi": "!=null",
            "endbyte": "!=null"
        }
    }
},


{
    "kretprobe:do_slab_free": {
        "description": "Free objects from a slab cache.",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": ">=0"
        }
    }
},
{
    "kprobe:do_slab_free": {
        "description": "Performs fastpath freeing without additional function calls.",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": ">=0"
        }
    }
},
{
    "kretprobe:slub_get_cpu_ptr": {
        "description": "Allocate a per-CPU object cache for the specified slab.",
        "pre": {
            "s": "!=null",
            "flags": "!=null",
            "size": "!=null",
            "p": "!=null",
            "objcg": "!=null"
        }
    },
    "kretprobe:local_lock_irqsave": {
        "description": "Acquire a local lock and disable IRQs.",
        "pre": {
            "lock": "!=null",
            "irqflags": "!=null"
        }
    },
    "kretprobe:for_loop": {
        "description": "Iterate over the range [0, size) using variable i.",
        "pre": {
            "i": ">=0",
            "i": "<size"
        }
    }
},
{
    "kprobe:c = slub_get_cpu_ptr(s->cpu_slab);local_lock_irqsave(&s->cpu_slab->lock, irqflags);for (i = 0; i < size; i++)": {
        "description": "Drain objects in the per cpu slab, while disabling local IRQ which protects against PREEMPT and interrupts handlers invoking normal fastpath.",
        "pre": {
            "s": "!=null",
            "s->cpu_slab": "!=null",
            "s->cpu_slab->lock": "!=null",
            "irqflags": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:__folio_put": {
        "description": "This function releases the page cache for the given folio and performs additional operations depending on the size of the folio.",
        "pre": {
            "folio": "!=null",
            "!folio_test_hugetlb(folio)": "true",
            "__page_cache_release(folio)": "true",
            "destroy_large_folio(folio)": "true"
        }
    }
},
{
    "kprobe:__folio_put": {
        "description": "Put the folio into the cache.",
        "pre": {
            "folio": "!=null",
            "!folio_test_hugetlb(folio)": true,
            "__page_cache_release(folio)": true,
            "destroy_large_folio(folio)": true
        }
    }
},
{
    "kretprobe:put_pages_list": {
        "description": "Release a list of pages threaded on page->lru.",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kprobe:put_pages_list": {
        "description": "Release a list of pages threaded on page->lru.",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:folio_test_active": {
        "description": "Check if the folio is active.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_active": {
        "description": "Check if the folio is active.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:__folio_batch_release": {
        "description": "__folio_batch_release() will drain those queues here. folio_batch_move_lru() calls folios_put() directly to avoid mutual recursion.",
        "pre": {
            "fbatch": "!=null",
            "queues_drained": true,
            "folios_put_called": true
        }
    }
},

{
    "kretprobe:preempt_disable_nested": {
        "description": "Disable preemption and calculate x and t values.",
        "pre": {
            "delta": "!=null",
            "*p": "!=null",
            "pcp->stat_threshold": "!=null",
            "x": "!=null",
            "t": "!=null",
            "abs(x)": "> t"
        }
    }
},
{
    "kprobe:preempt_disable_nested": {
        "description": "Disable preemption for nested sections.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]",
            "delta": "!=null",
            "pcp": "!=null",
            "p": "!=null",
            "x": "!=null",
            "t": "!=null"
        }
    }
},
{
    "kretprobe:VM_WARN_ON_ONCE(delta & (PAGE_SIZE - 1));delta >>= PAGE_SHIFT;}/* See __mod_node_page_state": {
        "description": "Modifies the node page state based on the given parameters.",
        "pre": {
            "pgdat": "!=null",
            "item": "in [NODE_STAT_ITEM_1, NODE_STAT_ITEM_2, ...]",
            "delta": "!=null"
        }
    }
},
{
    "kprobe:VM_WARN_ON_ONCE": {
        "description": "Check if delta has a non-zero value and is not a multiple of PAGE_SIZE.",
        "pre": {
            "delta": "!=0",
            "delta & (PAGE_SIZE - 1)": "==0"
        }
    },
    "kprobe:delta >>= PAGE_SHIFT": {
        "description": "Right shift delta by PAGE_SHIFT bits.",
        "pre": {
            "delta": "!=null"
        }
    }
},


{
    "kretprobe:mod_zone_state": {
        "description": "Modifies the zone counter state through atomic per CPU operations.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]",
            "delta": "is int",
            "overstep_mode": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:mod_zone_state": {
        "description": "Modifies the zone counter state through atomic per cpu operations.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]", 
            "delta": "is int",
            "overstep_mode": "in [-1, 0, 1]"
        }
    }
},


{
    "kretprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "useroffset": "!=null",
            "usersize": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "useroffset": "!=null",
            "usersize": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kretprobe:kmem_cache_sanity_check": {
        "description": "Integrity check for the kmem_cache_sanity_check function.",
        "pre": {
            "name": "!=null",
            "size": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},

{
    "kretprobe:kmem_cache_release": {
        "description": "Delete and release the kmem_cache object.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_release": {
        "description": "Release a kmem_cache object.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:kmem_cache_shrink": {
        "description": "Shrink a cache. Releases as many slabs as possible for a cache.",
        "pre": {
            "cachep": "!=null"
        },
        "post": {
            "return": "in [0, !=0]"
        }
    }
},
{
    "kprobe:kmem_cache_shrink": {
        "description": "Shrink a cache.",
        "pre": {
            "cachep": "!=null"
        }
    }
},


{
    "kretprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "pre": {
            "size": "== 0"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "pre": {
            "size": "== 0"
        }
    }
},
{
    "kretprobe:if (IS_ENABLED(CONFIG_MEMCG_KMEM) && (type == KMALLOC_NORMAL))flags |= SLAB_NO_MERGE;if (minalign > ARCH_KMALLOC_MINALIGN)": {
        "description": "This function checks if the CONFIG_MEMCG_KMEM is enabled and the type is KMALLOC_NORMAL. If both conditions are true, it sets the flags to include SLAB_NO_MERGE if minalign is greater than ARCH_KMALLOC_MINALIGN.",
        "pre": {
            "IS_ENABLED(CONFIG_MEMCG_KMEM)": true,
            "type": "KMALLOC_NORMAL",
            "flags": "|= SLAB_NO_MERGE",
            "minalign": "> ARCH_KMALLOC_MINALIGN"
        }
    }
},
{
    "kprobe:if (IS_ENABLED(CONFIG_MEMCG_KMEM) && (type == KMALLOC_NORMAL))flags |= SLAB_NO_MERGE;if (minalign > ARCH_KMALLOC_MINALIGN)": {
        "description": "Description of the function",
        "pre": {
            "IS_ENABLED(CONFIG_MEMCG_KMEM)": true,
            "type": "KMALLOC_NORMAL",
            "flags": "SLAB_NO_MERGE",
            "minalign": "> ARCH_KMALLOC_MINALIGN"
        }
    }
},
{
    "kretprobe:kmem_cache_create": {
        "description": "Create a cache.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_create": {
        "description": "Create a cache.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Free previously allocated memory.",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kprobe:kfree": {
        "description": "Free previously allocated memory.",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:krealloc": {
        "description": "Check for double-free before calling ksize.",
        "pre": {
            "p": "!=null",
            "likely(p)": "true"
        }
    }
},

{
    "kretprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:__ksize": {
        "description": "Report full size of underlying allocation",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kprobe:__ksize": {
        "description": "Report full size of underlying allocation",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_update_trace": {
        "description": "Update object allocation stack trace",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_update_trace": {
        "description": "Update object allocation stack trace",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive.",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive.",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:struct_kmemleak_object": {
        "description": "Structure holding the metadata for each allocated memory block.",
        "pre": {
            "object": "!=null",
            "object->lock": "held",
            "object_list": "protected",
            "gray_list": "protected",
            "rb_node": "protected",
            "use_count": "reference-counted",
            "RCU": "used for freeing"
        }
    }
},
{
    "kprobe:struct_kmemleak_object": {
        "description": "Structure holding the metadata for each allocated memory block.",
        "pre": {
            "node": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_no_scan": {
        "description": "Do not scan an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_no_scan": {
        "description": "Do not scan an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},


{
    "kretprobe:kmemleak_free_part_phys": {
        "description": "Free a range of memory starting from the given physical address.",
        "pre": {
            "phys": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_free_part_phys": {
        "description": "Free a part of a memory object based on the physical address and size.",
        "pre": {
            "phys": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but takes a physical address argument.",
        "pre": {
            "phys": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but takes a physical address argument",
        "pre": {
            "phys": "!=null",
            "phys": "is_valid_physical_address"
        }
    }
},
{
    "kretprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available",
        "pre": {
            "type": "!=null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:mem_cgroup_from_task": {
        "description": "Returns the memory cgroup associated with the given task.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kprobe:mem_cgroup_from_task": {
        "description": "Retrieve the memory cgroup associated with a task.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg.",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg.",
        "pre": {
            "mm": "!=null"
        }
    }
},


{
    "kretprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kretprobe:slab_post_alloc_hook": {
        "description": "Post-allocation hook for slab memory allocation.",
        "pre": {
            "s": "!=null",
            "objcg": "==null",
            "flags": "!=null",
            "size": "!=null",
            "p": "!=null"
        }
    }
},

{
    "kretprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kretprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode and produces a novel ino for the newly allocated inode.",
        "pre": {
            "sb": "!=null",
            "inop": "in [null, !=null]"
        }
    }
},
{
    "kprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode and produces a novel ino for the newly allocated inode.",
        "pre": {
            "sb": "!=null",
            "inop": "!=null or ==null"
        }
    }
},
{
    "kretprobe:kfree_const": {
        "description": "Conditionally free memory",
        "pre": {
            "x": "!=null",
            "x": "not in .rodata section"
        }
    }
},
{
    "kprobe:kfree_const": {
        "description": "Conditionally free memory.",
        "pre": {
            "x": "not in .rodata"
        }
    }
},
{
    "kretprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string.",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string.",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA]"
        }
    }
},
{
    "kretprobe:kstrdup_const": {
        "description": "conditionally duplicate an existing const string",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kstrdup_const": {
        "description": "conditionally duplicate an existing const string",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:kstrndup": {
        "description": "Allocate and copy a string up to a maximum length.",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kstrndup": {
        "description": "Allocate and copy at most 'max' bytes from 's' into a new string.",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:kvmemdup": {
        "description": "Duplicate a memory region.",
        "pre": {
            "src": "!=null",
            "len": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:kvmemdup": {
        "description": "Duplicate memory region with a specified size and allocate new memory for it.",
        "pre": {
            "src": "!=null",
            "len": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:memdup_user": {
        "description": "Duplicate memory region from user space",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:memdup_user": {
        "description": "Duplicate memory region from user space.",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space.",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:strndup_user": {
        "description": "Duplicate an existing string from user space",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strndup_user": {
        "description": "Duplicate an existing string from user space.",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vma_set_file": {
        "description": "Changing an anonymous vma with this is illegal",
        "pre": {
            "vma": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:vma_set_file": {
        "description": "Changing an anonymous vma with this is illegal",
        "pre": {
            "vma": "!=null",
            "file": "!=null"
        },
        "post": {
            "vma->vm_file": "==file",
            "file->refcount": "==refcount-1"
        }
    }
},
{
    "kretprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL, GFP_KERNEL | __GFP_RETRY_MAYFAIL]",
            "node": "!=null"
        },
        "post": {
            "return": "in [!=null, NULL]"
        }
    }
},
{
    "kprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL, GFP_KERNEL | __GFP_RETRY_MAYFAIL]",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information.",
        "pre": {
            "addr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information.",
        "pre": {
            "addr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array.",
        "pre": {
            "n": ">= 0",
            "size": ">= 0",
            "flags": "valid flags"
        }
    }
},
{
    "kprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array.",
        "pre": {
            "n": ">= 0",
            "size": ">= 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kretprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array.",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array.",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kretprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:page_offline_freeze": {
        "description": "Used by drivers that care about races when setting a page PageOffline().",
        "pre": {
            "page_offline_rwsem": "!=null"
        }
    }
},

{
    "kretprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "ret": "in [-ENOSPC, -EIO]"
        }
    }
},
{
    "kprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        }
    }
},
{
    "kretprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "sync_mode": "in [WB_SYNC_ALL]"
        }
    }
},
{
    "kprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "sync_mode": "in [WB_SYNC_ALL]"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:filemap_flush": {
        "description": "Mostly a non-blocking flush",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:filemap_flush": {
        "description": "Mostly a non-blocking flush",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:filemap_range_has_page": {
        "description": "Check if a page exists in range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_range_has_page": {
        "description": "Check if a page exists in range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_range": {
        "description": "Wait for writeback to complete for the given address space in the specified range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">=start_byte"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Wait for writeback to complete in the given range of the address space.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Wait for writeback to complete.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:file_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "file": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:file_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "file": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors in the given address space.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors in the given address space.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kretprobe:file_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "file": "!=null",
            "lstart": "!=null",
            "lend": "!=null",
            "lend": ">= lstart"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kprobe:file_write_and_wait_range": {
        "description": "Write out & wait on a file range",
        "pre": {
            "file": "!=null",
            "lstart": "!=null",
            "lend": "!=null",
            "lend": ">= lstart"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kretprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kretprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock for two mappings.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock for two mappings.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},


{
    "kretprobe:folio_unlock": {
        "description": "Unlock a locked folio. Unlocks the folio and wakes up any thread sleeping on the page lock.",
        "pre": {
            "folio": "!=null"
        },
        "context": {
            "interrupt": true,
            "process": true,
            "nmi": false
        }
    }
},
{
    "kprobe:folio_unlock": {
        "description": "Unlock a locked folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kretprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null",
            "index - return >= max_scan": "true"
        }
    }
},
{
    "kprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kretprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "fgp_flags": "in [0, FGP_ACCESSED, FGP_LOCK, FGP_CREAT, FGP_FOR_MMAP, FGP_WRITE, FGP_NOF FGP_NOWAIT, FGP_STABLE]",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "fgp_flags": "in [0, FGP_ACCESSED, FGP_LOCK, FGP_CREAT, FGP_FOR_MMAP, FGP_WRITE, FGP_NOF FGP_NOWAIT, FGP_STABLE]",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "fbatch": "!=null"
        }
    }
},
{
    "kprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "fbatch": "!=null"
        }
    }
},
{
    "kretprobe:generic_file_read_iter": {
        "description": "generic filesystem read routine",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        }
    }
},
{
    "kprobe:generic_file_read_iter": {
        "description": "generic filesystem read routine",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:page_cache_delete": {
        "description": "Delete a page from the page cache.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "shadow": "!=null",
            "mapping->host": "!=null",
            "mapping->host->i_mapping": "!=null",
            "mapping->host->i_mapping->nrpages": ">0",
            "folio->mapping": "==mapping",
            "folio->index": ">=0",
            "folio->index < mapping->host->i_mapping->nrpages",
            "folio->mapping->host": "==mapping->host",
            "folio->mapping->host->i_mapping": "==mapping->host->i_mapping",
            "folio->mapping->host->i_mapping->nrpages": "==mapping->host->i_mapping->nrpages",
            "shadow": "points to a valid shadow page"
        }
    }
},
{
    "kprobe:page_cache_delete": {
        "description": "Delete a page from the page cache.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "shadow": "!=null"
        }
    }
},
{
    "kretprobe:filemap_map_pages": {
        "description": "Handle the fault in the filemap",
        "pre": {
            "!pte_none(ptep_get(vmf->pte))": true,
            "goto unlock": true
        }
    }
},
{
    "kprobe:filemap_map_pages": {
        "description": "Handle the fault",
        "pre": {
            "vmf": {
                "pte": {
                    "none": false
                }
            }
        }
    }
},
{
    "kretprobe:folio_mark_dirty": {
        "description": "Marks the folio as dirty.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_wait_stable": {
        "description": "Waits for the folio to become stable.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:out:sb_end_pagefault": {
        "description": "Ends the page fault for the given mapping's host's superblock.",
        "pre": {
            "mapping": "!=null",
            "mapping->host": "!=null",
            "mapping->host->i_sb": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Returns the value of 'ret'.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kretprobe:generic_file_vm_ops": {
        "description": "Defines the virtual memory operations for generic file operations.",
        "pre": {}
    }
},
{
    "kprobe:folio_mark_dirty": {
        "description": "Marks the folio as dirty.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_wait_stable": {
        "description": "Waits for the folio to become stable.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:sb_end_pagefault": {
        "description": "Ends the page fault for the superblock of the mapping's host.",
        "pre": {
            "mapping->host->i_sb": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Returns the value of ret.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:generic_file_readonly_mmap": {
        "description": "This is for filesystems which do not implement ->writepage.",
        "pre": {
            "file": "!=null",
            "vma": "!=null",
            "file->f_mapping->a_ops->read_folio": "!=null"
        }
    }
},
{
    "kprobe:generic_file_readonly_mmap": {
        "description": "Maps a file into memory for read-only access.",
        "pre": {
            "file": "!=null",
            "vma": "!=null",
            "file->f_mapping": "!=null",
            "mapping->a_ops->read_folio": "==false"
        }
    }
},
{
    "kretprobe:filemap_page_mkwrite": {
        "description": "Handles page faults during write operations on file-backed memory mappings.",
        "pre": {},
        "post": {
            "return": "==VM_FAULT_SIGBUS"
        }
    }
},
{
    "kprobe:filemap_page_mkwrite": {
        "description": "Handles page faults for writeable mappings of file-backed memory.",
        "pre": {
            "vmf": "!=null"
        },
        "post": {
            "return": "in [VM_FAULT_SIGBU VM_FAULT_NOPAGE, VM_FAULT_LOCKED, VM_FAULT_RETRY, VM_FAULT_FALLBACK, VM_FAULT_MAJOR, VM_FAULT_WRITE, VM_FAULT_HWPOISON, VM_FAULT_SIGSEGV, VM_FAULT_OOM, VM_FAULT_SIGBUS]"
        }
    }
},
{
    "kretprobe:return ERR_PTR(err);}goto filler;}if (folio_test_uptodate(folio))goto out;if (!folio_trylock(folio))": {
        "description": "This function returns an error pointer if there is an error (ERR_PTR(err)). It then goes to the 'filler' label. If the 'folio' is up-to-date, it goes to the 'out' label. If 'folio' cannot be locked, it continues execution.",
        "pre": {
            "err": "!=null",
            "folio": "!=null",
            "folio_test_uptodate(folio)": "true",
            "folio_trylock(folio)": "false"
        }
    }
},
{
    "return ERR_PTR(err);}goto filler;}if (folio_test_uptodate(folio))goto out;if (!folio_trylock(folio))": {
        "pre": {
            "mapping": "!=null",
            "index": "any",
            "filler": "!=null",
            "file": "any",
            "gfp": "any"
        }
    }
},
{
    "kretprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:kiocb_invalidate_pages": {
        "description": "Invalidate pages and return the number of written bytes.",
        "pre": {
            "iocb": "!=null"
        }
    }
},

{
    "kretprobe:__generic_file_write_iter": {
        "description": "Write data to a file",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:__generic_file_write_iter": {
        "description": "Write data to a file",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio.",
        "pre": {
            "folio": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio.",
        "pre": {
            "folio": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:last_addr = phys_addr + size - 1;if (!size || last_addr < phys_addr)return NULL;/* Page-align mappings": {
        "description": "Disallow wrap-around or zero size",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "last_addr": "!=null",
            "size": "!=0",
            "last_addr < phys_addr": "true"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Disallow wrap-around or zero size",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot": "!=null"
        }
    }
},
{
    "kretprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null",
            "vma->vm_flags": "in [VM_IO | VM_PFNMAP]",
            "return": ">=0"
        }
    }
},
{
    "kprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc": {
        "description": "Allocate memory using vmalloc.",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "gfp_mask": "& ~__GFP_HIGHMEM == gfp_mask"
        }
    }
},
{
    "kprobe:__vmalloc": {
        "description": "Allocate virtual memory with specified size and flags.",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "gfp_mask": "not in [__GFP_HIGHMEM]"
        }
    }
},


{
    "kretprobe:vmalloc_node_range": {
        "description": "Allocate virtually contiguous memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:__vmalloc_node": {
        "description": "Allocate virtually contiguous memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "gfp_mask": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:__vmalloc_user_flags": {
        "description": "Allocate virtually contiguous memory with user flags.",
        "pre": {
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:vmalloc_user": {
        "description": "Allocate virtually contiguous memory for user.",
        "pre": {
            "size": "!=null"
        }
    },
    "kretprobe:vmalloc_to_page": {
        "description": "Convert virtual address to page.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kretprobe:vmalloc_to_pfn": {
        "description": "Convert virtual address to page frame number.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kretprobe:vread_iter": {
        "description": "Read data from memory using an iterator.",
        "pre": {
            "iter": "!=null",
            "addr": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_node_range": {
        "description": "Allocate virtually contiguous memory with specified range and node.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kprobe:__vmalloc_node": {
        "description": "Allocate virtually contiguous memory with specified node.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "gfp_mask": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kprobe:__vmalloc_user_flags": {
        "description": "Allocate virtually contiguous memory with specified flags for user space.",
        "pre": {
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:vmalloc_user": {
        "description": "Allocate virtually contiguous memory for user space.",
        "pre": {
            "size": "!=null"
        }
    },
    "kprobe:vmalloc_to_page": {
        "description": "Convert virtual address to corresponding page structure.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kprobe:vmalloc_to_pfn": {
        "description": "Convert virtual address to corresponding page frame number.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kprobe:vread_iter": {
        "description": "Read data from memory to an iterator.",
        "pre": {
            "iter": "!=null",
            "addr": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc_node_range": {
        "description": "Allocate a range of virtually contiguous kernel memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    }
},



{
    "kretprobe:usercopy_abort": {
        "description": "__check_object_size() function. Normal stack buffer usage should never trip the check and kernel text addressing will always trip the check. For cache object it is checking that only the whitelisted range of bytes for a given cache is being accessed (via the cache's usersize and useroffset fields). To adjust a cache whitelist, use the usercopy-aware kmem_cache_create_usercopy() function to create the cache (and carefully audit the whitelist range).",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "in [true, false]",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:usercopy_abort": {
        "description": "__noreturn usercopy_abort function",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "in [true, false]",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:kasan_reset_tag": {
        "description": "Reset the KASAN tag for the given address.",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": ">=0",
            "init": "in [true, false]",
            "shadow_start": "!=null",
            "shadow_end": "!=null",
            "kasan_arch_is_ready()": "true"
        }
    }
},
{
    "kprobe:kasan_reset_tag": {
        "description": "Reset the KASAN tag for the given address.",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": ">=0",
            "init": "in [true, false]",
            "shadow_start": "!=null",
            "shadow_end": "!=null",
            "kasan_arch_is_ready()": "true"
        }
    }
},

{
    "kprobe:__kasan_kmalloc": {
        "description": "Allocate memory using kmalloc with KASAN (Kernel Address Sanitizer) enabled.",
        "pre": {
            "cache": "!=null",
            "object": "!=null",
            "size": "!=null",
            "flags": "!=null",
            "redzone_start": "!=null",
            "redzone_end": "!=null",
            "gfpflags_allow_blocking(flags)": "true",
            "object == NULL": "false",
            "is_kfence_address(kasan_reset_tag(object))": "false"
        }
    }
},
{
    "kretprobe:kmsan_copy_page_meta": {
        "description": "Copy page metadata from source page to destination page.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "!kmsan_enabled": "true",
            "!kmsan_in_runtime()": "true",
            "!page_has_metadata(dst)": "false",
            "!page_has_metadata(src)": "false"
        }
    }
},
{
    "kprobe:kmsan_copy_page_meta": {
        "description": "Copy page metadata from source page to destination page.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "!kmsan_enabled": "false",
            "!kmsan_in_runtime()": "false",
            "!page_has_metadata(dst)": "false",
            "!page_has_metadata(src)": "false"
        }
    }
},
{
    "kretprobe:false);}EXPORT_SYMBOL(__msan_metadata_ptr_for_load_n": {
        "description": "Retrieve the metadata pointer for a load operation.",
        "pre": {
            "addr": "!=null",
            "size": ">0"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},



{
    "kretprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "pre": {
            "addr": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:__msan_memmove": {
        "description": "The __msan_memmove function copies n bytes from memory area src to memory area dst.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();kmsan_internal_memmove_metadata(dst, (void *)src, n);kmsan_leave_runtime();set_retval_metadata(shadow, origin);return result;}EXPORT_SYMBOL(__msan_memmove": {
        "description": "__msan_memmove function",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();/* Using memmove instead of memcpy doesn't affect correctness. `": {
        "description": "The kretprobe function returns the value of 'result' after performing some checks.",
        "pre": {
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true",
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();/* Using memmove instead of memcpy doesn't affect correctness. `": {
        "description": "This function returns the result after performing some operations related to memory copying.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},


{
    "kretprobe:__msan_chain_origin": {
        "description": "Chain the origin of the depot stack handle.",
        "pre": {
            "origin": "!=null"
        }
    }
},
{
    "kprobe:kmsan_enter_runtime": {
        "description": "Enter the KMSAN runtime.",
        "pre": {}
    },
    "kprobe:kmsan_internal_chain_origin": {
        "description": "Internal function to chain the origin.",
        "pre": {
            "origin": "!=null"
        }
    },
    "kprobe:kmsan_leave_runtime": {
        "description": "Leave the KMSAN runtime.",
        "pre": {}
    },
    "kprobe:user_access_restore": {
        "description": "Restore user access flags.",
        "pre": {
            "ua_flags": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return the value of ret.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:if (IS_ENABLED(CONFIG_UNWINDER_FRAME_POINTER))entries[3] = (u64)__builtin_return_address(1);elseentries[3] = 0;/* stack_depot_save() may allocate memory. `": {
        "description": "With frame pointers enabled, it is possible to quickly fetch the second frame of the caller stack without calling the unwinder. Without them, simply do not bother.",
        "pre": {
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true",
            "ua_flags": "!=null",
            "entries[0]": "==KMSAN_ALLOCA_MAGIC_ORIGIN",
            "entries[1]": "!=null",
            "entries[2]": "!=null"
        }
    }
},
{
    "kprobe:if (IS_ENABLED(CONFIG_UNWINDER_FRAME_POINTER))entries[3] = (u64)__builtin_return_address(1);elseentries[3] = 0;/* stack_depot_save() may allocate memory. `": {
        "description": "The given function condition",
        "pre": {
            "entries[0]": "== KMSAN_ALLOCA_MAGIC_ORIGIN",
            "entries[1]": "!= null",
            "entries[2]": "!= null",
            "entries[3]": "in [0, (u64)__builtin_return_address(1)]"
        }
    }
},
{
    "kretprobe:__msan_unpoison_alloca": {
        "description": "Unpoison memory allocated on the stack.",
        "pre": {
            "address": "!=null",
            "size": "!=null",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime": "==false"
        }
    }
},



{
    "kretprobe:copy_to_user": {
        "description": "Copy data from kernel space to user space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "to_copy": ">=0",
            "left": ">=0",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true"
        }
    }
},
{
    "kprobe:copy_to_user": {
        "description": "Copy data from kernel space to user space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "to_copy": ">=0",
            "left": ">=0",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true"
        }
    }
},
{
    "kretprobe:kmsan_internal_poison_memory": {
        "description": "Poison memory at the given address with the specified size and flags.",
        "pre": {
            "address": "!=null",
            "size": ">0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:kmsan_internal_poison_memory": {
        "description": "Poison memory at the given address with the specified size and flags.",
        "pre": {
            "address": "!=null",
            "size": ">0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:kmsan_internal_unpoison_memory": {
        "description": "Unpoison memory at the given address with the specified size.",
        "pre": {
            "address": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:kmsan_internal_unpoison_memory": {
        "description": "Unpoison the memory at the given address with the specified size.",
        "pre": {
            "address": "!=null",
            "size": "!=null"
        }
    }
},



{
    "kprobe:invalidate_mapping_pages": {
        "description": "Invalidates the mapping pages associated with a block device.",
        "pre": {
            "mapping": "!=null",
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_mapping": "!=null",
            "bdev->bd_inode->i_mapping->nrpages": ">0"
        }
    }
},
{
    "kretprobe:set_blocksize": {
        "description": "Set the block size for a block device.",
        "pre": {
            "bdev": "!=null",
            "size": {
                ">": "PAGE_SIZE",
                "<": 512,
                "!is_power_of_2": "size"
            }
        }
    }
},
{
    "kprobe:set_blocksize": {
        "description": "Set the block size for a block device.",
        "pre": {
            "bdev": "!=null",
            "size": {
                ">": "PAGE_SIZE",
                "<": 512,
                "!is_power_of_2": "size"
            }
        }
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block.",
        "pre": {
            "sb": "!=null",
            "size": ">= 512 && <= PAGE_SIZE",
            "sb->s_bdev": "!=null"
        },
        "post": {
            "sb->s_blocksize": "= size",
            "sb->s_blocksize_bits": "= blksize_bits(size)"
        }
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block.",
        "pre": {
            "sb": "!=null",
            "size": "is power of two",
            "size": ">= 512",
            "size": "<= PAGE_SIZE"
        }
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block",
        "pre": {
            "set_blocksize(sb->s_bdev, size)": "==0",
            "size": "is_power_of_two(size) && size >= 512 && size <= PAGE_SIZE"
        }
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block",
        "pre": {
            "sb": "!=null",
            "size": "is_power_of_two",
            "size_value": ">=512 && <=PAGE_SIZE",
            "blksize_bits(size)": "valid_value"
        }
    }
},




{
    "kretprobe:blkdev_get_by_dev": {
        "description": "Get the block device by device number",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "holder": "!=null",
            "hops": "!=null"
        },
        "post": {
            "return": {
                "type": "struct block_device",
                "constraints": [
                    {
                        "type": "reference",
                        "value": "!=ERR_PTR(-errno)"
                    }
                ]
            }
        }
    }
},
{
    "kprobe:blkdev_get_by_dev": {
        "description": "Get the block_device associated with the given device.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "holder": "!=null",
            "hops": "!=null"
        },
        "post": {
            "return": "in [block_device, ERR_PTR(-errno)]"
        },
        "context": "Might sleep"
    }
},
{
    "kretprobe:blkdev_put_no_open": {
        "description": "Release the block device and decrement the reference count.",
        "pre": {
            "bdev": "!=null",
            "atomic_dec_and_test(&bdev->bd_openers)": "true",
            "blkdev_flush_mapping(bdev)": "called if atomic_dec_and_test(&bdev->bd_openers) returns true",
            "bdev->bd_disk->fops->release": "called if bdev->bd_disk->fops->release is not null"
        }
    }
},
{
    "kprobe:blkdev_put_no_open": {
        "description": "Release a block device without opening it.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_device.kobj": "!=null",
            "!kobject_get_unless_zero(&bdev->bd_device.kobj)": "true",
            "inode": "!=null"
        },
        "post": {
            "return": "bdev"
        }
    }
},
{
    "kretprobe:if (atomic_read(&bdev->bd_openers) == 1)sync_blockdev(bdev);mutex_lock(&disk->open_mutex);if (holder)bd_end_claim(bdev, holder);/* * Trigger event checking and tell drivers to flush MEDIA_CHANGE * event.  This is to ensure detection of media removal commanded * from userland - e.g. eject(1). ": {
        "description": "This function performs various operations related to block devices and media change events.",
        "pre": {
            "atomic_read(&bdev->bd_openers)": "== 1",
            "sync_blockdev(bdev)": "called",
            "mutex_lock(&disk->open_mutex)": "called",
            "holder": "null or not null",
            "bd_end_claim(bdev, holder)": "called if holder is not null"
        }
    }
},
{
    "kprobe:if (atomic_read(&bdev->bd_openers) == 1)sync_blockdev(bdev);mutex_lock(&disk->open_mutex);if (holder)bd_end_claim(bdev, holder);/* * Trigger event checking and tell drivers to flush MEDIA_CHANGE * event.  This is to ensure detection of media removal commanded * from userland - e.g. eject(1). `": {
        "description": "This function performs various operations related to block devices and media change events.",
        "pre": {
            "atomic_read(&bdev->bd_openers)": "== 1",
            "sync_blockdev(bdev)": "called",
            "mutex_lock(&disk->open_mutex)": "called",
            "holder": "null or not null",
            "bd_end_claim(bdev, holder)": "called if holder is not null"
        }
    }
},
{
    "kretprobe:__invalidate_device": {
        "description": "__invalidate_device function",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "bool",
            "sb": "get_super(bdev)",
            "res": "int",
            "sb != null": true,
            "res == 0": true
        }
    }
},
{
    "kprobe:__invalidate_device": {
        "description": "Invalidate the device and its associated super block.",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "bool",
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished.",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished.",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_sb": "!=null",
            "bdev->bd_inode->i_sb->s_bdev": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue->flush_fn": "!=null"
        }
    }
},
{
    "kprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_sb": "!=null",
            "bdev->bd_inode->i_sb->s_bdev": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue->flush_fn": "!=null"
        }
    }
},
{
    "kretprobe:struct_bio_set_fs_bio_set": {
        "description": "Conditions for struct bio_set fs_bio_set",
        "pre": {
            "fs_bio_set": "!=null",
            "bio_pool": "!=null",
            "iovec_pool": "!=null"
        }
    }
},
{
    "kprobe:fs_bio_set": {
        "description": "The bio_set containing bio and iovec memory pools used by IO code that does not need private memory pools.",
        "pre": {
            "fs_bio_set": "!=null"
        }
    }
},


{
    "kretprobe:bio_reset": {
        "description": "Reset the given bio structure.",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "in [BLK_OP_READ, BLK_OP_WRITE, BLK_OP_DISCARD, BLK_OP_FLUSH]"
        }
    }
},
{
    "kprobe:bio_reset": {
        "description": "Reset the fields of a bio structure.",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "in [READ, WRITE, READA, FLUSH, DISCARD, WRITE_SAME, WRITE_ZEROE WRITE_SAME_UNMAP]"
        }
    }
},
{
    "kretprobe:bio_chain": {
        "description": "Chain bio completions",
        "pre": {
            "bio": "!=null",
            "parent": "!=null",
            "bio->bi_private": "==null",
            "bio->bi_end_io": "==null"
        }
    }
},
{
    "kprobe:bio_chain": {
        "description": "Chain bio completions",
        "pre": {
            "bio": "!=null",
            "parent": "!=null",
            "bio.bi_private": "==null",
            "bio.bi_end_io": "==null"
        }
    }
},
{
    "kretprobe:bio_kmalloc": {
        "description": "kmalloc a bio",
        "pre": {
            "nr_vecs": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:bio_kmalloc": {
        "description": "kmalloc a bio",
        "pre": {
            "nr_vecs": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:bvec_alloc_gfp": {
        "description": "Make the first allocation restricted and don't dump info on allocation failure since we'll fall back to the mempool in case of failure.",
        "pre": {
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:bvec_alloc_gfp": {
        "description": "Allocate memory for a bio vector with a given GFP flag.",
        "pre": {
            "gfp": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:bio_init_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:bio_init_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:bio_add_pc_page": {
        "description": "Attempt to add page to passthrough bio",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:bio_add_pc_page": {
        "description": "Attempt to add page to passthrough bio",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:__bio_add_page": {
        "description": "Add page(s) to a bio in a new segment.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kprobe:__bio_add_page": {
        "description": "Add page(s) to a bio in a new segment.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kretprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio.",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": ">=0",
            "off": ">=0",
            "len": "<=UINT_MAX",
            "off": "<=UINT_MAX"
        }
    }
},
{
    "kprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio.",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": "!=null",
            "off": "!=null",
            "len": "<= UINT_MAX",
            "off": "<= UINT_MAX"
        }
    }
},
{
    "kretprobe:submit_bio_wait": {
        "description": "Submit a bio and wait until it completes.",
        "pre": {
            "bio": "!=null",
            "bio->bi_private": "!=null"
        },
        "post": {
            "return": "in [0, bio_endio_error_code]"
        }
    }
},
{
    "kprobe:submit_bio_wait": {
        "description": "Submit a bio and wait until it completes.",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:bio_split": {
        "description": "Split a bio",
        "pre": {
            "bio": "!=null",
            "sectors": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kprobe:bio_split": {
        "description": "Split a bio",
        "pre": {
            "bio": "!=null",
            "sectors": ">=0",
            "gfp": ">=0",
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:bioset_exit": {
        "description": "Exit function for bioset",
        "pre": {
            "bs": "!=null",
            "bs": "allocated with kzalloc()",
            "bs": "zeroed but uninitialized"
        }
    }
},
{
    "kprobe:bioset_exit": {
        "description": "Exit function for bioset",
        "pre": {
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:disk_check_media_change": {
        "description": "Check if a removable media has been changed",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:disk_check_media_change": {
        "description": "Check if a removable media has been changed.",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_map_integrity_sg": {
        "description": "Map integrity metadata into a scatterlist",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_map_integrity_sg": {
        "description": "Map integrity metadata into a scatterlist",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null"
        }
    }
},
{
    "kretprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        }
    }
},
{
    "kretprobe:blk_integrity_register": {
        "description": "Register a gendisk as being integrity-capable",
        "pre": {
            "disk": "!=null",
            "template": "!=null"
        }
    }
},

{
    "kretprobe:blk_integrity_unregister": {
        "description": "Unregister block integrity profile",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_unregister": {
        "description": "Unregister block integrity profile",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_pm_runtime_init": {
        "description": "Block layer runtime PM initialization routine",
        "pre": {
            "q": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:blk_pm_runtime_init": {
        "description": "Block layer runtime PM initialization routine",
        "pre": {
            "q": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_suspend": {
        "description": "Pre runtime suspend check",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_pre_runtime_suspend": {
        "description": "Pre runtime suspend check",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing",
        "pre": {
            "q": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing",
        "pre": {
            "q": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_resume": {
        "description": "Pre runtime resume processing",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_pre_runtime_resume": {
        "description": "Pre runtime resume processing",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_post_runtime_resume": {
        "description": "Performs the real work of restarting the queue after runtime resume.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_post_runtime_resume": {
        "description": "Performs the real work of restarting the queue after runtime resume.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio",
        "pre": {
            "bio": "!=null",
            "gfp_mask": "!=null",
            "nr_vecs": ">=0"
        }
    }
},
{
    "kprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio",
        "pre": {
            "bio": "!=null",
            "gfp_mask": "!=null",
            "nr_vecs": ">=0"
        }
    }
},
{
    "kretprobe:bio_integrity_add_page": {
        "description": "Attach a page containing integrity metadata to bio.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:bio_integrity_add_page": {
        "description": "Attach integrity metadata to bio by updating the page.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO",
        "pre": {
            "bio": "!=null",
            "bio->bi_integrity": "==null",
            "bio->bi_data_dir": "in [WRITE, READ]",
            "bio->bi_bdev": "!=null",
            "bio->bi_sector": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO",
        "pre": {
            "bio": "!=null",
            "bio->bi_integrity": "==null",
            "bio->bi_data_dir": "in [WRITE, READ]",
            "bio->bi_bdev": "!=null",
            "bio->bi_sector": "!=null"
        }
    }
},
{
    "kretprobe:bio_integrity_trim": {
        "description": "Trim integrity vector",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_trim": {
        "description": "Trim integrity vector",
        "pre": {
            "bio": "!=null"
        }
    }
},


{
    "kretprobe:__blkdev_issue_zeroout": {
        "description": "Generate number of zero-filled write bios for block device.",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">0",
            "gfp_mask": ">=0",
            "biop": "!=null",
            "flags": "in [BLKDEV_ZERO_NOUNMAP, BLKDEV_ZERO_NOFALLBACK]"
        }
    }
},
{
    "kprobe:__blkdev_issue_zeroout": {
        "description": "Zero-fill a block range, either using hardware offload or by explicitly writing zeroes to the device.",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp_mask": ">=0",
            "biop": "!=null",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:blkdev_issue_secure_erase": {
        "description": "Issue a secure erase command to the block device.",
        "pre": {
            "bdev": "!=null",
            "sector": "!=null",
            "nr_sects": "!=null",
            "gfp": "!=null",
            "bs_mask": "= (bdev_logical_block_size(bdev) >> 9) - 1",
            "max_sectors": "= bdev_max_secure_erase_sectors(bdev)",
            "bio": "=null",
            "plug": "=null",
            "ret": "=0",
            "max_sectors": "> (UINT_MAX >> SECTOR_SHIFT)",
            "max_sectors": "= UINT_MAX >> SECTOR_SHIFT",
            "max_sectors": "&= ~bs_mask",
            "max_sectors": "== 0",
            "return": "-EOPNOTSUPP",
            "(sector | nr_sects)": "& bs_mask",
            "return": "-EINVAL",
            "bdev_read_only(bdev)": "== true",
            "return": "-EPERM"
        }
    }
},
{
    "kprobe:blkdev_issue_secure_erase": {
        "description": "Issue a secure erase command to the block device.",
        "pre": {
            "bdev": "!=null",
            "sector": "!=null",
            "nr_sects": "!=null",
            "gfp": "!=null",
            "bs_mask": "((bdev_logical_block_size(bdev) >> 9) - 1)",
            "max_sectors": "bdev_max_secure_erase_sectors(bdev)",
            "bio": "null",
            "plug": "null",
            "ret": "0",
            "max_sectors_check": "max_sectors > (UINT_MAX >> SECTOR_SHIFT)",
            "max_sectors_update": "max_sectors = UINT_MAX >> SECTOR_SHIFT",
            "max_sectors_mask": "max_sectors &= ~bs_mask",
            "max_sectors_zero_check": "max_sectors == 0",
            "sector_nr_sects_mask_check": "(sector | nr_sects) & bs_mask",
            "bdev_read_only_check": "bdev_read_only(bdev)"
        }
    }
},
{
    "kretprobe:ioc_lookup_icq": {
        "description": "Lookup io_cq from ioc",
        "pre": {
            "q": "!=null",
            "q->queue_lock": "held"
        }
    }
},
{
    "kprobe:ioc_lookup_icq": {
        "description": "Lookup io_cq from ioc",
        "pre": {
            "q": "!=null",
            "q->queue_lock": "held"
        }
    }
},
{
    "kretprobe:__register_blkdev": {
        "description": "Register a new block device",
        "pre": {
            "major": ">=1 and <=BLKDEV_MAJOR_MAX-1",
            "name": "!=null and unique within the system",
            "probe": "!=null"
        }
    }
},
{
    "kprobe:__register_blkdev": {
        "description": "Register a new block device",
        "pre": {
            "major": ">=1 && <=BLKDEV_MAJOR_MAX-1",
            "name": "!=null",
            "probe": "!=null"
        }
    }
},
{
    "kretprobe:device_add_disk": {
        "description": "Add disk information to kernel list",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kprobe:device_add_disk": {
        "description": "Add disk information to kernel list",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kretprobe:del_gendisk": {
        "description": "Delete the gendisk structure for the given disk.",
        "pre": {
            "disk": "!=null"
        },
        "post": {
            "disk": "==null"
        }
    }
},
{
    "kprobe:del_gendisk": {
        "description": "Delete a gendisk structure.",
        "pre": {
            "disk": "!=null"
        },
        "post": {
            "disk": "==null"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:invalidate_disk": {
        "description": "Invalidate the disk",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:invalidate_disk": {
        "description": "Invalidate the disk",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:set_disk_ro": {
        "description": "Set a gendisk read-only",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kprobe:set_disk_ro": {
        "description": "Set a gendisk read-only",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kretprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_sync_queue": {
        "description": "This function does not cancel any asynchronous activity arising out of elevator or throttling code. That would require elevator_exit() and blkcg_exit_queue() to be called with queue lock initialized.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_sync_queue": {
        "description": "This function is responsible for synchronously queuing a block I/O request.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_put_queue": {
        "description": "Decrement the request_queue refcount and free it when the refcount reaches 0.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_put_queue": {
        "description": "Decrement the request_queue refcount and free it when the refcount reaches 0.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:__submit_bio_noacct": {
        "description": "Submit a bio without accounting.",
        "pre": {
            "bio": "!=null",
            "bio_list": "!=null",
            "bio_list_on_stack[0]": "!=null",
            "bio_list_on_stack[1]": "!=null"
        },
        "post": {
            "bio_list": "!=null",
            "bio_list_on_stack[0]": "!=null",
            "bio_list_on_stack[1]": "!=null"
        }
    }
},

{
    "kretprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": {
                "type": "pointer",
                "value": "q"
            }
        }
    }
},

{
    "kretprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "pre": {
            "plug": "!=null",
            "nr_ios": "!=null",
            "tsk": "!=null",
            "tsk->plug": "false",
            "plug->mq_list": "null",
            "plug->cached_rq": "null",
            "plug->nr_ios": "min_t(unsigned short, nr_io BLK_MAX_REQUEST_COUNT)",
            "plug->rq_count": "0",
            "plug->multiple_queues": "false",
            "plug->has_elevator": "false",
            "plug->nowait": "false",
            "INIT_LIST_HEAD(&plug->cb_list)": "null"
        }
    }
},
{
    "kprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "pre": {
            "plug": {
                "mq_list": "null",
                "cached_rq": "null",
                "nr_ios": "min_t(unsigned short, nr_io BLK_MAX_REQUEST_COUNT)",
                "rq_count": "0",
                "multiple_queues": "false",
                "has_elevator": "false",
                "nowait": "false",
                "cb_list": "INIT_LIST_HEAD"
            }
        }
    }
},


{
    "kretprobe:blk_start_plug": {
        "description": "Starts a block plug for efficient I/O batching.",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kprobe:blk_start_plug": {
        "description": "Starts a block plug for efficient I/O batching.",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kretprobe:__bio_split_to_limits": {
        "description": "Split a bio to fit the queue limits",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        }
    }
},
{
    "kprobe:__bio_split_to_limits": {
        "description": "Split a bio to fit the queue limits.",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        }
    }
},
{
    "kretprobe:WARN_ON(nsegs > blk_rq_nr_phys_segments(rq))": {
        "description": "Check if the number of segments is greater than the number of request's physical segments",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "sglist": "!=null",
            "last_sg": "!=null",
            "nsegs": ">=0",
            "rq->rq_flags": "!=null",
            "rq->special_vec": "!=null",
            "rq->bio": "!=null"
        }
    }
},
{
    "kprobe:WARN_ON(nsegs > blk_rq_nr_phys_segments(rq));return nsegs;}EXPORT_SYMBOL(__blk_rq_map_sg": {
        "description": "This function maps scatterlist segments to a request.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "sglist": "!=null",
            "last_sg": "!=null",
            "nsegs": ">= 0",
            "rq->rq_flags": "!=null",
            "rq->special_vec": "!=null",
            "rq->bio": "!=null"
        }
    }
},
{
    "kretprobe:init_opal_dev": {
        "description": "Initialize the opal_dev structure with the given data and send_recv functions.",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        },
        "post": {
            "return": "!=null",
            "dev->cmd": "!=null",
            "dev->resp": "!=null",
            "dev->unlk_lst": "initialized",
            "dev->dev_lock": "initialized",
            "dev->flags": "0",
            "dev->data": "data",
            "dev->send_recv": "send_recv",
            "check_opal_support(dev)": "== 0"
        }
    }
},
{
    "kprobe:init_opal_dev": {
        "description": "Initialize the opal_dev structure with the given data and send_recv functions.",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        }
    },
    "kprobe:kmalloc": {
        "description": "Allocate memory of size IO_BUFFER_LENGTH with GFP_KERNEL flag.",
        "pre": {
            "size": "IO_BUFFER_LENGTH",
            "flags": "GFP_KERNEL"
        }
    },
    "kprobe:goto": {
        "description": "Jump to the specified label if the condition is true.",
        "pre": {
            "condition": "err_free_dev",
            "label": "err_free_dev"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the opal_dev's unlk_lst field as an empty list.",
        "pre": {
            "list": "empty"
        }
    },
    "kprobe:mutex_init": {
        "description": "Initialize the opal_dev's dev_lock field as a mutex.",
        "pre": {
            "mutex": "initialized"
        }
    },
    "kprobe:check_opal_support": {
        "description": "Check if opal support is available for the given opal_dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:while (j < npages)bio_release_page(bio, pages[j++]);if (pages != stack_pages)kvfree(pages);/* couldn't stuff something into bio? `": {
        "description": "Release pages mapped into the bio.",
        "pre": {
            "j": "< npages",
            "bio": "!= null",
            "pages[j]": "!= null",
            "pages": "!= stack_pages"
        }
    }
},
{
    "kprobe:bio_release_page": {
        "description": "Release the pages mapped into the bio.",
        "pre": {
            "bio": "!=null",
            "pages": "!=null",
            "j": "< npages",
            "pages != stack_pages": "true",
            "pages != null": "true"
        }
    },
    "kprobe:kvfree": {
        "description": "Free the memory allocated for pages if they are not stack_pages.",
        "pre": {
            "pages": "!= stack_pages"
        }
    }
},


{
    "kretprobe:blk_rq_map_bio_alloc": {
        "description": "Allocate a bio and map it to the request queue.",
        "pre": {
            "rq": "!=null",
            "bio": "==null"
        },
        "post": {
            "bio": "!=null"
        }
    },
    "kretprobe:bio_iov_bvec_set": {
        "description": "Set the iov_iter of the bio to the provided iter.",
        "pre": {
            "bio": "!=null",
            "iter": "!=null"
        }
    },
    "kretprobe:blk_rq_bio_prep": {
        "description": "Prepare the bio for the request queue with the given number of segments.",
        "pre": {
            "rq": "!=null",
            "bio": "!=null",
            "nr_segs": ">=0"
        }
    }
},
{
    "kprobe:blk_rq_map_bio_alloc": {
        "description": "Allocate a bio and map it to a request.",
        "pre": {
            "rq": "!=null",
            "iter": "!=null"
        }
    },
    "kprobe:bio_iov_bvec_set": {
        "description": "Set the iov_iter for a bio.",
        "pre": {
            "bio": "!=null",
            "iter": "!=null"
        }
    },
    "kprobe:blk_rq_bio_prep": {
        "description": "Prepare a request with a bio.",
        "pre": {
            "rq": "!=null",
            "bio": "!=null",
            "nr_segs": ">=0"
        }
    }
},
{
    "kretprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:blk_set_stacking_limits": {
        "description": "Set default limits for stacking devices",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kprobe:blk_set_stacking_limits": {
        "description": "Set default limits for stacking devices",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue.",
        "pre": {
            "q": "!=null",
            "bounce": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue.",
        "pre": {
            "q": "!=null",
            "bounce": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue",
        "pre": {
            "q": "!=null",
            "chunk_sectors": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue.",
        "pre": {
            "q": "!=null",
            "chunk_sectors": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard.",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard.",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase.",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes.",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes.",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segment_size": {
        "description": "Enables a low level driver to set an upper limit on the size of a coalesced segment.",
        "pre": {
            "q": "!=null",
            "max_size": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_segment_size": {
        "description": "Set max segment size for blk_rq_map_sg",
        "pre": {
            "q": "!=null",
            "max_size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">= 512"
        }
    }
},
{
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">= 512"
        }
    }
},
{
    "kretprobe:blk_queue_physical_block_size": {
        "description": "Set physical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_physical_block_size": {
        "description": "Set physical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset.",
        "pre": {
            "q": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset.",
        "pre": {
            "q": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:blk_limits_io_min": {
        "description": "Set minimum request size for a device",
        "pre": {
            "limits": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kprobe:blk_limits_io_min": {
        "description": "set minimum request size for a device",
        "pre": {
            "limits": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue",
        "pre": {
            "q": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue",
        "pre": {
            "q": "!=null",
            "min": ">=0"
        }
    }
},
{
    "kretprobe:blk_limits_io_opt": {
        "description": "set optimal request size for a device",
        "pre": {
            "limits": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:blk_limits_io_opt": {
        "description": "Set optimal request size for a device",
        "pre": {
            "limits": "!=null",
            "opt": "!=null",
            "optimal_io_size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue",
        "pre": {
            "q": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue",
        "pre": {
            "q": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kretprobe:blk_stack_limits": {
        "description": "Adjust queue_limits for stacked devices.",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": "!=null"
        }
    }
},
{
    "blk_stack_limits": {
        "description": "Adjust queue_limits for stacked devices",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": "!=null"
        }
    }
},
{
    "kretprobe:disk_stack_limits": {
        "description": "Adjust queue limits for stacked drivers",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:disk_stack_limits": {
        "description": "Adjust queue limits for stacked drivers.",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},

{
    "kprobe:blk_queue_max_segment_size": {
        "description": "Set the maximum segment size for the request queue.",
        "pre": {
            "q": "!=null",
            "max_size": "!=null"
        }
    },
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set the logical block size for the request queue.",
        "pre": {
            "q": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_dma_alignment": {
        "description": "set required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_dma_alignment": {
        "description": "Set required memory and length alignment for direct DMA transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_update_dma_alignment": {
        "description": "update required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_alignment": {
        "description": "update required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth.",
        "pre": {
            "q": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth.",
        "pre": {
            "q": "!=null",
            "depth": ">=0"
        }
    }
},

{
    "kprobe:__blk_mq_alloc_requests": {
        "description": "Allocate requests for the given blk_mq_alloc_data structure.",
        "pre": {
            "data": "!=null",
            "data->q": "!=null",
            "data->q->q_usage_counter": "!=null",
            "nr": ">=1",
            "data->nr_tags": ">=nr",
            "data->cached_rq": "!=null"
        }
    }
},
{
    "kretprobe:if (force_irqthreads())return false;/* same CPU or cache domain?  Complete locally `": {
        "description": "Check if force_irqthreads() returns true and return false if it does.",
        "pre": {
            "force_irqthreads()": "== true"
        }
    }
},
{
    "kprobe:if (force_irqthreads())return false;/* same CPU or cache domain?  Complete locally `": {
        "description": "Check if force_irqthreads() returns true and return false if it does.",
        "pre": {
            "force_irqthreads()": "== true"
        }
    }
},
{
    "kretprobe:blk_mq_start_request": {
        "description": "Start processing a request",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_start_request": {
        "description": "Start processing a request",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blk_execute_rq_nowait": {
        "description": "Insert a fully prepared request at the back of the IO scheduler queue for execution. Don't wait for completion.",
        "pre": {
            "rq": "!=null",
            "at_head": "in [true, false]"
        }
    }
},
{
    "kprobe:blk_execute_rq_nowait": {
        "description": "Insert a request to IO scheduler for execution.",
        "pre": {
            "rq": "!=null",
            "at_head": "in [true, false]"
        }
    }
},
{
    "kretprobe:blk_mq_sched_requeue_request": {
        "description": "Requeue a request in the block multi-queue scheduler.",
        "pre": {
            "rq": "!=null",
            "q": "!=null",
            "rq->q": "==q",
            "rq->q->requeue_lock": "locked",
            "rq->queuelist": "not empty",
            "kick_requeue_list": "boolean"
        }
    }
},
{
    "kprobe:blk_mq_requeue_request": {
        "description": "Requeue a request in the IO scheduler queue.",
        "pre": {
            "rq": "!=null",
            "kick_requeue_list": "!=null",
            "q": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:if (rq->rq_flags & RQF_DONTPREP)": {
        "description": "Check if the RQF_DONTPREP flag is set in the request flags.",
        "pre": {
            "rq": "!=null",
            "rq_flags": "& RQF_DONTPREP != 0"
        }
    }
},
{
    "kprobe:blk_mq_requeue_work": {
        "description": "Requeue work for a request queue.",
        "pre": {
            "q": "!=null",
            "rq_list": "not empty",
            "flush_list": "not empty",
            "rq": "not null",
            "rq->rq_flags & RQF_DONTPREP": "is set"
        }
    }
},
{
    "kretprobe:blk_mq_hctx_next_cpu": {
        "description": "This function returns the next CPU to be used for the hardware context.",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_hctx_next_cpu": {
        "description": "Function to determine the next CPU for a hardware context in the blk-mq subsystem.",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kretprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously.",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously.",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kretprobe:blk_mq_stop_hw_queue": {
        "description": "Stop the hardware queue for the given blk_mq_hw_ctx.",
        "pre": {
            "hctx": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queue": {
        "description": "Stop the hardware queue associated with the given blk_mq_hw_ctx.",
        "pre": {}
    }
},
{
    "kretprobe:blk_mq_stop_hw_queues": {
        "description": "Stop hardware queues for the given request queue.",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queues": {
        "description": "Stop the hardware queues associated with the given request queue.",
        "pre": {}
    }
},
{
    "kretprobe:blk_mq_destroy_queue": {
        "description": "Shutdown a request queue",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_destroy_queue": {
        "description": "Shutdown a request queue",
        "pre": {
            "q": "!=null"
        }
    }
},




{
    "kretprobe:xen_alloc_unpopulated_pages": {
        "description": "alloc unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:xen_alloc_unpopulated_pages": {
        "description": "Allocates unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0 on succes error otherwise"
        }
    }
},
{
    "kretprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages.",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out.",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_free_ballooned_pages": {
        "description": "Subtract `pgno` pages from `balloon_stats.target_unpopulated` and remove the remaining pages for accurate accounting.",
        "pre": {
            "pgno": "!=null",
            "pages": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:xen_free_ballooned_pages": {
        "description": "Subtract `pgno` pages from `target_unpopulated` and remove remaining pages for correct accounting.",
        "pre": {
            "pgno": "!=null",
            "pages": "!=null",
            "balloon_stats.target_unpopulated": "-= nr_pages - pgno"
        }
    }
},
{
    "kretprobe:st21nfca_hci_control_se": {
        "description": "Control the SE with the given parameters.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "in [NFC_SE_UICC, eSE]",
            "ST21NFCA_SE_MODE_ON": "!=null"
        },
        "post": {
            "r": "==ST21NFCA_ESE_HOST_ID"
        }
    }
},
{
    "kprobe:st21nfca_hci_control_se": {
        "description": "Control the SE with the given SE index.",
        "pre": {
            "hdev": "is_instance_of(struct nfc_hci_dev)",
            "se_idx": "is_instance_of(u32)"
        },
        "post": {
            "r": "== ST21NFCA_ESE_HOST_ID"
        }
    }
},
{
    "kretprobe:st21nfca_hci_disable_se": {
        "description": "Disable the SE with the given index in the ST21NFCA HCI device.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!=null",
            "se_idx": "==NFC_SE_UICC implies info->se_status->is_uicc_enable is true",
            "se_idx": "==NFC_SE_eSE implies info->se_status->is_ese_enable is true"
        },
        "post": {
            "r": ">=-1"
        }
    }
},
{
    "kprobe:st21nfca_hci_disable_se": {
        "description": "Disable the Secure Element (SE) with the given index.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!=null",
            "se_idx": "== NFC_SE_UICC when info->se_status->is_uicc_enable is true",
            "se_idx": "== NFC_SE_eSE when info->se_status->is_ese_enable is true"
        }
    }
},
{
    "kretprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st21nfca_hci_se_io": {
        "description": "Free the memory allocated for cb_context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st21nfca_hci_se_io": {
        "description": "Free the memory allocated for the callback context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kretprobe:st21nfca_connectivity_event_received": {
        "description": "Connectivity event received",
        "pre": {
            "skb->len": "< 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG",
            "return": "-EPROTO",
            "aid_len": "skb->data[1]",
            "skb->len": "< aid_len + 4 || aid_len > sizeof(transaction->aid)",
            "return": "-EPROTO",
            "params_len": "skb->data[aid_len + 3]",
            "skb->data[2]": "== 0x82",
            "skb->data[aid_len + 4]": "<= skb->len"
        }
    }
},
{
    "kprobe:st21nfca_connectivity_event_received": {
        "description": "Connectivity event received",
        "pre": {
            "skb->len": "< 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG",
            "aid_len": "skb->len < aid_len + 4 || aid_len > sizeof(transaction->aid)",
            "params_len": "skb->data[aid_len + 3] != 82",
            "skb->len": "aid_len + 4 + params_len"
        }
    }
},
{
    "kretprobe:st21nfca_se_init": {
        "description": "Initialize the st21nfca_se_info structure",
        "pre": {
            "bwi_timer": "!=null",
            "se_active_timer": "!=null",
            "bwi_active": "false",
            "se_active": "false",
            "count_pipes": "0",
            "expected_pipes": "0",
            "xch_error": "false",
            "wt_timeout": "ST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI)"
        }
    }
},
{
    "kprobe:timer_setup": {
        "description": "Set up a timer.",
        "pre": {
            "timer": "!=null",
            "callback": "!=null",
            "data": "any"
        }
    },
    "kprobe:info->se_info.count_pipes": {
        "description": "Set the value of count_pipes.",
        "pre": {
            "count_pipes": "0"
        }
    },
    "kprobe:info->se_info.expected_pipes": {
        "description": "Set the value of expected_pipes.",
        "pre": {
            "expected_pipes": "0"
        }
    },
    "kprobe:info->se_info.xch_error": {
        "description": "Set the value of xch_error.",
        "pre": {
            "xch_error": "false"
        }
    },
    "kprobe:info->se_info.wt_timeout": {
        "description": "Set the value of wt_timeout.",
        "pre": {
            "wt_timeout": "ST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI)"
        }
    }
},
{
    "kretprobe:st21nfca_hci_probe": {
        "description": "Probe ST21NFCA HCI device",
        "pre": {
            "dev_mask": "!=null",
            "ST21NFCA_NUM_DEVICES": "!=null",
            "dev_num": "!=null",
            "dev_num": "< ST21NFCA_NUM_DEVICES"
        }
    }
},
{
    "kprobe:st21nfca_hci_probe": {
        "description": "Probe ST21NFCA HCI",
        "pre": {
            "dev_mask": "!=null",
            "ST21NFCA_NUM_DEVICES": "!=null",
            "dev_num": "!=null",
            "dev_num >= ST21NFCA_NUM_DEVICES": "true"
        }
    }
},
{
    "kretprobe:st21nfca_im_send_atr_req": {
        "description": "Send an ATR request using the ST21NFCA interface.",
        "pre": {
            "hdev": "!=null",
            "gb": "!=null",
            "gb_len": ">=0",
            "info": "!=null",
            "atr_req": "!=null",
            "target": "!=null",
            "size": ">=0",
            "skb": "!=null",
            "atr_req->cmd0": "==ST21NFCA_NFCIP1_REQ",
            "atr_req->cmd1": "==ST21NFCA_NFCIP1_ATR_REQ",
            "atr_req->did": "==0x0",
            "atr_req->bsi": "==0x00",
            "atr_req->bri": "==0x00",
            "atr_req->ppi": "==ST21NFCA_LR_BITS_PAYLOAD_SIZE_254B",
            "atr_req->length": "==sizeof(struct st21nfca_atr_req) + hdev->gb_len",
            "skb->data": "!=null",
            "skb->len": "==sizeof(struct st21nfca_atr_req) + gb_len + 1",
            "info->dep_info.to": "==ST21NFCA_DEFAULT_TIMEOUT",
            "info->dep_info.bri": "==atr_req->bri",
            "info->dep_info.bsi": "==atr_req->bsi",
            "info->async_cb_type": "==ST21NFCA_CB_TYPE_READER_F",
            "info->async_cb_context": "==info",
            "info->async_cb": "==st21nfca_im_recv_atr_res_cb"
        }
    }
},
{
    "kprobe:st21nfca_im_send_atr_req": {
        "description": "Send an ATR request using the ST21NFCA IM interface.",
        "pre": {
            "hdev": "!=null",
            "gb": "!=null",
            "gb_len": ">=0",
            "info": "!=null",
            "atr_req": "!=null",
            "target": "!=null",
            "size": ">=0",
            "skb": "!=null",
            "atr_req->cmd0": "==ST21NFCA_NFCIP1_REQ",
            "atr_req->cmd1": "==ST21NFCA_NFCIP1_ATR_REQ",
            "atr_req->did": "==0x0",
            "atr_req->bsi": "==0x00",
            "atr_req->bri": "==0x00",
            "atr_req->ppi": "==ST21NFCA_LR_BITS_PAYLOAD_SIZE_254B",
            "atr_req->length": "==sizeof(struct st21nfca_atr_req) + hdev->gb_len",
            "skb->data": "!=null",
            "skb->len": "==sizeof(struct st21nfca_atr_req) + gb_len + 1",
            "info->dep_info.to": "==ST21NFCA_DEFAULT_TIMEOUT",
            "info->dep_info.bri": "==atr_req->bri",
            "info->dep_info.bsi": "==atr_req->bsi",
            "info->async_cb_type": "==ST21NFCA_CB_TYPE_READER_F",
            "info->async_cb_context": "==info",
            "info->async_cb": "==st21nfca_im_recv_atr_res_cb",
            "info->dep_info.lri": "==ST21NFCA_PP2LRI(atr_req->ppi)",
            "skb->data[0]": "==info->dep_info.to | 0x10"
        }
    }
},
{
    "kretprobe:pn544_hci_probe": {
        "description": "Probe the pn544 HCI device.",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        }
    }
},
{
    "kprobe:pn544_hci_probe": {
        "description": "Probe the pn544 HCI device.",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        }
    }
},
{
    "kretprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st_nci_se_io": {
        "description": "Free the cb_context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st_nci_se_io": {
        "description": "Free the memory allocated for the callback context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kretprobe:st_nci_se_init": {
        "description": "Initialize the st_nci_se_init function",
        "pre": {
            "ndev": "!=null",
            "se_status": "!=null"
        },
        "post": {
            "info": {
                "se_info": {
                    "bwi_timer": "!=null",
                    "bwi_active": "false",
                    "se_active_timer": "!=null",
                    "se_active": "false",
                    "xch_error": "false",
                    "wt_timeout": "ST_NCI_BWI_TO_TIMEOUT(ST_NCI_ATR_DEFAULT_BWI)",
                    "se_status": "se_status"
                }
            },
            "return": "0"
        }
    }
},

{
    "kretprobe:ndlc_open": {
        "description": "Toggle reset pin",
        "pre": {
            "ndlc": "!=null",
            "ndlc->ops": "!=null",
            "ndlc->ops->enable(ndlc->phy_id)": "called",
            "ndlc->powered": "==1",
            "return": "==0"
        }
    }
},



{
    "kretprobe:ndlc_send": {
        "description": "Add ndlc header to skb",
        "pre": {
            "ndlc": "!=null",
            "skb": "!=null"
        }
    }
},

{
    "kretprobe:ndlc_probe": {
        "description": "ndlc_probe function",
        "pre": {
            "ndlc": "!=null",
            "ndlc.ops": "phy_ops",
            "ndlc.phy_id": "phy_id",
            "ndlc.dev": "dev",
            "ndlc.powered": "0",
            "ndlc_id": "ndlc",
            "st_nci_probe": "ndlc, phy_headroom, phy_tailroom, se_status"
        }
    }
},
{
    "kprobe:ndlc_probe": {
        "description": "Probe function for ndlc",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "dev": "!=null",
            "phy_headroom": "!=null",
            "phy_tailroom": "!=null",
            "ndlc_id": "!=null",
            "se_status": "!=null"
        }
    }
},


{
    "kretprobe:tc_register_driver": {
        "description": "Register a new TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:tc_register_driver": {
        "description": "Register a new TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Retrieve the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": {
                "acl_node_mutex": "held"
            },
            "initiatorname": "!=null"
        }
    }
},
{
    "kprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Retrieve the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": {
                "acl_node_mutex": "held"
            },
            "initiatorname": "!=null"
        }
    }
},
{
    "kretprobe:kref_get": {
        "description": "Increments the reference count of the given kref object.",
        "pre": {
            "&acl->acl_kref": "!=null"
        }
    },
    "kretprobe:core_tpg_check_initiator_node_acl": {
        "description": "Checks the initiator node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:core_tpg_get_initiator_node_acl": {
        "description": "Gets the initiator node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:target_alloc_node_acl": {
        "description": "Allocates a node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:tpg->se_tpg_tfo->tpg_check_demo_mode": {
        "description": "Checks if the given se_portal_group is in demo mode.",
        "pre": {
            "tpg": "!=null"
        }
    },
    "kretprobe:transport_free_session": {
        "description": "Frees the session and releases the reference to the dynamically generated node_acl.",
        "pre": {
            "session": "!=null"
        }
    }
},
{
    "kprobe:kref_get": {
        "description": "Increment the reference count of the kref object.",
        "pre": {
            "kref": "!=null"
        }
    },
    "kprobe:core_tpg_check_initiator_node_acl": {
        "description": "Check the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:core_tpg_get_initiator_node_acl": {
        "description": "Get the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:target_alloc_node_acl": {
        "description": "Allocate a node ACL for a given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:tpg->se_tpg_tfo->tpg_check_demo_mode": {
        "description": "Check if the fabric is in demo mode for a given se_portal_group.",
        "pre": {
            "tpg": "!=null"
        }
    },
    "kprobe:transport_free_session": {
        "description": "Free the session and release the reference count of the node_acl.",
        "pre": {
            "session": "!=null"
        }
    }
},


{
    "kretprobe:core_tpg_set_initiator_node_tag": {
        "description": "Initiator nodeacl tags are not used internally, but may be used by userspace to emulate aliases or groups. Returns length of newly-set tag or -EINVAL.",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
        "post": {
            "return_value": "in [>=0, -EINVAL]"
        }
    }
},
{
    "kprobe:core_tpg_set_initiator_node_tag": {
        "description": "Set initiator nodeacl tags.",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
        "post": {
            "return": ">= -EINVAL"
        }
    }
},
{
    "kretprobe:core_tpg_register": {
        "description": "Register a target portal group with a given WWN.",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "int",
            "!se_tpg": "return -EINVAL",
            "se_tpg_tfo": "!=null"
        },
        "post": {
            "se_tpg_tfo": "!=null"
        }
    }
},
{
    "kprobe:core_tpg_register": {
        "description": "Register a target portal group with a given world wide name (WWN) and protocol ID.",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "int"
        },
        "post": {
            "ret": "int"
        }
    }
},



{
    "kprobe:spc_emulate_inquiry_std": {
        "description": "Set RMB (removable media) for tape devices",
        "pre": {
            "cmd": "!=null",
            "buf": "!=null",
            "cmd->se_lun": "!=null",
            "cmd->se_lun->lun_tpg": "!=null",
            "cmd->se_lun->lun_tpg->se_dev": "!=null",
            "cmd->se_sess": "!=null",
            "cmd->se_dev->transport": "!=null",
            "cmd->se_dev->transport->get_device_type(cmd->se_dev)": "== TYPE_TAPE",
            "buf[1]": "== 0x80",
            "buf[2]": "== 0x06"
        }
    }
},
{
    "kretprobe:spc_emulate_evpd_83": {
        "description": "No description provided.",
        "pre": {
            "dev": {
                "dev_flags": "& DF_EMULATED_VPD_UNIT_SERIAL == 0"
            }
        }
    }
},
{
    "kprobe:if (!(dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL))goto check_t10_vend_desc;": {
        "description": "Check if the DF_EMULATED_VPD_UNIT_SERIAL flag is not set in dev->dev_flags.",
        "pre": {
            "dev": {
                "dev_flags": "& ~DF_EMULATED_VPD_UNIT_SERIAL"
            }
        }
    }
},
{
    "kretprobe:spc_emulate_report_luns": {
        "description": "Emulate the REPORT LUNS command in the SPC-3 standard.",
        "pre": {
            "sess": "==null",
            "cmd": "!=null",
            "deve": "!=null",
            "nacl": "!=null",
            "slun": "!=null",
            "buf": "!=null",
            "lun_count": ">=0",
            "offset": ">=8",
            "len": "!=null"
        }
    }
},
{
    "kprobe:spc_emulate_report_luns": {
        "description": "Emulate the REPORT LUNS command in the SPC-3 standard.",
        "pre": {
            "cmd": "!=null",
            "cmd->se_sess": "!=null",
            "cmd->se_sess->se_node_acl": "!=null",
            "cmd->se_sess->se_node_acl->lun_entry_hlist": "!=null",
            "deve": "!=null",
            "&cmd->se_sess->se_node_acl->lun_entry_hlist": "!=null",
            "sess": "!=null",
            "nacl": "!=null",
            "slun": "!=null",
            "buf": "!=null",
            "lun_count": ">=0",
            "offset": ">=8",
            "len": "!=null"
        }
    }
},


{
    "kretprobe:transport_init_session": {
        "description": "Initialize a session object",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kprobe:transport_init_session": {
        "description": "Initialize a session object",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kretprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it.",
        "pre": {
            "sup_prot_ops": "!=null",
            "sup_prot_ops": "bitmask",
            "sup_prot_ops": "in [T10_PI_MODE1, T10_PI_MODE2, T10_PI_MODE3]"
        }
    }
},
{
    "kprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it.",
        "pre": {
            "sup_prot_ops": "!=null"
        }
    }
},
{
    "kretprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0"
        }
    }
},
{
    "kprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0"
        }
    }
},
{
    "if (se_nacl)": {
        "description": "Check if se_nacl is set for active se_session objects.",
        "pre": {
            "se_nacl": "!=null",
            "se_sess->se_tpg": "!=null",
            "se_sess->fabric_sess_ptr": "!=null"
        }
    }
},

{
    "kretprobe:target_setup_session": {
        "description": "Setup a session in the target",
        "pre": {
            "tag_num": "!= 0",
            "tag_size": "!= null",
            "prot_op": "!= null",
            "initiatorname": "!= null",
            "private": "!= null",
            "callback": "!= null"
        }
    },
    "kretprobe:transport_init_session_tags": {
        "description": "Initialize a session with tags",
        "pre": {
            "tag_num": "!= 0",
            "tag_size": "!= null",
            "prot_op": "!= null"
        }
    },
    "kretprobe:transport_alloc_session": {
        "description": "Allocate a session",
        "pre": {
            "tag_num": "== 0",
            "prot_op": "!= null"
        }
    },
    "kretprobe:IS_ERR": {
        "description": "Check if the session is an error",
        "pre": {
            "sess": "!= null"
        }
    }
},
{
    "kprobe:target_setup_session": {
        "description": "Setup a session in the target subsystem",
        "pre": {
            "tag_num": "!=0",
            "tag_size": "!=null",
            "prot_op": "!=null"
        }
    }
},
{
    "kretprobe:target_show_dynamic_sessions": {
        "description": "Function to show dynamic sessions in a target portal group.",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null",
            "se_sess": "!=null",
            "len": ">=0",
            "se_sess->se_node_acl": "!=null",
            "se_sess->se_node_acl->dynamic_node_acl": "!=null",
            "strlen(se_sess->se_node_acl->initiatorname) + 1 + len": "<=PAGE_SIZE"
        },
        "post": {
            "return": "len"
        }
    }
},
{
    "kprobe:}spin_unlock_bh(&se_tpg->session_lock);return len;}EXPORT_SYMBOL(target_show_dynamic_sessions": {
        "description": "This function is used to show dynamic sessions in a target portal group.",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null",
            "se_sess": "!=null",
            "len": ">=0",
            "se_sess->se_node_acl": "!=null",
            "se_sess->se_node_acl->dynamic_node_acl": "!=null",
            "strlen(se_sess->se_node_acl->initiatorname) + 1 + len": "<=PAGE_SIZE"
        }
    }
},






{
    "kretprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null",
            "page_83[1]": "& 0x30",
            "return_value": "unknown" 
        }
    }
},
{
    "kprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        }
    }
},
{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "Set the VPD identifier type.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
        "post": {
            "vpd->device_identifier_type": "= (page_83[1] & 0x0f)",
            "transport_dump_vpd_ident_type(vpd, NULL, 0)": "!=null"
        }
    }
},

{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
        "post": {
            "vpd->device_identifier_type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]"
        }
    }
},
{
    "kprobe:transport_set_vpd_ident_type": {
        "description": "Set the device identifier type in the VPD structure.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        }
    }
},






{
    "kretprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "data_length": ">=0",
            "task_attr": ">=0",
            "data_dir": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd.",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "data_length": ">=0",
            "task_attr": ">=0",
            "data_dir": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "!=null",
            "gfp": "!=null",
            "tag": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "!=null",
            "gfp": "!=null",
            "tag": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:transport_get_sense_buffer": {
        "description": "Used when asking transport to copy Sense Data from the underlying LinuxSCSI struct scsi_cmnd",
        "pre": {
            "cmd": "!=null",
            "return_value": "!=null",
            "cmd->sense_reason": "valid_value"
        }
    }
},



{
    "kretprobe:transport_kmap_data_sg": {
        "description": "Transport kmap data scatterlist",
        "pre": {
            "cmd->t_data_nents": "==0",
            "sg": "!=null",
            "cmd->t_data_nents": "==1",
            "kmap(sg_page(sg)) + sg->offset": "!=null"
        }
    }
},
{
    "kprobe:transport_kmap_data_sg": {
        "description": "Map scatterlist data to pages for a SCSI command.",
        "pre": {
            "cmd->t_data_nents": "==0",
            "sg": "!=null",
            "cmd->t_data_nents": "==1",
            "kmap(sg_page(sg)) + sg->offset": "!=null"
        }
    }
},
{
    "kretprobe:transport_generic_new_cmd": {
        "description": "Handle new command in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    },
    "kprobe:transport_generic_request_failure": {
        "description": "Handle request failure in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "ret": "!=0"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:transport_generic_map_mem_to_cmd": {
        "description": "Maps memory to the command structure in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    }
},

{
    "kprobe:transport_generic_free_cmd": {
        "description": "Free a transport generic command",
        "pre": {
            "cmd": "!=null",
            "wait_for_tasks": "int",
            "cmd->CMD_T_TAS": "bool",
            "cmd->queue_status": "!=null when cmd->CMD_T_TAS",
            "cmd->aborted_task": "!=null when !cmd->CMD_T_TAS",
            "target_handle_abort": "!=null when !cmd->CMD_T_TAS"
        }
    }
},
{
    "kretprobe:target_submit_prep": {
        "description": "Prepare cmd for submission",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0",
            "sgl_prot": "!=null",
            "sgl_prot_count": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:target_submit_prep": {
        "description": "Prepare cmd for submission",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0",
            "sgl_prot": "!=null",
            "sgl_prot_count": ">=0",
            "gfp": ">=0"
        }
    }
},




{
    "kretprobe:target_free_cmd_counter": {
        "description": "Free the command counter object if it is not stopped.",
        "pre": {
            "!atomic_read(&cmd_cnt->stopped)": true,
            "percpu_ref_put(&cmd_cnt->refcnt)": true,
            "percpu_ref_exit(&cmd_cnt->refcnt)": true
        }
    }
},
{
    "kprobe:target_free_cmd_counter": {
        "description": "Free the command counter if it is not stopped.",
        "pre": {
            "!atomic_read(&cmd_cnt->stopped)": true,
            "percpu_ref_put(&cmd_cnt->refcnt)": true,
            "percpu_ref_exit(&cmd_cnt->refcnt)": true
        }
    }
},
{
    "kretprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kretprobe:transport_cmd_check_stop_to_fabric": {
        "description": "Check if the transport command should stop to fabric.",
        "pre": {
            "cmd": "!=null"
        },
        "ret": {
            "value": ">=0"
        }
    }
},
{
    "kprobe:transport_cmd_check_stop_to_fabric": {
        "description": "Check if the transport command should stop to fabric.",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:target_submit": {
        "description": "Perform final initialization and submit cmd to LIO core",
        "pre": {
            "se_cmd": "!=null"
        },
        "post": {
            "return": "-EIO"
        }
    }
},
{
    "kprobe:target_submit": {
        "description": "Perform final initialization and submit cmd to LIO core",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kretprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator",
        "pre": {
            "cmd": "!=null",
            "cmd->scsi_command": "!=null",
            "cmd->scsi_command->cmnd": "!=null",
            "cmd->scsi_command->cmnd_len": ">0",
            "cmd->scsi_command->cmnd_len": "<=MAX_COMMAND_SIZE"
        }
    }
},
{
    "kretprobe:failure:INIT_WORK(&se_cmd->work, target_complete_tmr_failure);schedule_work(&se_cmd->work);return 0;}EXPORT_SYMBOL(target_submit_tmr);/* * Handle SAM-esque emulation for generic transport request failures. `": {
        "description": "For callback during failure handling, push this work off to process context with TMR_LUN_DOES_NOT_EXIST status.",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kprobe:failure:INIT_WORK(&se_cmd->work, target_complete_tmr_failure);schedule_work(&se_cmd->work);return 0;}EXPORT_SYMBOL(target_submit_tmr);/* * Handle SAM-esque emulation for generic transport request failures. `": {
        "description": "For callback during failure handling, push this work off to process context with TMR_LUN_DOES_NOT_EXIST status.",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kretprobe:num_blocks = get_unaligned_be32(&cmd->t_task_cdb[28])": {
        "description": "Use the explicit range when non zero is supplied, otherwise calculate the remaining range based on ->get_blocks() - starting LBA.",
        "pre": {
            "cmd": "!=null",
            "cmd->t_task_cdb": "!=null",
            "cmd->t_task_cdb[28]": "!=null",
            "cmd->t_task_cdb[0]": "in [WRITE_SAME, WRITE_SAME_16]",
            "cmd->t_task_cdb[7]": "!=null when cmd->t_task_cdb[0] == WRITE_SAME",
            "cmd->t_task_cdb[10]": "!=null when cmd->t_task_cdb[0] == WRITE_SAME_16"
        }
    }
},
{
    "kprobe:num_blocks = get_unaligned_be32(&cmd->t_task_cdb[28]);/* * Use the explicit range when non zero is supplied, otherwise calculate * the remaining range based on ->get_blocks() - starting LBA. */": {
        "description": "This function retrieves the number of blocks from the command buffer.",
        "pre": {
            "cmd->t_task_cdb[0]": "== WRITE_SAME",
            "num_blocks": "!= null"
        }
    }
},
{
    "kretprobe:sbc_parse_cdb": {
        "description": "Parse SCSI command CDB",
        "pre": {
            "sectors": ">1"
        }
    }
},
{
    "kprobe:sbc_parse_cdb": {
        "description": "Parse SCSI command descriptor block (CDB) in sbc_parse_cdb function.",
        "pre": {
            "sectors": ">1"
        }
    }
},
{
    "kretprobe:core_alua_check_nonop_delay": {
        "description": "Check if the ALUA ActiveNonOptimized access state delay is enabled.",
        "pre": {
            "cmd": {
                "alua_nonop_delay": "==null"
            }
        }
    }
},
{
    "kprobe:core_alua_check_nonop_delay": {
        "description": "Check if the ALUA ActiveNonOptimized access state delay is enabled.",
        "pre": {
            "cmd": {
                "alua_nonop_delay": "==null"
            }
        }
    }
},
{
    "kretprobe:if (se_cmd->orig_fe_lun != 0)": {
        "description": "Check if orig_fe_lun is not equal to 0",
        "pre": {
            "orig_fe_lun": "!= 0"
        }
    }
},
{
    "if (se_cmd->orig_fe_lun != 0)": {
        "description": "Check if orig_fe_lun is not equal to zero.",
        "pre": {
            "se_cmd->orig_fe_lun": "!= 0"
        }
    }
},
{
    "kretprobe:target_configure_unmap_from_queue": {
        "description": "Configure unmap from queue for target",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null",
            "block_size": "!=null",
            "bdev_max_discard_sectors(bdev)": "!=0",
            "attrib->max_unmap_lba_count": "= bdev_max_discard_sectors(bdev) >> (ilog2(block_size) - 9)"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:target_configure_unmap_from_queue": {
        "description": "Configure unmap from queue for the target.",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null",
            "block_size": "!=null",
            "bdev_max_discard_sectors(bdev)": "!=0",
            "attrib->max_unmap_lba_count": "= bdev_max_discard_sectors(bdev) >> (ilog2(block_size) - 9)"
        }
    }
},
{
    "kretprobe:if (cdb[0] == REPORT_LUNS)": {
        "description": "Emulate the response for REPORT LUN pass everything else up.",
        "pre": {
            "cdb": {
                "index": 0,
                "value": "REPORT_LUNS"
            }
        }
    }
},

{
    "kretprobe:rcu_barrier();kfree(t->tf_tpg_base_cit.ct_attrs);kfree(t->tf_ops);kfree(t);return;}}mutex_unlock(&g_tf_lock);}EXPORT_SYMBOL(target_unregister_template": {
        "description": "Unregister a target template from the target fabric.",
        "pre": {
            "fo": "!=null",
            "t": "!=null",
            "t->tf_ops->fabric_name": "==fo->fabric_name",
            "atomic_read(&t->tf_access_cnt)": "==0"
        }
    }
},
{
    "kprobe:rcu_barrier": {
        "description": "Wait for any outstanding fabric se_deve_entry->rcu_head callbacks to complete post kfree_rcu(), before allowing fabric driver unload of TFO->module to proceed.",
        "pre": {
            "fo": "!=null",
            "t": "!=null",
            "t->tf_tpg_base_cit.ct_attrs": "!=null",
            "t->tf_ops": "!=null",
            "g_tf_lock": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Free the memory allocated for the given pointer.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return from the function.",
        "pre": {}
    },
    "kprobe:mutex_unlock": {
        "description": "Release the lock held by the given mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL": {
        "description": "Export a symbol for use by other modules.",
        "pre": {
            "symbol": "!=null"
        }
    }
},
{
    "kretprobe:rcu_barrier();kfree(tb);return;}}mutex_unlock(&backend_mutex);}EXPORT_SYMBOL(target_backend_unregister": {
        "description": "Unregister a target backend",
        "pre": {
            "ops": "!=null",
            "tb": "!=null",
            "backend_mutex": "locked",
            "backend_list": "contains(tb)",
            "tb->ops": "==ops",
            "tb->list": "in backend_list",
            "target_backend_ops->owner": "not null",
            "target_backend_ops->owner": "not unloaded",
            "target_backend_ops->owner": "not in call_rcu()",
            "target_backend_ops->owner": "not in rcu_head callbacks"
        }
    }
},
{
    "kprobe:rcu_barrier();kfree(tb);return;}}mutex_unlock(&backend_mutex);}EXPORT_SYMBOL(target_backend_unregister": {
        "description": "Wait for any outstanding backend driver ->rcu_head callbacks to complete post TBO->free_device() -> call_rcu(), before allowing backend driver module unload of target_backend_ops->owner to proceed.",
        "pre": {
            "ops": "!=null",
            "tb": "!=null",
            "backend_mutex": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_sequence_cmd": {
        "description": "",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": "!=null",
            "ret": "in [CMDSN_NORMAL_OPERATION, CMDSN_HIGHER_THAN_EXP, CMDSN_LOWER_THAN_EXP, CMDSN_MAXCMDSN_OVERRUN]",
            "reject": "in [true, false]",
            "reason": "in [ISCSI_REASON_BOOKMARK_NO_RESOURCES]",
            "cmdsn_ret": "in [CMDSN_NORMAL_OPERATION, CMDSN_HIGHER_THAN_EXP, CMDSN_LOWER_THAN_EXP, CMDSN_MAXCMDSN_OVERRUN]",
            "cmd->i_state": "in [ISTATE_REMOVE]"
        }
    }
},
{
    "kprobe:iscsit_sequence_cmd": {
        "description": "Function to sequence commands in iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_allocate_cmd": {
        "description": "Allocate an iSCSI command structure.",
        "pre": {
            "conn": "!=null",
            "state": "int"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iscsit_allocate_cmd": {
        "description": "Allocate an iscsit_cmd structure for the given iscsit_conn and state.",
        "pre": {
            "conn": "!=null",
            "state": "int"
        }
    }
},
{
    "kretprobe:iscsit_setup_scsi_cmd": {
        "description": "Check if the flags in the iscsi_scsi_req structure satisfy the condition.",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "not in [ISCSI_FLAG_CMD_WRITE, ISCSI_FLAG_CMD_FINAL]"
        }
    }
},
{
    "kprobe:iscsit_setup_scsi_cmd": {
        "description": "Setup SCSI command for iSCSI target",
        "pre": {
            "hdr": {
                "flags": {
                    "&": {
                        "ISCSI_FLAG_CMD_WRITE": "0",
                        "ISCSI_FLAG_CMD_FINAL": "0"
                    }
                }
            }
        }
    }
},
{
    "kretprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->immediate_data": "==null"
        }
    }
},
{
    "kprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->immediate_data": "==null"
        }
    }
},
{
    "kretprobe:atomic_long_add": {
        "description": "Add the payload length to the received data octets in the session.",
        "pre": {
            "payload_length": "!=null",
            "conn->sess->rx_data_octets": "!=null",
            "hdr->itt": "!=null",
            "hdr->ttt": "!=null",
            "hdr->datasn": "!=null",
            "ntohl(hdr->offset)": "!=null",
            "conn->cid": "!=null",
            "cmd->cmd_flags": "!=null"
        }
    }
},
{
    "kprobe:atomic_long_add": {
        "description": "Add a value to an atomic long variable.",
        "pre": {
            "payload_length": "!=null",
            "&conn->sess->rx_data_octets": "!=null",
            "hdr->itt": "!=null",
            "hdr->ttt": "!=null",
            "hdr->datasn": "!=null",
            "ntohl(hdr->offset)": "!=null",
            "payload_length": "!=null",
            "conn->cid": "!=null",
            "cmd->cmd_flags & ICF_GOT_LAST_DATAOUT": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_check_post_dataout": {
        "description": "Increment post receive data and CRC values or perform within-command recovery.",
        "pre": {
            "cmd": "!=null",
            "hdr": "!=null",
            "data_crc_failed": "bool"
        },
        "post": {
            "rc": "in [DATAOUT_NORMAL, DATAOUT_WITHIN_COMMAND_RECOVERY, DATAOUT_SEND_R2T]"
        }
    }
},

{
    "kretprobe:if (hdr->ttt == cpu_to_be32(0xFFFFFFFF))": {
        "description": "Check if ttt is equal to 0xFFFFFFFF",
        "pre": {
            "hdr": "!=null",
            "ttt": "==cpu_to_be32(0xFFFFFFFF)"
        }
    }
},
{
    "if (hdr->ttt == cpu_to_be32(0xFFFFFFFF))": {
        "description": "Check if hdr->ttt is equal to cpu_to_be32(0xFFFFFFFF).",
        "pre": {
            "hdr->ttt": "== cpu_to_be32(0xFFFFFFFF)"
        }
    }
},


{
    "kretprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handle Task Management Command in iSCSI Target",
        "pre": {
            "function": "!= ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handle iSCSI task management command.",
        "pre": {
            "function": "!= ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kretprobe:text_ptr = strchr(text_in, '=');BUG_ON(!text_ptr);if (!strncmp(\"=All\", text_ptr, 5))": {
        "description": "This condition checks if the text_ptr is found and if the first 5 characters after text_ptr are equal to \"=All\".",
        "pre": {
            "text_in": "!=null",
            "text_ptr": "!=null",
            "strncmp_result": "==0"
        }
    }
},
{
    "kprobe:iscsit_process_text_cmd": {
        "description": "Process text command in iSCSI target",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->text_in_ptr": "!=null",
            "strchr(cmd->text_in_ptr, '=')": "!=null",
            "strncmp(strchr(cmd->text_in_ptr, '='), \"=All\", 5)": "true"
        }
    }
},
{
    "kretprobe:iscsit_handle_logout_cmd": {
        "description": "Handle logout command in the iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn_ret": "int",
            "logout_remove": "int",
            "reason_code": "u8",
            "hdr": "struct iscsi_logout",
            "tiqn": "struct iscsi_tiqn",
            "tiqn->logout_stats.lock": "spinlock_t",
            "hdr->flags": "int",
            "tiqn->logout_stats.normal_logouts": "int",
            "tiqn->logout_stats.abnormal_logouts": "int",
            "hdr->itt": "int",
            "hdr->cmdsn": "int",
            "hdr->exp_statsn": "int",
            "hdr->cid": "u16",
            "conn->cid": "u16",
            "conn->conn_state": "int",
            "cmd->iscsi_opcode": "int",
            "cmd->i_state": "int",
            "cmd->immediate_cmd": "int",
            "conn->sess->init_task_tag": "int",
            "cmd->init_task_tag": "int",
            "cmd->targ_xfer_tag": "int",
            "cmd->cmd_sn": "int",
            "cmd->exp_stat_sn": "int",
            "cmd->logout_cid": "u16",
            "cmd->logout_reason": "u8",
            "cmd->data_direction": "int"
        }
    }
},
{
    "kprobe:iscsit_handle_logout_cmd": {
        "description": "Handle logout command in the iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn_ret": "int",
            "logout_remove": "int",
            "reason_code": "u8",
            "hdr": "struct iscsi_logout",
            "tiqn": "struct iscsi_tiqn",
            "tiqn->logout_stats.lock": "spinlock_t",
            "hdr->flags": "u8",
            "tiqn->logout_stats.normal_logouts": "int",
            "tiqn->logout_stats.abnormal_logouts": "int",
            "hdr->itt": "u32",
            "hdr->cmdsn": "u32",
            "hdr->exp_statsn": "u32",
            "hdr->cid": "u16",
            "conn->cid": "u16",
            "conn->conn_state": "TARG_CONN_STATE_LOGGED_IN",
            "cmd->iscsi_opcode": "ISCSI_OP_LOGOUT",
            "cmd->i_state": "ISTATE_SEND_LOGOUTRSP",
            "cmd->immediate_cmd": "int",
            "cmd->init_task_tag": "u32",
            "cmd->targ_xfer_tag": "0xFFFFFFFF",
            "cmd->cmd_sn": "be32_to_cpu(hdr->cmdsn)",
            "cmd->exp_stat_sn": "be32_to_cpu(hdr->exp_statsn)",
            "cmd->logout_cid": "be16_to_cpu(hdr->cid)",
            "cmd->logout_reason": "reason_code",
            "cmd->data_direction": "DMA_NONE"
        }
    }
},
{
    "kretprobe:switch (hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK)": {
        "description": "Handle ISCSI_FLAG_SNACK_TYPE_MASK in the switch statement.",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "& ISCSI_FLAG_SNACK_TYPE_MASK != 0",
            "hdr->itt": "!=null",
            "hdr->exp_statsn": "!=null",
            "hdr->begrun": "!=null",
            "hdr->runlength": "!=null",
            "conn->cid": "!=null"
        }
    }
},
{
    "kprobe:iscsit_handle_snack": {
        "description": "Handle ISCSI_INIT_SNACK request",
        "pre": {
            "conn": "!=null",
            "buf": "!=null",
            "hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK": "in [SNACK_DATA, SNACK_R2T]"
        }
    }
},




{
    "kretprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for iSCSI.",
        "pre": {
            "cmd": "!=null",
            "conn": "!=null",
            "hdr": "!=null",
            "network_transport": "in [ISCSI_TCP, ISCSI_UDP, ISCSI_SCTP]"
        },
        "post": {
            "cmd->maxcmdsn_inc": "0",
            "hdr->exp_cmdsn": "cpu_to_be32(conn->sess->exp_cmd_sn)",
            "hdr->max_cmdsn": "cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn))",
            "pr_debug": "\"Built Text Response: ITT: 0x%08x, TTT: 0x%08x, StatSN: 0x%08x, Length: %u, CID: %hu F: %d C: %d\\n\", cmd->init_task_tag, cmd->targ_xfer_tag, cmd->stat_sn, text_length, conn->cid, !!(hdr->flags & ISCSI_FLAG_CMD_FINAL), !!(hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)",
            "return": "text_length + padding"
        }
    }
},
{
    "kprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for iSCSI target.",
        "pre": {
            "cmd": {
                "maxcmdsn_inc": 0
            },
            "hdr": {
                "exp_cmdsn": "cpu_to_be32(conn->sess->exp_cmd_sn)",
                "max_cmdsn": "cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn))",
                "flags": "(hdr->flags & ISCSI_FLAG_CMD_FINAL) ? ISCSI_FLAG_CMD_FINAL : ISCSI_FLAG_TEXT_CONTINUE"
            },
            "conn": {
                "sess": {
                    "exp_cmd_sn": "!=null",
                    "max_cmd_sn": "!=null"
                }
            }
        }
    }
},

{
    "kprobe:iscsit_thread_reschedule": {
        "description": "Reschedule the iscsit_thread_check_cpumask function for the given connection.",
        "pre": {
            "conn": "!=null"
        }
    }
},



{
    "kprobe:timeout": {
        "description": "Assign the value 100000 to timeout.",
        "pre": {
            "timeout": "==100000"
        }
    },
    "kprobe:interrupt_data[0][0]": {
        "description": "Assign the value 1 to interrupt_data[0][0].",
        "pre": {
            "interrupt_data[0][0]": "==1"
        }
    },
    "kprobe:loop_condition": {
        "description": "Check the loop condition.",
        "pre": {
            "interrupt_data[0][0]": "!=0",
            "pmu_state": "!=idle"
        }
    }
},
{
    "kretprobe:req->data[0] = PMU_ADB_CMD;req->nbytes += 2;req->reply_expected = 1;req->reply_len = 0;ret = pmu_queue_request(req);break;}if (ret)": {
        "description": "This is the kretprobe function for the given code snippet.",
        "pre": {
            "req->data[0]": "= PMU_ADB_CMD",
            "req->nbytes": "+= 2",
            "req->reply_expected": "= 1",
            "req->reply_len": "= 0",
            "ret": "= pmu_queue_request(req)"
        }
    }
},

{
    "kretprobe:low_sleep_handler": {
        "description": "This function is a low-level sleep handler.",
        "pre": {},
        "post": {}
    },
    "kretprobe:enable_kernel_altivec": {
        "description": "This function enables the kernel's AltiVec support.",
        "pre": {},
        "post": {}
    },
    "kretprobe:enable_kernel_fp": {
        "description": "This function enables the kernel's floating-point support.",
        "pre": {},
        "post": {}
    },
    "kretprobe:pmu_polled_request": {
        "description": "This function handles polled requests for the PMU.",
        "pre": {
            "DEBUG_SLEEP": "defined"
        },
        "post": {
            "req": "!=null"
        }
    },
    "kretprobe:pmu_blink": {
        "description": "This function blinks the PMU.",
        "pre": {},
        "post": {
            "n": "is_integer"
        }
    }
},
{
    "kprobe:low_sleep_handler": {
        "description": "Handler for low sleep.",
        "pre": {}
    }
},




{
    "kretprobe:pmu_handle_data": {
        "description": "Handle data from an ADB command",
        "pre": {
            "data": "!=null",
            "len": ">=0"
        }
    }
},



{
    "kretprobe:init_pmu": {
        "description": "Initialize the PMU.",
        "pre": {},
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:init_pmu": {
        "description": "Initialize the PMU.",
        "pre": {}
    }
},
{
    "kretprobe:smu_queue_cmd": {
        "description": "Queue a command in the SMU command list.",
        "pre": {
            "smu_irq_inited": "==false",
            "smu->db_irq": "==false"
        },
        "post": {
            "cmd": "!=null",
            "cmd->data_len": "<= SMU_MAX_DATA",
            "cmd->reply_len": "<= SMU_MAX_DATA",
            "cmd->status": "==1",
            "smu->cmd_cur": "==null"
        }
    }
},
{
    "kprobe:smu_queue_cmd": {
        "description": "Queue a command in the SMU command list.",
        "pre": {
            "smu_irq_inited": "==false",
            "smu->db_irq": "==false",
            "cmd->data_len": "<= SMU_MAX_DATA",
            "cmd->reply_len": "<= SMU_MAX_DATA"
        }
    }
},

{
    "kprobe:find_via_cuda": {
        "description": "This is the find_via_cuda function.",
        "pre": {
            "CONFIG_MAC": "defined"
        }
    }
},
"ret": "is_int",
{
    "kprobe:macio_register_driver": {
        "description": "Registers a new MacIO device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kprobe:macio_unregister_driver": {
        "description": "Unregisters a new MacIO device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:macio_request_resource": {
        "description": "Request an MMIO resource",
        "pre": {
            "dev": "!=null",
            "resource_no": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:macio_request_resource": {
        "description": "Request an MMIO resource",
        "pre": {
            "dev": "!=null",
            "resource_no": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:macio_request_resources": {
        "description": "Reserve all memory resources",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:macio_request_resources": {
        "description": "Reserve all memory resources",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kretprobe:macio_release_resources": {
        "description": "Release reserved memory resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_resources": {
        "description": "Release reserved memory resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:for (i = 1; i < 16; i++)": {
        "description": "Loop from 1 to 15",
        "pre": {
            "i": ">=1",
            "i": "<16"
        }
    }
},
{
    "kprobe:for (i = 1; i < 16; i++)": {
        "description": "Loop from 1 to 15",
        "pre": {
            "i": ">=1",
            "i": "<16"
        }
    }
},


{
    "kretprobe:is_vmalloc_addr": {
        "description": "Check if the given CPU address is in the vmalloc region.",
        "pre": {
            "cpu_addr": "!=null",
            "cpu_addr": "in vmalloc region",
            "cpu_addr": "not in ioremapped region",
            "cpu_addr": "not in dma_alloc_coherent region",
            "cpu_addr": "not in generic dma memory pool"
        }
    }
},
{
    "kprobe:is_vmalloc_addr": {
        "description": "Check if the given CPU address is in the vmalloc region.",
        "pre": {
            "cpu_addr": "!=null",
            "cpu_addr": "in vmalloc region",
            "cpu_addr": "not in ioremapped region",
            "cpu_addr": "not in dma_alloc_coherent region",
            "cpu_addr": "not in generic dma memory pool"
        }
    }
},
{
    "kretprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "len": ">=0",
            "is_iomem": "!=null"
        }
    }
},
{
    "kprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "len": ">=0",
            "is_iomem": "!=null"
        }
    }
},


{
    "kretprobe:rproc_of_resm_mem_entry_init": {
        "description": "Allocate and initialize rproc_mem_entry struct from a reserved memory phandle.",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": "!=null",
            "len": ">=0",
            "da": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rproc_of_resm_mem_entry_init": {
        "description": "Allocate and initialize rproc_mem_entry struct from a reserved memory phandle.",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": "!=null",
            "len": "!=null",
            "da": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:rproc_of_parse_firmware": {
        "description": "Parse and return the firmware-name",
        "pre": {
            "dev": "!=null",
            "index": "int",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:rproc_of_parse_firmware": {
        "description": "Parse and return the firmware-name",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources for rproc.",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources for rproc.",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_boot": {
        "description": "Initiate the process of attaching to a detached remote processor.",
        "pre": {
            "rproc->state": "== RPROC_DETACHED"
        },
        "post": {
            "return": "rproc_boot(rproc)"
        }
    }
},

{
    "kretprobe:rproc_shutdown": {
        "description": "Shuts down the remote processor.",
        "pre": {
            "rproc": {
                "cached_table": "!=null",
                "table_ptr": "!=null",
                "table_sz": "!=null"
            },
            "GFP_KERNEL": "in [GFP_KERNEL]"
        },
        "post": {
            "return_value": "in [-ENOMEM]"
        }
    }
},

{
    "kretprobe:rproc_detach": {
        "description": "Detach the resource table from the remote processor.",
        "pre": {
            "rproc": "!=null",
            "rproc->cached_table": "!=null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": "!=null",
            "GFP_KERNEL": "!=null"
        },
        "post": {
            "rproc->cached_table": "==null",
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:rproc_detach": {
        "description": "Detach the resource table from the remote processor.",
        "pre": {
            "rproc": "!=null",
            "rproc->cached_table": "==null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": "!=null"
        }
    }
},
{
    "kretprobe:rproc_get_by_phandle": {
        "description": "Get the rproc handle associated with the given phandle.",
        "pre": {
            "phandle": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},

{
    "kretprobe:rproc_set_firmware": {
        "description": "Assign a new firmware to the rproc handle.",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:rproc_set_firmware": {
        "description": "Assign a new firmware to the rproc handle.",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:devm_rproc_add": {
        "description": "Resource managed rproc_add().",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:devm_rproc_add": {
        "description": "Resource managed rproc_add().",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        }
    }
},


{
    "kretprobe:if (rproc->table_ptr)": {
        "description": "Reset the virtio device section in the cached resource table only if there is one to work with.",
        "pre": {
            "rproc": "!=null",
            "rproc->table_ptr": "!=null"
        }
    }
},
{
    "kprobe:if (rproc->table_ptr)": {
        "description": "Check if rproc->table_ptr is not NULL.",
        "pre": {
            "rproc": {
                "table_ptr": "!=null"
            }
        }
    }
},
{
    "kretprobe:devm_rproc_alloc": {
        "description": "Resource managed rproc_alloc()",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:devm_rproc_alloc": {
        "description": "Resource managed rproc_alloc()",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc.",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_enable_iommu": {
        "description": "Enable IOMMU for the given rproc.",
        "pre": {
            "rproc": "!=null"
        },
        "post": {
            "return_value": "-ENOSYS"
        }
    }
},

{
    "kretprobe:rproc_coredump_add_segment": {
        "description": "Add segment of device memory to coredump",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_add_segment": {
        "description": "Add segment of device memory to coredump",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_add_custom_segment": {
        "description": "Add device memory to the list of segments to be included in the coredump and associate the segment with the given custom dump function and private data.",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null",
            "dumpfn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_add_custom_segment": {
        "description": "Add custom coredump segment",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null",
            "dumpfn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_set_elf_info": {
        "description": "Set coredump elf information",
        "pre": {
            "rproc": "!=null",
            "class": "!=null",
            "machine": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_set_elf_info": {
        "description": "Set coredump elf information",
        "pre": {
            "rproc": "!=null",
            "class": "!=null",
            "machine": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_using_sections": {
        "description": "Perform coredump using section headers",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_using_sections": {
        "description": "Perform coredump using section headers",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:st_slim_rproc_alloc": {
        "description": "Allocate and initialize slim rproc for use by device drivers based on the SLIM core.",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:st_slim_rproc_alloc": {
        "description": "Allocate and initialise slim rproc.",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:st_slim_rproc_put": {
        "description": "Put slim rproc resources",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kprobe:st_slim_rproc_put": {
        "description": "Put slim rproc resources",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_vq_interrupt": {
        "description": "Tell remoteproc that a virtqueue is interrupted",
        "pre": {
            "rproc": "!=null",
            "notifyid": "!=null"
        },
        "post": {
            "return": "in [IRQ_NONE, IRQ_HANDLED]"
        }
    }
},
{
    "kprobe:rproc_vq_interrupt": {
        "description": "Tell remoteproc that a virtqueue is interrupted",
        "pre": {
            "rproc": "!=null",
            "notifyid": "!=null"
        },
        "post": {
            "return": "in [IRQ_NONE, IRQ_HANDLED]"
        }
    }
},
{
    "kretprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_load_rsc_table": {
        "description": "Load the resource table inside the remote processor's firmware, update @table_ptr.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:rproc_elf_load_rsc_table": {
        "description": "Load the resource table inside the remote processor's firmware, update @table_ptr.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "Find the loaded resource table",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "Find the loaded resource table",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_user": {
        "description": "Get descriptor from user space.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "getrange": "!=null",
            "head": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]"
        }
    }
},

{
    "kretprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors.",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "true"
        }
    }
},
{
    "kprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors.",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_user": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_user": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_user": {
        "description": "Complete the user's access to the vring buffer.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_user": {
        "description": "Complete the user's consumption of completed buffers in the vring.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "called"
        }
    }
},
{
    "kretprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_kern": {
        "description": "Get descriptor from vringh",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]",
            "riov": "reusable",
            "wiov": "reusable"
        }
    }
},
{
    "kprobe:vringh_getdesc_kern": {
        "description": "Get the descriptor from the vringh structure and allocate memory for riov and wiov if needed. Returns 0 if there was no descriptor, 1 if there wa or -errno.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "any value"
        }
    }
},
{
    "kretprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_kern": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_kern": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_kern": {
        "description": "Complete a virtio ring operation in the kernel.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_kern()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_kern": {
        "description": "Completes the processing of a virtio ring buffer in the kernel.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_kern()": "called after this function"
        }
    }
},
{
    "kretprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "is_error(num)"
        }
    }
},
{
    "kprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "boolean",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "is boolean",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_iotlb": {
        "description": "Get descriptor from vringh and handle IOTLB.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]",
            "riov": "!=null",
            "wiov": "!=null"
        }
    }
},
{
    "kprobe:vringh_getdesc_iotlb": {
        "description": "Get descriptor from the vringh iotlb.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_iotlb": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_iotlb": {
        "description": "We want to know if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_iotlb": {
        "description": "Complete IOTLB operation for a vringh instance.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_iotlb()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_iotlb": {
        "description": "Complete IOTLB operation for a vringh instance.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_iotlb": "true"
        }
    }
},


{
    "kretprobe:cmd->param1 = CONFIGURATION_ZONE;cmd->param2 = cpu_to_le16(DEVICE_LOCK_ADDR);cmd->count = READ_COUNT;atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_READ;cmd->rxsize = READ_RSP_SIZE;}EXPORT_SYMBOL(atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "pre": {
            "cmd->word_addr": "!=null",
            "cmd->opcode": "!=null"
        }
    }
},
{
    "kprobe:cmd->param1 = CONFIGURATION_ZONE;cmd->param2 = cpu_to_le16(DEVICE_LOCK_ADDR);cmd->count = READ_COUNT;atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_READ;cmd->rxsize = READ_RSP_SIZE;}EXPORT_SYMBOL(atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "pre": {
            "cmd->word_addr": "!=null",
            "cmd->opcode": "!=null"
        }
    }
},
{
    "kretprobe:cmd->param2 = cpu_to_le16(keyid);atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_GENKEY;cmd->rxsize = GENKEY_RSP_SIZE;": {
        "description": "Initialize the genkey command in the atmel_i2c driver.",
        "pre": {
            "cmd": "!=null",
            "keyid": "!=null",
            "cmd->word_addr": "==COMMAND",
            "cmd->count": "==GENKEY_COUNT",
            "cmd->opcode": "==OPCODE_GENKEY",
            "cmd->param1": "==GENKEY_MODE_PRIVATE"
        }
    }
},
{
    "kprobe:cmd->param2 = cpu_to_le16(keyid);atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_GENKEY;cmd->rxsize = GENKEY_RSP_SIZE;": {
        "description": "Initialize the genkey command in the Atmel I2C driver.",
        "pre": {
            "cmd": "!=null",
            "keyid": "!=null",
            "cmd->word_addr": "COMMAND",
            "cmd->count": "GENKEY_COUNT",
            "cmd->opcode": "OPCODE_GENKEY",
            "cmd->param1": "GENKEY_MODE_PRIVATE"
        }
    }
},


{
    "kretprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response.",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response.",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:i2c_priv->wake_token_sz": {
        "description": "Set the value of i2c_priv->wake_token_sz using atmel_i2c_wake_token_sz function.",
        "pre": {
            "i2c_priv": "!=null",
            "bus_clk_rate": "!=null"
        }
    },
    "kretprobe:memset(i2c_priv->wake_token, 0, sizeof(i2c_priv->wake_token))": {
        "description": "Set the value of i2c_priv->wake_token to 0 using memset function.",
        "pre": {
            "i2c_priv->wake_token": "!=null"
        }
    },
    "kretprobe:atomic_set(&i2c_priv->tfm_count, 0)": {
        "description": "Set the value of i2c_priv->tfm_count to 0 using atomic_set function.",
        "pre": {
            "i2c_priv": "!=null"
        }
    },
    "kretprobe:i2c_set_clientdata(client, i2c_priv)": {
        "description": "Set the client data of i2c_priv using i2c_set_clientdata function.",
        "pre": {
            "client": "!=null",
            "i2c_priv": "!=null"
        }
    },
    "kretprobe:return device_sanity_check(client)": {
        "description": "Return the result of device_sanity_check function.",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:i2c_priv->wake_token_sz = atmel_i2c_wake_token_sz(bus_clk_rate);memset(i2c_priv->wake_token, 0, sizeof(i2c_priv->wake_token));atomic_set(&i2c_priv->tfm_count, 0);i2c_set_clientdata(client, i2c_priv);return device_sanity_check(client);": {
        "description": "Probe function for Atmel I2C driver.",
        "pre": {
            "client": "!=null",
            "client->adapter": "!=null",
            "client->adapter->dev": "!=null",
            "client->adapter->dev->parent": "!=null",
            "client->adapter->dev->parent->bus": "!=null",
            "client->adapter->dev->parent->bus->bus_type": "!=null",
            "client->adapter->dev->parent->bus->bus_type->name": "==\"i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_name": "==\"i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->name": "==\"atmel_i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->name": "==\"atmel_i2c_probe\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->map": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->key": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->value": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},

{
    "kprobe:kmap_atomic": {
        "description": "Map a page descriptor to a virtual address.",
        "pre": {
            "sg": "!=null",
            "it": "!=null",
            "it_page": "!=null"
        }
    },
    "kprobe:sg_page": {
        "description": "Get the page associated with a scatterlist entry.",
        "pre": {
            "sg": "!=null",
            "it": "!=null"
        }
    }
},
{
    "kretprobe:caam_strstatus": {
        "description": "Handle error status in the caam_strstatus function.",
        "pre": {
            "jrdev": "!=null",
            "status": "!=null",
            "error": "!=null",
            "ssrc": "status >> JRSTA_SSRC_SHIFT",
            "error_handling_function": "status_src[ssrc].report_ssed != null",
            "error_source_name": "status_src[ssrc].error"
        }
    }
},
{
    "kprobe:caam_strstatus": {
        "description": "Handle error status in the caam_strstatus function.",
        "pre": {
            "jrdev": "!=null",
            "status": "!=null",
            "error": "!=null",
            "ssrc": "status >> JRSTA_SSRC_SHIFT",
            "error_handling_function": "status_src[ssrc].report_ssed != null",
            "error_source_name": "status_src[ssrc].error"
        }
    }
},
{
    "kretprobe:edesc = aead_edesc_alloc": {
        "description": "Allocate extended descriptor",
        "pre": {
            "req": "!=null",
            "false": "not in [0, false]",
            "IS_ERR(edesc)": "==false"
        }
    },
    "kretprobe:caam_req->flc = &ctx->flc[DECRYPT]": {
        "description": "Set caam_req->flc to &ctx->flc[DECRYPT]",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null",
            "DECRYPT": "!=null"
        }
    },
    "kretprobe:caam_req->flc_dma = ctx->flc_dma[DECRYPT]": {
        "description": "Set caam_req->flc_dma to ctx->flc_dma[DECRYPT]",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null",
            "DECRYPT": "!=null"
        }
    },
    "kretprobe:caam_req->cbk = aead_decrypt_done": {
        "description": "Set caam_req->cbk to aead_decrypt_done",
        "pre": {
            "caam_req": "!=null",
            "aead_decrypt_done": "!=null"
        }
    },
    "kretprobe:caam_req->ctx = &req->base": {
        "description": "Set caam_req->ctx to &req->base",
        "pre": {
            "caam_req": "!=null",
            "req": "!=null",
            "base": "!=null"
        }
    },
    "kretprobe:caam_req->edesc = edesc": {
        "description": "Set caam_req->edesc to edesc",
        "pre": {
            "caam_req": "!=null",
            "edesc": "!=null"
        }
    },
    "kretprobe:ret = dpaa2_caam_enqueue(ctx->dev, caam_req)": {
        "description": "Set ret to dpaa2_caam_enqueue(ctx->dev, caam_req)",
        "pre": {
            "ret": "!=null",
            "ctx": "!=null",
            "dev": "!=null",
            "caam_req": "!=null"
        }
    },
    "kretprobe:ret != -EINPROGRESS && !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)": {
        "description": "Check if ret is not -EINPROGRESS and not (-EBUSY and req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)",
        "pre": {
            "ret": "!=null",
            "-EINPROGRESS": "!=null",
            "-EBUSY": "!=null",
            "req": "!=null",
            "base": "!=null",
            "flags": "!=null",
            "CRYPTO_TFM_REQ_MAY_BACKLOG": "!=null"
        }
    }
},
{
    "kprobe:aead_edesc_alloc": {
        "description": "Allocate an extended descriptor for the AEAD request.",
        "pre": {
            "req": "!=null",
            "false": "true"
        }
    },
    "kprobe:IS_ERR": {
        "description": "Check if the extended descriptor is an error.",
        "pre": {
            "edesc": "!=null"
        }
    },
    "kprobe:PTR_ERR": {
        "description": "Get the error value from the extended descriptor.",
        "pre": {
            "edesc": "!=null"
        }
    },
    "kprobe:caam_req->flc": {
        "description": "Set the flc field of caam_req to the DECRYPT flc of ctx.",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null"
        }
    },
    "kprobe:caam_req->flc_dma": {
        "description": "Set the flc_dma field of caam_req to the DECRYPT flc_dma of ctx.",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null"
        }
    },
    "kprobe:caam_req->cbk": {
        "description": "Set the cbk field of caam_req to aead_decrypt_done.",
        "pre": {
            "caam_req": "!=null"
        }
    },
    "kprobe:caam_req->ctx": {
        "description": "Set the ctx field of caam_req to the base field of req.",
        "pre": {
            "caam_req": "!=null",
            "req": "!=null"
        }
    },
    "kprobe:caam_req->edesc": {
        "description": "Set the edesc field of caam_req to edesc.",
        "pre": {
            "caam_req": "!=null",
            "edesc": "!=null"
        }
    },
    "kprobe:dpaa2_caam_enqueue": {
        "description": "Enqueue the caam_req to the dev.",
        "pre": {
            "ctx": "!=null",
            "caam_req": "!=null"
        }
    },
    "kprobe:ret": {
        "description": "Check the return value of dpaa2_caam_enqueue.",
        "pre": {
            "ret": "!=null",
            "ret": "!= -EINPROGRESS",
            "!(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)": "true"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},
{
    "cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol) with no (null) decryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},

{
    "kretprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": "integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "is boolean",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "is boolean",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "is boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "is boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "encap": "in [true, false]",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "encap": "boolean",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES AND OP_ALG_AAI_XTS"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},


{
    "kretprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0",
            "import_ctx": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0",
            "import_ctx": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_sk_hash": {
        "description": "shared descriptor for symmetric key cipher-based hash algorithms",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_sk_hash": {
        "description": "shared descriptor for symmetric key cipher-based hash algorithms",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0"
        }
    }
},
{
    "kretprobe:caam_drv_ctx_update": {
        "description": "Update the CAAM driver context",
        "pre": {
            "old_fq": "!=null"
        }
    }
},

{
    "kretprobe:caam_drv_ctx_init": {
        "description": "Initialize the caam_drv_ctx structure and perform operations on it.",
        "pre": {
            "qidev": "!=null",
            "cpu": "integer",
            "sh_desc": "integer",
            "num_words": "integer",
            "size": "integer",
            "hwdesc": "integer",
            "drv_ctx": "!=null",
            "cpus": "!=null"
        }
    }
},
{
    "kprobe:drv_ctx->prehdr[0] = cpu_to_caam32((1 << PREHDR_RSLS_SHIFT) | num_words);drv_ctx->prehdr[1] = cpu_to_caam32(PREHDR_ABS);memcpy(drv_ctx->sh_desc, sh_desc, desc_bytes(sh_desc));size = sizeof(drv_ctx->prehdr) + sizeof(drv_ctx->sh_desc);hwdesc = dma_map_single(qidev, drv_ctx->prehdr, size,DMA_BIDIRECTIONAL);if (dma_mapping_error(qidev, hwdesc))": {
        "description": "Initialize pre-header, set RSLS and SDLEN, and shared descriptor, and perform DMA mapping.",
        "pre": {
            "qidev": "!=null",
            "cpu": "!=null",
            "sh_desc": "!=null"
        }
    }
},


{
    "kretprobe:init_job_desc": {
        "description": "Initialize job description.",
        "pre": {
            "desc": "!=null",
            "info->key_mod_len": "<= CAAM_BLOB_KEYMOD_LENGTH",
            "encap": "in [true, false]",
            "op": "in [OP_PCLID_BLOB | OP_TYPE_ENCAP_PROTOCOL, OP_PCLID_BLOB | OP_TYPE_DECAP_PROTOCOL]",
            "output_len": "info->input_len + CAAM_BLOB_OVERHEAD when encap == true, info->input_len - CAAM_BLOB_OVERHEAD when encap == false",
            "desc": "!=null",
            "dma_in": "!=null",
            "dma_out": "!=null",
            "ctrlpriv": "!=null",
            "moo": "in [CSTA_MOO_SECURE, CSTA_MOO_TRUSTED]"
        }
    }
},
{
    "kprobe:init_job_desc": {
        "description": "Initialize the job description with the given parameters.",
        "pre": {
            "desc": "!=null",
            "info->key_mod_len": "<= CAAM_BLOB_KEYMOD_LENGTH",
            "encap": "in [true, false]",
            "output_len": "info->input_len + CAAM_BLOB_OVERHEAD if encap, info->input_len - CAAM_BLOB_OVERHEAD otherwise",
            "desc_bytes(desc)": ">= CAAM_BLOB_DESC_BYTES_MAX",
            "dma_mapping_error(jrdev, dma_in)": "false",
            "dma_mapping_error(jrdev, dma_out)": "false",
            "moo": "in [CSTA_MOO_SECURE, CSTA_MOO_TRUSTED]"
        }
    },
    "kprobe:append_key_as_imm": {
        "description": "Append the key as an immediate value to the job description.",
        "pre": {
            "desc": "!=null",
            "info->key_mod": "!=null",
            "info->key_mod_len": "!=null",
            "info->key_mod_len": "info->key_mod_len",
            "CLASS_2 | KEY_DEST_CLASS_REG": "!=null"
        }
    },
    "kprobe:append_seq_in_ptr_intlen": {
        "description": "Append the input sequence as a pointer with the given length to the job description.",
        "pre": {
            "desc": "!=null",
            "dma_in": "!=null",
            "info->input_len": "!=null",
            "info->input_len": "info->input_len",
            "0": "!=null"
        }
    },
    "kprobe:append_seq_out_ptr_intlen": {
        "description": "Append the output sequence as a pointer with the given length to the job description.",
        "pre": {
            "desc": "!=null",
            "dma_out": "!=null",
            "output_len": "!=null",
            "output_len": "output_len",
            "0": "!=null"
        }
    },
    "kprobe:append_operation": {
        "description": "Append the operation to the job description.",
        "pre": {
            "desc": "!=null",
            "op": "!=null"
        }
    },
    "kprobe:print_hex_dump_debug": {
        "description": "Print the hex dump debug information.",
        "pre": {
            "info->input": "!=null",
            "info->input_len": "!=null",
            "desc": "!=null",
            "desc_bytes(desc)": "!=null"
        }
    },
    "kprobe:caam_jr_enqueue": {
        "description": "Enqueue the job description to the CAAM JR device.",
        "pre": {
            "jrdev": "!=null",
            "desc": "!=null",
            "caam_blob_job_done": "!=null",
            "&testres": "!=null",
            "ret": "in [-EINPROGRES other]"
        }
    }
},


{
    "kretprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed.",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_free": {
        "description": "Free the Job Ring",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_free": {
        "description": "Free the Job Ring",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head.",
        "pre": {
            "dev": "!=null",
            "desc": "!=null",
            "cbk": "!=null",
            "areq": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head.",
        "pre": {
            "dev": "!=null",
            "desc": "!=null",
            "cbk": "!=null",
            "areq": "!=null"
        }
    }
},
{
    "kretprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_alloc_device": {
        "description": "Allocate rdi",
        "pre": {
            "size": "!=null",
            "nports": "!=null"
        }
    }
},
{
    "kprobe:rvt_alloc_device": {
        "description": "Allocate rdi",
        "pre": {
            "size": "!=null",
            "nports": "!=null"
        }
    }
},
{
    "kretprobe:rvt_dealloc_device": {
        "description": "Deallocate the rdi structure",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_dealloc_device": {
        "description": "Deallocate the rdi structure.",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_register_device": {
        "description": "register a driver",
        "pre": {
            "rdi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:rvt_register_device": {
        "description": "Register a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_unregister_device": {
        "description": "Remove a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_unregister_device": {
        "description": "Remove a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_init_port": {
        "description": "Initialize internal data for driver port",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rvt_init_port": {
        "description": "Init internal data for driver port",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        }
    }
},
{
    "kretprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->s_lock": "unlocked",
            "qp->s_hlock": "unlocked",
            "qp->r_lock": "unlocked",
            "lastwqe": "bool",
            "qp->ibqp.device": "!=null",
            "qp->ibqp.qp_context": "!=null"
        }
    }
},
{
    "kretprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->r_rq": "!=null",
            "qp->r_rq.size": ">0",
            "qp->ibqp.recv_cq": "!=null",
            "qp->ibqp.event_handler": "!=null"
        }
    }
},
{
    "kprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->r_rq": "!=null",
            "qp->r_rq.size": ">0",
            "qp->ibqp.recv_cq": "!=null",
            "qp->ibqp.event_handler": "!=null"
        }
    }
},
{
    "kretprobe:rvt_comm_est": {
        "description": "Handle trap with QP established",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_comm_est": {
        "description": "Handle trap with QP established.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return index into ib_rvt_rnr_table",
        "pre": {
            "index": "!=null"
        }
    }
},
{
    "kprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return index into ib_rvt_rnr_table",
        "pre": {
            "index": "!=null"
        }
    }
},
{
    "kretprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP.",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP.",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kretprobe:rvt_add_rnr_timer": {
        "description": "Addstart an RNR timer on the QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null"
        }
    }
},
{
    "kprobe:rvt_add_rnr_timer": {
        "description": "Addstart an rnr timer on the QP",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null"
        }
    }
},
{
    "kretprobe:rdi->driver_f.stop_send_queue(qp);rvt_del_timers_sync(qp);/* Wait for things to stop `": {
        "description": "Stop the send queue and the retry timer",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "rdi->driver_f.stop_send_queue(qp)": "!=null",
            "rvt_del_timers_sync(qp)": "!=null",
            "rvt_stop_rc_timers(qp)": "!=null",
            "qp->s_flags": "&= ~(RVT_S_TIMER | RVT_S_ANY_WAIT)",
            "spin_unlock(&qp->s_lock)": "!=null",
            "spin_unlock(&qp->s_hlock)": "!=null",
            "spin_unlock_irq(&qp->r_lock)": "!=null"
        }
    }
},
{
    "kprobe:rdi->driver_f.stop_send_queue(qp);rvt_del_timers_sync(qp);/* Wait for things to stop": {
        "description": "Stop the send queue and the retry timer",
        "pre": {
            "qp": "!=null"
        }
    }
},




{
    "kretprobe:rvt_qp_iter_init": {
        "description": "Initializes an iterator for QP iteration.",
        "pre": {
            "rdi": "!=null",
            "v": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kprobe:rvt_qp_iter_init": {
        "description": "Initializes an iterator for QP iteration.",
        "pre": {
            "rdi": "!=null",
            "v": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter",
        "pre": {
            "iter": "!=null"
        },
        "post": {
            "iter->qp": "==0"
        }
    }
},
{
    "kprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter",
        "pre": {
            "iter": "!=null",
            "return": "in [0, 1]"
        },
        "post": {
            "iter->qp": "valid when return == 0"
        }
    }
},
{
    "kretprobe:rvt_qp_exit": {
        "description": "Clean up qps on device exit",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_qp_exit": {
        "description": "Clean up qps on device exit",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_copy_sge": {
        "description": "Copy data to SGE memory",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_copy_sge": {
        "description": "Copy data to SGE memory",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_ruc_loopback": {
        "description": "Handle UC and RC loopback requests",
        "pre": {
            "sqp": "!=null"
        }
    }
},

{
    "kretprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null",
            "qp.s_lock": "held"
        }
    }
},
{
    "kprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null",
            "qp.s_lock": "held"
        }
    }
},
{
    "kretprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kretprobe:rvt_fast_reg_mr": {
        "description": "fast register physical MR",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "!=null",
            "access": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:rvt_fast_reg_mr": {
        "description": "Fast register physical memory region.",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kretprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey",
        "pre": {
            "qp": "!=null",
            "rkey": "!=null"
        }
    }
},
{
    "kprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey",
        "pre": {
            "qp": "!=null",
            "rkey": "!=null"
        }
    }
},
{
    "kretprobe:rvt_lkey_ok": {
        "description": "Check IB SGE for validity and initialize",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "is int"
        },
        "post": {
            "return": "in [0, 1, -errno]"
        }
    }
},
{
    "kprobe:rvt_lkey_ok": {
        "description": "Check IB SGE for validity and initialize",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "is int"
        }
    }
},
{
    "kretprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual addres length, and RKEY",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">0",
            "vaddr": "!=null",
            "rkey": "!=null",
            "acc": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual addres length, and RKEY",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">=0",
            "vaddr": "!=null",
            "rkey": ">=0",
            "acc": "in [0, 1]"
        }
    }
},
{
    "kretprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GID LID.",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GID LID.",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": "!=null"
        }
    }
},
{
    "kretprobe:ib_uverbs_get_ucontext_file": {
        "description": "We do not hold the hw_destroy_rwsem lock for this flow, instead srcu is used. It does not matter if someone races this with get_context, we get NULL or valid ucontext.",
        "pre": {
            "ufile": "!=null",
            "ufile->device": "!=null",
            "ufile->device->ib_dev": "!=null",
            "ufile->device->disassociate_srcu": "!=null",
            "ucontext": "!=null"
        }
    }
},
{
    "kprobe:ib_uverbs_get_ucontext_file": {
        "description": "Get the ib_ucontext file for a given ufile.",
        "pre": {
            "ufile": "!=null",
            "ufile->ucontext": "!=null",
            "ufile->device->ib_dev": "!=null",
            "ufile->device->disassociate_srcu": "!=null",
            "ucontext": "!=null"
        }
    }
},
{
    "kretprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context",
        "pre": {
            "cq": "!=null",
            "budget": ">=0"
        }
    }
},
{
    "kprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context",
        "pre": {
            "cq": "!=null",
            "budget": ">=0"
        }
    }
},
{
    "kretprobe:__ib_alloc_cq": {
        "description": "Allocate a completion queue",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_cq": {
        "description": "Allocate a completion queue.",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:__ib_alloc_cq_any": {
        "description": "Allocate a completion queue",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "poll_ctx": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_cq_any": {
        "description": "Allocate a completion queue.",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:ib_free_cq": {
        "description": "Free a completion queue",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kprobe:ib_free_cq": {
        "description": "Free a completion queue.",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kretprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe.",
        "pre": {
            "dev": "!=null",
            "nr_cqe": "!=null",
            "comp_vector_hint": "!=null",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]"
        }
    }
},
{
    "kprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe.",
        "pre": {
            "dev": "!=null",
            "nr_cqe": "!=null",
            "comp_vector_hint": "!=null",
            "poll_ctx": "in [IB_POLL_NORMAL, IB_POLL_BATCH, IB_POLL_SOFTIRQ]"
        }
    }
},
{
    "kretprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool.",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool.",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kretprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kretprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID.",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID.",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "!=null"
        }
    }
},








{
    "kretprobe:ib_pack": {
        "description": "Pack a structure into a buffer",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_pack": {
        "description": "Pack a structure into a buffer",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_count": {
        "description": "The current usage of a specific object.",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]"
        }
    }
},
{
    "kprobe:rdma_restrack_count": {
        "description": "The current usage of specific object",
        "pre": {
            "dev": "!=null",
            "type": "in [valid values of enum rdma_restrack_type]"
        }
    }
},
{
    "kretprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource",
        "pre": {
            "res": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource",
        "pre": {
            "res": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack.",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in a fully automatic way.",
        "pre": {
            "res": "!=null",
            "type": "in [REstrack type values]"
        }
    }
},
{
    "kprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in a fully automatic way.",
        "pre": {
            "res": "!=null",
            "type": "in [REstrack type values]"
        }
    }
},
{
    "kretprobe:rdma_restrack_add": {
        "description": "Add object to the resource tracking database.",
        "pre": {
            "res": "!=null"
        }
    }
},

{
    "kretprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]",
            "id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]",
            "id": "!=null"
        },
        "post": {
            "return": "!= -ENOENT"
        }
    }
},
{
    "kretprobe:rdma_restrack_del": {
        "description": "Delete object from the resource tracking database.",
        "pre": {
            "res": "!=null"
        }
    }
},

{
    "kretprobe:sa_path_set_dmac_zero": {
        "description": "Set the destination MAC address to zero in the sa_path_rec structure.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kprobe:sa_path_set_dmac_zero(dst);}EXPORT_SYMBOL(ib_copy_path_rec_from_user": {
        "description": "Sets the destination MAC address to zero in the sa_path_rec structure.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_join_multicast": {
        "description": "Join a multicast group in the InfiniBand subnet administrator (SA) layer.",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": "!=null",
            "callback": "!=null",
            "context": "!=null",
            "dev": "!=null",
            "member": "!=null",
            "multicast": "!=null",
            "ret": "!=null",
            "dev": "!=null",
            "start_port": "!=null",
            "group": "!=null",
            "mgid": "!=null"
        },
        "post": {
            "multicast": "!=null",
            "callback": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_join_multicast": {
        "description": "Join a multicast group on the InfiniBand device.",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": "!=null",
            "callback": "!=null",
            "context": "!=null"
        }
    }
},


{
    "kretprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ndev": "optional",
            "gid_type": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ndev": "optional",
            "gid_type": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kretprobe:uverbs_uobject_put": {
        "description": "Called when the reference count is decreased and the uobject is freed.",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kprobe:uverbs_uobject_put": {
        "description": "Called when the reference count of a uobject is decreased and the uobject is freed.",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kretprobe:if_statement": {
        "description": "Check if the conditions for the if statement are met.",
        "pre": {
            "f->f_op": "!= fd_type->fops",
            "uobject->ufile": "!= ufile"
        }
    }
},

{
    "kretprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain.",
        "pre": {
            "device": "!=null",
            "flags": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain.",
        "pre": {
            "device": "!=null",
            "flags": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain.",
        "pre": {
            "pd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain.",
        "pre": {
            "pd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new new one.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new one.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "!=null",
            "udata": "any",
            "xmit_slave": "any"
        }
    }
},
{
    "kprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "!=null",
            "udata": "in [null, !=null]",
            "xmit_slave": "in [null, !=null]",
            "pd->device": "!=null",
            "pd->device->ops.create_ah": "!=null",
            "rdma_zalloc_drv_obj_gfp(device, ib_ah, ...)": "!=null",
            "ah->device": "= pd->device",
            "ah->pd": "= pd",
            "ah->type": "= ah_attr->type",
            "ah->sgid_attr": "= rdma_update_sgid_attr(ah_attr, NULL)",
            "init_attr.ah_attr": "= ah_attr",
            "init_attr.flags": "= flags",
            "init_attr.xmit_slave": "= xmit_slave",
            "device->ops.create_user_ah(ah, &init_attr, udata)": "!=null",
            "device->ops.create_ah(ah, &init_attr, NULL)": "!=null",
            "ret": "= 0 if succes else appropriate error code",
            "ah->sgid_attr": "= null if ret != 0",
            "pd->usecnt": "incremented by 1"
        }
    }
},
{
    "kretprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:if (ip6h->version != 6)return (ip4h->version == 4) ? 4 : 0;/* version may be 6 or 4 because the first 20 bytes could be garbled */": {
        "description": "Check the version of the IP header and return a value based on the condition.",
        "pre": {
            "ip6h->version": "!= 6",
            "ip4h->version": "== 4"
        }
    }
},
{
    "kprobe:if (ip6h->version != 6)return (ip4h->version == 4) ? 4 : 0;/* version may be 6 or 4 because the first 20 bytes could be garbled `": {
        "description": "Check the version of the IP header and return 4 if it's IPv4, otherwise return 0.",
        "pre": {
            "ip6h->version": "!= 6",
            "ip4h->version": "== 4"
        }
    }
},
{
    "kretprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "!=null",
            "hop_limit": "!=null",
            "traffic_class": "!=null",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "!=null",
            "hop_limit": "!=null",
            "traffic_class": "!=null",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "!=null",
            "udata": "!=null",
            "srq_attr->max_wr": ">=0",
            "srq_attr->max_sge": ">=0"
        }
    }
},
{
    "kprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check if the condition is true",
        "pre": {
            "qp_init_attr->cap.max_rdma_ctxs": "!=0"
        }
    },
    "kretprobe:rdma_rw_init_qp": {
        "description": "Initialize RDMA QP",
        "pre": {
            "device": "!=null",
            "qp_init_attr": "!=null"
        }
    },
    "kretprobe:create_qp": {
        "description": "Create QP",
        "pre": {
            "device": "!=null",
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:IS_ERR": {
        "description": "Check if the return value is an error",
        "pre": {
            "qp": "!=null"
        }
    },
    "kretprobe:ib_qp_usecnt_inc": {
        "description": "Increment QP use count",
        "pre": {
            "qp": "!=null"
        }
    }
},

{
    "kretprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP.",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP.",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": "!=null",
            "udata": "!=null"
        }
    }
},


{
    "kretprobe:ib_alloc_mr": {
        "description": "Allocates a memory region",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, IB_MR_TYPE_MEM_WINDOW]",
            "max_num_sg": ">=0"
        }
    }
},
{
    "kprobe:ib_alloc_mr": {
        "description": "Allocates a memory region",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, IB_MR_TYPE_MEM_WINDOW]",
            "max_num_sg": ">=0"
        }
    }
},
{
    "kretprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        }
    }
},
{
    "kprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        }
    }
},
{
    "kretprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain.",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain.",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain.",
        "pre": {
            "xrcd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain.",
        "pre": {
            "xrcd": "!=null",
            "udata": "in [valid_user_data, null]"
        }
    }
},
{
    "kretprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">=0",
            "wq_attr->max_sge": ">=0"
        }
    }
},
{
    "kprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">=0",
            "wq_attr->max_sge": ">=0"
        }
    }
},
{
    "kretprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ.",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ.",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "pre": {
            "mr": "!=null",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": "!=null",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": "!=null",
            "page_size": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "pre": {
            "mr": "!=null",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": ">=0",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": ">=0",
            "page_size": ">=0"
        }
    }
},
{
    "kretprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector.",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector.",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kretprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "pre": {
            "qp": "!=null",
            "qp->send_cq": "!=null",
            "qp->send_cq->poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ]",
            "qp->send_cq->poll_ctx == IB_POLL_DIRECT": {
                "cq->poll_ctx == IB_POLL_DIRECT": "true"
            },
            "qp->send_cq->poll_ctx == IB_POLL_SOFTIRQ": {
                "cq->poll_ctx == IB_POLL_SOFTIRQ": "true"
            }
        }
    }
},
{
    "kprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "pre": {
            "qp": "!=null",
            "cq": "!=null",
            "wc": "!=null",
            "wc->wr_cqe": "!=null",
            "cqe": "of type struct ib_drain_cqe",
            "cqe->done": "completed"
        }
    }
},
{
    "kprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "pre": {
            "cq": "!=null",
            "wc": "!=null"
        }
    }
},
{
    "kretprobe:__rdma_block_iter_start": {
        "description": "Initialize the ib_block_iter structure and assign the result of __fls(pgsz) to biter->__pg_bit.",
        "pre": {
            "biter": "!=null",
            "sglist": "!=null",
            "nents": ">=0",
            "pgsz": ">=0"
        }
    }
},
{
    "kprobe:biter->__pg_bit = __fls(pgsz)": {
        "description": "Assign the result of __fls(pgsz) to biter->__pg_bit",
        "pre": {
            "biter": {
                "__sg": "!=null",
                "__sg_nents": ">=0"
            },
            "sglist": "!=null",
            "nents": ">=0",
            "pgsz": ">=0"
        }
    }
},
{
    "kretprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers.",
        "pre": {
            "descs": "!=null",
            "num_counters": ">=0",
            "lifespan": ">=0"
        }
    }
},
{
    "kprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers.",
        "pre": {
            "descs": "!=null",
            "num_counters": ">=0",
            "lifespan": ">=0"
        }
    }
},
{
    "kretprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kretprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port",
        "pre": {
            "ibdev": "!=null",
            "port_num": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port",
        "pre": {
            "ibdev": "!=null",
            "port_num": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure",
        "pre": {
            "payload_bytes": "!=null",
            "lrh_present": "!=null",
            "eth_present": "!=null",
            "vlan_present": "!=null",
            "grh_present": "!=null",
            "ip_version": "!=null",
            "udp_present": "!=null",
            "immediate_present": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure",
        "pre": {
            "payload_bytes": "!=null",
            "lrh_present": "!=null",
            "eth_present": "!=null",
            "vlan_present": "!=null",
            "grh_present": "!=null",
            "ip_version": "!=null",
            "udp_present": "!=null",
            "immediate_present": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_pack": {
        "description": "Pack UD header struct into wire format",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_pack": {
        "description": "Pack UD header struct into wire format",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},

{
    "kprobe:ib_ud_header_unpack": {
        "description": "Unpack UD header struct from wire format",
        "pre": {
            "buf": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": "!=null",
            "virt": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": "!=null",
            "virt": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory.",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]"
        }
    }
},
{
    "kprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory.",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]"
        }
    }
},
{
    "kretprobe:iwcm_reject_msg": {
        "description": "Returns the rejection message for a given reason in iWARP.",
        "pre": {
            "reason": "!=null",
            "index": "!=null",
            "index < ARRAY_SIZE(iwcm_rej_reason_strs)": true,
            "iwcm_rej_reason_strs[index]": "!=null"
        },
        "post": {
            "return": "iwcm_rej_reason_strs[index]",
            "return == \"unrecognized reason\"": false
        }
    }
},
{
    "kprobe:iwcm_reject_msg": {
        "description": "Returns the rejection message based on the given reason.",
        "pre": {
            "reason": "!=null",
            "index": "!=null",
            "iwcm_rej_reason_strs": "!=null",
            "ARRAY_SIZE(iwcm_rej_reason_strs)": "!=null",
            "iwcm_rej_reason_strs[index]": "!=null"
        }
    }
},


{
    "kretprobe:iw_cm_connect": {
        "description": "Get the ib_qp given the QPN",
        "pre": {
            "cm_id": "!=null",
            "cm_id->device": "!=null",
            "cm_id->device->ops.iw_get_qp": "valid_function",
            "iw_param": "!=null",
            "iw_param->qpn": "valid_value",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:iw_cm_connect": {
        "description": "Connect to an InfiniBand device using the iw_cm interface.",
        "pre": {
            "cm_id": "!=null",
            "cm_id->device": "!=null",
            "cm_id->device->ops.iw_get_qp": "!=null",
            "iw_param->qpn": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "sg_offset": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "sg_offset": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_wrs": {
        "description": "Return chain of WRs for a RDMA READ or WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "in [null, !=null]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_wrs": {
        "description": "Return chain of WRs for a RDMA READ or WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_post": {
        "description": "Post a RDMA READ or RDMA WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_post": {
        "description": "Post a RDMA READ or RDMA WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_mr_factor": {
        "description": "Return the number of MRs required for a payload",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "maxpages": "!=null"
        }
    }
},
{
    "kprobe:rdma_rw_mr_factor": {
        "description": "Return the number of MRs required for a payload.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "maxpages": "!=null"
        }
    }
},
{
    "kretprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not.",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not.",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_index": {
        "description": "Return a valid device pointer for the given index.",
        "pre": {
            "net": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ib_device_get_by_index": {
        "description": "Get the InfiniBand device pointer associated with the given index.",
        "pre": {
            "net": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "valid device pointer",
            "ib_device_put()": "return device reference count"
        }
    }
},
{
    "kretprobe:ib_device_get_by_name": {
        "description": "Find an IB device by name",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ib_device_get_by_name": {
        "description": "Find an IB device by name",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        }
    }
},
{
    "kretprobe:_ib_alloc_device": {
        "description": "Allocate memory for a struct ib_device with size 'size'. Remember to use ib_dealloc_device() to free the allocated memory.",
        "pre": {
            "size": "!=null"
        }
    }
},

{
    "kretprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data",
        "pre": {
            "dev": "!=null",
            "port": ">=1 and <=rdma_end_port()"
        }
    }
},
{
    "kprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data",
        "pre": {
            "dev": "!=null",
            "port": ">=1 && <=rdma_end_port()"
        }
    }
},




{
    "kretprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:down_write": {
        "description": "Acquire write lock on devices_rwsem",
        "pre": {
            "devices_rwsem": "!=null"
        }
    },
    "kretprobe:xa_load": {
        "description": "Load value from devices xarray and check equality",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kretprobe:xa_erase": {
        "description": "Erase entry from devices xarray",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kretprobe:up_write": {
        "description": "Release write lock on devices_rwsem",
        "pre": {
            "devices_rwsem": "!=null"
        }
    }
},
{
    "kprobe:down_write": {
        "description": "Downgrade the write lock on devices_rwsem.",
        "pre": {
            "devices_rwsem": "!=null"
        }
    },
    "kprobe:xa_load": {
        "description": "Load the value associated with device->index from the devices xarray.",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kprobe:xa_erase": {
        "description": "Erase the entry associated with device->index from the devices xarray.",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kprobe:up_write": {
        "description": "Upgrade the write lock on devices_rwsem.",
        "pre": {
            "devices_rwsem": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_client": {
        "description": "Register an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_register_client": {
        "description": "Register an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_client": {
        "description": "Unregister an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_client": {
        "description": "Unregister an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_set_client_data": {
        "description": "Set IB client context",
        "pre": {
            "device": "!=null",
            "client": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ib_set_client_data": {
        "description": "Set IB client context",
        "pre": {
            "device": "!=null",
            "client": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_event_handler": {
        "description": "Register an IB event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_register_event_handler": {
        "description": "Register an IB event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_query_port": {
        "description": "Query IB port attributes",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_query_port": {
        "description": "Query IB port attributes",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device",
        "pre": {
            "ib_dev": "!=null",
            "ndev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device",
        "pre": {
            "ib_dev": "!=null",
            "ndev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_netdev": {
        "description": "Find an IB device associated with a netdev",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        }
    }
},
{
    "kprobe:ib_device_get_by_netdev": {
        "description": "Find an IB device associated with a netdev",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN]"
        }
    }
},
{
    "kretprobe:ib_query_pkey": {
        "description": "Get P_Key table entry",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kprobe:ib_query_pkey": {
        "description": "Get P_Key table entry",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kretprobe:ib_modify_device": {
        "description": "Change IB device attributes",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "!=null",
            "device_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_device": {
        "description": "Change IB device attributes",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "!=null",
            "device_modify": "!=null"
        }
    }
},
{
    "kretprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_modify_mask": "!=null",
            "port_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_modify_mask": "!=null",
            "port_modify": "!=null"
        }
    }
},
{
    "kretprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs.",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs.",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "pkey": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "pkey": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "pkey": "!=null",
            "gid": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "pkey": "!=null",
            "gid": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Store the value of cb_table in rdma_nl_types[index] using smp_store_release.",
        "pre": {
            "index": "!=null",
            "cb_table": "!=null",
            "is_nl_msg_valid(index, 0)": "!=false",
            "READ_ONCE(rdma_nl_types[index].cb_table)": "==null"
        }
    }
},

{
    "kretprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gid as needed, to the relevant RoCE devices.",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gid as needed, to the relevant RoCE devices.",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not.",
        "pre": {
            "gid": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not.",
        "pre": {
            "gid": "!=null"
        }
    }
},


{
    "kretprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries.",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": "!=null",
            "entries.length": "<= max_entries"
        }
    }
},
{
    "kprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries.",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kretprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute",
        "pre": {
            "attr": "!=null",
            "caller_reference": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null",
            "return->state": "==UP"
        }
    }
},
{
    "kprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state.",
        "pre": {
            "attr": "!=null",
            "attr->netdev": "!=null",
            "attr->netdev->state": "==UP"
        },
        "post": {
            "retval": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry.",
        "pre": {
            "attr": "!=null",
            "vlan_id": "!=null",
            "smac": "!=null"
        },
        "post": {
            "return": "in [0, vlan_id, error]"
        }
    }
},
{
    "kprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry.",
        "pre": {
            "attr": "!=null",
            "vlan_id": "optional",
            "smac": "optional"
        }
    }
},


{
    "kretprobe:ib_create_qp_security": {
        "description": "Create the security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "is_ib": "==true",
            "ret": "==0",
            "qp->qp_sec": "!=null",
            "qp->qp_sec->mutex": "initialized",
            "qp->qp_sec->shared_qp_list": "initialized",
            "qp->qp_sec->error_list_count": "==0",
            "qp->qp_sec->error_complete": "initialized",
            "ret": "==0",
            "qp->qp_sec->security": "initialized"
        }
    },
    "kretprobe:ib_close_shared_qp_security": {
        "description": "Close the shared security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "sec->shared_qp_list": "in qp->qp_sec->shared_qp_list",
            "sec->mutex": "initialized"
        }
    }
},
{
    "kprobe:ib_create_qp_security": {
        "description": "Create the security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "is_ib": "==true",
            "ret": "==0",
            "qp->qp_sec": "!=null"
        }
    },
    "kprobe:check_qp_port_pkey_settings": {
        "description": "Check the port and PKey settings for the queue pair (QP).",
        "pre": {
            "real_qp->qp_sec->mutex": "locked",
            "ret": "==0"
        }
    },
    "kprobe:destroy_qp_security": {
        "description": "Destroy the security context for the queue pair (QP).",
        "pre": {
            "sec->shared_qp_list": "deleted"
        }
    },
    "kprobe:ib_close_shared_qp_security": {
        "description": "Close the shared security context for the queue pair (QP).",
        "pre": {
            "real_qp->qp_sec->mutex": "locked"
        }
    }
},
{
    "kretprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "any"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_io": {
        "description": "This function is called by drivers as part of their mmap() functions to send PCI-E BAR memory to userspace.",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": "!=null",
            "size": "!=null",
            "prot": "!=null",
            "entry": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL, -EAGAIN]"
        }
    }
},
{
    "kprobe:rdma_user_mmap_io": {
        "description": "This function is called by drivers as part of their mmap() functions to send PCI-E BAR memory to userspace.",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": "!=null",
            "size": "!=null",
            "prot": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "Return a reference to an entry if it exists or NULL if there is no match.",
        "pre": {
            "ucontext": "!=null",
            "pgoff": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "Get the rdma_user_mmap_entry with the specified page offset.",
        "pre": {
            "ucontext": "!=null",
            "pgoff": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range.",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": "!=null",
            "min_pgoff": "!=null",
            "max_pgoff": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range.",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": "!=null",
            "min_pgoff": "!=null",
            "max_pgoff": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_dmabuf_map_pages": {
        "description": "Map pages for the given umem_dmabuf",
        "pre": {
            "umem_dmabuf": "!=null",
            "sgt": "!=null",
            "sg": "!=null",
            "start": ">=0",
            "end": ">=0",
            "cur": ">=0",
            "nmap": ">=0",
            "ret": ">=0",
            "i": ">=0"
        }
    }
},
{
    "kprobe:start = ALIGN_DOWN(umem_dmabuf->umem.addres PAGE_SIZE);end = ALIGN(umem_dmabuf->umem.address + umem_dmabuf->umem.length, PAGE_SIZE);for_each_sgtable_dma_sg(sgt, sg, i)": {
        "description": "Map pages from umem_dmabuf to sg_table",
        "pre": {
            "umem_dmabuf": {
                "address": "!=null",
                "umem": {
                    "address": "!=null",
                    "length": "!=null"
                }
            },
            "sgt": "!=null",
            "sg": "!=null",
            "i": "!=null"
        }
    }
},
{
    "if (umem_dmabuf->first_sg)": {
        "description": "Check if the first scatter-gather element is present in umem_dmabuf.",
        "pre": {
            "umem_dmabuf": "!=null",
            "umem_dmabuf->first_sg": "!=null"
        }
    }
},
{
    "kprobe:if (umem_dmabuf->first_sg)": {
        "description": "Check if the `first_sg` field of `umem_dmabuf` is not null.",
        "pre": {
            "umem_dmabuf": "!=null",
            "umem_dmabuf->first_sg": "!=null"
        }
    }
},
{
    "kretprobe:rdma_copy_src_l2_addr": {
        "description": "Copy netdevice source addresses",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_src_l2_addr": {
        "description": "Copy netdevice source addresses",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem",
        "pre": {
            "device": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem",
        "pre": {
            "device": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem.",
        "pre": {
            "root": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "ops": "==invalidate"
        }
    }
},
{
    "kprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem.",
        "pre": {
            "root": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]",
            "ops": "==&invalidate"
        }
    }
},
{
    "kprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]",
            "ops": "==&mmu_interval_notifier_ops_invalidate"
        }
    }
},


{
    "kretprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it.",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": "!=null",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "bool"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it.",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": "!=null",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "bool"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables.",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": ">=0",
            "page": "!=null",
            "access_mask": ">=0"
        },
        "post": {
            "return": "== -EFAULT"
        }
    }
},
{
    "kprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables.",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": "!=null",
            "page": "!=null",
            "access_mask": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query.",
        "pre": {
            "id": "!=null",
            "query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query.",
        "pre": {
            "id": "!=null",
            "query": "!=null"
        }
    }
},
{
    "kretprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null",
            "sa_query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": ">=0",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null",
            "sa_query": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_mad_agent": {
        "description": "Register to send/receive MADs",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "qp_type": "in [IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=0",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "!=null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kprobe:ib_register_mad_agent": {
        "description": "Register to send/receive MADs",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "qp_type": "in [IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=0",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "!=null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kretprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_send_mad": {
        "description": "Create and send an InfiniBand Management Datagram (MAD).",
        "pre": {
            "mad_agent": "!=null",
            "remote_qpn": "!=null",
            "pkey_index": "!=null",
            "rmpp_active": "!=null",
            "hdr_len": "!=null",
            "data_len": "!=null",
            "gfp_mask": "!=null",
            "base_version": "!=null",
            "opa": "!=null",
            "mad_agent_priv": "!=null",
            "mad_send_wr": "!=null",
            "pad": "!=null",
            "message_size": "!=null",
            "ret": "!=null",
            "size": "!=null",
            "buf": "!=null",
            "mad_size": "!=null"
        },
        "post": {
            "mad_send_wr->sg_list[1].length": "data_len",
            "mad_send_wr->sg_list[1].lkey": "mad_agent->qp->pd->local_dma_lkey",
            "mad_send_wr->mad_list.cqe.done": "ib_mad_send_done",
            "mad_send_wr->send_wr.wr.wr_cqe": "&mad_send_wr->mad_list.cqe",
            "mad_send_wr->send_wr.wr.sg_list": "mad_send_wr->sg_list",
            "mad_send_wr->send_wr.wr.num_sge": "2",
            "mad_send_wr->send_wr.wr.opcode": "IB_WR_SEND",
            "mad_send_wr->send_wr.wr.send_flags": "IB_SEND_SIGNALED",
            "mad_send_wr->send_wr.remote_qpn": "remote_qpn",
            "mad_send_wr->send_wr.remote_qkey": "IB_QP_SET_QKEY",
            "mad_send_wr->send_wr.pkey_index": "pkey_index"
        }
    }
},
{
    "kprobe:ib_create_send_mad": {
        "description": "Create and send an InfiniBand Management Datagram (MAD).",
        "pre": {
            "opa": true,
            "base_version": "OPA_MGMT_BASE_VERSION",
            "data_len": {
                "<": "mad_size - hdr_len"
            }
        },
        "post": {
            "mad_send_wr->sg_list[1].length": {
                "=": "data_len"
            },
            "mad_send_wr->sg_list[1].lkey": "mad_agent->qp->pd->local_dma_lkey",
            "mad_send_wr->mad_list.cqe.done": "ib_mad_send_done",
            "mad_send_wr->send_wr.wr.wr_cqe": "&mad_send_wr->mad_list.cqe",
            "mad_send_wr->send_wr.wr.sg_list": "mad_send_wr->sg_list",
            "mad_send_wr->send_wr.wr.num_sge": 2,
            "mad_send_wr->send_wr.wr.opcode": "IB_WR_SEND",
            "mad_send_wr->send_wr.wr.send_flags": "IB_SEND_SIGNALED",
            "mad_send_wr->send_wr.remote_qpn": "remote_qpn",
            "mad_send_wr->send_wr.remote_qkey": "IB_QP_SET_QKEY",
            "mad_send_wr->send_wr.pkey_index": "pkey_index",
            "rmpp_active": true
        }
    }
},


{
    "kretprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer.",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer.",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kretprobe:_uverbs_alloc": {
        "description": "Quickly allocate memory for use with a bundle",
        "pre": {
            "bundle": "!=null",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kprobe:_uverbs_alloc": {
        "description": "Quickly allocate memory for use with a bundle",
        "pre": {
            "bundle": "!=null",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},




{
    "kretprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:cma_modify_qp_rts": {
        "description": "Modify the QP attributes to transition the QP state to RTS.",
        "pre": {
            "id_priv->id": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "qp": "!=null",
            "IB_QPS_RTS": "constant",
            "IB_QP_SQ_PSN": "constant"
        }
    },
    "kretprobe:cma_init_conn_qp": {
        "description": "Initialize the connection QP attributes.",
        "pre": {
            "id_priv": "!=null",
            "qp": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "IB_QPS_INIT": "constant"
        }
    },
    "kretprobe:rdma_create_qp": {
        "description": "Create a QP for RDMA communication.",
        "pre": {
            "id": "!=null",
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "ret": "int",
            "IB_QPT_UD": "constant",
            "IB_QPS_INIT": "constant"
        }
    },
    "kretprobe:rdma_destroy_qp": {
        "description": "Destroy the QP for RDMA communication.",
        "pre": {
            "id": "!=null"
        }
    },
    "kretprobe:cma_modify_qp_rtr": {
        "description": "Modify the QP attributes to transition the QP state to RTR.",
        "pre": {
            "id_priv": "!=null",
            "conn_param": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "IB_QPS_RTR": "constant"
        }
    }
},
{
    "kprobe:qp_attr.qp_state = IB_QPS_INIT;ret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);if (ret)goto out;ret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);if (ret)goto out;qp_attr.qp_state = IB_QPS_RTR;ret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);if (ret)goto out;BUG_ON(id_priv->cma_dev->device != id_priv->id.device);if (conn_param)qp_attr.max_dest_rd_atomic = conn_param->responder_resources;ret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);out:mutex_unlock(&id_priv->qp_mutex);return ret;}static int cma_modify_qp_rts(struct rdma_id_private *id_priv, struct rdma_conn_param *conn_param)": {
        "description": "Modify the QP attributes for the given rdma_id_private and rdma_conn_param in the RTS state.",
        "pre": {
            "qp_attr.qp_state": "= IB_QPS_INIT",
            "ret": "= 0",
            "rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask)": "= 0",
            "ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask)": "= 0",
            "qp_attr.qp_state": "= IB_QPS_RTR",
            "rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask)": "= 0",
            "BUG_ON(id_priv->cma_dev->device != id_priv->id.device)": "not triggered",
            "conn_param": "!= null",
            "qp_attr.max_dest_rd_atomic": "= conn_param->responder_resources",
            "ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask)": "= 0",
            "mutex_unlock(&id_priv->qp_mutex)": "not triggered",
            "return ret": "not specified"
        }
    }
},

{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel the address resolution for the given device address.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->id.route.addr.dev_addr": "!=null"
        }
    },
    "kprobe:cma_cancel_route": {
        "description": "Cancel the route query operation for the given id_priv.",
        "pre": {
            "id_priv": "!=null"
        }
    },
    "kprobe:cma_cancel_listens": {
        "description": "Cancel the listen operation for the given id_priv if certain conditions are met.",
        "pre": {
            "id_priv": "!=null",
            "cma_any_addr(cma_src_addr(id_priv))": "true",
            "!id_priv->cma_dev": "true"
        }
    },
    "kprobe:cma_release_port": {
        "description": "Release the port for the given id_priv.",
        "pre": {
            "id_priv": "!=null"
        }
    }
},
{
    "kretprobe:rdma_set_ack_timeout": {
        "description": "Set the acknowledgment timeout for the RDMA connection.",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rdma_set_ack_timeout": {
        "description": "Set the acknowledgment timeout for the RDMA connection.",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier.",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": ">=0",
            "min_rnr_timer": "<=31"
        }
    }
},
{
    "kprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier.",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": ">=0",
            "min_rnr_timer": "<=31"
        }
    }
},


{
    "kretprobe:rdma_resolve_addr": {
        "description": "Resolve the address for RDMA communication.",
        "pre": {
            "id": "!=null",
            "src_addr": "!=null",
            "dst_addr": "!=null",
            "timeout_ms": ">=0"
        }
    }
},
{
    "kprobe:rdma_resolve_addr": {
        "description": "Resolve the address of the RDMA connection manager (CM) identifier.",
        "pre": {
            "id": "!=null",
            "src_addr": "!=null",
            "dst_addr": "!=null",
            "timeout_ms": ">=0"
        }
    }
},
{
    "kretprobe:if (id_priv->reuseaddr)": {
        "description": "Check if the ID is reusable.",
        "pre": {
            "id_priv": {
                "reuseaddr": "true"
            }
        }
    }
},
{
    "kprobe:if (id_priv->reuseaddr)": {
        "description": "Check if the ID is allowed to be reusable.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->reuseaddr": "==true"
        }
    }
},
{
    "kretprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        }
    }
},
{
    "kretprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        }
    }
},
{
    "kretprobe:trace_cm_disconnect": {
        "description": "Initiate or respond to a disconnect.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->cm_id.ib": "!=null"
        }
    },
    "kretprobe:ib_send_cm_dreq": {
        "description": "Send a connection manager disconnect request.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->cm_id.ib": "!=null"
        }
    }
},
{
    "id_priv": {
        "cm_id.ib": "!=null"
    }
},
{
    "kretprobe:rdma_join_multicast": {
        "description": "Join a multicast group in RDMA communication.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:if (WARN_ON(id->qp))return -EINVAL;/* ULP is calling this wrong. `": {
        "description": "Join a multicast group for RDMA communication.",
        "pre": {
            "id": {
                "qp": "!=null"
            }
        }
    }
},
{
    "kretprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for future RDMA operation",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, RTRS_CLT_CON_TYPE_3]",
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NO_WAIT]"
        }
    }
},
{
    "kprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for future RDMA operation",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, RTRS_CLT_CON_TYPE_3]",
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NO_WAIT]"
        }
    }
},
{
    "kretprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},
{
    "kprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},


{
    "kretprobe:alloc_path": {
        "description": "Allocate a path for the rtrs_clt_sess structure.",
        "pre": {
            "clt_path": "!=null",
            "clt": "!=null",
            "delay_ms": ">=1000",
            "con_num": ">=0",
            "nr_poll_queues": ">=0"
        },
        "post": {
            "clt_path->s.con": "kcalloc(total_con, sizeof(*clt_path->s.con), GFP_KERNEL)",
            "!clt_path->s.con": "goto err_free_path",
            "clt_path->s.con_num": "total_con",
            "clt_path->s.irq_con_num": "con_num + 1",
            "clt_path->stats": "kzalloc(sizeof(*clt_path->stats), GFP_KERNEL)",
            "!clt_path->stats": "goto err_free_con",
            "clt_path->init_mutex": "mutex_init",
            "clt_path->s.uuid": "uuid_gen",
            "clt_path->s.dst_addr": "memcpy(&clt_path->s.dst_addr, path->dst, rdma_addr_size((struct sockaddr *)path->dst))"
        }
    }
},
{
    "kprobe:rtrs_clt_close_work": {
        "description": "Close the client work.",
        "pre": {}
    },
    "kprobe:rtrs_clt_err_recovery_work": {
        "description": "Perform error recovery work for the client.",
        "pre": {}
    },
    "kprobe:alloc_path": {
        "description": "Allocate a client path.",
        "pre": {
            "clt": "!=null",
            "path": "!=null",
            "con_num": ">=0",
            "nr_poll_queues": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA.",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        }
    }
},
{
    "kprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA.",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_clt_rdma_cq_direct": {
        "description": "If no path, return -1 for block layer not to try again",
        "pre": {
            "cnt": "-1",
            "con": "!=null",
            "clt_path": "!=null",
            "it": "!=null",
            "rcu_read_lock": "called",
            "path_it_init": "called with parameters (&it, clt)",
            "it.next_path(&it)": "!=null",
            "it.i < it.clt->paths_num": "true"
        },
        "post": {
            "return_value": "-1"
        }
    }
},

{
    "kretprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        },
        "post": {
            "return_value": "in [0, -ECOMM]"
        }
    }
},
{
    "kprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA request",
        "pre": {
            "id": "!=null",
            "status": "<=0"
        }
    }
},
{
    "kprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA request",
        "pre": {
            "id": "!=null",
            "status": "<=0"
        }
    }
},
{
    "kretprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv.",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv.",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname.",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname.",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth.",
        "pre": {
            "srv": "!=null"
        },
        "post": {
            "return_value": "is int"
        }
    }
},
{
    "kprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth.",
        "pre": {
            "srv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_open": {
        "description": "Open RTRS server context",
        "pre": {
            "ops": "!=null",
            "port": ">=0"
        }
    }
},
{
    "kprobe:rtrs_srv_open": {
        "description": "Open RTRS server context",
        "pre": {
            "ops": "!=null",
            "port": "!=null"
        }
    }
},


{
    "kretprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_sockaddr": {
        "description": "Converts a path string to source-destination addresses.",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rtrs_addr_to_sockaddr": {
        "description": "Converts a path string 'src,dst' or 'src@dst' to sockaddreses.",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "==null"
        }
    }
},
{
    "skb = __hci_cmd_sync": {
        "description": "Assign the return value of __hci_cmd_sync to skb",
        "pre": {
            "hdev": "!=null",
            "fw": "!=null",
            "cmd": "is of type struct hci_command_hdr",
            "fw_ptr": "is of type u8",
            "fw_size": "is of type size_t",
            "skb": "is of type struct sk_buff",
            "opcode": "is of type u16",
            "err": "is of type int",
            "__hci_cmd_sync": "return value is not an error"
        }
    }
},

{
    "kretprobe:vme_alloc_consistent": {
        "description": "Allocate contiguous memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:vme_alloc_consistent": {
        "description": "Allocate contiguous memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:vme_free_consistent": {
        "description": "Free previously allocated memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:vme_free_consistent": {
        "description": "Free previously allocated memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:vme_get_size": {
        "description": "Get the size of the window resource.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_get_size": {
        "description": "Returns the size of the window resource.",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_check_window": {
        "description": "Check the window for VME access.",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "vme_base": "!=null",
            "size": "!=null"
        },
        "post": {
            "retval": "in [-EINVAL, -EFAULT, 0]"
        }
    }
},
{
    "kprobe:vme_check_window": {
        "description": "Check the window for VME access.",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "vme_base": "!=null",
            "size": "!=null",
            "retval": "in [-EINVAL, -EFAULT]"
        }
    }
},
{
    "kretprobe:vme_slave_request": {
        "description": "Request a VME slave window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_request": {
        "description": "Request a VME slave window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_slave_set": {
        "description": "Set VME slave window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "buf_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_set": {
        "description": "Set VME slave window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "buf_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_slave_free": {
        "description": "Free VME slave window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_free": {
        "description": "Free VME slave window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_request": {
        "description": "Request a VME master window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_master_request": {
        "description": "Request a VME master window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_set": {
        "description": "Set VME master window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_master_set": {
        "description": "Set VME master window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vme_master_write": {
        "description": "Write data out to VME space from a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:vme_master_write": {
        "description": "Write data out to VME space from a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle.",
        "pre": {
            "resource": "!=null",
            "mask": "!=null",
            "compare": "!=null",
            "swap": "!=null",
            "offset": "!=null"
        },
        "post": {
            "return": ">=0",
            "resource": "is a VME master resource",
            "operation_supported": "true"
        }
    }
},
{
    "kprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle.",
        "pre": {
            "resource": "!=null",
            "mask": "!=null",
            "compare": "!=null",
            "swap": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_mmap": {
        "description": "Mmap region of VME master window.",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:vme_master_mmap": {
        "description": "Mmap region of VME master window.",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_free": {
        "description": "Free VME master window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_master_free": {
        "description": "Free VME master window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_request": {
        "description": "Request a DMA controller.",
        "pre": {
            "vdev": "!=null",
            "route": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_request": {
        "description": "Request a DMA controller.",
        "pre": {
            "vdev": "!=null",
            "route": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_new_dma_list": {
        "description": "Return a pointer to a new VME DMA list.",
        "pre": {},
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:vme_new_dma_list": {
        "description": "Create a new VME DMA list.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_pattern_attribute": {
        "description": "Return a pointer to VME DMA attribute, NULL on failure.",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_pattern_attribute": {
        "description": "Generate conditions for the vme_dma_pattern_attribute function.",
        "pre": {
            "pattern": "!=null",
            "type": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_pci_attribute": {
        "description": "Create 'PCI' type VME DMA list attribute.",
        "pre": {
            "address": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_pci_attribute": {
        "description": "Create 'PCI' type VME DMA list attribute.",
        "pre": {
            "address": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_vme_attribute": {
        "description": "Create \"VME\" type VME DMA list attribute.",
        "pre": {
            "address": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_vme_attribute": {
        "description": "Create 'VME' type VME DMA list attribute.",
        "pre": {
            "address": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_free_attribute": {
        "description": "Free the attributes associated with VME DMA.",
        "pre": {
            "attributes": "!=null"
        }
    }
},

{
    "kretprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution.",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution.",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:vme_irq_request": {
        "description": "Request a specific VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null",
            "callback": "!=null",
            "priv_data": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:vme_irq_request": {
        "description": "Request a specific VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null",
            "callback": "!=null",
            "priv_data": "!=null"
        }
    }
},
{
    "kretprobe:vme_irq_free": {
        "description": "Free a VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kprobe:vme_irq_free": {
        "description": "Free a VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kretprobe:vme_irq_generate": {
        "description": "Generate VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_irq_generate": {
        "description": "Generate VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_request": {
        "description": "Request a VME location monitor",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_request": {
        "description": "Request a VME location monitor",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_set": {
        "description": "Configure location monitor",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_set": {
        "description": "Configure location monitor",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_get": {
        "description": "Retrieve location monitor settings",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_get": {
        "description": "Retrieve location monitor settings",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_attach": {
        "description": "Provide callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": ">=0",
            "callback": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_attach": {
        "description": "Provide callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null",
            "callback": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_detach": {
        "description": "Remove callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_detach": {
        "description": "Remove callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_free": {
        "description": "Free allocated VME location monitor",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_free": {
        "description": "Free allocated VME location monitor",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_slot_num": {
        "description": "Retrieve slot ID",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_slot_num": {
        "description": "Retrieve slot ID",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kretprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:__vme_register_driver_bus": {
        "description": "Register a VME driver",
        "pre": {
            "drv": "!=null",
            "bridge": "!=null",
            "ndevs": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__vme_register_driver_bus": {
        "description": "Register a VME driver",
        "pre": {
            "drv": "!=null",
            "bridge": "!=null",
            "ndevs": "!=null"
        }
    }
},
{
    "kretprobe:vme_unregister_driver": {
        "description": "Unregister a VME driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:vme_unregister_driver": {
        "description": "Unregister a VME driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:sscanf": {
        "description": "Read formatted data from a string",
        "pre": {
            "w": "!=null",
            "sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "!=null",
            "dir": "!=null",
            "ret": "!=null",
            "ret": "< 3"
        }
    }
},
{
    "kprobe:ret = sscanf": {
        "description": "Parse the string w->sname and store the results in intf_name, dai_id, and dir.",
        "pre": {
            "w": "!=null",
            "w->sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "!=null",
            "dir": "!=null",
            "ret": "!=null",
            "ret < 3": true
        }
    }
},
{
    "kretprobe:if (comp->card->instantiated)": {
        "description": "Check if the card is already instantiated.",
        "pre": {
            "comp": {
                "card": {
                    "instantiated": "==true"
                }
            }
        }
    }
},
{
    "kprobe:if (comp->card->instantiated)": {
        "description": "Check if the card is already instantiated.",
        "pre": {
            "comp": {
                "card": {
                    "instantiated": "==true"
                }
            }
        }
    }
},

{
    "list_for_each_entry_safe": {
        "description": "Iterate over the jack_list of the module structure and perform some operations on each entry.",
        "pre": {
            "jack": "!=null",
            "n": "!=null",
            "module": "!=null",
            "module.type": "struct gbaudio_module_info",
            "jack.type": "struct gbaudio_jack",
            "n.type": "struct gbaudio_jack"
        }
    }
},
{
    "kretprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:dev_set_drvdata": {
        "description": "Set the driver data of the device.",
        "pre": {
            "dev": "!=null",
            "indio_dev": "!=null",
            "bus": "!=null",
            "name": "!=null",
            "name[4]": "== '3' || name[4] == '5'",
            "name[6]": ">= '6'",
            "chip->bus": "== *bus",
            "chip->id": "ID_ADT7316 + (name[6] - '6') when name[4] == '3' || ID_ADT7516 + (name[6] - '6') when name[4] == '5'",
            "chip->id": "== ID_ADT7316 || chip->id == ID_ADT7516 when chip->id == ID_ADT7316 || chip->id == ID_ADT7516",
            "chip->dac_bits": "12 when chip->id == ID_ADT7316 || chip->id == ID_ADT7516 || chip->id == ID_ADT7317 || chip->id == ID_ADT7517, 10 when chip->id == ID_ADT7317 || chip->id == ID_ADT7517, 8 otherwise",
            "chip->ldac_pin": "!=null"
        },
        "post": {
            "return": "-ENODEV"
        }
    }
},
{
    "kprobe:dev_set_drvdata": {
        "description": "Set the driver data of the device.",
        "pre": {
            "dev": "!=null",
            "indio_dev": "!=null",
            "bus": "!=null",
            "name[4]": "== '3' or == '5'",
            "name[6]": ">= '6'",
            "chip->bus": "== *bus",
            "chip->id": "ID_ADT7316 + (name[6] - '6') when name[4] == '3', ID_ADT7516 + (name[6] - '6') when name[4] == '5'",
            "chip->id": "!=null",
            "chip->id": "== ID_ADT7316 or == ID_ADT7516 when chip->id == ID_ADT7316 or chip->id == ID_ADT7516",
            "chip->id": "== ID_ADT7317 or == ID_ADT7517 when chip->id == ID_ADT7317 or chip->id == ID_ADT7517",
            "chip->id": "!=null",
            "chip->dac_bits": "12 when chip->id == ID_ADT7316 or chip->id == ID_ADT7516, 10 when chip->id == ID_ADT7317 or chip->id == ID_ADT7517, 8 otherwise",
            "chip->ldac_pin": "devm_gpiod_get_optional(dev, \"adi,ldac\", GPIOD_OUT_LOW)",
            "chip->ldac_pin": "!=null"
        }
    }
},






{
    "kretprobe:ieee80211_resume_tx": {
        "description": "Resume transmission in the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "ieee->skb_drv_aggQ[queue_index]": "!=null",
            "ieee->skb_waitQ[queue_index]": "!=null",
            "txb->fragments[i]": "!=null",
            "ieee->dev": "!=null",
            "ieee->rate": "!=null",
            "ieee->lock": "acquired"
        }
    }
},
{
    "ieee80211_resume_tx": {
        "pre": {
            "USB_TX_DRIVER_AGGREGATION_ENABLE": "defined",
            "USB_TX_DRIVER_AGGREGATION_ENABLE": "undefined"
        }
    }
},
{
    "kretprobe:ieee80211_softmac_scan_syncro": {
        "description": "This function performs syncro scan blocking the caller until all channels in the allowed channel map have been checked.",
        "pre": {
            "ieee": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_softmac_scan_syncro": {
        "description": "This function performs syncro scan blocking the caller until all channels in the allowed channel map have been checked.",
        "pre": {
            "ieee": "!=null"
        }
    }
},


{
    "kretprobe:libipw_wx_set_encode": {
        "description": "Set the encryption for the wireless device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "dev": "!=null",
            "sec": "!=null",
            "i": ">=0",
            "key": "<WEP_KEYS",
            "key_provided": "in [0, 1]",
            "len": ">=0",
            "crypt": "!=null",
            "host_crypto": "in [0, 1]",
            "erq->flags & IW_ENCODE_DISABLED": "in [0, 1]",
            "erq->flags & IW_ENCODE_DISABLED && key_provided && crypt": "==0",
            "erq->flags & IW_ENCODE_DISABLED && !key_provided": "==1"
        }
    }
},
{
    "kprobe:libipw_wx_set_encode": {
        "description": "Set the encoding for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_encode_ext": {
        "description": "Set the extended encoding for IEEE 802.11 device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt[idx]": "!= null",
            "sec.flags": "|= SEC_ENABLED",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_encode_ext": {
        "description": "Set the extended encoding parameters for IEEE 802.11 device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt[idx]": "!= null",
            "sec.flags": "|= SEC_ENABLED",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},

{
    "kprobe:break;case IW_AUTH_CIPHER_PAIRWISE:case IW_AUTH_CIPHER_GROUP:case IW_AUTH_KEY_MGMT:/* *                  * Host AP driver does not use these parameters and allows *                                   * wpa_supplicant to control them internally. *                                                    */": {
        "description": "The function ieee80211_wx_set_auth is used to set the authentication parameters for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": "!=null",
            "extra": "!=null",
            "data.flags & IW_AUTH_INDEX": "in [IW_AUTH_WPA_VERSION]"
        }
    }
},
{
    "kretprobe:ieee80211_frag_cache_find": {
        "description": "Find the fragment entry in the cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_frag_cache_find": {
        "description": "Find the fragment entry in the cache based on the given parameters.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},

{
    "kprobe:if_memcmp": {
        "description": "Check if the memory contents of hdr->addr1 and ieee->dev->dev_addr are equal.",
        "pre": {
            "hdr->addr1": "!=null",
            "ieee->dev->dev_addr": "!=null"
        }
    }
},

{
    "kprobe:rtllib_wx_set_freq": {
        "description": "Set the frequency of the wireless device.",
        "pre": {
            "fwrq.e": "== 1"
        }
    }
},


{
    "kretprobe:spin_lock_irqsave": {
        "description": "Locks the spinlock and saves the IRQ state.",
        "pre": {
            "ieee": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:ieee80211_wx_get_wap": {
        "description": "Gets the wireless access point (WAP) address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.ap_addr.sa_family": "==ARPHRD_ETHER",
            "ieee.iw_mode": "!=IW_MODE_MONITOR"
        },
        "post": {
            "return": "==0"
        }
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Unlocks the spinlock and restores the IRQ state.",
        "pre": {
            "ieee": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:ieee80211_wx_get_wap": {
        "description": "Get the wireless access point (WAP) address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->ap_addr.sa_family": "==ARPHRD_ETHER",
            "ieee->iw_mode": "!=IW_MODE_MONITOR"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_wap": {
        "description": "Set the wireless access point (WAP) for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null",
            "ret": "int",
            "flags": "unsigned long",
            "ifup": "short",
            "dev": "!=null",
            "dev->flags": "IFF_UP"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_wap": {
        "description": "Set the wireless access point for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null",
            "ret": "int",
            "flags": "unsigned long",
            "ifup": "short",
            "dev": "!=null",
            "dev->flags": "IFF_UP"
        }
    }
},


{
    "kretprobe:ieee80211_wx_set_rate": {
        "description": "FIXME: we might want to limit rate also in management protocols.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "target_rate": "!=null",
            "ieee->rate": "target_rate * 100000"
        }
    }
},
{
    "kprobe:return 0;}EXPORT_SYMBOL(ieee80211_wx_set_rate": {
        "description": "FIXME: we might want to limit rate also in management protocols.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "target_rate": "!=null",
            "ieee->rate": "target_rate * 100000"
        }
    }
},
   "wrqu": {
       "rts": {
           "value": "ieee->rts",
           "fixed": "0"
       }
   }
   ```

4. `extra`: There is no specific constraint mentioned for this parameter in the documentation, so we can assume it can take any value. Therefore, we don't need to include it in the conditions.

Putting it all together, the JSON representation of the conditions for the `ieee80211_wx_get_rts` function would be:
,
{
    "kprobe:ieee80211_wx_get_rts": {
        "description": "Get the RTS (Request to Send) value from the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": {
                "rts": {
                    "value": "ieee->rts",
                    "fixed": 0
                }
            },
            "extra": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_scan": {
        "description": "This function is used to set the scan parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ret": "==0",
            "ieee->wx_mutex": "unlocked",
            "ieee->iw_mode": "in [IW_MODE_MONITOR, IW_MODE_NORMAL]",
            "ieee->proto_started": "true",
            "ieee->state": "in [IEEE80211_LINKED, IEEE80211_UNLINKED]"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_scan": {
        "description": "Set the scan parameters for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ret": "int",
            "ieee->wx_mutex": "locked",
            "ieee->iw_mode": "in [IW_MODE_MONITOR]",
            "ieee->proto_started": "true",
            "ieee->state": "in [IEEE80211_LINKED]"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Locks a spinlock and disables interrupts.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->essid.flags": "!=0",
            "wrqu->essid.length": "!=0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->essid.flags": "!=0",
            "wrqu->essid.length": "!=0"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_power": {
        "description": "Set the power parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.power.disabled": "==0",
            "wrqu.power.flags & IW_POWER_TIMEOUT": "!=0",
            "ieee->ps_period": "==wrqu.power.value / 1000"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_power": {
        "description": "Set the power parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.power.disabled": "==0",
            "wrqu.power.flags & IW_POWER_TIMEOUT": "!=0",
            "wrqu.power.value": ">=0"
        }
    }
},

{
    "kprobe:/* goto exit; ": {
        "description": "This function contains a goto statement that jumps to the exit label.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "ieee->wx_mutex": "locked",
            "ieee->ps": "==IEEE80211_PS_DISABLED",
            "wrqu->power.disabled": "==1",
            "wrqu->power.flags & IW_POWER_TYPE": "==IW_POWER_TIMEOUT",
            "wrqu->power.flags": "==IW_POWER_TIMEOUT",
            "wrqu->power.value": "==ieee->ps_timeout * 1000"
        }
    }
},

{
    "kprobe:HTUpdateSelfAndPeerSetting": {
        "description": "Update self and peer settings for high throughput.",
        "pre": {
            "pNetwork": {
                "bssht": {
                    "bdHTInfoLen": "!= 0"
                }
            },
            "pHTInfo": {
                "CurrentOpMode": "= pPeerHTInfo->OptMode"
            }
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Set the specified memory range to a specific value.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": ">=0"
        }
    },
    "kretprobe:dot11d_reset": {
        "description": "Reset the dot11d_info structure for the given ieee80211_device.",
        "pre": {
            "ieee": "!=null"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set new channel map",
        "pre": {
            "dot11d_info->channel_map": "==0",
            "dot11d_info->max_tx_pwr_dbm_list": "==0xFF"
        }
    }
},
{
    "kretprobe:pTriple": {
        "description": "Assigns a pointer to a structure of type chnl_txpower_triple.",
        "pre": {
            "pCoutryIe": "!=null",
            "CoutryIeLen": ">3",
            "NumTriples": ">0",
            "i": ">=0",
            "i": "<NumTriples"
        }
    }
},
{
    "kprobe:pTriple_assignment": {
        "description": "Assigns a pointer to a structure of type chnl_txpower_triple to pTriple.",
        "pre": {
            "pCoutryIe": "!=null",
            "NumTriples": ">0"
        }
    },
    "kprobe:for_loop": {
        "description": "Iterates over the triples.",
        "pre": {
            "i": ">=0",
            "i": "<NumTriples"
        }
    }
},




{
    "kretprobe:vchiq_shutdown": {
        "description": "Shutdown the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "instance->state": "!=null",
            "mutex_lock_killable(&state->mutex)": "==0"
        },
        "post": {
            "status": "==0"
        }
    }
},
{
    "kprobe:vchiq_shutdown": {
        "description": "Shutdown the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "instance->state": "!=null",
            "mutex_lock_killable(&state->mutex)": "==0"
        }
    }
},


{
    "kretprobe:vchiq_bulk_transmit": {
        "description": "Transmit bulk data over VCHIQ",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_transmit": {
        "description": "Transmit bulk data using the vchiq interface.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        }
    }
},
{
    "kretprobe:vchiq_bulk_receive": {
        "description": "Receives bulk data from VCHIQ instance.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_receive": {
        "description": "Receives bulk data using VCHIQ protocol.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]",
            "status": "!= -EAGAIN"
        }
    }
},




{
    "kretprobe:vchiq_queue_kernel_message": {
        "description": "Queue a kernel message in the VCHIQ instance.",
        "pre": {
            "instance": "!=null",
            "handle": "unsigned int",
            "data": "!=null",
            "size": "unsigned int"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_queue_kernel_message": {
        "description": "Queue a kernel message in the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:remote_event_create": {
        "description": "This function initializes a single remote_event and the associated wait_queue.",
        "pre": {
            "wq": "!=null",
            "event": "!=null"
        }
    }
},
{
    "kprobe:remote_event_create": {
        "description": "This function initializes a single remote_event and the associated wait_queue.",
        "pre": {
            "wq": "!=null",
            "event": "!=null"
        }
    }
},


{
    "kretprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry",
        "pre": {
            "work_queue_entry": "!=null"
        },
        "post": {
            "return_value": "in [0, <negative values>]"
        }
    }
},
{
    "kprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry",
        "pre": {
            "work_queue_entry": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kretprobe:rtllib_wx_get_wap": {
        "description": "Get the wireless access point address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "flags": "unsigned long",
            "wrqu.ap_addr.sa_family": "ARPHRD_ETHER",
            "ieee.iw_mode": "not equal to IW_MODE_MONITOR"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:eth_zero_addr": {
        "description": "Set the given Ethernet address to all zeros.",
        "pre": {
            "wrqu->ap_addr.sa_data": "!=null"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy memory area.",
        "pre": {
            "wrqu->ap_addr.sa_data": "!=null",
            "ieee->current_network.bssid": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:rtllib_wx_get_wap": {
        "description": "Get wireless access point information.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "flags": "!=null",
            "wrqu->ap_addr.sa_family": "ARPHRD_ETHER",
            "ieee->iw_mode": "not equal to IW_MODE_MONITOR"
        }
    }
},


{
    "wrqu->rts.disabled": "wrqu->rts.value == DEFAULT_RTS_THRESHOLD"
},
{
    "kprobe:rtllib_wx_get_rts": {
        "description": "Set the value of wrqu->rts.disabled based on wrqu->rts.value",
        "pre": {
            "wrqu->rts.value": "== DEFAULT_RTS_THRESHOLD"
        }
    }
},
{
    "kretprobe:rtllib_wx_set_scan": {
        "description": "Helper function for setting the scan mode in rtllib_device.",
        "pre": {
            "ieee->iw_mode": "==IW_MODE_MONITOR || ieee->proto_started == false",
            "ieee->link_state": "==MAC80211_LINKED"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:return 0;}out:return ret;}EXPORT_SYMBOL(rtllib_wx_set_scan": {
        "description": "Helper function for rtllib_wx_set_scan.",
        "pre": {
            "ieee->iw_mode": "==IW_MODE_MONITOR || !(ieee->proto_started)",
            "ret": "==0",
            "ieee->link_state": "==MAC80211_LINKED"
        }
    }
},


{
    "kretprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "pre": {
            "dev": "!=null",
            "bInitState": "bool"
        }
    }
},
{
    "kprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "pre": {
            "dev": "!=null",
            "bInitState": "bool"
        }
    }
},

{
    "kprobe:your_function_name": {
        "description": "Description of your function",
        "pre": {
            "ieee->link_state": "!= MAC80211_NOLINK",
            "ieee->iw_mode": {
                "== IW_MODE_INFRA": {
                    "net->capability": "& WLAN_CAPABILITY_ESS"
                },
                "== IW_MODE_ADHOC": {
                    "net->capability": "& WLAN_CAPABILITY_IBSS",
                    "net->channel": "> ieee->ibss_maxjoin_chal"
                }
            },
            "ieee->iw_mode": {
                "== IW_MODE_INFRA": null,
                "== IW_MODE_ADHOC": null
            }
        }
    }
},
{
    "kretprobe:rtllib_frag_cache_find": {
        "description": "Find the fragment entry in the fragment cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rtllib_frag_cache_find": {
        "description": "Find a fragment entry in the rtllib_frag_cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "for (i = 0; i < NUM_WEP_KEYS; i++)": {
        "description": "Loop over the WEP keys",
        "pre": {
            "i": ">= 0",
            "i": "< NUM_WEP_KEYS"
        }
    }
},
{
    "kprobe:rtllib_wx_set_encode": {
        "description": "Set the encoding for the rtllib device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null"
        }
    }
},
{
    "kretprobe:rtllib_wx_set_encode_ext": {
        "description": "Set the encryption parameters for a wireless device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt_info.crypt[idx]": "!= null",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},
{
    "kprobe:rtllib_wx_set_encode_ext": {
        "description": "Set the wireless encryption parameters.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "ieee->iw_mode": "==IW_MODE_INFRA",
            "idx": "!=0",
            "ext->alg": "!=IW_ENCODE_ALG_WEP",
            "encoding->flags & IW_ENCODE_DISABLED": "==0",
            "ext->alg": "!=IW_ENCODE_ALG_NONE"
        }
    }
},


{
    "kretprobe:alloc_rtllib": {
        "description": "Allocate rtllib device and initialize its variables.",
        "pre": {
            "ieee": "!=null",
            "sizeof_priv": "int",
            "dev": "!=null",
            "i": "int",
            "err": "int"
        },
        "post": {
            "ieee->fts": "DEFAULT_FTS",
            "ieee->scan_age": "DEFAULT_MAX_SCAN_AGE",
            "ieee->open_wep": "1"
        }
    }
},

{
    "kretprobe:rtllib_xmit_inter": {
        "description": "Transmit an skb on a rtllib device.",
        "pre": {
            ".duration_id": "== 0",
            ".seq_ctl": "== 0",
            ".qos_ctl": "== 0",
            "qos_activated": "== 1",
            "dest": "!= null",
            "src": "!= null",
            "crypt": "== null",
            "tcb_desc": "!= null",
            "bIsMulticast": "== false",
            "IsAmsdu": "== false",
            "boolbdhcp": "== false",
            "ieee->lock": "locked"
        }
    }
},

{
    "kretprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, -error_code]"
        }
    }
},
{
    "kretprobe:nvec_register_notifier": {
        "description": "Register a notifier block for nvec_chip events.",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": ">=0",
            "nvec_write_sync()": "called before nvec_register_notifier"
        }
    }
},
{
    "kprobe:nvec_register_notifier": {
        "description": "Register a notifier block for nvec events.",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_write_spi_emulate_9": {
        "description": "write SPI emulating 9-bit",
        "pre": {
            "par": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "len": "% 8 == 0",
            "par->extra": "!=null"
        }
    }
},
{
    "kprobe:fbtft_write_spi_emulate_9": {
        "description": "write SPI emulating 9-bit",
        "pre": {
            "par": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "len": "% 8 == 0",
            "par->extra": "!=null"
        }
    }
},




{
    "kretprobe:fbtft_write_vmem16_bus8": {
        "description": "Buffered write function for fbtft driver.",
        "pre": {
            "par->txbuf.buf": "==null",
            "par->fbtftops.write": "!=null",
            "vmem16": "!=null",
            "len": "!=null"
        }
    }
},

{
    "kretprobe:fbtft_write_vmem16_bus16": {
        "description": "Write the virtual memory buffer with 16-bit bus.",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:fbtft_write_vmem16_bus16": {
        "description": "Write the value of the entry in the screen buffer at the specified offset with 16-bit bus.",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:fbtft_register_backlight": {
        "description": "Register the backlight for the fbtft device.",
        "pre": {
            "par": "!=null",
            "bd": "!=null",
            "bl_props.type": "BACKLIGHT_RAW",
            "par->gpio.led[0]": "==false"
        }
    }
},
{
    "kprobe:fbtft_register_backlight": {
        "description": "Register the backlight for the fbtft device.",
        "pre": {
            "par": "!=null",
            "bd": "!=null",
            "bl_props.type": "BACKLIGHT_RAW",
            "par->gpio.led[0]": "==false"
        }
    }
},
{
    "kretprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure",
        "pre": {
            "display": "!=null",
            "dev": "!=null",
            "pdata": "!=null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure.",
        "pre": {
            "display": "!=null",
            "dev": "!=null",
            "pdata": "!=null",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a TFT frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a TFT frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function",
        "pre": {
            "par": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function",
        "pre": {
            "par": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_probe_common": {
        "description": "Generic device probe() helper function",
        "pre": {
            "display": "!=null",
            "sdev": "!=null",
            "pdev": "!=null",
            "sdev or pdev": "xor(sdev == null, pdev == null)",
            "return value": "==0"
        }
    }
},

{
    "kretprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:of_iommu_get_resv_regions": {
        "description": "Reserved region driver helper for device tree",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:of_iommu_get_resv_regions": {
        "description": "Reserved region driver helper for device tree.",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:iommu_group_alloc": {
        "description": "Allocate a new group",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iommu_group_alloc": {
        "description": "Allocate a new group",
        "pre": {
            "group": "!=null",
            "group->mutex": "unlocked",
            "group->default_domain": "!=null",
            "group->default_domain->type": "in [IOMMU_DOMAIN_BLOCKED, IOMMU_DOMAIN_IDENTITY, IOMMU_DOMAIN_UNMANAGED, IOMMU_DOMAIN_DMA, IOMMU_DOMAIN_DMA_FQ]"
        }
    }
},
{
    "kretprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources",
        "pre": {
            "domain": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources",
        "pre": {
            "domain": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:iommu_dma_get_resv_regions": {
        "description": "Reserved region driver helper",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:iommu_dma_get_resv_regions": {
        "description": "Reserved region driver helper",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},


{
    "kretprobe:amd_iommu_domain_enable_v2": {
        "description": "Save us all sanity checks whether devices already in the domain support IOMMUv2. Just force that the domain has no devices attached when it is switched into IOMMUv2 mode.",
        "pre": {
            "dom": "!=null",
            "pasids": "!=null",
            "pdom": "!=null",
            "flags": "!=null",
            "ret": "in [-EBUSY]"
        },
        "post": {
            "ret": "in [-EBUSY]"
        }
    }
},
{
    "kprobe:amd_iommu_domain_enable_v2": {
        "description": "Save us all sanity checks whether devices already in the domain support IOMMUv2. Just force that the domain has no devices attached when it is switched into IOMMUv2 mode.",
        "pre": {
            "dom": "!=null",
            "pasids": "!=null",
            "pdom": "!=null",
            "pdom->dev_cnt": "> 0",
            "pdom->flags & PD_IOMMUV2_MASK": "!= 0",
            "!pdom->gcr3_tbl": "true"
        },
        "post": {
            "ret": "-EBUSY"
        }
    }
},
{
    "kretprobe:device_flush_iotlb": {
        "description": "Command send function for flushing on-device TLB",
        "pre": {
            "dev_data": "!=null",
            "address": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:amd_iommu_flush_tlb_all": {
        "description": "Command send function for flushing on-device TLB",
        "pre": {
            "iommu": "!=null"
        }
    }
},
O,

{
    "kretprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used",
        "pre": {
            "pdev": "!=null",
            "pasid": "!=null",
            "sbdf": "!=null",
            "dev_state": "!=null",
            "dev_state->max_pasids": "!=null",
            "pasid_state": "!=null"
        }
    }
},
{
    "kprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used",
        "pre": {
            "pasid_state": "!=null"
        }
    }
},
{
    "kretprobe:amd_iommu_init_device": {
        "description": "Initialize the device state for AMD IOMMU",
        "pre": {
            "cc_platform_has(CC_ATTR_MEM_ENCRYPT)": true,
            "!amd_iommu_v2_supported()": true,
            "pasids <= 0 || pasids > (PASID_MASK + 1)": true,
            "sbdf": "!=null",
            "dev_state": "!=null",
            "dev_state->lock": "initialized",
            "dev_state->wq": "initialized",
            "dev_state->pdev": "!=null",
            "dev_state->sbdf": "!=null",
            "tmp": "!=null",
            "dev_state->pasid_levels": ">= 0",
            "dev_state->count": "1",
            "dev_state->max_pasids": "pasids",
            "ret": "-ENOMEM",
            "dev_state->states": "!=null",
            "dev_state->domain": "!=null"
        }
    }
},
{
    "kprobe:amd_iommu_init_device": {
        "description": "Initialize AMD IOMMU device",
        "pre": {
            "cc_platform_has(CC_ATTR_MEM_ENCRYPT)": true,
            "amd_iommu_v2_supported()": true,
            "pasids": {
                "constraint": "pasids <= 0 || pasids > (PASID_MASK + 1)",
                "value": "pasids"
            },
            "sbdf": {
                "constraint": "sbdf = get_pci_sbdf_id(pdev)",
                "value": "sbdf"
            },
            "dev_state": {
                "constraint": "dev_state = kzalloc(sizeof(*dev_state), GFP_KERNEL)",
                "value": "dev_state"
            },
            "dev_state == NULL": true,
            "spin_lock_init(&dev_state->lock)": true,
            "init_waitqueue_head(&dev_state->wq)": true,
            "dev_state->pdev": {
                "constraint": "dev_state->pdev = pdev",
                "value": "dev_state->pdev"
            },
            "dev_state->sbdf": {
                "constraint": "dev_state->sbdf = sbdf",
                "value": "dev_state->sbdf"
            },
            "tmp": {
                "constraint": "tmp = pasids",
                "value": "tmp"
            },
            "for (dev_state->pasid_levels = 0; (tmp - 1) & ~0x1ff; tmp >>= 9) dev_state->pasid_levels += 1": true,
            "atomic_set(&dev_state->count, 1)": true,
            "dev_state->max_pasids": {
                "constraint": "dev_state->max_pasids = pasids",
                "value": "dev_state->max_pasids"
            },
            "ret": {
                "constraint": "ret = -ENOMEM",
                "value": "ret"
            },
            "dev_state->states": {
                "constraint": "dev_state->states = (void *)get_zeroed_page(GFP_KERNEL)",
                "value": "dev_state->states"
            },
            "dev_state->states == NULL": true,
            "dev_state->domain": {
                "constraint": "dev_state->domain = iommu_domain_alloc(&pci_bus_type)",
                "value": "dev_state->domain"
            },
            "dev_state->domain == NULL": true
        }
    }
},
{
    "kretprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0, negative error value]"
        }
    }
},
{
    "kprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},


{
    "kretprobe:wait_event": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "pre": {
            "kc": "!=null",
            "atomic_read(&kc->nr_jobs)": "==0",
            "list_empty(&kc->callback_jobs)": "==true",
            "list_empty(&kc->complete_jobs)": "==true",
            "list_empty(&kc->io_jobs)": "==true",
            "list_empty(&kc->pages_jobs)": "==true"
        },
        "post": {
            "destroy_workqueue(kc->kcopyd_wq)": "called",
            "dm_io_client_destroy(kc->io_client)": "called",
            "client_free_pages(kc)": "called",
            "mempool_exit(&kc->job_pool)": "called",
            "kfree(kc)": "called"
        }
    }
},
{
    "kprobe:wait_event": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "pre": {
            "kc": "!=null",
            "atomic_read(&kc->nr_jobs)": "==0",
            "list_empty(&kc->callback_jobs)": "==true",
            "list_empty(&kc->complete_jobs)": "==true",
            "list_empty(&kc->io_jobs)": "==true",
            "list_empty(&kc->pages_jobs)": "==true",
            "kc->kcopyd_wq": "!=null",
            "kc->io_client": "!=null",
            "kc->job_pool": "initialized",
            "kc->kcopyd_wq->workqueue": "!=null"
        }
    }
},

{
    "kprobe:struct_io": {
        "description": "Helper for struct io",
        "pre": {
            "pool": "!=null",
            "bios": "!=null"
        }
    }
},
{
    "kretprobe:dm_kobject_release": {
        "description": "This function is called when releasing a dm kobject.",
        "pre": {
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:dm_kobject_release": {
        "description": "Release method for dm kobject.",
        "pre": {
            "kobj": "!=null"
        }
    }
},




{
    "kretprobe:return;if (bitmap->mddev->bitmap_info.external)return;if (!bitmap->storage.sb_page)": {
        "description": "Update the superblock of the bitmap.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null",
            "bitmap->mddev->bitmap_info.external": "false",
            "!bitmap->storage.sb_page": "true"
        }
    }
},
{
    "kprobe:return;if (bitmap->mddev->bitmap_info.external)return;if (!bitmap->storage.sb_page)": {
        "description": "Update the superblock of the bitmap.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null",
            "bitmap->mddev->bitmap_info.external": "false",
            "bitmap->storage.sb_page": "!=null"
        }
    }
},




{
    "kretprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync(struct bitmap  bitmap, sector_t offset, sector_t  block int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": "!=null",
            "blocks": "<= (PAGE_SIZE>>9)",
            "degraded": "!=null"
        }
    }
},
{
    "kprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync(struct bitmap  bitmap, sector_t offset, sector_t  block int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": "!=null",
            "blocks": "<= (PAGE_SIZE>>9)",
            "degraded": "!=null"
        }
    }
},




{
    "kretprobe:return": {
        "description": "The return value of the function.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->sysfs_can_clear": "==true",
            "bitmap->mddev": "!=null",
            "mddev_is_clustered(bitmap->mddev)": "==true",
            "bitmap->mddev->cluster_info": "!=null",
            "bitmap->cluster_slot": "md_cluster_ops->slot_number(bitmap->mddev)"
        }
    }
},
{
    "kprobe:return": {
        "description": "Return statement",
        "pre": {}
    },
    "kprobe:if (bitmap->sysfs_can_clear)sysfs_put(bitmap->sysfs_can_clear);": {
        "description": "Check if sysfs_can_clear is not null and call sysfs_put",
        "pre": {
            "bitmap->sysfs_can_clear": "!=null"
        }
    },
    "kprobe:if (mddev_is_clustered(bitmap->mddev) && bitmap->mddev->cluster_info &&bitmap->cluster_slot == md_cluster_ops->slot_number(bitmap->mddev))md_cluster_stop(bitmap->mddev);": {
        "description": "Check if mddev is clustered, cluster_info is not null, and cluster_slot matches slot_number",
        "pre": {
            "mddev_is_clustered(bitmap->mddev)": "true",
            "bitmap->mddev->cluster_info": "!=null",
            "bitmap->cluster_slot": "==md_cluster_ops->slot_number(bitmap->mddev)"
        }
    },
    "kprobe:/* Shouldn't be needed - but just in case.... */": {
        "description": "Comment",
        "pre": {}
    }
},

{
    "kprobe:md_handle_request": {
        "description": "Handle a request in the mddev structure with the given bio.",
        "pre": {
            "mddev": "!=null",
            "bio": "!=null",
            "bio->bi_opf": "& REQ_NOWAIT != 0"
        }
    }
},
{
    "kretprobe:wait_event_lock_irq": {
        "description": "Flush requests wait until ongoing flush complete hence coalescing all the pending requests.",
        "pre": {
            "mddev->sb_wait": "!=null",
            "!mddev->flush_bio || ktime_before(req_start, mddev->prev_flush_start)",
            "mddev->lock": "!=null"
        }
    }
},
{
    "kprobe:wait_event_lock_irq": {
        "description": "Wait for an event while holding a lock and handling IRQs.",
        "pre": {
            "mddev": "!=null",
            "mddev->sb_wait": "!=null",
            "mddev->flush_bio": "!=null",
            "req_start": "!=null",
            "mddev->prev_flush_start": "!=null",
            "mddev->lock": "!=null",
            "!mddev->flush_bio || ktime_before(req_start, mddev->prev_flush_start)": "true"
        }
    }
},

{
    "kprobe:md_integrity_register": {
        "description": "Register integrity for md device",
        "pre": {
            "!mddev->gendisk": "true",
            "blk_get_integrity(mddev->gendisk)": "true"
        }
    }
},
{
    "kretprobe:md_integrity_add_rdev": {
        "description": "Add a new device to the MD RAID array with integrity checking.",
        "pre": {
            "mddev": "!=null",
            "rdev": "!=null",
            "mddev->gendisk": "!=null",
            "rdev->bdev->bd_disk": "!=null",
            "blk_integrity_compare(mddev->gendisk, rdev->bdev->bd_disk)": "==0"
        }
    }
},
{
    "kprobe:return 0;if (blk_integrity_compare(mddev->gendisk, rdev->bdev->bd_disk) != 0)": {
        "description": "Check the integrity of the block device associated with the given mddev.",
        "pre": {
            "mddev->gendisk": "!= null",
            "rdev->bdev->bd_disk": "!= null"
        }
    }
},






{
    "kretprobe:md_super_write": {
        "description": "Write first size bytes of page to sector of rdev. Increment mddev->pending_writes before returning and decrement it on completion, waking up sb_wait if zero is reached. If an error occurred, call md_error.",
        "pre": {
            "page": "!=null",
            "rdev->flags[Faulty]": "false",
            "rdev->meta_bdev": "!=null",
            "rdev->bdev": "!=null",
            "sector": "!=null",
            "size": "!=null",
            "mddev->flags[MD_FAILFAST_SUPPORTED]": "true",
            "rdev->flags[FailFast]": "true",
            "rdev->flags[LastDev]": "false"
        }
    }
},
{
    "kprobe:md_super_write": {
        "description": "Write the first size bytes of the page to the sector of rdev. Increment mddev->pending_writes before returning and decrement it on completion, waking up sb_wait if zero is reached. If an error occurred, call md_error.",
        "pre": {
            "mddev": "!=null",
            "rdev": "!=null",
            "sector": "!=null",
            "size": "!=null",
            "page": "!=null"
        }
    }
},




{
    "kretprobe:md_write_inc": {
        "description": "Incremental write operation in mddev",
        "pre": {
            "mddev": "!=null",
            "bi": "!=null"
        }
    }
},







{
    "kretprobe:ad_dpot_probe": {
        "description": "Probe function for ad_dpot",
        "pre": {
            "data->feat": "& F_RDACS_WONLY",
            "data->rdac_cache[i]": "= data->max_pos / 2"
        }
    },
    "kretprobe:ad_dpot_probe": {
        "description": "Probe function for ad_dpot",
        "pre": {
            "data->feat": "& F_CMD_INC",
            "err": "= sysfs_create_group(&dev->kobj, &ad525x_group_commands)"
        }
    }
},
{
    "kprobe:if (data->feat & F_RDACS_WONLY)data->rdac_cache[i] = data->max_pos / 2;}if (data->feat & F_CMD_INC)err = sysfs_create_group(&dev->kobj, &ad525x_group_commands);if (err)": {
        "description": "The given function performs certain operations based on the values of 'data->feat' and 'F_RDACS_WONLY' and 'F_CMD_INC'. It updates the 'data->rdac_cache[i]' with 'data->max_pos / 2' if 'data->feat & F_RDACS_WONLY' is true. It also creates a sysfs group using 'sysfs_create_group' if 'data->feat & F_CMD_INC' is true.",
        "pre": {
            "data->feat": "& F_RDACS_WONLY != 0",
            "data->rdac_cache[i]": "= data->max_pos / 2",
            "err": "= sysfs_create_group(&dev->kobj, &ad525x_group_commands)"
        }
    }
},
{
    "kretprobe:c2port_device_register": {
        "description": "Registers a C2 port device.",
        "pre": {
            "ops": "!=null",
            "ops->access": "!=null",
            "ops->c2d_dir": "!=null",
            "ops->c2ck_set": "!=null",
            "ops->c2d_get": "!=null",
            "ops->c2d_set": "!=null"
        }
    }
},
{
    "c2port_device_register": {
        "pre": {
            "name": "!=null",
            "ops": {
                "access": "!=null",
                "c2d_dir": "!=null",
                "c2ck_set": "!=null",
                "c2d_get": "!=null",
                "c2d_set": "!=null",
                "blocks_num": ">0",
                "block_size": ">0"
            },
            "devdata": "any"
        },
        "description": "Registers a C2 port device with the given name and operations."
    }
},
{
    "kretprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:fwnode_irq_get_byname": {
        "description": "Get IRQ from a fwnode using its name",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:fwnode_irq_get_byname": {
        "description": "Get IRQ from a fwnode using its name",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null"
        }
    }
},






{
    "kretprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that.",
        "pre": {
            "dev": "!=null",
            "gfp": "!=null",
            "fmt": "!=null",
            "ap": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that.",
        "pre": {
            "dev": "!=null",
            "gfp": "!=null",
            "fmt": "!=null",
            "ap": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kprobe:request_firmware_prepare": {
        "description": "Prepare to request firmware.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "dbuf": "!=null",
            "size": ">=0",
            "offset": ">=0",
            "opt_flags": ">=0"
        }
    }
},
{
    "kretprobe:firmware_request_cache": {
        "description": "Request firmware with no uevent set.",
        "pre": {
            "device": "!=null",
            "name": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},

{
    "kretprobe:intrequest_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:intrequest_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:fw_abort_batch_reqs": {
        "description": "Handle failed batched requests and delay the release of struct fw_priv.",
        "pre": {
            "fw": "!=null"
        }
    }
},

{
    "kretprobe:if (capable(CAP_SYS_RAWIO))return true;/* Anybody who can open the device can do a read-safe command `": {
        "description": "Check if the user is capable of performing raw I/O operations and return true if so.",
        "pre": {
            "capable": "CAP_SYS_RAWIO",
            "open_for_write": "false"
        }
    }
},
{
    "kprobe:if (capable(CAP_SYS_RAWIO))return true;/* Anybody who can open the device can do a read-safe command `": {
        "description": "Check if the current user has the capability CAP_SYS_RAWIO and return true if so.",
        "pre": {
            "cmd": "!=null",
            "open_for_write": "!=null"
        }
    }
},
{
    "kretprobe:ioctl_probe": {
        "description": "Return host identification",
        "pre": {
            "host": "!=null",
            "buffer": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ioctl_probe": {
        "description": "Return host identification",
        "pre": {
            "host": "!=null",
            "buffer": "!=null"
        }
    }
},


{
    "kretprobe:scsi_print_command": {
        "description": "Print SCSI command details.",
        "pre": {
            "cmd": {
                "cmd_len": "> 16"
            }
        }
    }
},
{
    "kprobe:scsi_print_command": {
        "description": "Print SCSI command details.",
        "pre": {
            "cmd": {
                "cmd_len": ">16"
            }
        }
    }
},
{
    "kretprobe:scsi_change_queue_depth": {
        "description": "Change a device's queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kprobe:scsi_change_queue_depth": {
        "description": "Change a device's queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kretprobe:scsi_track_queue_full": {
        "description": "Track QUEUE_FULL events to adjust queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kprobe:scsi_track_queue_full": {
        "description": "Track QUEUE_FULL events to adjust queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kretprobe:scsi_report_opcode": {
        "description": "Find out if a given command is supported",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null",
            "len": ">=20",
            "opcode": "!=null",
            "sa": ">=0"
        }
    }
},
{
    "kprobe:scsi_report_opcode": {
        "description": "Find out if a given command is supported",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null",
            "len": ">=20",
            "opcode": "!=null",
            "sa": ">=0"
        }
    }
},
{
    "kretprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null",
            "host_lock": "held",
            "device_status": "not in [DEVICE_DELETED, DEVICE_CANCELLED]",
            "lld_module_status": "not in [MODULE_UNLOADING]"
        }
    }
},
{
    "kprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null",
            "host_lock": "held",
            "device_status": "not in [deleted, cancelled]",
            "lld_module_status": "not in [unloading]"
        }
    }
},
{
    "kretprobe:scsi_device_put": {
        "description": "Release a reference to a scsi_device and decrements the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_put": {
        "description": "Release a reference to a scsi_device and decrement the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:__scsi_iterate_devices": {
        "description": "__scsi_iterate_devices function",
        "pre": {
            "shost": "!=null",
            "prev": "!=null",
            "list": "!=null",
            "next": "!=null",
            "flags": "unsigned long",
            "shost.host_lock": "spin lock",
            "list->next": "!= &shost->__devices",
            "next": "list_entry(list->next, struct scsi_device, siblings)",
            "prev": "!=null"
        }
    }
},
{
    "kprobe:__scsi_iterate_devices": {
        "description": "Iterate through SCSI devices",
        "pre": {
            "shost": "!=null",
            "prev": "!=null",
            "list": "!=null",
            "next": "==null",
            "flags": "unsigned long",
            "list->next": "!=&shost->__devices",
            "!scsi_device_get(next)": "true"
        }
    }
},
{
    "kretprobe:starget_for_each_device": {
        "description": "Helper to walk all devices of a target",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:starget_for_each_device": {
        "description": "Helper to walk all devices of a target",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:__scsi_device_lookup_by_target": {
        "description": "Find a device given the target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "lun": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__scsi_device_lookup_by_target": {
        "description": "Find a device given the target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "lun": "!=null"
        }
    }
},
{
    "kretprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued.",
        "pre": {
            "sdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kretprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with.",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with.",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them.",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them.",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_bus_reset": {
        "description": "ask host to perform a bus reset",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_bus_reset": {
        "description": "Ask host to perform a bus reset.",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset",
        "pre": {
            "scmd": "!=null",
            "sdev": {
                "was_reset": 1,
                "expecting_cc_ua": 1
            }
        }
    }
},


{
    "kretprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format).",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer failure timers",
        "pre": {
            "rport": "!=null",
            "rport->mutex": "held",
            "rport->reconnect_delay": ">=0",
            "rport->fast_io_fail_tmo": ">=0",
            "rport->dev_loss_tmo": ">=0",
            "rport->state": "!=SRP_RPORT_LOST"
        }
    }
},
{
    "kprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer failure timers",
        "pre": {
            "rport": "!=null",
            "rport->mutex": "held",
            "rport->reconnect_delay": ">=0",
            "rport->fast_io_fail_tmo": ">=0",
            "rport->dev_loss_tmo": ">=0",
            "rport->state": "not in [SRP_RPORT_LOST]",
            "shost": "!=null",
            "shost->shost_gendev": "!=null",
            "dev_name(&shost->shost_gendev)": "!=null",
            "system_long_wq": "!=null",
            "HZ": "constant"
        }
    }
},
{
    "kretprobe:__rport_fail_io_fast": {
        "description": "This function is called when an I/O operation fails on the SRP rport.",
        "pre": {
            "rport": "!=null",
            "res": "!=0",
            "shost": "!=null",
            "rport->failed_reconnects": ">=0",
            "rport->reconnect_delay": ">=0",
            "delay": ">=0",
            "system_long_wq": "!=null",
            "rport->reconnect_work": "!=null",
            "HZ": ">=0",
            "scsi_block_targets()": "called before this function"
        }
    }
},
{
    "kprobe:__rport_fail_io_fast": {
        "description": "This function is called when an I/O operation fails on the SRP rport.",
        "pre": {
            "rport": "!=null",
            "res": "==0",
            "shost": "!=null",
            "rport->failed_reconnects": ">=0",
            "rport->reconnect_delay": ">=0",
            "delay": ">=0",
            "system_long_wq": "!=null",
            "rport->reconnect_work": "!=null",
            "HZ": ">=0"
        }
    }
},
{
    "kretprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "==0 if sg lists are NULL",
            "return_value": "== -ENOMEM if mapping failed"
        }
    }
},
{
    "kprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": ">=0"
        },
        "error": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:scsi_dma_unmap": {
        "description": "Unmap command's sg lists mapped by scsi_dma_map",
        "pre": {
            "cmd": "!=null"
        }
    }
},

{
    "kretprobe:u32fc_get_event_number": {
        "description": "Obtain the next sequential FC event number",
        "pre": {
            "fc_event_seq": "!=null"
        }
    }
},

{
    "kretprobe:fc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kprobe:fc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_post_event": {
        "description": "Called to post an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "event_data": "!=null"
        }
    }
},
{
    "kprobe:void fc_host_post_event": {
        "description": "Called to post an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "event_data": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "data_len": "!=null",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kprobe:fc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn",
        "pre": {
            "shost": "!=null",
            "wwpn": "!=null"
        }
    }
},
{
    "kprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn",
        "pre": {
            "shost": "!=null",
            "wwpn": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN.",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kprobe:fc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN.",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_attach_transport": {
        "description": "Attach a transport to the fc_function_template.",
        "pre": {
            "ft": "!=null",
            "i": "!=null",
            "i->t.target_attrs.ac.attrs": "!=null",
            "i->t.target_attrs.ac.class": "&fc_transport_class.class",
            "i->t.target_attrs.ac.match": "fc_target_match",
            "i->t.target_size": "sizeof(struct fc_starget_attrs)",
            "i->t.host_attrs.ac.attrs": "!=null",
            "i->t.host_attrs.ac.class": "&fc_host_class.class",
            "i->t.host_attrs.ac.match": "fc_host_match",
            "i->t.host_size": "sizeof(struct fc_host_attrs)",
            "i->rport_attr_cont.ac.attrs": "!=null",
            "i->rport_attr_cont.ac.class": "&fc_rport_class.class",
            "i->rport_attr_cont.ac.match": "fc_rport_match",
            "i->vport_attr_cont.ac.attrs": "!=null",
            "i->vport_attr_cont.ac.class": "&fc_vport_class.class",
            "i->vport_attr_cont.ac.match": "fc_vport_match",
            "i->f": "ft"
        },
        "post": {
            "i->t.create_work_queue": 1,
            "i->t.user_scan": "fc_user_scan"
        }
    }
},
{
    "kprobe:fc_attach_transport": {
        "description": "Setup SCSI Target Attributes.",
        "pre": {
            "ft": "!=null",
            "i": "!=null",
            "i->t.create_work_queue": "==1",
            "i->t.user_scan": "fc_user_scan"
        }
    }
},
{
    "kretprobe:fc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:void_fc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_create": {
        "description": "Create a new remote port entry",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        },
        "post": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:fc_remote_port_create": {
        "description": "Creates a remote port entry.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        },
        "post": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport.",
        "pre": {
            "rport": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport",
        "pre": {
            "cmnd": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport",
        "pre": {
            "cmnd": "!=null"
        }
    }
},
{
    "kretprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},




{
    "kretprobe:spi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:spi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement",
        "pre": {
            "starget": "!=null"
        }
    }
},
{
    "kprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement",
        "pre": {
            "starget": "!=null"
        }
    }
},

{
    "kprobe:} else if (msg[0] & 0x80)": {
        "description": "Identify",
        "pre": {
            "msg": "!=null",
            "msg[0]": "& 0x80 != 0"
        }
    }
},


{
    "kretprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:sas_get_address": {
        "description": "Return the SAS address of the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:sas_get_address": {
        "description": "Return the SAS address of the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_alloc": {
        "description": "Allocates and initializes a SAS PHY structure.",
        "pre": {
            "parent": "!=null",
            "number": ">=0"
        }
    }
},
{
    "kprobe:sas_phy_alloc": {
        "description": "Allocates and initializes a SAS PHY structure.",
        "pre": {
            "parent": "!=null",
            "number": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_free": {
        "description": "Free a SAS PHY",
        "pre": {
            "phy": "!=null",
            "phy->added": "==false"
        }
    }
},
{
    "kprobe:sas_phy_free": {
        "description": "Free a SAS PHY",
        "pre": {
            "phy": "!=null",
            "phy->added": "==false"
        }
    }
},
{
    "kretprobe:sas_port_alloc": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "port_id": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:sas_port_alloc": {
        "description": "Allocate and initialize a SAS port structure.",
        "pre": {
            "parent": "!=null",
            "port_id": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_alloc_num": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:sas_port_alloc_num": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_free": {
        "description": "Free a SAS PORT",
        "pre": {
            "port": "!=null",
            "port->added": "==false"
        }
    }
},
{
    "kprobe:sas_port_free": {
        "description": "Free a SAS PORT",
        "pre": {
            "port": "!=null",
            "port->added": "==false"
        }
    }
},
{
    "kretprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null",
            "port->phys": ">= 0",
            "port->phys_count": ">= 0",
            "port->phys_count": ">= 1",
            "port->phys_count": ">= 2 when port->wide_port == true"
        }
    }
},
{
    "kprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_initialize": {
        "description": "common rphy initialization",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_initialize": {
        "description": "common rphy initialization",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy",
        "pre": {
            "rphy": "!=null"
        }
    }
},


{
    "kretprobe:scsi_is_sas_port": {
        "description": "Check if a struct device represents a SAS port",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:scsi_is_sas_port": {
        "description": "Check if a struct device represents a SAS port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template.",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kretprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kretprobe:scsi_esp_register": {
        "description": "Register SCSI ESP device",
        "pre": {
            "esp": {
                "num_tags": "!=null"
            },
            "esp->host": {
                "transportt": "esp_transport_template",
                "max_lun": "ESP_MAX_LUN",
                "cmd_per_lun": 2,
                "unique_id": "instance"
            },
            "esp->host->irq": "!=null",
            "esp->dev": "!=null",
            "esp->rev": "!=null",
            "esp->cfreq": "!=null",
            "esp->cfact": "!=null",
            "esp->scsi_id": "!=null"
        }
    }
},

{
    "kretprobe:scsi_remove_host": {
        "description": "Remove a SCSI host",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_remove_host": {
        "description": "Remove a SCSI host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:scsi_add_host_with_dma": {
        "description": "Add a SCSI host with DMA device",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:scsi_add_host_with_dma": {
        "description": "Add a SCSI host with a DMA device.",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        }
    }
},


{
    "kretprobe:scsi_host_lookup": {
        "description": "Look up a SCSI host based on the host number.",
        "pre": {
            "hostnum": "!=null"
        }
    }
},

{
    "kretprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "pre": {
            "shost": "!=null"
        }
    }
},


{
    "kretprobe:#ifdef PROC_STATISTICShostdata->cmd_cnt[i] = 0;hostdata->disc_allowed_cnt[i] = 0;hostdata->disc_done_cnt[i] = 0;#endif}hostdata->input_Q = NULL;hostdata->selecting = NULL;hostdata->connected = NULL;hostdata->disconnected_Q = NULL;hostdata->state = S_UNCONNECTED;hostdata->dma = D_DMA_OFF;hostdata->level2 = L2_BASIC;hostdata->disconnect = DIS_ADAPTIVE;hostdata->args = DEBUG_DEFAULTS;hostdata->incoming_ptr = 0;hostdata->outgoing_len = 0;hostdata->default_sx_per = DEFAULT_SX_PER;hostdata->no_dma = 0;/* default is DMA enabled`": {
        "description": "Set various variables and fields to their default values.",
        "pre": {
            "hostdata->cmd_cnt[i]": "= 0",
            "hostdata->disc_allowed_cnt[i]": "= 0",
            "hostdata->disc_done_cnt[i]": "= 0",
            "hostdata->input_Q": "= NULL",
            "hostdata->selecting": "= NULL",
            "hostdata->connected": "= NULL",
            "hostdata->disconnected_Q": "= NULL",
            "hostdata->state": "= S_UNCONNECTED",
            "hostdata->dma": "= D_DMA_OFF",
            "hostdata->level2": "= L2_BASIC",
            "hostdata->disconnect": "= DIS_ADAPTIVE",
            "hostdata->args": "= DEBUG_DEFAULTS",
            "hostdata->incoming_ptr": "= 0",
            "hostdata->outgoing_len": "= 0",
            "hostdata->default_sx_per": "= DEFAULT_SX_PER",
            "hostdata->no_dma": "= 0"
        }
    }
},

{
    "kretprobe:tmp = (struct scsi_cmnd *) hostdata->input_Q; prev = NULL; while (tmp)": {
        "description": "Assign the value of hostdata->input_Q to tmp and initialize prev as NULL. Then, iterate over the linked list until tmp becomes NULL.",
        "pre": {
            "hostdata": "!=null",
            "hostdata->input_Q": "!=null",
            "tmp": "!=null",
            "prev": "==null"
        }
    }
},
{
    "kprobe:tmp = (struct scsi_cmnd *) hostdata->input_Q;prev = NULL;while (tmp)": {
        "description": "Loop through the input_Q and assign the value of tmp to each element of the input_Q.",
        "pre": {
            "hostdata": "!=null",
            "tmp": "!=null",
            "prev": "null"
        }
    }
},
{
    "kretprobe:cmd->host_scribble = NULL;cmd->result = 0;/* We use the Scsi_Pointer structure that's included with each command * as a scratchpad (as it's intended to be used!). The handy thing about * the SCp.xxx fields is that they're always associated with a given * cmd, and are preserved across disconnect-reselect. This means we * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages * if we keep all the critical pointers and counters in SCp: *  - SCp.ptr is the pointer into the RAM buffer *  - SCp.this_residual is the size of that buffer *  - SCp.buffer points to the current scatter-gather buffer *  - SCp.buffers_residual tells us how many S.G. buffers there are *  - SCp.have_data_in is not used *  - SCp.sent_command is not used *  - SCp.phase records this command's SRCID_ER bit setting `": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use.",
        "pre": {
            "cmd->host_scribble": "==null",
            "cmd->result": "==0"
        }
    }
},
{
    "kprobe:cmd->host_scribble = NULL;cmd->result = 0;/* We use the Scsi_Pointer structure that's included with each command * as a scratchpad (as it's intended to be used!). The handy thing about * the SCp.xxx fields is that they're always associated with a given * cmd, and are preserved across disconnect-reselect. This means we * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages * if we keep all the critical pointers and counters in SCp: *  - SCp.ptr is the pointer into the RAM buffer *  - SCp.this_residual is the size of that buffer *  - SCp.buffer points to the current scatter-gather buffer *  - SCp.buffers_residual tells us how many S.G. buffers there are *  - SCp.have_data_in is not used *  - SCp.sent_command is not used *  - SCp.phase records this command's SRCID_ER bit setting `": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use.",
        "pre": {
            "cmd->host_scribble": "==null",
            "cmd->result": "==0"
        }
    }
},


{
    "kretprobe:wd33c93_show_info": {
        "description": "Show information about the WD33C93 host.",
        "pre": {
            "m": "!=null",
            "instance": "!=null",
            "hd": "!=null",
            "cmd": "!=null",
            "x": "int",
            "hd.proc": "& PR_VERSION | PR_INFO | PR_STATISTICS | PR_CONNECTED | PR_INPUTQ | PR_DISCQ",
            "hd.clock_freq": "int",
            "hd.no_sync": "int",
            "hd.no_dma": "int",
            "hd.dma_mode": "int",
            "hd.fast": "int",
            "hd.sync_xfer": "array[7] of int",
            "hd.sync_stat": "array[7] of int",
            "hd.cmd_cnt": "array[7] of long",
            "hd.disc_allowed_cnt": "array[7] of long",
            "hd.disc_done_cnt": "array[7] of long",
            "hd.int_cnt": "long",
            "hd.dma_cnt": "long",
            "hd.pio_cnt": "long",
            "hd.connected": "bool",
            "cmd.device.id": "int",
            "cmd.device.lun": "long",
            "cmd.cmnd[0]": "int",
            "hd.input_Q": "!=null",
            "hd.disconnected_Q": "!=null"
        }
    }
},
{
    "kprobe:wd33c93_show_info": {
        "description": "Show information about the WD33C93 host.",
        "pre": {
            "m": "!=null",
            "instance": "!=null"
        }
    }
},
{
    "kretprobe:buf[len] = '\\0'; for (bp = buf; *bp; )": {
        "description": "Write information to wd33c93",
        "pre": {
            "instance": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:buf[len] = '\\0'; for (bp = buf; *bp; )": {
        "description": "Loop over the characters in the buffer array until a null character is encountered.",
        "pre": {
            "instance": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key.",
        "pre": {
            "compatible": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null",
            "flags": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key. If @compatible, add to the tail of the list, do not space pad, and set devinfo->compatible. The scsi_static_device_list entries are added with @compatible 1 and @clfags NULL.",
        "pre": {
            "compatible": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null",
            "flags": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key.",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [enum values]"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key.",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:scsi_get_device_flags_keyed": {
        "description": "Get device specific flags from the dynamic device list",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        }
    }
},
{
    "kprobe:scsi_get_device_flags_keyed": {
        "description": "Get device specific flags from the dynamic device list.",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        }
    }
},
{
    "kretprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list",
        "pre": {
            "key": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list",
        "pre": {
            "key": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH]",
            "buffer": "!=null",
            "bufflen": ">0",
            "timeout": ">=0",
            "retries": ">=0",
            "args": "optional"
        }
    }
},
{
    "kprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result.",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "!=null",
            "buffer": "!=null",
            "bufflen": "!=null",
            "timeout": "!=null",
            "retries": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kretprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "pre": {
            "shost": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "pre": {
            "shost": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kretprobe:scsi_block_requests": {
        "description": "Block SCSI requests",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_block_requests": {
        "description": "Block SCSI requests for the given SCSI host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:intscsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary.",
        "pre": {
            "sdev": "!=null",
            "dbd": "in [0, 1]",
            "modepage": "!=null",
            "subpage": "!=null",
            "buffer": "!=null",
            "len": ">=8",
            "timeout": ">=0",
            "retries": ">=0",
            "data": "!=null",
            "sshdr": "in [null, SCSI_SENSE_BUFFERSIZE]"
        }
    }
},
{
    "kprobe:intscsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary.",
        "pre": {
            "sdev": "!=null",
            "dbd": "in [0, 1]",
            "modepage": "!=null",
            "subpage": "!=null",
            "buffer": "!=null",
            "len": ">=8",
            "timeout": ">=0",
            "retries": ">=0",
            "data": "!=null",
            "sshdr": "in [null, SCSI_SENSE_BUFFERSIZE]"
        }
    }
},
{
    "kretprobe:intscsi_test_unit_ready": {
        "description": "Test if unit is ready",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:intscsi_test_unit_ready": {
        "description": "Test if unit is ready",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kretprobe:intscsi_device_set_state": {
        "description": "Take the given device through the device state model.",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_STATE_RUNNING, SCSI_STATE_BLOCK]",
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:intscsi_device_set_state": {
        "description": "Take the given device through the device state model.",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_STATE_RUNNING, SCSI_STATE_BLOCK]",
            "return": "int"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:intscsi_device_quiesce": {
        "description": "Block all commands except power management.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:intscsi_device_quiesce": {
        "description": "Block all commands except power management.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element.",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element.",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual addres previously mapped with scsi_kmap_atomic_sg.",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual addres previously mapped with scsi_kmap_atomic_sg.",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kretprobe:scsi_vpd_lun_id": {
        "description": "Return a unique device identification based on the information in the VPD page 0x83 of the device.",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">=0"
        }
    }
},
{
    "kprobe:scsi_vpd_lun_id": {
        "description": "Return a unique device identification based on the information in the VPD page 0x83 of the device.",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_vpd_tpg_id": {
        "description": "Return a target port group identifier from VPD page 0x83 of the SCSI device.",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kprobe:scsi_vpd_tpg_id": {
        "description": "Return a target port group identifier from VPD page 0x83 of the SCSI device.",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "pre": {
            "type": "!=null"
        },
        "post": {
            "return_value": "in scsi_device_types"
        }
    }
},
{
    "kprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "pre": {
            "type": "!=null",
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsilun_to_int": {
        "description": "Convert a scsi_lun to an int",
        "pre": {
            "scsilun": "!=null"
        }
    }
},
{
    "kprobe:scsilun_to_int": {
        "description": "Convert a scsi_lun to an int",
        "pre": {
            "scsilun": "!=null"
        }
    }
},
{
    "kretprobe:int_to_scsilun": {
        "description": "Reverts an int into a scsi_lun",
        "pre": {
            "lun": "!=null",
            "scsilun": "!=null"
        },
        "post": {
            "scsilun": "is struct scsi_lun",
            "scsilun.lun[0]": "== 0x04",
            "scsilun.lun[1]": "== 0xd2",
            "scsilun.lun[2]": "== 0x0b",
            "scsilun.lun[3]": "== 0x03",
            "scsilun.lun[4]": "== 0x00",
            "scsilun.lun[5]": "== 0x00",
            "scsilun.lun[6]": "== 0x00",
            "scsilun.lun[7]": "== 0x00"
        }
    }
},
{
    "kprobe:int_to_scsilun": {
        "description": "Reverts an int into a scsi_lun",
        "pre": {
            "lun": "!=null",
            "scsilun": "!=null"
        }
    }
},
{
    "kretprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kretprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer",
        "pre": {
            "desc": "!=null",
            "buf": "!=null",
            "key": "!=null",
            "asc": "!=null",
            "ascq": "!=null"
        }
    }
},
{
    "kprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer.",
        "pre": {
            "desc": "!=null",
            "buf": "!=null",
            "key": "!=null",
            "asc": "!=null",
            "ascq": "!=null"
        }
    }
},
{
    "kretprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "info": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "fp": ">=0",
            "bp": ">=0",
            "cd": "in [0, 1]"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "fp": ">=0",
            "bp": ">=0",
            "cd": "in [0, 1]"
        }
    }
},
{
    "kretprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null"
        },
        "post": {
            "return_value": "in [CHIP_TYPE_A, CHIP_TYPE_B, CHIP_TYPE_C]"
        }
    }
},
{
    "kprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_queuecommand_lck": {
        "description": "The qlogicfas408_queuecommand_lck function",
        "pre": {
            "cmd": "!=null",
            "done": "!=null",
            "priv": "!=null",
            "priv->qlcmd": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_queuecommand_lck": {
        "description": "Function for handling SCSI commands in the qlogicfas408 driver.",
        "pre": {
            "cmd": "!=null",
            "done": "!=null",
            "priv": "!=null",
            "priv->qlcmd": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_host_reset": {
        "description": "Reset SCSI bus",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_host_reset": {
        "description": "Reset SCSI bus",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_info": {
        "description": "Return info string",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_info": {
        "description": "Return info string",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": "!=null",
            "ip": "!=null",
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "==(unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2] > 1024": "true"
        }
    }
},
{
    "kprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": "!=null",
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "==(unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2] > 1024": "true"
        }
    }
},


{
    "kretprobe:qlogicfas408_setup": {
        "description": "Perform initialization tasks",
        "pre": {
            "qbase": "!=null",
            "id": "!=null",
            "int_type": "!=null"
        }
    }
},



{
    "kretprobe:qlogicfas408_disable_ints": {
        "description": "Disable interrupts",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null",
            "((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7)": true
        }
    }
},



{
    "kretprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_partsize": {
        "description": "Parse cylinder head sectors from PC partition table",
        "pre": {
            "bdev": "!=null",
            "capacity": "!=null",
            "geom": "!=null",
            "geom[0]": ">=0",
            "geom[1]": ">=0",
            "geom[2]": ">=0"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_partsize": {
        "description": "Parse cylinder head sectors from PC partition table",
        "pre": {
            "bdev": "!=null",
            "capacity": "!=null",
            "geom": "!=null",
            "geom[0]": ">=0",
            "geom[1]": ">=0",
            "geom[2]": ">=0"
        }
    }
},
{
    "kretprobe:logical_end": {
        "description": "Calculate the logical end value",
        "pre": {
            "logical_end": "!=null"
        }
    },
    "kretprobe:largest": {
        "description": "Pointer to the largest structure",
        "pre": {
            "largest": "!=null"
        }
    },
    "kretprobe:largest->start_sect": {
        "description": "Start sector value in the largest structure",
        "pre": {
            "largest->start_sect": "!=null"
        }
    },
    "kretprobe:largest->nr_sects": {
        "description": "Number of sectors value in the largest structure",
        "pre": {
            "largest->nr_sects": "!=null"
        }
    },
    "kretprobe:cyl": {
        "description": "Calculate the cyl value",
        "pre": {
            "cyl": "!=null"
        }
    },
    "kretprobe:largest_cyl": {
        "description": "Update largest_cyl if cyl > largest_cyl",
        "pre": {
            "largest_cyl": "!=null"
        }
    },
    "kretprobe:end_cyl": {
        "description": "Calculate the end_cyl value",
        "pre": {
            "end_cyl": "!=null"
        }
    },
    "kretprobe:end_head": {
        "description": "Assign the end_head value",
        "pre": {
            "end_head": "!=null"
        }
    },
    "kretprobe:end_sector": {
        "description": "Assign the end_sector value",
        "pre": {
            "end_sector": "!=null"
        }
    },
    "kretprobe:physical_end": {
        "description": "Calculate the physical_end value",
        "pre": {
            "physical_end": "!=null"
        }
    }
},
{
    "kprobe:logical_end": {
        "description": "Calculate the logical end value using the get_unaligned_le32 helper function.",
        "pre": {
            "largest": "!=null",
            "largest->start_sect": "!=null",
            "largest->nr_sects": "!=null"
        }
    }
},
{
    "kretprobe:device_remove_file": {
        "description": "Handles concurrent removal calls by serializing them and ignoring the second and later removal attempts.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null"
        }
    },
    "kretprobe:scsi_remove_device": {
        "description": "Serializes concurrent calls and ignores the second and later calls.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kretprobe:sysfs_unbreak_active_protection": {
        "description": "Unbreaks active protection if `kn` is not null.",
        "pre": {
            "kn": "!=null"
        }
    },
    "kretprobe:scsi_device_put": {
        "description": "Decrements the reference count of `sdev`.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kretprobe:store_state_field": {
        "description": "Stores the state field of a device.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:device_remove_file": {
        "description": "Remove a file associated with a device.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null"
        }
    },
    "kprobe:scsi_remove_device": {
        "description": "Remove a SCSI device.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kprobe:sysfs_unbreak_active_protection": {
        "description": "Unbreak active protection in sysfs.",
        "pre": {
            "kn": "!=null"
        }
    },
    "kprobe:scsi_device_put": {
        "description": "Put a reference to a SCSI device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_remove_target": {
        "description": "Try to remove a target and all its devices.",
        "pre": {
            "starget": "!=null",
            "shost": "!=null",
            "flags": "unsigned long",
            "sdev": "struct scsi_device",
            "sdev.channel": "!=starget.channel",
            "sdev.id": "!=starget.id",
            "sdev.sdev_state": "in [SDEV_DEL, SDEV_CANCEL]",
            "!get_device(&sdev.sdev_gendev)": "true",
            "shost.host_lock": "spin_lock_irqsave",
            "scsi_remove_device(sdev)": "true",
            "put_device(&sdev.sdev_gendev)": "true",
            "goto restart": "true",
            "spin_unlock_irqrestore(shost.host_lock, flags)": "true",
            "spin_unlock_irqrestore(shost.host_lock, flags)": "true"
        }
    }
},
{
    "kprobe:scsi_remove_target": {
        "description": "Try to remove a target and all its devices.",
        "pre": {
            "starget": "!=null",
            "shost": "!=null",
            "sdev": "!=null",
            "sdev->channel": "!=starget->channel",
            "sdev->id": "!=starget->id",
            "sdev->sdev_state": "in [SDEV_DEL, SDEV_CANCEL]",
            "!get_device(&sdev->sdev_gendev)": "true",
            "shost->host_lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphical chars from an INQUIRY result string",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphical chars from an INQUIRY result string",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_target_reap": {
        "description": "Reap the SCSI target and return the SCSI device.",
        "pre": {
            "starget": "!=null"
        },
        "post": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_target_reap": {
        "description": "Reap the SCSI target and put the device.",
        "pre": {
            "starget": "!=null"
        }
    },
    "kprobe:put_device": {
        "description": "Put the device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:__scsi_add_device": {
        "description": "Add a SCSI device.",
        "pre": {
            "shost": "!=null",
            "channel": "uint",
            "id": "uint",
            "lun": "u64",
            "hostdata": "!=null"
        }
    }
},
{
    "kretprobe:scsi_add_device": {
        "description": "Add a SCSI device to the SCSI host.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "hostdata": "!=null"
        }
    }
},
{
    "kprobe:scsi_add_device": {
        "description": "Add a SCSI device to the SCSI host.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "hostdata": "!=null",
            "scsi_scan_type": "!=none",
            "starget": "!=null",
            "sdev": "!=null",
            "parent": "!=null",
            "shost->shost_gendev": "!=null",
            "scsi_host_scan_allowed(shost)": "==true",
            "scsi_autopm_get_host(shost)": "==0"
        }
    }
},
{
    "kretprobe:return;starget = scsi_alloc_target(parent, channel, id);if (!starget)return;scsi_autopm_get_target(starget);if (lun != SCAN_WILD_CARD)": {
        "description": "Scan a SCSI target",
        "pre": {
            "parent": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "rescan": "in [SCSI_SCAN_NORMAL, SCSI_SCAN_ASYNC]"
        }
    }
},
{
    "kprobe:return;starget = scsi_alloc_target(parent, channel, id);if (!starget)return;scsi_autopm_get_target(starget);if (lun != SCAN_WILD_CARD)": {
        "description": "Scan a SCSI target",
        "pre": {
            "parent": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "rescan": "in [SCSI_SCAN_NORMAL, SCSI_SCAN_ASYNC]"
        }
    }
},
{
    "kretprobe:scsi_scan_host_selected": {
        "description": "Scan and select a SCSI host.",
        "pre": {
            "sdev->sdev_state": "== SDEV_DEL",
            "channel": "!= SCAN_WILD_CARD",
            "channel": "> shost->max_channel",
            "id": "!= SCAN_WILD_CARD",
            "id": ">= shost->max_id",
            "lun": "!= SCAN_WILD_CARD",
            "lun": ">= shost->max_lun",
            "shost->async_scan": "== false",
            "scsi_host_scan_allowed(shost)": "== true",
            "scsi_autopm_get_host(shost)": "== 0",
            "channel": "== SCAN_WILD_CARD",
            "channel": "in [0, shost->max_channel]",
            "id": "!= null",
            "lun": "!= null",
            "rescan": "!= null",
            "scsi_autopm_put_host(shost)": "exists",
            "return": "== 0"
        }
    }
},
{
    "kprobe:scsi_sysfs_add_devices": {
        "description": "Add devices to sysfs for a SCSI host.",
        "pre": {
            "sdev->sdev_state": "== SDEV_DEL"
        }
    }
},


{
    "kretprobe:static inline intNCR_700_data_residual (struct Scsi_Host *host)": {
        "description": "Return residual data count of what's in the chip.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:static inline intNCR_700_data_residual (struct Scsi_Host *host)": {
        "description": "Return residual data count of what's in the chip.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Lock the host and check if istat has SCSI_INT_PENDING or DMA_INT_PENDING set.",
        "pre": {
            "host": "!=null",
            "host->host_lock": "!=null",
            "flags": "!=null",
            "istat": "!=null",
            "istat & (SCSI_INT_PENDING | DMA_INT_PENDING)": "!=0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spin lock and disable interrupts.",
        "pre": {
            "host->host_lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:NCR_700_readb": {
        "description": "Read a byte from the NCR 700 device.",
        "pre": {
            "host": "!=null",
            "ISTAT_REG": "!=null"
        }
    },
    "kprobe:bitwise_and": {
        "description": "Perform a bitwise AND operation.",
        "pre": {
            "istat": "!=null",
            "SCSI_INT_PENDING | DMA_INT_PENDING": "!=null"
        }
    }
},
{
    "kretprobe:fas216_init_chip": {
        "description": "Initialise FAS216 state after reset",
        "pre": {
            "info": "!=null"
        }
    }
},

{
    "kretprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process",
        "pre": {
            "SCpnt": "!=null",
            "done": "!=null"
        }
    }
},
{
    "fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_internal_done": {
        "description": "Trigger restart of a waiting thread in fas216_command",
        "pre": {
            "SCpnt": "!=null",
            "SCpnt": "is_valid_scsi_cmnd",
            "fas216_command": "is_waiting_for_thread_restart"
        }
    }
},
{
    "kprobe:fas216_internal_done": {
        "description": "Description of the function",
        "pre": {
            "SCpnt": "Condition for SCpnt"
        }
    }
},
{
    "kretprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "pre": {
            "info": "!=null"
        },
        "post": {
            "return_value": "in [IRQ_NONE, IRQ_HANDLED, IRQ_WAKE_THREAD]"
        }
    }
},
{
    "kprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fas216_release": {
        "description": "Release all resources for FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:fas216_release": {
        "description": "Release all resources for FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_abort": {
        "description": "Abort this command.",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [FAILED, SUCCESS]"
        }
    }
},
{
    "kprobe:fas216_eh_abort": {
        "description": "Abort this command.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [FAILED, SUCCESS]"
        },
        "notes": "Further commands are blocked."
    }
},
{
    "kretprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "==FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_initialise": {
        "description": "Initialize a message queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},

{
    "kretprobe:msgqueue_free": {
        "description": "Free a queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_free": {
        "description": "Free a queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_getmsg": {
        "description": "Return a message from the specified queue.",
        "pre": {
            "msgq": "!=null",
            "msgno": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_getmsg": {
        "description": "Return a message from the queue.",
        "pre": {
            "msgq": "!=null",
            "msgno": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "pre": {
            "msgq": "!=null",
            "length": "!=null",
            "...": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "pre": {
            "msgq": "!=null",
            "length": ">=0",
            "...": "valid message bytes"
        }
    }
},
{
    "kretprobe:msgqueue_flush": {
        "description": "Flush all messages from the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_flush": {
        "description": "Flush all messages from message queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:queue_initialise": {
        "description": "Initializes a queue.",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_initialise": {
        "description": "Initialise a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:queue_free": {
        "description": "Free a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_free": {
        "description": "Free a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "int"
        },
        "post": {
            "return": "int"
        }
    }
},


{
    "kretprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null",
            "tag": "!=null"
        },
        "post": {
            "return": "struct scsi_cmnd",
            "constraints": "!=null"
        }
    }
},
{
    "kprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag",
        "pre": {
            "queue": "!=null",
            "target": "any",
            "lun": "any",
            "tag": "any"
        }
    }
},
{
    "kretprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target.",
        "pre": {
            "queue": "!=null",
            "target": "!=null"
        }
    }
},
{
    "kprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target.",
        "pre": {
            "queue": "!=null",
            "target": "!=null"
        }
    }
},
{
    "kretprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null"
        },
        "post": {
            "return_value": "in [0, !=0]"
        }
    }
},
{
    "kprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance",
        "pre": {
            "fip": "!=null",
            "mode": "in [FIP_MODE_INIT, FIP_MODE_AUTO]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance",
        "pre": {
            "fip": "!=null",
            "mode": "in [FIP_MODE_1, FIP_MODE_2, FIP_MODE_3]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller",
        "pre": {
            "fip": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller",
        "pre": {
            "fip": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate.",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null",
            "return_value": "==0",
            "skb_length": "% 4 == 0",
            "skb_headroom": ">= 28",
            "skb_tailroom": ">= 8",
            "skb_type": "==fc_frame"
        }
    }
},
{
    "kprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate.",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null",
            "skb_length": "% 4 == 0",
            "skb_headroom": ">= 28",
            "skb_tailroom": ">= 8",
            "skb_type": "fc_frame"
        },
        "post": {
            "return_value": "== 0"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "pre": {
            "fip": "!=null",
            "state": "in [DISABLED, LINK_WAIT, AUTO, NON_FIP, ENABLED, VNMP_START, VNMP_PROBE1, VNMP_PROBE2, VNMP_CLAIM, VNMP_UP]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "pre": {
            "fip": "!=null",
            "state": "in [DISABLED, LINK_WAIT, AUTO, NON_FIP, ENABLED, VNMP_START, VNMP_PROBE1, VNMP_PROBE2, VNMP_CLAIM, VNMP_UP]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "fp": "!=null",
            "fip->flogi_oxid": "!=FC_XID_UNKNOWN"
        },
        "post": {
            "return_value": "!=0"
        }
    }
},
{
    "kprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "fp": "!=null",
            "fip->flogi_oxid": "!=FC_XID_UNKNOWN"
        }
    }
},
{
    "kretprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:fc_frame_crc_check": {
        "description": "Check the CRC of the fc_frame",
        "pre": {
            "fp": "!=null",
            "bp": "!=null",
            "crc": "!=null",
            "error": "!=null",
            "len": ">=0",
            "fr_flags(fp)": "&= ~FCPHF_CRC_UNCHECKED",
            "len": "== (fr_len(fp) + 3) & ~3"
        },
        "post": {
            "error": "== (crc ^ fr_crc(fp))"
        }
    }
},
{
    "kprobe:fc_frame_crc_check": {
        "description": "Calculate the CRC and check for errors in the fc_frame structure.",
        "pre": {
            "fp": "!=null",
            "bp": "!=null",
            "crc": "!=null",
            "error": "!=null",
            "len": ">=0",
            "fr_flags(fp)": "&= ~FCPHF_CRC_UNCHECKED",
            "len": "==((fr_len(fp) + 3) & ~3)"
        }
    }
},

{
    "kprobe:fc_frame_alloc_fill": {
        "description": "Allocate and fill an FC frame.",
        "pre": {
            "lp": "!=null",
            "payload_len": ">=0"
        }
    }
},
{
    "kretprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_create": {
        "description": "Create a new remote port",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_create": {
        "description": "Create a new remote port",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_destroy": {
        "description": "Free a remote port after the last reference is released",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_destroy": {
        "description": "Free a remote port after the last reference is released",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout",
        "pre": {
            "rport": "!=null",
            "timeout": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout",
        "pre": {
            "rport": "!=null",
            "timeout": "!=null",
            "timeout": "is_integer",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:fc_rport_login": {
        "description": "Start the remote port login state machine",
        "pre": {
            "rdata": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_login": {
        "description": "Start the remote port login state machine",
        "pre": {
            "rdata": "!=null"
        }
    }
},


{
    "kretprobe:fc_rport_recv_req": {
        "description": "Handler for requests",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_recv_req": {
        "description": "Handler for requests",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "pre": {
            "rport_event_queue": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "pre": {
            "rport_event_queue": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port",
        "pre": {
            "rport": "!=null"
        }
    }
},

{
    "kprobe:fc_disc_config": {
        "description": "Configure the discovery layer for a local port",
        "pre": {
            "lport": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0"
        }
    }
},
{
    "kprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0"
        }
    }
},
{
    "kretprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID",
        "pre": {
            "n_port": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID",
        "pre": {
            "n_port": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null",
            "lp_mutex": "held"
        }
    }
},
{
    "kprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null",
            "lp_mutex": "held"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "pre": {
            "fc_cpu_mask": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "pre": {
            "fc_cpu_mask": "!=null"
        }
    }
},
{
    "kretprobe:fc_seq_send_locked": {
        "description": "Send the frame.",
        "pre": {
            "fr_max_payload(fp)": true,
            "sp->cnt": ">= 0",
            "fr_len(fp)": ">= sizeof(*fh)",
            "fh": "!= null"
        }
    }
},
{
    "kprobe:fc_seq_send_locked": {
        "description": "Send the frame.",
        "pre": {
            "fp": "!=null",
            "sp": "!=null",
            "fr_max_payload(fp)": "!=0",
            "fr_len(fp)": ">sizeof(*fh)"
        }
    }
},
{
    "kretprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence.",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence.",
        "pre": {
            "sp": "!=null"
        }
    }
},


{
    "kretprobe:fc_seq_assign": {
        "description": "Assigns a sequence to a Fibre Channel frame.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_seq_assign": {
        "description": "Assign a sequence to a frame in the Fibre Channel protocol.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        }
    }
},
{
    "kprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        }
    }
},
{
    "kretprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "!=null",
            "timer_msec": ">=0"
        }
    }
},
{
    "kprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence",
        "pre": {
            "lport": "!=null",
            "fp": "!=null",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "!=null",
            "timer_msec": ">=0"
        }
    }
},
{
    "kretprobe:fc_exch_update_stats": {
        "description": "Update exchange manager stats for the local port.",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_update_stats": {
        "description": "Update exches stats to lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_2, FC_CLASS_3]",
            "min_xid": ">=0",
            "max_xid": ">=0",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_1, FC_CLASS_2, FC_CLASS_3, FC_CLASS_4]",
            "min_xid": ">=0",
            "max_xid": ">=min_xid",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fill_hdr": {
        "description": "Fill FC header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "any",
            "f_ctl": "any",
            "seq_cnt": "any",
            "parm_offset": "any"
        }
    }
},
{
    "kprobe:fc_fill_hdr": {
        "description": "Fill FC header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "!=null",
            "f_ctl": "!=null",
            "seq_cnt": "!=null",
            "parm_offset": "!=null"
        }
    }
},
{
    "kretprobe:fc_fill_reply_hdr": {
        "description": "Fill FC reply header fields based on request.",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "is an enum value",
            "parm_offset": "is an integer value"
        }
    }
},
{
    "kprobe:fc_fill_reply_hdr": {
        "description": "Fill FC reply header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "is an enum value",
            "parm_offset": "is an unsigned integer"
        }
    }
},
{
    "kretprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        },
        "post": {
            "return": "in [0, negative error]"
        }
    }
},
{
    "kprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_port_state": {
        "description": "Return the port state of the given Scsi_Host",
        "pre": {
            "shost": "!=null"
        }
    }
},

{
    "kretprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics",
        "pre": {
            "shost": "!=null",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_login": {
        "description": "Start the lport state machine",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fabric_login": {
        "description": "Start the lport state machine",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkup": {
        "description": "Handler for transport linkup events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkup": {
        "description": "Handler for transport linkup events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric",
        "pre": {
            "lport": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "pre": {
            "lport": "!=null",
            "mfs": "!=null"
        }
    }
},
{
    "kprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "pre": {
            "lport": "!=null",
            "mfs": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint.",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint.",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_reset": {
        "description": "Reset a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_reset": {
        "description": "Reset a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_config": {
        "description": "Configure a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_config": {
        "description": "Configure a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kretprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_abort": {
        "description": "Abort a command",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_abort": {
        "description": "Abort a command",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host.",
        "pre": {
            "sc_cmd": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host.",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host",
        "pre": {
            "sdev": "!=null",
            "sdev->host": "!=null",
            "sdev->host->cmd_per_len": ">=0"
        }
    }
},
{
    "kprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host",
        "pre": {
            "sdev": "!=null",
            "sdev->host": "!=null",
            "sdev->host->cmd_per_len": ">=0"
        }
    }
},
{
    "kretprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame",
        "pre": {
            "lport": "!=null",
            "did": "!=null",
            "fp": "!=null",
            "op": "!=null",
            "resp": "!=null",
            "arg": "!=null",
            "timer_msec": "!=null"
        }
    }
},
{
    "kprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame",
        "pre": {
            "lport": "!=null",
            "did": "!=null",
            "fp": "!=null",
            "op": "!=null",
            "resp": "!=null",
            "arg": "!=null",
            "timer_msec": "!=null"
        }
    }
},
{
    "kretprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer",
        "pre": {
            "lport": "!=null"
        }
    }
},


{
    "kretprobe:i = phys_suspended(ha);if (i)dev_info(ha->dev, \"waiting up to 25 seconds for %d phy%s to resume\\n\", i, i > 1 ? \"s\" : \"\");wait_event_timeout(ha->eh_wait_q, phys_suspended(ha) == 0, tmo);for (i = 0; i < ha->num_phys; i++)": {
        "description": "Resume the SAS host adapter and wait for all phys to resume",
        "pre": {
            "ha": "!=null",
            "tmo": ">=0",
            "i": ">=0",
            "ha->dev": "!=null",
            "ha->num_phys": ">=0"
        }
    }
},
{
    "kprobe:i = phys_suspended(ha);if (i)dev_info(ha->dev, \"waiting up to 25 seconds for %d phy%s to resume\\n\", i, i > 1 ? \"s\" : \"\");wait_event_timeout(ha->eh_wait_q, phys_suspended(ha) == 0, tmo);for (i = 0; i < ha->num_phys; i++)": {
        "description": "Resume SAS host adapter and wait for all phys to resume",
        "pre": {
            "ha": "!=null",
            "tmo": ">=0",
            "i": ">=0",
            "i > 1 ? \"s\" : \"\"": "is a valid string",
            "phys_suspended(ha)": "==0"
        }
    }
},
{
    "kretprobe:sas_suspend_ha": {
        "description": "Suspend the SAS host adapter and flush suspend events while unregistered.",
        "pre": {
            "ha": "!=null",
            "ha->drain_mutex": "!=null",
            "ha->sas_port": "!=null",
            "ha->num_phys": ">=0",
            "port": "!=null",
            "port->discover_event": "in [DISCE_SUSPEND]",
            "ha->core.shost": "!=null",
            "ha->core.shost->host_blocked": "==true"
        }
    }
},
{
    "kprobe:sas_suspend_ha": {
        "description": "Suspend the SAS host adapter and flush suspend events while unregistered.",
        "pre": {
            "ha": "!=null",
            "ha->drain_mutex": "!=null"
        }
    }
},



{
    "kprobe:mutex_lock": {
        "description": "Locks the specified mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:tgt->tgt_stop": {
        "description": "Sets tgt_stop flag to 1.",
        "pre": {
            "tgt": "!=null"
        }
    },
    "kprobe:qlt_clear_tgt_db": {
        "description": "Clears the target database for qlt.",
        "pre": {
            "tgt": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlocks the specified mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlocks the qla_tgt_mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:ql_dbg": {
        "description": "Debugs the target management.",
        "pre": {
            "vha": "!=null",
            "tgt": "!=null"
        }
    },
    "kprobe:spin_lock_irqsave": {
        "description": "Locks the specified spin lock and saves the IRQ state.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:do": {
        "description": "Performs the specified action.",
        "pre": {
            "action": "!=null"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "The ql_dbg function",
        "pre": {
            "vha": "!=null",
            "vha->flags.online": "!=null",
            "qla2x00_reset_active(vha)": "!=null",
            "mcmd->reset_count": "!=null",
            "qpair->chip_reset": "!=null",
            "mcmd->flags": "== QLA24XX_MGMT_SEND_NACK"
        },
        "post": {
            "mcmd->sess": "!=null",
            "mcmd->sess->vha": "!=null",
            "mcmd->sess->vha->hw": "!=null",
            "mcmd->qpair": "!=null",
            "mcmd->qpair->qp_lock_ptr": "!=null"
        }
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Debug function ql_dbg",
        "pre": {
            "vha": "!=null",
            "mcmd": "!=null",
            "mcmd->sess": "!=null",
            "mcmd->sess->vha": "!=null",
            "mcmd->sess->vha->hw": "!=null",
            "mcmd->qpair": "!=null",
            "mcmd->qpair->qp_lock_ptr": "!=null",
            "mcmd->flags": "== QLA24XX_MGMT_SEND_NACK",
            "vha->flags.online": "== true",
            "mcmd->reset_count": "== mcmd->qpair->chip_reset"
        }
    }
},

{
    "kprobe:qlt_xmit_response": {
        "description": "Transmit response for qla_tgt_cmd",
        "pre": {
            "cmd->state": "QLA_TGT_STATE_PROCESSED",
            "ql_dbg_qp": {
                "arg1": "ql_dbg_async",
                "arg2": "qpair",
                "arg3": "0xe101",
                "arg4": {
                    "format": "RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
                    "args": [
                        "vha->flags.online",
                        "qla2x00_reset_active(vha)",
                        "cmd->reset_count",
                        "qpair->chip_reset"
                    ]
                }
            },
            "res": "0"
        },
        "post": {
            "goto": "out_unmap_unlock"
        }
    }
},
{
    "kretprobe:qlt_rdy_to_xfer": {
        "description": "Calculate number of entries and segments required",
        "pre": {
            "cmd->aborted": "== 1",
            "cmd->write_data_transferred": "== 0",
            "cmd->state": "== QLA_TGT_STATE_DATA_IN",
            "vha->hw->tgt.tgt_ops->handle_data(cmd)": "No specific constraint mentioned",
            "ql_dbg_qp(ql_dbg_async, qpair, 0xe102,\"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\\n\",vha->flags.online, qla2x00_reset_active(vha),cmd->reset_count, qpair->chip_reset)": "No specific constraint mentioned"
        },
        "post": {
            "return value": "== 0"
        }
    }
},
{
    "kprobe:qlt_rdy_to_xfer": {
        "description": "Calculate number of entries and segments required",
        "pre": {
            "cmd->aborted": "1",
            "cmd->write_data_transferred": "0",
            "cmd->state": "QLA_TGT_STATE_DATA_IN",
            "vha->hw->tgt.tgt_ops->handle_data(cmd)": "called"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "Debug function for qla_target",
        "pre": {
            "cmd": "!=null",
            "vha": "!=null",
            "cmd->tgt": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd->tag": ">=0",
            "cmd->aborted": "==1",
            "cmd->sg_mapped": "==0"
        }
    }
},
{
    "kprobe:qlt_abort_cmd": {
        "description": "Terminating exchange for aborted cmd",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "cmd->tgt->vha": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd.tag": "!=null",
            "cmd->aborted": "1",
            "cmd->trc_flags": "&= TRC_ABORT",
            "cmd->cmd_lock": "unlocked",
            "cmd->qpair": "!=null",
            "cmd->atio": "!=null",
            "cmd->atio": "!=0",
            "cmd->atio": "!=1"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "Debug function for qla_target.",
        "pre": {
            "vha": "!=null",
            "cmd": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd.transport_state": "!=null",
            "cmd->se_cmd.t_state": "!=null",
            "cmd->se_cmd.se_cmd_flags": "!=null"
        },
        "post": {
            "cmd->aborted": "1",
            "cmd->trc_flags": "|= TRC_ABORT"
        }
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Debug function for qla_target",
        "pre": {
            "ql_dbg_tgt_mgt": "!=null",
            "vha": "!=null",
            "cmd": "!=null",
            "cmd->se_cmd.transport_state": "!=null",
            "cmd->se_cmd.t_state": "!=null",
            "cmd->se_cmd.se_cmd_flags": "!=null"
        }
    },
    "kprobe:qlt_send_term_exchange": {
        "description": "Send termination exchange for qla_target",
        "pre": {
            "cmd->qpair": "!=null",
            "cmd": "!=null",
            "&cmd->atio": "!=null",
            "0": "!=null",
            "1": "!=null"
        }
    },
    "kprobe:qlt_abort_cmd": {
        "description": "Abort command for qla_target",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "tgt->vha": "!=null",
            "&cmd->se_cmd": "!=null",
            "se_cmd->tag": "!=null"
        }
    },
    "kprobe:qlt_free_cmd": {
        "description": "Free command for qla_target",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:qlt_lport_register": {
        "description": "Register lport with external module",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": "!=null",
            "npiv_wwpn": "!=null",
            "npiv_wwnn": "!=null",
            "callback": "!=null"
        }
    }
},
{
    "kprobe:qlt_lport_register": {
        "description": "Register lport with external module.",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": "!=null",
            "npiv_wwpn": "!=null",
            "npiv_wwnn": "!=null",
            "callback": "!=null"
        }
    }
},

{
    "kprobe:qlt_lport_deregister": {
        "description": "Deregister lport",
        "pre": {
            "vha": "!=null"
        },
        "post": {
            "lport_deregistered": "true"
        }
    }
},
{
    "kretprobe:SDMMC_GET_HDATA_WIDTH": {
        "description": "Get the host data width - this assumes that HCON has been set with the correct values.",
        "pre": {
            "mci_readl(host, HCON)": "!=null",
            "i": "!=0"
        }
    }
},




{
    "kprobe:mci_writel": {
        "description": "Write the value of host->fifoth_val to the FIFOTH register and invalidate host->prev_blksz with zero.",
        "pre": {
            "host": {
                "type": "struct dw_mci",
                "slot": {
                    "mmc": {
                        "gpio_cd": "exists",
                        "removable": false
                    }
                },
                "biu_clk": "prepared and enabled",
                "ciu_clk": "prepared and enabled",
                "ctrl_reset": false,
                "use_dma": true,
                "dma_ops": {
                    "init": "defined"
                }
            },
            "FIFOTH": "host->fifoth_val",
            "host->prev_blksz": 0
        }
    }
},
{
    "kretprobe:cqhci_resume": {
        "description": "Re-enable is done upon first request",
        "pre": {
            "mmc": "!=null",
            "request_count": ">0",
            "return_value": "==0"
        }
    }
},





{
    "kretprobe:mmc_request_done": {
        "description": "Finish processing an MMC request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_request_done": {
        "description": "Finish processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},


{
    "kretprobe:__mmc_start_request": {
        "description": "Starts an MMC request and waits for it to be done.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->done": "!=null",
            "mmc_wait_for_req_done()": "called"
        }
    }
},
{
    "kprobe:__mmc_start_request": {
        "description": "Starts an MMC request",
        "pre": {
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors.",
        "pre": {
            "host": "!=null"
        },
        "post": {
            "return": "int"
        },
        "side_effects": [
            "Stop CQE",
            "Stop eMMC",
            "Discard queue in eMMC",
            "Discard queue in CQE",
            "Call mmc_cqe_request_done() on all requests"
        ],
        "error_handling": {
            "eMMC_queue_discard": "Return error if eMMC fails to discard its queue"
        }
    }
},
{
    "kretprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->cap_cmd_during_tfr": "==true"
        }
    }
},
{
    "kprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->cap_cmd_during_tfr": "==true"
        }
    }
},
{
    "kretprobe:cmd.flags": {
        "description": "Wait for command completion and discard the entire queue.",
        "pre": {
            "host": "!=null",
            "cmd": "!=null",
            "cmd.flags": "in [MMC_RSP_R1B | MMC_CMD_AC]",
            "cmd.flags": "&= ~MMC_RSP_CRC"
        }
    }
},
{
    "kprobe:mmc_wait_for_cmd": {
        "description": "Wait for a command to complete on the MMC host.",
        "pre": {
            "host": "!=null",
            "cmd": {
                "opcode": "MMC_CMDQ_TASK_MGMT",
                "arg": 1
            }
        }
    }
},
{
    "kretprobe:mmc_set_data_timeout": {
        "description": "set the timeout for a data command",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        }
    }
},
{
    "kprobe:mmc_set_data_timeout": {
        "description": "Set the timeout for a data command.",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        },
        "post": {
            "data_timeout_parameters": "computed correctly according to the algorithm given the card type"
        }
    }
},
{
    "kretprobe:__mmc_claim_host": {
        "description": "Exclusively claim a host",
        "pre": {
            "host": "!=null",
            "ctx": "!=null",
            "abort": "!=null",
            "*abort": "==0"
        }
    }
},
{
    "kprobe:__mmc_claim_host": {
        "description": "Exclusively claim a host.",
        "pre": {
            "host": "!=null",
            "ctx": "!=null",
            "abort": "!=null",
            "*abort": "==0"
        }
    }
},
{
    "kretprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL))__pm_wakeup_event(host->w 5000);host->detect_change = 1;mmc_schedule_delayed_work(&host->detect, delay);}/** *mmc_detect_change - process change of state on a MMC socket *@host: host which changed state. *@delay: optional delay to wait before detection (jiffies) * *MMC drivers should call this when they detect a card has been *inserted or removed. The MMC layer will confirm that any *present card is still functional, and initialize any newly *inserted. ": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "pre": {
            "cd_irq": "==true",
            "host->caps & MMC_CAP_NEEDS_POLL": "==0",
            "__pm_wakeup_event(host->w 5000)": "called",
            "host->detect_change": "==1",
            "mmc_schedule_delayed_work(&host->detect, delay)": "called"
        }
    }
},
{
    "kprobe:if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL))__pm_wakeup_event(host->w 5000);host->detect_change = 1;mmc_schedule_delayed_work(&host->detect, delay);}/** *mmc_detect_change - process change of state on a MMC socket *@host: host which changed state. *@delay: optional delay to wait before detection (jiffies) * *MMC drivers should call this when they detect a card has been *inserted or removed. The MMC layer will confirm that any *present card is still functional, and initialize any newly *inserted. ": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "pre": {
            "cd_irq": true,
            "host->caps & MMC_CAP_NEEDS_POLL": false
        }
    }
},
{
    "kretprobe:if (arg == MMC_TRIM_ARG)erase_timeout = card->ext_csd.trim_timeout;elseerase_timeout = card->ext_csd.hc_erase_timeout;} else": {
        "description": "Calculate the erase timeout based on the arguments and card properties.",
        "pre": {
            "card": "!=null",
            "arg": "!=null",
            "qty": "!=null",
            "card->ext_csd.rev": ">= 6",
            "card->ext_csd.erase_group_def & 1": "== 1"
        }
    }
},
{
    "kprobe:if (arg == MMC_TRIM_ARG)erase_timeout = card->ext_csd.trim_timeout;elseerase_timeout = card->ext_csd.hc_erase_timeout;} else": {
        "description": "Helper function for MMC erase timeout calculation.",
        "pre": {
            "card": "!=null",
            "arg": "!=null",
            "qty": "!=null",
            "card->ext_csd.rev": ">=6",
            "card->ext_csd.erase_group_def & 1": "==1"
        }
    }
},

{
    "kprobe:mmc_can_discard": {
        "description": "Check if the MMC card supports discard feature.",
        "pre": {
            "card": "!=null",
            "card->ext_csd.feature_support": "& MMC_DISCARD_FEATURE"
        }
    }
},
{
    "kretprobe:if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))return card->pref_erase;max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);if (mmc_can_trim(card))": {
        "description": "Calculate the maximum discard value for the MMC card.",
        "pre": {
            "card": "!=null",
            "mmc_card_mmc(card)": "true",
            "!(card->ext_csd.erase_group_def & 1)": "true",
            "card->pref_erase": "!=null",
            "mmc_do_calc_max_discard(card, MMC_ERASE_ARG)": "!=null",
            "mmc_can_trim(card)": "true"
        }
    }
},
{
    "kprobe:if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))return card->pref_erase;max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);if (mmc_can_trim(card))": {
        "description": "Calculate the maximum discard value for the MMC card.",
        "pre": {
            "card": "!=null",
            "mmc_card_mmc(card)": "true",
            "!(card->ext_csd.erase_group_def & 1)": "true",
            "card->pref_erase": "!=null",
            "max_discard": "not in [null, 0]",
            "mmc_do_calc_max_discard(card, MMC_ERASE_ARG)": "not in [null, 0]",
            "mmc_can_trim(card)": "true"
        }
    }
},
{
    "kretprobe:mmc_hw_reset": {
        "description": "Reset the card in hardware",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:mmc_hw_reset": {
        "description": "Reset the card in hardware",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:if (!ret && host->ops->get_cd && !host->ops->get_cd(host))": {
        "description": "Check if the card is removed and the card detect status and alive check are in sync.",
        "pre": {
            "ret": "false",
            "host->ops->get_cd": "true",
            "!host->ops->get_cd(host)": "true"
        }
    }
},
{
    "kprobe:if (!ret && host->ops->get_cd && !host->ops->get_cd(host))": {
        "description": "Check if the card is removed and reschedule a detect work 200ms later if necessary.",
        "pre": {
            "ret": "false",
            "host->ops->get_cd": "true",
            "!host->ops->get_cd(host)": "true"
        }
    }
},


{
    "kretprobe:if (ctx->cd_irq >= 0)irq = ctx->cd_irq;else if (!(host->caps & MMC_CAP_NEEDS_POLL))irq = gpiod_to_irq(ctx->cd_gpio);if (irq >= 0)": {
        "description": "Condition for assigning value to 'irq' variable in the given function",
        "pre": {
            "ctx->cd_irq": ">= 0",
            "host->caps & MMC_CAP_NEEDS_POLL": "== 0",
            "gpiod_to_irq(ctx->cd_gpio)": ">= 0",
            "irq": ">= 0"
        }
    }
},
{
    "kprobe:if (ctx->cd_irq >= 0)irq = ctx->cd_irq;else if (!(host->caps & MMC_CAP_NEEDS_POLL))irq = gpiod_to_irq(ctx->cd_gpio);if (irq >= 0)": {
        "description": "Condition for assigning irq value based on ctx->cd_irq and host->caps",
        "pre": {
            "ctx->cd_irq": ">= 0",
            "host->caps & MMC_CAP_NEEDS_POLL": "== 0",
            "gpiod_to_irq(ctx->cd_gpio)": ">= 0",
            "irq": ">= 0"
        }
    }
},
{
    "kretprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection.",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "!=null",
            "debounce": ">=0"
        }
    }
},
{
    "kprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection.",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "!=null",
            "debounce": ">=0"
        }
    }
},
{
    "kretprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards",
        "pre": {
            "card": "!=null",
            "card->manual_bkops_enabled": "==true",
            "card->urgent_bkops_level": ">0"
        }
    }
},
{
    "kprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards",
        "pre": {
            "card": "!=null",
            "card->manual_bkops_enabled": "==true",
            "card->urgent_bkops_level": ">0"
        }
    }
},
{
    "kretprobe:mmc_register_driver": {
        "description": "Register a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_register_driver": {
        "description": "Register a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure.",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure.",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mmc_add_host": {
        "description": "Initialise host hardware.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_add_host": {
        "description": "initialise host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_remove_host": {
        "description": "Remove host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_remove_host": {
        "description": "Remove host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM",
        "pre": {
            "directory": "!=null",
            "key": "!=null",
            "buf": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM",
        "pre": {
            "directory": "!=null",
            "key": "!=null",
            "buf": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fw_device_enable_phys_dma": {
        "description": "Enable physical DMA for the given fw_device.",
        "pre": {
            "device": "!=null",
            "device->card": "!=null",
            "device->card->driver": "!=null",
            "device->card->driver->enable_phys_dma": "!=null",
            "device->node_id": ">= generation"
        }
    }
},
{
    "kprobe:fw_device_enable_phys_dma": {
        "description": "Enable physical DMA for the given fw_device.",
        "pre": {
            "device": "!=null",
            "device->card": "!=null",
            "device->card->driver": "!=null",
            "device->card->driver->enable_phys_dma": "!=null",
            "device->node_id": ">= generation"
        }
    }
},
{
    "kretprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued.",
        "pre": {
            "card": "!=null",
            "transaction": "!=null",
            "tstamp": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued.",
        "pre": {
            "card": "!=null",
            "transaction": "!=null"
        }
    }
},
{
    "kretprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep.",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "in [TCODE_...]",
            "destination_id": ">generation",
            "speed": "any",
            "offset": "any",
            "payload": "DMA-mapped when length > 8 or not local request",
            "length": "any",
            "callback": "!=null",
            "with_tstamp": "any",
            "callback_data": "any"
        }
    }
},
{
    "kprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep. In case of lock request specify one of the firewire-core specific %TCODE_ constants instead of %TCODE_LOCK_REQUEST in @tcode. Make sure that the value in @destination_id is not older than the one in @generation. Otherwise the request is in danger to be sent to a wrong node. In case of asynchronous stream packets i.e. %TCODE_STREAM_DATA, the caller needs to synthesize @destination_id with fw_stream_packet_destination_id(). It will contain tag, channel, and sy data instead of a node ID then. The payload buffer at @data is going to be DMA-mapped except in case of @length <= 8 or of local (loopback) requests. Hence make sure that the buffer complies with the restrictions of the streaming DMA mapping API. @payload must not be freed before the @callback is called. In case of request types without payload, @data is NULL and @length is 0. After the transaction is completed successfully or unsuccessfully, the @callback will be called. Among its parameters is the response code which is either one of the rcodes per IEEE 1394 or, in case of internal error the firewire-core specific %RCODE_SEND_ERROR. The other firewire-core specific rcodes (%RCODE_CANCELLED, %RCODE_BUSY, %RCODE_GENERATION, %RCODE_NO_ACK) denote transaction timeout, busy responder, stale request generation, or missing ACK respectively. Note some timing corner cases: fw_send_request() may complete much earlier than when the request packet actually hits the wire. On the other hand, transaction completion and hence execution of @callback may happen even before fw_send_request() returns.",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "int",
            "destination_id": "int",
            "generation": "int",
            "speed": "int",
            "offset": "unsigned long long",
            "payload": "void*",
            "length": "size_t",
            "callback": "union fw_transaction_callback",
            "with_tstamp": "bool",
            "callback_data": "void*"
        }
    }
},
{
    "kretprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "quadlet-aligned",
            "region->end": "quadlet-aligned",
            "handler->length": "quadlet-aligned"
        },
        "post": {
            "return value": "==0"
        }
    }
},
{
    "kprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "quadlet-aligned",
            "region->end": "quadlet-aligned",
            "handler->length": "quadlet-aligned"
        }
    }
},
{
    "kretprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler",
        "pre": {
            "handler": "!=null",
            "handler->callback": "!=null",
            "handler->callback()": "not running on any CPU"
        }
    }
},
{
    "kprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler",
        "pre": {
            "handler": "!=null",
            "handler->callback": "!=null",
            "handler->callback()": "not running on any CPU"
        }
    }
},
{
    "kretprobe:fw_send_response": {
        "description": "Send response packet for asynchronous transaction.",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "int"
        }
    }
},
{
    "kprobe:fw_send_response": {
        "description": "Send response packet for asynchronous transaction.",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "!=null"
        }
    }
},
{
    "kretprobe:fw_get_request_speed": {
        "description": "Returns the speed at which the request was received.",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kprobe:fw_get_request_speed": {
        "description": "returns speed at which the @request was received",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kretprobe:fw_core_handle_request": {
        "description": "Handle a request in the fw_core_handle_request function.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "p->ack": "in [ACK_PENDING, ACK_COMPLETE]",
            "HEADER_GET_TCODE(p->header[0])": "is_link_internal",
            "request": "==allocate_request(card, p)"
        }
    }
},
{
    "kprobe:fw_core_handle_request": {
        "description": "Handle a request in the fw_core module.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "p->ack": "in [ACK_PENDING, ACK_COMPLETE]",
            "HEADER_GET_TCODE(p->header[0])": "is_link_internal",
            "request": "==allocate_request(card, p)"
        }
    }
},
{
    "switch (tcode)": {
        "description": "Handle the response based on the value of tcode.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "t": "null",
            "flags": "any",
            "data": "any",
            "data_length": "any",
            "tcode": "any",
            "tlabel": "any",
            "source": "any",
            "rcode": "any"
        },
        "post": {
            "t": "null",
            "flags": "unchanged",
            "data": "unchanged",
            "data_length": "unchanged",
            "tcode": "unchanged",
            "tlabel": "unchanged",
            "source": "unchanged",
            "rcode": "unchanged"
        }
    }
},
{
    "switch (tcode)": {
        "description": "Handle the response based on the value of tcode.",
        "pre": {
            "p": {
                "header": {
                    "0": {
                        "!=null": true
                    }
                }
            },
            "tcode": "!=null",
            "tlabel": "!=null",
            "source": "!=null",
            "rcode": "!=null",
            "card": {
                "lock": "!=null",
                "transaction_list": {
                    "iter": {
                        "node_id": "!=null",
                        "tlabel": "!=null",
                        "try_cancel_split_timeout": "!=null"
                    }
                },
                "tlabel_mask": "!=null"
            },
            "t": "!=null"
        }
    }
},

{
    "kprobe:fw_rcode_string": {
        "description": "Convert a firewire result code to an error description.",
        "pre": {
            "rcode": "!=null",
            "rcode_type": "int",
            "rcode": "in [FIREWIRE_RESULT_CODE_1, FIREWIRE_RESULT_CODE_2, ...]"
        }
    }
},

{
    "kprobe:fw_core_add_descriptor": {
        "description": "Check if the descriptor is valid and the length of all blocks in the descriptor adds up to exactly the length of the block.",
        "pre": {
            "desc": "!=null",
            "i": "=0",
            "ret": "=0",
            "i < desc->length": "true",
            "i += (desc->data[i] >> 16) + 1": "true",
            "i != desc->length": "false",
            "mutex_lock(&card_mutex)": "true",
            "config_rom_length + required_space(desc) > 256": "true"
        }
    }
},
{
    "kretprobe:card->br_short = short_reset": {
        "description": "Set the value of card->br_short to short_reset.",
        "pre": {
            "card": "!=null",
            "short_reset": "!=null"
        }
    }
},
{
    "kprobe:fw_schedule_bus_reset": {
        "description": "Schedule a bus reset for the given firewire card.",
        "pre": {
            "card": "!=null",
            "delayed": "!=null",
            "short_reset": "!=null"
        }
    }
},
{
    "kretprobe:dummy_driver.free_iso_context": {
        "description": "Free the ISO context of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->free_iso_context": "!=null",
            "flags": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:dummy_driver.stop_iso": {
        "description": "Stop the ISO of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->stop_iso": "!=null",
            "flags": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:card->driver = &dummy_driver": {
        "description": "Assign the dummy driver to card->driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "dummy_driver": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:spin_lock_irqsave(&card->lock, flags)": {
        "description": "Acquire a spin lock with IRQ save.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:fw_destroy_nodes(card)": {
        "description": "Destroy the nodes in fw_destroy_nodes.",
        "pre": {
            "card": "!=null"
        }
    },
    "kretprobe:spin_unlock_irqrestore(&card->lock, flags)": {
        "description": "Release a spin lock with IRQ restore.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:dummy_driver.free_iso_context": {
        "description": "Free the ISO context of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->free_iso_context": "!=null",
            "card->driver->free_iso_context": "dummy_driver.free_iso_context"
        }
    },
    "kprobe:dummy_driver.stop_iso": {
        "description": "Stop the ISO of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->stop_iso": "!=null",
            "card->driver->stop_iso": "dummy_driver.stop_iso"
        }
    },
    "kprobe:card->driver = &dummy_driver": {
        "description": "Assign the dummy driver to the card's driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver": "&dummy_driver"
        }
    },
    "kprobe:spin_lock_irqsave(&card->lock, flags)": {
        "description": "Acquire a spin lock and save the IRQ flags.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:fw_destroy_nodes(card)": {
        "description": "Destroy the nodes associated with the card.",
        "pre": {
            "card": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore(&card->lock, flags)": {
        "description": "Release the spin lock and restore the IRQ flags.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:fw_iso_resource_manage": {
        "description": "Allocate or deallocate a channel and/or bandwidth.",
        "pre": {
            "card": "!=null",
            "generation": ">=0",
            "channels_mask": ">=0",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "in [true, false]"
        },
        "post": {
            "channel": "<0 or >=0",
            "bandwidth": "=0 or >0"
        }
    }
},
{
    "kprobe:fw_iso_resource_manage": {
        "description": "Allocate or deallocate a channel and/or bandwidth.",
        "pre": {
            "card": "!=null",
            "generation": ">=0",
            "channels_mask": ">=0",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "in [true, false]",
            "channel < 0": "bandwidth = 0",
            "generation is stale": "channel = -EAGAIN",
            "channel allocation fails": "bandwidth = 0",
            "bandwidth allocation fails": "channel < 0"
        }
    }
},
{
    "kretprobe:devfreq_get_freq_range": {
        "description": "Get the current frequency range",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_get_freq_range": {
        "description": "Get the current frequency range.",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior",
        "pre": {
            "devfreq": "!=null",
            "freq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior",
        "pre": {
            "devfreq": "!=null",
            "freq": "!=null"
        }
    }
},

{
    "kprobe:devfreq_update_target": {
        "description": "Update the target frequency for a devfreq device.",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        }
    }
},
{
    "kretprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_interval": {
        "description": "Update device devfreq monitoring interval",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},
{
    "kprobe:devfreq_update_interval": {
        "description": "Update device devfreq monitoring interval",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},


{
    "kretprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device.",
        "pre": {
            "devfreq": "==null"
        }
    }
},
{
    "kprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device.",
        "pre": {
            "devfreq": "==null"
        }
    }
},
{
    "kretprobe:devm_devfreq_add_device": {
        "description": "Resource-managed devfreq_add_device()",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_add_device": {
        "description": "Resource-managed devfreq_add_device()",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback.",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback.",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},

{
    "kprobe:rio_query_mport": {
        "description": "Query mport device attributes",
        "pre": {
            "port": "!=null",
            "mport_attr": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_update": {
        "description": "Update a register",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_update": {
        "description": "Update a register",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Send a simple command",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Send a simple command",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Command with data",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "size": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Command with data",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "size": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kretprobe:wmi_driver_unregister": {
        "description": "Unregister a WMI driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:wmi_driver_unregister": {
        "description": "Unregister a WMI driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:dcdbas_smi_request": {
        "description": "generate SMI request",
        "pre": {
            "smi_data_lock": "!=null"
        }
    }
},

{
    "kretprobe:intel_punit_ipc_simple_command": {
        "description": "Simple IPC command",
        "pre": {
            "cmd": "!=null",
            "para1": ">=0",
            "para1": "<=255",
            "para2": ">=0",
            "para2": "<=255"
        }
    }
},
{
    "kprobe:intel_punit_ipc_simple_command": {
        "description": "Simple IPC command",
        "pre": {
            "cmd": "!=null",
            "para1": ">=0",
            "para2": ">=0"
        }
    }
},
{
    "kretprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "ec_msg->result": "==EC_RES_IN_PROGRESS"
        },
        "post": {
            "return": "== -EAGAIN"
        }
    }
},
{
    "kprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "ec_msg->result": "==EC_RES_IN_PROGRESS"
        },
        "post": {
            "return": "== -EAGAIN"
        }
    }
},
{
    "kretprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_cmd_xfer": {
        "description": "Execute an EC command and handle communication with the EC device.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return_value": {
                ">": 0,
                "=": 0,
                "<": 0
            }
        }
    }
},
{
    "kprobe:cros_ec_cmd_xfer": {
        "description": "Execute an EC command and transfer data between the Linux host and the EC.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null",
            "has_more_events": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null",
            "has_more_events": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "in [IRQ_NONE, IRQ_HANDLED, IRQ_WAKE_THREAD]"
        }
    }
},
{
    "kprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "in [IRQ_HANDLED, IRQ_NONE]"
        }
    }
},
{
    "kretprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read/write bytes to MEC EMI port.",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": "!=null",
            "length": "!=null",
            "buf": "!=null"
        },
        "post": {
            "return_value": "is an 8-bit checksum of all bytes read/written"
        }
    }
},
{
    "kprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read/write bytes to MEC EMI port.",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": "!=null",
            "length": "!=null",
            "buf": "!=null"
        },
        "post": {
            "return": "is an 8-bit checksum of all bytes read/written"
        }
    }
},


{
    "kretprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "pre": {
            "tm": "!=null"
        }
    }
},
{
    "kprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "pre": {
            "tm": "!=null"
        }
    }
},


{
    "kretprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload.",
        "pre": {
            "hd": "!=null"
        }
    }
},
{
    "kprobe:voidmptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload.",
        "pre": {
            "hd": "!=null"
        }
    }
},


{
    "kretprobe:for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++)": {
        "description": "Loop over the physical disks",
        "pre": {
            "i": ">= 0",
            "i": "< ioc->raid_data.pIocPg3->NumPhysDisks"
        }
    }
},
{
    "kprobe:for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++)": {
        "description": "Loop over the physical disks in the RAID data",
        "pre": {
            "ioc": "!=null",
            "channel": "!=null",
            "id": "!=null"
        }
    }
},


{
    "kretprobe:mptscsih_info_scsiio": {
        "description": "Debug print info on reply frame",
        "pre": {
            "ioc": "!=null",
            "sc": "!=null",
            "pScsiReply": "!=null"
        }
    }
},
{
    "kprobe:mptscsih_info_scsiio": {
        "description": "Debug print info on reply frame",
        "pre": {
            "ioc": "!=null",
            "sc": "!=null",
            "pScsiReply": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},



{
    "kprobe:mptscsih_slave_configure": {
        "description": "Configure a SCSI device in the mptscsih driver.",
        "pre": {
            "sdev": "!=null",
            "sh": "!=null",
            "vtarget": "!=null",
            "vdevice": "!=null",
            "starget": "!=null",
            "hd": "!=null",
            "ioc": "!=null",
            "ioc->bus_type": "==SPI",
            "sdev->sdtr": "!=null",
            "sdev->wdtr": "!=null",
            "sdev->ppr": "!=null",
            "sdev->inquiry_len": "!=null",
            "vdevice->configured_lun": "==1",
            "sdev->queue_depth": "!=null",
            "vtarget->tflags": "!=null",
            "vtarget->negoFlags": "!=null",
            "vtarget->maxOffset": "!=null",
            "vtarget->minSyncFactor": "!=null",
            "sdev->tagged_supported": "!=null",
            "sdev->simple_tags": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCES FAILED]"
        }
    }
},
{
    "kretprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCES FAILED]"
        }
    }
},
{
    "kretprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">=0x200000",
            "geom": "!=null"
        }
    }
},
{
    "kprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">=0x200000",
            "geom": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_change_queue_depth": {
        "description": "This function will set a device's queue depth.",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kprobe:intmptscsih_change_queue_depth": {
        "description": "This function will set a device's queue depth.",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kretprobe:intmpt_raid_phys_disk_get_num_paths": {
        "description": "Returns the number of paths associated with the given physical disk number.",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null"
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_get_num_paths": {
        "description": "Returns the number of paths associated with the given physical disk number.",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_raid_phys_disk_pg1": {
        "description": "Returns the physical disk page 1",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "!=null"
        },
        "post": {
            "return_value": "in [0, -EFAULT, -ENOMEM]"
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_pg1": {
        "description": "Returns physical disk page 1",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "==null"
        }
    }
},
{
    "kretprobe:intmpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:intmpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management.",
        "pre": {
            "ioc": "!=null",
            "flags": "==0"
        }
    }
},
{
    "kprobe:voidmpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panics the kernel.",
        "pre": {
            "ioc": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panics the kernel.",
        "pre": {
            "ioc": "!=null"
        }
    }
},


{
    "kretprobe:intmpt_attach": {
        "description": "Install a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:intmpt_attach": {
        "description": "Install a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},

{
    "kprobe:mpt_detach": {
        "description": "Remove a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null"
        }
    }
},


{
    "kretprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},


{
    "kretprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler.",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in [MPT_DRIVER_CLASS]",
            "func_name": "!=null"
        }
    }
},
{
    "kprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler.",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in [MPT_DRIVER_CLASS values]",
            "func_name": "!=null"
        }
    }
},
{
    "kretprobe:mpt_deregister": {
        "description": "Deregister a protocol driver's resources.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_deregister": {
        "description": "Deregister a protocol driver's resources.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler.",
        "pre": {
            "cb_idx": "!=null",
            "ev_cbfunc": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler.",
        "pre": {
            "cb_idx": "!=null",
            "ev_cbfunc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null",
            "reset_func": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null",
            "reset_func": "!=null"
        }
    }
},
{
    "kretprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null"
        }
    }
},
{
    "kprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "ioc.active": "==true"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame": {
        "description": "Send a protocol-specific MPT request frame to an IOC",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame": {
        "description": "Send a protocol-specific MPT request frame to an IOC.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kretprobe:if (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == NULL)": {
        "description": "Check for (valid) IO callback!",
        "pre": {
            "cb_idx": "==0 || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == NULL"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if cb_idx is null or greater than or equal to MPT_MAX_PROTOCOL_DRIVERS or MptCallbacks[cb_idx] is null.",
        "pre": {
            "cb_idx": "==null || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == null"
        }
    }
},
{
    "kretprobe:intmpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "reqBytes": "!=null",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, !CAN_SLEEP]"
        }
    }
},
{
    "kprobe:intmpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "reqBytes": ">=0",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, !CAN_SLEEP]"
        }
    }
},
{
    "kretprobe:intmpt_verify_adapter": {
        "description": "Given IOC identifier, set pointer to its adapter structure.",
        "pre": {
            "iocid": "!=null",
            "iocpp": "!=null"
        },
        "post": {
            "iocid": "found",
            "iocpp": "set if iocid is found",
            "return_value": "-1 if iocid is not found"
        }
    }
},
{
    "kprobe:intmpt_verify_adapter": {
        "description": "Given IOC identifier, set pointer to its adapter structure.",
        "pre": {
            "iocid": "!=null",
            "iocpp": "!=null"
        }
    }
},

"pre": {
    "ioc": "!=null"
},


{
    "kretprobe:if (ioc->alt_ioc)ioc = ioc->alt_ioc;": {
        "description": "Check if `ioc->alt_ioc` is not null and assign its value to `ioc`.",
        "pre": {
            "ioc": "!=null",
            "ioc->alt_ioc": "!=null"
        }
    }
},


{
    "kprobe:mpt_remove_dead_ioc_func": {
        "description": "kthread context to remove dead ioc",
        "pre": {
            "arg": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},


{
    "kretprobe:intmpt_alloc_fw_memory": {
        "description": "Allocate firmware memory",
        "pre": {
            "ioc": "!=null",
            "size": ">=0"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_alloc_fw_memory": {
        "description": "Allocate firmware memory",
        "pre": {
            "ioc": "!=null",
            "size": ">=0"
        }
    }
},




{
    "kretprobe:intmpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "any",
            "phys_disk": "any"
        },
        "post": {
            "return": {
                "constraints": [
                    "0",
                    "-EFAULT",
                    "-ENOMEM"
                ]
            }
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver",
        "pre": {
            "drv": "!=null",
            "id_table": "properly populated",
            "probe_routine": "valid"
        }
    }
},
{
    "kprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_add_device": {
        "description": "Add a SuperHyway module",
        "pre": {
            "base": "!=null",
            "sdev": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:superhyway_add_device": {
        "description": "Add a SuperHyway module",
        "pre": {
            "base": "!=null",
            "sdev": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence",
        "pre": {
            "hba": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence",
        "pre": {
            "hba": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_get_local_unipro_ver": {
        "description": "Get the local UniPro version for the given UFS HBA.",
        "pre": {
            "hba": "!=null",
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "return": "in [UFS_UNIPRO_VER_1_41, UFS_UNIPRO_VER_1_6]"
        }
    }
},
{
    "kprobe:ufshcd_get_local_unipro_ver": {
        "description": "Get the local UniPro version for the given UFS HBA.",
        "pre": {
            "hba": "!=null",
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "return": "in [UFS_UNIPRO_VER_1_41, UFS_UNIPRO_VER_1_6]"
        }
    }
},
{
    "kretprobe:ufshcd_system_suspend": {
        "description": "System suspend callback for UFS controller",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ufshcd_system_suspend": {
        "description": "System suspend callback for the UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_system_resume": {
        "description": "system resume callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_system_resume": {
        "description": "system resume callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_suspend": {
        "description": "runtime suspend callback",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ufshcd_runtime_suspend": {
        "description": "runtime suspend callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_resume": {
        "description": "Runtime resume routine for UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_runtime_resume": {
        "description": "Runtime resume routine for the UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},




{
    "kretprobe:v4l2_async_nf_register": {
        "description": "Register a v4l2_async_notifier structure.",
        "pre": {
            "notifier": "!=null",
            "notifier->list": "!=null",
            "notifier_list": "!=null",
            "list_lock": "!=null"
        }
    }
},
{
    "kprobe:v4l2_async_nf_register": {
        "description": "Register a v4l2_async_notifier",
        "pre": {
            "&notifier->list": "!=null",
            "&notifier_list": "!=null",
            "&list_lock": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_async_register_subdev": {
        "description": "Register a V4L2 subdevice asynchronously.",
        "pre": {
            "sd->fwnode": "==null",
            "sd->dev": "!=null",
            "list_lock": "mutex_locked",
            "sd->async_list": "list_empty",
            "notifier_list": "list_not_empty"
        }
    }
},
{
    "kprobe:if (!sd->fwnode && sd->dev)sd->fwnode = dev_fwnode(sd->dev);mutex_lock(&list_lock);INIT_LIST_HEAD(&sd->async_list);list_for_each_entry(notifier, &notifier_list, list)": {
        "description": "Register a V4L2 async sub-device",
        "pre": {
            "sd->fwnode": "==null",
            "sd->dev": "!=null",
            "list_lock": "locked",
            "sd->async_list": "initialized",
            "notifier": "in notifier_list"
        }
    }
},
{
    "kretprobe:v4l2_norm_to_name": {
        "description": "Converts a V4L2 standard ID to its corresponding name.",
        "pre": {
            "id": "!=null",
            "myid": "!=null",
            "standards": "!=null",
            "i": ">=0",
            "i": "<=length(standards)",
            "standards[i].std": "!=null",
            "myid": "==standards[i].std"
        },
        "post": {
            "return": "!=null",
            "return": "standards[i].descr"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if myid is not equal to id and raise a bug if it is.",
        "pre": {
            "myid": "!= id"
        }
    },
    "kprobe:v4l2_norm_to_name": {
        "description": "Convert v4l2_std_id to its corresponding name.",
        "pre": {
            "id": "!= null"
        }
    },
    "kprobe:return": {
        "description": "Return the description corresponding to the given id.",
        "pre": {
            "standards[i].std": "== myid"
        }
    }
},
{
    "kretprobe:v4l2_m2m_schedule_next_job": {
        "description": "Description of the function",
        "pre": {
            "m2m_dev": "!=null",
            "m2m_ctx": "!=null"
        },
        "post": {
            "return_value": "Constraints on the return value"
        }
    }
},



{
    "kretprobe:vdev->minor = -1;/* the release callback MUST be present `": {
        "description": "Set the minor value of the video device to -1, indicating that it has never been registered.",
        "pre": {
            "vdev": "!=null",
            "vdev->minor": "-1"
        }
    }
},

{
    "kretprobe:video_unregister_device": {
        "description": "Unregister a video4linux device",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:video_unregister_device": {
        "description": "Unregister a video4linux device",
        "pre": {
            "vdev": "!=null"
        }
    }
},


{
    "kretprobe:v4l2_ctrl_type_op_equal": {
        "description": "Checks if two v4l2_ctrl objects are equal based on their type.",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null",
            "ctrl->type": "in [V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_STRING]",
            "ctrl->type == V4L2_CTRL_TYPE_BUTTON": "return false",
            "ctrl->type == V4L2_CTRL_TYPE_STRING": {
                "i": ">=0",
                "i < ctrl->elems": {
                    "idx": "= i * ctrl->elem_size",
                    "ptr1.p_char + idx": "!=null",
                    "ptr2.p_char + idx": "!=null",
                    "strcmp(ptr1.p_char + idx, ptr2.p_char + idx)": "return false"
                },
                "return true"
            },
            "default": "!memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size)"
        }
    }
},
{
    "kprobe:v4l2_ctrl_type_op_equal": {
        "description": "Checks if two v4l2_ctrl pointers are equal based on the control type.",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null",
            "ctrl->type": "in [V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_STRING]",
            "ctrl->type == V4L2_CTRL_TYPE_BUTTON": "return false",
            "ctrl->type == V4L2_CTRL_TYPE_STRING": {
                "i": ">=0",
                "i < ctrl->elems": {
                    "idx": "= i * ctrl->elem_size",
                    "ptr1.p_char + idx": "!=null",
                    "ptr2.p_char + idx": "!=null",
                    "strcmp(ptr1.p_char + idx, ptr2.p_char + idx)": "return false"
                },
                "return true"
            },
            "default": "!memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size)"
        }
    }
},
{
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of entrie safely removing each entry from the list.",
        "pre": {
            "ref": "!=null",
            "next_ref": "!=null",
            "&hdl->ctrl_refs": "!=null",
            "node": "!=null"
        }
    }
},

{
    "kretprobe:if (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev))": {
        "description": "Add immediately at the end of the list if the list is empty, or if the last element in the list has a lower ID. This ensures that when elements are added in ascending order the insertion is an O(1) operation.",
        "pre": {
            "list_empty(&hdl->ctrl_refs)": true,
            "id": "> node2id(hdl->ctrl_refs.prev)"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the list is empty or if the ID is greater than the ID of the last element in the list.",
        "pre": {
            "list_empty(&hdl->ctrl_refs)": true,
            "id": "> node2id(hdl->ctrl_refs.prev)"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_get_menu": {
        "description": "Retrieve the menu items for a specific control identified by the id parameter.",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_get_menu": {
        "description": "Get the menu associated with the control identified by *id*.",
        "pre": {
            "id": "!=null",
            "v4l2_ctrl_get_menu(id)": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_add_handler": {
        "description": "Add a control handler to another control handler in the V4L2 framework.",
        "pre": {
            "hdl": "==null",
            "add": "==null",
            "hdl == add": "==true"
        }
    }
},
{
    "kprobe:v4l2_ctrl_add_handler": {
        "description": "Add a control handler to another control handler.",
        "pre": {
            "hdl": "==null",
            "add": "==null",
            "hdl == add": "==true"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_cluster": {
        "description": "v4l2_ctrl_cluster(unsigned ncontrol struct v4l2_ctrl controls) - bool has_volatiles = false; int i; The first control is the master control and it must not be NULL",
        "pre": {
            "ncontrols": ">0",
            "controls[0]": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_cluster": {
        "description": "v4l2_ctrl_cluster(unsigned ncontrol struct v4l2_ctrl controls)",
        "pre": {
            "ncontrols": "!=0",
            "controls[0]": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_activate": {
        "description": "Invert the 'active' flag to set the 'inactive' flag.",
        "pre": {
            "ctrl": "!=null",
            "active": "==false"
        }
    }
},
{
    "kprobe:v4l2_ctrl_activate": {
        "description": "Activate or deactivate the V4L2 control.",
        "pre": {
            "ctrl": "!=null",
            "active": "bool",
            "inactive": "!active"
        }
    }
},


{
    "kretprobe:v4l2_ctrl_handler_setup": {
        "description": "Setup the V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "hdl->lock": "held",
            "ctrls": "not empty",
            "ctrls[i].done": "false",
            "ctrls[i].cluster[0]": "not handled"
        }
    }
},
{
    "kprobe:v4l2_ctrl_handler_setup": {
        "description": "Setup the V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "hdl->lock": "held",
            "ctrls": "not empty",
            "ctrls[i].done": "false",
            "ctrls[i].cluster[0]": "not handled"
        }
    }
},
{
    "kretprobe:v4l2_g_ext_ctrls_common": {
        "description": "Get extended controls for a video device.",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "==V4L2_CTRL_WHICH_REQUEST_VAL",
            "p_req_valid": "==true"
        }
    }
},
{
    "kprobe:v4l2_g_ext_ctrls_common": {
        "description": "Get extended controls from a V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "==V4L2_CTRL_WHICH_REQUEST_VAL",
            "p_req_valid": "==true"
        }
    }
},

{
    "kprobe:v4l2_ctrl_g_ctrl": {
        "description": "Get the value of the v4l2_ctrl structure.",
        "pre": {
            "ctrl": "!=null",
            "ctrl.is_int": "==true"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_g_ctrl_int64": {
        "description": "Get the value of a 64-bit integer control.",
        "pre": {
            "ctrl": "!=null",
            "ctrl->is_ptr": "==false",
            "ctrl->type": "==V4L2_CTRL_TYPE_INTEGER64"
        },
        "post": {
            "return": "==0",
            "c.value64": "==0"
        }
    }
},
{
    "kprobe:v4l2_ctrl_g_ctrl_int64": {
        "description": "Get the value of a 64-bit integer control.",
        "pre": {
            "ctrl": "!=null",
            "ctrl.is_ptr": "==false",
            "ctrl.type": "==V4L2_CTRL_TYPE_INTEGER64"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl": {
        "description": "Set the value of a V4L2 control.",
        "pre": {
            "ctrl": {
                "is_int": "true"
            },
            "val": "!=null"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl": {
        "description": "Set the value of a v4l2 control.",
        "pre": {
            "ctrl": {
                "is_int": "==true",
                "handler": {
                    "lock": "held"
                }
            },
            "WARN_ON(!ctrl->is_int)": "==false",
            "return": "-EINVAL",
            "ctrl->val": "=val",
            "set_ctrl": {
                "args": ["NULL", "ctrl", "0"]
            },
            "EXPORT_SYMBOL": "__v4l2_ctrl_s_ctrl"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "Set the value of the control to the specified 64-bit integer.",
        "pre": {
            "ctrl": {
                "is_ptr": false,
                "type": "V4L2_CTRL_TYPE_INTEGER64"
            },
            "val": "!=null"
        },
        "post": {
            "return": "-EINVAL",
            "ctrl->p_new.p_s64": "val"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "Sets the value of a V4L2 control to a 64-bit integer.",
        "pre": {
            "ctrl->is_ptr": "false",
            "ctrl->type": "V4L2_CTRL_TYPE_INTEGER64",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_string": {
        "description": "Sets the control value to a string.",
        "pre": {
            "ctrl": {
                "type": "== V4L2_CTRL_TYPE_STRING",
                "handler": {
                    "lock": "held"
                }
            },
            "s": "!= null"
        },
        "post": {
            "return": "== -EINVAL",
            "ctrl": {
                "p_new": {
                    "p_char": "strscpy( ctrl->p_new.p_char, ctrl->maximum + 1)"
                }
            },
            "set_ctrl": {
                "args": ["NULL", "ctrl", "0"]
            }
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_string": {
        "description": "__v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl ctrl, const char s)",
        "pre": {
            "ctrl": "!=null",
            "s": "!=null",
            "ctrl->type": "==V4L2_CTRL_TYPE_STRING",
            "return": "==0"
        },
        "post": {
            "ctrl->handler->lock": "held"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_compound": {
        "description": "Set the value of a compound control.",
        "pre": {
            "ctrl": "!=null",
            "type": "!=null",
            "p": "!=null",
            "ctrl->type": "==type"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_compound": {
        "description": "Set the value of a compound control.",
        "pre": {
            "ctrl": "!=null",
            "type": "!=null",
            "p": "!=null",
            "ctrl->type": "==type",
            "return": "== -EINVAL",
            "ctrl->handler->lock": "is held"
        }
    }
},
{
    "kretprobe:find_ref": {
        "description": "Find a reference in the control handler.",
        "pre": {
            "hdl": "!=null",
            "id": "!=null"
        }
    },
    "kretprobe:list_empty": {
        "description": "Check if the control references list is empty.",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:find_ref": {
        "description": "Find the reference for a control handler and query extended control.",
        "pre": {
            "hdl": "!=null",
            "qc": "!=null",
            "next_flags": "V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND",
            "id": "qc->id & V4L2_CTRL_ID_MASK",
            "ref": "!=null",
            "ctrl": "!=null",
            "hdl->lock": "locked"
        }
    }
},






{
    "kretprobe:v4l2_ctrl_request_complete": {
        "description": "v4l2_ctrl_request_complete() could not allocate a control handler object to store the completed state in. So return ENOMEM to indicate that there was an out-of-memory error.",
        "pre": {
            "set": "==null",
            "new_hdl": "!=null",
            "ret": "==ENOMEM"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the condition is true",
        "pre": {
            "set": "==null"
        }
    },
    "kprobe:ERR_PTR": {
        "description": "Return an error pointer",
        "pre": {
            "set": "==null"
        }
    },
    "kprobe:kzalloc": {
        "description": "Allocate memory for new_hdl",
        "pre": {
            "new_hdl": "==null"
        }
    },
    "kprobe:v4l2_ctrl_handler_init": {
        "description": "Initialize v4l2 control handler",
        "pre": {
            "ret": "==null"
        }
    },
    "kprobe:v4l2_ctrl_request_bind": {
        "description": "Bind v4l2 control request",
        "pre": {
            "ret": "==null"
        }
    }
},
{
    "kretprobe:media_request_object_find": {
        "description": "Find the media request object for the given request and main handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        },
        "post": {
            "obj": "!=null",
            "obj->completed": "==false"
        }
    }
},
{
    "kprobe:media_request_object_find": {
        "description": "Find the media request object for the given request and control handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        }
    },
    "kprobe:v4l2_ctrl_request_setup": {
        "description": "Setup the V4L2 control request with the given media request and control handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        }
    },
    "kprobe:obj->completed": {
        "description": "Check if the 'completed' flag of the media request object is set.",
        "pre": {
            "obj": "!=null",
            "obj->completed": "==false"
        }
    }
},
{
    "kretprobe:s5h1409_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1409_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:zl10036_read_status_reg": {
        "description": "Read the status register of the zl10036 device.",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "ret": "< 0"
        }
    }
},
{
    "kprobe:zl10036_read_status_reg": {
        "description": "Read the status register of the zl10036 device.",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "fe->ops.i2c_gate_ctrl": "exists => fe->ops.i2c_gate_ctrl(1)"
        }
    }
},


{
    "kretprobe:cx24123_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24123_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:lg2160_attach": {
        "description": "Attach function for lg2160",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->fic_ver": "0xff",
            "state->parade_id": "0xff",
            "config->lg_chip": "in [LG2160, LG2161]",
            "state->frontend.demodulator_priv": "state",
            "state->current_frequency": "-1",
            "state->frontend.dtv_property_cache.atscmh_parade_id": "1"
        }
    }
},
{
    "kprobe:state->frontend.dtv_property_cache.atscmh_parade_id = 1;return &state->frontend;}EXPORT_SYMBOL(lg2160_attach": {
        "description": "Attach the LG2160 frontend to the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->fic_ver": "0xff",
            "state->parade_id": "0xff",
            "config->lg_chip": "in [LG2160, LG2161]",
            "state->frontend.demodulator_priv": "state",
            "state->current_frequency": "-1",
            "state->frontend.dtv_property_cache.atscmh_parade_id": "1"
        }
    }
},
{
    "kretprobe:state = kzalloc(sizeof(*state), GFP_KERNEL);if (!state)return NULL;/* setup the state `": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:state = kzalloc(sizeof(*state), GFP_KERNEL);if (!state)return NULL;/* setup the state `": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "state": "!=null",
            "sizeof(*state)": "!=0",
            "GFP_KERNEL": "in [GFP_KERNEL, GFP_ATOMIC, GFP_NOWAIT]"
        }
    }
},
{
    "kretprobe:cx22702_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "sizeof(struct cx22702_state)": "!=null",
            "GFP_KERNEL": "!=null"
        }
    },
    "kprobe:if (state == NULL)goto error": {
        "description": "Check if the allocated memory is NULL",
        "pre": {
            "state": "==null"
        }
    },
    "kprobe:/* setup the state `": {
        "description": "Setup the state",
        "pre": {}
    }
},
{
    "kretprobe:tda10023_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10023_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        }
    }
},
{
    "kretprobe:nxt6000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:nxt6000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:s5h1411_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1411_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:mt312_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:mt312_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},

{
    "kprobe:lgs8gxx_read_reg": {
        "description": "Read a register from the lgs8gxx device.",
        "pre": {
            "priv": "!=null",
            "data": "any"
        }
    }
},
{
    "kretprobe:dprintk": {
        "description": "Prints a debug message.",
        "pre": {
            "state": "!=null",
            "state->pid_ctrl_index": "==state->pid_ctrl_index+1",
            "state->pid_ctrl[state->pid_ctrl_index].cmd": "==DIB9000_PID_FILTER_CTRL",
            "state->pid_ctrl[state->pid_ctrl_index].onoff": "==onoff",
            "mutex_lock_interruptible(&state->demod_lock)": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:dib9000_fw_pid_filter_ctrl": {
        "description": "Postpone the pid filtering cmd.",
        "pre": {
            "fe": "!=null",
            "onoff": "!=null",
            "state": "!=null",
            "state->demodulator_priv": "!=null",
            "state->pid_ctrl_index": "!=null",
            "state->pid_ctrl_index": "< 9"
        }
    }
},
{
    "kretprobe:dib9000_i2c_enumeration": {
        "description": "Enumeration function for dib9000_i2c",
        "pre": {
            "new_addr": "first_addr + (k << 1)",
            "client.i2c_addr": "default_addr",
            "dib9000_i2c_write16(&client, 1817, 3)": "true",
            "dib9000_i2c_write16(&client, 1796, 0)": "true",
            "dib9000_i2c_write16(&client, 1227, 1)": "true",
            "dib9000_i2c_write16(&client, 1227, 0)": "true",
            "client.i2c_addr": "new_addr",
            "dib9000_i2c_write16(&client, 1817, 3)": "true",
            "dib9000_i2c_write16(&client, 1796, 0)": "true",
            "dib9000_i2c_write16(&client, 1227, 1)": "true",
            "dib9000_i2c_write16(&client, 1227, 0)": "true",
            "if (dib9000_identify(&client) == 0)": "true"
        }
    }
},
{
    "kprobe:dib9000_i2c_enumeration": {
        "description": "Enumeration function for dib9000 i2c devices.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "first_addr": "!=null"
        }
    }
},
{
    "kretprobe:dib9000_attach": {
        "description": "Attach the dib9000 device to the i2c adapter with the given configuration.",
        "pre": {
            "i2c_adap": "!=null",
            "i2c_addr": "!=null",
            "cfg": "!=null",
            "st": "!=null",
            "fe": "!=null",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_SERIAL",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_PAR_GATED_CLK",
            "st->chip.d9.cfg.output_mode": "=OUTMODE_MPEG2_FIFO",
            "dib9000_identify(&st->i2c)": "=0",
            "st->i2c.i2c_adap": "=i2c_adap",
            "st->i2c.i2c_addr": "=i2c_addr",
            "st->i2c.i2c_write_buffer": "=st->i2c_write_buffer",
            "st->i2c.i2c_read_buffer": "=st->i2c_read_buffer",
            "st->gpio_dir": "=DIB9000_GPIO_DEFAULT_DIRECTIONS",
            "st->gpio_val": "=DIB9000_GPIO_DEFAULT_VALUES",
            "st->gpio_pwm_pos": "=DIB9000_GPIO_DEFAULT_PWM_POS",
            "st->platform.risc.mbx_if_lock": "!=null",
            "st->platform.risc.mbx_lock": "!=null",
            "st->platform.risc.mem_lock": "!=null",
            "st->platform.risc.mem_mbx_lock": "!=null",
            "st->demod_lock": "!=null",
            "st->get_frontend_internal": "=0",
            "st->pid_ctrl_index": "=-2",
            "st->fe[0]": "=fe",
            "fe->demodulator_priv": "=st",
            "st->fe[0]->ops": "=dib9000_ops"
        },
        "post": {
            "return": "=fe"
        }
    }
},
{
    "kprobe:dib9000_attach": {
        "description": "Attaches a DIB9000 device to an I2C adapter.",
        "pre": {
            "i2c_adap": "!=null",
            "i2c_addr": "!=null",
            "cfg": "!=null",
            "st": "!=null",
            "fe": "!=null",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_SERIAL",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_PAR_GATED_CLK",
            "st->chip.d9.cfg.output_mode": "=OUTMODE_MPEG2_FIFO",
            "dib9000_identify(&st->i2c)": "==0",
            "st->tuner_adap.dev.parent": "=i2c_adap->dev.parent",
            "st->tuner_adap.name": "=DIB9000_FW TUNER ACCESS",
            "st->tuner_adap.algo": "=&dib9000_tuner_algo",
            "st->tuner_adap.algo_data": "=NULL",
            "i2c_set_adapdata(&st->tuner_adap, st)": "!=NULL",
            "i2c_add_adapter(&st->tuner_adap)": "<0",
            "st->component_bus.dev.parent": "=i2c_adap->dev.parent",
            "st->component_bus.name": "=DIB9000_FW COMPONENT BUS ACCESS",
            "st->component_bus.algo": "=&dib9000_component_bus_algo",
            "st->component_bus.algo_data": "=NULL",
            "st->component_bus_speed": "=340",
            "i2c_set_adapdata(&st->component_bu st)": "!=NULL",
            "i2c_add_adapter(&st->component_bus)": "<0",
            "dib9000_fw_reset(fe)": "",
            "return": "fe",
            "component_bus_add_error": "i2c_del_adapter(&st->tuner_adap)",
            "error": "kfree(st)",
            "return": "NULL"
        }
    }
},


{
    "kretprobe:dibx000_i2c_gate_ctrl": {
        "description": "Initialize the i2c-master by closing the gate",
        "pre": {
            "mst": "!=null",
            "mst->i2c_write_buffer": "!=null",
            "device_rev": "is u16",
            "i2c_adap": "!=null",
            "i2c_addr": "is u8"
        },
        "post": {
            "ret": "==1",
            "mutex_unlock(&mst->i2c_buffer_lock)": "called"
        }
    }
},
{
    "kprobe:dibx000_i2c_gate_ctrl": {
        "description": "Initialize the i2c-master by closing the gate.",
        "pre": {
            "mst": "!=null",
            "mst->i2c_write_buffer": "!=null",
            "device_rev": "is u16",
            "i2c_adap": "!=null",
            "i2c_addr": "is u8"
        }
    }
},
{
    "kretprobe:l64781_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:l64781_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "ter_state": "==null"
        }
    }
},
{
    "kprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "cab_state": "==null"
        }
    }
},
{
    "kprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ddb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "ter_state": "==null",
            "cab_state": "==null"
        }
    }
},
{
    "kprobe:stv0367ddb_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb6000_attach": {
        "description": "Attach STB6000 tuner to DVB frontend",
        "pre": {
            "ret": "==2",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "priv": "!=null"
        },
        "post": {
            "fe": "!=null"
        }
    }
},
{
    "kprobe:stb6000_attach": {
        "description": "Attach STB6000 frontend to DVB frontend",
        "pre": {
            "fe": {
                "ops": {
                    "i2c_gate_ctrl": "!=null"
                }
            },
            "ret": "==2",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:cx24113_agc_callback": {
        "description": "This function is the kretprobe for cx24113_agc_callback.",
        "pre": {
            "fe": "!=null",
            "fe->ops.read_signal_strength": "!=null",
            "fe->tuner_priv": "!=null",
            "s": "!=null",
            "i": "!=null",
            "cx24113_agc_table[state->gain_level][i]": "> s",
            "s": "<= -25",
            "i": "<= (sizeof(cx24113_agc_table[0]) - 1) / 5"
        }
    }
},
{
    "kprobe:fe->ops.read_signal_strength": {
        "description": "Reads the signal strength from the frontend.",
        "pre": {
            "fe": "!=null",
            "fe->ops.read_signal_strength": "!=null"
        }
    },
    "kprobe:dprintk": {
        "description": "Prints the signal strength.",
        "pre": {
            "format": "is a string",
            "arguments": [
                {
                    "type": "int",
                    "value": "signal strength: %d"
                },
                {
                    "type": "int",
                    "value": "s"
                }
            ]
        }
    },
    "kprobe:cx24113_agc_table": {
        "description": "Accesses the AGC table.",
        "pre": {
            "state": "!=null",
            "state->gain_level": "!=null",
            "i": "!=null",
            "cx24113_agc_table[state->gain_level][i]": "!=null",
            "s": "!=null"
        }
    },
    "kprobe:cx24113_set_gain_settings": {
        "description": "Sets the gain settings.",
        "pre": {
            "state": "!=null",
            "s": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(cx24113_agc_callback)": {
        "description": "Exports the cx24113_agc_callback symbol."
    }
},
{
    "kretprobe:cx24113_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24113_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "state": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "state": "==null"
        }
    },
    "state.config": {
        "description": "Set the configuration value",
        "pre": {
            "state.config": "!=null"
        }
    },
    "state.i2c": {
        "description": "Set the i2c value",
        "pre": {
            "state.i2c": "!=null"
        }
    },
    "state.prevUCBS2": {
        "description": "Set the prevUCBS2 value",
        "pre": {
            "state.prevUCBS2": "==0"
        }
    },
    "ds3000_attach": {
        "description": "Check if the demod is present",
        "pre": {
            "ds3000_attach": "!=null"
        }
    }
},
{
    "ds3000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:cx24116_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24116_attach": {
        "description": "Allocate memory for the internal state and check if the demod is present.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:isl6405_attach": {
        "description": "Attach the isl6405 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": "& 0x80 != 0",
            "override_clear": "& 0x80 == 0"
        }
    }
},
{
    "kprobe:isl6405_attach": {
        "description": "Attach the isl6405 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": "& 0x80 != 0",
            "override_clear": "& 0x80 == 0"
        }
    }
},
{
    "kretprobe:tda10048_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10048_attach": {
        "description": "Attach the tda10048 device with the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:cx24110_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:cx24110_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv6110_attach": {
        "description": "Attach STV6110 tuner to DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "reg0": "array of size 9",
            "msg": "array of size 1",
            "ret": "int",
            "priv": "null",
            "priv.i2c_address": "config->i2c_address",
            "priv.i2c": "i2c",
            "priv.mclk": "config->mclk",
            "priv.clk_div": "config->clk_div",
            "priv.gain": "config->gain",
            "priv.regs": "array of size 8",
            "fe.ops.tuner_ops": "struct dvb_tuner_ops",
            "fe.tuner_priv": "priv"
        },
        "post": {
            "return": "fe"
        }
    }
},
{
    "kprobe:stv6110_attach": {
        "description": "Attach STV6110 tuner to DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "config->i2c_address": "!=null",
            "reg0": "!=null",
            "msg": "!=null",
            "ret": "!=null",
            "priv": "==null"
        }
    }
},
{
    "kretprobe:bcm3510_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:bcm3510_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:s5h1432_attach": {
        "description": "Attach the s5h1432 device to the i2c adapter and allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1432_attach": {
        "description": "Attach the s5h1432 device to the i2c adapter and allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:new_addr": {
        "description": "Assigns a new address to the 'dmcst->i2c_addr' variable and identifies the dib3000mc device.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": "int",
            "default_addr": "int",
            "cfg": "!=null",
            "k": "int",
            "new_addr": "int",
            "DIB3000MC_I2C_ADDRESS": "array",
            "dmcst": "!=null",
            "dmcst->i2c_adap": "i2c_adapter",
            "dmcst->cfg": "!=null",
            "dmcst->i2c_addr": "int"
        },
        "post": {
            "return_value": "int",
            "dmcst->i2c_addr": "new_addr",
            "dib3000mc_identify(dmcst)": "0"
        }
    }
},
{
    "kprobe:new_addr = DIB3000MC_I2C_ADDRESS[k]; dmcst->i2c_addr = new_addr; if (dib3000mc_identify(dmcst) != 0)": {
        "description": "This function sets the new address for the DIB3000MC device and identifies it.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "cfg": "!=null",
            "k": ">=0",
            "new_addr": "in DIB3000MC_I2C_ADDRESS",
            "dmcst": "!=null",
            "dmcst->i2c_adap": "==i2c",
            "k >= 0": "true"
        }
    }
},



{
    "kprobe:u8_ltg2": {
        "description": "Check if ltg2 is non-zero when current_band is BAND_CBAND.",
        "pre": {
            "state->current_band": "==BAND_CBAND",
            "ltg2": "!=0"
        }
    }
},
{
    "kretprobe:or51211_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:or51211_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:zl10039_attach": {
        "description": "Attach the zl10039 tuner to the dvb_frontend.",
        "pre": {
            "fe": "!=null",
            "i2c_addr": "!=null",
            "i2c": "!=null",
            "state": "==null"
        }
    }
},
{
    "kprobe:if (fe->ops.i2c_gate_ctrl)fe->ops.i2c_gate_ctrl(fe, 1);/* check if this is a valid tuner `": {
        "description": "Open i2c gate",
        "pre": {
            "fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "i2c_addr": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:usleep_range": {
        "description": "IQ Generator disable",
        "pre": {
            "min_usec": "==4000",
            "max_usec": "==6000"
        }
    }
},
{
    "kprobe:usleep_range": {
        "description": "IQ Generator disable",
        "pre": {
            "min_usec": "==4000",
            "max_usec": "==6000"
        }
    }
},
{
    "kretprobe:stv090x_attach": {
        "description": "Attach function for stv090x",
        "pre": {
            "state->demod_mode": "= config->demod_mode",
            "state->device": "= config->device"
        }
    }
},
{
    "kprobe:stv090x_attach": {
        "description": "Attach the STV090x demodulator with the given configuration.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "demod": "in [STV090X_DEMOD_SINGLE, STV090X_DEMOD_DUAL]",
            "state": "!=null",
            "state->verbose": "!=null",
            "state->config": "!=null",
            "state->i2c": "!=null",
            "state->frontend.ops": "!=null",
            "state->frontend.demodulator_priv": "!=null",
            "state->demod": "in [STV090X_DEMOD_SINGLE, STV090X_DEMOD_DUAL]",
            "state->demod_mode": "= config->demod_mode",
            "state->device": "= config->device"
        }
    }
},
{
    "kretprobe:ves1x93_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ves1x93_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb0899_attach": {
        "description": "Attach the stb0899 configuration and i2c adapter to the stb0899 state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "state->verbose": "!=null",
            "state->config": "= config",
            "state->i2c": "= i2c",
            "state->frontend.ops": "= stb0899_ops",
            "state->frontend.demodulator_priv": "= state",
            "state->internal.inversion": "= config->inversion",
            "stb0899_get_dev_id(state)": "== -ENODEV"
        }
    }
},
{
    "kprobe:stb0899_attach": {
        "description": "Attach the stb0899 configuration and i2c adapter to the stb0899 state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:lgdt3306a_attach": {
        "description": "Attach the lgdt3306a driver to the i2c adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "==config",
            "state->i2c_adap": "==i2c_adap",
            "state->frontend.ops": "==lgdt3306a_ops",
            "state->frontend.demodulator_priv": "==state"
        }
    }
},
{
    "kprobe:lgdt3306a_attach": {
        "description": "Attach the lgdt3306a driver to the specified configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        }
    }
},
{
    "kretprobe:dvb_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);if (!state)return NULL;/* create dvb_frontend": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:ec100_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "sizeof(struct ec100_state)": "!=null",
            "GFP_KERNEL": "!=null"
        }
    },
    "kprobe:if (state == NULL)goto error": {
        "description": "Check if the allocated memory is NULL",
        "pre": {
            "state": "==null"
        }
    },
    "kprobe:/* setup the state `": {
        "description": "Setup the state",
        "pre": {}
    }
},


{
    "kretprobe:lgs8gl5_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:lgs8gl5_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:new_addr": {
        "description": "The new address is calculated as (0x40 + k) << 1. The i2c address is set to the new address. If dib7000m_identify(&st) returns a non-zero value, the condition is not satisfied.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "cfg": "!=null",
            "k": ">=0",
            "new_addr": ">=0",
            "dib7000m_identify(&st)": "==0"
        }
    }
},
{
    "kprobe:new_addr": {
        "description": "Assign a new address to the variable new_addr.",
        "pre": {
            "k": ">= 0",
            "no_of_demods": ">= 0",
            "i2c": "!= null",
            "default_addr": "!= null",
            "cfg": "!= null"
        }
    },
    "kprobe:st.i2c_addr": {
        "description": "Assign the value of new_addr to st.i2c_addr.",
        "pre": {
            "new_addr": "!= null",
            "st": "!= null"
        }
    },
    "kprobe:dib7000m_identify": {
        "description": "Check if dib7000m_identify(&st) returns 0.",
        "pre": {
            "st": "!= null"
        }
    }
},


{
    "kretprobe:si21xx_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:si21xx_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:nxt200x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:nxt200x_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:ascot2e_attach": {
        "description": "Attach the ascot2e driver to the dvb_frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "data": "!=null",
            "priv": "!=null",
            "priv": "kzalloc(sizeof(struct ascot2e_priv), GFP_KERNEL)",
            "priv->i2c_address": "(config->i2c_address >> 1)",
            "priv->i2c": "i2c",
            "priv->set_tuner_data": "config->set_tuner_priv",
            "priv->set_tuner": "config->set_tuner_callback",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "fe->ops.i2c_gate_ctrl(fe, 1)": "null",
            "data[0]": "16"
        }
    }
},
{
    "kprobe:ascot2e_attach": {
        "description": "Attach the ascot2e driver to the DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:state->uio_mask = config->antenna_gpio;/* Default gpio to DVB-C `": {
        "description": "Set the default gpio to DVB-C",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "config->antenna_gpio": "!=null"
        }
    }
},
{
    "kprobe:state->uio_mask = config->antenna_gpio;/* Default gpio to DVB-C `": {
        "description": "Set the value of state's uio_mask to config's antenna_gpio.",
        "pre": {
            "state": "!=null",
            "config->antenna_gpio": "!=null"
        }
    }
},
{
    "kretprobe:dib0070_wbd_offset": {
        "description": "Calculate and return the WBD offset value based on the current gain.",
        "pre": {
            "state": "!=null",
            "tmp": "!=null",
            "state->wbd_gain_current": ">= 6",
            "state->wbd_offset_3_3[state->wbd_gain_current - 6]": "!=null"
        }
    }
},
{
    "kprobe:dib0070_wbd_offset": {
        "description": "Calculate and return the WBD offset for the given state.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:tda10086_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:tda10086_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:CDRXD": {
        "description": "Attach a DRXD device with the given configuration, private data, I2C adapter, and device.",
        "pre": {
            "config": "!=null",
            "priv": "!=null",
            "i2c": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:CDRXD": {
        "description": "Attach the drxd device with the given configuration, private data, I2C adapter, and device.",
        "pre": {
            "config": "!=null",
            "priv": "!=null",
            "i2c": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:lgdt3305_attach": {
        "description": "Attach LGDT3305 hardware",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "ret": "int",
            "val": "u8",
            "config->i2c_addr": "int",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->frontend.ops": "memcpy(&lgdt3305_op sizeof(struct dvb_frontend_ops))",
            "state->frontend.demodulator_priv": "state"
        },
        "post": {
            "ret": "!=null",
            "state->current_frequency": "-1",
            "state->current_modulation": "-1",
            "return": "&state->frontend"
        },
        "fail": {
            "lg_warn": "unable to detect %s hardware\n",
            "config->demod_chip": "LGDT3304 or LGDT3305",
            "state": "kfree(state)",
            "return": "NULL"
        }
    }
},
{
    "kprobe:lgdt3305_attach": {
        "description": "Attach the LGDT3305 demodulator to the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        }
    },
    "kprobe:lgdt3305_read_reg": {
        "description": "Read the value of the register at the given address using the LGDT3305 demodulator state.",
        "pre": {
            "state": "!=null",
            "reg_addr": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:lgdt3305_write_reg": {
        "description": "Write the given value to the register at the given address using the LGDT3305 demodulator state.",
        "pre": {
            "state": "!=null",
            "reg_addr": "!=null",
            "value": "!=null"
        }
    }
},

{
    "kprobe:atbm8830_read_reg": {
        "description": "Read the value of the register with ID REG_CHIP_ID.",
        "pre": {
            "priv": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ves1820_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:tda10021_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10021_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        }
    }
},
{
    "kretprobe:isl6421_attach": {
        "description": "Attach the isl6421 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": ">=0",
            "override_clear": ">=0",
            "override_tone": "is boolean",
            "isl6421": "!=null",
            "isl6421->config": "==ISL6421_ISEL1",
            "isl6421->i2c": "==i2c",
            "isl6421->i2c_addr": "==i2c_addr",
            "fe->sec_priv": "==isl6421"
        }
    }
},
{
    "kprobe:isl6421_attach": {
        "description": "Attach the isl6421 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": ">=0",
            "override_clear": ">=0",
            "override_tone": "is boolean",
            "isl6421": "!=null"
        }
    }
},
{
    "kretprobe:s921_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:struct_s921_state_kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:ts2020_attach": {
        "description": "This is only used by ts2020_probe() so can be on the stack",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "config.fe": "!=null",
            "config.attach_in_use": "true",
            "board_info": "!=null",
            "board_info.type": "==\"ts2020\"",
            "board_info.addr": "==config.tuner_address",
            "board_info.platform_data": "==&pdata",
            "client": "!=null",
            "i2c_client_has_driver(client)": "==false"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ts2020_attach": {
        "description": "This is only used by ts2020_probe() so can be on the stack",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:dib3000mb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:dib3000mb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        }
    }
},
{
    "kretprobe:isl6423->reg_3 = 0x02 << 5": {
        "description": "Set the value of isl6423->reg_3 to 0x02 shifted left by 5 bits.",
        "pre": {
            "isl6423": "!=null",
            "fe": "!=null",
            "i2c": "!=null",
            "config": "!=null",
            "SR3H": "0",
            "SR3M": "1",
            "SR3L": "0"
        }
    }
},
{
    "kprobe:isl6423->reg_3 = 0x02 << 5;/* SR4H = 0, SR4M = 1, SR4L = 1 */": {
        "description": "Set the value of isl6423->reg_3 to 0x02 shifted left by 5 bits.",
        "pre": {
            "isl6423": "!=null",
            "reg_3": "==0x02 << 5",
            "SR4H": "==0",
            "SR4M": "==1",
            "SR4L": "==1"
        }
    }
},
{
    "kretprobe:cx22700_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:cx22700_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:mt352_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:mt352_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:au8522_i2c_gate_ctrl": {
        "description": "Manage the gate control for the au8522 demodulator.",
        "pre": {
            "fe": "!=null",
            "enable": "any",
            "state": "!=null"
        }
    }
},

{
    "kretprobe:au8522_led_ctrl": {
        "description": "Control an LED in the au8522_state structure.",
        "pre": {
            "state": "!=null",
            "led": ">= 0",
            "led_config": "!=null",
            "led_config->gpio_leds": "!=null",
            "led_config->num_led_states": "!=null",
            "led_config->led_states": "!=null"
        }
    }
},
{
    "kprobe:au8522_led_ctrl": {
        "description": "Control an LED in the au8522_state structure.",
        "pre": {
            "state": "!=null",
            "led": ">=0",
            "led_config": "!=null",
            "led_config->gpio_leds": "!=null",
            "led_config->num_led_states": "!=null",
            "led_config->led_states": "!=null"
        }
    }
},



{
    "kprobe:au8522_sleep": {
        "description": "Power down the AU8522 chip if the digital side is currently using it.",
        "pre": {
            "state->operational_mode": "== AU8522_ANALOG_MODE"
        }
    }
},
{
    "kretprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:tda8083_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda8083_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb6100_attach": {
        "description": "Attach STB6100 tuner to dvb_frontend",
        "pre": {
            "fe": "!=null",
            "state": "!=null",
            "stb6100_ops": "!=null",
            "fe->tuner_priv": "==state",
            "fe->ops.tuner_ops": "==stb6100_ops"
        }
    }
},
{
    "kprobe:stb6100_attach": {
        "description": "Attach STB6100 tuner",
        "pre": {
            "fe": "!=null",
            "config": "unknown",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:struct s5h1420_state *state = kzalloc(sizeof(struct s5h1420_state), GFP_KERNEL);": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:s5h1420_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:drx39xxj_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "demod": "!=null",
            "demod_addr": "!=null",
            "demod_comm_attr": "!=null",
            "demod_ext_attr": "!=null"
        }
    }
},
{
    "kprobe:drx39xxj_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "demod_addr": "!=null",
            "demod_comm_attr": "!=null",
            "demod_ext_attr": "!=null",
            "demod": "!=null",
            "p": "!=null",
            "result": "int"
        }
    }
},
{
    "kretprobe:fimc_find_remote_sensor": {
        "description": "Find the remote sensor for a given media entity.",
        "pre": {
            "pad": "!=null",
            "is_media_entity_v4l2_subdev(pad->entity)": "true",
            "sd->grp_id": "in [GRP_ID_FIMC_IS_SENSOR, GRP_ID_SENSOR]"
        }
    }
},
{
    "pad": "!=null"
},
{
    "kretprobe:mtk_v4l2_err": {
        "description": "mtk_v4l2_err function",
        "pre": {
            "ctx": "!=null",
            "command": "!=null",
            "timeout_ms": ">=0",
            "hw_id": ">=0"
        }
    }
},

{
    "kretprobe:vdoa_device_run": {
        "description": "Progressive, no sync, 1 frame per run",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "dst_q_data->pixelformat": "== V4L2_PIX_FMT_YUYV",
            "val": "== VDOAC_PFS",
            "writel(val, vdoa->regs + VDOAC)": "success",
            "writel(dst_q_data->height << 16 | dst_q_data->width, vdoa->regs + VDOAFP)": "success",
            "val": "== dst",
            "writel(val, vdoa->regs + VDOAIEBA00)": "success",
            "writel(src_q_data->bytesperline << 16 | dst_q_data->bytesperline, vdoa->regs + VDOASL)": "success",
            "dst_q_data->pixelformat": "== V4L2_PIX_FMT_NV12 || dst_q_data->pixelformat == V4L2_PIX_FMT_NV21",
            "val": "== dst_q_data->bytesperline * dst_q_data->height",
            "writel(val, vdoa->regs + VDOAIUBO)": "success",
            "val": "== src",
            "writel(val, vdoa->regs + VDOAVEBA0)": "success",
            "val": "== round_up(src_q_data->bytesperline * src_q_data->height, 4096)",
            "writel(val, vdoa->regs + VDOAVUBO)": "success"
        }
    }
},

{
    "kretprobe:vdoa_context_configure": {
        "description": "Configure the VDOA context",
        "pre": {
            "ctx": "!=null",
            "width": ">=16 && <=8192 && %16==0",
            "height": ">=16 && <=4096 && %16==0",
            "pixelformat": "==V4L2_PIX_FMT_YUYV || ==V4L2_PIX_FMT_NV12"
        }
    }
},
{
    "kprobe:vdoa_context_configure": {
        "description": "Configure the VDOA context with the given parameters.",
        "pre": {
            "ctx": "!=null",
            "width": ">=16 && <=8192 && %16==0",
            "height": ">=16 && <=4096 && %16==0",
            "pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12]"
        }
    }
},
{
    "kretprobe:DUMPREG": {
        "description": "Dump registers specific to VPE or VIP based on who is using it.",
        "pre": {
            "vpdma": "!=null",
            "dev": "valid device",
            "PID": "!=null",
            "LIST_ADDR": "!=null",
            "LIST_ATTR": "!=null",
            "LIST_STAT_SYNC": "!=null",
            "BG_RGB": "!=null",
            "BG_YUV": "!=null",
            "SETUP": "!=null",
            "MAX_SIZE1": "!=null",
            "MAX_SIZE2": "!=null",
            "MAX_SIZE3": "!=null",
            "group": "in [0, 3]"
        }
    }
},
{
    "kprobe:DUMPREG(INT_CHAN_STAT(0))": {
        "description": "Dump register INT_CHAN_STAT(0)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_MASK(0))": {
        "description": "Dump register INT_CHAN_MASK(0)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_STAT(3))": {
        "description": "Dump register INT_CHAN_STAT(3)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_MASK(3))": {
        "description": "Dump register INT_CHAN_MASK(3)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT0_STAT)": {
        "description": "Dump register INT_CLIENT0_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT0_MASK)": {
        "description": "Dump register INT_CLIENT0_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT1_STAT)": {
        "description": "Dump register INT_CLIENT1_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT1_MASK)": {
        "description": "Dump register INT_CLIENT1_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_LIST0_STAT)": {
        "description": "Dump register INT_LIST0_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_LIST0_MASK)": {
        "description": "Dump register INT_LIST0_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list for VPDMA.",
        "pre": {
            "list": "!=null",
            "size": ">=0",
            "type": "in [VPDMA_LIST_TYPE_NORMAL]"
        }
    }
},
{
    "kprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list for VPDMA.",
        "pre": {
            "list": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:vpdma_update_dma_addr": {
        "description": "Update DMA address in vpdma_data structure",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "in [0, 1]",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:vpdma_update_dma_addr": {
        "description": "Update DMA address in vpdma_data structure",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "in [0, 1]",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:sc_set_hs_coeffs": {
        "description": "Set the high-speed coefficients for the given sc_data structure.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "!=null",
            "dst_w": "!=null",
            "sixteenths": "int",
            "idx": "int",
            "i": "int",
            "j": "int",
            "coeff_h": "u16",
            "cp": "const u16",
            "dst_w_condition": "dst_w > src_w",
            "dst_w_condition2": "(dst_w << 1) < src_w"
        },
        "post": {
            "dst_w_update": "if dst_w_condition2 then dst_w <<= 1"
        }
    }
},
{
    "kprobe:sc_set_hs_coeffs": {
        "description": "Set the high-speed coefficients for the given sc_data structure.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "!=null",
            "dst_w": "!=null",
            "sixteenths": "int",
            "idx": "int",
            "i": "int",
            "j": "int",
            "coeff_h": "u16",
            "cp": "const u16",
            "dst_w > src_w": "bool",
            "(dst_w << 1) < src_w": "bool"
        }
    }
},
{
    "kretprobe:sc_set_vs_coeffs": {
        "description": "Function to update coefficients for the vertical scaler",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "!=null",
            "dst_h": "!=null",
            "coeff_v": "!=null",
            "cp": "!=null",
            "idx": "in [VS_UP_SCALE, VS_1_TO_1_SCALE, VS_LT_9_16_SCALE + sixteenths - 8]",
            "sixteenths": ">= 8",
            "i": ">= 0",
            "j": ">= 0"
        }
    }
},
{
    "kprobe:sc_set_vs_coeffs": {
        "description": "Set vertical scaler coefficients.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "!=null",
            "dst_h": "!=null"
        }
    }
},
{
    "kretprobe:sc_config_scaler": {
        "description": "Configure the scaler",
        "pre": {
            "sc": "!=null",
            "sc_reg0": "!=null",
            "sc_reg8": "!=null",
            "sc_reg17": "!=null",
            "src_w": ">=0",
            "src_h": ">=0",
            "dst_w": ">=0",
            "dst_h": ">=0"
        }
    }
},
{
    "kprobe:sc_config_scaler": {
        "description": "Configure the scaler",
        "pre": {
            "sc": "!=null",
            "sc_reg0": "!=null",
            "sc_reg8": "!=null",
            "sc_reg17": "!=null",
            "src_w": "!=null",
            "src_h": "!=null",
            "dst_w": "!=null",
            "dst_h": "!=null"
        }
    }
},





{
    "kprobe:return;}if (s->type == CX18_ENC_STREAM_TYPE_VBI &&test_bit(CX18_F_S_INTERNAL_USE, &s->s_flags))": {
        "description": "Release the cx18 stream.",
        "pre": {
            "s": "!=null",
            "s->type": "== CX18_ENC_STREAM_TYPE_VBI",
            "test_bit(CX18_F_S_INTERNAL_USE, &s->s_flags)": "== true"
        }
    }
},

{
    "kprobe:captype = CAPTURE_CHANNEL_TYPE_VBI;#endifcx->vbi.frame = 0;cx->vbi.inserted_frame = 0;memset(cx->vbi.sliced_mpeg_size,0, sizeof(cx->vbi.sliced_mpeg_size));break;default:return -EINVAL;": {
        "description": "Set capture type to VBI and initialize related variables.",
        "pre": {
            "cx": "!=null",
            "cx->vbi.frame": "==0",
            "cx->vbi.inserted_frame": "==0",
            "cx->vbi.sliced_mpeg_size": "array of zeros with size sizeof(cx->vbi.sliced_mpeg_size)"
        },
        "return": "-EINVAL"
    }
},
{
    "kretprobe:CX18_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "atomic_read(&cx->tot_capturing)": "== 0",
            "s->type": "== CX18_ENC_STREAM_TYPE_MPG",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kretprobe:set_bit": {
        "description": "Set bit CX18_F_S_STOPPING in s->s_flags",
        "pre": {
            "s->s_flags": "!= null"
        }
    },
    "kretprobe:cx18_vapi": {
        "description": "Call cx18_vapi function",
        "pre": {
            "cx": "!= null",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kretprobe:cx18_stop_v4l2_encode_stream": {
        "description": "Stop v4l2 encode stream",
        "pre": {
            "s": "!= null",
            "gop_end": "!= null"
        }
    }
},
{
    "kprobe:CX18_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "atomic_read(&cx->tot_capturing)": "== 0",
            "s->type": "== CX18_ENC_STREAM_TYPE_MPG",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the CX18_F_S_STOPPING flag",
        "pre": {
            "s->s_flags": "!= null"
        }
    },
    "kprobe:cx18_vapi": {
        "description": "Call cx18_vapi function",
        "pre": {
            "cx": "!= null",
            "CX18_CPU_CAPTURE_STOP": "!= null",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:cX18_stop_v4l2_encode_stream": {
        "description": "Stop V4L2 encode stream",
        "pre": {
            "s": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:cx18_stream_enabled": {
        "description": "Check if the stream is enabled",
        "pre": {
            "s": "!= null"
        }
    }
},
{
    "kretprobe:cx88_risc_buffer": {
        "description": "Calculate and allocate RISC buffer for cx88 device.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "top_offset": ">=0",
            "bottom_offset": ">=0",
            "bpl": ">=0",
            "padding": ">=0",
            "lines": ">=0"
        },
        "post": {
            "instructions": ">=0",
            "risc->size": ">=0",
            "risc->dma": "=0",
            "risc->cpu": "!=null"
        }
    }
},
{
    "kprobe:cx88_risc_buffer": {
        "description": "Function to estimate risc mem",
        "pre": {
            "pci": "!=null",
            "risc.size": ">0",
            "risc.dma": "is an integer",
            "risc.cpu": "valid memory address",
            "sglist": "!=null",
            "top_offset": "!=null",
            "bottom_offset": "!=null",
            "bpl": "!=null",
            "padding": "!=null",
            "lines": "!=null"
        }
    }
},
{
    "kretprobe:cx88_risc_databuffer": {
        "description": "Estimate RISC memory usage for cx88 driver.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": ">=0",
            "lines": ">=0",
            "lpi": ">=0"
        },
        "post": {
            "instructions": ">=0",
            "risc->size": "instructions * 8",
            "risc->dma": "0",
            "risc->cpu": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": "!=null",
            "lines": "!=null",
            "lpi": "!=null"
        }
    }
},
{
    "kretprobe:.fifo_start = 0x185400": {
        "description": "The same as audio IN",
        "pre": {
            ".fifo_start": "== 0x185400"
        }
    }
},
{
    "kprobe:.fifo_start = 0x185400": {
        "description": "Same as audio IN",
        "pre": {
            ".fifo_start": "==0x185400"
        }
    }
},







{
    "kprobe:cx_andor": {
        "description": "Set the scale and filters for the cx88 video device.",
        "pre": {
            "core": "!=null",
            "width": "!=null",
            "height": "!=null",
            "field": "in [V4L2_FIELD_ANY, V4L2_FIELD_NONE, V4L2_FIELD_TOP, V4L2_FIELD_BOTTOM, V4L2_FIELD_INTERLACED, V4L2_FIELD_SEQ_TB, V4L2_FIELD_SEQ_BT, V4L2_FIELD_ALTERNATE, V4L2_FIELD_INTERLACED_TB, V4L2_FIELD_INTERLACED_BT, V4L2_FIELD_ALTERNATE_TB, V4L2_FIELD_ALTERNATE_BT]",
            "swidth": "norm_swidth(core->tvnorm)",
            "sheight": "norm_maxh(core->tvnorm)",
            "value": "!=null",
            "norm": "v4l2_norm_to_name(core->tvnorm)",
            "height": "2 if !V4L2_FIELD_HAS_BOTH(field) else height",
            "value": "(width - norm_hdelay(core->tvnorm)) * swidth & 0x3fe",
            "value": "(swidth * 4096 / width) - 4096",
            "width": "width",
            "value": "(0x10000 - (sheight - 512) * (height - 512) / 512) & 0x1fff",
            "sheight": "sheight",
            "value": "0",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value"
        }
    }
},


{
    "kretprobe:cx88_vdev_init": {
        "description": "Initialize cx88 video device",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null",
            "core->v4l2_dev": "!=null",
            "pci->dev": "!=null",
            "video_device_release_empty": "!=null",
            "core->lock": "!=null",
            "core->name": "!=null",
            "type": "!=null",
            "core->board.name": "!=null"
        }
    }
},
{
    "kprobe:vfd->v4l2_dev = &core->v4l2_dev;vfd->dev_parent = &pci->dev;vfd->release = video_device_release_empty;vfd->lock = &core->lock;snprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", core->name, type, core->board.name);}EXPORT_SYMBOL(cx88_vdev_init": {
        "description": "Initialize the video device structure for cx88 driver.",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null",
            "vfd->v4l2_dev": "==&core->v4l2_dev",
            "vfd->dev_parent": "==&pci->dev",
            "vfd->release": "==video_device_release_empty",
            "vfd->lock": "==&core->lock",
            "snprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", core->name, type, core->board.name);": "executes successfully"
        }
    }
},




{
    "kretprobe:cx8802_register_driver": {
        "description": "Register a cx8802 driver",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kretprobe:cx8802_unregister_driver": {
        "description": "Unregister the cx8802 driver",
        "pre": {
            "d->type_id": "!= drv->type_id",
            "err": "== 0"
        }
    }
},
{
    "kprobe:cx8802_unregister_driver": {
        "description": "Unregister the cx8802 driver",
        "pre": {
            "d->type_id": "!= drv->type_id",
            "err": "== 0"
        }
    }
},


{
    "kretprobe:break;}/* If software stereo detection is not supported...": {
        "description": "This function checks if software stereo detection is supported.",
        "pre": {
            "core": "!=null",
            "t": "!=null",
            "core->astat": "!=reg",
            "reg": "!=null",
            "m[mode]": "!=null",
            "p[pilot]": "!=null",
            "aud_ctl_names[cx_read(AUD_CTL) & 63]": "!=null",
            "t->capability": "& (V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_SAP | V4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2)",
            "t->rxsubchans": "= UNSET",
            "t->audmode": "= V4L2_TUNER_MODE_MONO",
            "mode": "= 0, 1, 2, 3",
            "core->tvaudio": "= WW_BTSC, WW_BG, WW_DK, WW_M, WW_EIAJ",
            "core->use_nicam": "= false",
            "t->rxsubchans": "= cx88_dsp_detect_stereo_sap(core)"
        }
    }
},



{
    "kretprobe:memset": {
        "description": "Set the memory block starting at &t with 0, for a size of sizeof(t).",
        "pre": {
            "&t": "!=null",
            "sizeof(t)": ">0",
            "core->audiomode_manual": "==UNSET"
        },
        "post": {
            "core->tvaudio": "in [WW_BG, WW_DK, WW_M, WW_I, WW_L]",
            "core->use_nicam": "==true"
        }
    },
    "kretprobe:cx88_get_stereo": {
        "description": "Get the stereo information for the given core and store it in &t.",
        "pre": {
            "core": "!=null",
            "&t": "!=null"
        },
        "post": {
            "core->tvaudio": "in [WW_BG, WW_DK, WW_M, WW_I, WW_L]",
            "core->use_nicam": "==true"
        }
    }
},
{
    "memset": {
        "pre": {
            "dest": "!=null",
            "value": "0",
            "count": "sizeof(t)"
        }
    },
    "cx88_get_stereo": {
        "pre": {
            "core": "!=null",
            "t": "!=null"
        }
    },
    "core->audiomode_manual": {
        "pre": {
            "core": "!=null",
            "core->audiomode_manual": "!=UNSET"
        }
    }
},
{
    "kretprobe:cx_write": {
        "description": "Write a value to the map represented by MO_DDSCFG_IO.",
        "pre": {
            "MO_DDSCFG_IO": "!=null",
            "value": "==0x5"
        }
    }
},
{
    "kprobe:cx_write": {
        "description": "Write a value to the map represented by MO_DDSCFG_IO.",
        "pre": {
            "MO_DDSCFG_IO": "!=null",
            "value": "0x5"
        }
    }
},


{
    "kretprobe:usleep_range": {
        "description": "Sleep for a specified range of microseconds.",
        "pre": {
            "usec_min": "== 10000",
            "usec_max": "== 20000"
        }
    },
    "kretprobe:cx88_set_tvaudio": {
        "description": "Set the TV audio for the cx88 core.",
        "pre": {
            "core": "!= null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(cx88_set_freq": {
        "description": "Exported symbol for cx88_set_freq function.",
        "pre": {}
    }
},
{
    "kprobe:usleep_range": {
        "description": "Sleep for a specified range of microseconds.",
        "pre": {
            "min": "10000",
            "max": "20000"
        }
    },
    "kprobe:cx88_set_tvaudio": {
        "description": "Set the TV audio for the cx88 core.",
        "pre": {
            "core": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:EXPORT_SYMBOL(cx88_set_freq": {
        "description": "Export the symbol cx88_set_freq.",
        "pre": {}
    }
},
{
    "kretprobe:cx88_dsp_detect_stereo_sap": {
        "description": "If audio RDS fifo is disabled, we can't read the samples",
        "pre": {
            "core": "!=null",
            "samples": "!=null",
            "N": "!=null",
            "ret": "!=null",
            "cx_read(MO_AUD_DMACNTRL) & 0x04": "==0",
            "cx_read(AUD_CTL) & EN_FMRADIO_EN_RDS": "==0",
            "wait_time": ">=500"
        }
    }
},



{
    "kretprobe:ivtv_stop_v4l2_encode_stream": {
        "description": "Stop the capture of the IVTV V4L2 encode stream.",
        "pre": {
            "s->type": "== IVTV_DEC_STREAM_TYPE_VOUT",
            "atomic_read(&itv->capturing)": "== 0"
        }
    }
},
{
    "kprobe:IVTV_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "s->type": "== IVTV_DEC_STREAM_TYPE_VOUT",
            "atomic_read(&itv->capturing)": "== 0"
        }
    }
},

{
    "kprobe:ivtv_claim_stream": {
        "description": "Claim a stream in the ivtv driver",
        "pre": {
            "s->fh": "== &id->fh"
        }
    }
},



{
    "kprobe:ivtv_msleep_timeout": {
        "description": "Sleep for a specified number of milliseconds with a timeout.",
        "pre": {
            "msecs": ">=0",
            "intr": "is an integer"
        }
    }
},
{
    "kretprobe:ivtv_setup_pci": {
        "description": "PCI Device Setup",
        "pre": {
            "itv": "!=null",
            "pdev": "!=null",
            "pci_id": "!=null",
            "retval": "in [-EIO, -ENXIO]"
        },
        "post": {
            "retval": {
                "==": "-EIO",
                "goto": "free_worker"
            },
            "retval": {
                "==": "-ENXIO",
                "goto": "free_mem"
            }
        }
    }
},


{
    "kprobe:request_module": {
        "description": "Initialize ivtv-alsa for this instance of the cx18 device",
        "pre": {
            "module": "=='ivtv-alsa'"
        }
    }
},
{
    "kretprobe:ivtv_open_id": {
        "description": "Open the ivtv device with the given id.",
        "pre": {
            "itv": "!=null",
            "fh": "!=null",
            "fw_retry_count": ">0",
            "video_input": "!=null",
            "fh.itv": "==itv",
            "fh.type": "==IVTV_ENC_STREAM_TYPE_MPG",
            "test_bit(IVTV_F_I_FAILED, &itv->i_flags)": "==0",
            "test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags)": "==0"
        }
    }
},
{
    "kprobe:struct_ivtv_open_id_fh": {
        "description": "Function struct ivtv_open_id fh",
        "pre": {
            "fh.itv": "!=null",
            "fh.type": "IVTV_ENC_STREAM_TYPE_MPG",
            "test_bit(IVTV_F_I_FAILED, &itv->i_flags)": "false",
            "test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags)": "false",
            "fw_retry_count": "> 0"
        }
    }
},
{
    "kretprobe:cx25821_set_gpiopin_direction": {
        "description": "Check for valid pinNumber",
        "pre": {
            "dev": "!=null",
            "pin_number": ">= 0",
            "pin_logic_value": "!=null"
        }
    }
},
{
    "kprobe:cx25821_set_gpiopin_direction": {
        "description": "Check for valid pinNumber",
        "pre": {
            "dev": "!=null",
            "pin_number": ">= 0",
            "pin_logic_value": "!=null"
        }
    }
},

{
    "kprobe:cx25821_sram_channel_setup_audio": {
        "description": "Setup audio for cx25821 device",
        "pre": {
            "dev": "!=null",
            "ch": {
                "cmds_start": "==0",
                "ptr1_reg": "!=null",
                "ptr2_reg": "!=null",
                "cnt2_reg": "!=null",
                "cnt1_reg": "!=null"
            },
            "bpl": "!=null",
            "risc": "!=null"
        }
    }
},





{
    "kprobe:cx25821_risc_databuffer_audio": {
        "description": "Jump and write need an extra dword",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": "!=null",
            "lines": "!=null",
            "lpi": "!=null"
        }
    }
},
{
    "kretprobe:0,   /* n_slots */": {
        "description": "altera_ci_init(struct altera_ci_config  config, int ci_nr)",
        "pre": {
            "config": "!=null",
            "ci_nr": "int",
            "state": "!=null",
            "temp_int": "!=null",
            "inter": "!=null",
            "ret": "int",
            "store": "u8",
            "state->internal": "!=null",
            "state->nr": "int",
            "state->ca.owner": "THIS_MODULE",
            "state->ca.read_attribute_mem": "altera_ci_read_attribute_mem",
            "state->ca.write_attribute_mem": "altera_ci_write_attribute_mem",
            "state->ca.read_cam_control": "altera_ci_read_cam_ctl",
            "state->ca.write_cam_control": "altera_ci_write_cam_ctl",
            "state->ca.slot_reset": "altera_ci_slot_reset",
            "state->ca.slot_shutdown": "altera_ci_slot_shutdown",
            "state->ca.slot_ts_enable": "altera_ci_slot_ts_ctl",
            "state->ca.poll_slot_status": "altera_poll_ci_slot_status",
            "state->ca.data": "!=null",
            "dvb_ca_en50221_init(config->adapter,   &state->ca,     flags": "ret"
        }
    }
},
{
    "kprobe:0,   /* n_slots `": {
        "description": "Initialize the altera_ci_state structure for the given configuration and ci_nr.",
        "pre": {
            "config": "!=null",
            "ci_nr": "int",
            "state": "kzalloc(sizeof(struct altera_ci_state), GFP_KERNEL)",
            "temp_int": "find_inode(config->dev)",
            "inter": "NULL or kzalloc(sizeof(struct fpga_internal), GFP_KERNEL)",
            "ret": "int",
            "store": "u8",
            "temp_int != NULL": "bool",
            "inter->cis_used++": "bool",
            "inter->fpga_rw = config->fpga_rw": "bool",
            "mutex_init(&inter->fpga_mutex)": "void",
            "inter->strt_wrk = 1": "void",
            "state->internal = inter": "void",
            "state->nr = ci_nr - 1": "void",
            "state->ca.owner = THIS_MODULE": "void",
            "state->ca.read_attribute_mem = altera_ci_read_attribute_mem": "void",
            "state->ca.write_attribute_mem = altera_ci_write_attribute_mem": "void",
            "state->ca.read_cam_control = altera_ci_read_cam_ctl": "void",
            "state->ca.write_cam_control = altera_ci_write_cam_ctl": "void",
            "state->ca.slot_reset = altera_ci_slot_reset": "void",
            "state->ca.slot_shutdown = altera_ci_slot_shutdown": "void",
            "state->ca.slot_ts_enable = altera_ci_slot_ts_ctl": "void",
            "state->ca.poll_slot_status = altera_poll_ci_slot_status": "void",
            "state->ca.data = state": "void",
            "ret = dvb_ca_en50221_init(config->adapter, &state->ca, flags)": "int"
        }
    }
},
{
    "kretprobe:dst_probe": {
        "description": "Check if the ASIC is present",
        "pre": {
            "state": "!=null",
            "dvb_adapter": "!=null",
            "dst_probe(state)": "< 0"
        }
    }
},




{
    "kprobe:bt878_risc_program": {
        "description": "Start the bt878 device with the given control register, op_sync_orin, and irq_err_ignore values.",
        "pre": {
            "bt": "!=null",
            "controlreg": "&= ~0x1f",
            "controlreg": "|= 0x1b",
            "btwrite(bt->risc_dma, BT878_ARISC_START)": "!=null",
            "int_mask": "in [6, 2, 8, 4, 0]"
        }
    }
},

{
    "sof_ipc3_do_rx_work": {
        "description": "Function for handling received IPC messages",
        "pre": {
            "cmd": "!=null",
            "cmd": "in [0, SOF_GLB_TYPE_MASK]"
        }
    }
},
{
    "kretprobe:ddbridge_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ddbridge_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},

{
    "kprobe:case 1:core_dbg": {
        "description": "Setting GPIO to static value",
        "pre": {
            "dev": "!=null",
            "bit_no": "!=null",
            "value": "!=null"
        }
    }
},




{
    "kretprobe:saa7134_buffer_queue": {
        "description": "Queue a buffer for DMA transfer.",
        "pre": {
            "dev": "!=null",
            "q": "!=null",
            "buf": "!=null",
            "dev->pci": "!=null",
            "q->dma": "!=null",
            "buf->size": ">0",
            "buf->data": "!=null",
            "buf->dma": "!=null",
            "buf->dma->cpu": "!=null",
            "buf->dma->dma_addr": "!=null",
            "buf->dma->size": ">0",
            "buf->dma->cpu->pci": "!=null",
            "buf->dma->cpu->pt": "!=null",
            "buf->dma->cpu->pt->cpu": "!=null",
            "buf->dma->cpu->pt->dma": "!=null",
            "buf->dma->cpu->pt->size": ">0",
            "buf->dma->cpu->pt->cpu->pci": "!=null",
            "buf->dma->cpu->pt->cpu->pt": "!=null",
            "buf->dma->cpu->pt->cpu->pt->cpu": "!=null",
            "buf->dma->cpu->pt->cpu->pt->dma": "!=null",
            "buf->dma->cpu->pt->cpu->pt->size": ">0"
        }
    }
},




{
    "kprobe:if (0 != card(dev).gpiomask)": {
        "description": "Check if the gpiomask of the card associated with the given dev is not equal to zero.",
        "pre": {
            "card(dev)": {
                "gpiomask": "!=0"
            }
        }
    }
},




{
    "kretprobe:snd_tea575x_s_hw_freq_seek": {
        "description": "Seek hardware frequency in the snd_tea575x driver.",
        "pre": {
            "tea->cannot_read_data": "==0",
            "a->tuner": "==0",
            "a->wrap_around": "==0",
            "file->f_flags & O_NONBLOCK": "==0",
            "a->rangelow || a->rangehigh": "==1",
            "bands[i].rangelow == a->rangelow && bands[i].rangehigh == a->rangehigh": "exists i such that (i == BAND_FM && tea->tea5759) || (i == BAND_FM_JAPAN && !tea->tea5759) || (i == BAND_AM && !tea->has_am)"
        }
    }
},
{
    "kprobe:if (i != tea->band)": {
        "description": "Check if the value of i is not equal to the value of tea->band.",
        "pre": {
            "i": "!=null",
            "tea->band": "!=null"
        }
    }
},


{
    "kretprobe:snd_tea575x_init": {
        "description": "Initialize snd_tea575x structure",
        "pre": {
            "tea->cannot_read_data": "true",
            "v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK)": "called",
            "tea->cannot_mute": "false"
        }
    }
},
{
    "kprobe:snd_tea575x_init": {
        "description": "Initialize the snd_tea575x structure.",
        "pre": {
            "tea": {
                "cannot_read_data": true,
                "cannot_mute": false
            }
        }
    }
},
{
    "kretprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation.",
        "pre": {
            "ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation.",
        "pre": {
            "ev": "!=null",
            "*ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        },
        "post": {
            "return": "in [0, -ENOBUFS]",
            "*ev": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation.",
        "pre": {
            "ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_encode_scancode": {
        "description": "Encode a scancode as raw events",
        "pre": {
            "protocol": "!=null",
            "scancode": "!=null",
            "events": "!=null",
            "max": "!=null"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "<=max"
        }
    }
},
{
    "kprobe:ir_raw_encode_scancode": {
        "description": "Encode a scancode as raw events",
        "pre": {
            "protocol": "!=null",
            "scancode": "!=null",
            "events": "!=null",
            "max": "!=null"
        },
        "post": {
            "return": ">=0",
            "return": "!= -ENOBUFS",
            "return": "!= -EINVAL"
        }
    }
},
{
    "kretprobe:ir_raw_encode_carrier": {
        "description": "Get carrier used for protocol",
        "pre": {
            "protocol": "!=null",
            "protocol": "in [RC_PROTO_1, RC_PROTO_2, RC_PROTO_3, ...]",
            "return_value": ">=0",
            "return_value": "!=EINVAL"
        }
    }
},
{
    "kprobe:ir_raw_encode_carrier": {
        "description": "Get carrier used for protocol",
        "pre": {
            "protocol": "!=null",
            "protocol": "in [RC_PROTO_1, RC_PROTO_2, RC_PROTO_3, ...]",
            "return_value": ">=0",
            "return_value": "<=MAX_CARRIER_VALUE",
            "return_value": "!=EINVAL"
        }
    }
},












{
    "kretprobe:dprintk": {
        "description": "Prints a debug message if reading from EEPROM fails.",
        "pre": {
            "proposed_mac": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:eth_zero_addr": {
        "description": "Sets the proposed MAC address to zero if reading from EEPROM fails.",
        "pre": {
            "proposed_mac": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:getmac_tt": {
        "description": "Retrieves the MAC address from the EEPROM and stores it in decodedMAC.",
        "pre": {
            "decodedMAC": "!=null",
            "encodedMAC": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},

{
    "kretprobe:flexcop_pid_feed_control": {
        "description": "Toggle complete-TS-streaming when certain conditions are met.",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "is boolean",
            "dvbdmxfeed->index": ">= max_pid_filter",
            "fc->extra_feedcount": "+= onoff ? 1 : -1",
            "max_pid_filter": "== 6",
            "fc->skip_6_hw_pid_filter": "== 0",
            "fc->has_32_hw_pid_filter": "== 1",
            "fc->feedcount": "+= onoff ? 1 : -1"
        }
    }
},
{
    "kprobe:flexcop_pid_feed_control": {
        "description": "Toggle complete-TS-streaming when certain conditions are met.",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "in [0, 1]",
            "fc->skip_6_hw_pid_filter": "!=null",
            "fc->has_32_hw_pid_filter": "!=null",
            "max_pid_filter": "!=null",
            "dvbdmxfeed->index": ">= max_pid_filter",
            "fc->extra_feedcount": "+= onoff ? 1 : -1",
            "max_pid_filter": "-= 6",
            "fc->skip_6_hw_pid_filter": "-= 6",
            "max_pid_filter": "+= 32",
            "fc->has_32_hw_pid_filter": "+= 32",
            "fc->feedcount": "+= onoff ? 1 : -1"
        }
    }
},
{
    "kretprobe:flexcop_sram_set_dest": {
        "description": "Sets the destination of the flexcop sram.",
        "pre": {
            "fc": "!=null",
            "dest": "!=null",
            "target": "!=null",
            "v": "!=null",
            "v.sram_dest_reg_714.NET_Dest": "if dest & FC_SRAM_DEST_NET",
            "v.sram_dest_reg_714.CAI_Dest": "if dest & FC_SRAM_DEST_CAI",
            "v.sram_dest_reg_714.CAO_Dest": "if dest & FC_SRAM_DEST_CAO",
            "v.sram_dest_reg_714.MEDIA_Dest": "if dest & FC_SRAM_DEST_MEDIA",
            "fc->rev": "!= FLEXCOP_III || target != FC_SRAM_DEST_TARGET_FC3_CA",
            "err": "target == FC_SRAM_DEST_TARGET_FC3_CA",
            "return": "0"
        }
    }
},
{
    "kprobe:return 0;}EXPORT_SYMBOL(flexcop_sram_set_dest": {
        "description": "Sets the destination of the flexcop sram.",
        "pre": {
            "fc": "!=null",
            "dest": "!=null",
            "target": "!=null",
            "v": "!=null",
            "v.sram_dest_reg_714.NET_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.CAI_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.CAO_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.MEDIA_Dest": "in [0, 1]"
        }
    }
},
{
    "kretprobe:flexcop_i2c_request": {
        "description": "Perform an I2C request using the FlexCop adapter.",
        "pre": {
            "i2c->no_base_addr": true,
            "len": 0,
            "op": "FC_WRITE"
        }
    }
},
{
    "kprobe:flexcop_i2c_request": {
        "description": "Perform an I2C request using the FlexCop adapter.",
        "pre": {
            "i2c->no_base_addr": "true",
            "len": "0",
            "op": "FC_WRITE"
        }
    }
},
{
    "kretprobe:flexcop_i2c_init": {
        "description": "Initialize the I2C interface of the flexcop device.",
        "pre": {
            "fc": "!=null",
            "ret": "==0"
        }
    }
},
{
    "kprobe:flexcop_i2c_init": {
        "description": "Initialize the I2C interface of the flexcop device.",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:vb2_buffer_in_use": {
        "description": "Check if the buffer is in use by multiple users.",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "vb->num_planes": ">0",
            "vb->planes[plane].mem_priv": "!=null",
            "call_memop(vb, num_user mem_priv)": ">1"
        }
    }
},
{
    "kprobe:vb2_buffer_in_use": {
        "description": "Check if the buffer is in use by multiple users.",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "vb->num_planes": ">0",
            "vb->planes[0].mem_priv": "!=null",
            "call_memop(vb, num_user mem_priv)": ">1"
        }
    }
},
{
    "kretprobe:__verify_mmap_ops": {
        "description": "Verify the memory operations for mmap",
        "pre": {
            "q": "!=null",
            "memory": "==VB2_MEMORY_MMAP"
        }
    }
},
{
    "kprobe:__verify_mmap_ops": {
        "description": "Verify the memory operations for mmap.",
        "pre": {
            "q": "!=null",
            "memory": "==VB2_MEMORY_MMAP"
        }
    }
},


{
    "kretprobe:dvb_frontend_detach": {
        "description": "Detach the DVB frontend and remove the list entry.",
        "pre": {
            "fe->dvb.frontend": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:dvb_frontend_detach": {
        "description": "Detach the DVB frontend and remove the list entry.",
        "pre": {
            "fe->dvb.frontend": "!=null"
        }
    }
},
{
    "kretprobe:vb2_querybuf": {
        "description": "Query video buffer information",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:vb2_querybuf": {
        "description": "Query video buffer information",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:vb2_create_framevec": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "length": "!=null",
            "write": "!=null"
        }
    }
},
{
    "kprobe:vb2_create_framevec": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "length": "!=null",
            "write": "!=null"
        }
    }
},
{
    "kretprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns and free the passed vector.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:get_vaddr_frames": {
        "description": "Map virtual addresses to page frame numbers or page pointers.",
        "pre": {
            "start": "!=null",
            "nr_frames": ">= 0",
            "write": "in [true, false]",
            "vec": "!=null"
        }
    }
},
{
    "kprobe:get_vaddr_frames": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "nr_frames": "!=null",
            "write": "!=null",
            "vec": "!=null",
            "vec->entries": ">=nr_frames"
        }
    }
},
{
    "kretprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them and invalidate the frame vector.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pages": {
        "description": "Convert frame vector to contain page pointers",
        "pre": {
            "vec": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:frame_vector_to_pages": {
        "description": "Convert frame vector to contain page pointers.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pfns": {
        "description": "convert frame vector to contain pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_to_pfns": {
        "description": "convert frame vector to contain pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_create": {
        "description": "Allocate and initialize structure for pinned pfns",
        "pre": {
            "nr_frames": ">= 0"
        }
    }
},
{
    "kprobe:frame_vector_create": {
        "description": "Allocate and initialize structure for pinned pfns.",
        "pre": {
            "nr_frames": ">= 0"
        }
    }
},
{
    "kretprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector",
        "pre": {
            "vec": "!=null"
        }
    }
},


{
    "kretprobe:dibusb_dib3000mc_tuner_attach": {
        "description": "Attach DIB3000MC tuner to DVB USB adapter",
        "pre": {
            "le16_to_cpu(adap->dev->udev->descriptor.idVendor)": "USB_VID_LITEON",
            "le16_to_cpu(adap->dev->udev->descriptor.idProduct)": "USB_PID_LITEON_DVB_T_WARM",
            "a": "0x00",
            "a": "0x80",
            "desc": "2",
            "desc & 0x80": "true"
        }
    }
},
{
    "kprobe:dvb_attach": {
        "description": "Attach a DVB device to the adapter.",
        "pre": {
            "dvb_pll_attach": "!=null",
            "adap->fe_adap[0].fe": "!=null",
            "0x60": "!=null",
            "tun_i2c": "!=null",
            "DVB_PLL_ENV57H1XD5": "!=null"
        }
    }
},
{
    "kretprobe:usb_cypress_load_firmware": {
        "description": "Load firmware to a Cypress USB device.",
        "pre": {
            "udev": "!=null",
            "fw": "!=null",
            "type": "int",
            "hx": "!=null",
            "buf": "!=null",
            "ret": "int",
            "pos": "int",
            "cpu_cs_register": "u16",
            "buf_size": "sizeof(hx)",
            "buf_allocation": "!null",
            "stop_CPU": "true"
        },
        "post": {
            "ret": "==1"
        }
    }
},
{
    "kprobe:usb_cypress_load_firmware": {
        "description": "Load firmware to a Cypress USB device.",
        "pre": {
            "udev": "!=null",
            "fw": "!=null",
            "type": "int"
        }
    },
    "kprobe:usb_cypress_writemem": {
        "description": "Write data to the Cypress USB device memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "int",
            "buf": "!=null",
            "buf_size": "int"
        }
    },
    "kprobe:dvb_usb_get_hexline": {
        "description": "Get a line of hexadecimal data from a DVB USB device.",
        "pre": {
            "fw": "!=null",
            "hx": "!=null",
            "pos": "int"
        }
    }
},
{
    "kretprobe:usb_cypress_writemem": {
        "description": "Write data to a Cypress USB device's memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "!=null",
            "buf": "!=null",
            "1": "!=null",
            "usb_cypress_writemem(udev, cpu_cs_register, buf, 1)": "!=1"
        }
    }
},
{
    "kprobe:usb_cypress_writemem": {
        "description": "Write data to a Cypress USB device's memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "!=null",
            "buf": {
                "type": "array",
                "length": 1,
                "values": [0]
            },
            "1": "==1"
        }
    }
},
{
    "kretprobe:for (i = 0; i < d->props.rc.legacy.rc_map_size; i++)if (rc5_custom(&keymap[i]) == keybuf[1] &&rc5_data(&keymap[i]) == keybuf[3])": {
        "description": "Check if the conditions for the given function are satisfied.",
        "pre": {
            "d": "!=null",
            "keybuf": "!=null",
            "event": "!=null",
            "state": "!=null",
            "i": ">=0",
            "i": "< d->props.rc.legacy.rc_map_size",
            "rc5_custom(&keymap[i])": "== keybuf[1]",
            "rc5_data(&keymap[i])": "== keybuf[3]"
        }
    }
},
{
    "kprobe:for": {
        "description": "Loop through the rc_map_table and check if rc5_custom(&keymap[i]) is equal to keybuf[1] and rc5_data(&keymap[i]) is equal to keybuf[3].",
        "pre": {
            "d": "!=null",
            "keybuf": "array of size 5",
            "event": "!=null",
            "state": "!=null",
            "i": ">=0 and < d->props.rc.legacy.rc_map_size",
            "keymap": "!=null",
            "keymap[i]": "!=null",
            "keybuf[1]": "!=null",
            "keybuf[3]": "!=null",
            "rc5_custom(&keymap[i])": "== keybuf[1]",
            "rc5_data(&keymap[i])": "== keybuf[3]"
        }
    }
},
{
    "kretprobe:dvb_usb_generic_rw": {
        "description": "Reads and writes data using the DVB USB generic interface.",
        "pre": {
            "ret": "== 0",
            "rbuf": "!= null",
            "rlen": "!= 0"
        }
    }
},
{
    "if (!ret && rbuf && rlen)": {
        "description": "Check the conditions for the given function",
        "pre": {
            "d": "!=null",
            "wbuf": "!=null",
            "wlen": "!=0"
        },
        "post": {
            "ret": "false",
            "rbuf": "!=null",
            "rlen": "!=0"
        }
    }
},





{
    "kprobe:;} else if (ret == RECONNECTS_USB)": {
        "description": "Condition for the function `;} else if (ret == RECONNECTS_USB)`",
        "pre": {
            "intf": "any",
            "id": "any"
        }
    }
},

{
    "kprobe:if (d->rc_polling_active)cancel_delayed_work_sync(&d->rc_query_work);for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--)": {
        "description": "Stop remote controller poll",
        "pre": {
            "d": {
                "rc_polling_active": true
            },
            "i": ">= 0"
        }
    }
},
{
    "kretprobe:usb_urb_submitv2": {
        "description": "Submit a USB urb for streaming.",
        "pre": {
            "d": "is of type struct dvb_usb_device",
            "d->adapter[i].stream": "!=null",
            "d->props->streaming_ctrl": "exists",
            "fe": "is of type struct dvb_frontend",
            "d->adapter[i].active_fe": "!= -1",
            "d->adapter[i].dvb_adap.priv": "exists",
            "d->adapter[i].fe[active_fe]": "exists",
            "dvb_frontend_resume(fe)": "returns a value"
        }
    }
},
{
    "kprobe:usb_urb_submitv2": {
        "description": "Submit a USB urb for streaming.",
        "pre": {
            "d": {
                "adapter": {
                    "i": {
                        "stream": "!=null"
                    }
                },
                "props": {
                    "streaming_ctrl": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:gspca_expo_autogain": {
        "description": "Function for automatic gain adjustment in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_knee": "!=null",
            "exposure_knee": "!=null",
            "v4l2_ctrl_g_ctrl(gspca_dev->autogain)": "!=0"
        }
    }
},
{
    "kprobe:gspca_expo_autogain": {
        "description": "Function for automatic gain adjustment in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_knee": "!=null",
            "exposure_knee": "!=null",
            "v4l2_ctrl_g_ctrl(gspca_dev->autogain)": "!=0"
        }
    }
},
{
    "kretprobe:gspca_coarse_grained_expo_autogain": {
        "description": "Autogain function for gspca_dev",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_low": "!=null",
            "gain_high": "!=null",
            "gain": "!=null",
            "orig_gain": "!=null",
            "exposure": "!=null",
            "orig_exposure": "!=null",
            "steps": "!=null",
            "retval": "!=null"
        },
        "post": {
            "retval": "==0",
            "gain": "==orig_gain",
            "exposure": "==orig_exposure",
            "steps": "==(desired_avg_lum - avg_lum) / deadzone",
            "gain_low": "==(gspca_dev->gain->maximum - gspca_dev->gain->minimum) * 5 / 2 + gspca_dev->gain->minimum",
            "gain_high": "==(gspca_dev->gain->maximum - gspca_dev->gain->minimum) * 5 / 4 + gspca_dev->gain->minimum"
        }
    }
},
{
    "kprobe:gspca_coarse_grained_expo_autogain": {
        "description": "Function for coarse-grained exposure autogain in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null"
        }
    }
},

{
    "kprobe:gspca_frame_add": {
        "description": "Add a frame to the gspca device.",
        "pre": {
            "gspca_dev": "!=null",
            "packet_type": "in [GSPCA_PACKET_TYPE_1, GSPCA_PACKET_TYPE_2, GSPCA_PACKET_TYPE_3, GSPCA_PACKET_TYPE_4]",
            "data": "!=null",
            "len": ">=0",
            "buf": "==null"
        }
    }
},
{
    "kretprobe:gspca_dev_probe2": {
        "description": "Probe the gspca_dev structure for the given usb_interface, usb_device_id, sd_desc, dev_size, and module.",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "sd_desc": "!=null",
            "dev_size": "< sizeof *gspca_dev",
            "module": "!=null"
        }
    }
},
{
    "kprobe:gspca_dev_probe2": {
        "description": "Probe the gspca_dev structure for a USB device.",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "sd_desc": "!=null",
            "dev_size": "< sizeof *gspca_dev",
            "module": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_device_put": {
        "description": "Disconnects the gspca device from the v4l2 device.",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "gspca_dev->v4l2_dev": "!=null",
            "gspca_dev->present": "false",
            "gspca_dev->usb_lock": "unlocked"
        },
        "post": {
            "gspca_dev->present": "false",
            "gspca_dev->input_dev": "null",
            "gspca_dev->v4l2_dev": "disconnected",
            "gspca_dev->vdev": "unregistered",
            "gspca_dev->usb_lock": "unlocked"
        }
    }
},
{
    "kprobe:v4l2_device_put": {
        "description": "Release the reference to the v4l2_device structure.",
        "pre": {
            "gspca_dev": "!=null",
            "gspca_dev->v4l2_dev": "!=null"
        }
    }
},
{
    "kretprobe:gspca_suspend": {
        "description": "Suspends the gspca device.",
        "pre": {
            "intf": "!=null",
            "message": "!=null",
            "gspca_dev": "=usb_get_intfdata(intf)",
            "gspca_dev->queue": "vb2_start_streaming_called(&gspca_dev->queue)",
            "gspca_dev->usb_lock": "mutex_lock(&gspca_dev->usb_lock)",
            "gspca_dev->frozen": "=1"
        }
    }
},
{
    "kprobe:gspca_suspend": {
        "description": "Suspends the gspca device.",
        "pre": {
            "intf": "!=null",
            "message": "!=null"
        }
    }
},
{
    "kretprobe:gspca_resume": {
        "description": "Resume function for gspca driver",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "streaming": "int",
            "ret": "int",
            "gspca_dev->usb_lock": "mutex",
            "gspca_dev->frozen": "int",
            "gspca_dev->usb_err": "int",
            "gspca_dev->sd_desc": "!=null"
        }
    }
},
{
    "kprobe:gspca_resume": {
        "description": "Resume function for gspca driver.",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "streaming": "in [0, 1]",
            "ret": "int",
            "mutex_unlock": "called"
        }
    }
},
{
    "kretprobe:ttusbdecfe_dvbs_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ttusbdecfe_dvbs_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null"
        }
    }
},
{
    "kretprobe:mt2060_readreg": {
        "description": "Read a register from the MT2060 device.",
        "pre": {
            "priv": "!=null",
            "REG_PART_REV": "!=null",
            "id": "!=null",
            "mt2060_readreg(priv, REG_PART_REV, &id)": "!=0"
        }
    }
},
{
    "kprobe:mt2060_readreg": {
        "description": "Read a register from the MT2060 tuner.",
        "pre": {
            "priv": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:fc0012_readreg": {
        "description": "Reads a register from the fc0012 tuner chip.",
        "pre": {
            "priv": "!=null",
            "i2c": "!=null",
            "cfg": "!=null",
            "fe": "!=null",
            "chip_id": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:fc0012_readreg": {
        "description": "Read a register from the fc0012 tuner.",
        "pre": {
            "priv": "!=null",
            "0x00": "is an integer",
            "&chip_id": "!=null"
        }
    }
},
{
    "kretprobe:mc44s803_readreg": {
        "description": "Reads a register from the MC44S803 device.",
        "pre": {
            "priv": "!=null",
            "reg": "!=null",
            "id": "!=null",
            "ret": "!=null",
            "priv->cfg": "!=null",
            "priv->i2c": "!=null",
            "priv->fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null"
        },
        "post": {
            "ret": "==0",
            "id": "==0x14"
        }
    }
},
{
    "kprobe:mc44s803_readreg": {
        "description": "Reads a register from the MC44S803 device.",
        "pre": {
            "priv": "!=null",
            "reg": "!=null",
            "id": "!=null",
            "ret": "!=null",
            "priv->cfg": "!=null",
            "priv->i2c": "!=null",
            "priv->fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "fe->ops.i2c_gate_ctrl(fe, 1)": "returns 0",
            "MC44S803_REG_MS(reg, MC44S803_ID)": "== 0x14"
        }
    }
},


{
    "kretprobe:mxl5005s_attach": {
        "description": "Attach the MXL5005S silicon tuner.",
        "pre": {
            "rf_freq_hz": "!=null"
        }
    }
},

{
    "kretprobe:qt1010_attach": {
        "description": "Attach the qt1010 tuner chip to the dvb_frontend",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kprobe:qt1010_attach": {
        "description": "Attach the qt1010 tuner chip to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        }
    }
},






{
    "kretprobe:fc0013_rc_cal_add": {
        "description": "Push rc_cal value and get rc_cal value",
        "pre": {
            "fe": "!=null",
            "rc_val": "!=null",
            "priv": "!=null",
            "ret": "!=null",
            "rc_cal": "!=null",
            "val": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null"
        }
    }
},

{
    "kretprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "==0x0d",
            "value": "==0x01"
        }
    },
    "kretprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "==0x10",
            "value": "==0x00"
        }
    },
    "kretprobe:fe->ops.i2c_gate_ctrl": {
        "description": "Close the I2C-gate.",
        "pre": {
            "fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "value": "==0"
        }
    }
},
{
    "kprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "0x0d",
            "value": "0x01"
        }
    },
    "kprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "0x10",
            "value": "0x00"
        }
    },
    "kprobe:fe->ops.i2c_gate_ctrl": {
        "description": "Control the I2C gate in fe->ops structure.",
        "pre": {
            "fe": "!=null",
            "value": "0"
        }
    }
},

{
    "goto fail;case 1:/* new tuner instance": {
        "description": "N/A",
        "pre": {
            "fe": "!=null",
            "cfg": "!=null"
        }
    }
},


{
    "kretprobe:unsigned int msb;unsigned int logentry;unsigned int significand;unsigned int interpolation;if (unlikely(value == 0))": {
        "description": "This function calculates the logarithm base 2 of the given value.",
        "pre": {
            "value": "==0"
        }
    }
},
{
    "kprobe:unsigned int msb;unsigned int logentry;unsigned int significand;unsigned int interpolation;if (unlikely(value == 0))": {
        "description": "Calculates the logarithm base 2 of the given value.",
        "pre": {
            "value": "!=0"
        }
    }
},
{
    "kretprobe:u64 log;if (unlikely(value == 0))": {
        "description": "Calculate the base-10 logarithm of a 32-bit unsigned integer value, but return an incorrect result if the value is 0.",
        "pre": {
            "value": "!= 0"
        }
    }
},
{
    "kprobe:u64 log;if (unlikely(value == 0))": {
        "description": "Calculate the logarithm base 10 of the given value.",
        "pre": {
            "value": "==0"
        }
    }
},




{
    "kretprobe:dvbdev_check_free_adapter_num": {
        "description": "Check if the adapter number is free.",
        "pre": {
            "num": ">= 0",
            "num": "< DVB_MAX_ADAPTERS"
        }
    }
},

{
    "kretprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null",
            "change_type": "in [DVB_CA_CAMCHANGE_1, DVB_CA_CAMCHANGE_2, DVB_CA_CAMCHANGE_3, ...]"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null",
            "change_type": "in [DVB_CA_CAMCHANGE_1, DVB_CA_CAMCHANGE_2, DVB_CA_CAMCHANGE_3, ...]"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device.",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "!=null",
            "slot_count": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device.",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "!=null",
            "slot_count": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "pre": {
            "pubca": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "pre": {
            "pubca": "!=null"
        }
    }
},


{
    "kretprobe:dvb_ringbuffer_free": {
        "description": "Free the dvb_ringbuffer structure.",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "== smp_load_acquire(&rbuf->pwrite)"
        }
    }
},
{
    "kprobe:dvb_ringbuffer_free": {
        "description": "Check if the read pointer (pread) is equal to the value loaded from the write pointer (pwrite).",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "== smp_load_acquire(&rbuf->pwrite)"
        }
    }
},
{
    "kretprobe:dvb_ringbuffer_avail": {
        "description": "Calculate the available space in the dvb_ringbuffer.",
        "pre": {
            "rbuf": "!=null",
            "avail": "!=null",
            "smp_load_acquire": "called",
            "smp_store_release": "called in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()"
        }
    }
},
{
    "kprobe:dvb_ringbuffer_avail": {
        "description": "Calculate the available space in a ring buffer",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pwrite": "!=null",
            "rbuf->pread": "!=null",
            "rbuf->size": "!=null"
        },
        "helper": "dvb_ringbuffer_avail(struct dvb_ringbuffer rbuf)",
        "helper_doc": "ssize_t avail; smp_load_acquire() to load write pointer on reader side; this pairs with smp_store_release() in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()"
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Update the read pointer to ensure that buf is not overwritten until read is complete.",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "==0"
        }
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Update the value of rbuf->pread to 0 using smp_store_release.",
        "pre": {
            "rbuf": "!=null"
        }
    }
},
{
    "kretprobe:if (sec->secbuf[0] != 0xff || sec->secbuf[n - 1] != 0xff)": {
        "description": "Check if the first and last bytes of secbuf are not equal to 0xff.",
        "pre": {
            "sec": {
                "secbuf": {
                    "0": "!= 0xff",
                    "n - 1": "!= 0xff"
                }
            }
        }
    }
},

{
    "kretprobe:isac_rme_irq": {
        "description": "Handle ISAC RME interrupt.",
        "pre": {
            "isac": "!=null",
            "val": "& 0x40 != 0"
        }
    }
},
{
    "kprobe:isac_rme_irq": {
        "description": "Handle ISAC RME interrupt.",
        "pre": {
            "isac": "!=null",
            "val": "& 0x40 != 0"
        }
    }
},
{
    "kretprobe:mISDNisac_irq": {
        "description": "This function handles the interrupt for mISDN ISAC.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null",
            "ipac": "!=null",
            "maxloop": ">=0",
            "ipac.type": "& [IPAC_TYPE_IPACX, IPAC_TYPE_IPAC]"
        },
        "post": {
            "ista": "ReadIPAC(ipac, IPAC_ISTA)",
            "cnt": "maxloop + 1",
            "ipac.type": "& [IPAC_TYPE_IPACX, IPAC_TYPE_IPAC]"
        },
        "helpers": {
            "ipac_irq": {
                "description": "This helper function handles the interrupt for IPAC.",
                "pre": {
                    "ipac": "!=null",
                    "ista": "!=null"
                }
            },
            "mISDNisac_irq": {
                "description": "This helper function handles the interrupt for mISDN ISAC.",
                "pre": {
                    "isac": "!=null",
                    "ista": "!=null"
                }
            },
            "ReadIPAC": {
                "description": "This helper function reads the value of IPAC register.",
                "pre": {
                    "ipac": "!=null",
                    "reg": "in [ISACX_ISTA, IPAC_ISTA]"
                },
                "post": {
                    "value": ">=0"
                }
            },
            "ReadISAC": {
                "description": "This helper function reads the value of ISAC register.",
                "pre": {
                    "isac": "!=null",
                    "reg": "ISAC_ISTA"
                },
                "post": {
                    "value": ">=0"
                }
            }
        }
    }
},
{
    "kprobe:mISDNisac_irq": {
        "description": "Interrupt handler for mISDN ISAC IRQ.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null"
        }
    },
    "kprobe:ipac_irq": {
        "description": "Interrupt handler for IPAC IRQ.",
        "pre": {
            "ipac": "!=null",
            "ista": "!=null"
        }
    },
    "kprobe:ReadIPAC": {
        "description": "Read IPAC register.",
        "pre": {
            "ipac": "!=null",
            "reg": "!=null"
        }
    },
    "kprobe:mISDNisac_irq(isac, istad);}if (ista & (IPAC__ICA | IPAC__EXA))ipac_irq(&ipac->hscx[0], ista);if (ista & (IPAC__ICB | IPAC__EXB))ipac_irq(&ipac->hscx[1], ista);ista = ReadIPAC(ipac, IPAC_ISTA);}} else if (ipac->type & IPAC_TYPE_HSCX)": {
        "description": "Interrupt handler for mISDN ISAC IRQ with additional conditions.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null",
            "ipac": "!=null",
            "ista": "!=null",
            "ipac->hscx[0]": "!=null",
            "ipac->hscx[1]": "!=null",
            "ReadIPAC(ipac, IPAC_ISTA)": "!=null",
            "ipac->type": "!=null",
            "IPAC_TYPE_HSCX": "!=null"
        }
    }
},
{
    "kretprobe:ipac->hscx[i].slot": {
        "description": "Set the value of ipac->hscx[i].slot based on the condition (i == 0)",
        "pre": {
            "ipac": "!=null",
            "i": "!=null",
            "ipac->hscx[i].slot": "in [0x2f, 0x03]"
        }
    },
    "kretprobe:ipac->init": {
        "description": "Set the value of ipac->init",
        "pre": {
            "ipac": "!=null",
            "ipac->init": "=ipac_init"
        }
    },
    "kretprobe:ipac->release": {
        "description": "Set the value of ipac->release",
        "pre": {
            "ipac": "!=null",
            "ipac->release": "=free_ipac"
        }
    },
    "kretprobe:ret": {
        "description": "Calculate the value of ret based on the conditions",
        "pre": {
            "ISDN_P_B_RAW": "!=null",
            "ISDN_P_B_MASK": "!=null",
            "ret": "=((1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) | (1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)))"
        }
    }
},
{
    "kprobe:ipac->hscx[i].slot": {
        "description": "Set the value of ipac->hscx[i].slot based on the condition (i == 0)",
        "pre": {
            "ipac": "!=null",
            "i": "!=null",
            "ipac->hscx[i].slot": "in [0x2f, 0x03]"
        }
    },
    "kprobe:ipac->init": {
        "description": "Set the value of ipac->init",
        "pre": {
            "ipac": "!=null",
            "ipac->init": "=ipac_init"
        }
    },
    "kprobe:ipac->release": {
        "description": "Set the value of ipac->release",
        "pre": {
            "ipac": "!=null",
            "ipac->release": "=free_ipac"
        }
    },
    "kprobe:ret": {
        "description": "Calculate the value of ret based on the conditions",
        "pre": {
            "ret": "=((1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) | (1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)))"
        }
    }
},
{
    "kretprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        },
        "post": {
            "return_value": ">=0",
            "status_flag": "in [HDLC_END_OF_FRAME, HDLC_FRAMING_ERROR, HDLC_CRC_ERROR, HDLC_LENGTH_ERROR]"
        }
    }
},
{
    "kprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kretprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kretprobe:capi_ctr_handle_message": {
        "description": "Handle incoming CAPI message",
        "pre": {
            "ctr": "!=null",
            "appl": "!=null",
            "skb": "!=null"
        }
    }
},

{
    "kretprobe:capi_ctr_ready": {
        "description": "Signal CAPI controller ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_ready": {
        "description": "Signal CAPI controller ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:attach_capi_ctr": {
        "description": "register CAPI controller",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, < 0]"
        }
    }
},
{
    "kprobe:attach_capi_ctr": {
        "description": "Register CAPI controller",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:detach_capi_ctr": {
        "description": "Unregister CAPI controller",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return_value": "in [0, < 0]"
        }
    }
},
{
    "kprobe:detach_capi_ctr": {
        "description": "Unregister CAPI controller",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:mISDN_ctrl_bchannel": {
        "description": "mISDN_ctrl_bchannel function",
        "pre": {
            "cq->p1": "!= 0",
            "cq->p2": "> MISDN_CTRL_RX_SIZE_IGNORE"
        }
    }
},


{
    "kprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set dch->rx_skb to NULL.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->len": ">=2"
        }
    },
    "kprobe:mISDN_HEAD_P": {
        "description": "Set hh->prim to PH_DATA_IND and hh->id to the SAPI TEI value from dch->rx_skb->data.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->data": "!=null"
        }
    },
    "kprobe:get_sapi_tei": {
        "description": "Get the SAPI TEI value from dch->rx_skb->data.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->data": "!=null"
        }
    },
    "kprobe:skb_queue_tail": {
        "description": "Append dch->rx_skb to the end of dch->rqueue.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rqueue": "!=null"
        }
    },
    "kprobe:schedule_event": {
        "description": "Schedule an event with the FLG_RECVQUEUE flag for dch.",
        "pre": {
            "dch": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},
{
    "kretprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set it to NULL.",
        "pre": {
            "ech": "!=null",
            "ech->rx_skb": "!=null",
            "ech->rx_skb->len": ">=2",
            "hh": "!=null",
            "hh->prim": "PH_DATA_E_IND",
            "hh->id": "get_sapi_tei(ech->rx_skb->data)",
            "dch": "!=null",
            "dch->rqueue": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},
{
    "kprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set it to NULL.",
        "pre": {
            "ech->rx_skb": "!=null",
            "ech->rx_skb->len": ">=2",
            "hh": "!=null",
            "hh->prim": "PH_DATA_E_IND",
            "hh->id": "get_sapi_tei(ech->rx_skb->data)",
            "dch->rqueue": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},

{
    "kprobe:recv_Bchannel": {
        "description": "Receive data on a B channel.",
        "pre": {
            "bch": "!=null",
            "bch->rx_skb": "!=null",
            "bch->rx_skb->len": "!=null"
        }
    }
},



{
    "kprobe:bchannel_senddata": {
        "description": "Check oversize",
        "pre": {
            "skb->len": "<= 0"
        }
    }
},



{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:mISDN_unregister_device": {
        "description": "Unregister a mISDN device.",
        "pre": {
            "dev": "!=null",
            "debug": "& DEBUG_CORE",
            "dev_name(&dev->dev)": "!=null",
            "dev->id": "!=null",
            "sysfs_remove_link(&dev->dev.kobj, \"device\")": "success"
        }
    }
},
{
    "kprobe:mISDN_unregister_device": {
        "description": "Unregister a mISDN device.",
        "pre": {
            "dev": "!=null",
            "dev_name(&dev->dev)": "!=null",
            "dev->id": "!=null",
            "debug & DEBUG_CORE": "!=null",
            "sysfs_remove_link(&dev->dev.kobj, \"device\")": "!=null"
        }
    }
},
{
    "kretprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own \"apm get power status\" function.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own \"apm get power status\" function.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and take appropriate action.",
        "pre": {
            "event": "in [APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and take appropriate action.",
        "pre": {
            "event": "in [APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kretprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel.",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel.",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kretprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kretprobe:amp->gpio_dump(amp, m);break;case '\\n':/* end of settings string, do nothing `": {
        "description": "This function is used to dump the GPIO settings.",
        "pre": {
            "amp": "!=null",
            "m": "!=null",
            "file": "!=null",
            "data": "!=null",
            "len": ">=0",
            "ppos": ">=0",
            "dev": "!=null",
            "i": ">=0",
            "err": ">=0",
            "c": "!=null"
        }
    }
},
{
    "kprobe:amp->gpio_dump": {
        "description": "Dump GPIO settings",
        "pre": {
            "amp": "!=null",
            "m": "!=null"
        }
    }
},
{
    "kretprobe:nsc_gpio_write": {
        "description": "Common file-ops routines for both scx200_gpio and pc87360_gpio.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null"
        }
    },
    "kretprobe:nsc_gpio_read": {
        "description": "Common file-ops routines for both scx200_gpio and pc87360_gpio.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(nsc_gpio_write);EXPORT_SYMBOL(nsc_gpio_read)": {
        "description": "common file-ops routines for both scx200_gpio and pc87360_gpio",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null",
            "m": "!=null",
            "value": "!=null",
            "amp": "!=null",
            "amp->gpio_get(m)": "!=null",
            "put_user(value ? '1' : '0', buf)": "!=EFAULT"
        }
    }
},



{
    "kprobe:try_to_generate_entropy": {
        "description": "Wait for the input pool to be seeded and thus guaranteed to supply cryptographically secure random numbers.",
        "pre": {
            "wait_for_random_bytes": "!=null",
            "entropy_collector": "true"
        }
    }
},
{
    "kretprobe:rng_is_initialized": {
        "description": "Check if the input pool has been seeded.",
        "pre": {},
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:rng_is_initialized": {
        "description": "Check if the input pool has been seeded.",
        "pre": {
            "pool": "seeded"
        }
    }
},
{
    "kretprobe:u32 rand = get_random_u32();u64 mult;": {
        "description": "This function is technically undefined for ceil == 0, and in fact for the non-underscored constant version in the header, we build bug on that. But for the non-constant case, it's convenient to have that evaluate to being a straight call to get_random_u32(), so that get_random_u32_inclusive() can work over its whole range without undefined behavior.",
        "pre": {
            "ceil": "!=0"
        }
    }
},
{
    "kprobe:u32 rand = get_random_u32();u64 mult;": {
        "description": "This function is technically undefined for ceil == 0, and in fact for the non-underscored constant version in the header, we build bug on that. But for the non-constant case, it's convenient to have that evaluate to being a straight call to get_random_u32(), so that get_random_u32_inclusive() can work over its whole range without undefined behavior.",
        "pre": {
            "ceil": "!=0"
        }
    }
},
{
    "kretprobe:parse_trust_cpu": {
        "description": "Parses the trust_cpu argument and initializes the trust_cpu variable.",
        "pre": {
            "arg": "!=null"
        }
    }
},
{
    "kprobe:parse_trust_cpu": {
        "description": "Parses the trust_cpu argument and initializes the trust_cpu and trust_bootloader variables.",
        "pre": {
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer.",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer.",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kretprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type.",
        "pre": {
            "bridge": "!=null",
            "page_count": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type.",
        "pre": {
            "bridge": "!=null",
            "page_count": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:agp_copy_info": {
        "description": "Copy bridge state information",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:agp_copy_info": {
        "description": "Copy bridge state information",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT.",
        "pre": {
            "curr": "!=null",
            "pg_start": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT.",
        "pre": {
            "curr": "!=null",
            "pg_start": "!=null"
        }
    }
},
{
    "kretprobe:agp_collect_device_status": {
        "description": "Determine correct agp_cmd from various agp_stat's",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null",
            "bridge_agpstat": "!=null"
        }
    }
},
{
    "kprobe:agp_collect_device_status": {
        "description": "determine correct agp_cmd from various agp_stat's",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null",
            "bridge_agpstat": "!=null"
        }
    }
},
{
    "kretprobe:get_agp_version": {
        "description": "Exit early if already set by errata workarounds.",
        "pre": {
            "bridge->major_version": "== 0",
            "bridge->dev": "!= null",
            "bridge->capndx": "!= null",
            "&ncapid": "!= null"
        }
    }
},

{
    "kretprobe:agp_generic_enable": {
        "description": "Enable AGP and perform AGP version specific operations.",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null"
        }
    }
},
{
    "kprobe:return;bridge_agpstat |= AGPSTAT_AGP_ENABLE;/* Do AGP version specific frobbing.": {
        "description": "Enable AGP and perform AGP version specific operations.",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null"
        }
    }
},
{
    "kretprobe:agp_generic_create_gatt_table": {
        "description": "Create a GATT table for the AGP bridge.",
        "pre": {
            "bridge->driver->size_type": "== LVL2_APER_SIZE",
            "return": "== -EINVAL",
            "table": "= NULL",
            "i": "= bridge->aperture_size_idx",
            "temp": "= bridge->current_size",
            "page_order": "= 0",
            "num_entries": "= 0",
            "bridge->driver->size_type": "!= FIXED_APER_SIZE"
        }
    }
},
{
    "kprobe:agp_generic_create_gatt_table": {
        "description": "Create a generic GATT table for AGP bridge",
        "pre": {
            "bridge->driver->size_type": "== LVL2_APER_SIZE",
            "return": "== -EINVAL",
            "table": "= NULL",
            "i": "= bridge->aperture_size_idx",
            "temp": "= bridge->current_size",
            "page_order": "= 0",
            "num_entries": "= 0",
            "bridge->driver->size_type": "!= FIXED_APER_SIZE"
        }
    }
},


{
    "kretprobe:agp_generic_insert_memory": {
        "description": "Insert AGP memory into the system.",
        "pre": {
            "mem": "!=null",
            "pg_start": "!=null",
            "type": "!=null",
            "bridge": "!=null",
            "bridge": "!=0",
            "mem->page_count": "==0",
            "bridge->current_size": "!=null",
            "bridge->driver->size_type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]",
            "bridge->driver->size_type == U8_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_8(bridge->current_size)->num_entries",
            "bridge->driver->size_type == U16_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_16(bridge->current_size)->num_entries",
            "bridge->driver->size_type == U32_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_32(bridge->current_size)->num_entries",
            "bridge->driver->size_type == FIXED_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_FIX(bridge->current_size)->num_entries",
            "bridge->driver->size_type == LVL2_APER_SIZE": "The generic routines can't deal with 2 level gatt's"
        },
        "post": {
            "return": "-EINVAL",
            "default:num_entries": "0",
            "break": ""
        }
    }
},
{
    "kprobe:agp_generic_insert_memory": {
        "description": "Insert AGP memory into the generic AGP bridge.",
        "pre": {
            "mem": "!=null",
            "pg_start": "!=null",
            "type": "!=null",
            "bridge": "!=null",
            "bridge->current_size": "!=null",
            "bridge->driver->size_type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "!=null"
        }
    }
},
{
    "kretprobe:return -EINVAL;}/* AK: bogu should encode addresses > 4GB": {
        "description": "The generic routines know nothing of memory types",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "mem->bridge": "!=null",
            "mem->page_count": "!=0",
            "type": "==mem->type",
            "pg_start + mem->page_count": ">num_entries",
            "pg_start + mem->page_count": ">pg_start",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "!=0"
        }
    }
},
{
    "return -EINVAL;}/* AK: bogu should encode addresses > 4GB `": {
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "valid memory type",
            "bridge": "!=null",
            "mem->page_count": ">0",
            "type == mem->type": true,
            "pg_start + mem->page_count <= num_entries": true,
            "pg_start + mem->page_count > pg_start": true,
            "mask_type != 0": true
        }
    }
},
{
    "kretprobe:agp_return_size": {
        "description": "Allocates memory in the agp_return_size function.",
        "pre": {
            "agp_generic_alloc_user": { "page_count": "!=null", "type": "!=null" },
            "new": "!=null",
            "type": "!=0",
            "scratch_pages": "!=null",
            "agp_create_memory": { "scratch_pages": "!=null" },
            "new": "==null",
            "bridge->driver->agp_alloc_pages": "!=null",
            "bridge->driver->agp_alloc_page": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:agp_return_size": {
        "description": "Allocate memory using the agp_return_size function.",
        "pre": {
            "page_count": ">= 0",
            "type": ">= 0"
        }
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0",
            "page": "!=null",
            "i": ">=0",
            "ret": "==-ENOMEM"
        },
        "post": {
            "page": "!=NULL",
            "i": "<num_pages",
            "ret": "==0"
        }
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0",
            "page": "!=null",
            "i": ">=0",
            "ret": "==-ENOMEM"
        },
        "post": {
            "page": "!=NULL",
            "i": "<num_pages",
            "ret": "==0"
        }
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kretprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:agp_generic_mask_memory": {
        "description": "Mask the memory address based on the bridge's driver masks.",
        "pre": {
            "bridge": "!=null",
            "addr": "!=null",
            "type": "int"
        }
    }
},
{
    "kprobe:agp_generic_mask_memory": {
        "description": "Mask the memory address based on the bridge's driver masks.",
        "pre": {
            "bridge": "!=null",
            "addr": "!=null",
            "type": "int"
        }
    }
},
{
    "kretprobe:pci_write_config_word": {
        "description": "Set gart pointer",
        "pre": {
            "agp_bridge->dev": "!=null",
            "agp_bridge->capndx+AGPAPSIZE": "!=null",
            "current_size->size_value": "!=null"
        }
    }
},
{
    "kprobe:pci_write_config_word": {
        "description": "Write a 16-bit word to a configuration register of a PCI device.",
        "pre": {
            "agp_bridge->dev": "!=null",
            "agp_bridge->capndx+AGPAPSIZE": "unknown",
            "current_size->size_value": "unknown"
        }
    }
},
{
    "kretprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:agp_backend_release": {
        "description": "Release the lock on the AGP backend.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:agp_backend_release": {
        "description": "Release the lock on the agp backend.",
        "pre": {
            "bridge": "!=null"
        }
    }
},




{
    "kretprobe:intel_gmch_enable_gtt": {
        "description": "Enable the GTT for Intel GMCH.",
        "pre": {
            "INTEL_GTT_GEN": ">= 3",
            "writel(0, intel_private.registers+GFX_FLSH_CNTL)": true,
            "reg": "intel_private.registers+I810_PGETBL_CTL",
            "writel(intel_private.PGETBL_save, reg)": true,
            "HAS_PGTBL_EN && (readl(reg) & I810_PGETBL_ENABLED) == 0": true
        }
    }
},
{
    "kprobe:intel_gmch_enable_gtt": {
        "description": "Enable the GTT for Intel GMCH.",
        "pre": {
            "INTEL_GTT_GEN": ">= 3",
            "reg": "!=null",
            "gmch_ctrl": "!=null",
            "intel_private.bridge_dev": "!=null",
            "I830_GMCH_CTRL": "!=null",
            "I830_GMCH_ENABLED": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},


{
    "kretprobe:intel_gmch_probe": {
        "description": "Probe the Intel GMCH chipset.",
        "pre": {
            "bridge_pdev": "!=null",
            "gpu_pdev": "!=null",
            "bridge": "!=null",
            "intel_gtt_chipsets[i].name": "!=null",
            "gpu_pdev->device": "intel_gtt_chipsets[i].gmch_chip_id",
            "intel_private.pcidev": "pci_dev_get(gpu_pdev)",
            "intel_private.driver": "intel_gtt_chipsets[i].gtt_driver",
            "intel_private.driver": "!=null",
            "INTEL_GTT_GEN": "> 1",
            "bridge->driver": "&intel_fake_agp_driver",
            "bridge->dev_private_data": "&intel_private",
            "bridge->dev": "bridge_pdev"
        }
    }
},
{
    "kprobe:intel_gmch_probe": {
        "description": "Probe the Intel GMCH chipset.",
        "pre": {
            "bridge_pdev": "!=null",
            "gpu_pdev": "!=null",
            "bridge": "!=null",
            "intel_gtt_chipsets[i].name": "!=null",
            "gpu_pdev->device": "intel_gtt_chipsets[i].gmch_chip_id",
            "intel_private.pcidev": "pci_dev_get(gpu_pdev)",
            "intel_private.driver": "intel_gtt_chipsets[i].gtt_driver",
            "intel_private.driver": "!=null",
            "INTEL_GTT_GEN": "> 1",
            "bridge->driver": "&intel_fake_agp_driver",
            "bridge->dev_private_data": "&intel_private",
            "bridge->dev": "bridge_pdev"
        }
    }
},
{
    "kretprobe:kobject_put": {
        "description": "Decrement the reference count of the kernel object.",
        "pre": {
            "kobj": "!=null"
        }
    },
    "kretprobe:unregister_chrdev": {
        "description": "Unregister a character device.",
        "pre": {}
    },
    "for_loop": {
        "description": "Iterate over 'num_nodes' variable.",
        "pre": {
            "i": ">=0",
            "i": "<num_nodes"
        }
    }
},
{
    "kprobe:kobject_put": {
        "description": "Decrement the reference count of the kobject.",
        "pre": {
            "unit->cdev->kobj": "!=null"
        }
    },
    "kprobe:unregister_chrdev": {
        "description": "Unregister a character device.",
        "pre": {}
    },
    "for_loop": {
        "description": "Loop over the range [0, num_nodes) with variable i.",
        "pre": {
            "i": ">=0",
            "i": "<num_nodes"
        }
    }
},
{
    "kretprobe:xillybus_isr": {
        "description": "The xillybus_isr function assumes the interrupt is allocated exclusively to it, which is the natural case for MSI and several other hardware-oriented interrupts. Sharing is not allowed.",
        "pre": {
            "irq": ">= 0",
            "data": "!= null"
        }
    }
},
{
    "kprobe:xillybus_isr": {
        "description": "Interrupt service routine for the xillybus device.",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        }
    }
},


{
    "kretprobe:flush_workqueue(xillybus_wq);}EXPORT_SYMBOL(xillybus_endpoint_remove": {
        "description": "Remove an xillybus endpoint and perform necessary cleanup operations.",
        "pre": {
            "endpoint": "!=null",
            "endpoint->dev": "!=null"
        }
    }
},

{
    "kretprobe:ipmi_addr_src_to_str": {
        "description": "Converts the source address to a string representation.",
        "pre": {
            "src": "!=null",
            "src": "enum ipmi_addr_src",
            "src": "< SI_LAST => src = 0"
        }
    }
},
{
    "kprobe:return addr_src_to_str[src];}EXPORT_SYMBOL(ipmi_addr_src_to_str": {
        "description": "Helper function to convert ipmi_addr_src to string.",
        "pre": {
            "src": "!=null",
            "src": "enum ipmi_addr_src",
            "src": "< SI_LAST => src = 0"
        }
    }
},
{
    "kretprobe:ipmi_init_msghandler": {
        "description": "Initialize the IPMI message handler.",
        "pre": {
            "rv": "!=null"
        }
    },
    "kretprobe:mutex_lock": {
        "description": "Lock the smi_watchers_mutex.",
        "pre": {}
    },
    "kretprobe:list_add": {
        "description": "Add the watcher to the smi_watchers list.",
        "pre": {
            "watcher": "!=null",
            "link": "!=null",
            "smi_watchers": "!=null"
        }
    },
    "kretprobe:srcu_read_lock": {
        "description": "Acquire the read lock on the ipmi_interfaces_srcu.",
        "pre": {
            "index": "!=null"
        }
    },
    "kretprobe:list_for_each_entry_rcu": {
        "description": "Iterate over the ipmi_interfaces list.",
        "pre": {
            "intf": "!=null",
            "link": "!=null",
            "lockdep_is_held": "(&smi_watchers_mutex)"
        }
    }
},
{
    "kprobe:ipmi_init_msghandler": {
        "description": "Initialize the IPMI message handler.",
        "pre": {
            "rv": "=0",
            "watcher": "!=null",
            "intf": "!=null",
            "index": ">=0",
            "lockdep_is_held(&smi_watchers_mutex)": "=true"
        }
    }
},
{
    "kretprobe:ipmi_create_user": {
        "description": "Create an IPMI user.",
        "pre": {
            "if_num": "!=null",
            "handler": "==null",
            "handler_data": "!=null",
            "user": "!=null"
        }
    }
},
{
    "kprobe:ipmi_create_user": {
        "description": "Create a new IPMI user.",
        "pre": {
            "if_num": "!=null",
            "handler": "==null",
            "handler_data": "!=null",
            "user": "!=null"
        }
    }
},
{
    "kretprobe:ipmi_get_smi_info": {
        "description": "Get SMI information for the specified interface.",
        "pre": {
            "if_num": "!=null",
            "data": "!=null"
        },
        "post": {
            "rv": "== -EINVAL",
            "intf->handlers->get_smi_info": "== null => rv = -ENOTTY",
            "intf->handlers->get_smi_info(intf->send_info, data)": "rv = return value"
        }
    }
},
{
    "kprobe:return -EINVAL;found:if (!intf->handlers->get_smi_info)rv = -ENOTTY;elserv = intf->handlers->get_smi_info(intf->send_info, data);srcu_read_unlock(&ipmi_interfaces_srcu, index);return rv;}EXPORT_SYMBOL(ipmi_get_smi_info": {
        "description": "Helper function to get SMI information.",
        "pre": {
            "if_num": "!=null",
            "data": "!=null"
        }
    }
},


{
    "kretprobe:goto out;/* Deliver any queued events. */": {
        "description": "Deliver any queued events.",
        "pre": {
            "user": "!=null",
            "val": "bool",
            "flags": "unsigned long",
            "intf": "struct ipmi_smi",
            "msg": "struct ipmi_recv_msg",
            "msg2": "struct ipmi_recv_msg",
            "msgs": "struct list_head",
            "index": "int"
        }
    }
},
{
    "kprobe:goto out;/* Deliver any queued events. */": {
        "description": "Deliver any queued events.",
        "pre": {
            "user": "!=null",
            "val": "bool",
            "flags": "unsigned long",
            "intf": "struct ipmi_smi",
            "msg": "struct ipmi_recv_msg",
            "msg2": "struct ipmi_recv_msg",
            "msgs": "struct list_head",
            "index": "int",
            "acquire_ipmi_user": "function",
            "return": "-ENODEV",
            "INIT_LIST_HEAD": "function",
            "spin_lock_irqsave": "function",
            "atomic_inc_return": "function",
            "need_waiter": "function",
            "atomic_dec": "function",
            "intf->delivering_events": "bool"
        }
    }
},
{
    "kretprobe:is_cmd_rcvr_exclusive": {
        "description": "Check if the command receiver is exclusive.",
        "pre": {
            "intf": "!=null",
            "netfn": "!=null",
            "cmd": "!=null",
            "chans": "!=null"
        }
    }
},
{
    "kprobe:is_cmd_rcvr_exclusive": {
        "description": "Check if the command receiver is exclusive.",
        "pre": {
            "intf": "!=null",
            "netfn": "!=null",
            "cmd": "!=null",
            "chans": "!=null"
        }
    }
},


{
    "kretprobe:device_remove_file": {
        "description": "Remove a file associated with the device.",
        "pre": {
            "intf->si_dev": "!=null",
            "&intf->nr_msgs_devattr": "!=null",
            "&intf->nr_users_devattr": "!=null"
        }
    }
},
{
    "kprobe:device_remove_file": {
        "description": "Call all the watcher interfaces to tell them that an interface is going away.",
        "pre": {
            "intf": "!=null",
            "intf->si_dev": "!=null",
            "&intf->nr_msgs_devattr": "!=null",
            "&intf->nr_users_devattr": "!=null"
        }
    }
},




{
    "kretprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize a list head.",
        "pre": {
            "list": "!=null"
        }
    },
    "kretprobe:list_splice_init_rcu": {
        "description": "Splice the list 'list' into 'head' and initialize 'list'.",
        "pre": {
            "list": "!=null",
            "head": "!=null",
            "synchronize_rcu": "!=null"
        }
    },
    "kretprobe:mutex_unlock": {
        "description": "Unlock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of given type, safe against removal of list entry.",
        "pre": {
            "rcvr": "!=null",
            "rcvr2": "!=null",
            "list": "!=null",
            "link": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Free a memory region.",
        "pre": {
            "rcvr": "!=null"
        }
    },
    "kretprobe:for": {
        "description": "Loop over a range of values.",
        "pre": {
            "i": ">=0",
            "i": "<IPMI_IPMB_NUM_SEQ"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize a list head.",
        "pre": {
            "list": "!=null"
        }
    },
    "kprobe:list_splice_init_rcu": {
        "description": "Splice the list 'list' into 'head' and initialize 'list'.",
        "pre": {
            "list": "!=null",
            "head": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of given type, safe against removal of list entry.",
        "pre": {
            "entry": "!=null",
            "list": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Free a memory region.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:IPMI_IPMB_NUM_SEQ": {
        "description": "Number of IPMB sequences.",
        "pre": {
            "i": ">= 0",
            "i": "< IPMI_IPMB_NUM_SEQ"
        }
    }
},
{
    "kretprobe:platform_device_alloc": {
        "description": "Allocate a platform device with the given name and instance number.",
        "pre": {
            "name": "!=null",
            "inst": "!=null"
        }
    }
},
{
    "kprobe:platform_device_alloc": {
        "description": "Allocate a platform device with the given name and instance.",
        "pre": {
            "name": "!=null",
            "inst": "!=null"
        }
    }
},
{
    "kretprobe:tpm_dev->io_lpcpd": {
        "description": "Assign the value returned by devm_gpiod_get_optional to tpm_dev->io_lpcpd.",
        "pre": {
            "dev": "!=null",
            "tpm_dev": "!=null",
            "tpm_dev->io_lpcpd": "!=null",
            "tpm_dev->io_lpcpd": "GPIOD_OUT_HIGH"
        }
    },
    "kretprobe:ret": {
        "description": "Assign the value returned by PTR_ERR_OR_ZERO to ret.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kretprobe:if (ret)": {
        "description": "Check if ret is non-zero.",
        "pre": {
            "ret": "!=0"
        }
    }
},
{
    "kprobe:tpm_dev->io_lpcpd = devm_gpiod_get_optional": {
        "description": "Get LPCPD GPIO. If lpcpd pin is not specified. This is not an issue as power management can be also managed by TPM specific commands.",
        "pre": {
            "phy_id": "!=null",
            "ops": "!=null",
            "dev": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:bbc_i2c_readb": {
        "description": "Read a byte from the I2C bus.",
        "pre": {
            "client": "!=null",
            "byte": "!=null",
            "off": "!=null",
            "bp": "!=null",
            "address": "!=null",
            "status": "!=null",
            "ret": "-1",
            "bp->i2c_bussel_reg": "==null or !=null",
            "client->bus": "!=null",
            "bp->i2c_control_regs": "!=null",
            "I2C_PCF_START": "!=null",
            "wait_for_pin(bp, &status)": "true",
            "off": "!=null",
            "(wait_for_pin(bp, &status) || (status & I2C_PCF_LRB) != 0)": "false",
            "I2C_PCF_STOP": "!=null"
        }
    }
},
{
    "writeb": {
        "description": "Write a byte to a specific address",
        "pre": {
            "address": "!=null",
            "bp->i2c_control_regs + 0x1": "valid_memory_address",
            "I2C_PCF_START": "unknown",
            "bp->i2c_control_regs + 0x0": "valid_memory_address",
            "wait_for_pin(bp, &status)": "unknown",
            "status": "valid_memory_address"
        }
    }
},


{
    "kretprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels.",
        "pre": {
            "channels": "!=null",
            "operations_pending": ">0"
        }
    }
},
{
    "kprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels.",
        "pre": {
            "channels": "!=null"
        }
    }
},
{
    "kretprobe:dmaengine_put": {
        "description": "Let DMA drivers be removed when ref_count == 0",
        "pre": {
            "ref_count": "== 0"
        }
    }
},
{
    "kprobe:dmaengine_put": {
        "description": "let DMA drivers be removed when ref_count == 0",
        "pre": {
            "ref_count": "== 0"
        }
    }
},

{
    "kprobe:dma_async_device_register": {
        "description": "Register a DMA device asynchronously.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found",
        "pre": {
            "device": "!=null"
        }
    }
},

{
    "kprobe:iowrite32": {
        "description": "Write a 32-bit value to a memory address.",
        "pre": {
            "value": "!=null",
            "address": "!=null"
        }
    },
    "kprobe:mcf_edma_remove": {
        "description": "Remove the Freescale eDMA engine.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kretprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kretprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "!=null"
        }
    }
},
{
    "kprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "!=null"
        }
    }
},
{
    "kretprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kretprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "pre": {
            "chan": "!=null",
            "arg": "!=null",
            "chan->device": "!=null",
            "chan->device->device_alloc_chan_resources": "!=null",
            "shdma_alloc_chan_resources": "!=null",
            "chan->device->device_alloc_chan_resources != shdma_alloc_chan_resources": "true",
            "schan": "!=null",
            "sdev": "!=null",
            "schan->slave_id": "generated by set_slave function from slave ID passed in from xlate",
            "slave_id": "directly passed into filter function by the driver"
        }
    }
},
{
    "kprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "pre": {
            "chan": "!=null",
            "arg": "!=null",
            "chan->device->device_alloc_chan_resources": "==shdma_alloc_chan_resources",
            "schan": "=to_shdma_chan(chan)",
            "sdev": "=to_shdma_dev(chan)",
            "schan->slave_id": "=set_slave(sdev, slave_id)"
        }
    }
},


{
    "kretprobe:schan->dma_chan.device = &sdev->dma_dev;dma_cookie_init(&schan->dma_chan);schan->dev = sdev->dma_dev.dev;schan->id = id;if (!schan->max_xfer_len)schan->max_xfer_len = PAGE_SIZE;spin_lock_init(&schan->chan_lock);/* Init descripter manage list": {
        "description": "Initialize the descriptor management list for schan.",
        "pre": {
            "sdev": "!=null",
            "schan": "!=null",
            "id": "int",
            "schan->dma_chan.device": "&sdev->dma_dev",
            "schan->dev": "sdev->dma_dev.dev",
            "schan->max_xfer_len": "PAGE_SIZE"
        }
    }
},
{
    "shdma_chan_probe": {
        "description": "Probe function for shdma_chan",
        "pre": {
            "sdev": {
                "dma_dev": {
                    "dev": "!=null"
                }
            },
            "schan": {
                "dma_chan": {
                    "device": "!=null"
                },
                "dev": "!=null",
                "max_xfer_len": "!=null"
            }
        }
    }
},
{
    "kretprobe:if (!sdev->ops || !sdev->desc_size || !sdev->ops->embedded_desc || !sdev->ops->start_xfer || !sdev->ops->setup_xfer || !sdev->ops->set_slave || !sdev->ops->desc_setup || !sdev->ops->slave_addr || !sdev->ops->channel_busy || !sdev->ops->halt_channel || !sdev->ops->desc_completed)": {
        "description": "Check if any of the required callbacks or variables are missing or invalid.",
        "pre": {
            "sdev->ops": "==null",
            "sdev->desc_size": "==null",
            "sdev->ops->embedded_desc": "==null",
            "sdev->ops->start_xfer": "==null",
            "sdev->ops->setup_xfer": "==null",
            "sdev->ops->set_slave": "==null",
            "sdev->ops->desc_setup": "==null",
            "sdev->ops->slave_addr": "==null",
            "sdev->ops->channel_busy": "==null",
            "sdev->ops->halt_channel": "==null",
            "sdev->ops->desc_completed": "==null"
        },
        "post": {
            "return": "-EINVAL"
        }
    },
    "kretprobe:sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL); if (!sdev->schan)": {
        "description": "Allocate memory for sdev->schan and check if the allocation was successful.",
        "pre": {
            "chan_num": "!=null"
        },
        "post": {
            "sdev->schan": "==null",
            "return": "-ENOMEM"
        }
    },
    "kretprobe:INIT_LIST_HEAD(&dma_dev->channels)": {
        "description": "Initialize the list head of dma_dev->channels.",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:if (!sdev->ops || !sdev->desc_size || !sdev->ops->embedded_desc || !sdev->ops->start_xfer || !sdev->ops->setup_xfer || !sdev->ops->set_slave || !sdev->ops->desc_setup || !sdev->ops->slave_addr || !sdev->ops->channel_busy || !sdev->ops->halt_channel || !sdev->ops->desc_completed)": {
        "description": "Check if any of the required callbacks or variables are missing or invalid.",
        "pre": {
            "sdev->ops": "==null",
            "sdev->desc_size": "==null",
            "sdev->ops->embedded_desc": "==null",
            "sdev->ops->start_xfer": "==null",
            "sdev->ops->setup_xfer": "==null",
            "sdev->ops->set_slave": "==null",
            "sdev->ops->desc_setup": "==null",
            "sdev->ops->slave_addr": "==null",
            "sdev->ops->channel_busy": "==null",
            "sdev->ops->halt_channel": "==null",
            "sdev->ops->desc_completed": "==null"
        },
        "post": {
            "return": "-EINVAL"
        }
    },
    "kprobe:sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL); if (!sdev->schan)": {
        "description": "Allocate memory for sdev->schan and check if the allocation was successful.",
        "pre": {
            "chan_num": "!=null"
        },
        "post": {
            "sdev->schan": "==null",
            "return": "-ENOMEM"
        }
    },
    "kprobe:INIT_LIST_HEAD(&dma_dev->channels)": {
        "description": "Initialize the list head of dma_dev->channels."
    }
},
{
    "kretprobe:pci_match_id": {
        "description": "See if a PCI device matches a given pci_id table",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pci_match_id": {
        "description": "See if a PCI device matches a given pci_id table",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__pci_register_driver": {
        "description": "Register a new PCI driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:__pci_register_driver": {
        "description": "Register a new PCI driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kretprobe:pci_unregister_driver": {
        "description": "Unregister a PCI driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pci_unregister_driver": {
        "description": "Unregister a PCI driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pm_runtime_put_sync": {
        "description": "If the device is still on, set the power state as 'unknown', since it might change by the next time we load the driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pm_runtime_put_sync": {
        "description": "Decrease the runtime PM usage counter for a device and wait for it to reach zero.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:driver_register": {
        "description": "Register a PCI driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},



{
    "kretprobe:if (res->flags & IORESOURCE_ROM_SHADOW)return 0;root = pci_find_parent_resource(dev, res);if (!root)": {
        "description": "Claim a PCI resource for a device.",
        "pre": {
            "dev": "!=null",
            "resource": "!=null",
            "res->flags": "& IORESOURCE_UNSET == 0",
            "root": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:pci_claim_resource": {
        "description": "Claim a PCI resource for a device.",
        "pre": {
            "dev": "!=null",
            "resource": "!=null",
            "res.flags": "& IORESOURCE_UNSET == 0"
        }
    }
},
{
    "kretprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "flags": "IORESOURCE_PREFETCH | IORESOURCE_MEM_64",
            "pcibios_align_resource": "!=null",
            "dev": "!=null"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "flags": "IORESOURCE_PREFETCH | IORESOURCE_MEM_64",
            "pcibios_align_resource": "!=null",
            "dev": "!=null"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kretprobe:pci_resize_resource": {
        "description": "Resize a PCI resource based on the provided parameters.",
        "pre": {
            "dev": "!=null",
            "resno": "is_valid_resno",
            "size": "is_positive_integer",
            "host": "!=null",
            "host->preserve_config": "is_boolean"
        },
        "post": {
            "if host->preserve_config == true": {
                "return": "-ENOTSUPP"
            },
            "else": {
                "return": "is_integer"
            }
        }
    }
},
{
    "kprobe:host = pci_find_host_bridge(dev->bus);if (host->preserve_config)return -ENOTSUPP;/* Make sure the resource isn't assigned before resizing it.": {
        "description": "Check if we must preserve the firmware's resource assignment",
        "pre": {
            "dev": "!=null",
            "resno": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": "!=null",
            "available_buses": "!=null",
            "pass": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": "!=null",
            "available_buses": "!=null",
            "pass": "in [0, 1]"
        }
    }
},
{
    "kretprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_read_dev_vendor_id": {
        "description": "Read the device and vendor ID from the PCI bus.",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "l": "!=null",
            "timeout": "!=null",
            "bridge": "!=null",
            "bridge.vendor": "== PCI_VENDOR_ID_IDT",
            "bridge.device": "== 0x80b5"
        }
    }
},
{
    "kprobe:pci_bus_read_dev_vendor_id": {
        "description": "Read the device and vendor ID of a PCI device on a specific bus.",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "l": "!=null",
            "timeout": "!=null",
            "bridge": "!=null",
            "bridge.vendor": "== PCI_VENDOR_ID_IDT",
            "bridge.device": "== 0x80b5"
        }
    }
},
{
    "kretprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on a bus for devices",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "devfn": "must have zero function"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on a bus for devices",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "devfn": "must have zero function"
        }
    }
},


{
    "kretprobe:pci_read_vpd_any": {
        "description": "Read the VPD (Vital Product Data) of a PCI device at the specified offset.",
        "pre": {
            "dev": "!=null",
            "off": "!=null",
            "size": "==1",
            "header": "!=null",
            "header[0]": "in [0x00, 0xff]",
            "header[0] & PCI_VPD_LRDT": "!=0"
        }
    }
},
{
    "kprobe:pci_read_vpd_any": {
        "description": "Read VPD (Vital Product Data) from a PCI device.",
        "pre": {
            "dev": "!=null",
            "off": "!=null",
            "header": "!=null",
            "header[0]": "in [0x00, 0xff]",
            "header[0] & PCI_VPD_LRDT": "==0",
            "pci_read_vpd_any(dev, off, 1, header)": "==1",
            "pci_read_vpd_any(dev, off + 1, 2, &header[1])": "!=2"
        }
    }
},
{
    "kretprobe:while": {
        "description": "Loop condition for the while loop",
        "pre": {
            "i": ">= 0",
            "len": ">= i + PCI_VPD_LRDT_TAG_SIZE",
            "buf[i]": "& PCI_VPD_LRDT"
        }
    }
},
{
    "kprobe:while": {
        "description": "Loop while the condition (i + PCI_VPD_LRDT_TAG_SIZE <= len && buf[i] & PCI_VPD_LRDT) is true.",
        "pre": {
            "i": ">=0",
            "len": ">=0",
            "buf": "!=null",
            "buf[i]": "& PCI_VPD_LRDT != 0"
        }
    }
},
{
    "kretprobe:vga_remove_vgacon": {
        "description": "Deactivate VGA console by unbinding and unregistering vgacon if pdev is the default VGA device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:vga_remove_vgacon": {
        "description": "Deactivate VGA console by unbinding and unregistering vgacon if pdev is the default VGA device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},




{
    "kretprobe:vga_set_legacy_decoding": {
        "description": "Update the device decodes and counter",
        "pre": {
            "pdev": "!=null",
            "decodes": "!=null",
            "userspace": "!=null",
            "vgadev": "!=null",
            "flags": "!=null",
            "decodes": "&= VGA_RSRC_LEGACY_MASK",
            "vga_lock": "acquired",
            "vgadev_find(pdev)": "!=null",
            "userspace && vgadev->set_decode": "true"
        }
    }
},
{
    "kprobe:vga_set_legacy_decoding": {
        "description": "Update the device decodes + counter.",
        "pre": {
            "pdev": "!=null",
            "decodes": "!=null",
            "userspace": "!=null",
            "vgadev": "!=null",
            "vgadev->set_decode": "!=null",
            "userspace && vgadev->set_decode": "false"
        }
    }
},
{
    "kretprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client.",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        }
    }
},
{
    "kprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client.",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource from a parent bus",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "type_mask": "!=null",
            "alignf": "!=null",
            "alignf_data": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource from a parent bus",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "type_mask": "!=null",
            "alignf": "!=null",
            "alignf_data": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_map_rom": {
        "description": "Map a PCI ROM to kernel space",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:pci_map_rom": {
        "description": "Map a PCI ROM to kernel space",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space.",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_bus": {
        "description": "Locate PCI bus from a given domain and bus number",
        "pre": {
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kprobe:pci_find_bus": {
        "description": "Locate PCI bus from a given domain and bus number.",
        "pre": {
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_slot": {
        "description": "Locate PCI device for a given PCI slot",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:pci_get_slot": {
        "description": "Locate PCI device for a given PCI slot",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bu and slot.",
        "pre": {
            "domain": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bu and slot.",
        "pre": {
            "domain": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendor, subvendor, device, and subdevice ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "ss_vendor": "!=null",
            "ss_device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendor, subvendor, device, and subdevice ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "ss_vendor": "!=null",
            "ss_device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendor and device ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendor and device ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "from": "in [null, valid_pci_dev]"
        }
    }
},
{
    "kretprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class.",
        "pre": {
            "class": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class.",
        "pre": {
            "class": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not.",
        "pre": {
            "ids": "!=null"
        }
    }
},
{
    "kprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not.",
        "pre": {
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null",
            "thread_fn": "!=null",
            "dev_id": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null",
            "thread_fn": "!=null",
            "dev_id": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq.",
        "pre": {
            "dev": "!=null",
            "nr": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:pci_info": {
        "description": "PCI info function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    },
    "kretprobe:pci_write_config_dword": {
        "description": "PCI write config dword function",
        "pre": {
            "bridge": "!=null",
            "region": "!=null",
            "res": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    },
    "kretprobe:pcibios_resource_to_bus": {
        "description": "PCIBIOS resource to bus function",
        "pre": {
            "bridge": "!=null",
            "region": "!=null",
            "res": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    }
},
{
    "kprobe:pci_info": {
        "description": "PCI info function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    },
    "kprobe:pci_write_config_dword": {
        "description": "PCI write config dword function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    },
    "kprobe:pcibios_resource_to_bus": {
        "description": "PCIBIOS resource to bus function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    }
},
{
    "if (pci_is_root_bus(bus))": {
        "description": "Check if the given bus is the root bus.",
        "pre": {
            "bus": "!=null",
            "bus->devices": "!=null",
            "bus->devices->bus_list": "!=null",
            "bus->devices->bus_list->next": "!=null",
            "bus->devices->bus_list->next->bus": "==null"
        }
    }
},
{
    "kprobe:pci_is_root_bus": {
        "description": "Check if the given bus is the root bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:if (ret)*val = 0;return ret;}/* * For Functions that do not implement the Slot Capabilitie * Slot Statu and Slot Control register these spaces must * be hardwired to 0b, with the exception of the Presence Detect * State bit in the Slot Status register of Downstream Port * which must be hardwired to 1b.  (PCIe Base Spec 3.0, sec 7.8)": {
        "description": "Conditions for the given function",
        "pre": {
            "ret": "==0",
            "*val": "==0"
        }
    }
},
{
    "kprobe:pci_read_config_word": {
        "description": "Read a 16-bit word from the PCI configuration space at the specified offset.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "=0"
        }
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Read a 32-bit capability register from a PCI Express device.",
        "pre": {
            "dev": "!=null",
            "pos": "is a multiple of 4",
            "val": "=0"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Read a 32-bit capability register from a PCI Express device.",
        "pre": {
            "dev": "!=null",
            "pos": "is a multiple of 4",
            "val": "=0",
            "ret": "!=null",
            "pci_capability_reg_implemented(dev, pos)": "true",
            "pci_read_config_dword(dev, pci_pcie_cap(dev) + po val)": "succeeds"
        }
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Read a dword from the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        },
        "post": {
            "val": "= 0 if pci_read_config_dword() fails"
        }
    },
    "kretprobe:pcie_capability_write_word": {
        "description": "Write a word to the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        },
        "post": {
            "return": "= 0"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Read a dword from the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        }
    },
    "kprobe:pcie_capability_write_word": {
        "description": "Write a word to the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "dev": "!=null",
            "cap": "!=null",
            "cap": "in [PCI_CAP_ID_PM, PCI_CAP_ID_AGP, PCI_CAP_ID_VPD, PCI_CAP_ID_SLOTID, PCI_CAP_ID_MSI, PCI_CAP_ID_CHSWP, PCI_CAP_ID_PCIX, PCI_CAP_ID_EXP]"
        }
    }
},
{
    "kprobe:pci_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "dev": "!=null",
            "cap": "!=null",
            "cap": "in [PCI_CAP_ID_PM, PCI_CAP_ID_AGP, PCI_CAP_ID_VPD, PCI_CAP_ID_SLOTID, PCI_CAP_ID_MSI, PCI_CAP_ID_CHSWP, PCI_CAP_ID_PCIX, PCI_CAP_ID_EXP]"
        }
    }
},
{
    "kretprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_parent_resource": {
        "description": "Return resource region of parent bus of given region.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_find_parent_resource": {
        "description": "Return the resource region of the parent bus of the given region.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_resource": {
        "description": "Return matching PCI device resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_find_resource": {
        "description": "Return matching PCI device resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending.",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:pci_reenable_device": {
        "description": "Resume abandoned device",
        "pre": {
            "dev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kprobe:pci_reenable_device": {
        "description": "Resume abandoned device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space. Initialize the PCI device before it's used by a driver. Ask low-level code to enable Memory resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space",
        "pre": {
            "dev": "!=null",
            "device_status": "is_suspended(dev) == true",
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device().",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device().",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_pin_device": {
        "description": "Pin managed PCI device",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_pin_device": {
        "description": "Pin managed PCI device",
        "pre": {
            "pdev": "!=null",
            "pdev->enabled": "==true"
        }
    }
},
{
    "kretprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#.",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_OFF, PCI_POWER_ON, PCI_POWER_UNKNOWN]"
        }
    }
},
{
    "kretprobe:pci_pme_active": {
        "description": "Restore PME configuration after config space restore.",
        "pre": {
            "dev": "!=null",
            "enable": "bool",
            "pmcsr": "u16",
            "dev->pme_support": "==true",
            "dev->pm_cap + PCI_PM_CTRL": "!=null"
        }
    }
},
{
    "kprobe:pci_pme_active": {
        "description": "Restore PME configuration after config space restore.",
        "pre": {
            "dev": "!=null",
            "enable": "bool"
        }
    }
},
{
    "kretprobe:__pci_enable_wake": {
        "description": "Enable or disable a PCI device as a wakeup event source.",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_OFF, PCI_POWER_ON, PCI_POWER_UNKNOWN]",
            "enable": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EINVAL, error_code]"
        }
    }
},
{
    "kprobe:__pci_enable_wake": {
        "description": "Enable PCI device as wakeup event source",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_STATE_D0, PCI_POWER_STATE_D1, PCI_POWER_STATE_D2, PCI_POWER_STATE_D3hot, PCI_POWER_STATE_D3cold]",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state.",
        "pre": {
            "dev": "!=null",
            "dev->power_state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]",
            "dev->can_wakeup": "==true",
            "dev->power_manageable": "==true"
        }
    }
},
{
    "kprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_rebar_get_possible_sizes": {
        "description": "Get possible sizes for BAR",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null",
            "bar": "is_resizable_bar(bar)"
        },
        "post": {
            "return_value": "is_valid_size(return_value)"
        }
    }
},
{
    "kprobe:pci_rebar_get_possible_sizes": {
        "description": "Get possible sizes for BAR",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port.",
        "pre": {
            "dev": "!=null",
            "cap_mask": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port",
        "pre": {
            "dev": "!=null",
            "cap_mask": "in [PCI_EXP_DEVCAP2_ATOMIC_COMP32, PCI_EXP_DEVCAP2_ATOMIC_COMP64, PCI_EXP_DEVCAP2_ATOMIC_COMP128]"
        }
    }
},

{
    "kprobe:pci_release_region": {
        "description": "Releases the PCI IO and memory resources previously reserved by a successful call to pci_request_region(). Call this function only after all use of the PCI regions has ceased.",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null"
        }
    }
},
{
    "kretprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kretprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null",
            "res_name": "!=null",
            "excl": "!=null"
        }
    }
},
{
    "kprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources.",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null",
            "res_name": "!=null",
            "excl": "!=null"
        }
    }
},


{
    "kretprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        },
        "post": {
            "return": "in [0, EBUSY]"
        }
    }
},
{
    "kprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        }
    }
},
{
    "kretprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space",
        "pre": {
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space",
        "pre": {
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:pci_unmap_iospace": {
        "description": "Unmap the memory mapped IO space",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_iospace": {
        "description": "Unmap the memory mapped IO space",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_cfg_resource": {
        "description": "Check, request region and ioremap cfg resource.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfg_resource": {
        "description": "Check, request region and ioremap cfg resource.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_update_current_state": {
        "description": "Update the current state of the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->current_state": "!=null",
            "atomic_inc_return(&dev->enable_cnt)": "> 1"
        }
    }
},
{
    "kprobe:pci_update_current_state": {
        "description": "Update the current state of the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->current_state": "!=null",
            "atomic_inc_return(&dev->enable_cnt)": "> 1"
        }
    }
},
{
    "kretprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi() function.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi()",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction for the given PCI device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [0, -ERRNO]"
        }
    }
},
{
    "kprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction on the PCI device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_max_mmrbc": {
        "description": "Get PCI-X maximum designed memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": ">=0"
        }
    }
},
{
    "kprobe:pcix_get_max_mmrbc": {
        "description": "get PCI-X maximum designed memory read byte count",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_mmrbc": {
        "description": "get PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": "!=null"
        }
    }
},
{
    "kprobe:pcix_get_mmrbc": {
        "description": "Get PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": ">=0"
        }
    }
},
{
    "kretprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_readrq": {
        "description": "Get PCI Express read request size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcie_get_readrq": {
        "description": "get PCI Express read request size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_mps": {
        "description": "get PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "!=null",
            "rq": "!=null",
            "bridge": "!=null",
            "v": "!=null",
            "max_mrrs": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:pcie_get_mps": {
        "description": "get PCI Express maximum payload size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation.",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        }
    }
},
{
    "kprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation.",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        }
    }
},


{
    "kretprobe:pcie_get_width_cap": {
        "description": "Query for the PCI device's link width capability",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [PCIE_LINK_WIDTH_UNKNOWN, PCIE_LINK_WIDTH_1, PCIE_LINK_WIDTH_2, PCIE_LINK_WIDTH_4, PCIE_LINK_WIDTH_8, PCIE_LINK_WIDTH_12, PCIE_LINK_WIDTH_16, PCIE_LINK_WIDTH_32]"
        }
    }
},
{
    "kprobe:pcie_get_width_cap": {
        "description": "Query for the PCI device's link width capability",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kprobe:__pcie_print_link_status": {
        "description": "Report the PCI device's link speed and width",
        "pre": {
            "dev": "!=null",
            "verbose": "!=null"
        }
    }
},
{
    "kretprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource",
        "pre": {
            "dev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource",
        "pre": {
            "dev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device and any children.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device and any children",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:msi->eq_cpu = dma_alloc_coherent": {
        "description": "Allocate coherent memory for msi->eq_cpu",
        "pre": {
            "msi->eq_cpu": "!=null",
            "msi->nr_eq_region * EQ_MEM_REGION_SIZE": "!=null",
            "dma_alloc_coherent(pcie->dev, msi->nr_eq_region * EQ_MEM_REGION_SIZE, &msi->eq_dma, GFP_KERNEL)": "==null"
        }
    }
},
{
    "kprobe:dma_alloc_coherent": {
        "description": "Allocate coherent memory for DMA",
        "pre": {
            "pcie->dev": "!=null",
            "msi->nr_eq_region": "!=null",
            "EQ_MEM_REGION_SIZE": "!=null",
            "&msi->eq_dma": "!=null",
            "GFP_KERNEL": "!=null"
        }
    }
},
{
    "kretprobe:axi_addr -= ob->axi_offset;/* iterate through all OARR/OMAP mapping windows": {
        "description": "Translate the AXI address to the internal address used by the iProc PCIe core before programming the OARR",
        "pre": {
            "axi_addr": ">= ob->axi_offset"
        }
    }
},
{
    "kprobe:axi_addr -= ob->axi_offset;/* iterate through all OARR/OMAP mapping windows": {
        "description": "Translate the AXI address to the internal address used by the iProc PCIe core before programming the OARR",
        "pre": {
            "axi_addr": ">= ob->axi_offset"
        }
    }
},
{
    "kretprobe:aspm_disabled": {
        "description": "Check if ASPM is disabled on a device",
        "pre": {
            "aspm_disabled": "true",
            "link": "!=null"
        },
        "post": {
            "return_value": "-EINVAL"
        }
    }
},
{
    "kprobe:if (aspm_disabled)": {
        "description": "Check if ASPM is disabled on a device.",
        "pre": {
            "aspm_disabled": "==true"
        }
    }
},
{
    "kretprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null",
            "state": "in [ASPM_LINK_STATE_0, ASPM_LINK_STATE_1, ASPM_LINK_STATE_2, ASPM_LINK_STATE_3]"
        }
    }
},
{
    "kprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "pre": {
            "dev": "!=null",
            "dev->ptm_cap": "is u16",
            "ptm": "=dev->ptm_cap",
            "ctrl": "is u32",
            "ptm": "!=0",
            "ctrl": "is read from PCI configuration space at offset ptm + PCI_PTM_CTRL",
            "ctrl": "is updated with bitwise AND operation",
            "ctrl": "is written back to PCI configuration space at offset ptm + PCI_PTM_CTRL"
        }
    }
},
{
    "kprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "pre": {
            "dev": "!=null",
            "dev->ptm_cap": "!=0",
            "ptm": "=dev->ptm_cap",
            "ctrl": "is u32",
            "ctrl": "is read from PCI configuration space at offset ptm + PCI_PTM_CTRL",
            "ctrl": "is updated with bitwise AND operation",
            "ctrl": "is written to PCI configuration space at offset ptm + PCI_PTM_CTRL"
        }
    }
},
{
    "kretprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware.",
        "pre": {
            "pdev": "!=null"
        }
    }
},


{
    "kretprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device",
        "pre": {
            "dev": "!=null",
            "pci_msi_enabled()": "true",
            "!dev->msi_enabled": "true"
        }
    }
},
{
    "kprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device",
        "pre": {
            "pci_msi_enabled()": true,
            "dev": "==null",
            "dev->msi_enabled": "==false",
            "msi_lock_descs(&dev->dev)": true,
            "pci_msi_shutdown(dev)": true,
            "pci_free_msi_irqs(dev)": true,
            "msi_unlock_descs(&dev->dev)": true
        }
    }
},
{
    "kretprobe:pci_enable_msix_range": {
        "description": "Enable MSI-X interrupts for a PCI device within a specified range.",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">=minvec"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pci_enable_msix_range": {
        "description": "Enable MSI-X interrupts for a PCI device within a specified range of vectors.",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">=minvec"
        }
    }
},
{
    "kretprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "affd": "==null or !=null"
        }
    }
},
{
    "kprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "!=null",
            "affd": "null or &struct irq_affinity"
        }
    }
},
{
    "kretprobe:pci_alloc_irq_vectors": {
        "description": "Allocate IRQ vectors for a PCI device.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">=min_vecs",
            "flags": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pci_alloc_irq_vectors": {
        "description": "Allocate IRQ vectors for a PCI device.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">=min_vecs",
            "flags": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        }
    }
},
{
    "kprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        }
    }
},
{
    "kretprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "nvec": ">=0",
            "nvec < minvec": "-ENOSPC",
            "nvec > maxvec": "nvec = maxvec",
            "pci_setup_msi_context(dev) != 0": "return pci_setup_msi_context(dev)",
            "!pci_setup_msi_device_domain(dev)": "return -ENODEV",
            "affd != null": {
                "nvec = irq_calc_affinity_vectors(minvec, nvec, affd)",
                "nvec < minvec": "return -ENOSPC"
            },
            "rc == 0": "return nvec",
            "rc < 0": "return rc",
            "rc < minvec": "return -ENOSPC",
            "nvec = rc"
        }
    }
},
{
    "kretprobe:pci_msi_mask_irq": {
        "description": "Generic IRQ chip callback to mask PCI MSI interrupts",
        "pre": {
            "data": "!=null",
            "desc": "msi_desc_to_pci_dev(data)",
            "desc->pci.mask_pos": "!=null",
            "desc->pci.msi_mask": "!=null",
            "lock": "properly initialized",
            "flags": "properly initialized"
        }
    }
},



{
    "kretprobe:return -ENODEV;}pc_host = container_of(dev->bus->op struct bcma_drv_pci_host, pci_ops);return bcma_core_irq(pc_host->pdev->core, 0);}EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq": {
        "description": "bcma_core_pci_pcibios_map_irq function",
        "pre": {
            "dev": "!=null",
            "dev->bus": "!=null",
            "dev->bus->ops": "!=null",
            "dev->bus->ops->read": "!=bcma_core_pci_hostmode_read_config",
            "pc_host": "!=null",
            "pc_host->pdev": "!=null",
            "pc_host->pdev->core": "!=null"
        }
    }
},
{
    "kprobe:return -ENODEV;}pc_host = container_of(dev->bus->op struct bcma_drv_pci_host, pci_ops);return bcma_core_irq(pc_host->pdev->core, 0);}EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq": {
        "description": "bcma_core_pci_pcibios_map_irq function",
        "pre": {
            "dev": "!=null",
            "dev->bus": "!=null",
            "dev->bus->ops": "!=null",
            "dev->bus->ops->read": "!=bcma_core_pci_hostmode_read_config"
        }
    }
},
{
    "kretprobe:dio_register_driver": {
        "description": "Register a new DIO driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:dio_register_driver": {
        "description": "Register a new DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:driver_register": {
        "description": "Register a driver with the DIO subsystem.",
        "pre": {
            "drv": "!=null",
            "drv->driver": "!=null",
            "dio_bus_type": "register with core"
        }
    }
},
{
    "kprobe:driver_register": {
        "description": "Register a driver with the DIO subsystem.",
        "pre": {
            "drv": {
                "driver": "!=null"
            },
            "dio_bus_type": "register with core"
        }
    }
},
{
    "kretprobe:devm_extcon_register_notifier": {
        "description": "Resource-managed extcon_register_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:devm_extcon_register_notifier": {
        "description": "Resource-managed extcon_register_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:devm_extcon_register_notifier_all": {
        "description": "Resource-managed extcon_register_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:devm_extcon_register_notifier_all": {
        "description": "Resource-managed extcon_register_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dmi_check_system": {
        "description": "Check system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:dmi_check_system": {
        "description": "Check system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image.",
        "pre": {
            "buf": "!=null",
            "dmi_ver": "unknown"
        }
    }
},
{
    "kprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image.",
        "pre": {
            "buf": "!=null",
            "buf[16]": "== 'DMI'",
            "buf[0]": "== 'SMBIOS'"
        }
    }
},
{
    "kretprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "pre": {
            "str": "!=null"
        }
    }
},


{
    "kretprobe:dmi_get_date": {
        "description": "Parse a DMI date",
        "pre": {
            "field": "!=null",
            "yearp": "!=null",
            "monthp": "!=null",
            "dayp": "!=null"
        }
    }
},
{
    "kprobe:dmi_get_date": {
        "description": "Parse a DMI date",
        "pre": {
            "field": ">=0",
            "yearp": ">=0",
            "monthp": ">=0",
            "dayp": ">=0"
        }
    }
},
{
    "kretprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field.",
        "pre": {
            "return_value": ">=0 or <0",
            "errno": "in [-ENXIO, <other negative error codes>]"
        }
    }
},
{
    "kprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field.",
        "pre": {
            "return_value": ">=0",
            "errno": "in [-ENXIO, <0]",
            "dmi_field_present": "true",
            "dmi_field_parseable": "true"
        }
    }
},
{
    "kretprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata",
        "pre": {
            "peripheral": "!=null",
            "metadata": "!=null",
            "size": ">=0",
            "ctx": "optional"
        }
    }
},
{
    "kprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata",
        "pre": {
            "peripheral": "!=null",
            "metadata": "!=null",
            "size": ">=0",
            "ctx": "optional"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading.",
        "pre": {
            "peripheral": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading.",
        "pre": {
            "peripheral": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor.",
        "pre": {
            "peripheral": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor",
        "pre": {
            "peripheral": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        },
        "post": {
            "return_value": "is a boolean"
        }
    }
},
{
    "kprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface.",
        "pre": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface.",
        "pre": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table for the IOMMU.",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table for the IOMMU.",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership",
        "pre": {
            "dev": "!=null",
            "mem_region": "!=null",
            "mem_sz": "!=null",
            "src": "!=null",
            "src_sz": "!=null",
            "dest": "!=null",
            "dest_sz": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership.",
        "pre": {
            "dev": "!=null",
            "mem_region": "!=null",
            "mem_sz": "!=null",
            "src": "!=null",
            "src_sz": "!=null",
            "dest": "!=null",
            "dest_sz": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_ocmem_lock_available": {
        "description": "Check if OCMEM lock/unlock interface is available.",
        "pre": {
            "return_value": "is_bool"
        }
    }
},
{
    "kprobe:qcom_scm_ocmem_lock_available": {
        "description": "is OCMEM lock/unlock interface available",
        "pre": {},
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "pre": {
            "id": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "pre": {
            "id": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP.",
        "pre": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP.",
        "pre": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request.",
        "pre": {
            "req": "!=null",
            "req_cnt": ">=0",
            "resp": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request.",
        "pre": {
            "req": "!=null",
            "req_cnt": "!=null",
            "resp": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_iommu_set_pt_format": {
        "description": "Sets the page table format for the specified secure ID, context number, and page table format.",
        "pre": {
            "sec_id": "!=null",
            "ctx_num": "!=null",
            "pt_fmt": "in [0, 1]"
        }
    }
},
{
    "kprobe:qcom_scm_iommu_set_pt_format": {
        "description": "Sets the page table format for the specified secure ID, context number, and page table format.",
        "pre": {
            "sec_id": "!=null",
            "ctx_num": "!=null",
            "pt_fmt": "in [0, 1]"
        }
    }
},
{
    "kretprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "pre": {
            "return_value": "==1"
        }
    }
},
{
    "kprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "pre": {
            "void": "null"
        }
    }
},
{
    "kretprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware using an OP-TEE call to start a secure boot process.",
        "pre": {
            "return_value": ">= -4095",
            "errno": "< 0"
        }
    }
},
{
    "kprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware. Uses an OP-TEE call to start a secure boot process.",
        "pre": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory using an OP-TEE call.",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory using an OP-TEE call.",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        }
    }
},
{
    "var": "!=null",
    "end": "!=null",
    "nvram_buf": "!=null",
    "sizeof(struct nvram_header)": "!=null",
    "var < end": true,
    "*var": "!=null",
    "name": "!=null",
    "val": "!=null",
    "val_len": "!=null"
},
{
    "kprobe:bcm47xx_nvram_getenv": {
        "description": "Look for name=value and return value",
        "pre": {
            "name": "!=null",
            "val": "!=null",
            "val_len": "!=null",
            "var": "!=null",
            "value": "!=null",
            "end": "!=null",
            "eq": "!=null",
            "err": "!=null",
            "nvram_len": "!=null",
            "nvram_buf": "!=null",
            "sizeof(struct nvram_header)": "!=null",
            "sizeof(nvram_buf)": "!=null",
            "var < end": true,
            "*var": "!=0"
        }
    }
},


{
    "kretprobe:smp_rmb();tegra_ivc_invalidate_frame(ivc, ivc->rx.phy ivc->rx.position, 0, ivc->frame_size);return tegra_ivc_frame_virt(ivc, &ivc->rx.map, ivc->rx.position, map);}EXPORT_SYMBOL(tegra_ivc_read_get_next_frame": {
        "description": "Order observation of ivc->rx.position potentially indicating new data before data read.",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kprobe:smp_rmb": {
        "description": "Read memory barrier that guarantees ordering of memory accesses.",
        "pre": {},
        "post": {}
    },
    "kprobe:tegra_ivc_invalidate_frame": {
        "description": "Invalidate a frame in the tegra_ivc structure.",
        "pre": {
            "ivc": "!=null",
            "ivc->rx.phys": "!=null",
            "ivc->rx.position": "!=null",
            "ivc->frame_size": "!=null"
        },
        "post": {}
    },
    "kprobe:tegra_ivc_frame_virt": {
        "description": "Get the virtual address of a frame in the tegra_ivc structure.",
        "pre": {
            "ivc": "!=null",
            "&ivc->rx.map": "!=null",
            "ivc->rx.position": "!=null",
            "map": "!=null"
        },
        "post": {}
    },
    "kprobe:EXPORT_SYMBOL(tegra_ivc_read_get_next_frame": {
        "description": "Exported symbol for tegra_ivc_read_get_next_frame function.",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        },
        "post": {}
    }
},
{
    "kretprobe:tegra_ivc_check_read": {
        "description": "Check if the tegra_ivc read operation is successful.",
        "pre": {
            "ivc": "!=null"
        },
        "post": {
            "err": "< 0"
        }
    },
    "kretprobe:tegra_ivc_advance_rx": {
        "description": "Advance the tegra_ivc receive buffer.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kretprobe:tegra_ivc_flush": {
        "description": "Flush the tegra_ivc buffer with the given parameters.",
        "pre": {
            "ivc": "!=null",
            "rx": ">= 0"
        },
        "post": {
            "ivc->rx.position": ">= ivc->tx.position"
        }
    }
},
{
    "kprobe:tegra_ivc_check_read": {
        "description": "Check if the tegra_ivc read operation is successful.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kprobe:tegra_ivc_advance_rx": {
        "description": "Advance the tegra_ivc receive buffer.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kprobe:tegra_ivc_flush": {
        "description": "Flush the tegra_ivc buffer.",
        "pre": {
            "ivc": "!=null",
            "rx": "!=null"
        }
    }
},
{
    "kretprobe:smp_wmb;tegra_ivc_advance_tx;tegra_ivc_flush": {
        "description": "Ensure our write to ivc->tx.position occurs before our read from ivc->rx.position.",
        "pre": {
            "ivc": "!=null",
            "ivc->tx.phys": "!=null",
            "ivc->tx.position": "!=null",
            "ivc->rx.position": "!=null"
        }
    }
},
{
    "kprobe:smp_wmb();tegra_ivc_advance_tx(ivc);tegra_ivc_flush(ivc, ivc->tx.phys + tx);/* * Ensure our write to ivc->tx.position occurs before our read from * ivc->rx.position.": {
        "description": "Order any possible stores to the frame before update of ivc->tx.position.",
        "pre": {
            "ivc": "!=null",
            "tx": "!=null",
            "ivc->tx.phys": "!=null",
            "tx.position": "!=null",
            "ivc->rx.position": "!=null"
        }
    }
},
{
    "kretprobe:tegra_ivc_notified": {
        "description": "Function to handle notifications in tegra_ivc",
        "pre": {
            "ivc": "!=null",
            "localremoteaction": "in [SYNCEST, SYNCACK, ACKEST, ACKACK, ACKSYNC, ESTEST, ESTACK, ESTSYNC]"
        },
        "post": {
            "conditions": {
                "SYNCEST": {
                    "counter_reset": true,
                    "state_transition": "EST",
                    "notification": true
                },
                "SYNCACK": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                },
                "ACKEST": {
                    "state_transition": "EST",
                    "notification": true
                },
                "ACKACK": {
                    "state_transition": "EST",
                    "notification": true
                },
                "ACKSYNC": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                },
                "ESTEST": {
                    "notification": false
                },
                "ESTACK": {
                    "notification": false
                },
                "ESTSYNC": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                }
            }
        }
    }
},

{
    "kretprobe:tegra_ivc_init": {
        "description": "Initialize tegra_ivc structure",
        "pre": {
            "ivc": "!=null",
            "peer": "!=null",
            "rx": "!=null",
            "rx_phys": "!=null",
            "tx": "!=null",
            "tx_phys": "!=null",
            "num_frames": ">=0",
            "frame_size": ">=0",
            "notify": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:tegra_ivc_init": {
        "description": "Initialize the tegra_ivc structure with the given parameters.",
        "pre": {
            "ivc": "!=null",
            "peer": "!=null",
            "rx": "!=null",
            "rx_phys": "!=null",
            "tx": "!=null",
            "tx_phys": "!=null",
            "num_frames": ">=0",
            "frame_size": ">=0",
            "notify": "!=null",
            "data": "!=null",
            "err": "int",
            "queue_size": "size_t"
        },
        "post": {
            "queue_size": "tegra_ivc_total_queue_size(num_frames * frame_size)",
            "err": "<0 => return err"
        }
    }
},

{
    "kprobe:meson_sm_call": {
        "description": "generic SMC32 call to the secure-monitor",
        "pre": {
            "fw": "!=null",
            "cmd_index": "!=null",
            "ret": "!=null",
            "arg0": "!=null",
            "arg1": "!=null",
            "arg2": "!=null",
            "arg3": "!=null",
            "arg4": "!=null"
        }
    }
},
{
    "kretprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">=0",
            "cmd_index": ">=0",
            "arg0": ">=0",
            "arg1": ">=0",
            "arg2": ">=0",
            "arg3": ">=0",
            "arg4": ">=0"
        }
    }
},


{
    "kretprobe:imx_scu_call_rpc": {
        "description": "SCU firmware API call",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "bool",
            "((struct imx_sc_rpc_msg *)msg)->svc": "!=null",
            "((struct imx_sc_rpc_msg *)msg)->func": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:imx_scu_call_rpc": {
        "description": "SCU firmware API call",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "bool",
            "((struct imx_sc_rpc_msg *)msg)->svc": "!=null",
            "((struct imx_sc_rpc_msg *)msg)->func": "!=null"
        }
    }
},
{
    "kretprobe:imx_sc_rm_is_resource_owned": {
        "description": "Check if a resource is owned by the SCU firmware.",
        "pre": {
            "ipc": "!=null",
            "resource": "!=null"
        }
    }
},
{
    "kprobe:imx_sc_rm_is_resource_owned": {
        "description": "Check if a resource is owned by the SCU firmware.",
        "pre": {
            "ipc": "!=null",
            "msg": "!=null",
            "hdr": "!=null",
            "hdr->ver": "==IMX_SC_RPC_VERSION",
            "hdr->svc": "==IMX_SC_RPC_SVC_RM",
            "hdr->func": "==IMX_SC_RM_FUNC_IS_RESOURCE_OWNED",
            "hdr->size": "==2",
            "msg.resource": "!=null"
        }
    }
},
{
    "kretprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP)",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP).",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        }
    }
},
{
    "kretprobe:ch = mbox_request_channel_byname": {
        "description": "Request a mailbox channel by name.",
        "pre": {
            "cl": "!=null",
            "dev": "!=null",
            "ret": "==0",
            "i": ">=0",
            "imx_sc_irq_ipc_handle": "!=null",
            "ch": "!=null",
            "imx_scu_irq_callback": "!=null"
        }
    }
},
{
    "kprobe:ch = mbox_request_channel_byname": {
        "description": "Request a mailbox channel by name.",
        "pre": {
            "cl": "!=null",
            "dev": "!=null",
            "ret": "==0",
            "i": ">=0",
            "imx_sc_irq_ipc_handle": "!=null",
            "ch": "!=null",
            "imx_scu_irq_callback": "!=null"
        }
    }
},
{
    "kretprobe:w1_register_family": {
        "description": "Register a device family driver",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kprobe:w1_register_family": {
        "description": "Register a device family driver",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kretprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kretprobe:w1_add_master_device": {
        "description": "Registers a new master device",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kprobe:w1_add_master_device": {
        "description": "Registers a new master device",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kretprobe:atomic_set": {
        "description": "Set the value of the entry associated with *dev->refcnt* to 1.",
        "pre": {
            "dev": "!=null",
            "dev->refcnt": "==1"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head *dev->slist* and *dev->async_list*.",
        "pre": {
            "dev": "!=null",
            "dev->slist": "is empty",
            "dev->async_list": "is empty"
        }
    },
    "kretprobe:mutex_init": {
        "description": "Initialize the mutex *dev->mutex*, *dev->bus_mutex*, and *dev->list_mutex*.",
        "pre": {
            "dev": "!=null",
            "dev->mutex": "is initialized",
            "dev->bus_mutex": "is initialized",
            "dev->list_mutex": "is initialized"
        }
    },
    "kretprobe:memcpy": {
        "description": "Copy the content of *device* to *dev->dev*.",
        "pre": {
            "dev": "!=null",
            "device": "!=null",
            "sizeof(struct device)": "is valid",
            "dev->dev": "is equal to *device*"
        }
    },
    "kretprobe:dev_set_name": {
        "description": "Set the name of *dev->dev* to 'w1_bus_master%u', where %u is replaced with *dev->id*.",
        "pre": {
            "dev": "!=null",
            "dev->dev": "is initialized",
            "dev->id": "is valid",
            "dev->name": "is equal to 'w1_bus_master%u', where %u is replaced with *dev->id*"
        }
    },
    "kretprobe:snprintf": {
        "description": "Format the string 'w1_bus_master%u', where %u is replaced with *dev->id*, and store it in *dev->name*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid",
            "dev->name": "is equal to the formatted string 'w1_bus_master%u', where %u is replaced with *dev->id*"
        }
    },
    "kretprobe:device_register": {
        "description": "Register the device *dev->dev* and store the return value in *err*.",
        "pre": {
            "dev": "!=null",
            "dev->dev": "is initialized",
            "err": "is valid",
            "*err": "is the return value of device_register(&dev->dev)"
        }
    }
},
{
    "kprobe:atomic_set": {
        "description": "Set the value of the entry associated with *dev->refcnt* to 1.",
        "pre": {
            "dev": "!=null",
            "dev->refcnt": "==1"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head *dev->slist*.",
        "pre": {
            "dev": "!=null",
            "dev->slist": "is empty"
        }
    },
    "kprobe:mutex_init": {
        "description": "Initialize the mutex *dev->mutex*.",
        "pre": {
            "dev": "!=null",
            "dev->mutex": "is unlocked"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy the content of *device* to *dev->dev*.",
        "pre": {
            "dev": "!=null",
            "device": "!=null",
            "sizeof(struct device)": "is valid"
        }
    },
    "kprobe:dev_set_name": {
        "description": "Set the name of *dev->dev* to \"w1_bus_master%u\", where %u is replaced with *dev->id*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid"
        }
    },
    "kprobe:snprintf": {
        "description": "Format the string \"w1_bus_master%u\" with *dev->id* and store it in *dev->name*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid",
            "sizeof(dev->name)": "is valid"
        }
    },
    "kprobe:device_register": {
        "description": "Register *dev->dev* as a device.",
        "pre": {
            "dev": "!=null",
            "err": "==0"
        }
    }
},
{
    "kretprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">=0",
            "type": "in [MBIM, QMI...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">=0",
            "type": "in [MBIM, QMI...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kretprobe:cdc_parse_cdc_header": {
        "description": "Parse the extra headers present in CDC devices.",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        },
        "post": {
            "return_value": ">= -EINVAL"
        }
    }
},
{
    "kprobe:cdc_parse_cdc_header": {
        "description": "Parse the extra headers present in CDC devices.",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:usb_serial_suspend": {
        "description": "Suspend the USB serial interface",
        "pre": {
            "serial": "!=null",
            "serial->suspend_count++": "!=0"
        }
    }
},
{
    "kprobe:usb_serial_suspend": {
        "description": "Suspend the USB serial interface",
        "pre": {
            "serial": "!=null",
            "serial->suspend_count": "==0"
        }
    }
},
{
    "kretprobe:usb_serial_resume": {
        "description": "Resume the USB serial interface.",
        "pre": {
            "serial->suspend_count": "==0",
            "serial": "!=null",
            "serial->type->resume": "!=null",
            "rv": "!=null"
        }
    }
},
{
    "kprobe:usb_serial_resume": {
        "description": "Resume the USB serial interface",
        "pre": {
            "intf": "!=null",
            "serial": "!=null",
            "rv": "int",
            "serial->suspend_count": "==0",
            "serial->type->resume": "!=null"
        }
    }
},
{
    "kretprobe:usb_wwan_dtr_rts": {
        "description": "Set the RTS and DTR states of the USB WWAN port and send setup.",
        "pre": {
            "port": "!=null",
            "on": "is_boolean",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        }
    }
},
{
    "kprobe:usb_wwan_dtr_rts": {
        "description": "Set the RTS and DTR states of the USB WWAN port and send setup.",
        "pre": {
            "port": "!=null",
            "on": "in [0, 1]"
        }
    }
},
{
    "kretprobe:usb_wwan_tiocmset": {
        "description": "Set or clear the TIOCM_RTS and TIOCM_DTR flags for a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "set": "!=0",
            "clear": "!=0",
            "port": "!=null",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        },
        "post": {
            "portdata.rts_state": "in [0, 1]",
            "portdata.dtr_state": "in [0, 1]"
        }
    }
},
{
    "kprobe:usb_wwan_tiocmset": {
        "description": "Sets the TIOCM_RTS and TIOCM_DTR bits in the portdata structure based on the set and clear arguments.",
        "pre": {
            "tty": "!=null",
            "set": "!=null",
            "clear": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        },
        "post": {
            "portdata.rts_state": "in [0, 1]",
            "portdata.dtr_state": "in [0, 1]"
        }
    }
},
{
    "kretprobe:usb_wwan_write": {
        "description": "Write data to a USB WWAN device.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "portdata": "!=null",
            "intfdata": "!=null",
            "i": ">=0",
            "left": ">=0",
            "todo": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kprobe:usb_wwan_write": {
        "description": "Write data to a USB WWAN device.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "portdata": "!=null",
            "intfdata": "!=null",
            "i": ">=0",
            "left": ">=0",
            "todo": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kretprobe:usb_wwan_chars_in_buffer": {
        "description": "Calculate the number of characters in the buffer of a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "i": ">=0",
            "data_len": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kprobe:usb_wwan_chars_in_buffer": {
        "description": "Calculate the number of characters in the buffer of a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "i": ">=0",
            "data_len": ">=0",
            "this_urb": "!=null"
        }
    }
},



{
    "kprobe:spin_lock_irq": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:--intfdata->open_ports": {
        "description": "Decrement the value of open_ports in intfdata by 1.",
        "pre": {
            "intfdata": "!=null",
            "intfdata->open_ports": ">0"
        }
    },
    "kprobe:intfdata->interface->needs_remote_wakeup": {
        "description": "Set the value of needs_remote_wakeup in intfdata's interface to 0.",
        "pre": {
            "intfdata": "!=null",
            "intfdata->interface": "!=null"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release the spinlock and enable interrupts.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:gemini_sata_bridge_enabled": {
        "description": "Check if the SATA bridge is enabled for the given sata_gemini structure and is_ata1 flag.",
        "pre": {
            "sg->sata_bridge": "==true",
            "sg->muxmode": "in [GEMINI_MUXMODE_2, GEMINI_MUXMODE_3]",
            "!is_ata1": "==true when sg->muxmode == GEMINI_MUXMODE_2",
            "is_ata1": "==true when sg->muxmode == GEMINI_MUXMODE_3"
        },
        "post": {
            "return": "==true"
        }
    }
},
{
    "kprobe:gemini_sata_bridge_enabled": {
        "description": "Check if the Gemini SATA bridge is enabled for the given sata_gemini structure and is_ata1 flag.",
        "pre": {
            "sg->sata_bridge": "!=null",
            "sg->muxmode": "in [GEMINI_MUXMODE_2, GEMINI_MUXMODE_3]",
            "is_ata1": "in [true, false]",
            "sg->muxmode == GEMINI_MUXMODE_2 && !is_ata1": "false",
            "sg->muxmode == GEMINI_MUXMODE_3 && is_ata1": "false"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kretprobe:gemini_sata_setup_bridge": {
        "description": "Setup the Gemini SATA bridge.",
        "pre": {
            "sg": "!=null",
            "bridge": "!=null",
            "pclk": "!=null",
            "ret": "int",
            "ret == 0": true,
            "bridge == 0 || bridge == 1": true
        }
    }
},
{
    "kprobe:gemini_sata_setup_bridge": {
        "description": "Setup the Gemini SATA bridge.",
        "pre": {
            "sg": "!=null",
            "bridge": "!=null",
            "pclk": "!=null",
            "ret": "int"
        }
    }
},


{
    "kretprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine.",
        "pre": {
            "ap": "!=null"
        }
    }
},
{
    "kprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine.",
        "pre": {
            "ap": "!=null"
        }
    }
},
{
    "kretprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading.",
        "pre": {
            "indio_dev": "!=null",
            "ev_code": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading.",
        "pre": {
            "indio_dev": "!=null",
            "ev_code": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "!=null"
        }
    }
},
{
    "kprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property.",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__iio_device_register": {
        "description": "Register an IIO device",
        "pre": {
            "indio_dev": "!=null",
            "this_mod": "!=null",
            "indio_dev->info": "!=null"
        }
    }
},
{
    "kprobe:__iio_device_register": {
        "description": "Register an IIO device.",
        "pre": {
            "indio_dev": {
                "info": "!=null"
            },
            "this_mod": "!=null"
        }
    }
},
{
    "kretprobe:iio_read_channel_ext_info": {
        "description": "Read channel-specific extended information and write it to the buffer.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:iio_read_channel_ext_info": {
        "description": "Read extended information about a channel.",
        "pre": {
            "dev": "!=null",
            "attr": "any",
            "buf": "any"
        }
    }
},
{
    "kretprobe:dev_set_name": {
        "description": "Set the name used for the sysfs directory etc.",
        "pre": {
            "trig_info->dev": "!=null",
            "trig_info->id": "!=null"
        }
    },
    "kretprobe:device_add": {
        "description": "Add the device to the list of available triggers held by the IIO core.",
        "pre": {
            "ret": "==0"
        }
    },
    "kretprobe:iio_trigger_register": {
        "description": "Register the IIO trigger.",
        "pre": {
            "trig_info": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:dev_set_name": {
        "description": "Set the name of the device.",
        "pre": {
            "trig_info->dev": "!=null",
            "trig_info->id": "!=null"
        }
    },
    "kprobe:device_add": {
        "description": "Add the device to the list of available triggers held by the IIO core.",
        "pre": {
            "ret": "==0"
        }
    },
    "kprobe:iio_trigger_register": {
        "description": "Register the IIO trigger.",
        "pre": {
            "trig_info": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kretprobe:device_del": {
        "description": "Unregister an IIO trigger device.",
        "pre": {
            "trig_info": "!=null",
            "trig_info->dev": "!=null",
            "iio_trigger_list_lock": "locked",
            "iio_trigger_ida": "initialized",
            "trig_info->list": "in iio_trigger_list",
            "trig_info->id": "in iio_trigger_ida"
        },
        "post": {
            "iio_trigger_list_lock": "unlocked",
            "iio_trigger_ida": "updated"
        }
    }
},
{
    "kprobe:device_del": {
        "description": "Unregister an IIO trigger device.",
        "pre": {
            "trig_info": "!=null",
            "trig_info->dev": "!=null",
            "iio_trigger_list_lock": "locked",
            "trig_info->list": "in iio_trigger_list",
            "iio_trigger_ida": "initialized",
            "trig_info->id": "in iio_trigger_ida"
        },
        "post": {
            "iio_trigger_list_lock": "unlocked"
        }
    }
},
{
    "kretprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device.",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device.",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},




{
    "kretprobe:qcom_vadc_map_temp_voltage": {
        "description": "Map temperature to voltage using linear interpolation.",
        "pre": {
            "pts": "!=null",
            "tablesize": ">0",
            "input": "!=null"
        }
    }
},

{
    "kretprobe:is_stm32_lptim_trigger": {
        "description": "Check if the trigger is a valid STM32 IIO Low-Power Timer Trigger",
        "pre": {
            "trig": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:is_stm32_lptim_trigger": {
        "description": "Check if the trigger is a valid STM32 IIO Low-Power Timer Trigger.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex referenced by &priv->lock.",
        "pre": {
            "priv": {
                "lock": "!=null"
            },
            "sms": 6,
            "priv->enabled": false
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex associated with priv->lock.",
        "pre": {
            "priv->lock": "!=null",
            "sms": "==6",
            "!priv->enabled": "true"
        }
    }
},
{
    "kretprobe:amba_driver_register": {
        "description": "Register an AMBA device driver with the Linux device model core. If devices pre-exist, the driver's probe function will be called.",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kretprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:amba_device_register": {
        "description": "Register an AMBA device",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:amba_device_register": {
        "description": "Register an AMBA device",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:amba_request_regions": {
        "description": "Request all memory regions associated with the device.",
        "pre": {
            "dev": "!=null",
            "name": "!=null or ==null"
        }
    }
},
{
    "kprobe:amba_request_regions": {
        "description": "Request all memory regions associated with the device.",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:amba_release_regions": {
        "description": "Release mem regions associated with device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_release_regions": {
        "description": "Release mem regions associated with device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_init": {
        "description": "Initialize the MSI context",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        }
    }
},
{
    "kprobe:ntb_msi_init": {
        "description": "Initialize the MSI context",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows",
        "pre": {
            "ntb": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kretprobe:ntbm_msi_request_threaded_irq": {
        "description": "Allocate an MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "!=null",
            "name": "!=null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_request_threaded_irq": {
        "description": "Allocate an MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "!=null",
            "name": "!=null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        }
    }
},
{
    "kretprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt",
        "pre": {
            "ntb": "!=null",
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt",
        "pre": {
            "ntb": "!=null",
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null",
            "msi_addr": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null",
            "msi_addr": "!=null"
        }
    }
},
{
    "kretprobe:tty_register_ldisc": {
        "description": "Install a line discipline",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_register_ldisc": {
        "description": "Install a line discipline",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_init": {
        "description": "Initialize tty_port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_init": {
        "description": "Initialize tty_port",
        "pre": {
            "port": "!=null"
        }
    }
},


{
    "kretprobe:tty_port_tty_set": {
        "description": "Set the tty of a port",
        "pre": {
            "port": "!=null",
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_port_tty_set": {
        "description": "Set the tty of a port",
        "pre": {
            "port": "!=null",
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "tty->termios.c_cflag & HUPCL": "==0",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "tty->termios.c_cflag & HUPCL": "!=0",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_raise_dtr_rts": {
        "description": "Raise DTRRTS",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_raise_dtr_rts": {
        "description": "Raise DTRRTS",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference.",
        "pre": {
            "port": "!=null",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_block_til_ready": {
        "description": "Waiting logic for tty open",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_port_block_til_ready": {
        "description": "Waiting logic for tty open",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_close_start": {
        "description": "Function to close a tty port",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null",
            "tty_lock": "held"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:tty_port_close_start": {
        "description": "Called before closing a TTY port.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null",
            "locking": "TTY lock held",
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:tty_port_open": {
        "description": "Generic tty->ops->open handler",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_port_open": {
        "description": "generic tty->ops->open handler",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes",
        "pre": {
            "tty": "!=null",
            "sig": "!=null"
        }
    }
},
{
    "kprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes",
        "pre": {
            "tty": "!=null",
            "sig": "!=null"
        }
    }
},

{
    "kprobe:.c_iflag = ICRNL | IXON,.c_oflag = OPOST | ONLCR,.c_cflag = B38400 | CS8 | CREAD | HUPCL,.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN,.c_cc = INIT_C_CC,.c_ispeed = 38400,.c_ospeed = 38400,/* .c_line = N_TTY,": {
        "description": "Set the termios structure for tty standard input/output.",
        "pre": {
            ".c_iflag": "ICRNL | IXON",
            ".c_oflag": "OPOST | ONLCR",
            ".c_cflag": "B38400 | CS8 | CREAD | HUPCL",
            ".c_lflag": "ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN",
            ".c_cc": "INIT_C_CC",
            ".c_ispeed": 38400,
            ".c_ospeed": 38400
        }
    }
},
{
    "kretprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:__tty_hangup": {
        "description": "Actual handler for hangup events",
        "pre": {
            "tty": "!=null",
            "exit_session": "is int"
        }
    }
},
{
    "kprobe:__tty_hangup": {
        "description": "Actual handler for hangup events",
        "pre": {
            "tty": "!=null",
            "exit_session": "int"
        }
    }
},
{
    "kretprobe:tty_vhangup": {
        "description": "Process vhangup for tty",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_vhangup": {
        "description": "Process vhangup for tty",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "pre": {
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "pre": {
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:stop_tty": {
        "description": "Perform flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->ops->stop": "!=null"
        }
    }
},
{
    "kprobe:stop_tty": {
        "description": "Perform flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->ops->stop": "!=null"
        }
    }
},
{
    "kretprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->flow.tco_stopped": "==false",
            "tty->flow.stopped": "=false",
            "tty->ops.start": "!=null"
        },
        "post": {
            "tty->ops.start(tty)": "called",
            "tty_wakeup(tty)": "called"
        }
    }
},
{
    "kprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->flow.tco_stopped": "==false",
            "tty->ops->start": "!=null"
        }
    }
},
{
    "if (cons_filp)": {
        "description": "Check if `cons_filp` is not NULL.",
        "pre": {
            "cons_filp": "!=null"
        }
    }
},
{
    "if (cons_filp)": {
        "description": "Check if `cons_filp` is not null.",
        "pre": {
            "cons_filp": "!=null"
        }
    }
},
{
    "kretprobe:tty_do_resize": {
        "description": "Resize event for tty",
        "pre": {
            "tty": "!=null",
            "ws": "!=null"
        }
    }
},
{
    "kprobe:tty_do_resize": {
        "description": "Resize event for tty",
        "pre": {
            "tty": "!=null",
            "ws": "!=null",
            "termios_variables_updated": true,
            "signals_sent": true
        }
    }
},
{
    "kretprobe:do_SAK": {
        "description": "Executes do_SAK() into process context. Less stack use in devfs functions. alloc_tty_struct() always uses kmalloc().",
        "pre": {
            "context": "in [process]",
            "stack_use": "<= [devfs_functions]",
            "alloc_tty_struct": "uses [kmalloc]"
        }
    }
},

{
    "kretprobe:tty_register_device": {
        "description": "Register a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kprobe:tty_register_device": {
        "description": "Register a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kretprobe:tty_unregister_device": {
        "description": "Unregister a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:tty_unregister_device": {
        "description": "Unregister a tty device",
        "pre": {
            "driver": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:__tty_alloc_driver": {
        "description": "Allocate tty driver",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [TTY_DRIVER_1, TTY_DRIVER_2, ...]"
        }
    }
},
{
    "kprobe:__tty_alloc_driver": {
        "description": "Allocate tty driver",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [TTY_DRIVER_1, TTY_DRIVER_2, TTY_DRIVER_3]"
        }
    }
},
{
    "kretprobe:INIT_WORK": {
        "description": "Release a tty kref",
        "pre": {
            "tty": "!=null",
            "driver": "!=null",
            "owner": "!=null",
            "tty->files_lock": "unlocked",
            "tty->tty_files": "not in list",
            "tty->ctrl.pgrp": "pid released",
            "tty->ctrl.session": "pid released"
        }
    }
},
{
    "kprobe:INIT_WORK": {
        "description": "Initialize a work item and schedule it for execution.",
        "pre": {
            "tty": "!=null",
            "driver": "!=null",
            "owner": "!=null",
            "tty->files_lock": "locked",
            "tty->tty_files": "not in list",
            "tty->ctrl.pgrp": "valid PID",
            "tty->ctrl.session": "valid PID"
        }
    },
    "kprobe:schedule_work": {
        "description": "Schedule a work item for execution.",
        "pre": {
            "tty->hangup_work": "initialized"
        }
    }
},
{
    "kretprobe:tty_register_driver": {
        "description": "Register a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_register_driver": {
        "description": "Register a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},


{
    "kretprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        },
        "post": {
            "speed": "!=null"
        }
    }
},
{
    "kretprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack. Takes the termios rwsem to protect against parallel throttle/unthrottle and also to ensure the driver can consistently reference its own termios data at this point when implementing software flow control. Drivers should, however, remember that the stack can issue a throttle, then change flow control method, then unthrottle.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:tty_termios_copy_hw": {
        "description": "Copy hardware settings from old termios to new termios",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_copy_hw": {
        "description": "Copy hardware settings from old termios to new termios.",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_hw_change": {
        "description": "Check for setting change",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "bits_changed": "in [true, false]",
            "speed_change_needed": "in [true, false]"
        }
    }
},
{
    "kprobe:tty_termios_hw_change": {
        "description": "Check for setting change between two termios structures or a speed change is needed.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:return_tty_mode_ioctl": {
        "description": "Helper function for handling ioctl commands in the n_tty driver.",
        "pre": {
            "tty": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:return_tty_mode_ioctl": {
        "description": "Helper function for handling ioctl commands in the n_tty driver.",
        "pre": {
            "tty": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:tty_insert_flip_string_flags": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:tty_insert_flip_string_flags": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:__tty_insert_flip_char": {
        "description": "Add one character to the tty buffer",
        "pre": {
            "port": "!=null",
            "ch": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kprobe:__tty_insert_flip_char": {
        "description": "Add one character to the tty buffer",
        "pre": {
            "port": "!=null",
            "ch": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:tty_flip_buffer_push": {
        "description": "Push terminal buffers",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_flip_buffer_push": {
        "description": "Push terminal buffers",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:orig_log_level = console_loglevel;console_loglevel = CONSOLE_LOGLEVEL_DEFAULT;op_p = __sysrq_get_key_op(key);if (op_p)": {
        "description": "Handle sysrq key operation",
        "pre": {
            "key": "!=null",
            "check_mask": "!=null",
            "orig_log_level": "!=null",
            "orig_suppress_printk": "!=null",
            "i": "!=null",
            "suppress_printk": "!=null"
        }
    }
},
{
    "kprobe:orig_log_level = console_loglevel;console_loglevel = CONSOLE_LOGLEVEL_DEFAULT;op_p = __sysrq_get_key_op(key);if (op_p)": {
        "description": "Handle sysrq key operation",
        "pre": {
            "key": "!=null",
            "check_mask": "!=null",
            "orig_log_level": "!=null",
            "orig_suppress_printk": "!=null",
            "i": "!=null",
            "suppress_printk": "!=null"
        }
    }
},
{
    "kretprobe:fg_console": {
        "description": "Helper for managing virtual consoles.",
        "pre": {
            "fg_console": "!=null",
            "last_console": "!=null",
            "want_console": "!=null",
            "saved_variants": "!=null"
        }
    }
},
{
    "kprobe:int_fg_console": {
        "description": "Helper function for fg_console",
        "pre": {
            "fg_console": "!=null",
            "last_console": "!=null",
            "want_console": "!=null",
            "saved_variants": "!=null"
        }
    }
},


{
    "kretprobe:return_resize_screen": {
        "description": "This function is being called here to cover the case where the userspace calls the FBIOPUT_VSCREENINFO twice, passing the same fb_var_screeninfo containing the fields yresxres equal to a number non-multiple of vc_font.height and yres_virtualxres_virtual equal to number lesser than the vc_font.height and yresxres. In the second call, the struct fb_var_screeninfo isn't being modified by the underlying driver because of the if above, and this causes the fbcon_display->vrows to become negative and it eventually leads to out-of-bound access by the imageblit function. To give the correct values to the struct and to not have to deal with possible errors from the code below, we call the resize_screen here as well.",
        "pre": {
            "vc": "!=null",
            "new_cols": "<= VC_MAXCOL",
            "new_rows": "<= VC_MAXROW",
            "new_screen_size": "> KMALLOC_MAX_SIZE",
            "!new_screen_size": "!=null",
            "newscreen": "!=null",
            "vc->vc_uni_lines": "!=null"
        }
    }
},
{
    "kprobe:resize_screen": {
        "description": "Resizes the screen based on the given parameters.",
        "pre": {
            "vc": "!=null",
            "new_cols": "!=null",
            "new_rows": "!=null",
            "user": "!=null",
            "new_screen_size": "> KMALLOC_MAX_SIZE || == 0",
            "newscreen": "==null",
            "vc->vc_uni_lines": "!=null"
        }
    }
},
{
    "kretprobe:conswitchp": {
        "description": "Description of the conswitchp function",
        "pre": {
            "con_is_bound(csw)": true,
            "con_driver_map[i]": "!= null",
            "con_driver_map[i]": "!= csw",
            "con_is_bound(defcsw)": false
        }
    }
},



{
    "kretprobe:give_up_console": {
        "description": "Unregister console driver",
        "pre": {
            "csw": "!=null"
        }
    }
},


{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},


{
    "kretprobe:con_set_default_unimap": {
        "description": "Set default unicode map for the console being updated.",
        "pre": {
            "vc": "!=null",
            "console_lock": "held",
            "font": "exists in uni_hash.tbl"
        }
    }
},
{
    "kprobe:con_set_default_unimap": {
        "description": "Set default unicode map for the console.",
        "pre": {
            "vc": "!=null"
        }
    }
},
{
    "kretprobe:con_copy_unimap": {
        "description": "Copy unimap between two virtual terminals.",
        "pre": {
            "dst_vc": "!=null",
            "src_vc": "!=null"
        }
    }
},


{
    "kprobe:sunserial_register_minors": {
        "description": "Register the driver on the first call",
        "pre": {
            "drv": "!=null",
            "count": "!=null"
        }
    },
    "kprobe:uart_register_driver": {
        "description": "Register the UART driver",
        "pre": {
            "drv": "!=null",
            "drv->nr": "==count"
        }
    }
},
{
    "kretprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate for a mouse.",
        "pre": {
            "mouse_got_break": "==true",
            "ctr": "<8"
        }
    }
},
{
    "kprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate for a mouse.",
        "pre": {
            "mouse_got_break": "==1",
            "ctr": "<8"
        }
    }
},
{
    "kretprobe:uart_write_wakeup": {
        "description": "Schedule write processing",
        "pre": {
            "port": "!=null",
            "port->lock": "held",
            "port->transmit_buffer_size": "< threshold"
        }
    }
},
{
    "kprobe:uart_write_wakeup": {
        "description": "Schedule write processing for a specific port.",
        "pre": {
            "port": "!=null",
            "port->lock": "held"
        }
    }
},
{
    "kretprobe:uart_update_timeout": {
        "description": "Update per-port frame timing information",
        "pre": {
            "port": "!=null",
            "cflag": "!=null",
            "baud": "!=null"
        }
    }
},
{
    "kprobe:uart_update_timeout": {
        "description": "Update per-port frame timing information",
        "pre": {
            "port": "!=null",
            "cflag": "!=null",
            "baud": "!=null"
        }
    }
},
{
    "kretprobe:uart_get_baud_rate": {
        "description": "Return baud rate for a particular port",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:uart_get_baud_rate": {
        "description": "Return baud rate for a particular port.",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:uart_get_divisor": {
        "description": "Return uart clock divisor",
        "pre": {
            "port": "!=null",
            "baud": "!=null",
            "baud_base": "!=null",
            "custom_divisor": "!=38400"
        }
    }
},
{
    "kprobe:uart_get_divisor": {
        "description": "Return uart clock divisor",
        "pre": {
            "port": "!=null",
            "baud": "!=null",
            "baud_base": "!=null",
            "custom_divisor": "!=38400"
        }
    }
},
{
    "kretprobe:if (!console_suspend_enabled && uart_console(uport))": {
        "description": "Check if the console is not suspended and the UART console is enabled.",
        "pre": {
            "console_suspend_enabled": "== false",
            "uart_console(uport)": "!= 0"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the console is not suspended and the UART console is enabled for the given uart_port.",
        "pre": {
            "console_suspend_enabled": "==false",
            "uart_console(uport)": "==true"
        }
    }
},
{
    "kretprobe:uart_console": {
        "description": "Check if the UART console is active for the given UART port.",
        "pre": {
            "drv": "!=null",
            "uport": "!=null",
            "state": "!=null",
            "port": "!=null",
            "tty_dev": "!=null",
            "match": "!=null",
            "termios": "!=null",
            "port->mutex": "locked",
            "tty_dev": "child of uport->dev with match and serial_match_port",
            "uport->suspended": "false",
            "device_may_wakeup(tty_dev)": "true",
            "irqd_is_wakeup_set(irq_get_irq_data(uport->irq))": "true",
            "disable_irq_wake(uport->irq)": "called",
            "put_device(tty_dev)": "called",
            "port->mutex": "unlocked"
        }
    }
},
{
    "kprobe:uart_console": {
        "description": "Check if the UART console is active for the given UART port.",
        "pre": {
            "uport": "!=null"
        }
    }
},
{
    "kretprobe:uart_register_driver": {
        "description": "Register a driver with the uart core layer",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kprobe:uart_register_driver": {
        "description": "Register a driver with the uart core layer",
        "pre": {
            "drv": {
                "port": "==null"
            }
        }
    }
},
{
    "kretprobe:uart_unregister_driver": {
        "description": "Remove a driver from the uart core layer.",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kprobe:uart_unregister_driver": {
        "description": "Remove a driver from the uart core layer",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kretprobe:uart_match_port": {
        "description": "Are the two ports equivalent?",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        }
    }
},
{
    "kprobe:uart_match_port": {
        "description": "Are the two ports equivalent?",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        }
    }
},
{
    "kretprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kretprobe:serial8250_resume_port": {
        "description": "Resume one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kprobe:serial8250_resume_port": {
        "description": "Resume one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},


{
    "kretprobe:serial8250_isa_devs": {
        "description": "This function registers and unregisters 16x50 serial ports at runtime to support PCMCIA modems and PCI multiport cards.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:serial8250_unregister_port": {
        "description": "Unregister a serial port from the 8250 serial driver.",
        "pre": {
            "i": "!=null"
        }
    },
    "kprobe:serial8250_suspend": {
        "description": "Suspend the 8250 serial driver for a platform device.",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    },
    "kprobe:serial8250_resume": {
        "description": "Resume the 8250 serial driver for a platform device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:serial8250_probe": {
        "description": "Probe the 8250 serial driver for a platform device.",
        "pre": {}
    },
    "kprobe:serial8250_remove": {
        "description": "Remove the 8250 serial driver for a platform device.",
        "pre": {}
    }
},
{
    "kretprobe:serial8250_rpm_get": {
        "description": "Retrieve the RPM value for the serial port.",
        "pre": {
            "up": "!=null",
            "port": "!=null",
            "flags": "!=null",
            "cval": "!=null",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:serial8250_rpm_get": {
        "description": "Get the RPM value for the serial port.",
        "pre": {
            "up": "!=null",
            "port->lock": "!=null",
            "cval": "any",
            "baud": "any",
            "quot": "any",
            "frac": "any"
        }
    }
},

{
    "kprobe:convert_ifc_address": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null",
            "addr_base": "is a valid physical address"
        }
    }
},
{
    "kretprobe:fsl_ifc_find": {
        "description": "Find IFC bank",
        "pre": {
            "addr_base": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:fsl_ifc_find": {
        "description": "Find IFC bank",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:of_get_min_tck": {
        "description": "Extract min timing values for ddr",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_get_min_tck": {
        "description": "Extract min timing values for DDR.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_ddr_timings": {
        "description": "Extracts the DDR timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kprobe:of_get_ddr_timings": {
        "description": "Extracts the DDR timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "in [LPDDR2, S2S4]",
            "nr_frequencies": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr3_get_min_tck": {
        "description": "Extract min timing values for lpddr3",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_min_tck": {
        "description": "Extract min timing values for lpddr3",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr3_get_ddr_timings": {
        "description": "Extracts the lpddr3 timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_ddr_timings": {
        "description": "Extracts the lpddr3 timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of banks referenced by a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of banks referenced by a device",
        "pre": {
            "dev": "!=null",
            "dev.child_of": "NEMC",
            "return": ">=0"
        }
    }
},
{
    "kretprobe:jz4780_nemc_set_type": {
        "description": "Set the type of device connected to a bank",
        "pre": {
            "dev": "!=null",
            "bank": "unsigned int",
            "type": "enum jz4780_nemc_bank_type"
        }
    }
},

{
    "kretprobe:jz4780_nemc_assert": {
        "description": "(De-)asserts the chip enable pin for the NAND device connected to the specified bank.",
        "pre": {
            "dev": "!=null",
            "bank": "!=null",
            "assert": "in [true, false]"
        }
    }
},
{
    "kprobe:jz4780_nemc_assert": {
        "description": "(De-)assert a NAND device's chip enable pin",
        "pre": {
            "dev": "!=null",
            "bank": "!=null",
            "assert": "!=null"
        }
    }
},
{
    "kretprobe:regmap_update_bits": {
        "description": "Update bits in the regmap",
        "pre": {
            "rpc->regmap": "!=null",
            "RPCIF_PHYCNT": "!=null",
            "RPCIF_PHYCNT_HS": "!=null",
            "0": "!=null",
            "RPCIF_PHYCNT_PHYMEM_MASK": "!=null",
            "RPCIF_PHYCNT_PHYMEM(hyperflash ? 3 : 0)": "!=null"
        }
    }
},
{
    "kprobe:regmap_update_bits": {
        "description": "Update bits in the regmap",
        "pre": {
            "rpc->regmap": "!=null",
            "RPCIF_PHYCNT": "!=null",
            "RPCIF_PHYCNT_HS": "!=null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "bytes_left": ">= max",
            "nbytes": "in [1, 2, 4, 8]",
            "bytes_left > nbytes": true,
            "nbytes == 8": false
        }
    }
},
{
    "kretprobe:gpmc_cs_disable_mem": {
        "description": "Disable CS while changing base address and size mask.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num"
        }
    },
    "kretprobe:gpmc_cs_set_memconf": {
        "description": "Set memory configuration for CS.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num",
            "res->start": "!= null",
            "resource_size(res)": "!= null"
        },
        "post": {
            "r": "< 0"
        }
    }
},
{
    "kprobe:gpmc_cs_disable_mem": {
        "description": "Disable CS while changing base address and size mask.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num"
        }
    },
    "kprobe:gpmc_cs_set_memconf": {
        "description": "Set memory configuration for CS.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num",
            "res->start": "!= null",
            "resource_size(res)": "!= null"
        }
    }
},
{
    "kretprobe:gpmc_configure": {
        "description": "Write request to configure gpmc",
        "pre": {
            "cmd": "!=null",
            "wval": "!=null"
        },
        "post": {
            "return": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
        }
    }
},
{
    "kprobe:gpmc_configure": {
        "description": "Write request to configure gpmc",
        "pre": {
            "cmd": "!=null",
            "wval": "!=null"
        }
    }
},
{
    "kretprobe:vfio_info_cap_add": {
        "description": "Add a vfio_info_cap_header to the caps list.",
        "pre": {
            "caps": "!=null"
        }
    }
},

{
    "kretprobe:vfio_pin_pages": {
        "description": "Pin pages for VFIO device",
        "pre": {
            "device": "!=null",
            "iova": "!=null",
            "npage": "!=null",
            "prot": "!=null",
            "pages": "!=null",
            "group->container": "cannot change while a vfio device is open"
        },
        "post": {
            "return": "-EINVAL",
            "conditions": [
                "!pages",
                "!npage",
                "WARN_ON(!vfio_assert_device_open(device))",
                "vfio_device_has_container(device)",
                "vfio_device_container_pin_pages(device, iova, npage, prot, pages)",
                "device->iommufd_access"
            ]
        }
    }
},
{
    "kprobe:vfio_pin_pages": {
        "description": "Pin pages for VFIO device",
        "pre": {
            "device": "!=null",
            "iova": "!=null",
            "npage": "!=null",
            "prot": "!=null",
            "pages": "!=null",
            "group->container": "cannot change while a vfio device is open"
        }
    }
},
{
    "kretprobe:vfio_dma_rw": {
        "description": "Perform DMA read or write operation on the VFIO device.",
        "pre": {
            "device": "!=null",
            "iova": "<= ULONG_MAX",
            "data": "!=null",
            "len": "> 0",
            "write": "bool"
        }
    }
},
{
    "kprobe:vfio_dma_rw": {
        "description": "Perform read or write operation on the VFIO device's DMA memory.",
        "pre": {
            "device": "!=null",
            "iova": "<=ULONG_MAX",
            "data": "!=null",
            "len": ">0",
            "write": "bool"
        }
    }
},


{
    "kretprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": "< 0"
        }
    }
},
{
    "kprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mdev_unregister_driver": {
        "description": "Unregister an MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdev_unregister_driver": {
        "description": "Unregister MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pps_register_source": {
        "description": "Add a PPS source in the system",
        "pre": {
            "info": "!=null",
            "default_params": "!=null"
        }
    }
},
{
    "kprobe:pps_register_source": {
        "description": "Add a PPS source in the system",
        "pre": {
            "info": "!=null",
            "default_params": "!=null"
        }
    }
},
{
    "kretprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system",
        "pre": {
            "pps": "!=null"
        }
    }
},
{
    "kprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system",
        "pre": {
            "pps": "!=null"
        }
    }
},




{
    "kretprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "Destroy the rpmsg character device endpoint device.",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "eptdev": "!=null",
            "ept_lock": "!=null",
            "rpdev": "in [null, !=null]",
            "ept": "in [null, !=null]"
        }
    }
},
{
    "kprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "Destroy the rpmsg character device endpoint device.",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "eptdev": "!=null",
            "eptdev->default_ept": "==false",
            "eptdev->ept": "==null",
            "eptdev->ept_lock": "is unlocked"
        }
    }
},
{
    "kretprobe:qcom_smd_register_edge": {
        "description": "Register an edge based on a device_node",
        "pre": {
            "parent": "!=null",
            "node": "!=null"
        }
    }
},

{
    "kretprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children.",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint",
        "pre": {
            "ept": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint",
        "pre": {
            "ept": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_send": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_send": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_sendto": {
        "description": "Send a message across to the remote processor, specifying the destination address.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_sendto": {
        "description": "Send a message across to the remote processor, specifying the destination address.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_send_offchannel": {
        "description": "send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:rpmsg_send_offchannel": {
        "description": "Send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_trysend": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_trysend": {
        "description": "send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_trysendto": {
        "description": "Send a message across to the remote processor, specifying the destination.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_trysendto": {
        "description": "Send a message across to the remote processor, specifying the destination.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers.",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        },
        "post": {
            "return_value": "in [POLLIN, POLLOUT, POLLERR, POLLHUP, POLLNVAL]"
        }
    }
},
{
    "kprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers.",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_trysend_offchannel": {
        "description": "Send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_trysend_offchannel": {
        "description": "send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message.",
        "pre": {
            "ept": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message.",
        "pre": {
            "ept": "!=null"
        }
    }
},


{
    "kretprobe:__register_rpmsg_driver": {
        "description": "Register an rpmsg driver with the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__register_rpmsg_driver": {
        "description": "Register an rpmsg driver with the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null"
        },
        "post": {
            "return": "in [0, error_value]"
        }
    }
},
{
    "kprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev",
        "pre": {
            "rpdev": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev",
        "pre": {
            "rpdev": "!=null"
        }
    }
},

{
    "kprobe:blackhole_netdev": {
        "description": "A device used for dsts that are marked expired!",
        "pre": {
            "blackhole_netdev": "!=null"
        }
    }
},
{
    "kretprobe:mii_link_ok": {
        "description": "Checks if the MII reports link status upok.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_link_ok": {
        "description": "Check if the MII reports link status upok.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface",
        "pre": {
            "mii": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null",
            "ecmd_cleared": "==false"
        }
    }
},
{
    "kprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null",
            "cmd_cleared": "==false"
        }
    }
},
{
    "kprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd.",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd.",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in cmd.",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return_value": ">= -1"
        }
    }
},
{
    "kprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in cmd.",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_link": {
        "description": "Check MII link status",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_link": {
        "description": "Check MII link status",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_media": {
        "description": "Check the MII interface for a carrier speed duplex change",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "!=null",
            "init_media": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:mii_check_media": {
        "description": "Check the MII interface for a carrier speed duplex change.",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "in [0, 1]",
            "init_media": "in [0, 1]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null",
            "duplex_chg_out": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null",
            "duplex_chg_out": "!=null"
        }
    }
},
{
    "kretprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "ret": "in [0, 1]"
        }
    }
},
{
    "kprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null"
        }
    }
},
{
    "kretprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null",
            "devad": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "sense": "!=null"
        }
    }
},
{
    "kprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register.",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null",
            "devad": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "sense": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise.",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": "!=null"
        }
    }
},
{
    "kprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise.",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface",
        "pre": {
            "mdio": "!=null"
        }
    }
},
{
    "kprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface",
        "pre": {
            "mdio": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_gset_npage": {
        "description": "get settings for ETHTOOL_GSET",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kprobe:mdio45_ethtool_gset_npage": {
        "description": "get settings for ETHTOOL_GSET",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "get settings for ETHTOOL_GLINKSETTINGS",
        "pre": {
            "mdio": "!=null",
            "cmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "get settings for ETHTOOL_GLINKSETTINGS",
        "pre": {
            "mdio": "!=null",
            "cmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kretprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null"
        }
    }
},


{
    "kretprobe:s->hdlcrx.bitstream >>= 16;s->hdlcrx.bitstream |= word << 16;s->hdlcrx.bitbuf >>= 16;s->hdlcrx.bitbuf |= word << 16;s->hdlcrx.numbits += 16;for(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00, mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; i >= 0; i--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1, mask5 <<= 1, mask6 = (mask6 << 1) | 1)": {
        "description": "The given function performs various bit operations on the hdlcrx structure.",
        "pre": {
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "word": "!=null",
            "i": ">= 0",
            "mask1": "!=null",
            "mask2": "!=null",
            "mask3": "!=null",
            "mask4": "!=null",
            "mask5": "!=null",
            "mask6": "!=null"
        }
    }
},
{
    "kprobe:s->hdlcrx.bitstream >>= 16;s->hdlcrx.bitstream |= word << 16;s->hdlcrx.bitbuf >>= 16;s->hdlcrx.bitbuf |= word << 16;s->hdlcrx.numbits += 16;for(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00, mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; i >= 0; i--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1, mask5 <<= 1, mask6 = (mask6 << 1) | 1)": {
        "description": "Helper function for HDLC driver receiver.",
        "pre": {
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->hdlcrx.in_hdlc_rx": "== 0",
            "s->hdlcrx.hbuf": "not empty"
        }
    }
},
{
    "kretprobe:hdlcdrv_transmitter": {
        "description": "Transmitter function in HDLCDRV",
        "pre": {
            "pkt_len": ">= HDLCDRV_MAXFLEN || < 2"
        }
    }
},
{
    "kprobe:hdlcdrv_transmitter": {
        "description": "Condition for pkt_len in hdlcdrv_transmitter function",
        "pre": {
            "pkt_len": ">= HDLCDRV_MAXFLEN || < 2"
        }
    }
},
{
    "kretprobe:hdlcdrv_arbitrate": {
        "description": "Arbitrate the network driver interface.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->hdlctx.ptt": "== false",
            "s->skb": "!=null",
            "s->ch_params.fulldup": "== true",
            "s->hdlcrx.dcd": "== true",
            "s->hdlctx.slotcnt": "> 0",
            "get_random_u8()": "<= s->ch_params.ppersist"
        }
    }
},
{
    "kprobe:hdlcdrv_arbitrate": {
        "description": "Arbitrate the HDLC driver",
        "pre": {
            "dev": "any",
            "s": {
                "s != null",
                "s->magic == HDLCDRV_MAGIC",
                "s->hdlctx.ptt == false",
                "s->skb != null",
                "s->ch_params.fulldup in [true, false]",
                "if s->ch_params.fulldup: call start_tx(dev, s)",
                "if s->hdlcrx.dcd: set s->hdlctx.slotcnt = s->ch_params.slottime",
                "if s->hdlctx.slotcnt > 0: return",
                "set s->hdlctx.slotcnt = s->ch_params.slottime",
                "if get_random_u8() > s->ch_params.ppersist: call start_tx(dev, s)"
            }
        }
    }
},
{
    "kretprobe:s = netdev_priv(dev);s->magic = HDLCDRV_MAGIC;s->ops = ops;dev->base_addr = baseaddr;dev->irq = irq;dev->dma = dma;err = register_netdev(dev);if (err < 0)": {
        "description": "Register a network device with the HDLCDRV driver.",
        "pre": {
            "dev": "!=null",
            "ops": "!=null",
            "baseaddr": "!=null",
            "irq": "!=null",
            "dma": "!=null",
            "privsize": ">= sizeof(struct hdlcdrv_state)"
        }
    }
},
{
    "kprobe:netdev_priv": {
        "description": "Get the private data associated with a network device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:HDLCDRV_MAGIC": {
        "description": "Set the magic value of the HDLCDRV state.",
        "pre": {
            "s": "!=null",
            "s->magic": "= HDLCDRV_MAGIC"
        }
    },
    "kprobe:HDLCDRV_OPS": {
        "description": "Set the ops value of the HDLCDRV state.",
        "pre": {
            "s": "!=null",
            "s->ops": "= ops"
        }
    },
    "kprobe:dev->base_addr": {
        "description": "Set the base address of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "= baseaddr"
        }
    },
    "kprobe:dev->irq": {
        "description": "Set the IRQ of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->irq": "= irq"
        }
    },
    "kprobe:dev->dma": {
        "description": "Set the DMA of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->dma": "= dma"
        }
    },
    "kprobe:register_netdev": {
        "description": "Register a network device.",
        "pre": {
            "dev": "!=null",
            "err": "< 0"
        }
    }
},
{
    "kretprobe:hdlcdrv_receiver": {
        "description": "Receives data from the HDLC driver.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->opened": "== true",
            "s->ops->receive": "!=null"
        }
    }
},
{
    "kprobe:hdlcdrv_receiver": {
        "description": "Receives data from the HDLC driver.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->opened": "== true",
            "s->ops->close": "!=null"
        }
    }
},
{
    "kretprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for the specified net.",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        }
    }
},
{
    "kprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for specified net.",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:chan->ppp = NULL;/* * This ensures that we have returned from any calls into * the channel's start_xmit or ioctl routine before we proceed. */": {
        "description": "Set chan->ppp to NULL to ensure that we have returned from any calls into the channel's start_xmit or ioctl routine before proceeding.",
        "pre": {
            "chan": "!=null"
        },
        "post": {
            "chan->ppp": "==null"
        }
    }
},
{
    "kprobe:chan->ppp = NULL;/* * This ensures that we have returned from any calls into * the channel's start_xmit or ioctl routine before we proceed. */": {
        "description": "Set chan->ppp to NULL to ensure that we have returned from any calls into the channel's start_xmit or ioctl routine before proceeding.",
        "pre": {
            "chan": "!=null",
            "chan->ppp": "==null"
        }
    }
},
{
    "kretprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "pre": {
            "chan": "!=null",
            "pch": "!=null",
            "pch->file.index": "!=null",
            "return value": "-1"
        }
    }
},
{
    "kprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "pre": {
            "chan": "!=null",
            "return": "int",
            "return >= -1"
        }
    }
},
{
    "kretprobe:ppp_dev_name": {
        "description": "Return the PPP device interface name of a channel.",
        "pre": {
            "chan": "!=null"
        }
    }
},

{
    "kretprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "pre": {
            "chan": "!=null"
        }
    }
},

{
    "kprobe:ppp_bridge_channels": {
        "description": "Bridge two channels in a PPP network.",
        "pre": {
            "pch": "!=null",
            "pchb": "!=null",
            "pch->ops->start_xmit": "!=null",
            "pchb->ops->start_xmit": "!=null",
            "pch->bridge_instance": "==null",
            "pchb->bridge_instance": "==null",
            "pch->unit": "==null",
            "pchb->unit": "==null"
        }
    }
},
{
    "kretprobe:ppp_input_error": {
        "description": "We come in here to process a received frame. The receive side of the ppp unit is locked.",
        "pre": {
            "chan": "!=null",
            "code": "!=null",
            "pch": "!=null",
            "skb": "!=null",
            "pch->ppp": "!=null",
            "skb->len": "==0"
        }
    }
},
{
    "kprobe:skb->cb[0] = code;ppp_do_recv(pch->ppp, skb, pch);}}read_unlock_bh(&pch->upl);}/* * We come in here to process a received frame. * The receive side of the ppp unit is locked. `": {
        "description": "This function is used to process a received frame in the ppp unit.",
        "pre": {
            "skb": "!=null",
            "code": "!=null",
            "pch": "!=null",
            "pch->ppp": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kretprobe:ppp_output_wakeup": {
        "description": "Compression control.",
        "pre": {
            "chan": "!=null",
            "pch": "!=null",
            "ppp_channel_push(pch)": "called"
        }
    }
},
{
    "kprobe:ppp_output_wakeup": {
        "description": "Compression control.",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "pre": {
            "cp": "!=null",
            "compress_proto": "!=null",
            "compressor_list_lock": "!=null"
        },
        "post": {
            "ret": "in [-EEXIST, -ENOMEM, 0]"
        }
    }
},
{
    "kprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "pre": {
            "cp": "!=null",
            "compress_proto": "!=null",
            "compressor_list_lock": "!=null",
            "compressor_list": "!=null",
            "ret": "in [-EEXIST, -ENOMEM, 0]"
        }
    }
},
{
    "kretprobe:find_compressor": {
        "description": "Find a compressor.",
        "pre": {
            "type": "is_integer"
        },
        "post": {
            "return": "is_pointer",
            "return_constraints": {
                "if return != null": {
                    "return->compress_proto": "type"
                }
            }
        }
    }
},


{
    "kprobe:pppox_unbind_sock": {
        "description": "Clear connection to ppp device, if attached.",
        "pre": {
            "sk": {
                "sk_state": "&",
                "value": "in [PPPOX_BOUND, PPPOX_CONNECTED]"
            }
        }
    }
},


{
    "kretprobe:lan9303_probe": {
        "description": "Probe function for lan9303",
        "pre": {
            "chip->reset_duration": ">1000",
            "chip->reset_duration": "=1000"
        },
        "post": {
            "return": "=0"
        }
    }
},
{
    "kprobe:lan9303_probe": {
        "description": "Probe function for lan9303",
        "pre": {
            "chip->reset_duration": ">1000",
            "chip->reset_duration": "=1000",
            "np": "!=null"
        }
    }
},


{
    "kprobe:dev->info = info;dev_info(dev->dev, \"found switch: %s, rev %i\\n\", dev->info->dev_name, dev->chip_rev);ret = ksz_check_device_id(dev);if (ret)return ret;dev->dev_ops = dev->info->ops;ret = dev->dev_ops->init(dev);if (ret)return ret;dev->ports = devm_kzalloc(dev->dev,  dev->info->port_cnt * sizeof(struct ksz_port),  GFP_KERNEL);if (!dev->ports)return -ENOMEM;for (i = 0; i < dev->info->port_cnt; i++)": {
        "description": "Register a KSZ switch device",
        "pre": {
            "dev": "!=null",
            "info": "!=null",
            "dev->dev": "!=null",
            "dev->info->dev_name": "!=null",
            "dev->chip_rev": "!=null",
            "ret": "!=null",
            "dev->info->ops": "!=null",
            "dev->dev_ops": "!=null",
            "dev->ports": "!=null",
            "dev->info->port_cnt": "!=null",
            "i": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "dev": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "pre": {
            "ds": "!=null",
            "port": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:b53_fdb_add": {
        "description": "Add a forwarding database entry to the b53 device.",
        "pre": {
            "ds": "!=null",
            "port": "int",
            "addr": "!=null",
            "vid": "u16",
            "db": "!=null",
            "priv": "!=null",
            "ret": "int"
        },
        "post": {
            "ret": "int"
        }
    }
},
{
    "kprobe:b53_fdb_add": {
        "description": "Add a forwarding database entry to the B53 switch.",
        "pre": {
            "ds": "!=null",
            "port": "int",
            "addr": "!=null",
            "vid": "u16",
            "db": "!=null",
            "priv": "!=null",
            "ret": "int"
        }
    }
},
S,
S,
S,
{
    "kprobe:b53_mdb_add": {
        "description": "Add an entry to the MDB (Multicast Database) of a B53 switch.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "mdb": "!=null",
            "db": "!=null",
            "priv": "!=null",
            "ret": "!=null",
            "is5325(priv) || is5365(priv)": "true",
            "mutex_lock(&priv->arl_mutex)": "true",
            "b53_arl_op(priv, 0, port, mdb->addr, mdb->vid, true)": "ret",
            "mutex_unlock(&priv->arl_mutex)": "true",
            "return": "ret"
        }
    }
},
S,
{
    "kprobe:b53_br_join": {
        "description": "Join a bridge in the b53 switch driver.",
        "pre": {
            "dev->chip_id": "== BCM7278_DEVICE_ID",
            "port": "== 7"
        },
        "return": "-EINVAL",
        "comment": "Make this port leave the all VLANs join since we will have proper VLAN entries from now on."
    }
},
{
    "kretprobe:b53_br_leave": {
        "description": "Leave a bridge for a specific port",
        "pre": {
            "dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge)": true,
            "b53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg)": true,
            "reg &= ~BIT(port)": true,
            "b53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg)": true,
            "dev->ports[port].vlan_ctl_mask = reg": true
        },
        "post": {}
    }
},
{
    "kprobe:b53_br_leave": {
        "description": "Leave a bridge for a specific port in a DSA switch.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "bridge": "!=null"
        }
    }
},
S,
{
    "kprobe:[function name]": {
        "description": "[description of the function]",
        "pre": {
            "[argument1]": "[condition1]",
            "[argument2]": "[condition2]",
            ...
        }
    }
},
{
    "kretprobe:b53_mirror_del": {
        "description": "Update the desired ingress/egress register.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "mirror": "!=null",
            "dev": "!=null",
            "loc_disable": "false",
            "other_loc_disable": "false",
            "reg": "!=null",
            "loc": "!=null",
            "mirror->ingress": "in [true, false]",
            "loc": "in [B53_IG_MIR_CTL, B53_EG_MIR_CTL]"
        }
    }
},
{
    "kprobe:b53_read16": {
        "description": "Read a 16-bit value from the specified device and location.",
        "pre": {
            "dev": "!=null",
            "B53_MGMT_PAGE": "!=null",
            "loc": "!=null",
            "&reg": "!=null",
            "port": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__set_bit": {
        "description": "Set a bit in the supported_interfaces field of the config structure.",
        "pre": {
            "config": "!=null",
            "config->supported_interfaces": "!=null",
            "PHY_INTERFACE_MODE_GMII": "!=null"
        }
    }
},
S,
{
    "kretprobe:b53_switch_alloc": {
        "description": "Allocate and initialize a b53 switch.",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:b53_switch_alloc": {
        "description": "Allocate and initialize a b53 switch",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
S,
{
    "kprobe:b53_write16": {
        "description": "Write 16 bits to the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_VLAN_PAGE": "!=null",
            "B53_VLAN_TABLE_ACCESS_25": "!=null",
            "0xf": "!=null"
        }
    },
    "kprobe:b53_read16": {
        "description": "Read 16 bits from the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_VLAN_PAGE": "!=null",
            "B53_VLAN_TABLE_ACCESS_25": "!=null",
            "&tmp": "!=null"
        }
    },
    "kprobe:dev->chip_id = BCM5325_DEVICE_ID": {
        "description": "Set the chip ID to BCM5325_DEVICE_ID if tmp is equal to 0xf.",
        "pre": {
            "tmp": "==0xf"
        }
    },
    "kprobe:dev->chip_id = BCM5365_DEVICE_ID": {
        "description": "Set the chip ID to BCM5365_DEVICE_ID if tmp is not equal to 0xf.",
        "pre": {
            "tmp": "!=0xf"
        }
    },
    "kprobe:break": {
        "description": "Break from the switch statement.",
        "pre": {}
    },
    "kprobe:case BCM5389_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5395_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5397_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5398_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:ret = b53_read32": {
        "description": "Read 32 bits from the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_MGMT_PAGE": "!=null",
            "B53_DEVICE_ID": "!=null",
            "&id32": "!=null"
        }
    },
    "kprobe:if (ret)": {
        "description": "Check if the return value of b53_read32 is non-zero.",
        "pre": {}
    },
    "kprobe:switch (id32)": {
        "description": "Switch statement based on the value of id32.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:mt76_wcid_key_setup": {
        "description": "Setup the key for the mt76_wcid structure.",
        "pre": {
            "dev": "!=null",
            "wcid": "!=null",
            "key": "!=null",
            "key->cipher": "==WLAN_CIPHER_SUITE_CCMP"
        }
    }
},
S,
S,
S,
{
    "kretprobe:memset": {
        "description": "Initialize the pktq structure by setting the specified number of precursors to zero.",
        "pre": {
            "pq": "!=null",
            "num_prec": ">= 0",
            "max_len": ">= 0",
            "prec": ">= 0",
            "prec": "< num_prec"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Initialize the pktq structure by zeroing out the requested number of precursors.",
        "pre": {
            "pq": "!=null",
            "num_prec": ">=0",
            "max_len": ">=0",
            "prec": ">=0",
            "prec < num_prec": true
        }
    }
},
{
    "kretprobe:ath_hw_setbssidmask": {
        "description": "Filter out bssids we listen",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kprobe:ath_hw_setbssidmask": {
        "description": "Filter out bssids we listen",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kretprobe:ath_hw_cycle_counters_update": {
        "description": "common function to update cycle counters",
        "pre": {
            "common": "!=null",
            "common->cc_lock": "held"
        }
    }
},
{
    "kprobe:ath_hw_cycle_counters_update": {
        "description": "Common function to update cycle counters in the ath_common struct for the device.",
        "pre": {
            "common": "!=null",
            "common->cc_lock": "held"
        }
    }
},
{
    "kretprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address for a key in the key cache.",
        "pre": {
            "common": "!=null",
            "entry": ">=0",
            "mac": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address for a key in the key cache.",
        "pre": {
            "common": "!=null",
            "entry": ">=0",
            "mac": "!=null",
            "unicast_flag": "=AR_KEYTABLE_VALID",
            "ah": "!=null",
            "entry": "<common->keymax",
            "mac": "!=NULL"
        }
    }
},
{
    "kretprobe:idx = key->keyidx;} elsereturn -EIO;} else": {
        "description": "Set the value of 'idx' based on 'key->keyidx' and return -EIO if not satisfied.",
        "pre": {
            "key": "!=null",
            "key->keyidx": "!=null",
            "idx": ">= 0"
        }
    }
},
{
    "kprobe:ath_key_config": {
        "description": "Configure the ATH key.",
        "pre": {
            "common": "any",
            "vif": "any",
            "sta": "any",
            "key": {
                "cipher": "in [0, WLAN_CIPHER_SUITE_WEP40, WLAN_CIPHER_SUITE_WEP104, WLAN_CIPHER_SUITE_TKIP, WLAN_CIPHER_SUITE_CCMP]",
                "keylen": ">0",
                "key": "!=null",
                "flags": "!& IEEE80211_KEY_FLAG_PAIRWISE",
                "vif.type": "in [NL80211_IFTYPE_AP, NL80211_IFTYPE_ADHOC]",
                "vif.addr": "!=null",
                "gmac[0]": "= vif.addr[0] | 0x01",
                "sta.addr": "!=null",
                "gmac[0]": "= sta.addr[0] | 0x01",
                "key.keyidx": ">0",
                "sta": "!=null",
                "mac": "= sta.addr"
            }
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:ath_reg_apply_radar_flags": {
        "description": "Apply radar flags for custom regulatory request",
        "pre": {
            "wiphy": "!=null",
            "request": "!=null",
            "reg": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath_rxbuf_alloc": {
        "description": "Cache-line-align. This is important (for the 5210 at least) as not doing so causes bogus data in rx'd frames.",
        "pre": {
            "common": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:ath_rxbuf_alloc": {
        "description": "Cache-line-align. This is important (for the 5210 at least) as not doing so causes bogus data in rx'd frames.",
        "pre": {
            "common": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_wmi_shutdown": {
        "description": "Shutdown the WMI module in ath6kl.",
        "pre": {
            "ar": "!=null",
            "ar->wmi": "!=null",
            "ar->flag": "!=null",
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_wmi_shutdown": {
        "description": "Shutdown the WMI module in ath6kl.",
        "pre": {
            "ar": "!=null",
            "ar->wmi": "!=null",
            "ar->flag": "!=null",
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_core_init": {
        "description": "Initialize the ath6kl core.",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]"
        },
        "post": {
            "ret": "==0",
            "ar->ath6kl_wq": "!=null",
            "ret": "==0"
        }
    },
    "kretprobe:ath6kl_hif_power_on": {
        "description": "Turn on power to get hardware (target) version.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_bmi_get_target_info": {
        "description": "Get target information from BMI.",
        "pre": {
            "ar": "!=null",
            "targ_info": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_bmi_init": {
        "description": "Initialize BMI.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_init_hw_params": {
        "description": "Initialize hardware parameters.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_htc_create": {
        "description": "Create HTC target.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_core_init": {
        "description": "Initialize the ath6kl core.",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]"
        }
    },
    "kprobe:ath6kl_htc_mbox_attach": {
        "description": "Attach ath6kl HTC mailbox.",
        "pre": {
            "ar": "!=null"
        }
    },
    "kprobe:ath6kl_htc_pipe_attach": {
        "description": "Attach ath6kl HTC pipe.",
        "pre": {
            "ar": "!=null"
        }
    },
    "kprobe:ath6kl_bmi_init": {
        "description": "Initialize the ath6kl BMI.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_core_create": {
        "description": "Create the ath6kl core structure.",
        "pre": {
            "dev": "!=null",
            "ar": "!=null",
            "ctr": ">=0",
            "ctr": "<AP_MAX_NUM_STA"
        }
    }
},
{
    "kprobe:ath6kl_core_create": {
        "description": "Create the ath6kl core structure.",
        "pre": {
            "dev": "!=null",
            "ctr": ">=0",
            "ctr": "<AP_MAX_NUM_STA"
        }
    }
},
{
    "kretprobe:trace_ath6kl_log_dbg_dump": {
        "description": "Logs debug information with optional message and prefix, and dumps buffer in hex format.",
        "pre": {
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:trace_ath6kl_log_dbg_dump": {
        "description": "Logs debug information and dumps a hex representation of a buffer.",
        "pre": {
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:ath6kl_tx_data_cleanup": {
        "description": "Clean up function for transmitting data in ath6kl.",
        "pre": {
            "ar": "!=null",
            "prev_state": "!=null",
            "ret": "!=null",
            "wow": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_tx_data_cleanup": {
        "description": "Clean up the transmission data in ath6kl.",
        "pre": {
            "ar": "!=null",
            "prev_state": "!=null",
            "ret": "!=null",
            "wow": "!=null",
            "mode": "in [ATH6KL_CFG_SUSPEND_WOW]"
        }
    }
},
{
    "kretprobe:ath9k_cmn_beacon_config_sta": {
        "description": "No need to configure beacon if we are not associated",
        "pre": {
            "common": {
                "op_flags": "!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)"
            }
        }
    }
},
{
    "kprobe:ath9k_cmn_beacon_config_sta": {
        "description": "Check if the bit ATH_OP_PRIM_STA_VIF is not set in the op_flags field of the common structure.",
        "pre": {
            "common.op_flags": "not test_bit(ATH_OP_PRIM_STA_VIF)"
        }
    }
},
{
    "kretprobe:conf->intval = TU_TO_USEC(conf->beacon_interval)": {
        "description": "Convert the beacon interval from TU to microseconds and assign it to conf->intval.",
        "pre": {
            "conf": "!=null",
            "conf->beacon_interval": "!=null"
        },
        "post": {
            "conf->intval": "= TU_TO_USEC(conf->beacon_interval)"
        }
    }
},
{
    "kprobe:ath9k_cmn_beacon_config_ap": {
        "description": "Configure the beacon for an access point.",
        "pre": {
            "ah": "!=null",
            "conf": "!=null",
            "bc_buf": "!=null",
            "conf->intval": "!=null",
            "conf->intval": "/= bc_buf",
            "conf->nexttbtt": "= ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah), conf->beacon_interval)",
            "conf->enable_beacon": "= true",
            "ah->imask": "|= ATH9K_INT_SWBA",
            "conf->beacon_interval": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath9k_hw_btcoex_init_2wire": {
        "description": "Connect bt_active to baseband.",
        "pre": {
            "ah": "!=null",
            "btcoex_hw": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for Bluetooth and WLAN coexistence.",
        "pre": {
            "ah": "!=null",
            "bt_weight": "!=null",
            "wlan_weight": "!=null",
            "stomp_type": "in [0, 1, 2, 3]",
            "mci_hw": "!=null",
            "concur_tx": "==true",
            "btcoex_hw": "!=null",
            "tx_prio[stomp_type]": "!=null",
            "ar9003_wlan_weights[stomp_type]": "!=null",
            "i": "!=null",
            "AR_SREV_9300_20_OR_LATER(ah)": "==false"
        }
    }
},
{
    "kprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for Bluetooth and WLAN coexistence in the ATH9K hardware.",
        "pre": {
            "ah": "!=null",
            "bt_weight": "!=null",
            "wlan_weight": "!=null",
            "stomp_type": "in [0, 1, 2, 3]",
            "mci_hw": "!=null",
            "btcoex_hw": "!=null",
            "mci_hw.concur_tx": "==true",
            "btcoex_hw.tx_prio[stomp_type]": "==true",
            "ar9003_wlan_weights[stomp_type]": "!=null",
            "i": "!=null",
            "AR_SREV_9300_20_OR_LATER(ah)": "==false"
        }
    }
},
{
    "kretprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": "!=null",
            "btcoex_hw->wlanactive_gpio": "is a valid GPIO port",
            "btcoex_hw->wlanactive_gpio": "is configured as an output",
            "btcoex_hw->wlanactive_gpio": "is configured as TX_FRAME output",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME when AR9002",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME when AR9003 and above"
        }
    }
},
{
    "kprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": "!=null",
            "btcoex_hw->wlanactive_gpio": "is a valid GPIO port",
            "btcoex_hw->wlanactive_gpio": "is configured as an output",
            "btcoex_hw->wlanactive_gpio": "is configured as TX_FRAME output",
            "btcoex_hw->wlanactive_gpio": "is configured as AR_GPIO_OUTPUT_MUX_AS_TX_FRAME",
            "btcoex_hw->wlanactive_gpio": "is configured for AR9002 or above",
            "btcoex_hw->wlanactive_gpio": "is configured for AR9003 or above"
        }
    }
},
{
    "kretprobe:ath9k_hw_btcoex_bt_stomp": {
        "description": "Configures appropriate weight based on stomp type.",
        "pre": {
            "ah": "!=null",
            "stomp_type": "unknown constraints"
        }
    }
},
{
    "kprobe:ath9k_hw_btcoex_bt_stomp": {
        "description": "Configures appropriate weight based on stomp type.",
        "pre": {
            "ah": "!=null",
            "stomp_type": "in [ATH_BTCOEX_STOMP_NONE, ...]"
        }
    }
},
{
    "kretprobe:ar9003_paprd_enable": {
        "description": "Enable or disable PAPRD for different sub-bands in the 5GHz band.",
        "pre": {
            "ah": "!=null",
            "val": "!=null",
            "chan": "!=null",
            "is2ghz": "==false",
            "modalHeader5G.papdRateMaskHt20": "!=null",
            "modalHeader5G.papdRateMaskHt20[30]": "==0",
            "modalHeader5G.papdRateMaskHt20[29]": "==0",
            "modalHeader5G.papdRateMaskHt20[28]": "==0"
        }
    }
},
{
    "kprobe:ar9003_paprd_enable": {
        "description": "Enable or disable PAPRD for different sub-bands in the 5GHz band.",
        "pre": {
            "ah": "!=null",
            "val": "!=null",
            "chan": "!=null",
            "is2ghz": "==false",
            "modalHeader5G.papdRateMaskHt20": "& 0x40000000 == 0",
            "modalHeader5G.papdRateMaskHt20": "& 0x20000000 == 0",
            "modalHeader5G.papdRateMaskHt20": "& 0x10000000 == 0"
        }
    }
},
{
    "kretprobe:REG_RMW_FIELD": {
        "description": "Modify a register field with a new value.",
        "pre": {
            "ah": "!=null",
            "AR_PHY_PAPRD_CTRL1_B2": "!=null",
            "AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL": "!=null",
            "training_power": "!=null"
        }
    }
},
{
    "kprobe:REG_RMW_FIELD": {
        "description": "Modify a register field using a read-modify-write operation.",
        "pre": {
            "ah": "!=null",
            "AR_PHY_PAPRD_CTRL1_B2": "!=null",
            "AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL": "!=null",
            "training_power": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_paprd_is_done": {
        "description": "Check if PAPRD training is done and return the result.",
        "pre": {
            "ah": "!=null",
            "paprd_done": "==0x1",
            "agc2_pwr": "<=PAPRD_IDEAL_AGC2_PWR_RANGE"
        }
    }
},
{
    "kprobe:ar9003_paprd_is_done": {
        "description": "Check if PAPRD training is done and AGC2 power is within the ideal range.",
        "pre": {
            "ah": "!=null",
            "paprd_done": "==1",
            "agc2_pwr": "<=PAPRD_IDEAL_AGC2_PWR_RANGE"
        }
    }
},
{
    "kretprobe:ath9k_hw_loadnf": {
        "description": "Try to get calibrated noise floor value",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "h": "null or !=null",
            "i": ">=0 and <NUM_NF_READINGS",
            "j": ">=0",
            "chainmask": ">=0",
            "common": "!=null",
            "default_nf": "!=null",
            "bb_agc_ctl": "!=null",
            "nfval": "!=null",
            "ah->caldata": "null or !=null",
            "ah->caldata->nfCalHist": "null or !=null",
            "ah->nf_override": "null or !=null",
            "h[i].privNF": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_loadnf": {
        "description": "Try to get calibrated noise floor value",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "h": "in [null, !=null]",
            "i": ">=0",
            "j": ">=0",
            "chainmask": ">=0",
            "common": "!=null",
            "default_nf": "!=null",
            "bb_agc_ctl": "!=null",
            "nfval": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_hw_bstuck_nfcal": {
        "description": "Trigger a noise floor calibration to recover from stuck beacons.",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null",
            "caldata->cal_flags": "!test_bit(NFCAL_PENDING, &caldata->cal_flags)",
            "REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) & AR_PHY_AGC_CONTROL_NF": "==0"
        }
    }
},
{
    "kprobe:ath9k_hw_bstuck_nfcal": {
        "description": "If beacons are stuck, trigger a noise floor calibration to adapt to a noisy environment.",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:result = MS": {
        "description": "While receiving unsupported rate frame rx state machine gets into a state 0xb and if phy_restart happens in that state, BB would go hang. If RXSM is in 0xb state after first bb panic, ensure to disable the phy_restart.",
        "pre": {
            "ah": "!=null",
            "ah->bb_watchdog_last_status": "==0xb",
            "AR_PHY_WATCHDOG_RX_OFDM_SM": "!=null",
            "result": "!=null",
            "result": "==0xb",
            "ah->bb_hang_rx_ofdm": "!=null"
        }
    }
},
{
    "kprobe:result = MS": {
        "description": "Perform a bitwise shift operation on ah->bb_watchdog_last_status with AR_PHY_WATCHDOG_RX_OFDM_SM and assign the result to 'result'. If 'result' is equal to 0xb or ah->bb_hang_rx_ofdm is true, then execute the following code.",
        "pre": {
            "ah": "!=null",
            "ah->bb_watchdog_last_status": "!=null",
            "AR_PHY_WATCHDOG_RX_OFDM_SM": "!=null",
            "result": "!=null",
            "result == 0xb || ah->bb_hang_rx_ofdm": "true"
        }
    }
},
{
    "kretprobe:ath9k_hw_updatetxtriglevel": {
        "description": "adjusts the frame trigger level",
        "pre": {
            "ah": "!=null",
            "bIncTrigLevel": "!=null",
            "ah": "is a struct of type ath_hw",
            "bIncTrigLevel": "is a boolean",
            "frame_trigger_level": ">= 0",
            "frame_trigger_level": "<= 384 if ah is a dual stream device",
            "frame_trigger_level": "<= 2048 if ah is a single stream device"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_resettxqueue": {
        "description": "Reset the transmit queue.",
        "pre": {
            "AR_SREV_9300_20_OR_LATER(ah)": true,
            "ah->opmode": "!= NL80211_IFTYPE_ADHOC"
        }
    }
},
{
    "kprobe:ath9k_hw_resettxqueue": {
        "description": "Reset the transmit queue.",
        "pre": {
            "AR_SREV_9300_20_OR_LATER(ah)": true,
            "ah->opmode": "!=NL80211_IFTYPE_ADHOC"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ath9k_hw_init_config": {
        "description": "Initialize the configuration of the ath9k hardware.",
        "pre": {
            "num_possible_cpus()": "> 1",
            "ah->config.serialize_regmode": "SER_REG_MODE_AUTO",
            "NR_CPUS": "> 1",
            "ah->config.serialize_regmode == SER_REG_MODE_AUTO": "true"
        }
    }
},
{
    "kprobe:ath9k_hw_init_config": {
        "description": "Initialize the configuration of the ath9k hardware.",
        "pre": {
            "num_possible_cpus()": "> 1",
            "ah->config.serialize_regmode": "SER_REG_MODE_AUTO",
            "NR_CPUS": "> 1"
        }
    }
},
{
    "kretprobe:ath9k_hw_init_global_settings": {
        "description": "Initialize global settings for ath9k_hw.",
        "pre": {
            "ah": "!=null",
            "ah->curchan": "!=null",
            "ah->misc_mode": "==0",
            "IS_CHAN_A_FAST_CLOCK(ah, ah->curchan)": "in [true, false]",
            "IS_CHAN_5GHZ(ah->curchan)": "in [true, false]",
            "IS_CHAN_HALF_RATE(ah->curchan)": "in [true, false]",
            "IS_CHAN_QUARTER_RATE(ah->curchan)": "in [true, false]",
            "AR_SREV_9287(ah)": "in [true, false]",
            "AR_SREV_9287_13_OR_LATER(ah)": "in [true, false]"
        },
        "post": {
            "slottime": "!=null",
            "acktimeout": "!=null",
            "ctstimeout": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_init_global_settings": {
        "description": "Initialize global settings for ath9k_hw.",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "acktimeout": "!=null",
            "ctstimeout": "!=null",
            "ack_offset": "!=null",
            "slottime": "!=null",
            "sifstime": "!=null",
            "rx_lat": "!=null",
            "tx_lat": "!=null",
            "eifs": "!=null",
            "ack_shift": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:if (REG_READ(ah, AR_CFG) == 0xdeadbeef)": {
        "description": "Check if REG_READ(ah, AR_CFG) is equal to 0xdeadbeef",
        "pre": {
            "ah": "!=null",
            "AR_CFG": "== 0xdeadbeef"
        }
    },
    "kretprobe:if (AR_SREV_9300(ah))": {
        "description": "Check if AR_SREV_9300(ah) is true",
        "pre": {
            "ah": "!=null"
        }
    },
    "kretprobe:if (AR_SREV_9285_12_OR_LATER(ah))": {
        "description": "Check if AR_SREV_9285_12_OR_LATER(ah) is true",
        "pre": {
            "ah": "!=null"
        }
    },
    "kretprobe:last_val = REG_READ(ah, AR_OBS_BUS_1)": {
        "description": "Assign the value of REG_READ(ah, AR_OBS_BUS_1) to last_val",
        "pre": {
            "ah": "!=null",
            "AR_OBS_BUS_1": "!=null"
        }
    }
},
{
    "kprobe:if (REG_READ(ah, AR_CFG) == 0xdeadbeef)return false;if (AR_SREV_9300(ah))return !ath9k_hw_detect_mac_hang(ah);if (AR_SREV_9285_12_OR_LATER(ah))return true;last_val = REG_READ(ah, AR_OBS_BUS_1);do": {
        "description": "Function with multiple conditions",
        "pre": {
            "REG_READ(ah, AR_CFG)": "== 0xdeadbeef",
            "AR_SREV_9300(ah)": "true",
            "ath9k_hw_detect_mac_hang(ah)": "false",
            "AR_SREV_9285_12_OR_LATER(ah)": "true",
            "REG_READ(ah, AR_OBS_BUS_1)": "!= null"
        }
    }
},
{
    "kretprobe:ath9k_hw_ar9330_reset_war": {
        "description": "Reset WMAC if doing a cold reset or if there are pending frames in the TX queues.",
        "pre": {
            "ah": "!=null",
            "type": "int"
        }
    }
},
{
    "kprobe:ath9k_hw_ar9330_reset_war": {
        "description": "Reset AR9330 WAR: call external reset function to reset WMAC if doing a cold reset or if there are pending frames in the TX queues.",
        "pre": {
            "ah": "!=null",
            "type": "int"
        }
    }
},
{
    "kretprobe:switch (ah->hw_version.devid)": {
        "description": "Check the hardware version and perform specific actions based on the device ID.",
        "pre": {
            "ah": "!=null",
            "ah->hw_version.devid": "!=null",
            "ah->hw_version.devid": "in [AR5008, AR9001, AR9002, AR9003]"
        }
    }
},
S,
{
    "kretprobe:REG_WRITE": {
        "description": "Write a value to a register.",
        "pre": {
            "ah": "!=null",
            "AR_TSFOOR_THRESHOLD": "!=null",
            "bs->bs_tsfoor_threshold": "!=null"
        }
    }
},
{
    "kprobe:REG_WRITE": {
        "description": "Write a value to a register.",
        "pre": {
            "ah": "!=null",
            "AR_TSFOOR_THRESHOLD": "!=null",
            "bs->bs_tsfoor_threshold": "!=null"
        }
    }
},
{
    "kretprobe:ah->radar_conf.ext_channel = IS_CHAN_HT40(chan);ath9k_hw_set_radar_params(ah);return 0;": {
        "description": "Set radar configuration and return 0.",
        "pre": {
            "ah": "!=null",
            "chan": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_chip_test": {
        "description": "Check if the chip is working correctly.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_chip_test": {
        "description": "Disable PCIe for all families including legacy.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_hw_init_desc": {
        "description": "Initialize the descriptor for the ath9k_hw module.",
        "pre": {
            "AR_ISR": "= ~0",
            "AR_RSSI_THR": "= INIT_RSSI_THR",
            "ah->opmode": "= ah->opmode"
        }
    }
},
S,
S,
S,
{
    "kretprobe:if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))": {
        "description": "Condition for the kretprobe function if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))",
        "pre": {
            "ah": "!=null",
            "tsf": "!=null"
        },
        "post": {
            "AR_SREV_9100(ah)": "true",
            "ath9k_hw_gettsf64(ah) < tsf": "true"
        }
    }
},
{
    "kprobe:if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))": {
        "description": "Condition for the given function",
        "pre": {
            "AR_SREV_9100(ah)": true,
            "ath9k_hw_gettsf64(ah) < tsf": true
        }
    }
},
{
    "kretprobe:timer_table->timers[timer_index] = timer;timer->index = timer_index;timer->trigger = trigger;timer->overflow = overflow;timer->arg = arg;if ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled)": {
        "description": "Allocate a hardware generic timer slot",
        "pre": {
            "timer_table": "!=null",
            "timer": "!=null",
            "timer_index": ">= AR_FIRST_NDP_TIMER && < ATH_MAX_GEN_TIMER",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index > AR_FIRST_NDP_TIMER && !timer_table->tsf2_enabled": "true"
        }
    }
},
{
    "kprobe:timer_table->timers[timer_index] = timer;timer->index = timer_index;timer->trigger = trigger;timer->overflow = overflow;timer->arg = arg;if ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled)": {
        "description": "Allocate a hardware generic timer slot",
        "pre": {
            "timer_table": "!=null",
            "timer": "!=null",
            "timer_index": ">= AR_FIRST_NDP_TIMER && < ATH_MAX_GEN_TIMER",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index > AR_FIRST_NDP_TIMER && !timer_table->tsf2_enabled": true
        }
    }
},
S,
S,
{
    "kretprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "pre": {
            "ah": "!=null",
            "timer": "!=null",
            "timer_table": "!=null",
            "timer_table->timers[timer->index]": "==null"
        }
    }
},
{
    "kprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "pre": {
            "ah": "!=null",
            "timer": "!=null"
        }
    }
},
{
    "kretprobe:ath_gen_timer_isr": {
        "description": "Get hardware generic timer interrupt status",
        "pre": {
            "trigger_mask": "!=null",
            "thresh_mask": "!=null",
            "trigger_mask": "&= timer_table->timer_mask",
            "thresh_mask": "&= timer_table->timer_mask",
            "index": "for_each_set_bit(&thresh_mask, ARRAY_SIZE(timer_table->timers))"
        }
    }
},
{
    "kprobe:trigger_mask = ah->intr_gen_timer_trigger;thresh_mask = ah->intr_gen_timer_thresh;trigger_mask &= timer_table->timer_mask;thresh_mask &= timer_table->timer_mask;for_each_set_bit(index, &thresh_mask, ARRAY_SIZE(timer_table->timers))": {
        "description": "Get hardware generic timer interrupt status",
        "pre": {
            "ah": "!=null",
            "timer_table": "!=null",
            "trigger_mask": "!=null",
            "thresh_mask": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:AR_SREV_9280_20_OR_LATER": {
        "description": "Check if the AR_SREV is 9280 or later",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:memset": {
        "description": "Set the memory block starting at &ht_info->mcs to zero.",
        "pre": {
            "&ht_info->mcs": "!=null"
        }
    },
    "kretprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams based on the given txchainmask and max_streams.",
        "pre": {
            "ah->txchainmask": "!=null",
            "max_streams": "!=null"
        }
    },
    "kretprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams based on the given rxchainmask and max_streams.",
        "pre": {
            "ah->rxchainmask": "!=null",
            "max_streams": "!=null"
        }
    },
    "kretprobe:ath_dbg": {
        "description": "Print the number of TX streams and RX streams.",
        "pre": {
            "common": "!=null",
            "CONFIG": "!=null",
            "tx_streams": "!=null",
            "rx_streams": "!=null"
        }
    },
    "kretprobe:if": {
        "description": "Check if the number of TX streams is not equal to the number of RX streams.",
        "pre": {
            "tx_streams": "!=rx_streams"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set the memory at ht_info->mcs to zero.",
        "pre": {
            "ht_info": {
                "mcs": "0"
            }
        }
    },
    "kprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams for txchainmask and rxchainmask.",
        "pre": {
            "ah": "!=null",
            "txchainmask": "!=null",
            "max_streams": "!=null",
            "rxchainmask": "!=null"
        }
    },
    "kprobe:ath_dbg": {
        "description": "Print the number of TX streams and RX streams.",
        "pre": {
            "common": "!=null",
            "CONFIG": "!=null",
            "tx_streams": "!=null",
            "rx_streams": "!=null"
        }
    },
    "kprobe:if": {
        "description": "Check if the number of TX streams is not equal to the number of RX streams.",
        "pre": {
            "tx_streams": "!=rx_streams"
        }
    }
},
{
    "kretprobe:rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);if (rxsp->status11 & AR_RxKeyIdxValid)rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);elserxs->rs_keyix = ATH9K_RXKEYIX_INVALID;rxs->rs_rate = MS(rxsp->status1, AR_RxRate);rxs->rs_more = (rxsp->status2 & AR_RxMore) ? 1 : 0;rxs->rs_firstaggr = (rxsp->status11 & AR_RxFirstAggr) ? 1 : 0;rxs->rs_isaggr = (rxsp->status11 & AR_RxAggr) ? 1 : 0;rxs->rs_moreaggr = (rxsp->status11 & AR_RxMoreAggr) ? 1 : 0;rxs->rs_antenna = (MS(rxsp->status4, AR_RxAntenna) & 0x7);rxs->enc_flags |= (rxsp->status4 & AR_GI) ? RX_ENC_FLAG_SHORT_GI : 0;rxs->enc_flags |=(rxsp->status4 & AR_STBC) ? (1 << RX_ENC_FLAG_STBC_SHIFT) : 0;rxs->bw = (rxsp->status4 & AR_2040) ? RATE_INFO_BW_40 : RATE_INFO_BW_20;rxs->evm0 = rxsp->status6;rxs->evm1 = rxsp->status7;rxs->evm2 = rxsp->status8;rxs->evm3 = rxsp->status9;rxs->evm4 = (rxsp->status10 & 0xffff);if (rxsp->status11 & AR_PreDelimCRCErr)rxs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;if (rxsp->status11 & AR_PostDelimCRCErr)rxs->rs_flags |= ATH9K_RX_DELIM_CRC_POST;if (rxsp->status11 & AR_DecryptBusyErr)rxs->rs_flags |= ATH9K_RX_DECRYPT_BUSY;if ((rxsp->status11 & AR_RxFrameOK) == 0)": {
        "description": "Generate conditions for rxs->rs_rssi, rxs->rs_rssi_ctl, rxs->rs_rssi_ext, rxs->rs_keyix, rxs->rs_rate, rxs->rs_more, rxs->rs_firstaggr, rxs->rs_isaggr, rxs->rs_moreaggr, rxs->rs_antenna, rxs->enc_flags, rxs->bw, rxs->evm0, rxs->evm1, rxs->evm2, rxs->evm3, rxs->evm4, rxs->rs_flags",
        "pre": {
            "rxs->rs_rssi": "!=null",
            "rxs->rs_rssi_ctl[0]": "!=null",
            "rxs->rs_rssi_ctl[1]": "!=null",
            "rxs->rs_rssi_ctl[2]": "!=null",
            "rxs->rs_rssi_ext[0]": "!=null",
            "rxs->rs_rssi_ext[1]": "!=null",
            "rxs->rs_rssi_ext[2]": "!=null",
            "rxs->rs_keyix": "!=null",
            "rxs->rs_rate": "!=null",
            "rxs->rs_more": "!=null",
            "rxs->rs_firstaggr": "!=null",
            "rxs->rs_isaggr": "!=null",
            "rxs->rs_moreaggr": "!=null",
            "rxs->rs_antenna": "!=null",
            "rxs->enc_flags": "!=null",
            "rxs->bw": "!=null",
            "rxs->evm0": "!=null",
            "rxs->evm1": "!=null",
            "rxs->evm2": "!=null",
            "rxs->evm3": "!=null",
            "rxs->evm4": "!=null",
            "rxs->rs_flags": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_process_rxdesc_edma": {
        "description": "Process RX descriptor in ath9k hardware.",
        "pre": {
            "ah": "!=null",
            "rxs": "!=null",
            "buf_addr": "!=null",
            "rxsp": "!=null",
            "phyerr": "!=null",
            "rxsp->status11 & AR_RxDone": "!=0",
            "MS(rxsp->ds_info, AR_DescId)": "==0x168c",
            "(rxsp->ds_info & (AR_TxRxDesc | AR_CtrlStat))": "==0",
            "rxs->rs_status": "==0",
            "rxs->rs_flags": "==0",
            "rxs->enc_flags": "==0",
            "rxs->bw": "==RATE_INFO_BW_20",
            "rxs->rs_datalen": "==rxsp->status2 & AR_DataLen",
            "rxs->rs_tstamp": "==rxsp->status3"
        }
    }
},
{
    "kretprobe:ath9k_cmn_rx_accept": {
        "description": "Key miss events are only relevant for pairwise keys where the descriptor does contain a valid key index. This has been observed mostly with CCMP encryption.",
        "pre": {
            "rx_stats->rs_keyix": "== ATH9K_RXKEYIX_INVALID || !test_bit(rx_stats->rs_keyix, common->ccmp_keymap)",
            "is_valid_tkip": "&& !ieee80211_is_ctl(fc) && !ieee80211_has_morefrags(fc) && !(le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG)",
            "rx_stats->rs_status": "& ATH9K_RXERR_MIC"
        }
    }
},
{
    "kprobe:ath9k_cmn_rx_accept": {
        "description": "Accept an incoming packet in the ath9k driver.",
        "pre": {
            "common": "!=null",
            "hdr": "!=null",
            "rxs": "!=null",
            "rx_stats": "!=null",
            "decrypt_error": "!=null",
            "rxfilter": "!=null",
            "common->ah": "!=null",
            "hdr->frame_control": "!=null",
            "rx_stats->rs_keyix": "==ATH9K_RXKEYIX_INVALID || !test_bit(rx_stats->rs_keyix, common->tkip_keymap)",
            "is_valid_tkip": "rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID && test_bit(rx_stats->rs_keyix, common->tkip_keymap)",
            "strip_mic": "is_valid_tkip && ieee80211_is_data(hdr->frame_control) && ieee80211_has_protected(hdr->frame_control) && !(rx_stats->rs_status & (ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC | ATH9K_RXERR_KEYMISS))"
        }
    }
},
{
    "kretprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "See if any padding is done by the hw and remove it.",
        "pre": {
            "common": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "decrypt_error": "!=null",
            "ah": "common->ah",
            "hdr": "!=null",
            "hdrlen": "ieee80211_get_hdrlen_from_skb(skb)",
            "padpos": "!=null",
            "padsize": "(4 - padpos % 4) % 4",
            "keyix": "!=null",
            "fc": "hdr->frame_control"
        }
    }
},
{
    "kprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "See if any padding is done by the hw and remove it.",
        "pre": {
            "common": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "decrypt_error": "!=null",
            "ah": "!=null",
            "hdr": "!=null",
            "hdrlen": "!=null",
            "padpos": "!=null",
            "padsize": "!=null",
            "keyix": "!=null",
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_cmn_process_rate": {
        "description": "Process rate for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "sband": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "i": ">=0",
            "ah": "!=null",
            "ah.curchan": "!=null",
            "ah.curchan.chan": "!=null",
            "ah.curchan.chan.band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "hw.wiphy": "!=null",
            "hw.wiphy.bands": "!=null",
            "hw.wiphy.bands[band]": "!=null",
            "rxs.bw": "in [RATE_INFO_BW_5, RATE_INFO_BW_10]",
            "rx_stats.rs_rate": ">=0",
            "rx_stats.rs_rate & 0x80": "==0"
        },
        "post": {
            "rxs.encoding": "==RX_ENC_HT",
            "rxs.enc_flags": "|=rx_stats.enc_flags",
            "rxs.bw": "==rx_stats.bw",
            "rxs.rate_idx": "==rx_stats.rs_rate & 0x7f",
            "return": "==0"
        }
    }
},
{
    "kprobe:ath9k_cmn_process_rate": {
        "description": "Process rate for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "sband": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "i": ">=0",
            "ah": "!=null",
            "ah.curchan": "!=null",
            "ah.curchan.chan": "!=null",
            "ah.curchan.chan.band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "hw.wiphy": "!=null",
            "hw.wiphy.bands": "!=null",
            "hw.wiphy.bands[band]": "!=null",
            "rxs.bw": "in [RATE_INFO_BW_5, RATE_INFO_BW_10]",
            "rx_stats.rs_rate": ">=0",
            "rx_stats.rs_rate & 0x7f": "==rxs.rate_idx",
            "rx_stats.rs_rate & 0x80": "in [0, 1]"
        }
    }
},
S,
{
    "kprobe:if (rx_stats->rs_moreaggr)": {
        "description": "Check if rs_moreaggr is true.",
        "pre": {
            "rx_stats": "!=null",
            "rx_stats->rs_moreaggr": "==true"
        }
    }
},
{
    "kretprobe:ath9k_cmn_update_txpow": {
        "description": "Update the transmit power level.",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "!=null",
            "new_txpow": "!=null",
            "txpower": "!=null",
            "reg": "!=null",
            "reg->power_limit": "!=new_txpow",
            "ah->curchan": "!=null"
        }
    }
},
{
    "kprobe:ath9k_cmn_update_txpow": {
        "description": "Update the transmit power level for the ath9k wireless driver.",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "!=null",
            "new_txpow": "!=null",
            "txpower": "!=null",
            "reg": "!=null",
            "reg->power_limit": "!=new_txpow",
            "ah->curchan": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:rval = REG_READ(ah, AR_WOW_PATTERN);val = AR_WOW_STATUS(rval);/* * Mask only the WoW events that we have enabled. Sometimes * we have spurious WoW events from the AR_WOW_PATTERN * register. This mask will clean it up.": {
        "description": "Read the WoW status register to know the wakeup reason.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:rval = REG_READ(ah, AR_WOW_PATTERN);val = AR_WOW_STATUS(rval);/* * Mask only the WoW events that we have enabled. Sometimes * we have spurious WoW events from the AR_WOW_PATTERN * register. This mask will clean it up.": {
        "description": "Read the WoW status register to know the wakeup reason.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:REG_SET_BIT": {
        "description": "",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_HOST_PME_EN | AR_PMCTRL_PWR_PM_CTRL_ENA | AR_PMCTRL_AUX_PWR_DET | AR_PMCTRL_WOW_PME_CLR": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null",
            "AR_WOW_PATTERN": "!=null"
        }
    }
},
{
    "kprobe:REG_SET_BIT": {
        "description": "Set specific bits in the register",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_HOST_PME_EN": "!=null",
            "AR_PMCTRL_PWR_PM_CTRL_ENA": "!=null",
            "AR_PMCTRL_AUX_PWR_DET": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null"
        }
    },
    "kprobe:REG_CLR_BIT": {
        "description": "Clear specific bits in the register",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_sample_tx_ts": {
        "description": "Status timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_sample_tx_ts": {
        "description": "Status timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_node_init": {
        "description": "Initialize ath_node related information.",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_init": {
        "description": "Init ath_node related info",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_node_deinit": {
        "description": "Deinitialize ath_node related info",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_deinit": {
        "description": "Deinitialize ath_node related info.",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_reset": {
        "description": "Reset dynack processing",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_reset": {
        "description": "Reset dynack processing",
        "pre": {
            "ah": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_mci_get_interrupt": {
        "description": "This function is responsible for getting interrupts in the AR9003 MCI module.",
        "pre": {
            "ar9003_mci_state(ah, MCI_STATE_ENABLE)": true,
            "mci->bt_state": "!= MCI_BT_SLEEP",
            "!mci->halted_bt_gpm": true
        },
        "post": {
            "mci->ready": false
        }
    }
},
{
    "kprobe:ar9003_mci_get_interrupt": {
        "description": "This function handles the interrupt for ar9003_mci.",
        "pre": {
            "ar9003_mci_state(ah, MCI_STATE_ENABLE)": true,
            "mci->bt_state != MCI_BT_SLEEP": true,
            "!mci->halted_bt_gpm": true
        }
    }
},
{
    "description": "Check if gpm_type is MCI_GPM_BT_CAL_GRANT and recv_type is MCI_GPM_BT_CAL_REQ",
    "pre": {
        "gpm_type": "== MCI_GPM_BT_CAL_GRANT",
        "recv_type": "== MCI_GPM_BT_CAL_REQ"
    }
},
{
    "description": "Check if gpm_type is MCI_GPM_BT_CAL_GRANT and recv_type is MCI_GPM_BT_CAL_REQ",
    "pre": {
        "gpm_type": "== MCI_GPM_BT_CAL_GRANT",
        "recv_type": "== MCI_GPM_BT_CAL_REQ"
    }
},
{
    "kretprobe:ath_cmn_process_fft": {
        "description": "Process FFT data for spectral scan.",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": "!=null",
            "tsf": "!=null",
            "rs->rs_phyerr": "not in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ath_cmn_process_fft": {
        "description": "Process FFT data for spectral scan.",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": {
                "rs_phyerr": "not in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]"
            }
        }
    }
},
{
    "kretprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "Spectral scan trigger function for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "rxfilter": "!=null",
            "ath9k_hw_ops(spec_priv->ah)->spectral_scan_trigger": "!=null",
            "spec_priv->spec_config.enabled": "==true",
            "ath_ps_ops(common)->wakeup": "!=null",
            "ath9k_hw_getrxfilter(spec_priv->ah)": "!=null",
            "ath9k_hw_setrxfilter(spec_priv->ah, rxfilter | ATH9K_RX_FILTER_PHYRADAR | ATH9K_RX_FILTER_PHYERR)": "!=null"
        }
    }
},
{
    "kprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "Trigger the spectral scan on the specified hardware.",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "rxfilter": "!=null",
            "ath9k_hw_ops(spec_priv->ah)->spectral_scan_trigger": "!=null",
            "spec_priv->spec_config.enabled": "==true"
        }
    }
},
S,
S,
{
    "kretprobe:ath11k_ce_get_shadow_config": {
        "description": "Check if shadow configuration is already done.",
        "pre": {
            "ab": "!=null",
            "shadow_cfg": "!=null",
            "shadow_cfg_len": "!=null",
            "ab->hw_params.supports_shadow_regs": "==true"
        },
        "post": {
            "*shadow_cfg_len": "==0"
        }
    }
},
{
    "kprobe:ath11k_ce_get_shadow_config": {
        "description": "Get the shadow configuration for CE (Copy Engine) registers in ath11k.",
        "pre": {
            "shadow_cfg_len": "==0",
            "ab->hw_params.supports_shadow_regs": "==false"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ath11k_core_suspend": {
        "description": "Suspend the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==true"
        }
    }
},
{
    "kprobe:ath11k_core_suspend": {
        "description": "Suspend the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==false"
        }
    }
},
{
    "kretprobe:ath11k_core_resume": {
        "description": "Resume the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==true"
        }
    }
},
{
    "kprobe:ath11k_core_resume": {
        "description": "Resume the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar->state": "==ATH11K_STATE_OFF"
        }
    }
},
S,
S,
{
    "kretprobe:done:return tot_work_done;}EXPORT_SYMBOL(ath11k_dp_service_srng": {
        "description": "Function to handle ath11k_dp_service_srng",
        "pre": {
            "ab": "!=null",
            "irq_grp": "!=null",
            "budget": "!=null",
            "napi": "!=null",
            "hal_params": "!=null",
            "grp_id": "!=null",
            "work_done": ">=0",
            "i": ">=0",
            "j": ">=0",
            "tot_work_done": ">=0",
            "ab->hw_params.max_tx_ring": ">=0",
            "ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num": ">=0",
            "ab->hw_params.ring_mask->tx[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_err[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_wbm_rel[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_mon_status[grp_id]": ">=0",
            "ab->num_radios": ">=0",
            "ab->hw_params.num_rxmda_per_pdev": ">=0",
            "ab->hw_params.ring_mask->reo_status[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rxdma2host[grp_id]": ">=0",
            "ab->hw_params.ring_mask->host2rxdma[grp_id]": ">=0",
            "id": ">=0",
            "ath11k_ab_to_ar(ab, id)": "!=null",
            "ath11k_ab_to_ar(ab, id)->dp": "!=null",
            "ath11k_ab_to_ar(ab, id)->dp->rx_refill_buf_ring": "!=null",
            "ab->hw_params.hal_params->rx_buf_rbm": ">=0"
        }
    }
},
S,
{
    "kretprobe:ath11k_debugfs_soc_destroy": {
        "description": "Destroy the debugfs_soc object for ath11k_base",
        "pre": {
            "ab": "!=null",
            "ab->debugfs_soc": "!=null"
        }
    }
},
{
    "kprobe:ath11k_debugfs_soc_destroy": {
        "description": "Destroy the debugfs_soc directory associated with the ath11k_base structure.",
        "pre": {
            "ab": "!=null"
        }
    }
},
S,
{
    "kprobe:trace_ath11k_log_dbg_dump": {
        "description": "Debug dump function for ath11k",
        "pre": {
            "ab": "!=null",
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);__ath11k_pcic_write32(ab, offset, value);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);}EXPORT_SYMBOL(ath11k_pcic_write32": {
        "description": "The `ath11k_pcic_write32` function writes a 32-bit value to a specific offset in the `ab` device's memory.",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START",
            "value": "!=null",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "==0",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);__ath11k_pcic_write32(ab, offset, value);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);}EXPORT_SYMBOL(ath11k_pcic_write32": {
        "description": "Function to write a 32-bit value to the PCI configuration space of the ath11k device.",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START",
            "value": "!=null",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "!=null",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required": {
        "description": "Check if wakeup is required before accessing the device.",
        "pre": {
            "test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags)": "true",
            "offset": ">= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        },
        "post": {
            "ret": "null",
            "val": "!= null"
        }
    },
    "kretprobe:ab->pci.ops->wakeup": {
        "description": "Call the wakeup function of ab->pci.ops if wakeup is required.",
        "pre": {
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!= null"
        },
        "post": {
            "ret": "null"
        }
    },
    "kretprobe:__ath11k_pcic_read32": {
        "description": "Read a 32-bit value from the device.",
        "pre": {
            "ab": "!= null",
            "offset": ">= ATH11K_PCI_WINDOW_START"
        },
        "post": {
            "val": "!= null"
        }
    },
    "kretprobe:ab->pci.ops->release": {
        "description": "Call the release function of ab->pci.ops if wakeup is not required and ret is null.",
        "pre": {
            "wakeup_required": "true",
            "ret": "null",
            "ab->pci.ops->release": "!= null"
        },
        "post": {}
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);val = __ath11k_pcic_read32(ab, offset);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);return val;}EXPORT_SYMBOL(ath11k_pcic_read32": {
        "description": "Function to read a 32-bit value from the PCI configuration space of the ATH11K device.",
        "pre": {
            "ab": "!=null",
            "offset": ">=ATH11K_PCI_WINDOW_START",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "0",
            "val": "!=null",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required": {
        "description": "Check if wakeup is required before accessing the device.",
        "pre": {
            "test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags)": "true",
            "offset": ">= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        }
    },
    "kretprobe:ab->pci.ops->wakeup": {
        "description": "Call the wakeup function of the PCI operations.",
        "pre": {
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!= null"
        }
    },
    "kretprobe:__ath11k_pcic_read32": {
        "description": "Read a 32-bit value from the device.",
        "pre": {
            "ab": "!= null",
            "offset": ">= ATH11K_PCI_WINDOW_START"
        }
    },
    "kretprobe:ab->pci.ops->release": {
        "description": "Call the release function of the PCI operations.",
        "pre": {
            "wakeup_required": "true",
            "!ret": "true",
            "ab->pci.ops->release": "!= null"
        }
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);val = __ath11k_pcic_read32(ab, offset);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);return val;}EXPORT_SYMBOL(ath11k_pcic_read": {
        "description": "Function to read a 32-bit value from the PCI configuration space of the ath11k device.",
        "pre": {
            "ab": "!=null",
            "offset": ">=ATH11K_PCI_WINDOW_START",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "0",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:ath11k_pcic_ext_irq_enable": {
        "description": "Enable external IRQ for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "irq_grp": "!=null",
            "irq_grp->ab": "!=null",
            "irq_grp->num_irq": ">=0",
            "irq_grp->irqs[i]": ">=0",
            "irq_grp->ab->irq_num[irq_grp->irqs[i]]": ">=0"
        }
    }
},
{
    "kprobe:ath11k_pcic_ext_irq_enable": {
        "description": "Enable external IRQ for ath11k_base.",
        "pre": {
            "!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags)": true,
            "i": ">= 0",
            "i": "< irq_grp->num_irq",
            "enable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]])": true
        }
    }
},
{
    "for (i = 0, msi_data_idx = 0; i < ab->hw_params.ce_count; i++)": {
        "description": "Loop over CE parameters",
        "pre": {
            "i": "integer",
            "msi_data_idx": "integer",
            "ab->hw_params.ce_count": "integer"
        }
    }
},
{
    "kprobe:ath11k_pcic_config_irq": {
        "description": "Configure CE irqs",
        "pre": {
            "ab->hw_params.ce_count": ">0",
            "i": ">=0",
            "msi_data_idx": ">=0"
        }
    }
},
{
    "kretprobe:ath11k_pcic_register_pci_ops": {
        "description": "Register PCI operations for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "!pci_ops->get_msi_irq": true,
            "!pci_ops->window_write32": true,
            "!pci_ops->window_read32": true
        }
    }
},
{
    "kprobe:ath11k_pcic_register_pci_ops": {
        "description": "Register PCI operations for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "!pci_ops->get_msi_irq": true,
            "!pci_ops->window_write32": true,
            "!pci_ops->window_read32": true
        }
    }
},
{
    "kretprobe:write_index = CE_RING_IDX_INCR(nentries_mask, write_index);/* WORKAROUND `": {
        "description": "Update the write index of the source ring in the CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": "> 0",
            "transfer_id": ">= 0",
            "flags": ">= 0",
            "ar": "!=null",
            "src_ring": "!=null",
            "nentries_mask": ">= 0",
            "sw_index": ">= 0",
            "write_index": ">= 0",
            "ctrl_addr": ">= 0",
            "desc_flags": ">= 0",
            "ret": ">= 0"
        }
    }
},
{
    "kprobe:write_index = CE_RING_IDX_INCR(nentries_mask, write_index);/* WORKAROUND `": {
        "description": "Update the value of write_index using CE_RING_IDX_INCR function.",
        "pre": {
            "nentries_mask": "!=null",
            "write_index": "!=null"
        }
    }
},
{
    "kretprobe:__ath10k_ce_send_revert": {
        "description": "This function must be called only if there is an incomplete scatter-gather transfer (before index register is updated) that needs to be cleaned up.",
        "pre": {
            "pipe": "!=null",
            "pipe->ar": "!=null",
            "pipe->ar->ce": "!=null",
            "pipe->src_ring": "!=null",
            "pipe->ctrl_addr": "!=null",
            "ce->ce_lock": "held"
        }
    }
},
{
    "kprobe:__ath10k_ce_send_revert": {
        "description": "This function must be called only if there is an incomplete scatter-gather transfer (before index register is updated) that needs to be cleaned up.",
        "pre": {
            "pipe": "!=null",
            "pipe->ar": "!=null",
            "pipe->ar->ce": "!=null",
            "pipe->src_ring": "!=null",
            "pipe->ctrl_addr": "!=null",
            "ce->ce_lock": "held"
        }
    }
},
{
    "kretprobe:_ath10k_ce_send_nolock": {
        "description": "Send data using the ath10k_ce_send function.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:_ath10k_ce_send_nolock": {
        "description": "Send data using the ath10k_ce_send helper.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "pre": {
            "pipe": "!=null",
            "nentries": "!=null",
            "ar": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "ctrl_addr": "!=null",
            "cur_write_idx": "!=null",
            "cur_write_idx + nentries": "== dest_ring->sw_index",
            "nentries": "-= 1",
            "write_index": "= CE_RING_IDX_ADD(nentries_mask, write_index, nentries)",
            "ath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index)": "",
            "dest_ring->write_index": "= write_index"
        }
    }
},
{
    "kprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "pre": {
            "pipe": "!=null",
            "nentries": "!=null",
            "ar": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "ctrl_addr": "!=null",
            "cur_write_idx": "!=null",
            "((cur_write_idx + nentries) & nentries_mask)": "== dest_ring->sw_index",
            "nentries": "-= 1",
            "write_index": "= CE_RING_IDX_ADD(nentries_mask, write_index, nentries)",
            "ath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index)": "",
            "dest_ring->write_index": "= write_index"
        }
    }
},
{
    "kretprobe:ath10k_ce_rx_post_buf": {
        "description": "Post a buffer to the receive ring of the ath10k CE pipe.",
        "pre": {
            "pipe": "!=null",
            "ctx": "!=null",
            "paddr": "!=null",
            "ar": "!=null",
            "ce": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "sw_index": "!=null",
            "base": "!=null",
            "desc": "!=null",
            "ctrl_addr": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_rx_post_buf": {
        "description": "Post a buffer to the receive ring of the ath10k CE pipe.",
        "pre": {
            "pipe": "!=null",
            "ctx": "!=null",
            "paddr": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_completed_recv_next_nolock": {
        "description": "Copy in one go for performance reasons",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "sw_index": "!=null",
            "base": "!=null",
            "desc": "!=null",
            "sdesc": "!=null",
            "nbytes": "!=null",
            "nbytes": "==0"
        }
    }
},
{
    "kprobe:sdesc = *desc;nbytes = __le16_to_cpu(sdesc.nbytes);if (nbytes == 0)": {
        "description": "Copy in one go for performance reasons",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kretprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_revoke_recv_next": {
        "description": "Return data from completed destination descriptor",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null",
            "ce_state->dest_ring": "!=null",
            "dest_ring->nentries_mask": "!=null",
            "dest_ring->sw_index": "!=null",
            "dest_ring->write_index": "!=null",
            "dest_ring->write_index": "!=dest_ring->sw_index",
            "dest_ring->base_addr_owner_space": "!=null",
            "dest_ring->base_addr_owner_space[dest_ring->sw_index]": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_revoke_recv_next": {
        "description": "Revoke the next received data from the ath10k CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_src_ring_read_index_get": {
        "description": "Read the index from the source ring.",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null"
        }
    },
    "kretprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "Send the next completed transfer without locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "src_ring": "!=null",
            "src_ring->nentries_mask": "!=null",
            "src_ring->sw_index": "!=null",
            "src_ring->hw_index": "!=null",
            "ar": "!=null",
            "ar->hw_params.rri_on_ddr": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, -EIO]"
        }
    }
},
{
    "kprobe:ath10k_ce_src_ring_read_index_get": {
        "description": "Read the index from the source ring.",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null"
        }
    },
    "kprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "Send the next completed transfer without locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "src_ring": "!=null",
            "src_ring.hw_index": "read_index",
            "src_ring.nentries_mask": "!=null",
            "src_ring.sw_index": "!=null",
            "read_index": "!=0xffffffff",
            "read_index": "&= nentries_mask",
            "src_ring.hw_index": "read_index"
        }
    }
},
{
    "kretprobe:ath10k_ce_cancel_send_next": {
        "description": "Cancel the next send operation on the CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "==null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null",
            "src_ring": "!=null",
            "nentries_mask": "!=null",
            "sw_index": "!=null",
            "write_index": "!=null",
            "ar": "!=null",
            "ce": "!=null"
        }
    }
},
{
    "kprobe:src_ring->per_transfer_context[sw_index] = NULL;/* Update sw_index `": {
        "description": "Update sw_index in src_ring and set per_transfer_context[sw_index] to NULL.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null"
        }
    }
},
{
    "kretprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_engine_int_status_clear": {
        "description": "Clear before handling Misc CE interrupts",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null",
            "wm_regs.cc_mask | wm_regs.wm_mask": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_engine_int_status_clear": {
        "description": "Clear before handling Misc CE interrupts.",
        "pre": {
            "ar": "!=null",
            "ce_id": "!=null",
            "ce_state": "!=null",
            "wm_regs": "!=null",
            "ctrl_addr": "!=null",
            "wm_regs->cc_mask | wm_regs->wm_mask": "!=null"
        }
    }
},
{
    "kretprobe:continue;ath10k_ce_per_engine_service(ar, ce_id);}}EXPORT_SYMBOL(ath10k_ce_per_engine_service_any": {
        "description": "This function services the per-engine interrupt for the ath10k device.",
        "pre": {
            "ar": "!=null",
            "ce_id": ">=0",
            "intr_summary": ">=0",
            "intr_summary & (1 << ce_id)": "!=0"
        }
    }
},
{
    "kprobe:continue;ath10k_ce_per_engine_service(ar, ce_id);}}EXPORT_SYMBOL(ath10k_ce_per_engine_service_any": {
        "description": "Performs per-engine service for ath10k.",
        "pre": {
            "ar": "!=null",
            "ce_id": ">=0 && <=CE_COUNT",
            "intr_summary": ">=0"
        }
    }
},
{
    "kretprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engines that are not using polling mode.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engines that are not using polling mode.",
        "pre": {
            "ar": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "pre": {
            "ar->hw_params.delay_unmap_buffer": "true",
            "ep->ul_pipe_id": "== 3"
        },
        "post": {
            "hdr": "!= null",
            "ep->ep_ops.ep_tx_complete": "false"
        }
    }
},
{
    "kprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "pre": {
            "ar->hw_params.delay_unmap_buffer": "true",
            "ep->ul_pipe_id": "== 3"
        }
    }
},
{
    "kretprobe:ath10k_htc_tx_completion_handler": {
        "description": "Handle the completion of a transmit operation in the ath10k_htc module.",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:ath10k_htc_tx_completion_handler": {
        "description": "Handles the completion of a transmit operation in the ath10k_htc module.",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:trailer_present": {
        "description": "Check if the trailer is present in the header flags",
        "pre": {
            "hdr": "!=null",
            "hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT": "!=0"
        }
    }
},
{
    "kprobe:trailer_present": {
        "description": "Check if the trailer is present in the header flags",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "!=null",
            "hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT": "!=0"
        }
    }
},
S,
{
    "kprobe:ath10k_core_create_board_name": {
        "description": "Create the board name for ath10k_core.",
        "pre": {
            "ar": "!=null",
            "boardname": "!=null",
            "sizeof(boardname)": ">=100",
            "true": "true",
            "true": "true"
        }
    }
},
{
    "kretprobe:ath10k_core_stop": {
        "description": "Try to suspend target.",
        "pre": {
            "ar->state": "!= ATH10K_STATE_RESTARTING && != ATH10K_STATE_UTF",
            "ar->conf_mutex": "held"
        },
        "post": {
            "ar->id.bmi_ids_valid": "false"
        }
    }
},
S,
{
    "kretprobe:set_bit": {
        "description": "Set a bit in a bitfield.",
        "pre": {
            "bitfield": "!=null",
            "bit": "!=null",
            "value": "!=null"
        }
    },
    "kretprobe:ath10k_core_probe_fw": {
        "description": "Probe the firmware of the ath10k core.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:set_bit": {
        "description": "Set a bit in a given memory location.",
        "pre": {
            "bit": ">= 0",
            "addr": "!= null"
        }
    }
},
{
    "kretprobe:ath10k_spectral_destroy": {
        "description": "Destroy the spectral functionality in ath10k.",
        "pre": {
            "ar": "!=null",
            "cancel_work_sync(&ar->register_work)": "called",
            "test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags)": "true",
            "ath10k_thermal_unregister(ar)": "called",
            "stop_spectral_before_unregistering": "true",
            "parent_debugfs_tree_freed_recursively": "false"
        }
    }
},
{
    "kprobe:ath10k_spectral_destroy": {
        "description": "Unregister from mac80211 before stopping HTC and HIF.",
        "pre": {
            "ar": "!=null",
            "ar->register_work": "cancelled",
            "ar->dev_flags": "contains ATH10K_FLAG_CORE_REGISTERED",
            "ath10k_thermal_unregister(ar)": "called",
            "spectral": "stopped",
            "mac80211": "unregistered",
            "relayfs debugfs file": "removed",
            "parent debugfs tree": "not recursively freed"
        }
    }
},
{
    "kretprobe:ath10k_core_create_board_name": {
        "description": "Create board name for ath10k core.",
        "pre": {
            "ar": "!=null",
            "name": "!=null",
            "name_len": ">= (9 + ATH10K_SMBIOS_BDF_EXT_STR_LENGTH)",
            "with_variant": "boolean",
            "with_chip_id": "boolean"
        }
    }
},
{
    "ath10k_core_create_board_name": {
        "description": "Create the board name for ath10k core.",
        "pre": {
            "ar": "!=null",
            "name": "!=null",
            "name_len": ">= (9 + ATH10K_SMBIOS_BDF_EXT_STR_LENGTH)",
            "with_variant": "boolean",
            "with_chip_id": "boolean"
        }
    }
},
{
    "kretprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k.",
        "pre": {
            "ar": "!=null",
            "mask": "in [ATH10K_DBG_MASK_1, ATH10K_DBG_MASK_2, ATH10K_DBG_MASK_3]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k.",
        "pre": {
            "ar": "!=null",
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:size += hw->region_table.size * sizeof(struct ath10k_dump_ram_data_hdr)": {
        "description": "Reserve space for the headers",
        "pre": {
            "hw": "!=null",
            "hw->region_table.size": ">0",
            "sizeof(struct ath10k_dump_ram_data_hdr)": ">0"
        }
    }
},
S,
{
    "kretprobe:ath10k_coredump_new": {
        "description": "Create a new coredump for the ath10k driver.",
        "pre": {
            "ar": "!=null",
            "crash_data": "!=null",
            "ar->coredump.fw_crash_data": "!=null",
            "ar->dump_mutex": "held",
            "ath10k_coredump_mask": "==0"
        },
        "post": {
            "return": "crash_data",
            "crash_data->guid": "generated",
            "crash_data->timestamp": "generated"
        }
    }
},
{
    "kprobe:ath10k_coredump_new": {
        "description": "Create a new coredump for the ath10k driver.",
        "pre": {
            "ar": "!=null",
            "crash_data": "!=null",
            "ar->coredump.fw_crash_data": "!=null",
            "lockdep_assert_held(&ar->dump_mutex)": "true",
            "ath10k_coredump_mask": "!=0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:try_module_get": {
        "description": "Get a module reference to avoid unloading and schedule removal.",
        "pre": {
            "THIS_MODULE": "!=null"
        }
    }
},
{
    "kprobe:try_module_get": {
        "description": "Get a module reference to avoid unloading and schedule removal.",
        "pre": {
            "THIS_MODULE": "!=null"
        }
    }
},
{
    "kretprobe:il_update_stats": {
        "description": "Record all the MGMT, CTRL, and DATA packets for both TX and Rx using debugfs to display the rxrx_stats.",
        "pre": {
            "il": "!=null",
            "is_tx": "is boolean",
            "fc": "is 16-bit little-endian",
            "len": "is 16-bit"
        }
    }
},
{
    "kprobe:il_update_stats": {
        "description": "Record MGMT, CTRL, and DATA packets for both TX and Rx",
        "pre": {
            "il": "!=null",
            "is_tx": "is boolean",
            "fc": "!=null",
            "len": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:BUG_ON": {
        "description": "Check if cmd->callback is not null.",
        "pre": {
            "cmd->callback": "==null"
        }
    },
    "kretprobe:D_INFO": {
        "description": "Print debug information for the command.",
        "pre": {
            "cmd": "!=null",
            "cmd->id": "!=null"
        }
    },
    "kretprobe:set_bit": {
        "description": "Set the S_HCMD_ACTIVE bit in il->status.",
        "pre": {
            "il": "!=null",
            "&il->status": "!=null"
        }
    },
    "kretprobe:il_enqueue_hcmd": {
        "description": "Enqueue the command in il.",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd_idx": "<0"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if cmd->callback is not null.",
        "pre": {
            "cmd->callback": "==null"
        }
    },
    "kprobe:D_INFO": {
        "description": "Print debug information about the command being sent.",
        "pre": {
            "cmd->id": "!=null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the S_HCMD_ACTIVE bit in il->status.",
        "pre": {
            "il->status": "!=null"
        }
    },
    "kprobe:il_enqueue_hcmd": {
        "description": "Enqueue the command in il and get the index.",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd_idx": "<0"
        }
    }
},
{
    "kretprobe:BUG_ON(cmd->flags & CMD_WANT_SKB)": {
        "description": "Check if the CMD_WANT_SKB flag is set in the flags field of the cmd structure.",
        "pre": {
            "cmd": "!=null",
            "cmd->flags": "& CMD_WANT_SKB != 0"
        }
    }
},
{
    "kprobe:BUG_ON(cmd->flags & CMD_WANT_SKB);/* Assign a generic callback if one is not provided */": {
        "description": "Check if the CMD_WANT_SKB flag is set in the flags field of the cmd structure and trigger a bug if it is.",
        "pre": {
            "cmd": {
                "flags": "& CMD_WANT_SKB == 0"
            }
        }
    }
},
{
    "kretprobe:intil_eeprom_init": {
        "description": "Read EEPROM contents. Load the EEPROM contents from the adapter into il->eeprom. Note: This routine uses the non-debug IO access functions.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_eeprom_init": {
        "description": "Read EEPROM contents from adapter into il->eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:intil_init_channel_map": {
        "description": "Set up driver's info for all possible channels",
        "pre": {
            "il": "!=null",
            "band": "!=null",
            "channel": "!=null",
            "ch_info": "!=null",
            "eeprom_ch": "!=null",
            "il_is_channel_valid(ch_info)": "==0",
            "eeprom_ch->flags & EEPROM_CHANNEL_VALID": "==0",
            "ch_info->ht40_extension_channel": "==clear_ht40_extension_channel"
        }
    }
},
{
    "kprobe:intil_init_channel_map": {
        "description": "Set up driver's info for all possible channels",
        "pre": {
            "il": "!=null",
            "band": "!=null",
            "channel": "!=null",
            "il_is_channel_valid(il_get_channel_info(il, band, channel))": "==true",
            "D_EEPROM": "called",
            "ch_info->ht40_extension_channel": "==clear_ht40_extension_channel",
            "return": "==0"
        }
    }
},
{
    "kretprobe:il_free_channel_map": {
        "description": "undo allocations in il_init_channel_map",
        "pre": {}
    }
},
{
    "kprobe:il_free_channel_map": {
        "description": "undo allocations in il_init_channel_map",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:intil_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:intil_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null",
            "ms": ">=0"
        }
    }
},
{
    "kprobe:intil_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null",
            "ms": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:il_get_passive_dwell_time": {
        "description": "Calculate the passive dwell time based on the given parameters.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        }
    }
},
{
    "kprobe:il_get_passive_dwell_time": {
        "description": "Get the passive dwell time for the given parameters.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        }
    }
},
{
    "kretprobe:il_mac_hw_scan": {
        "description": "Scan the hardware for available networks.",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "req->n_channels": ">0",
            "il->mutex": "locked",
            "il->status": "!S_SCANNING"
        },
        "post": {
            "ret": "is an integer"
        }
    }
},
{
    "kprobe:il_mac_hw_scan": {
        "description": "Scan the hardware for available networks.",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "req": "!=null",
            "il": "!=null",
            "ret": "int",
            "req->n_channels": ">0",
            "il->mutex": "locked",
            "il->status": "bit not set for S_SCANNING"
        }
    }
},
{
    "kretprobe:u16il_fill_probe_req": {
        "description": "Fill in all required fields and IE for probe request",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": ">=0",
            "left": ">=0"
        }
    }
},
{
    "kprobe:u16il_fill_probe_req": {
        "description": "fill in all required fields and IE for probe request",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": "any",
            "left": "any"
        }
    }
},
S,
S,
{
    "kretprobe:il_clear_ucode_stations": {
        "description": "Clear ucode station table bits",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_clear_ucode_stations": {
        "description": "Clear ucode station table bits",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
{
    "kprobe:il_restore_stations": {
        "description": "Restore driver known stations to device. All stations considered active by driver, but not present in ucode, are restored. Function sleeps.",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "pre": {
            "q": "!=null",
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:voidil_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:voidil_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:il_set_decrypted_flag": {
        "description": "Set the decrypted flag in the il_priv structure based on the decrypt_res value.",
        "pre": {
            "il": "!=null",
            "hdr": "!=null",
            "decrypt_res": "!=null",
            "stats": "!=null",
            "fc": "!=null",
            "fc": "&",
            "fc": "IEEE80211_FCTL_PROTECTED",
            "decrypt_res": "&",
            "decrypt_res": "RX_RES_STATUS_SEC_TYPE_MSK"
        }
    }
},
S,
{
    "kretprobe:il_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kprobe:il_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "pre": {
            "il": "!=null",
            "txq_id": "is_integer"
        }
    }
},
{
    "kprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        }
    }
},
{
    "kretprobe:il_tx_queue_free": {
        "description": "Deallocate DMA queue.",
        "pre": {
            "il": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kprobe:voidil_tx_queue_free": {
        "description": "Deallocate DMA queue.",
        "pre": {
            "il": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kretprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_queue_space": {
        "description": "Calculate the available space in the il_queue",
        "pre": {
            "q": "!=null",
            "q->read_ptr": "!=null",
            "q->write_ptr": "!=null",
            "q->n_bd": "!=null",
            "q->n_win": "!=null"
        },
        "post": {
            "s": ">= 0"
        }
    }
},
{
    "kprobe:il_queue_space": {
        "description": "Calculate the available space in the il_queue",
        "pre": {
            "q": "!=null",
            "q->read_ptr": "!=null",
            "q->write_ptr": "!=null",
            "q->n_bd": "!=null",
            "q->n_win": "!=null",
            "s": "!=null",
            "s": "q->read_ptr - q->write_ptr",
            "q->read_ptr > q->write_ptr": "s -= q->n_bd",
            "s <= 0": "s += q->n_win"
        }
    }
},
S,
S,
{
    "kretprobe:il_queue_init": {
        "description": "Initialize queue's highlow-water marks, and headtail idxes",
        "pre": {
            "il": "!=null",
            "&txq->q": "!=null",
            "slots": "in [TFD_CMD_SLOTS, TFD_TX_CMD_SLOTS]",
            "txq_id": "!=null"
        }
    }
},
{
    "kprobe:il_queue_init": {
        "description": "Initialize queue's highlow-water marks, and headtail idxes.",
        "pre": {
            "il": "!=null",
            "txq->q": "!=null",
            "slots": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them",
        "pre": {
            "il": "!=null",
            "rxb": "!=null",
            "rxb->async_callback": "!=null",
            "rxb->async_callback_return": "==1",
            "rxb->skb": "==null || rxb->async_callback_return != 1"
        }
    }
},
{
    "kprobe:il_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them",
        "pre": {
            "il": "!=null",
            "rxb": "!=null",
            "rxb->callback": "!=null",
            "rxb->callback_return": "==1",
            "rxb->skb": "==null"
        }
    }
},
{
    "kretprobe:intil_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_free_geos": {
        "description": "undo allocations in il_init_geos",
        "pre": {}
    }
},
{
    "kprobe:il_free_geos": {
        "description": "undo allocations in il_init_geos",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:u8il_prep_station": {
        "description": "Prepare station information for addition",
        "pre": {
            "il": "!=null",
            "addr": "!=null",
            "is_ap": "is boolean",
            "sta": "!=null",
            "sta_lock": "held"
        }
    }
},
S,
{
    "kretprobe:il->timing.atim_win = 0;beacon_int = il_adjust_beacon_interval(beacon_int, il->hw_params.max_beacon_itrvl * TIME_UNIT);il->timing.beacon_interval = cpu_to_le16(beacon_int);tsf = il->timestamp;/* tsf is modifed by do_div: copy it`": {
        "description": "Set the timing parameters for the il structure.",
        "pre": {
            "il": "!=null",
            "il->timing.atim_win": "==0",
            "beacon_int": "!=null",
            "il->hw_params.max_beacon_itrvl": "!=null",
            "TIME_UNIT": "!=null",
            "il->timing.beacon_interval": "!=null",
            "beacon_int": "!=null",
            "tsf": "!=null",
            "il->timestamp": "!=null"
        }
    }
},
{
    "kprobe:il_send_rxon_timing": {
        "description": "Send RXON timing information.",
        "pre": {
            "il": "!=null",
            "beacon_int": ">=0",
            "tsf": "!=null"
        }
    }
},
{
    "kretprobe:if ((rxon->ofdm_basic_rates & RATE_6M_MASK) == 0 && (rxon->cck_basic_rates & RATE_1M_MASK) == 0)": {
        "description": "Check if basic rates 6Mbps and 1Mbps are supported",
        "pre": {
            "rxon->ofdm_basic_rates": "& RATE_6M_MASK == 0",
            "rxon->cck_basic_rates": "& RATE_1M_MASK == 0"
        }
    }
},
{
    "kprobe:il_check_rxon_cmd": {
        "description": "Check if basic rates 6Mbps and 1Mbps are supported.",
        "pre": {
            "rxon->ofdm_basic_rates": "& RATE_6M_MASK == 0",
            "rxon->cck_basic_rates": "& RATE_1M_MASK == 0"
        }
    }
},
{
    "kretprobe:intil_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed",
        "pre": {
            "il": "!=null",
            "staging_rxon": "!=null",
            "active_rxon": "!=null",
            "staging_rxon != active_rxon": true,
            "staging_rxon.RXON_FILTER_ASSOC_MSK": "!=0"
        }
    }
},
{
    "kprobe:intil_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed.",
        "pre": {
            "il": "!=null",
            "staging_rxon": "!=active_rxon",
            "active_rxon": "!=null",
            "RXON_FILTER_ASSOC_MSK": "!=null"
        }
    }
},
S,
{
    "kprobe:il_get_lowest_plcp": {
        "description": "Assign the lowest rate",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
{
    "kprobe:clear_ht_channel_mode_before_set_mode": {
        "description": "Clear the HT channel mode before setting the mode.",
        "pre": {
            "il": "!=null",
            "ht_conf": "!=null",
            "il.ht.enabled": "==true",
            "il.staging.flags": "& ~(RXON_FLG_CHANNEL_MODE_MSK | RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK | RXON_FLG_HT40_PROT_MSK | RXON_FLG_HT_PROT_MSK)",
            "il.staging.flags": "|= cpu_to_le32(il.ht.protection << RXON_FLG_HT_OPERATING_MODE_POS)"
        }
    }
},
{
    "kretprobe:intil_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON",
        "pre": {
            "il": "!=null",
            "ch": "!=null",
            "ch->band": "!=null"
        }
    }
},
{
    "kprobe:intil_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON.",
        "pre": {
            "il": "!=null",
            "ch": "!=null",
            "ch->band": "!=null"
        }
    }
},
{
    "kretprobe:il_set_flags_for_band": {
        "description": "Set flags for the given band in il_set_flags_for_band function.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_5GHZ, NL80211_BAND_2GHZ]",
            "vif": "!=null",
            "vif->bss_conf.use_short_slot": "==true"
        },
        "post": {
            "il->staging.flags": "|= RXON_FLG_SHORT_SLOT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_BAND_24G_MSK",
            "il->staging.flags": "|= RXON_FLG_AUTO_DETECT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_CCK_MSK"
        }
    }
},
{
    "kprobe:il_set_flags_for_band": {
        "description": "Set flags for the given band in il_priv structure.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_5GHZ]",
            "vif": "!=null",
            "vif->bss_conf.use_short_slot": "==true"
        },
        "post": {
            "il->staging.flags": "|= RXON_FLG_SHORT_SLOT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_BAND_24G_MSK",
            "il->staging.flags": "|= RXON_FLG_AUTO_DETECT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_CCK_MSK"
        }
    }
},
{
    "kretprobe:il_connection_init_rx_config": {
        "description": "Initialize RX configuration for il_connection",
        "pre": {
            "il": "!=null",
            "ch_info": "!=null",
            "il->staging": "memset(&il->staging, 0, sizeof(il->staging))",
            "il->iw_mode": "in [NL80211_IFTYPE_UNSPECIFIED, NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC]",
            "il->staging.dev_type": "in [RXON_DEV_TYPE_ESS, RXON_DEV_TYPE_IBSS]",
            "il->staging.filter_flags": "in [RXON_FILTER_ACCEPT_GRP_MSK, RXON_FILTER_BCON_AWARE_MSK | RXON_FILTER_ACCEPT_GRP_MSK]",
            "il->staging.flags": "RXON_FLG_SHORT_PREAMBLE_MSK when il->iw_mode == NL80211_IFTYPE_ADHOC",
            "il->staging.channel": "cpu_to_le16(ch_info->channel)",
            "il->band": "ch_info->band",
            "il_set_flags_for_band(il, il->band, il->vif)": "il_set_flags_for_band(il, il->band, il->vif)",
            "il->staging.ofdm_basic_rates": "(IL_OFDM_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF",
            "il->staging.cck_basic_rates": "(IL_CCK_RATES_MASK >> IL_FIRST_CCK_RATE) & 0xF"
        }
    }
},
S,
{
    "kretprobe:il_irq_handle_error": {
        "description": "Called for HW or SW error interrupt from card",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_irq_handle_error": {
        "description": "called for HW or SW error interrupt from card",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:_il_apm_stop": {
        "description": "Stop device's busmaster DMA activity.",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:il_sta_ucode_activate": {
        "description": "Activate the ucode for a specific station in the il_priv structure.",
        "pre": {
            "il": "!=null",
            "sta_id": "!=null",
            "il->tx_power_next": "!=null",
            "il->ops->post_scan": "!=null",
            "il->mutex": "!=null",
            "il->sta_lock": "held"
        }
    }
},
{
    "kprobe:il_sta_ucode_activate": {
        "description": "Activate the microcode for the specified station ID in the il_priv structure.",
        "pre": {
            "il": "!=null",
            "sta_id": "!=null",
            "il->tx_power_next": "!=null",
            "il->ops": "!=null",
            "il->ops->post_scan": "!=null",
            "il->mutex": "!=null",
            "il->sta_lock": "held"
        }
    }
},
{
    "kretprobe:reset": {
        "description": "Check if the interface needs to be reset",
        "pre": {
            "il": "!=null",
            "vif": "!=null",
            "reset": "!=null",
            "il->vif": "==vif",
            "il->vif": "!=null",
            "!reset": "true"
        }
    }
},
{
    "kprobe:reset": {
        "description": "Reset function for il_mac_add_interface",
        "pre": {
            "il->vif": "!=null",
            "il->vif->type": "==vif->type",
            "il->vif->addr": "==vif->addr",
            "il_is_ready_rf(il)": "==true"
        }
    }
},
{
    "kretprobe:if (!external && !il->cfg->mod_params->restart_fw)": {
        "description": "Check if external is false and il->cfg->mod_params->restart_fw is false.",
        "pre": {
            "external": "==false",
            "il->cfg->mod_params->restart_fw": "==false"
        }
    }
},
{
    "if (!external && !il->cfg->mod_params->restart_fw)": {
        "description": "Check if the request is from external and fw_restart module parameter is not set.",
        "pre": {
            "external": false,
            "il->cfg->mod_params->restart_fw": false
        }
    }
},
{
    "kretprobe:err = -EBUSY;goto out;}/* success `": {
        "description": "Function: err = -EBUSY;goto out;}/* success `",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "newtype": "in [nl80211_iftype values]",
            "newp2p": "boolean",
            "err": "-EOPNOTSUPP when newp2p == true",
            "il->vif": "!=null",
            "il_is_ready_rf(il)": "true"
        }
    }
},
{
    "err": "-EBUSY",
    "hw": "!=null",
    "vif": "!=null",
    "newtype": "enum value",
    "newp2p": "bool value"
},
S,
S,
S,
S,
S,
{
    "kprobe:dev_consume_skb_irq": {
        "description": "Consume the skb associated with il->beacon_skb and reset related variables.",
        "pre": {
            "il": "!=null",
            "il->beacon_skb": "==null",
            "il->timestamp": "==0",
            "il->lock": "!=null",
            "flags": "!=null",
            "il_scan_cancel_timeout": "!=null",
            "il_is_ready_rf(il)": "==false"
        }
    }
},
{
    "kretprobe:il_mac_bss_info_changed": {
        "description": "Function to handle changes in MAC BSS info",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "bss_conf": "!=null",
            "changes": "!=null"
        }
    }
},
{
    "kprobe:il_mac_bss_info_changed": {
        "description": "Function to handle changes in MAC BSS info",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "bss_conf": "!=null",
            "changes": "!=null"
        }
    }
},
{
    "kretprobe:inta_mask = _il_rd(il, CSR_INT_MASK);/* just for debug `": {
        "description": "This helper function reads the value of CSR_INT_MASK and assigns it to the variable inta_mask.",
        "pre": {
            "il": "!=null",
            "CSR_INT_MASK": "!=null"
        }
    }
},
{
    "kprobe:inta_mask = _il_rd(il, CSR_INT_MASK);/* just for debug `": {
        "description": "This helper function reads the value of CSR_INT_MASK and assigns it to the variable inta_mask.",
        "pre": {
            "il": "!=null",
            "CSR_INT_MASK": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        }
    }
},
{
    "kprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        }
    }
},
{
    "kretprobe:libipw_wx_get_encode": {
        "description": "Get the encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "len": "int",
            "key": "int",
            "sec": "!=null",
            "LIBIPW_DEBUG_WX": "string",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "char",
            "module": "char",
            "ops": "!=null",
            "crypt": "!=null",
            "dev": "!=null"
        },
        "post": {
            "erq->flags": "int",
            "sec->enabled": "bool",
            "erq->length": "int",
            "erq->flags": "int",
            "ieee->open_wep": "bool"
        }
    },
    "kretprobe:libipw_wx_set_encodeext": {
        "description": "Set the extended encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "idx": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "char",
            "module": "char",
            "ops": "!=null",
            "crypt": "!=null",
            "sec": "!=null"
        },
        "post": {
            "crypt": "!=null",
            "group_key": "int"
        }
    }
},
{
    "kprobe:libipw_wx_get_encode": {
        "description": "Get the encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "len": "int",
            "key": "int",
            "sec": "!=null",
            "LIBIPW_DEBUG_WX": "macro",
            "WEP_KEYS": "macro",
            "memcpy": "function",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "const char",
            "module": "const char",
            "ops": "struct lib80211_crypto_ops",
            "crypt": "struct lib80211_crypt_data",
            "sec.flags": "int",
            "idx": "int"
        },
        "post": {
            "return": "int"
        }
    },
    "kprobe:libipw_wx_set_encodeext": {
        "description": "Set the extended encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "const char",
            "module": "const char",
            "ops": "struct lib80211_crypto_ops",
            "crypt": "struct lib80211_crypt_data",
            "sec.flags": "int",
            "idx": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
S,
{
    "libipw_xmit": {
        "description": "Transmit a packet using the libipw driver.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "ieee": "!=null",
            "skb->priority": "=0",
            "ieee->is_queue_full": "!=null",
            "(*ieee->is_queue_full)(dev, priority)": "=0",
            "ieee->lock": "!=null"
        }
    }
},
{
    "kretprobe:libipw_xmit": {
        "description": "Transmit an skb through a net_device.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_tx_t_libipw_xmit": {
        "description": "Transmit a network device packet using the libipw driver.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:libipw_freq_to_channel": {
        "description": "Converts frequency to channel number based on the geography map.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null"
        },
        "post": {
            "return": "in [0, ieee->geo.bg_channels, ieee->geo.a_channels]"
        }
    }
},
{
    "kprobe:libipw_set_geo": {
        "description": "Set the geography map for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "geo": "!=null",
            "ieee->geo.bg_channels": "==0",
            "ieee->geo.a_channels": "==0"
        }
    },
    "kprobe:libipw_freq_to_channel": {
        "description": "Convert frequency to channel for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null",
            "freq": "% 100000 == 0",
            "ieee->freq_band & LIBIPW_24GHZ_BAND": "!=0",
            "ieee->freq_band & LIBIPW_52GHZ_BAND": "!=0"
        },
        "post": {
            "return": "!=0"
        }
    }
},
{
    "kretprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "pre": {
            "ieee.geo.bg_channels": "== 0",
            "ieee.geo.a_channels": "== 0",
            "return": "== 0",
            "ieee.freq_band": "& LIBIPW_24GHZ_BAND",
            "i": "< ieee.geo.bg_channels"
        }
    }
},
{
    "kprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "pre": {
            "ieee.geo.bg_channels": "== 0",
            "ieee.geo.a_channels": "== 0",
            "ieee.freq_band": "& LIBIPW_24GHZ_BAND",
            "for (i = 0; i < ieee.geo.bg_channels; i++)": "",
            "if (ieee.freq_band & LIBIPW_24GHZ_BAND)": "",
            "if (ieee.geo.bg_channels == 0 && ieee.geo.a_channels == 0)": "return 0"
        }
    }
},
{
    "kretprobe:libipw_freq_to_channel": {
        "description": "Converts a frequency to a channel number.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null",
            "ieee.geo.bg_channels": "==0",
            "ieee.geo.a_channels": "==0"
        },
        "post": {
            "return": "!=0",
            "ch.channel": "!=null",
            "return": "ch.freq"
        }
    }
},
S,
S,
S,
{
    "kretprobe:alloc_libipw": {
        "description": "Allocate memory for libipw device",
        "pre": {
            "sizeof_priv": ">= 0",
            "monitor": "in {0, 1}",
            "dev": "!= null",
            "ieee": "!= null",
            "ieee->dev": "== dev",
            "ieee->wdev.wiphy": "!= null",
            "ieee->wdev.iftype": "in {NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC}"
        }
    },
    "kretprobe:libipw_networks_allocate": {
        "description": "Allocate memory for libipw networks",
        "pre": {
            "ieee": "!= null",
            "err": ">= 0"
        }
    }
},
{
    "alloc_libipw": {
        "description": "Allocate memory for libipw device",
        "pre": {
            "sizeof_priv": ">= 0",
            "monitor": "in [0, 1]"
        },
        "post": {
            "ieee->wdev.wiphy": "!= null",
            "ieee->dev->ieee80211_ptr": "!= null",
            "ieee->wdev.iftype": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC]"
        }
    }
},
{
    "kretprobe:free_libipw": {
        "description": "Free resources used by libipw.",
        "pre": {
            "monitor": "==0",
            "ieee->wdev.wiphy": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:free_libipw": {
        "description": "Free resources used by the libipw driver.",
        "pre": {
            "dev": "!=null",
            "monitor": "==0",
            "ieee->wdev.wiphy": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:wlcore_read": {
        "description": "Read the tx results from the chipset.",
        "pre": {
            "wl": "!=null",
            "memmap": "!=null",
            "memmap->tx_result": "!=null",
            "wl->tx_res_if": "!=null",
            "sizeof(*wl->tx_res_if)": ">0",
            "false": "true"
        }
    }
},
{
    "kprobe:wlcore_read": {
        "description": "Read the tx results from the chipset.",
        "pre": {
            "wl": "!=null",
            "memmap": "!=null",
            "memmap->tx_result": "!=null",
            "wl->tx_res_if": "!=null",
            "sizeof(*wl->tx_res_if)": "!=null",
            "false": "is boolean",
            "ret": "< 0",
            "fw_counter": "le32_to_cpu(wl->tx_res_if->tx_result_fw_counter)"
        }
    }
},
{
    "kretprobe:orinoco_stop": {
        "description": "Stop the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "err": "!=null",
            "priv.hw_unavailable": "!=true"
        }
    }
},
{
    "kprobe:orinoco_stop": {
        "description": "Stop the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "err": "int",
            "priv.hw_unavailable": "bool"
        }
    }
},
S,
S,
{
    "kretprobe:orinoco_change_mtu": {
        "description": "Change the MTU of the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "priv": "!=null",
            "priv->nicbuf_size": "!=null",
            "ETH_HLEN": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "dev->mtu": "new_mtu"
        }
    }
},
{
    "kprobe:orinoco_change_mtu": {
        "description": "Change the MTU of the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "priv": "!=null",
            "priv == ndev_priv(dev)": true,
            "(new_mtu + ENCAPS_OVERHEAD + sizeof(struct ieee80211_hdr)) > (priv->nicbuf_size - ETH_HLEN)": true
        },
        "post": {
            "dev->mtu": "new_mtu",
            "return": "0"
        }
    }
},
{
    "kretprobe:orinoco_process_xmit_skb": {
        "description": "Encapsulate Ethernet-II frames",
        "pre": {
            "eh": {
                "h_proto": "> ETH_DATA_LEN"
            }
        }
    }
},
{
    "kprobe:orinoco_process_xmit_skb": {
        "description": "Encapsulate Ethernet-II frames",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "priv": "!=null",
            "tx_control": "!=null",
            "mic_buf": "!=null",
            "priv->encode_alg": "== ORINOCO_ALG_TKIP",
            "priv->keys[priv->tx_key].key": "!=null",
            "ntohs(eh->h_proto)": "> ETH_DATA_LEN"
        }
    }
},
{
    "kretprobe:if (priv->iw_mode == NL80211_IFTYPE_MONITOR)": {
        "description": "Check if the iw_mode of the priv struct is equal to NL80211_IFTYPE_MONITOR.",
        "pre": {
            "priv": "!=null",
            "priv->iw_mode": "== NL80211_IFTYPE_MONITOR"
        }
    }
},
{
    "kprobe:__orinoco_ev_rx": {
        "description": "Handle frames in monitor mode",
        "pre": {
            "dev": "!=null",
            "hw": "!=null",
            "priv": "!=null",
            "stats": "!=null",
            "wstats": "!=null",
            "skb": "null",
            "rxfid": "!=null",
            "status": "!=null",
            "length": "!=null",
            "desc": "!=null",
            "rx_data": "!=null",
            "err": "!=null"
        },
        "post": {
            "stats.rx_crc_errors": "stats.rx_crc_errors + 1"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "wdev = netdev_priv(dev)": {
        "description": "Assign the value of netdev_priv(dev) to wdev.",
        "pre": {
            "dev": "!=null"
        }
    },
    "wdev->wiphy = wiphy": {
        "description": "Assign the value of wiphy to wdev->wiphy.",
        "pre": {
            "wiphy": "!=null"
        }
    },
    "wdev->iftype = NL80211_IFTYPE_STATION": {
        "description": "Assign the value NL80211_IFTYPE_STATION to wdev->iftype.",
        "pre": {}
    }
},
{
    "kprobe:wdev = netdev_priv(dev);wdev->wiphy = wiphy;wdev->iftype = NL80211_IFTYPE_STATION;/* Setup / override net_device fields": {
        "description": "Initialize wireless_dev structure and set net_device fields.",
        "pre": {
            "wdev": "!=null",
            "wdev->wiphy": "!=null",
            "wdev->iftype": "==NL80211_IFTYPE_STATION",
            "dev": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:PRISM2_NO_KERNEL_IEEE80211_MGMTproc_create_seq_data": {
        "description": "Create a sequential file in the /proc file system for ap_control and ap.",
        "pre": {
            "local_info_t": "!=null",
            "local": {
                "ap": {
                    "proc": "!=null"
                }
            },
            "ap": {
                "proc": "!=null"
            }
        }
    }
},
{
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of entries, safely removing each entry from the list.",
        "pre": {
            "sta": "!=null",
            "n": "!=null",
            "&ap->sta_list": "!=null",
            "list": "!=null"
        }
    }
},
S,
{
    "kretprobe:hostap_ap_tx_cb": {
        "description": "Callback function for hostap_ap_tx_cb",
        "pre": {
            "skb": "!=null",
            "ok": "int",
            "data": "!=null",
            "ap": "!=null",
            "sta_fw_ver": "int"
        },
        "post": {
            "ap->nullfunc_ack": {
                "value": "1",
                "condition": "sta_fw_ver == PRISM2_FW_VER(0,8,0)"
            }
        }
    }
},
{
    "kprobe:hostap_ap_tx_cb": {
        "description": "Callback function for hostap_ap_tx.",
        "pre": {
            "skb": "!=null",
            "ok": "!=null",
            "data": "!=null",
            "ap": "!=null",
            "sta_fw_ver": "!=null",
            "ap->nullfunc_ack": "in [0, 1]",
            "sta_fw_ver == PRISM2_FW_VER(0,8,0)": "ap->nullfunc_ack == 1",
            "sta_fw_ver == PRISM2_FW_VER(1,4,2)": "printk(KERN_WARNING \"%s: Warning: secondary station firmware version 1.4.2 does not seem to work in Host AP mode\\n\", ap->local->dev->name)"
        }
    }
},
{
    "kretprobe:hostap_handle_sta_tx_exc": {
        "description": "Handle TX exception for a station in hostap",
        "pre": {
            "sta": "!=null",
            "rate": ">0",
            "old": ">=0"
        }
    }
},
S,
S,
S,
{
    "kretprobe:tx.crypt": {
        "description": "Set the value of tx.crypt",
        "pre": {
            "tx": {
                "crypt": "!=null"
            },
            "local": {
                "crypt_info": {
                    "crypt": "!=null",
                    "tx_keyidx": "!=null"
                }
            }
        }
    },
    "kretprobe:tx.host_encrypt": {
        "description": "Set the value of tx.host_encrypt",
        "pre": {
            "tx": {
                "host_encrypt": 1
            }
        }
    }
},
{
    "kprobe:tx.crypt": {
        "description": "Set the value of tx.crypt",
        "pre": {
            "tx": {
                "crypt": {
                    "index": "local->crypt_info.tx_keyidx",
                    "value": "!=null"
                }
            }
        }
    },
    "kprobe:tx.host_encrypt": {
        "description": "Set the value of tx.host_encrypt",
        "pre": {
            "tx": {
                "host_encrypt": 1
            }
        }
    }
},
{
    "kretprobe:hostap_get_porttype": {
        "description": "Get the port type for the local_info_t structure.",
        "pre": {
            "local_info_t": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:hostap_set_string": {
        "description": "Set a string value for the hostap interface.",
        "pre": {
            "dev": "!=null",
            "rid": "!=null",
            "val": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "len": "<=MAX_SSID_LEN",
            "buf[0]": "len",
            "buf[2]": "val",
            "buf[2 + len]": "0",
            "iface": "!=null",
            "iface->local": "!=null",
            "iface->local->func": "!=null",
            "iface->local->func->set_rid": "!=null",
            "iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2)": "!=null",
            "hostap_get_porttype(local_info_t *local)": "!=null"
        }
    }
},
{
    "kretprobe:keylen = 6; /* first 5 octets`": {
        "description": "104-bit support seems to require that all the keys are set to the same keylen",
        "pre": {
            "local_info_t": "!=null",
            "local": "!=null",
            "val": "!=null",
            "old_val": "!=null",
            "i": "!=null",
            "keylen": "= 6",
            "len": "!=null",
            "idx": "!=null",
            "keybuf": "!=null",
            "encrypt_type": "in [NONE, WEP, OTHER]",
            "local->crypt_info.tx_keyidx": "!=null",
            "local->crypt_info.crypt[idx]": "!=null",
            "local->crypt_info.crypt[idx]->ops": "!=null",
            "local->crypt_info.crypt[idx]->ops->name": "!=null",
            "local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1)": ">= 0",
            "val": "!= old_val",
            "local->privacy_invoked": "!=null",
            "HFA384X_WEPFLAGS_PRIVACYINVOKED": "!=null",
            "local->open_wep": "!=null",
            "HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED": "!=null",
            "local->ieee_802_1x": "!=null",
            "local->wpa": "!=null",
            "local->host_decrypt": "!=null",
            "HFA384X_WEPFLAGS_HOSTENCRYPT": "!=null",
            "HFA384X_WEPFLAGS_HOSTDECRYPT": "!=null",
            "hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)": "!=null",
            "encrypt_type": "= WEP"
        }
    }
},
{
    "kprobe:keylen = 6; /* first 5 octets": {
        "description": "Set the key length to 6 for the first 5 octets.",
        "pre": {
            "local_info_t": "!=null",
            "local": "!=null",
            "val": "!=null",
            "old_val": "!=null",
            "i": "!=null",
            "keylen": "==6",
            "len": "!=null",
            "idx": "!=null",
            "keybuf": "!=null",
            "encrypt_type": "in [NONE, WEP, OTHER]",
            "local->crypt_info.tx_keyidx": "!=null",
            "local->crypt_info.crypt[idx]": "!=null",
            "local->crypt_info.crypt[idx]->ops": "!=null",
            "local->crypt_info.crypt[idx]->ops->name": "!=null",
            "local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1)": ">=0",
            "val": "!=old_val",
            "local->privacy_invoked": "!=null",
            "HFA384X_WEPFLAGS_PRIVACYINVOKED": "!=null",
            "local->open_wep": "!=null",
            "HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED": "!=null",
            "local->ieee_802_1x": "!=null",
            "local->wpa": "!=null",
            "local->host_decrypt": "!=null",
            "HFA384X_WEPFLAGS_HOSTENCRYPT": "!=null",
            "HFA384X_WEPFLAGS_HOSTDECRYPT": "!=null",
            "hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)": ">=0"
        }
    }
},
{
    "kretprobe:hostap_set_word": {
        "description": "Set the value of the specified register in the hostap driver.",
        "pre": {
            "local": "!=null",
            "val": "!=null",
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "!= PRISM2_AUTH_OPEN",
            "val": "!= PRISM2_AUTH_SHARED_KEY"
        }
    }
},
{
    "kprobe:hostap_set_word": {
        "description": "Set the value of a word in the hostap driver.",
        "pre": {
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "!= PRISM2_AUTH_OPEN",
            "val": "!= PRISM2_AUTH_SHARED_KEY"
        }
    }
},
S,
{
    "kprobe:hostap_80211_get_hdrlen": {
        "description": "Calculate the header length of a hostap frame.",
        "pre": {
            "fc": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:hostap_set_multicast_list": {
        "description": "Set the multicast list for the hostap interface.",
        "pre": {
            "work": "!=null",
            "local": "!=null",
            "dev": {
                "flags": {
                    "&": ["IFF_ALLMULTI", "IFF_PROMISC"]
                }
            }
        }
    }
},
{
    "map": "!=null",
    "key": "!=null",
    "value": "!=null",
    "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
    "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
},
{
    "kretprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "pre": {
            "rx_stats": {
                "signal": "!=null",
                "noise": "!=null",
                "rate": "!=null"
            },
            "skb": {
                "len": ">=2"
            },
            "hdr": {
                "frame_control": "!=null",
                "frame_control_ftype": "(frame_control & IEEE80211_FCTL_FTYPE) >> 2 != null",
                "frame_control_stype": "(frame_control & IEEE80211_FCTL_STYPE) >> 4 != null",
                "frame_control_tods": "(frame_control & IEEE80211_FCTL_TODS) != null",
                "frame_control_fromds": "(frame_control & IEEE80211_FCTL_FROMDS) != null",
                "addr1": "!=null",
                "addr2": "!=null",
                "addr3": "!=null",
                "addr4": "!=null"
            }
        }
    }
},
{
    "kprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "pre": {
            "dev": "any",
            "skb": {
                "len": ">=2"
            },
            "rx_stats": {
                "signal": "!=null",
                "noise": "!=null",
                "rate": "!=null"
            },
            "type": "any"
        }
    }
},
S,
{
    "kprobe:hostap_info_init": {
        "description": "Initialize hostap info",
        "pre": {
            "local": "!=null",
            "local->info_list": "is empty",
            "PRISM2_NO_STATION_MODES": "not defined"
        }
    }
},
{
    "kretprobe:info = (struct hfa384x_info_frame *) skb->data; buf = skb->data + sizeof(*info); left = skb->len - sizeof(*info); switch (le16_to_cpu(info->type))": {
        "description": "Process hostap info",
        "pre": {
            "skb": {
                "data": "!=null",
                "len": "!=null"
            },
            "info": {
                "type": "!=null"
            },
            "buf": "!=null",
            "left": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kprobe:stop_atmel_card": {
        "description": "Stop the Atmel card and perform cleanup operations.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "priv->bus_type": "==BUS_TYPE_PCCARD"
        },
        "post": {
            "dev": "unregister_netdev(dev)",
            "priv->management_timer": "del_timer_sync(&priv->management_timer)",
            "priv->firmware": "kfree(priv->firmware)",
            "dev->irq": "free_irq(dev->irq, dev)",
            "dev->base_addr": "release_region(dev->base_addr, 32)",
            "NULL": "remove_proc_entry(\"driver/atmel\", NULL)",
            "NULL": "free_netdev(dev)"
        }
    }
},
{
    "kretprobe:rtw_phy_read_rf_sipi": {
        "description": "Reads a value from the RF SIPI address.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, hal->rf_phy_num)",
            "addr": "!=null",
            "mask": "!=null"
        }
    }
},
S,
{
    "kretprobe:rtw_phy_set_tx_power_level": {
        "description": "Set the transmit power level for a specific channel and path in the rtw_dev structure.",
        "pre": {
            "rtwdev": "!=null",
            "ch": "!=null",
            "path": "!=null",
            "hal": "!=null",
            "hal.current_band_type": "==RTW_BAND_2G",
            "rs": ">=RTW_RATE_SECTION_CCK",
            "rs": "<RTW_RATE_SECTION_MAX"
        }
    }
},
{
    "kprobe:rtw_phy_set_tx_power_level": {
        "description": "Set the transmit power level for a specific channel and path.",
        "pre": {
            "rtwdev": "!=null",
            "ch": "!=null",
            "path": "!=null",
            "hal->current_band_type": "==RTW_BAND_2G",
            "rs": ">=RTW_RATE_SECTION_CCK",
            "rs": "<RTW_RATE_SECTION_MAX"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:rtw_power_mode_change": {
        "description": "Toggle the request power mode",
        "pre": {
            "rtwdev": "!=null",
            "enter": true,
            "request": "!=null",
            "BIT_RPWM_TOGGLE": "!=null"
        }
    }
},
{
    "kprobe:rtw_power_mode_change": {
        "description": "Toggle the request power mode",
        "pre": {
            "rtwdev": "!=null",
            "enter": "!=null",
            "request": "!=null",
            "confirm": "!=null",
            "polling": "!=null",
            "ret": "!=null",
            "request": "is_bit_set(request, BIT_RPWM_TOGGLE)",
            "confirm": "0",
            "polling": "0",
            "ret": "0"
        }
    }
},
{
    "kretprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "Receive C2H command in the firmware.",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": "!=null",
            "skb": "!=null",
            "skb->data + pkt_offset": "!=null",
            "skb->len - pkt_offset - 2": ">=0",
            "skb->cb": "!=null"
        },
        "post": {
            "*((u32 *)skb->cb)": "pkt_offset"
        }
    }
},
{
    "kprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "Receives a command from firmware and performs further operations based on the command ID.",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:rtw_tx_report_enqueue": {
        "description": "Enqueue a transmit report",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "sn": "!=null"
        },
        "post": {
            "drv_data": "!=null",
            "*drv_data": "sn",
            "tx_report.q_lock": "locked",
            "tx_report.queue": "contains(skb)",
            "tx_report.purge_timer": "modified"
        }
    }
},
S,
S,
S,
{
    "kretprobe:rtw_pci_probe": {
        "description": "Probe function for rtw_pci",
        "pre": {
            "rtwdev->chip->id": "== RTW_CHIP_TYPE_8821C",
            "bridge->vendor": "== PCI_VENDOR_ID_INTEL"
        },
        "post": {
            "rtwpci->rx_no_aspm": "== true"
        }
    }
},
{
    "kprobe:rtw_pci_probe": {
        "description": "Probe function for rtw_pci",
        "pre": {
            "rtwdev->chip->id": "== RTW_CHIP_TYPE_8821C",
            "bridge->vendor": "== PCI_VENDOR_ID_INTEL"
        }
    }
},
{
    "kretprobe:rtw_ops_start": {
        "description": "Starts the rtw_ops",
        "pre": {
            "txq": {
                "ac": "IEEE80211_AC_VO"
            }
        },
        "post": {
            "__rtw_tx_work": {},
            "queue_work": {
                "tx_wq": "!=null",
                "work": "&rtwdev->tx_work"
            }
        }
    }
},
{
    "kprobe:rtw_ops_start": {
        "description": "Start the rtw_ops",
        "pre": {
            "txq->ac": "== IEEE80211_AC_VO",
            "__rtw_tx_work(rtwdev)": "called if txq->ac == IEEE80211_AC_VO",
            "queue_work(rtwdev->tx_wq, &rtwdev->tx_work)": "called if txq->ac != IEEE80211_AC_VO"
        }
    }
},
{
    "kretprobe:rtw_coex_write_scbd": {
        "description": "Write to the scbd array in the rtw_coex structure.",
        "pre": {
            "chip": {
                "new_scbd10_def": "==false"
            },
            "bitpos": "& COEX_SCBD_FIX2M"
        }
    }
},
{
    "if (!chip->new_scbd10_def && (bitpos & COEX_SCBD_FIX2M))": {
        "description": "Check if the new_scbd10_def is false and bitpos has the COEX_SCBD_FIX2M flag set.",
        "pre": {
            "chip": {
                "new_scbd10_def": "==false"
            },
            "bitpos": {
                "&": ["COEX_SCBD_FIX2M"]
            }
        }
    }
},
S,
S,
{
    "kretprobe:rtw89_phy_write_rf": {
        "description": "Write RF register in the rtw89_phy_write_rf function.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, rtwdev->chip->rf_path_num)",
            "addr": ">= 0",
            "mask": ">= 0",
            "data": ">= 0",
            "chip": "!=null",
            "base_addr": "!=null",
            "direct_addr": "!=null",
            "RFREG_MASK": "!=null"
        }
    }
},
{
    "kprobe:rtw89_phy_write_rf": {
        "description": "Write RF register in the rtw89_phy_write_rf function.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, rtwdev->chip->rf_path_num)",
            "addr": ">=0 && <=255",
            "mask": ">=0",
            "data": ">=0",
            "chip": "!=null",
            "base_addr": "!=null",
            "direct_addr": "!=null",
            "RFREG_MASK": "!=null",
            "rtw89_phy_write32_mask": "!=null"
        }
    }
},
{
    "kretprobe:rtw89_phy_write32_idx": {
        "description": "Write a 32-bit value to a PHY register at the specified address.",
        "pre": {
            "rtwdev": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "data": "!=null",
            "phy_idx": "in [RTW89_PHY_IDX_0, RTW89_PHY_IDX_1]"
        },
        "post": {
            "ofst": "= 0 if phy_page >= 0x40 && phy_page <= 0x4f, else = 0x2000"
        }
    }
},
S,
{
    "kretprobe:drv_info_len": {
        "description": "Calculate the length of drv_info in 8-byte units.",
        "pre": {
            "rtwdev": "!=null",
            "desc_info": "!=null",
            "data": "!=null",
            "data_offset": "!=null",
            "chip": "!=null",
            "rxd_s": "!=null",
            "rxd_l": "!=null",
            "shift_len": "!=null"
        },
        "post": {
            "drv_info_len": "desc_info->drv_info_size << 3"
        }
    }
},
{
    "kprobe:drv_info_len": {
        "description": "Calculate the length of drv_info in 8-byte units.",
        "pre": {
            "rtwdev": "!=null",
            "desc_info": "!=null",
            "data": "!=null",
            "data_offset": "!=null",
            "chip": "!=null",
            "rxd_s": "!=null",
            "rxd_l": "!=null",
            "shift_len": "!=null",
            "drv_info_len": "!=null"
        }
    }
},
{
    "kretprobe:rtw89_core_rx_process_phy_ppdu_iter": {
        "description": "Process the PHY PPDU in the RX path of the rtw89_core driver.",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "phy_ppdu": "!=null",
            "rxinfo": "!=null",
            "rx_cnt_valid": "in [true, false]",
            "plcp_size": ">=0",
            "usr_num": ">=0",
            "phy_sts": "!=null"
        }
    }
},
{
    "kprobe:rtw89_core_rx_process_phy_ppdu_iter": {
        "description": "Process PHY PPDU in RX core",
        "pre": {
            "usr_num": "& BIT(0) != 0",
            "rx_cnt_valid": "true",
            "plcp_size": ">= 0",
            "phy_ppdu->buf": "!= null",
            "phy_ppdu->len": "skb->data + skb->len - phy_sts"
        }
    }
},
S,
S,
S,
{
    "kprobe:cancel_work_sync": {
        "description": "Cancel a work item and wait for it to complete.",
        "pre": {
            "rtwdev": "!=null",
            "mutex": "!=null",
            "rtw89_leave_ps_mode": "!=null",
            "hw": "!=null",
            "changed": "!=null",
            "IEEE80211_CONF_CHANGE_IDLE": "!=null",
            "IEEE80211_CONF_CHANGE_CHANNEL": "!=null"
        }
    },
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "rtwdev": "!=null",
            "mutex": "!=null"
        }
    },
    "kprobe:rtw89_leave_ps_mode": {
        "description": "Leave power save mode.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_leave_ips": {
        "description": "Leave idle power save mode.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_core_tx_write": {
        "description": "Write a transmit frame to the core.",
        "pre": {
            "rtwdev": "!=null",
            "vif": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "qsel": "!=null"
        }
    },
    "kprobe:rtw89_core_tx_kick_off": {
        "description": "Kick off the transmit process.",
        "pre": {
            "rtwdev": "!=null",
            "qsel": "!=null"
        }
    },
    "kprobe:ieee80211_schedule_txq": {
        "description": "Schedule a transmission queue.",
        "pre": {
            "hw": "!=null",
            "txq": "!=null"
        }
    },
    "kprobe:queue_work": {
        "description": "Queue a work item.",
        "pre": {
            "rtwdev": "!=null",
            "txq_wq": "!=null",
            "txq_work": "!=null"
        }
    },
    "kprobe:rtw89_core_start": {
        "description": "Start the core.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_core_stop": {
        "description": "Stop the core.",
        "pre": {
            "rtwdev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:elsetbl_w1 = cxtbl[8];if (dm->leak_ap && (type == BTC_CXP_PFIX || type == BTC_CXP_PAUTO2))": {
        "description": "Set the value of elsetbl_w1 to the entry at index 8 in cxtbl if dm->leak_ap is true and type is either BTC_CXP_PFIX or BTC_CXP_PAUTO2.",
        "pre": {
            "dm->leak_ap": "==true",
            "type": "in [BTC_CXP_PFIX, BTC_CXP_PAUTO2]"
        }
    }
},
{
    "kprobe:elsetbl_w1": {
        "description": "Set the value of elsetbl_w1 based on the conditions",
        "pre": {
            "dm->leak_ap": true,
            "type": {
                "in": ["BTC_CXP_PFIX", "BTC_CXP_PAUTO2"]
            }
        }
    }
},
{
    "kretprobe:rtl_init_rfkill": {
        "description": "Initialize RFKill state",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv->rfkill.rfkill_state": "==true",
            "hw->wiphy": "!=null",
            "valid": "!=null"
        }
    }
},
{
    "kprobe:rtl_init_rfkill": {
        "description": "Set the initial state of rfkill to on.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv.rfkill.rfkill_state": "true",
            "hw.wiphy": "!=null",
            "valid": "!=null"
        }
    },
    "kprobe:wiphy_rfkill_set_hw_state": {
        "description": "Set the hardware state of wiphy rfkill to 0.",
        "pre": {
            "hw.wiphy": "!=null",
            "state": "0"
        }
    },
    "kprobe:rtlpriv.cfg.ops.radio_onoff_checking": {
        "description": "Perform radio on/off checking.",
        "pre": {
            "hw": "!=null",
            "valid": "!=null"
        }
    }
},
{
    "kretprobe:rtl_get_tcb_desc": {
        "description": "Helper function to get the TCB descriptor for special data and management frames.",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "tcb_desc": "!=null",
            "tcb_desc->hw_rate": "!=null",
            "tcb_desc->use_spe_rpt": "in [0, 1]",
            "fc": "!=null",
            "ieee80211_is_data(fc)": "==true"
        }
    }
},
{
    "kprobe:rtl_get_tcb_desc": {
        "description": "Helper function to get the TCB (Transmit Control Block) descriptor.",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "tcb_desc": "!=null",
            "tcb_desc->hw_rate": "is used for special data and mgt frames"
        }
    }
},
{
    "kretprobe:if (!mac->act_scanning) return;": {
        "description": "Check if scanning is active",
        "pre": {
            "mac": "!=null",
            "mac.act_scanning": "==false"
        }
    }
},
{
    "kprobe:if (!mac->act_scanning) return;": {
        "description": "Check if this is a beacon",
        "pre": {
            "mac": {
                "act_scanning": false
            }
        }
    }
},
{
    "kretprobe:skb_queue_tail": {
        "description": "Enqueue an skb into the c2hcmd_queue.",
        "pre": {
            "rtlpriv": "!=null",
            "hw": "!=null",
            "skb": "!=null",
            "rtl_c2h_fast_cmd(hw, skb)": true
        },
        "post": {
            "skb_queue_tail(&rtlpriv->c2hcmd_queue, skb)": true
        }
    }
},
{
    "kprobe:skb_queue_tail": {
        "description": "Enqueue an skb to the c2hcmd_queue.",
        "pre": {
            "hw": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "if (skb)": {
        "description": "Check if skb is not null",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "if (skb)": {
        "description": "Check if skb is not null.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_init": {
        "description": "Initialize the spin lock for usb_lock.",
        "pre": {
            "usb_lock": "!=null"
        }
    }
},
S,
{
    "kretprobe:wait_for_completion(&rtlpriv->firmware_loading_complete);clear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);/*ieee80211_unregister_hw will call ops_stop `": {
        "description": "Wait for completion of firmware loading and clear a bit in rtlpriv->status.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->firmware_loading_complete": "==true",
            "&rtlpriv->status": "!=null",
            "RTL_STATUS_INTERFACE_START": "is not set",
            "ieee80211_unregister_hw": "will call ops_stop"
        }
    }
},
{
    "kprobe:wait_for_completion(&rtlpriv->firmware_loading_complete);clear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);/*ieee80211_unregister_hw will call ops_stop `": {
        "description": "Function to wait for completion of firmware loading and clear a bit in the status variable.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->firmware_loading_complete": "==true",
            "rtlpriv->status": "!=null",
            "RTL_STATUS_INTERFACE_START": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:rtl_cmd_send_packet": {
        "description": "Send a packet using RTL commands.",
        "pre": {
            "hw": "!=null",
            "skb": "!=null",
            "ring": "!=null",
            "pdesc": "!=null",
            "flags": "!=null",
            "rtlpriv": "!=null",
            "rtlpci": "!=null",
            "pskb": "!=null"
        }
    }
},
S,
{
    "kretprobe:rtl_ps_enable_nic": {
        "description": "Reset trx ring",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "rtlhal": "!=null",
            "rtlmac": "!=null",
            "rtlhal.interface": "==INTF_PCI",
            "rtlpriv.intf_ops.reset_trx_ring": "called with argument hw",
            "is_hal_stop(rtlhal)": "==true"
        }
    }
},
{
    "kprobe:rtl_ps_enable_nic": {
        "description": "Reset trx ring",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "rtlhal": "!=null",
            "rtlmac": "!=null",
            "rtlhal.interface": "==INTF_PCI",
            "rtlpriv.intf_ops": "!=null",
            "rtlpriv.intf_ops.reset_trx_ring": "!=null",
            "is_hal_stop(rtlhal)": "==true"
        }
    }
},
{
    "kretprobe:rtl_deinit_deferred_work": {
        "description": "Disable Interrupt",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv.hw": "==hw",
            "timer_stopped": "==true"
        }
    }
},
{
    "kprobe:rtl_deinit_deferred_work": {
        "description": "Disable Interrupt",
        "pre": {
            "hw": "!=null",
            "hw.type": "==struct ieee80211_hw",
            "hw.priv": "!=null",
            "hw.priv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv": "!=null",
            "hw.priv.rtlpriv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw": "==hw",
            "hw.priv.rtlpriv.hw.type": "==struct ieee80211_hw",
            "hw.priv.rtlpriv.hw.priv": "==hw.priv",
            "hw.priv.rtlpriv.hw.priv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv": "==hw.priv.rtlpriv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.hw": "==hw",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.hw.type": "==struct ieee80211_hw"
        }
    }
},
{
    "kretprobe:rtl_pci_probe": {
        "description": "Initialize cfg and intf_ops",
        "pre": {
            "rtlpriv.proximity.proxim_on": false,
            "pcipriv.dev.pdev": "pdev"
        }
    }
},
{
    "kprobe:rtl_pci_probe": {
        "description": "Probe function for rtl_pci",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:efuse_initialize": {
        "description": "Initialize the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null"
        }
    },
    "kretprobe:efuse_read_1byte": {
        "description": "Read one byte from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "data": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null",
            "k": "!=null",
            "efuse_len": "!=null",
            "address": "<= efuse_len"
        },
        "post": {
            "data": "!=null"
        }
    },
    "kretprobe:efuse_write_1byte": {
        "description": "Write one byte to the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null",
            "k": "!=null",
            "efuse_len": "!=null",
            "address": "<= efuse_len",
            "value": "!=null"
        }
    },
    "kretprobe:read_efuse_byte": {
        "description": "Read a byte from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "_offset": "!=null",
            "pbuf": "!=null",
            "value32": "!=null",
            "readbyte": "!=null",
            "retry": "!=null"
        },
        "post": {
            "pbuf": "!=null"
        }
    },
    "kretprobe:read_efuse": {
        "description": "Read data from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlefuse": "!=null",
            "efuse_tbl": "!=null",
            "rtemp8": "!=null",
            "efuse_addr": "!=null",
            "offset": "!=null",
            "wren": "!=null",
            "u1temp": "!=null",
            "i": "!=null",
            "j": "!=null",
            "efuse_max_section": "!=null",
            "efuse_len": "!=null",
            "efuse_word": "!=null",
            "efuse_utilized": "!=null",
            "efuse_usage": "!=null",
            "_offset": "<= efuse_len",
            "_size_byte": "!=null"
        },
        "post": {
            "pbuf": "!=null"
        }
    }
},
{
    "kprobe:efuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], GFP_ATOMIC);if (!efuse_tbl)return;efuse_word = kcalloc(EFUSE_MAX_WORD_UNIT, sizeof(u16 *), GFP_ATOMIC);if (!efuse_word)goto out;for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++)": {
        "description": "Allocate memory for efuse_tbl and efuse_word.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]": "!=null",
            "GFP_ATOMIC": "!=null",
            "efuse_tbl": "==null",
            "efuse_word": "==null",
            "EFUSE_MAX_WORD_UNIT": "!=null",
            "sizeof(u16 *)": "!=null",
            "i": "!=null",
            "i": "< EFUSE_MAX_WORD_UNIT"
        }
    }
},
{
    "kretprobe:rtl_cam_del_entry": {
        "description": "Delete an entry from the RTL CAM.",
        "pre": {
            "i": "= 4",
            "i": "< TOTAL_CAM_ENTRY"
        }
    }
},
{
    "kprobe:rtl_cam_del_entry": {
        "description": "Does STA already exist?",
        "pre": {
            "hw": "!=null",
            "sta_addr": "!=null",
            "sta_addr": "!is_zero_ether_addr(sta_addr)"
        }
    }
},
{
    "kretprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Fill IQK matrix for path A in _rtl92c_phy_path_a_fill_iqk_matrix function.",
        "pre": {
            "hw": "!=null",
            "b_patha_ok": "!=null",
            "result": "!=null",
            "final_candidate": "!=null",
            "reg_ea4": "==0"
        }
    }
},
{
    "kprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Function _rtl92c_phy_path_a_fill_iqk_matrix",
        "pre": {
            "hw": "!=null",
            "b_patha_ok": "!=null",
            "result": "!=null",
            "final_candidate": "!=null",
            "reg_ea4": "==0"
        }
    }
},
{
    "kretprobe:rtl92c_dm_initial_gain_min_pwdb": {
        "description": "Calculate the minimum received signal strength value.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "dm_digtable": "!=null",
            "rssi_val_min": ">10000"
        }
    }
},
S,
{
    "kretprobe:rtl92c_dm_watchdog": {
        "description": "Watchdog function for rtl92c_dm",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "fw_current_inpsmode": "bool",
            "fw_ps_awake": "bool",
            "ppsc->p2p_ps_info.p2p_ps_mode": "bool",
            "ppsc->rfpwr_state": "ERFON",
            "!fw_current_inpsmode": "true",
            "fw_ps_awake": "true",
            "!ppsc->rfchange_inprogress": "true"
        }
    }
},
{
    "kprobe:rtl92c_dm_watchdog": {
        "description": "Watchdog function for rtl92c_dm",
        "pre": {
            "hw": "!=null"
        }
    }
},
{
    "kretprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine AMPDU setting for BT coexistence.",
        "pre": {
            "undec_sm_pwdb": ">= 67",
            "curr_bt_rssi_state": "&= (~BT_RSSI_STATE_NORMAL_POWER)",
            "undec_sm_pwdb": "< 62",
            "curr_bt_rssi_state": "|= BT_RSSI_STATE_NORMAL_POWER"
        }
    }
},
{
    "kprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine AMPDU setting for BT coexistence.",
        "pre": {
            "undec_sm_pwdb": ">= 67",
            "curr_bt_rssi_state": "&= (~BT_RSSI_STATE_NORMAL_POWER)",
            "undec_sm_pwdb": "< 62",
            "curr_bt_rssi_state": "|= BT_RSSI_STATE_NORMAL_POWER"
        }
    }
},
S,
S,
{
    "kretprobe:if (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq))": {
        "description": "Check if the FLAG_MPI bit is set in ai->flags and the ai->txq is not empty.",
        "pre": {
            "ai": "!=null",
            "FLAG_MPI": "is set in ai->flags",
            "ai->txq": "is not empty"
        }
    }
},
{
    "description": "Check if the FLAG_MPI bit is set in ai->flags and the ai->txq is not empty.",
    "pre": {
        "ai->flags": "test_bit(FLAG_MPI, &ai->flags)",
        "ai->txq": "!skb_queue_empty(&ai->txq)"
    }
},
{
    "init_airo_card": {
        "pre": {
            "dev": "!=null",
            "ai": "!=null",
            "irq": null,
            "port": null,
            "is_pcmcia": null,
            "pci": "!=null",
            "dmdev": "!=null"
        },
        "description": "Create the network device object."
    }
},
S,
{
    "kretprobe:reset_airo_card": {
        "description": "Reset the airo card.",
        "pre": {
            "!test_bit(FLAG_MPI, &ai->flags)": true,
            "for (i = 0; i < MAX_FIDS; i++)": {
                "ai->fids[i]": "transmit_allocate(ai, AIRO_DEF_MTU, i >= MAX_FIDS/2)"
            },
            "enable_interrupts(ai)": true,
            "netif_wake_queue(dev)": true
        }
    }
},
S,
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancel the synchronous execution of work associated with the kevent of the device.",
        "pre": {
            "dev": "!=null",
            "kevent": "!=null"
        }
    },
    "kretprobe:del_timer_sync": {
        "description": "Delete the timer associated with the delay of the device synchronously.",
        "pre": {
            "dev": "!=null",
            "delay": "!=null"
        }
    },
    "kretprobe:free_percpu": {
        "description": "Free the per-CPU statistics of the network.",
        "pre": {
            "net": "!=null",
            "tstats": "!=null"
        }
    },
    "kretprobe:free_netdev": {
        "description": "Free the network device.",
        "pre": {
            "net": "!=null"
        }
    },
    "kretprobe:usbnet_probe": {
        "description": "Probe the USB network device.",
        "pre": {}
    }
},
S,
{
    "kretprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status",
        "pre": {
            "phydev": "!=null",
            "(*phydev)": "valid_phy_device_struct"
        }
    }
},
{
    "kprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from the target phy_device struct.",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return_value": ">0"
        }
    }
},
{
    "kprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from the phydev.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask.",
        "pre": {
            "speed": "!=null",
            "duplex": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask.",
        "pre": {
            "speed": "!=null",
            "duplex": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kretprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "int"
        }
    }
},
{
    "kprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:phy_do_ioctl_running": {
        "description": "Generic ndo_eth_ioctl implementation but test first.",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kretprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test": {
        "description": "Start a cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test": {
        "description": "Start a cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kretprobe:phy_config_aneg": {
        "description": "Configures auto-negotiation for the PHY device.",
        "pre": {
            "phydev": "!=null",
            "phydev->is_c45": "==true",
            "!(phydev->c45_ids.devices_in_package & BIT(0))": "==true"
        },
        "post": {
            "return_value": "genphy_c45_config_aneg(phydev)"
        }
    }
},
{
    "kprobe:phy_config_aneg": {
        "description": "Configure autonegotiation for the PHY device.",
        "pre": {
            "phydev": "!=null",
            "phydev->is_c45": "==true",
            "!(phydev->c45_ids.devices_in_package & BIT(0))": "==true"
        }
    }
},
{
    "kretprobe:linkmode_and": {
        "description": "Verify the settings we care about.",
        "pre": {
            "advertising": "!=null",
            "advertising": "!=null",
            "phydev->supported": "!=null",
            "cmd->base.autoneg": "!=null",
            "cmd->base.duplex": "!=null",
            "cmd->base.speed": "!=null",
            "cmd->base.phy_address": "==phydev->mdio.addr"
        }
    }
},
{
    "kprobe:linkmode_and": {
        "description": "Verify the settings we care about.",
        "pre": {
            "advertising": "!=null",
            "advertising": "!=null",
            "phydev->supported": "!=null",
            "cmd->base.autoneg": "!=null",
            "cmd->base.duplex": "!=null",
            "cmd->base.speed": "!=null",
            "cmd->base.phy_address": "phydev->mdio.addr"
        }
    }
},
{
    "kretprobe:phy_error": {
        "description": "Enter ERROR state for this PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->lock": "not held",
            "context": "not interrupt"
        }
    }
},
{
    "kprobe:phy_error": {
        "description": "Enter ERROR state for the PHY device and inform the controller that the link is down.",
        "pre": {
            "phydev": "!=null",
            "phydev->lock": "not held",
            "context": "not interrupt"
        }
    }
},
{
    "kretprobe:phy_request_interrupt": {
        "description": "Request and enable interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "irq": "valid IRQ number"
        }
    }
},
{
    "kprobe:phy_request_interrupt": {
        "description": "Request and enable interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "irq": "valid IRQ number"
        }
    }
},
{
    "kretprobe:phy_free_interrupt": {
        "description": "Disable and free interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->irq": "==PHY_POLL"
        }
    }
},
{
    "kprobe:phy_free_interrupt": {
        "description": "Disable and free interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->irq": "==PHY_POLL"
        }
    }
},
{
    "kretprobe:phy_stop_machine": {
        "description": "stop the PHY state machine tracking",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_stop_machine": {
        "description": "Stop the PHY state machine tracking",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:phy_init_eee": {
        "description": "init and check the EEE feature",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_init_eee": {
        "description": "init and check the EEE feature",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:phy_get_eee_err": {
        "description": "Report the EEE wake error count",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_get_eee_err": {
        "description": "Report the EEE wake error count.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_eee": {
        "description": "get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_eee": {
        "description": "Get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_wol": {
        "description": "Configure Wake On LAN",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kretprobe:mdio_device_create": {
        "description": "Allocate and initialize an MDIO device.",
        "pre": {
            "bus": "!=null",
            "addr": "int"
        },
        "post": {
            "mdiodev": "!=null",
            "mdiodev->dev.release": "==mdio_device_release",
            "mdiodev->dev.parent": "==&bus->dev",
            "mdiodev->dev.bus": "==&mdio_bus_type",
            "mdiodev->device_free": "==mdio_device_free",
            "mdiodev->device_remove": "==mdio_device_remove",
            "mdiodev->bus": "==bus",
            "mdiodev->addr": "==addr"
        }
    }
},
{
    "kprobe:mdio_device_create": {
        "description": "Allocate and initialize an MDIO device.",
        "pre": {
            "bus": "!=null",
            "addr": "int"
        }
    }
},
{
    "kretprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "pre": {
            "mdiodev->bus": "==bus",
            "mdiodev->addr": "==addr",
            "dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr)": "called",
            "device_initialize(&mdiodev->dev)": "called"
        },
        "post": {
            "return": "mdiodev"
        }
    }
},
{
    "kprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->addr": "!=null",
            "dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr)": "success",
            "device_initialize(&mdiodev->dev)": "success"
        }
    }
},
{
    "kretprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_eee_is_active": {
        "description": "get EEE status",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        }
    }
},
{
    "kprobe:genphy_c45_eee_is_active": {
        "description": "get EEE status",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_ethtool_get_eee": {
        "description": "get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
S,
{
    "kretprobe:genphy_c45_ethtool_set_eee": {
        "description": "set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null",
            "data->eee_enabled": "in [true, false]"
        }
    }
},
{
    "kprobe:genphy_c45_ethtool_set_eee": {
        "description": "set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null",
            "data->eee_enabled": "in [true, false]"
        }
    }
},
{
    "kretprobe:mdio_device_reset": {
        "description": "Reset the MDIO device and register it with the MDIO bus.",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->addr": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags & MDIO_DEVICE_FLAG_PHY": "!=0"
        }
    }
},
{
    "kprobe:mdio_device_reset": {
        "description": "Reset the MDIO device.",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags & MDIO_DEVICE_FLAG_PHY": "!=0"
        }
    }
},
{
    "kretprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure",
        "pre": {
            "size": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus.",
        "pre": {
            "mdio_name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus.",
        "pre": {
            "mdio_name": "!=null"
        }
    }
},
{
    "kretprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus.",
        "pre": {
            "mdio_bus_np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus.",
        "pre": {
            "mdio_bus_np": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus.",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus. MDIO devices which are not PHYs will not be brought up by this function.",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:bus->state = MDIOBUS_UNREGISTERED": {
        "description": "Set the state of the bus to MDIOBUS_UNREGISTERED",
        "pre": {
            "bus": "!=null",
            "bus->state": "==MDIOBUS_UNREGISTERED"
        }
    },
    "kretprobe:err = device_register(&bus->dev)": {
        "description": "Register the device",
        "pre": {
            "bus": "!=null",
            "&bus->dev": "!=null",
            "err": "!=null"
        }
    },
    "kretprobe:if (err)": {
        "description": "Handle error",
        "pre": {
            "err": "!=0"
        }
    }
},
{
    "kprobe:bus->state = MDIOBUS_UNREGISTERED; err = device_register(&bus->dev); if (err)": {
        "description": "Update the state of the bus to MDIOBUS_UNREGISTERED and register the device. If an error occurs during registration, the state will not be updated.",
        "pre": {
            "bus": "!=null",
            "bus->state": "==MDIOBUS_UNREGISTERED",
            "err": "!=null",
            "device_register(&bus->dev)": "returns 0 on success"
        }
    }
},
{
    "kretprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        },
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:__mdiobus_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device.",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        }
    }
},
{
    "kprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device.",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        }
    }
},
{
    "kretprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper.",
        "pre": {
            "node": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper.",
        "pre": {
            "node": "!=null",
            "port": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper.",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper.",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kretprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support.",
        "pre": {
            "phydev": "!=null",
            "max_speed": "!=null"
        }
    }
},
{
    "kprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support.",
        "pre": {
            "phydev": "!=null",
            "max_speed": "!=null"
        }
    }
},
{
    "kretprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": ">=0 && <=31",
            "regnum": ">=0 && <=65535"
        }
    }
},
{
    "kprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": ">=0 && <=31",
            "regnum": ">=0 && <=65535"
        }
    }
},
{
    "kretprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kretprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "mask": "!=null",
            "set": "!=null"
        },
        "post": {
            "return_value": "in [-errno, 0, 1]"
        }
    }
},
{
    "kprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "mask": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kretprobe:phy_register_fixup": {
        "description": "Creates a new phy_fixup and adds it to the list",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null",
            "run": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null"
        }
    }
},
{
    "kprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list.",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null"
        }
    }
},
{
    "kretprobe:phy_device_create": {
        "description": "We allocate the device, and initialize the default values.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "phy_id": "!=null",
            "is_c45": "!=null",
            "c45_ids": "!=null"
        }
    }
},
{
    "kprobe:phy_device_create": {
        "description": "We allocate the device, and initialize the default values.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "phy_id": "!=null",
            "is_c45": "!=null",
            "c45_ids": "!=null"
        }
    }
},
{
    "kretprobe:get_phy_device": {
        "description": "Probe for a PHY at @addr on @bus.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "is_c45": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is instance of struct phy_device",
            "return": "is not %-ENODEV",
            "return": "is not %-EIO"
        }
    }
},
{
    "kprobe:get_phy_device": {
        "description": "Probe for a PHY at @addr on @bus and return the @phy_device struct.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "is_c45": "!=null"
        }
    }
},
{
    "kretprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:if (!netdev)goto out;if (netdev->wol_enabled)return false;/* As long as not all affected network drivers support the * wol_enabled flag, let's check for hints that WoL is enabled. * Don't suspend PHY if the attached netdev parent may wake up. * The parent may point to a PCI device, as in tg3 driver. */": {
        "description": "Check if WoL is enabled and avoid suspending PHY if the attached netdev parent may wake up.",
        "pre": {
            "netdev": "==null",
            "netdev->wol_enabled": "==true"
        }
    }
},
{
    "kprobe:netdev_suspend": {
        "description": "Check if the netdev is suspended and return false if WOL is enabled.",
        "pre": {
            "netdev": "==null",
            "netdev->wol_enabled": "==true"
        }
    }
},
{
    "kretprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device.",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return_value": "in [0, -EIO, -ENODEV]"
        }
    }
},
{
    "kprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device.",
        "pre": {
            "phydev": "!=null"
        },
        "return": {
            "success": "0",
            "bus_access_error": "-EIO",
            "invalid_devices_in_package": "-ENODEV"
        }
    }
},
{
    "kretprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device.",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_XGMII]"
        }
    }
},
{
    "kprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device.",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_XGMII]"
        }
    }
},
{
    "kretprobe:phydev->irq_rerun": {
        "description": "Rerun interrupts which were postponed by phy_interrupt() because they occurred during the system sleep transition.",
        "pre": {
            "phydev": "!=null",
            "phydev->irq_rerun": "==true"
        }
    }
},
{
    "kprobe:if (phydev->irq_rerun)": {
        "description": "Check if the `irq_rerun` flag of `phydev` is true.",
        "pre": {
            "phydev": {
                "irq_rerun": "==true"
            }
        }
    }
},
{
    "kretprobe:phy_sfp_attach": {
        "description": "attach the SFP bus to the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_attach": {
        "description": "attach the SFP bus to the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_sfp_detach": {
        "description": "detach the SFP bus from the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_detach": {
        "description": "Detach the SFP bus from the PHY upstream network device.",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect": {
        "description": "Connect an ethernet device to a PHY device.",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_RTBI, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII_ID, PHY_INTERFACE_MODE_RGMII_RXID, PHY_INTERFACE_MODE_RGMII_TXID, PHY_INTERFACE_MODE_SGMII_2500, PHY_INTERFACE_MODE_QSGMII, PHY_INTERFACE_MODE_XGMII, PHY_INTERFACE_MODE_2500BASEX, PHY_INTERFACE_MODE_USXGMII, PHY_INTERFACE_MODE_INTERNAL]"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:phy_connect": {
        "description": "Connect an Ethernet device to a PHY device.",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "any",
            "interface": "any"
        }
    }
},
{
    "kretprobe:WARN_ON": {
        "description": "Check if the PHY device state is not PHY_HALTED, PHY_READY, or PHY_UP.",
        "pre": {
            "phydev->state": "not in [PHY_HALTED, PHY_READY, PHY_UP]"
        }
    },
    "kretprobe:phy_init_hw": {
        "description": "Initialize the PHY hardware.",
        "pre": {}
    },
    "kretprobe:phy_resume": {
        "description": "Resume the PHY device.",
        "pre": {}
    },
    "kretprobe:return": {
        "description": "Return the value of the previous helper function.",
        "pre": {
            "ret": ">= 0"
        }
    },
    "kretprobe:no_resume": {
        "description": "Label for the 'no_resume' section.",
        "pre": {}
    },
    "kretprobe:phy_interrupt_is_valid": {
        "description": "Check if the PHY interrupt is valid.",
        "pre": {
            "phydev": "!= null"
        }
    }
},
{
    "kprobe:phy_resume": {
        "description": "Resume the PHY device.",
        "pre": {
            "phydev": {
                "mac_managed_pm": "false",
                "suspended_by_mdio_bus": "true"
            }
        }
    }
},
{
    "kretprobe:phy_reset_after_clk_enable": {
        "description": "Perform a PHY reset if needed.",
        "pre": {
            "phydev": "!=null",
            "return_value": "in [-1, 0, 1]",
            "flags": "!=null",
            "reset_needed": "if flags indicate a reset is needed",
            "error": "return_value < 0"
        }
    }
},
{
    "kprobe:phy_reset_after_clk_enable": {
        "description": "Perform a PHY reset if needed.",
        "pre": {
            "phydev": "!=null",
            "ret": "!=0"
        }
    }
},
{
    "kretprobe:genphy_config_eee_advert": {
        "description": "disable unwanted eee mode advertisement",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_config_eee_advert": {
        "description": "disable unwanted eee mode advertisement",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_setup_forced": {
        "description": "Configures MII_BMCR to force speedduplex to the values in phydev.",
        "pre": {
            "phydev": "!=null",
            "phydev.speed": "valid",
            "phydev.duplex": "valid",
            "phydev.MII_BMCR": "valid"
        }
    }
},
S,
{
    "kretprobe:genphy_read_master_slave": {
        "description": "Reads the master/slave configuration and state of a PHY device.",
        "pre": {
            "phydev": "!=null",
            "cfg": "in [MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "state": "in [MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_UNKNOWN]",
            "val": ">=0",
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN]",
            "val & CTL1000_ENABLE_MASTER": "==0 or ==CTL1000_ENABLE_MASTER",
            "val & CTL1000_AS_MASTER": "==0 or ==CTL1000_AS_MASTER",
            "val & CTL1000_PREFER_MASTER": "==0 or ==CTL1000_PREFER_MASTER",
            "val & LPA_1000MSFAIL": "==0 or ==LPA_1000MSFAIL",
            "phydev->link": "==0 or ==1"
        }
    }
},
{
    "kprobe:genphy_read_master_slave": {
        "description": "Function to read the master-slave configuration and state of a PHY device.",
        "pre": {
            "phydev": "!=null",
            "cfg": "in [MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "state": "in [MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_UNKNOWN]",
            "val": ">=0",
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN]",
            "val & CTL1000_ENABLE_MASTER": "!=0",
            "val & CTL1000_AS_MASTER": "!=0",
            "val & CTL1000_PREFER_MASTER": "!=0",
            "val & LPA_1000MSFAIL": "!=0",
            "phydev->link": "!=0"
        }
    }
},
{
    "kretprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "pre": {
            "phydev": "!=null",
            "phydev->dev": "!=null",
            "phydev->dev->type": "==PHY_DEVICE_TYPE",
            "phydev->dev->bus": "==PHY_DEVICE_BUS",
            "phydev->dev->addr": "==PHY_DEVICE_ADDR"
        }
    }
},
S,
S,
{
    "kretprobe:__genphy_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "changed": "is bool"
        }
    }
},
{
    "kprobe:__genphy_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "changed": "is bool"
        }
    }
},
{
    "kretprobe:genphy_c37_config_aneg": {
        "description": "restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "auto-negotiation": "in [enabled, disabled]",
            "advertising": "!=null when auto-negotiation == enabled",
            "BMCR": "!=null when auto-negotiation == disabled"
        }
    }
},
{
    "kprobe:genphy_c37_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "auto_negotiation_enabled": {
                "true": {
                    "advertising_configured": "true",
                    "auto_negotiation_restarted": "true"
                },
                "false": {
                    "bmcr_written": "true"
                }
            }
        }
    }
},
{
    "kretprobe:genphy_aneg_done": {
        "description": "Return auto-negotiation status",
        "pre": {
            "phydev": "!=null",
            "return_value": "in [0, BMSR_ANEGCOMPLETE]"
        }
    }
},
{
    "kprobe:genphy_aneg_done": {
        "description": "Returns the auto-negotiation status",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_read_status_fixed": {
        "description": "Read the link parameters for !aneg mode",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_read_status_fixed": {
        "description": "Read the current duplex and speed state for a PHY operating with autonegotiation disabled.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c37_read_status": {
        "description": "Check the link status and update current link state",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_c37_read_status": {
        "description": "Check the link status and update the current link state.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:genphy_read_abilities": {
        "description": "Read PHY abilities from Clause 22 registers",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_read_abilities": {
        "description": "Read PHY abilities from Clause 22 registers",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode",
        "pre": {
            "phydev": "!=null",
            "link_mode": "!=null"
        }
    }
},
{
    "kprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode",
        "pre": {
            "phydev": "!=null",
            "link_mode": "!=null"
        }
    }
},
{
    "kretprobe:phy_advertise_supported": {
        "description": "Advertise all supported modes",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_advertise_supported": {
        "description": "Advertise all supported modes",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_support_asym_pause": {
        "description": "Enable support of asym pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported.",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool",
            "autoneg": "bool"
        }
    }
},
{
    "kprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported. Generally called from the set_pauseparam .ndo.",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool",
            "autoneg": "bool"
        }
    }
},
{
    "kretprobe:phy_set_asym_pause": {
        "description": "Configure advertised Pause support depending on if transmit and receiver pause is supported. If there has been a change in adverting, trigger a new autoneg. Generally called from the set_pauseparam .ndo.",
        "pre": {
            "phydev": "!=null",
            "rx": "is_boolean",
            "tx": "is_boolean"
        }
    }
},
{
    "kprobe:phy_set_asym_pause": {
        "description": "Configure Pause and Asym Pause",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool"
        }
    }
},
{
    "kretprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting.",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        }
    }
},
{
    "kprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting.",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_pause": {
        "description": "Resolve negotiated pause modes",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kprobe:phy_get_pause": {
        "description": "Resolve negotiated pause modes",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_internal_delay": {
        "description": "Returns the index of the internal delay",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "boolean"
        }
    }
},
{
    "kprobe:phy_get_internal_delay": {
        "description": "Returns the index of the internal delay",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "boolean"
        }
    }
},
{
    "kretprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device.",
        "pre": {
            "phy_fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device.",
        "pre": {
            "phy_fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size()",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size().",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "any"
        }
    }
},
{
    "kretprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information.",
        "pre": {
            "bus": "!=null",
            "cb": "valid_function_pointer"
        }
    }
},
{
    "kprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information.",
        "pre": {
            "bus": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board.",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        },
        "context": "can sleep"
    }
},
{
    "kprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board.",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:pcs_np = of_get_parent": {
        "description": "Get the parent node of np using of_get_parent function.",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "pcs_np": "!=null"
        }
    },
    "kretprobe:!pcs_np": {
        "description": "Return ERR_PTR(-ENODEV) if pcs_np is null.",
        "pre": {
            "pcs_np": "==null"
        },
        "post": {
            "return_value": "ERR_PTR(-ENODEV)"
        }
    },
    "kretprobe:!of_device_is_available(pcs_np)": {
        "description": "Return ERR_PTR(-ENODEV) if pcs_np is not available.",
        "pre": {
            "pcs_np": "!=null"
        },
        "post": {
            "return_value": "ERR_PTR(-ENODEV)"
        }
    }
},
{
    "kprobe:miic_create": {
        "description": "Create a miic device.",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "pcs_np": "!=null",
            "!pcs_np": "false",
            "!of_device_is_available(pcs_np)": "false"
        }
    }
},
{
    "kretprobe:mdio_device_put": {
        "description": "Put the reference to the MDIO device and return the PCS.",
        "pre": {
            "mdio": "!=null",
            "pcs": "!=null"
        }
    }
},
{
    "kprobe:mdio_device_put": {
        "description": "Put the reference to the MDIO device.",
        "pre": {
            "mdio": "!=null"
        }
    },
    "kprobe:return_pcs": {
        "description": "Return the PCS structure.",
        "pre": {
            "pcs": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:qede_rdma_unregister_driver": {
        "description": "Unregister the QEDR driver for RDMA.",
        "pre": {
            "drv": "!=null",
            "edev": "!=null",
            "qedr_dev_list_lock": "locked"
        },
        "post": {
            "qedr_drv": "null",
            "qedr_dev_list_lock": "unlocked"
        }
    }
},
{
    "kprobe:qede_rdma_unregister_driver": {
        "description": "Unregister the QEDR driver for RDMA.",
        "pre": {
            "drv": "!=null",
            "edev": {
                "rdma_info": {
                    "qedr_dev": "!=null",
                    "exp_recovery": "false"
                }
            }
        }
    }
},
{
    "kretprobe:mlx5_create_cq": {
        "description": "Create a completion queue (CQ) and add it to the comp EQ CQ tree to receive completion events.",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "out": "!=null",
            "outlen": ">=0",
            "eqn": ">=0",
            "din": "!=null",
            "eq": "!=null",
            "err": ">=0",
            "cq->cqn": ">=0",
            "cq->cons_index": ">=0",
            "cq->arm_sn": ">=0",
            "cq->eq": "!=null",
            "cq->uid": ">=0",
            "cq->refcount": ">=0",
            "cq->free": "!=null",
            "cq->comp": "!=null"
        }
    }
},
{
    "kprobe:mlx5_create_cq": {
        "description": "Create a completion queue (CQ) in mlx5_core_dev.",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kretprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in mlx5.",
        "pre": {
            "ft_attr": {
                "level": ">= fs_prio->num_levels"
            }
        }
    }
},
{
    "kprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in mlx5 with the given attributes.",
        "pre": {
            "ft_attr": {
                "level": ">= fs_prio->num_levels"
            }
        }
    }
},
{
    "kretprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Create an auto-grouped flow table in the mlx5 driver.",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": "!=null",
            "ft_attr->autogroup.max_num_groups": "!=null",
            "ft": "!=null",
            "ft->max_fte": "!=null",
            "autogroups_max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null"
        },
        "post": {
            "ft": "!=null",
            "ft->max_fte": "!=null",
            "autogroups_max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null",
            "ft->autogroup.active": "true",
            "ft->autogroup.required_groups": "(autogroups_max_fte / MAX_FLOW_GROUP_SIZE) - 1",
            "ft->autogroup.max_fte": "autogroups_max_fte"
        }
    }
},
{
    "kprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Create an auto-grouped flow table in the mlx5 driver.",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": "!=null",
            "ft_attr->autogroup.max_num_groups": "!=null",
            "ft": "!=null",
            "autogroups_max_fte": "!=null",
            "ft->max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null"
        }
    }
},
{
    "kretprobe:build_match_list": {
        "description": "Builds a match list",
        "pre": {
            "match_head": "!=null",
            "ft": "!=null",
            "spec": "!=null",
            "flow_act->fg": "!=null",
            "take_write": "boolean"
        }
    }
},
{
    "build_match_list": {
        "pre": {
            "&match_head": "!=null",
            "ft": "unknown",
            "spec": "unknown",
            "flow_act->fg": "unknown",
            "take_write": "unknown"
        }
    }
},
S,
S,
S,
{
    "kprobe:tree_init_node": {
        "description": "Initialize a tree node for the rule.",
        "pre": {
            "rule": "!=null",
            "node": "!=null",
            "del_sw_hw_rule": "!=null",
            "dest": "!=null",
            "dest[i].type": "!=MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE",
            "list_add(&rule->node.list, &fte->node.children)": "true",
            "list_add_tail(&rule->node.list, &fte->node.children)": "true"
        }
    }
},
{
    "kretprobe:mlx5_get_flow_namespace": {
        "description": "Get the flow namespace based on the given parameters.",
        "pre": {
            "dev": "!=null",
            "type": "in [MLX5_FLOW_NAMESPACE_FDB, MLX5_FLOW_NAMESPACE_PORT_SEL, MLX5_FLOW_NAMESPACE_SNIFFER_RX, MLX5_FLOW_NAMESPACE_SNIFFER_TX, MLX5_FLOW_NAMESPACE_FDB_BYPASS, MLX5_FLOW_NAMESPACE_EGRESS, MLX5_FLOW_NAMESPACE_EGRESS_IPSEC, MLX5_FLOW_NAMESPACE_EGRESS_MACSEC, MLX5_FLOW_NAMESPACE_RDMA_RX, MLX5_FLOW_NAMESPACE_RDMA_RX_KERNEL, MLX5_FLOW_NAMESPACE_RDMA_TX, MLX5_FLOW_NAMESPACE_RDMA_RX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_TX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_RX_IPSEC, MLX5_FLOW_NAMESPACE_RDMA_TX_IPSEC]",
            "steering": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlx5_eq_enable": {
        "description": "Enable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eq_get_eqe": {
        "description": "Get the EQ entry from the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "valid value",
            "ci": "eq->cons_index + cc",
            "nent": "eq_get_size(eq)",
            "eqe": "get_eqe(eq, ci & (nent - 1))",
            "ownership_bit_check": "(eqe->owner & 1) ^ !!(ci & nent)",
            "eqe_result": "(ownership_bit_check ? NULL : eqe)"
        },
        "post": {
            "return_value": "eqe"
        }
    }
},
{
    "kprobe:mlx5_eq_get_eqe": {
        "description": "Get the EQ entry from the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "any"
        }
    }
},
{
    "kretprobe:wmb();}EXPORT_SYMBOL(mlx5_eq_update_ci": {
        "description": "Updates the consumer index of the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "!=null",
            "arm": "in [true, false]",
            "addr": "!=null",
            "val": "!=null",
            "eq->cons_index": "!=null",
            "eq->eqn": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:wmb();}EXPORT_SYMBOL(mlx5_eq_update_ci": {
        "description": "Updates the consumer index of the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "!=null",
            "arm": "in [true, false]",
            "addr": "!=null",
            "val": "!=null",
            "eq->cons_index": "!=null",
            "eq->eqn": "!=null",
            "addr": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:mlx5_eq_create_generic": {
        "description": "Generic EQ API for mlx5_core consumers. Needed For RDMA ODP EQ for now.",
        "pre": {
            "dev": "!=null",
            "param": "!=null"
        },
        "post": {
            "return": "err",
            "dev": "unchanged",
            "param": "unchanged"
        }
    }
},
{
    "kprobe:mlx5_eq_create_generic": {
        "description": "Generic EQ API for mlx5_core consumers. Needed For RDMA ODP EQ for now.",
        "pre": {
            "dev": "!=null",
            "param": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_fc_counters_lookup_next": {
        "description": "Access a reference to struct mlx5_fc and perform operations on it.",
        "pre": {
            "dev": "!=null",
            "id": "!=null"
        },
        "post": {
            "struct mlx5_fc": "!=null",
            "counter list": "valid order of operations",
            "destroy": "not called after dump",
            "query": "consistent packets and bytes"
        }
    }
},
S,
S,
S,
{
    "kretprobe:find_rl_entry": {
        "description": "Finds an entry where we can register the given rate. If the rate already exists, return the entry where it is registered, otherwise return the first available entry. If the table is full, return NULL.",
        "pre": {
            "table": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dedicated": "in [true, false]"
        }
    }
},
{
    "kprobe:find_rl_entry": {
        "description": "Finds an entry where we can register the given rate. If the rate already exists, return the entry where it is registered, otherwise return the first available entry. If the table is full, return NULL.",
        "pre": {
            "table": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dedicated": "in [true, false]"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy data from rl_in to entry->rl_raw and set uid. Then call mlx5_set_pp_rate_limit_cmd with dev, entry, and true as arguments.",
        "pre": {
            "entry->rl_raw": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dev": "!=null",
            "entry": "!=null",
            "err": "!=null",
            "dev->priv.rl_table->max_size": "!=0",
            "rate": "!=0",
            "rate": ">=dev->priv.rl_table->min_rate",
            "rate": "<=dev->priv.rl_table->max_rate",
            "table->rl_lock": "locked",
            "table": "!=null",
            "table->rl_lock": "locked",
            "entry->refcount": "!=0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source to destination memory.",
        "pre": {
            "entry->rl_raw": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dev": "!=null",
            "dedicated_entry": "in [true, false]",
            "index": "!=null"
        }
    }
},
S,
{
    "kprobe:mlx5_free_bfreg": {
        "description": "Free a BF register in mlx5_core_dev.",
        "pre": {
            "mdev": "!=null",
            "bfreg": "!=null",
            "bfregs": "!=null",
            "up": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eswitch_add_send_to_vport_rule": {
        "description": "Add a rule to send packets to a virtual port in mlx5_eswitch.",
        "pre": {
            "on_esw": "!=null",
            "from_esw": "!=null",
            "rep": "!=null",
            "sqn": "!=null",
            "vport": "!=null",
            "mlx5_eswitch_vport_match_metadata_enabled(on_esw)": "true"
        }
    }
},
{
    "kprobe:mlx5_eswitch_add_send_to_vport_rule": {
        "description": "Add a rule to send packets to a vport in the mlx5 eswitch.",
        "pre": {
            "on_esw": "!=null",
            "from_esw": "!=null",
            "rep": "!=null",
            "sqn": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mlx5_eswitch_vport_match_metadata_enabled": {
        "description": "Check if vport metadata matching is enabled.",
        "pre": {
            "misc2": "!=null",
            "misc2.metadata_reg_c_0": 0,
            "misc2.metadata_reg_c_0": 0,
            "memchr_inv(misc2, 0, MLX5_ST_SZ_BYTES(fte_match_set_misc2))": false,
            "spec.match_criteria_enable": "& ~MLX5_MATCH_MISC_PARAMETERS_2"
        }
    }
},
{
    "kprobe:mlx5_eswitch_vport_match_metadata_enabled": {
        "description": "Check if vport metadata matching is enabled.",
        "pre": {
            "esw": "!=null",
            "spec->match_value": "!=null",
            "spec->match_criteria": "!=null"
        }
    }
},
{
    "kretprobe:if (esw_attr->out_count - esw_attr->split_count > 1)return -EOPNOTSUPP;err = esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i);if (err)return err;if (esw_attr->dests[esw_attr->split_count].pkt_reformat)": {
        "description": "The kretprobe function with the given condition",
        "pre": {
            "esw_attr->out_count - esw_attr->split_count": "> 1",
            "esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i)": "== 0",
            "err": "== 0",
            "esw_attr->dests[esw_attr->split_count].pkt_reformat": "!= null"
        }
    }
},
{
    "kprobe:if (esw_attr->out_count - esw_attr->split_count > 1)return -EOPNOTSUPP;err = esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i);if (err)return err;if (esw_attr->dests[esw_attr->split_count].pkt_reformat)": {
        "description": "The given function checks if the difference between 'out_count' and 'split_count' in 'esw_attr' is greater than 1. If it is, it returns -EOPNOTSUPP. Otherwise, it calls the 'esw_setup_chain_dest' function with the provided arguments. If an error occurs during the setup, it returns the error code. Finally, it checks if 'pkt_reformat' is set in 'esw_attr->dests[esw_attr->split_count]' and performs some action based on that.",
        "pre": {
            "esw_attr->out_count - esw_attr->split_count": "> 1",
            "esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i)": "!= null",
            "err": "== null",
            "esw_attr->dests[esw_attr->split_count].pkt_reformat": "!= null"
        }
    }
},
{
    "kretprobe:mlx5_sriov_blocking_notifier_unregister": {
        "description": "Unregister a VF from a notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_sriov_blocking_notifier_unregister": {
        "description": "Unregister a VF from a notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_sriov_blocking_notifier_register": {
        "description": "Register a VF notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_sriov_blocking_notifier_register": {
        "description": "Register a VF notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eswitch_get_core_dev": {
        "description": "Get the mdev device",
        "pre": {
            "esw": "!=null"
        }
    }
},
{
    "kprobe:mlx5_eswitch_get_core_dev": {
        "description": "Get the mdev device",
        "pre": {
            "esw": "!=null"
        }
    }
},
S,
{
    "kprobe:mlx5_cmd_check": {
        "description": "Aborted due to PCI error or via reset flow mlx5_cmd_trigger_completions()",
        "pre": {
            "dev": "!=null",
            "err": "== -ENXIO",
            "in": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_cmd_do": {
        "description": "Executes a fw command, wait for completion.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        },
        "post": {
            "return": {
                "type": "int",
                "constraints": [
                    "-EREMOTEIO",
                    "0",
                    "< 0"
                ]
            }
        }
    }
},
{
    "kprobe:mlx5_cmd_do": {
        "description": "Executes a fw command, wait for completion.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        },
        "post": {
            "-EREMOTEIO": "outbox.status != MLX5_CMD_STAT_OK",
            "0": "outbox.status == MLX5_CMD_STAT_OK",
            "< 0": "Command execution couldn't be performed by firmware or driver"
        }
    }
},
S,
S,
{
    "kretprobe:mlx5_cmd_exec_polling": {
        "description": "Executes a fw command, poll for completion. Needed for driver force teardown, when command completion EQ will not be available to complete the command.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        }
    }
},
{
    "kprobe:mlx5_cmd_exec_polling": {
        "description": "Executes a fw command, poll for completion. Needed for driver force teardown, when command completion EQ will not be available to complete the command.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        }
    }
},
{
    "kretprobe:mlx5_cmd_init_async_ctx": {
        "description": "Initialize async context for mlx5 command",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null",
            "ctx->num_inflight": "==1",
            "ctx->inflight_done": "is initialized"
        }
    }
},
{
    "kprobe:mlx5_cmd_init_async_ctx": {
        "description": "Initialize the async context for mlx5 command handling.",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null",
            "ctx->dev": "==dev",
            "ctx->num_inflight": "==1",
            "ctx->inflight_done": "not in [null, 0]"
        }
    }
},
{
    "kretprobe:mlx5_cmd_cleanup_async_ctx": {
        "description": "Cleanup the async context for mlx5_cmd",
        "pre": {},
        "post": {
            "mlx5_cmd_exec_cb": "==null"
        }
    }
},
{
    "kprobe:mlx5_cmd_cleanup_async_ctx": {
        "description": "Cleanup the async context for mlx5_cmd",
        "pre": {
            "mlx5_cmd_exec_cb_called": true,
            "mlx5_cmd_exec_cb_not_called_during_cleanup": true,
            "mlx5_cmd_exec_cb_not_called_after_cleanup": true
        }
    }
},
S,
{
    "kprobe:mlx5_vf_get_core_dev": {
        "description": "Get the associated mlx5_core_dev for the given pci_dev.",
        "pre": {
            "pdev": "!=null"
        },
        "post": {
            "return": "in [valid pointer to mlx5_core_dev, NULL]"
        }
    }
},
S,
S,
{
    "kretprobe:if (mlx5_lag_is_multipath(dev0))return;tracker = ldev->tracker;do_bond = tracker.is_bonded && mlx5_lag_check_prereq(ldev);}if (do_bond && !__mlx5_lag_is_active(ldev))": {
        "description": "Condition for the given function",
        "pre": {
            "mlx5_lag_is_multipath(dev0)": true,
            "ldev->tracker.is_bonded": true,
            "mlx5_lag_check_prereq(ldev)": true,
            "__mlx5_lag_is_active(ldev)": false
        }
    }
},
{
    "kprobe:mlx5_lag_is_multipath": {
        "description": "Check if the given device is in multipath mode.",
        "pre": {
            "dev0": "!=null"
        }
    },
    "kprobe:mlx5_lag_check_prereq": {
        "description": "Check if the prerequisites for lag bonding are met.",
        "pre": {
            "ldev": "!=null"
        }
    },
    "kprobe:__mlx5_lag_is_active": {
        "description": "Check if the given device is active in the lag.",
        "pre": {
            "ldev": "!=null"
        }
    },
    "kprobe:do_bond": {
        "description": "Check if bonding should be performed.",
        "pre": {
            "tracker.is_bonded": "==true",
            "ldev": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_gen_guid_change_eqe": {
        "description": "Generate an event queue entry for a GUID change event.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "dev->persist->num_vfs": "< slave",
            "eqe": "memset(&eqe, 0, sizeof(eqe))",
            "eqe.type": "MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT",
            "eqe.subtype": "MLX4_DEV_PMC_SUBTYPE_GUID_INFO",
            "eqe.event.port_mgmt_change.port": "mlx4_phys_to_slave_port(dev, slave, port)"
        },
        "post": {
            "return": "mlx4_GEN_EQE(dev, slave, &eqe)"
        }
    }
},
{
    "kprobe:mlx4_gen_guid_change_eqe": {
        "description": "Generate a GUID change event for mlx4 device.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "dev->persist->num_vfs": "< slave",
            "eqe": "memset(&eqe, 0, sizeof(eqe))",
            "eqe.type": "MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT",
            "eqe.subtype": "MLX4_DEV_PMC_SUBTYPE_GUID_INFO",
            "eqe.event.port_mgmt_change.port": "mlx4_phys_to_slave_port(dev, slave, port)",
            "mlx4_GEN_EQE(dev, slave, &eqe)": "return 0"
        }
    }
},
{
    "kretprobe:mlx4_gen_port_state_change_eqe": {
        "description": "Generate an event queue entry for port state change.",
        "pre": {
            "dev": "!=null",
            "slave": "int",
            "port": "u8",
            "port_subtype_change": "u8"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:mlx4_gen_port_state_change_eqe": {
        "description": "Generate a port state change event for a specific slave port.",
        "pre": {
            "dev->persist->num_vfs": "< slave",
            "eqe.subtype": "in [MLX4_EVENT_TYPE_PORT_CHANGE]",
            "slave_port": "calculated using mlx4_phys_to_slave_port(dev, slave, port)"
        }
    }
},
{
    "kretprobe:set_and_calc_slave_port_state": {
        "description": "Change the slave's port state based on the new event and previous state.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "event": "in [MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN, MLX4_PORT_STATE_DEV_EVENT_PORT_UP, MLX4_PORT_STATE_IB_EVENT_GID_VALID, MLX4_PORT_STATE_IB_EVENT_GID_INVALID]",
            "gen_event": "!=null"
        }
    }
},
{
    "kprobe:set_and_calc_slave_port_state": {
        "description": "Change the slave's port state based on the new event and previous state.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "event": "in [MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN, MLX4_PORT_STATE_DEV_EVENT_PORT_UP, MLX4_PORT_STATE_IB_EVENT_GID_VALID, MLX4_PORT_STATE_IB_EVENT_GID_INVALID]",
            "gen_event": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:eq_set_ci": {
        "description": "Set the congestion index of the specified eq.",
        "pre": {
            "eq": "!=null",
            "eq_index": "MLX4_EQ_ASYNC",
            "value": "1"
        }
    },
    "kretprobe:return": {
        "description": "Return 0."
    },
    "kretprobe:err_out_unmap": {
        "description": "Handle error and free eq_table.eq.",
        "pre": {
            "i": ">0"
        },
        "post": {
            "eq_table.eq[i]": "null"
        }
    },
    "kretprobe:CONFIG_RFS_ACCEL": {
        "description": "Handle RFS acceleration.",
        "pre": {
            "i": "1",
            "i": "<=dev.caps.num_ports"
        }
    }
},
{
    "kprobe:eq_set_ci": {
        "description": "Set the ci value of the eq element in the eq_table array.",
        "pre": {
            "&priv->eq_table.eq[MLX4_EQ_ASYNC]": "!=null",
            "1": "not specified"
        }
    }
},
{
    "kretprobe:mutex_unlock": {
        "description": "Unlock the mutex associated with the pool_lock in msix_ctl.",
        "pre": {
            "priv": "!=null",
            "priv->msix_ctl.pool_lock": "locked"
        }
    }
},
{
    "kprobe:mutex_unlock": {
        "description": "Unlock the mutex associated with the pool_lock in the msix_ctl structure.",
        "pre": {
            "priv": "!=null",
            "priv->msix_ctl.pool_lock": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_slave_from_roce_gid": {
        "description": "Calculate the globally unique slave id",
        "pre": {
            "found_ix": "< MLX4_ROCE_PF_GIDS",
            "slave_gid": "== 0"
        },
        "pre_else_if": {
            "found_ix": "< MLX4_ROCE_PF_GIDS + (vf_gids % num_vfs) * (vf_gids / num_vfs + 1)",
            "slave_gid": "== ((found_ix - MLX4_ROCE_PF_GIDS) / (vf_gids / num_vfs + 1)) + 1"
        },
        "pre_else": {
            "slave_gid": "== ((found_ix - MLX4_ROCE_PF_GIDS - ((vf_gids % num_vfs) * ((vf_gids / num_vfs + 1)))) / (vf_gids / num_vfs)) + vf_gids % num_vfs + 1"
        }
    }
},
{
    "kprobe:mlx4_get_slave_from_roce_gid": {
        "description": "Calculate the globally unique slave id",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "gid": "!=null",
            "slave_id": "!=null",
            "priv": "!=null",
            "i": ">=0",
            "found_ix": ">=-1",
            "vf_gids": ">=0",
            "slaves_pport": "!=null",
            "num_vfs": ">=0",
            "slave_gid": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_module_info": {
        "description": "Read cable module eeprom data",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:mlx4_get_module_info": {
        "description": "Read cable module eeprom data",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_ALLOCATE_VPP_get": {
        "description": "Allocate VPPs for mlx4 device",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "available_vpp": "!=null",
            "vpp_p_up": "!=null",
            "i": ">=0",
            "i": "< MLX4_NUM_UP",
            "vpp_p_up[i]": "!=null"
        },
        "post": {
            "available_vpp": "== be32_to_cpu(out_param->available_vpp)",
            "vpp_p_up[i]": "== be32_to_cpu(out_param->vpp_p_up[i])",
            "out": "mlx4_free_cmd_mailbox(dev, mailbox)",
            "return": "err"
        }
    }
},
{
    "kprobe:mlx4_ALLOCATE_VPP_get": {
        "description": "Total number of supported VPPs",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "available_vpp": "!=null",
            "vpp_p_up": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_parav_qkey": {
        "description": "Get the paravirtualized QKey for a given QPN.",
        "pre": {
            "dev": "!=null",
            "qpn": "!=null",
            "qkey": "!=null",
            "qk": "MLX4_RESERVED_QKEY_BASE",
            "condition1": "qpn >= dev->phys_caps.base_tunnel_sqpn + 8 * MLX4_MFUNC_MAX || qpn < dev->phys_caps.base_proxy_sqpn",
            "condition2": "qpn >= dev->phys_caps.base_tunnel_sqpn",
            "tunnel_qp": "true"
        },
        "post": {
            "qkey": "qk",
            "return": "0"
        }
    }
},
{
    "kprobe:mlx4_get_parav_qkey": {
        "description": "Get the paravirtualized QKey for a given QPN.",
        "pre": {
            "dev": "!=null",
            "qpn": "!=null",
            "qkey": "!=null",
            "qk": "MLX4_RESERVED_QKEY_BASE",
            "qpn >= dev->phys_caps.base_tunnel_sqpn + 8 && qpn < dev->phys_caps.base_proxy_sqpn": true
        },
        "post": {
            "*qkey": "qk",
            "return": 0
        }
    }
},
{
    "kretprobe:mlx4_tunnel_steer_add": {
        "description": "Add a tunnel steer rule for inner eth header",
        "pre": {
            "spec_eth_inner.id": "MLX4_NET_TRANS_RULE_ID_ETH"
        }
    }
},
"spec_eth_inner.id": "MLX4_NET_TRANS_RULE_ID_ETH",
S,
S,
{
    "kretprobe:mlxsw_emad_rx_listener_func": {
        "description": "The mlxsw_emad_rx_listener_func function in the bpftrace kretprobe.",
        "pre": {
            "mlxsw_core": "!=null",
            "skb": "!=null",
            "trans->tx_info": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlxsw_core_event_listener_register": {
        "description": "Register an event listener in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "el": "!=null",
            "priv": "!=null",
            "el_item": "==null",
            "rxl.func": "mlxsw_core_event_listener_func",
            "rxl.local_port": "MLXSW_PORT_DONT_CARE",
            "rxl.trap_id": "el->trap_id"
        },
        "post": {
            "return": "0",
            "err": "==null"
        }
    }
},
{
    "kprobe:mlxsw_core_event_listener_register": {
        "description": "Register an event listener in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "el": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_core_driver_register": {
        "description": "Register an mlxsw driver.",
        "pre": {
            "mlxsw_driver": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlxsw_core_trap_state_set": {
        "description": "Not supported for event listener",
        "pre": {
            "mlxsw_core": "!=null",
            "listener": "!=null",
            "enabled": "!=null",
            "listener.is_event": "==false",
            "listener.is_event": "!=true",
            "listener->is_event": "==false",
            "listener->is_event": "!=true",
            "WARN_ON(listener->is_event)": "==false",
            "WARN_ON(listener->is_event)": "!=true",
            "return": "==0",
            "return": "!=EINVAL",
            "action": "in [listener->en_action, listener->dis_action]",
            "trap_group": "in [listener->en_trap_group, listener->dis_trap_group]",
            "mlxsw_reg_hpkt_pack(hpkt_pl, action, listener->trap_id, trap_group, listener->is_ctrl)": "==0",
            "err": "==0",
            "mlxsw_reg_write(mlxsw_core, MLXSW_REG(hpkt), hpkt_pl)": "==0",
            "mlxsw_core_rx_listener_state_set(mlxsw_core, &listener->rx_listener, enabled)": "==0"
        }
    }
},
{
    "kprobe:mlxsw_core_trap_state_set": {
        "description": "Not supported for event listener",
        "pre": {
            "mlxsw_core": "!=null",
            "listener": "!=null",
            "enabled": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_reg_trans_bulk_wait": {
        "description": "Wait for completion of multiple mlxsw_reg_trans operations in bulk.",
        "pre": {
            "bulk_list": "!=null",
            "trans": "!=null",
            "tmp": "!=null",
            "sum_err": "int",
            "err": "int",
            "err != 0": "sum_err == 0"
        }
    }
},
{
    "kprobe:mlxsw_reg_trans_bulk_wait": {
        "description": "Wait for the completion of multiple register transactions in bulk.",
        "pre": {
            "bulk_list": "!=null"
        }
    }
},
{
    "kretprobe:get_random_bytes": {
        "description": "Generate random bytes and store them in the variable tid.",
        "pre": {
            "tid": "!=null"
        }
    },
    "kretprobe:atomic64_set": {
        "description": "Set the value of the variable tid to the left-shifted value of tid by 32.",
        "pre": {
            "tid": "!=null",
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the variable mlxsw_core->emad.trans_list as an empty list.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:spin_lock_init": {
        "description": "Initialize the spin lock variable mlxsw_core->emad.trans_list_lock.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_core_trap_register": {
        "description": "Register the trap listener mlxsw_emad_rx_listener with mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_emad_tlv_enable": {
        "description": "Enable the TLV feature for mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_core_trap_unregister": {
        "description": "Unregister the trap listener mlxsw_emad_rx_listener from mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:destroy_workqueue": {
        "description": "Destroy the workqueue mlxsw_core->emad_wq.",
        "pre": {
            "mlxsw_core": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_emad_fini": {
        "description": "Finalize the mlxsw_core->emad structure.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_query": {
        "description": "Query the mlxsw_core with the mgir register.",
        "pre": {
            "mlxsw_core": "!=null",
            "mgir": "!=null",
            "mgir_pl": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_reg_mgir_fw_info_string_tlv_get": {
        "description": "Get the string TLV from the mgir firmware info.",
        "pre": {
            "mgir_pl": "!=null",
            "string_tlv": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_mgir_fw_info_latency_tlv_get": {
        "description": "Get the latency TLV from the mgir firmware info.",
        "pre": {
            "mgir_pl": "!=null",
            "latency_tlv": "!=null"
        }
    },
    "kretprobe:mlxsw_emad_tlv_disable": {
        "description": "Disable the TLV feature for mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_emad_init": {
        "description": "Initialize the mlxsw_core->emad structure.",
        "pre": {
            "mlxsw_core": "!=null",
            "emad_wq": "!=null",
            "tid": "!=null",
            "err": "==0"
        }
    }
},
{
    "kprobe:get_random_bytes": {
        "description": "Generate random bytes and store them in the variable tid. Then left shift tid by 32 bits. Set the value of the atomic64 variable mlxsw_core->emad.tid to tid. Initialize the list head mlxsw_core->emad.trans_list. Initialize the spin lock mlxsw_core->emad.trans_list_lock. Register the trap mlxsw_emad_rx_listener with mlxsw_core using mlxsw_core_trap_register. If there is an error, go to err_trap_register. Enable the TLV mlxsw_emad_tlv_enable with mlxsw_core. If there is an error, go to err_emad_tlv_enable. Set mlxsw_core->emad.use_emad to true. Return 0. If there is an error, unregister the trap mlxsw_emad_rx_listener with mlxsw_core using mlxsw_core_trap_unregister. Go to err_trap_register. Destroy the workqueue mlxsw_core->emad_wq. Return the error code.",
        "pre": {
            "tid": "!=null",
            "mlxsw_core->emad.tid": "tid << 32",
            "mlxsw_core->emad.trans_list": "INIT_LIST_HEAD",
            "mlxsw_core->emad.trans_list_lock": "spin_lock_init",
            "err": "0",
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "mlxsw_emad_tlv_enable": "!=null",
            "mlxsw_core_trap_register": "!=null",
            "mlxsw_core_trap_unregister": "!=null",
            "err_trap_register": "!=null",
            "err_emad_tlv_enable": "!=null",
            "destroy_workqueue": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mlxsw_core_lag_mapping_get": {
        "description": "Get the local port for the lag port and push it up.",
        "pre": {
            "mlxsw_core": "!=null",
            "rx_info->u.lag_id": "!=null",
            "rx_info->lag_port_index": "!=null"
        }
    }
},
{
    "kprobe:mlxsw_core_lag_mapping_get": {
        "description": "Get the local port for the lag port.",
        "pre": {
            "mlxsw_core": "!=null",
            "rx_info->u.lag_id": "!=null",
            "rx_info->lag_port_index": "!=null"
        }
    }
},
{
    "kretprobe:if (err == -EAGAIN && !called_again)": {
        "description": "Condition for if (err == -EAGAIN && !called_again)",
        "pre": {
            "err": "== -EAGAIN",
            "called_again": "== false"
        }
    }
},
{
    "kprobe:if (err == -EAGAIN && !called_again)": {
        "description": "Condition for the given function",
        "pre": {
            "err": "== -EAGAIN",
            "called_again": "== false"
        }
    }
},
{
    "kretprobe:mlxsw_core_resources_query": {
        "description": "This function queries the resources of the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mbox": "!=null",
            "res": "!=null",
            "index": ">=0",
            "i": ">=0",
            "data": ">=0",
            "id": ">=0",
            "err": ">=0"
        },
        "post": {
            "return": "-EIO"
        }
    }
},
{
    "kprobe:return -EIO;}EXPORT_SYMBOL(mlxsw_core_resources_query": {
        "description": "This function is used to query resources in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mbox": "!=null",
            "res": "!=null",
            "index": ">=0",
            "i": ">=0",
            "data": ">=0",
            "id": ">=0",
            "err": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_MAX_QUERIES": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_PER_QUERY": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_TABLE_END_ID": ">=0",
            "MLXSW_RESOURCES_QUERY_MAX_QUERIES": ">=0"
        }
    }
},
{
    "kretprobe:mlxsw_afa_block_create": {
        "description": "Create an mlxsw_afa_block structure and initialize it with the given mlxsw_afa structure.",
        "pre": {
            "mlxsw_afa": "!=null"
        },
        "post": {
            "block": "!=null",
            "block->resource_list": "initialized",
            "block->afa": "mlxsw_afa"
        }
    }
},
{
    "kprobe:mlxsw_afa_block_create": {
        "description": "Create an mlxsw_afa_block structure and initialize it with the given mlxsw_afa.",
        "pre": {
            "mlxsw_afa": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_afa_block_first_kvdl_index": {
        "description": "Get the KVD linear index of the second set in the given block.",
        "pre": {
            "block": "!=null",
            "block->first_set": "!=null",
            "block->first_set->next": "!=null"
        },
        "post": {
            "return": "block->first_set->next->kvdl_index"
        }
    }
},
S,
{
    "kretprobe:mlxsw_afa_cookie_lookup": {
        "description": "Lookup the cookie associated with the given cookie index.",
        "pre": {
            "mlxsw_afa": "!=null",
            "cookie_index": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mlxsw_afa_cookie_lookup": {
        "description": "Lookup the cookie associated with the given cookie_index in mlxsw_afa.",
        "pre": {
            "cookie_index": "!=0",
            "cookie_index": "!=null",
            "idr_find_result": "!=null",
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:return;if (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) || WARN_ON(elinfo->item.size.bytes != len))return;__mlxsw_item_memcpy_to(values->storage.key, key_value, storage_item, 0);__mlxsw_item_memcpy_to(values->storage.mask, mask_value, storage_item, 0);mlxsw_afk_element_usage_add(&values->elusage, element);}EXPORT_SYMBOL(mlxsw_afk_values_add_buf": {
        "description": "mlxsw_afk_values_add_buf function",
        "pre": {
            "values": "!=null",
            "element": "in [valid enum values]",
            "key_value": "!=null",
            "mask_value": "!=null",
            "len": "!=null",
            "elinfo->type": "== MLXSW_AFK_ELEMENT_TYPE_BUF",
            "elinfo->item.size.bytes": "== len",
            "mask_value": "!=0"
        }
    }
},
{
    "kprobe:return;if (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) || WARN_ON(elinfo->item.size.bytes != len))return;__mlxsw_item_memcpy_to(values->storage.key, key_value, storage_item, 0);__mlxsw_item_memcpy_to(values->storage.mask, mask_value, storage_item, 0);mlxsw_afk_element_usage_add(&values->elusage, element);}EXPORT_SYMBOL(mlxsw_afk_values_add_buf": {
        "description": "mlxsw_afk_values_add_buf function",
        "pre": {
            "values": "!=null",
            "element": "in [MLXSW_AFK_ELEMENT_TYPE_BUF]",
            "key_value": "!=null",
            "mask_value": "!=null",
            "len": "!=null",
            "mask": "==0"
        }
    }
},
{
    "kretprobe:mlxsw_env_query_module_eeprom": {
        "description": "Verify if transceiver provides diagnostic monitoring page",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "SFP_DIAGMON": "in [0, 1]",
            "diag_mon": "in [0, 1]",
            "read_size": ">= 1",
            "modinfo->type": "ETH_MODULE_SFF_8472",
            "modinfo->eeprom_len": "ETH_MODULE_SFF_8472_LEN"
        },
        "post": {
            "err": "= 0 if read_size >= 1, else -EIO"
        }
    }
},
S,
{
    "kretprobe:mlxsw_env_validate_cable_ident": {
        "description": "Validate module identifier value.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "qsfp": "!=null",
            "cmis": "!=null",
            "ee->len": "!=0",
            "mlxsw_env_linecard_is_active(mlxsw_env, slot_index)": "==true"
        }
    }
},
{
    "kprobe:mlxsw_env_validate_cable_ident": {
        "description": "Validate cable identifier value.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "qsfp": "!=null",
            "cmis": "!=null",
            "err": "!=null",
            "i": "!=null",
            "ee->len": "!=null"
        }
    }
},
{
    "kretprobe:device_addr = page->offset": {
        "description": "Assign the value of page->offset to device_addr.",
        "pre": {
            "page": "!=null",
            "page->offset": "!=null"
        }
    },
    "kretprobe:while (bytes_read < page->length)": {
        "description": "Loop until bytes_read is less than page->length.",
        "pre": {
            "bytes_read": "!=null",
            "page": "!=null",
            "page->length": "!=null"
        }
    }
},
{
    "kprobe:device_addr = page->offset; while (bytes_read < page->length)": {
        "description": "This condition represents the function 'device_addr = page->offset; while (bytes_read < page->length)'.",
        "pre": {
            "page->offset": "!=null",
            "page->length": ">bytes_read"
        }
    }
},
{
    "kretprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_mcion_pack": {
        "description": "Pack the mcion payload with slot index and module.",
        "pre": {
            "mcion_pl": "!=null",
            "slot_index": "!=null",
            "module": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_query": {
        "description": "Query the mlxsw core with mcion payload.",
        "pre": {
            "mlxsw_core": "!=null",
            "mcion_pl": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kprobe:mlxsw_reg_mcion_pack": {
        "description": "Pack the mcion payload with slot index and module.",
        "pre": {
            "mcion_pl": "!=null",
            "slot_index": "!=null",
            "module": "!=null"
        }
    },
    "kprobe:mlxsw_reg_query": {
        "description": "Query mlxsw_core with mcion payload.",
        "pre": {
            "mlxsw_core": "!=null",
            "mcion_pl": "!=null"
        }
    }
},
{
    "kretprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active in the mlxsw_env.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kretprobe:mlxsw_env_module_enable_set": {
        "description": "Set the power mode of a module in the mlxsw_env.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "low_power": "in [true, false]",
            "extack": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active in the mlxsw_env.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kprobe:mlxsw_env_module_enable_set": {
        "description": "Set the power mode of a module in the mlxsw_env.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "low_power": "in [true, false]",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:__mlxsw_env_set_module_power_mode": {
        "description": "Set the power mode of a module in the mlxsw_env environment.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "module_info": "!=null",
            "err": "int",
            "mlxsw_env": "!=null",
            "mlxsw_env->line_cards_lock": "mutex_locked",
            "module_info->power_mode_policy": "==ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO",
            "module_info->num_ports_up": "==0"
        },
        "post": {
            "module_info->num_ports_up": "++"
        }
    }
},
{
    "kprobe:__mlxsw_env_set_module_power_mode": {
        "description": "Set the power mode of a module in the mlxsw environment.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "module_info": "!=null",
            "err": "int",
            "mlxsw_env": "!=null",
            "mlxsw_env->line_cards_lock": "mutex",
            "module_info->power_mode_policy": "== ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO",
            "module_info->num_ports_up": "== 0"
        },
        "post": {
            "module_info->num_ports_up": "++"
        },
        "goto": {
            "out_inc": "label",
            "out_unlock": "label"
        },
        "return": "err"
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:bnxt_register_async_events": {
        "description": "Register asynchronous events for the bnxt driver.",
        "pre": {
            "edev": "!=null",
            "events_bmap": "!=null",
            "max_id": "!=null",
            "dev": "!=null",
            "bp": "!=null",
            "ulp": "!=null",
            "async_events_bmap": "events_bmap"
        }
    }
},
{
    "kprobe:bnxt_register_async_events": {
        "description": "Register asynchronous events for the bnxt driver.",
        "pre": {
            "edev": "!=null",
            "events_bmap": "!=null",
            "max_id": "!=null",
            "dev": "!=null",
            "bp": "!=null",
            "ulp": "!=null",
            "async_events_bmap": "events_bmap"
        }
    }
},
S,
S,
{
    "kretprobe:hnae3_register_ae_algo": {
        "description": "Register a AE algorithm to hnae3 framework",
        "pre": {
            "ae_algo": "!=null"
        }
    }
},
{
    "kprobe:hnae3_register_ae_algo": {
        "description": "Register a AE algorithm to hnae3 framework.",
        "pre": {
            "ae_algo": "!=null"
        }
    }
},
{
    "kretprobe:hnae3_register_ae_dev": {
        "description": "Registers an AE device to the hnae3 framework",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kprobe:hnae3_register_ae_dev": {
        "description": "Registers an AE device to the hnae3 framework.",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kretprobe:hnae3_unregister_ae_dev": {
        "description": "Unregisters an AE device.",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kprobe:hnae3_unregister_ae_dev": {
        "description": "Unregisters an AE device",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kretprobe:hns_dsaf_roce_reset": {
        "description": "Reset dsaf and roce",
        "pre": {
            "dsaf_fwnode": "!=null",
            "dereset": "in [false, true]"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:hns_dsaf_roce_reset": {
        "description": "Reset dsaf and roce",
        "pre": {
            "dsaf_fwnode": "!=null",
            "dereset": "in [false, true]"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
S,
S,
{
    "kretprobe:hnae_get_handle": {
        "description": "Get a handle from the AE",
        "pre": {
            "owner_dev": "!=null",
            "fwnode": "!=null",
            "port_id": "!=null",
            "bops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:hnae_get_handle": {
        "description": "Get a handle from the AE.",
        "pre": {
            "owner_dev": "!=null",
            "fwnode": "!=null",
            "port_id": "!=null",
            "bops": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:hnae_ae_register": {
        "description": "Register a AE engine to hnae framework",
        "pre": {
            "hdev": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:hnae_ae_register": {
        "description": "Register a AE engine to hnae framework.",
        "pre": {
            "hdev": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:hnae_ae_unregister": {
        "description": "Unregisters a HNAE AE engine",
        "pre": {
            "hdev": "!=null"
        }
    }
},
{
    "kprobe:hnae_ae_unregister": {
        "description": "Unregisters a HNAE AE engine.",
        "pre": {
            "hdev": "!=null"
        }
    }
},
{
    "kretprobe:wx_irq_disable": {
        "description": "Mask off interrupt generation on the NIC",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_irq_disable": {
        "description": "Mask off interrupt generation on the NIC",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wr32m": {
        "description": "Let firmware know the driver has taken over if drv is true, otherwise let firmware take over control of hw.",
        "pre": {
            "wx": "!=null",
            "WX_CFG_PORT_CTL": "!=null",
            "WX_CFG_PORT_CTL_DRV_LOAD": "!=null",
            "drv": "in [true, false]"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Let firmware know the driver has taken over if drv is true, otherwise let firmware take over control of hw.",
        "pre": {
            "wx": "!=null",
            "drv": "in [true, false]",
            "WX_CFG_PORT_CTL": "if drv == true then == WX_CFG_PORT_CTL_DRV_LOAD else == 0"
        }
    }
},
{
    "kretprobe:wx_mng_present": {
        "description": "Returns 0 when management capability is present",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:wx_mng_present": {
        "description": "Returns 0 when management capability is present",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_host_interface_command": {
        "description": "Issue command to manageability block",
        "pre": {
            "wx": "!=null",
            "buffer": "!=null",
            "length": "is_multiple_of(4)",
            "timeout": ">=0",
            "return_data": "is_boolean"
        }
    }
},
{
    "kprobe:wx_host_interface_command": {
        "description": "Issue command to manageability block",
        "pre": {
            "wx": "!=null",
            "buffer": "!=null",
            "length": "is_multiple_of(4)",
            "timeout": "is_positive",
            "return_data": "is_boolean"
        }
    }
},
{
    "kretprobe:wx_read_ee_hostif_data": {
        "description": "Read EEPROM word using a host interface cmd assuming that the semaphore is already obtained.",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:wx_read_ee_hostif_data": {
        "description": "Read EEPROM word using a host interface cmd assuming that the semaphore is already obtained.",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:wx_read_ee_hostif_buffer": {
        "description": "Read EEPROM word(s) using hostif",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "words": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:wx_read_ee_hostif_buffer": {
        "description": "Read EEPROM word(s) using hostif",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "words": "!=null",
            "data": "!=null"
        }
    }
},
S,
{
    "kprobe:wx_reset_hostif": {
        "description": "Send reset cmd to fw",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_get_mac_addr": {
        "description": "Generic get MAC address",
        "pre": {
            "wx": "!=null",
            "mac_addr": "!=null"
        }
    }
},
{
    "kprobe:wx_get_mac_addr": {
        "description": "Generic get MAC address",
        "pre": {
            "wx": "!=null",
            "mac_addr": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_set_mac": {
        "description": "Change the Ethernet Address of the NIC",
        "pre": {
            "netdev": "!=null",
            "p": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:wx_set_mac": {
        "description": "Change the Ethernet Address of the NIC",
        "pre": {
            "netdev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:wr32m(wx, WX_MAC_RX_CFG, WX_MAC_RX_CFG_RE, 0);}}}EXPORT_SYMBOL(wx_disable_rx": {
        "description": "Disable the MAC receiver.",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_RE": "!=null",
            "0": "==0"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Disable the MAC receiver.",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_RE": "!=null",
            "0": "==0"
        }
    }
},
{
    "kretprobe:fctrl": {
        "description": "Set the conditions for the fctrl function",
        "pre": {
            "fctrl": "!=null",
            "fctrl & (WX_PSR_CTL_UPE | WX_PSR_CTL_MPE)": "== 0",
            "vmolr": "!=null",
            "vmolr & (WX_PSR_VM_L2CTL_UPE | WX_PSR_VM_L2CTL_MPE | WX_PSR_VM_L2CTL_ROPE | WX_PSR_VM_L2CTL_ROMPE)": "== 0",
            "vlnctrl": "!=null",
            "vlnctrl & (WX_PSR_VLAN_CTL_VFE | WX_PSR_VLAN_CTL_CFIEN)": "== 0"
        }
    }
},
{
    "kprobe:fctrl": {
        "description": "Set the control flags for the given net device.",
        "pre": {
            "netdev": "!=null",
            "netdev.type": "==struct net_device",
            "netdev.features": "!=null"
        }
    }
},
{
    "kretprobe:wx_change_mtu": {
        "description": "Change the Maximum Transfer Unit",
        "pre": {
            "netdev": "!=null",
            "new_mtu": "!=null",
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:wx_change_mtu": {
        "description": "Change the Maximum Transfer Unit",
        "pre": {
            "netdev": "!=null",
            "new_mtu": "!=null",
            "new_mtu": ">=0"
        }
    }
},
{
    "kretprobe:wr32m": {
        "description": "Disable the rx queue by clearing the RRCFG.EN bit.",
        "pre": {
            "wx": "!=null",
            "ring": "!=null",
            "ring->reg_idx": "!=null",
            "rxdctl": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Disable the RX queue by clearing the RRCFG.EN bit.",
        "pre": {
            "wx": "!=null",
            "ring": "!=null",
            "ring->reg_idx": "!=null",
            "rxdctl": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:wx_disable_sec_rx_path": {
        "description": "Stops the receive data path",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_disable_sec_rx_path": {
        "description": "Stops the receive data path",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_disable_pcie_master": {
        "description": "Disable PCI-express master access",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_disable_pcie_master": {
        "description": "Disable PCI-express master access",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_stop_adapter": {
        "description": "Generic stop TxRx units",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_stop_adapter": {
        "description": "Generic stop TxRx units",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wr32m": {
        "description": "Clear counters on read",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_JE": "!=null",
            "WX_MAC_RX_CFG_JE_size": ">2048"
        }
    }
},
S,
{
    "kretprobe:wx_get_pcie_msix_counts": {
        "description": "Gets MSI-X vector count",
        "pre": {
            "wx": "!=null",
            "msix_count": "!=null",
            "max_msix_count": "!=null"
        }
    }
},
{
    "kprobe:wx_get_pcie_msix_counts": {
        "description": "Gets MSI-X vector count",
        "pre": {
            "wx": "!=null",
            "msix_count": "!=null",
            "max_msix_count": "!=null"
        }
    }
},
{
    "kretprobe:wx_configure_rx": {
        "description": "Configure Receive Unit after Reset",
        "pre": {
            "wx": "!=null",
            "wx->netdev": "!=null",
            "VLAN ID": "0",
            "wx->active_vlans": "!=null",
            "vid": ">=0"
        }
    }
},
S,
{
    "kretprobe:wx_vlan_rx_kill_vid": {
        "description": "Remove VID from filter table",
        "pre": {
            "netdev": "!=null",
            "proto": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kprobe:wx_vlan_rx_kill_vid": {
        "description": "Remove VID from filter table",
        "pre": {
            "netdev": "!=null",
            "proto": "!=null",
            "vid": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_xmit_frame_ring": {
        "description": "Record the location of the first descriptor for this packet.",
        "pre": {
            "skb": {
                "shinfo": {
                    "frags": {
                        "f": {
                            "count": ">= 0",
                            "size": ">= 0"
                        }
                    },
                    "nr_frags": "> 0"
                }
            },
            "tx_ring": "!= null",
            "count": ">= 0"
        }
    }
},
{
    "kprobe:wx_xmit_frame_ring": {
        "description": "Record the location of the first descriptor for this packet.",
        "pre": {
            "skb": {
                "shinfo": {
                    "frags": {
                        "f": {
                            "count": ">= 0",
                            "size": ">= 0"
                        }
                    },
                    "nr_frags": "> 0"
                }
            },
            "tx_ring": "!= null",
            "count": ">= 0"
        }
    }
},
{
    "kretprobe:wx_clear_interrupt_scheme": {
        "description": "Clear the current interrupt scheme settings",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clear_interrupt_scheme": {
        "description": "Clear the current interrupt scheme settings",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_set_num_queues": {
        "description": "Set interrupt mode",
        "pre": {
            "wx": "!=null",
            "ret": "is int"
        }
    }
},
{
    "kprobe:wx_set_num_queues": {
        "description": "Set interrupt mode",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_free_irq": {
        "description": "Free IRQs based on specific conditions",
        "pre": {
            "q_vector->rx.ring": "==false",
            "q_vector->tx.ring": "==false",
            "entry->vector": "!=null",
            "q_vector": "!=null",
            "wx->mac.type": "==wx_mac_em",
            "wx->msix_entries[vector].vector": "!=null",
            "wx": "!=null"
        }
    }
},
{
    "wx_free_irq": {
        "description": "Free the IRQ associated with the given wx structure.",
        "pre": {
            "!q_vector->rx.ring && !q_vector->tx.ring": true,
            "!(pdev->msix_enabled)": {
                "action": "free_irq(pdev->irq, wx)"
            },
            "pdev->msix_enabled": {
                "for": "vector",
                "range": {
                    "start": 0,
                    "end": "wx->num_q_vectors"
                },
                "pre": {
                    "q_vector": "wx->q_vector[vector]",
                    "entry": "&wx->msix_entries[vector]",
                    "action": "free_irq(entry->vector, q_vector)"
                }
            }
        }
    }
},
{
    "kretprobe:wx_setup_isb_resources": {
        "description": "Allocate interrupt status resources",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:wx_setup_isb_resources": {
        "description": "Allocate interrupt status resources",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_free_isb_resources": {
        "description": "Allocate all queues Rx resources",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:wx_free_isb_resources": {
        "description": "Allocate all queues Rx resources",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_configure_vectors": {
        "description": "Configure vectors for hardware",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_configure_vectors": {
        "description": "Configure vectors for hardware",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_clean_all_rx_rings": {
        "description": "Free Rx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clean_all_rx_rings": {
        "description": "Free Rx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_clean_all_tx_rings": {
        "description": "Free Tx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clean_all_tx_rings": {
        "description": "Free Tx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_get_stats64": {
        "description": "Get System Network Statistics",
        "pre": {
            "netdev": "!=null",
            "stats": "!=null"
        }
    }
},
S,
{
    "kretprobe:otx2_set_mac_address": {
        "description": "Set the MAC address for the given net device.",
        "pre": {
            "netdev": "!=null",
            "p": "!=null",
            "pfvf": "!=null",
            "addr": "!=null",
            "addr->sa_data": "is_valid_ether_addr(addr->sa_data)",
            "otx2_hw_set_mac_addr(pfvf, addr->sa_data)": "true"
        }
    }
},
{
    "kprobe:otx2_set_mac_address": {
        "description": "Set the MAC address for the given network device.",
        "pre": {
            "netdev": "!=null",
            "p": "!=null",
            "pfvf": "!=null",
            "addr": "!=null",
            "is_valid_ether_addr(addr->sa_data)": "true",
            "otx2_hw_set_mac_addr(pfvf, addr->sa_data)": "true"
        }
    }
},
{
    "kretprobe:otx2_get_mac_from_af": {
        "description": "If AF doesn't provide a valid MAC, generate a random one",
        "pre": {
            "netdev": "!=null",
            "pfvf": "!=null",
            "err": "!=null",
            "pfvf->dev": "!=null",
            "pfvf->dev": "is of type struct device",
            "pfvf->dev": "has a valid MAC address",
            "err": "==0"
        }
    }
},
{
    "kprobe:if (!is_valid_ether_addr(netdev->dev_addr))eth_hw_addr_random(netdev);": {
        "description": "Generate a random MAC address if the AF does not provide a valid MAC.",
        "pre": {
            "netdev": "!=null",
            "netdev->dev_addr": "!is_valid_ether_addr(netdev->dev_addr)"
        }
    }
},
{
    "kretprobe:otx2_txschq_config": {
        "description": "Set topology e.t.c configuration",
        "pre": {
            "pfvf": "!=null",
            "lvl": "== NIX_TXSCH_LVL_SMQ",
            "prio": "!=null",
            "txschq_for_pfc": "!=null"
        }
    }
},
{
    "kprobe:otx2_txschq_config": {
        "description": "Set topology e.t.c configuration",
        "pre": {
            "pfvf": "!=null",
            "lvl": "== NIX_TXSCH_LVL_SMQ",
            "prio": "!=null",
            "txschq_for_pfc": "!=null"
        }
    }
},
{
    "kretprobe:otx2_detach_resources": {
        "description": "Detach resources",
        "pre": {
            "mbox": "!=null",
            "mbox->lock": "locked",
            "detach": "!=null"
        }
    }
},
{
    "kprobe:otx2_detach_resources": {
        "description": "Detach resources",
        "pre": {
            "mbox": "!=null"
        },
        "post": {
            "detach->partial": "==false"
        }
    }
},
S,
S,
{
    "kretprobe:otx2_config_pause_frm": {
        "description": "Use max receive length supported by hardware for loopback devices",
        "pre": {
            "is_otx2_lbkvf(pfvf->pdev)": true,
            "req->maxlen": "maxlen",
            "otx2_sync_mbox_msg(&pfvf->mbox)": "err",
            "mutex_unlock(&pfvf->mbox.lock)": true
        }
    }
},
{
    "kprobe:otx2_config_pause_frm": {
        "description": "Configure pause frame for OTX2 NIC.",
        "pre": {
            "is_otx2_lbkvf(pfvf->pdev)": true,
            "req->maxlen": "maxlen",
            "otx2_sync_mbox_msg(&pfvf->mbox)": "err",
            "mutex_unlock(&pfvf->mbox.lock)": true
        }
    }
},
{
    "kretprobe:pfvf->tot_lmt_lines": {
        "description": "Assigns the value of (num_online_cpus() * LMT_BURST_SIZE) to pfvf->tot_lmt_lines.",
        "pre": {
            "pfvf": "!=null",
            "num_online_cpus()": ">= 0",
            "LMT_BURST_SIZE": ">= 0"
        }
    },
    "kretprobe:pfvf->hw.lmt_info": {
        "description": "Allocates memory for struct otx2_lmt_info and assigns it to pfvf->hw.lmt_info.",
        "pre": {
            "pfvf": "!=null",
            "alloc_percpu(struct otx2_lmt_info)": "!=null"
        }
    },
    "kretprobe:mutex_lock(&pfvf->mbox.lock)": {
        "description": "Locks the mutex pfvf->mbox.lock.",
        "pre": {
            "pfvf": "!=null",
            "mutex_lock(&pfvf->mbox.lock)": "success"
        }
    },
    "kretprobe:req = otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": {
        "description": "Allocates memory for struct lmtst_tbl_setup_req and assigns it to req.",
        "pre": {
            "pfvf": "!=null",
            "otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": "!=null"
        }
    },
    "kretprobe:!req": {
        "description": "Checks if req is null.",
        "pre": {
            "req": "==null"
        }
    }
},
{
    "kprobe:pfvf->tot_lmt_lines": {
        "description": "Assign the value of (num_online_cpus() * LMT_BURST_SIZE) to pfvf->tot_lmt_lines.",
        "pre": {
            "pfvf": "!=null",
            "num_online_cpus()": "!=null",
            "LMT_BURST_SIZE": "!=null"
        }
    },
    "kprobe:pfvf->hw.lmt_info": {
        "description": "Allocate memory for struct otx2_lmt_info and assign it to pfvf->hw.lmt_info.",
        "pre": {
            "pfvf": "!=null",
            "alloc_percpu(struct otx2_lmt_info)": "!=null"
        }
    },
    "kprobe:mutex_lock(&pfvf->mbox.lock)": {
        "description": "Lock the mutex pfvf->mbox.lock.",
        "pre": {
            "pfvf": "!=null",
            "pfvf->mbox.lock": "!=null"
        }
    },
    "kprobe:req = otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": {
        "description": "Allocate memory for struct lmtst_tbl_setup_req and assign it to req.",
        "pre": {
            "req": "!=null",
            "otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": "!=null"
        }
    },
    "kprobe:!req": {
        "description": "Check if req is not null.",
        "pre": {
            "req": "==null"
        }
    }
},
{
    "kretprobe:otx2_free_ntuple_mcam_entries": {
        "description": "Free current ntuple mcam entries and allocate new ones with requested count.",
        "pre": {
            "pfvf": "!=null",
            "count": "!=0",
            "flow_cfg": "!=null",
            "req": "!=null",
            "rsp": "!=null",
            "ent": ">=0",
            "allocated": ">=0"
        }
    }
},
{
    "kprobe:otx2_free_ntuple_mcam_entries": {
        "description": "Free current ntuple mcam entries and allocate new ones with requested count.",
        "pre": {
            "pfvf": "!=null",
            "count": "!=0",
            "flow_cfg": "!=null",
            "flow_cfg.flow_ent": "==null"
        }
    }
},
{
    "kretprobe:otx2_sq_append_skb": {
        "description": "Check if there is enough room between producer and consumer index.",
        "pre": {
            "netdev": "!=null",
            "sq": "!=null",
            "skb": "!=null",
            "qidx": "!=null",
            "txq": "!=null",
            "pfvf": "!=null",
            "offset": "!=null",
            "num_segs": "!=null",
            "free_desc": "!=null",
            "sqe_hdr": "!=null",
            "sq->cons_head": "!=null",
            "sq->head": "!=null",
            "sq->sqe_cnt": "!=null",
            "sq->sqe_thresh": "!=null",
            "otx2_get_sqe_count(pfvf, skb)": "!=null",
            "skb_shinfo(skb)->nr_frags": "!=null"
        },
        "post": {
            "free_desc": "<= (sq->sqe_cnt - 1)",
            "free_desc": ">= sq->sqe_thresh",
            "free_desc": ">= otx2_get_sqe_count(pfvf, skb)",
            "num_segs": "= (skb_shinfo(skb)->nr_frags + 1)"
        }
    }
},
{
    "kprobe:otx2_sq_append_skb": {
        "description": "Check if there is enough room between producer and consumer index.",
        "pre": {
            "netdev": "!=null",
            "sq": "!=null",
            "skb": "!=null",
            "qidx": "!=null",
            "free_desc": "(sq->cons_head - sq->head - 1 + sq->sqe_cnt) & (sq->sqe_cnt - 1)",
            "sqe_thresh": "!=null",
            "otx2_get_sqe_count(pfvf, skb)": "!=null",
            "num_segs": "skb_shinfo(skb)->nr_frags + 1"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Free the memory allocated for tc_entries_bitmap.",
        "pre": {
            "tc": {
                "tc_entries_bitmap": "!=null"
            }
        }
    },
    "kretprobe:kcalloc": {
        "description": "Allocate memory for tc_entries_bitmap using kcalloc.",
        "pre": {
            "nic": {
                "flow_cfg": {
                    "max_flows": "!=0"
                }
            }
        }
    }
},
{
    "kprobe:kfree": {
        "description": "Free the memory allocated for tc_entries_bitmap.",
        "pre": {
            "tc->tc_entries_bitmap": "==null"
        }
    },
    "kprobe:kcalloc": {
        "description": "Allocate memory for tc_entries_bitmap.",
        "pre": {
            "nic->flow_cfg->max_flows": "!=0",
            "tc->tc_entries_bitmap": "==null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:otx2_write64": {
        "description": "Write a 64-bit value to the specified address.",
        "pre": {
            "pf": "!=null",
            "RVU_PF_VFME_INT_ENA_W1CX(0)": "!=null",
            "INTR_MASK(vfs)": "!=null"
        }
    },
    "kretprobe:pci_irq_vector": {
        "description": "Get the IRQ vector for the specified device.",
        "pre": {
            "pf->pdev": "!=null",
            "RVU_PF_INT_VEC_VFME0": "!=null"
        }
    },
    "kretprobe:free_irq": {
        "description": "Free the specified IRQ.",
        "pre": {
            "irq": "!=null",
            "pf": "!=null"
        }
    }
},
S,
{
    "kretprobe:u16 htb_maj_id = smp_load_acquire(&pf->qos.maj_id);if (unlikely(htb_maj_id))": {
        "description": "Load the value of `pf->qos.maj_id` into `htb_maj_id` and check if it is non-zero.",
        "pre": {
            "pf": "!=null",
            "pf->qos.maj_id": "!=null",
            "htb_maj_id": "!=0"
        }
    }
},
{
    "kprobe:u16 htb_maj_id = smp_load_acquire(&pf->qos.maj_id);if (unlikely(htb_maj_id))": {
        "description": "Load the value of `pf->qos.maj_id` into `htb_maj_id` using `smp_load_acquire` and check if it is non-zero.",
        "pre": {
            "pf": "!=null",
            "pf->qos.maj_id": "!=null",
            "htb_maj_id": "!=0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:otx2_mbox_msg_send": {
        "description": "Send a message through the OTX2 mailbox.",
        "pre": {
            "mbox": "!=null",
            "devid": "int",
            "mdev": "!=null",
            "hw_mbase": "!=null",
            "tx_hdr": "!=null",
            "rx_hdr": "!=null",
            "msgs_offset": "int",
            "mdev->mbase": "!=null",
            "mbox->tx_start": "int",
            "mdev->msg_size": "!=null",
            "mdev->mbase + mbox->tx_start + msgs_offset": "!=null",
            "hw_mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->msg_size": "!=null",
            "mdev->msg_size": "int",
            "mdev->mbox_lock": "spin_lock"
        },
        "post": {
            "tx_hdr->msg_size": "mdev->msg_size"
        }
    }
},
{
    "kprobe:otx2_mbox_msg_send": {
        "description": "Send a message through the OTX2 mailbox.",
        "pre": {
            "mbox": "!=null",
            "devid": "!=null",
            "mdev": "!=null",
            "hw_mbase": "!=null",
            "tx_hdr": "!=null",
            "rx_hdr": "!=null",
            "msgs_offset": "!=null",
            "mdev->mbase": "!=null",
            "hw_mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->msg_size": "!=null",
            "mdev->mbase": "!=hw_mbase",
            "memcpy(hw_mbase + mbox->tx_start + msgs_offset, mdev->mbase + mbox->tx_start + msgs_offset, mdev->msg_size)": "valid",
            "spin_lock(&mdev->mbox_lock)": "valid",
            "tx_hdr->msg_size": "mdev->msg_size",
            "bounce_buffer": "not implemented"
        }
    }
},
S,
{
    "kprobe:otx2_mbox_alloc_msg_rsp": {
        "description": "Check if there is space in mailbox",
        "pre": {
            "mbox": "!=null",
            "devid": "!=null",
            "size": "!=null",
            "size_rsp": "!=null",
            "mdev": "!=null",
            "msghdr": "null",
            "mbox_lock": "locked"
        },
        "post": {
            "msghdr": "!=null"
        },
        "goto": {
            "exit": {
                "conditions": [
                    "(mdev->msg_size + size) > mbox->tx_size - msgs_offset",
                    "(mdev->rsp_size + size_rsp) > mbox->rx_size - msgs_offset",
                    "mdev->msg_size == 0"
                ]
            }
        }
    }
},
{
    "kretprobe:ocelot_match_all_as_mac_etype": {
        "description": "Matches on MAC_ETYPE keys such as destination and source MAC on this ingress port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "lookup": "!=null",
            "on": "!=null"
        }
    }
},
{
    "kprobe:ocelot_match_all_as_mac_etype": {
        "description": "Matches on MAC_ETYPE keys such as destination and source MAC on this ingress port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "lookup": "!=null",
            "on": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_disable_reservation_watermarks": {
        "description": "Disable reservation watermarks for the ocelot device on a specific port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:ocelot_disable_reservation_watermarks": {
        "description": "Disable reservation watermarks for the ocelot device on the specified port.",
        "pre": {
            "ocelot": "!=null",
            "port": ">=0"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:ocelot_ptp_gettime64": {
        "description": "Get the current time from the Ocelot PTP clock.",
        "pre": {
            "ns": {
                "type": "int",
                "range": {
                    "min": "0x3ffffff0",
                    "max": "0x3fffffff"
                }
            }
        }
    }
},
{
    "kprobe:ocelot_ptp_gettime64": {
        "description": "Get the current time from the Ocelot PTP clock.",
        "pre": {
            "ns": ">=0x3ffffff0",
            "ns": "<=0x3fffffff"
        }
    }
},
{
    "kretprobe:ocelot_ptp_adjtime": {
        "description": "Adjust the time of the PTP clock on the Ocelot device.",
        "pre": {
            "ptp": "!=null",
            "delta": ">= -(NSEC_PER_SEC * 2) && <= (NSEC_PER_SEC * 2)"
        }
    }
},
{
    "kprobe:ocelot_ptp_adjtime": {
        "description": "Adjust the time of the PTP clock.",
        "pre": {
            "ptp": "!=null",
            "delta": "delta > -(NSEC_PER_SEC * 2) && delta < (NSEC_PER_SEC * 2)"
        }
    }
},
{
    "kretprobe:ocelot_ptp_adjfine": {
        "description": "Check if the adjustment value is greater than or equal to (1L << 30).",
        "pre": {
            "adj": ">= (1L << 30)"
        }
    }
},
{
    "kprobe:ocelot_ptp_adjfine": {
        "description": "Check if the adjustment value is greater than or equal to (1L << 30).",
        "pre": {
            "adj": ">= (1L << 30)"
        }
    }
},
{
    "kretprobe:ocelot_ptp_enable": {
        "description": "Enable PTP on the Ocelot switch.",
        "pre": {
            "rq->perout.flags": "& ~(PTP_PEROUT_DUTY_CYCLE | PTP_PEROUT_PHASE) == 0",
            "rq->perout.index": ">= 0",
            "rq->perout.period.sec": "== 1",
            "rq->perout.period.nsec": "== 0"
        },
        "post": {
            "return": "== -EOPNOTSUPP"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ocelot_port_txtstamp_request": {
        "description": "Check the conditions for the ocelot_port_txtstamp_request function.",
        "pre": {
            "ptp_cmd": "!=null",
            "ptp_class": "!=PTP_CLASS_NONE"
        }
    }
},
{
    "kprobe:ocelot_port_txtstamp_request": {
        "description": "Request PTP timestamping for the Ocelot port.",
        "pre": {
            "ptp_cmd": "!=null",
            "ptp_class": "!=PTP_CLASS_NONE"
        }
    }
},
{
    "kretprobe:ocelot_get_txtstamp": {
        "description": "Retrieve the ts ID and Tx port",
        "pre": {
            "val": "!=null",
            "val & SYS_PTP_STATUS_PTP_MESS_VLD": "==0",
            "val & SYS_PTP_STATUS_PTP_OVFL": "!=0"
        }
    }
},
{
    "ocelot_get_txtstamp": {
        "description": "Retrieve the ts ID and Tx port",
        "pre": {
            "val & SYS_PTP_STATUS_PTP_MESS_VLD": "== 0",
            "val & SYS_PTP_STATUS_PTP_OVFL": "!= 0"
        }
    }
},
{
    "kretprobe:ocelot_init_timestamp": {
        "description": "Initialize the timestamp for the ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "info": "!=null",
            "ptp_clock": "!=null",
            "i": ">=0",
            "ocelot->ptp_info": "!=null",
            "ocelot->ptp_pins": "!=null",
            "p->name": "string",
            "sizeof(p->name)": ">=0",
            "p->index": ">=0",
            "p->func": "in [PTP_PF_NONE, PTP_PF_OTHER]",
            "ocelot->ptp_info.pin_config": "!=null",
            "ptp_clock": "!=null",
            "IS_ERR(ptp_clock)": "false"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ocelot_init_timestamp": {
        "description": "Initialize the timestamp for the ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "info": "!=null",
            "ptp_clock": "!=null",
            "i": ">=0",
            "i": "< OCELOT_PTP_PINS_NUM",
            "p": "!=null",
            "p->name": "!=null",
            "sizeof(p->name)": ">= sizeof(char)",
            "p->index": ">=0",
            "p->func": "in [PTP_PF_NONE]",
            "ocelot->ptp_info": "!=null",
            "ocelot->ptp_info.pin_config": "!=null",
            "ptp_clock": "!=null",
            "IS_ERR(ptp_clock)": "==0",
            "PTR_ERR(ptp_clock)": "==0"
        }
    }
},
{
    "kretprobe:ocelot_mact_learn": {
        "description": "Set MAC_CPU_COPY if the CPU port is used by a multicast entry",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mac": "!=null",
            "vid": "!=null",
            "type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]"
        },
        "post": {
            "cmd": "& ANA_TABLES_MACACCESS_MAC_CPU_COPY != 0",
            "mc_ports": "& BIT(ocelot->num_phys_ports) != 0"
        }
    }
},
{
    "kprobe:ocelot_mact_learn": {
        "description": "Set MAC_CPU_COPY if the CPU port is used by a multicast entry",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mac": "!=null",
            "vid": "!=null",
            "type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]"
        }
    }
},
{
    "kretprobe:ocelot_write": {
        "description": "Issue a forget command",
        "pre": {
            "ocelot": "!=null",
            "mac": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kprobe:ocelot_write": {
        "description": "Issue a forget command",
        "pre": {
            "ocelot": "!=null",
            "mac": "!=null",
            "vid": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:ocelot_vlan_add": {
        "description": "Add a VLAN to the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "vid": "!=0",
            "pvid": "bool",
            "untagged": "bool"
        }
    }
},
{
    "kprobe:ocelot_vlan_member_add": {
        "description": "Add a VLAN member to the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "vid": "!=null",
            "untagged": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_port_set_pvid": {
        "description": "Set the Port VLAN ID (PVID) for the specified port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "NULL": "true"
        }
    }
},
{
    "kprobe:ocelot_port_set_pvid": {
        "description": "Set the PVID (Port VLAN ID) for a specific port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "NULL": "==null"
        }
    }
},
{
    "kretprobe:ocelot_rx_frame_word": {
        "description": "Read the FCS",
        "pre": {
            "ocelot": "!=null",
            "grp": "!=null",
            "false": "!=null",
            "&val": "!=null"
        }
    }
},
{
    "kprobe:ocelot_rx_frame_word": {
        "description": "Read a word from the frame buffer.",
        "pre": {
            "ocelot": "!=null",
            "grp": "is an integer",
            "false": "is a boolean value",
            "&val": "!=null"
        }
    }
},
S,
{
    "ocelot_port_inject_frame": {
        "description": "Inject a frame into the Ocelot switch port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "grp": "!=null",
            "rew_op": "!=null",
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ocelot_set_ageing_time": {
        "description": "Set the ageing time for the ocelot structure.",
        "pre": {
            "ocelot": "!=null",
            "msecs": "!=null",
            "age_period": "!=null",
            "age_period": "!=0"
        }
    }
},
{
    "kprobe:ocelot_set_ageing_time": {
        "description": "Set the ageing time for the Ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "msecs": "!=null",
            "age_period": "!=null",
            "age_period": "!=0"
        }
    }
},
{
    "kretprobe:ocelot_port_mdb_add": {
        "description": "Add a multicast database entry to the Ocelot switch port.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": "!=null",
            "bridge": "!=null",
            "mdb->addr": "!=null",
            "mdb->vid": "int",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "int",
            "ocelot_multicast_get(ocelot, mdb->addr, vid)": "!=null"
        }
    }
},
{
    "kprobe:ocelot_port_mdb_add": {
        "description": "Add a multicast database entry for a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": {
                "addr": "!=null",
                "vid": "int"
            },
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_port_mdb_del": {
        "description": "Delete a multicast database entry associated with a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": "!=null",
            "bridge": "!=null",
            "addr": "array of unsigned char with length ETH_ALEN",
            "mc": "struct ocelot_multicast",
            "pgid": "struct ocelot_pgid",
            "vid": "u16",
            "mc != null": true,
            "mc->entry_type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "u16",
            "ocelot_multicast_get(ocelot, mdb->addr, vid)": "!=null",
            "ocelot_encode_ports_to_mdb(addr, mc)": "void",
            "ocelot_mact_forget(ocelot, addr, vid)": "void",
            "ocelot_pgid_free(ocelot, mc->pgid)": "void",
            "mc->ports &= ~BIT(port)": "void",
            "mc->ports": "!=0",
            "list_del(&mc->list)": "void",
            "devm_kfree(ocelot->dev, mc)": "void",
            "return": "int"
        }
    }
},
{
    "kprobe:ocelot_port_mdb_del": {
        "description": "Delete a multicast database entry associated with a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mdb": "!=null",
            "bridge": "!=null",
            "addr": "array of size ETH_ALEN",
            "mc": "!=null",
            "pgid": "!=null",
            "vid": "int",
            "mc != null": true,
            "mc->entry_type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "int",
            "mc->pgid->ports": "!=null",
            "mc->pgid->index": "!=null"
        },
        "post": {
            "return value": "int",
            "ocelot_mact_learn(ocelot, pgid->index, addr, vid, mc->entry_type)": "int"
        }
    }
},
S,
S,
{
    "kretprobe:ocelot_fields_write": {
        "description": "Set Pause watermark hysteresis",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "field": "in [SYS_PAUSE_CFG_PAUSE_START, SYS_PAUSE_CFG_PAUSE_STOP]",
            "value": "!=null"
        }
    }
},
{
    "kprobe:ocelot_fields_write": {
        "description": "Write ocelot fields",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "field": "in [SYS_PAUSE_CFG_PAUSE_START, SYS_PAUSE_CFG_PAUSE_STOP]",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_init_port": {
        "description": "Set MAC IFG Gaps",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "ocelot_port": "!=null",
            "ocelot_port->tx_skbs": "!=null",
            "TX_IFG": "==5",
            "FDX": "in [true, false]",
            "RX_IFG1": "if FDX == true then ==0 else ==5",
            "RX_IFG2": "if FDX == true then ==0 else ==5"
        }
    }
},
S,
{
    "kretprobe:ocelot_reset": {
        "description": "Reset the ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "err": "int",
            "val": "u32",
            "ocelot->regfields[SYS_RESET_CFG_MEM_INIT]": "1",
            "ocelot->regfields[SYS_RESET_CFG_MEM_ENA]": "1"
        },
        "post": {
            "err": "int",
            "val": "!val",
            "ocelot->regfields[SYS_RESET_CFG_CORE_ENA]": "1"
        }
    }
},
{
    "kprobe:ocelot_reset": {
        "description": "Reset the Ocelot switch core.",
        "pre": {
            "ocelot": "!=null",
            "ocelot->regfields[SYS_RESET_CFG_MEM_INIT]": "1",
            "ocelot->regfields[SYS_RESET_CFG_MEM_ENA]": "1",
            "ocelot->regfields[SYS_RESET_CFG_CORE_ENA]": "1"
        }
    }
},
{
    "kretprobe:ocelot_mrp_trap_add": {
        "description": "Add a trap for MRP in Ocelot.",
        "pre": {
            "filter": "!=null",
            "filter->key.etype.dmac.value": "!=null",
            "mrp_test_dmac": "!=null",
            "filter->key.etype.dmac.mask": "!=null",
            "mrp_mask": "!=null"
        }
    }
},
{
    "kprobe:ocelot_mrp_trap_add": {
        "description": "Add a trap for MRP (Multiple Registration Protocol) on the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "filter->key.etype.dmac.value": "!=null",
            "filter->key.etype.dmac.mask": "!=null",
            "filter->key.etype.dmac.mask[5]": "==0x00"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:stats->rx_bytes": {
        "description": "Assign the value of s[OCELOT_STAT_RX_OCTETS] to stats->rx_bytes.",
        "pre": {
            "stats": "!=null",
            "s[OCELOT_STAT_RX_OCTETS]": "!=null"
        }
    }
},
{
    "kprobe:stats->rx_bytes": {
        "description": "Get Rx stats",
        "pre": {
            "stats": "!=null",
            "ocelot": "!=null",
            "port": ">=0",
            "s": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:xcv_setup_link": {
        "description": "Set operating speed and reset datapaths.",
        "pre": {
            "xcv": "!=null",
            "link_speed": "in [100, 10]",
            "link_up": "==true"
        }
    }
},
{
    "kprobe:xcv_setup_link": {
        "description": "Set up the link configuration.",
        "pre": {
            "link_up": "in [true, false]",
            "link_speed": "in [10, 100]",
            "speed": "in [0, 1] when link_speed == 10 or link_speed == 100"
        }
    }
},
{
    "kretprobe:bgx_set_dmac_cam_filter_mac": {
        "description": "Configure DCAM filtering for designated LMAC",
        "pre": {
            "cam_dmac": "!=0",
            "bgx": "!=null",
            "lmacid": ">=0",
            "idx": ">=0"
        }
    }
},
S,
{
    "kretprobe:bgx_set_xcast_mode": {
        "description": "Set the filtering mode for the given bgx, lmac, and mode.",
        "pre": {
            "node": "!=null",
            "bgx_idx": "!=null",
            "lmacid": "!=null",
            "mode": "!=null",
            "cfg": "!=null",
            "cfg": "&= ~(CAM_ACCEPT | BGX_MCAST_MODE(MCAST_MODE_MASK))",
            "cfg": "updated with appropriate filtering mode"
        }
    }
},
{
    "kprobe:cfg &= ~(CAM_ACCEPT | BGX_MCAST_MODE(MCAST_MODE_MASK))": {
        "description": "Check requested bits and set filtering mode appropriately.",
        "pre": {
            "cfg": "!=null",
            "CAM_ACCEPT": "!=null",
            "BGX_MCAST_MODE(MCAST_MODE_MASK)": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:iavf_register_client": {
        "description": "Register a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:iavf_register_client": {
        "description": "Register a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:iavf_unregister_client": {
        "description": "Unregister a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:iavf_unregister_client": {
        "description": "Unregister a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:neigh_event_send": {
        "description": "Send a neighbor event.",
        "pre": {
            "e->neigh": "!=null",
            "e->lock": "!=null",
            "e->state": "==L2T_STATE_STALE"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:alloc_l2e": {
        "description": "Allocate a new entry for l2t_data.",
        "pre": {
            "d": "!=null"
        }
    }
},
{
    "e = alloc_l2e(d); if (e)": {
        "description": "Allocate a new entry",
        "pre": {
            "d": "!=null",
            "neigh": "!=null",
            "physdev": "!=null",
            "priority": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_register_client": {
        "description": "Register an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_register_client": {
        "description": "Register an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_unregister_client": {
        "description": "Unregister an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_unregister_client": {
        "description": "Unregister an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_queue_tid_release": {
        "description": "Release a TID in the cxgb3 queue.",
        "pre": {
            "tdev": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_queue_tid_release": {
        "description": "Release a TID in the cxgb3 queue.",
        "pre": {
            "tdev": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kretprobe:ppm_get_cpu_entries": {
        "description": "Try to get the CPU entries from the general pool.",
        "pre": {
            "ppm": "!=null",
            "npods": ">0",
            "caller_data": "!=null"
        }
    }
},
{
    "kprobe:ppm_get_cpu_entries": {
        "description": "Try to get the index from the general pool.",
        "pre": {
            "ppm": "!=null",
            "npods": ">0",
            "caller_data": "!=null"
        }
    }
},
{
    "kretprobe:cxgbi_ppm_make_ppod_hdr": {
        "description": "Generate pagepod header for cxgbi_ppm.",
        "pre": {
            "ppm": "!=null",
            "tag": "&= 0x3FFFFFFF",
            "tid": "!=null",
            "offset": "!=null",
            "length": "!=null",
            "hdr": "!=null",
            "hdr.ddp_tag": "&= 0xC0000000",
            "hdr.ddp_tag_wire": "&!= 0xC0000000"
        }
    }
},
{
    "kprobe:cxgbi_ppm_make_ppod_hdr": {
        "description": "The ddp tag in pagepod should be with bit 31:30 set to 0. The ddp Tag on the wire should be with non-zero 31:30 to the peer",
        "pre": {
            "ppm": "!=null",
            "tag": "&= 0x3FFFFFFF",
            "tid": "!=null",
            "offset": "!=null",
            "length": "!=null",
            "hdr": "!=null",
            "hdr.vld_tid": "htonl(PPOD_VALID_FLAG | PPOD_TID(tid))",
            "hdr.rsvd": "0",
            "hdr.pgsz_tag_clr": "htonl(tag & ppm.tformat.idx_clr_mask)",
            "hdr.max_offset": "htonl(length)",
            "hdr.page_offset": "htonl(offset)"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_get_srq_entry": {
        "description": "Read the SRQ table entry",
        "pre": {
            "dev": "!=null",
            "srq_idx": "!=null",
            "entryp": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_get_srq_entry": {
        "description": "Read the SRQ table entry",
        "pre": {
            "dev": "!=null",
            "srq_idx": "!=null",
            "entryp": "!=null"
        }
    }
},
{
    "kretprobe:neigh_event_send": {
        "description": "Send a packet on the fast-path if the l2t_entry state is valid or update the state if it is stale.",
        "pre": {
            "e->neigh": "!=null",
            "e->state": "==L2T_STATE_STALE",
            "e->lock": "!=null"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
{
    "kprobe:neigh_event_send": {
        "description": "Send a neighbor event",
        "pre": {
            "e->neigh": "!=null",
            "e->lock": "!=null",
            "e->state": "==L2T_STATE_STALE"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_l2t_alloc_switching": {
        "description": "Allocates an L2T entry for switch filters",
        "pre": {
            "dev": "!=null",
            "vlan": "!=null",
            "port": "!=null",
            "dmac": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_l2t_alloc_switching": {
        "description": "Allocates an L2T entry for switch filters",
        "pre": {
            "dev": "!=null",
            "vlan": "!=null",
            "port": "!=null",
            "dmac": "!=null"
        }
    }
},
S,
{
    "kprobe:cxgb4_alloc_stid": {
        "description": "Allocate a stid for the given tid_info structure.",
        "pre": {
            "t": "!=null",
            "family": "== PF_INET6",
            "data": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_create_server": {
        "description": "Create an IP server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": "!=null",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_create_server": {
        "description": "Create an IP server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "vlan": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_create_server6": {
        "description": "Create an IPv6 server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_create_server6": {
        "description": "Create an IPv6 server",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_best_mtu": {
        "description": "Find the entry in the MTU table closest to an MTU.",
        "pre": {
            "mtus": "!=null",
            "mtu": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_best_mtu": {
        "description": "Find the entry in the MTU table closest to an MTU.",
        "pre": {
            "mtus": "!=null",
            "mtu": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_best_aligned_mtu": {
        "description": "Find the best MTU with data size alignment",
        "pre": {
            "mtus": "!=null",
            "header_size": "!=null",
            "data_size_max": "!=null",
            "data_size_align": "!=null",
            "mtu_idxp": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_best_aligned_mtu": {
        "description": "Find the best MTU with data size alignment",
        "pre": {
            "mtus": "!=null",
            "header_size": "!=null",
            "data_size_max": "!=null",
            "data_size_align": "!=null",
            "mtu_idxp": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_chan": {
        "description": "Get the HW channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_chan": {
        "description": "Get the HW channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_e2cchan": {
        "description": "get the HW c-channel of a port",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "is an unsigned integer"
        }
    }
},
{
    "kprobe:cxgb4_port_e2cchan": {
        "description": "Get the HW c-channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_viid": {
        "description": "Get the VI id of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_viid": {
        "description": "Get the VI id of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_idx": {
        "description": "Get the index of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_idx": {
        "description": "Get the index of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:size = t4_read_reg(adap, MA_EDRAM0_BAR_A);edc0_size = EDRAM0_SIZE_G(size) << 20;size = t4_read_reg(adap, MA_EDRAM1_BAR_A);edc1_size = EDRAM1_SIZE_G(size) << 20;size = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);mc0_size = EXT_MEM0_SIZE_G(size) << 20;if (t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F)": {
        "description": "Calculate the sizes of various memory regions based on register values.",
        "pre": {
            "adap": "!=null",
            "size": "!=null",
            "edc0_size": ">= 0",
            "edc1_size": ">= 0",
            "mc0_size": ">= 0",
            "t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A)": "!=null"
        }
    }
},
{
    "kprobe:function_name": {
        "description": "Description of the function",
        "pre": {
            "adap": "!=null",
            "size": "!=null",
            "edc0_size": "!=null",
            "edc1_size": "!=null",
            "mc0_size": "!=null",
            "t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F": "!=0"
        }
    }
},
{
    "kretprobe:cxgb4_create_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "dev": "!=null",
            "stid": "stid - adap->tids.sftid_base + adap->tids.nftids",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null",
            "port": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_create_server_filter": {
        "description": "Create a server filter on the cxgb4 network device.",
        "pre": {
            "dev": "!=null",
            "stid": "!=null",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null",
            "port": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_remove_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "dev": "!=null",
            "stid": "-= adap->tids.sftid_base; stid += adap->tids.nftids;",
            "queue": "!=null",
            "ipv6": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_remove_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "stid": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_register_uld": {
        "description": "Register an upper-layer driver",
        "pre": {
            "type": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_register_uld": {
        "description": "Register an upper-layer driver",
        "pre": {
            "type": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_unregister_uld": {
        "description": "Unregister an upper-layer driver.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_unregister_uld": {
        "description": "Unregister an upper-layer driver.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_reclaim_completed_tx": {
        "description": "Reclaims completed Tx descriptors",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "unmap": "in [true, false]"
        }
    }
},
{
    "kprobe:cxgb4_reclaim_completed_tx": {
        "description": "Reclaims completed Tx descriptors",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "unmap": "in [true, false]"
        }
    }
},
{
    "kretprobe:cxgb4_write_sgl": {
        "description": "Populate a scattergather list for a packet.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "start": ">=0",
            "addr": "!=null",
            "sgl_alignment": "16-byte aligned",
            "sgl_within_tx_descriptor": "within a Tx descriptor with available space",
            "end_greater_than_sgl": "end > sgl"
        }
    }
},
{
    "kprobe:cxgb4_write_sgl": {
        "description": "Populate a scattergather list for a packet.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "sgl_alignment": "16-byte aligned",
            "end": "!=null",
            "start": "unsigned int",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_write_partial_sgl": {
        "description": "Populate SGL for partial packet",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "addr": "!=null",
            "start": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_write_partial_sgl": {
        "description": "Populate SGL for partial packet",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "addr": "!=null",
            "start": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_ring_tx_db": {
        "description": "Check and potentially ring a Tx queue's doorbell.",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_ring_tx_db": {
        "description": "Check and potentially ring a Tx queue's doorbell.",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_inline_tx_skb": {
        "description": "Inline a packet's data into Tx descriptors.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_inline_tx_skb": {
        "description": "Inline a packet's data into Tx descriptors.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_ofld_send": {
        "description": "Sends an offload packet.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_ofld_send": {
        "description": "Sends an offload packet.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_crypto_send": {
        "description": "Send crypto packet",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_crypto_send": {
        "description": "Send crypto packet",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_pktgl_to_skb": {
        "description": "Build an sk_buff from a packet gather list.",
        "pre": {
            "gl": "!=null",
            "skb_len": ">=0",
            "pull_len": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_pktgl_to_skb": {
        "description": "Build an sk_buff from a packet gather list",
        "pre": {
            "gl": "!=null",
            "skb_len": ">=0",
            "pull_len": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_update_dev_clip": {
        "description": "Update the device clip for cxgb4 devices.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_update_dev_clip": {
        "description": "Update the device clip for cxgb4 devices.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_smt_release": {
        "description": "Release SMT entry",
        "pre": {
            "e": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_smt_release": {
        "description": "Release SMT entry",
        "pre": {
            "e": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_smt_alloc_switching": {
        "description": "Allocates an SMT entry for switch filters.",
        "pre": {
            "dev": "!=null",
            "smac": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
S,
{
    "kretprobe:fman_port_config": {
        "description": "Creates a descriptor for the FM PORT module.",
        "pre": {
            "port": "!=null",
            "params": "!=null"
        }
    }
},
{
    "kprobe:fman_port_config": {
        "description": "Creates a descriptor for the FM PORT module.",
        "pre": {
            "port": "!=null",
            "params": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_use_kg_hash": {
        "description": "Sets the HW KeyGen or the BMI as HW Parser next engine, enabling or bypassing the KeyGen hashing of Rx traffic.",
        "pre": {
            "port": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:fman_port_use_kg_hash": {
        "description": "Sets the HW KeyGen or the BMI as HW Parser next engine, enabling or bypassing the KeyGen hashing of Rx traffic.",
        "pre": {
            "port": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:fman_port_init": {
        "description": "Initializes the FM PORT module by defining the software structure and configuring the hardware registers.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_init": {
        "description": "Initializes the FM PORT module by defining the software structure and configuring the hardware registers.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_cfg_buf_prefix_content": {
        "description": "Configures the buffer prefix content for a FM Port module.",
        "pre": {
            "port": "!=null",
            "buffer_prefix_content": "!=null"
        },
        "post": {
            "return": "in [0, error code]"
        }
    }
},
{
    "kprobe:fman_port_cfg_buf_prefix_content": {
        "description": "Configures the buffer prefix content for the FM Port module.",
        "pre": {
            "port": "!=null",
            "buffer_prefix_content": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_disable": {
        "description": "Gracefully disable an FM port. The port will not start new tasks after all tasks associated with the port are terminated.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_disable": {
        "description": "Gracefully disable an FM port. The port will not start new tasks after all tasks associated with the port are terminated.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_enable": {
        "description": "A runtime routine provided to allow disable/enable of port.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_enable": {
        "description": "A runtime routine provided to allow disable/enable of port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_bind": {
        "description": "Bind to a specific FMan Port. Allowed only after the port was created.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:fman_port_bind": {
        "description": "Bind to a specific FMan Port. Allowed only after the port was created.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_get_qman_channel_id": {
        "description": "Get the QMan channel ID for the specific port",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:fman_port_get_qman_channel_id": {
        "description": "Get the QMan channel ID for the specific port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_get_device": {
        "description": "Get the 'struct device' associated to the specified FMan port device",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:fman_port_get_device": {
        "description": "Get the 'struct device' associated to the specified FMan port device",
        "pre": {
            "port": "!=null"
        }
    }
},
S,
S,
S,
{
    "fman_sp_build_buffer_struct": {
        "description": "Translate margin and int_context params to FM parameters",
        "pre": {
            "int_context_data_copy": {
                "ext_buf_offset": {
                    "type": "u16",
                    "condition": "(buffer_prefix_content->priv_data_size & (OFFSET_UNITS - 1)) ? ((buffer_prefix_content->priv_data_size + OFFSET_UNITS) & ~(u16)(OFFSET_UNITS - 1)) : buffer_prefix_content->priv_data_size"
                }
            }
        }
    }
},
{
    "kretprobe:keygen_init": {
        "description": "KeyGen initialization: Initializes and enables KeyGen, allocate driver memory, setup registers, clear port bindings, invalidate all schemes",
        "pre": {
            "keygen_regs": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:keygen_init": {
        "description": "KeyGen initialization: Initializes and enables KeyGen, allocate driver memory, setup registers, clear port bindings, invalidate all schemes",
        "pre": {
            "keygen_regs": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:keygen_port_hashing_init": {
        "description": "Initializes a port for Rx Hashing with specified configuration parameters",
        "pre": {
            "keygen": "!=null",
            "hw_port_id": "!=null",
            "hash_base_fqid": "!=null",
            "hash_size": "!=null"
        }
    }
},
{
    "kprobe:keygen_port_hashing_init": {
        "description": "Initializes a port for Rx Hashing with specified configuration parameters",
        "pre": {
            "keygen": "!=null",
            "hw_port_id": "!=null",
            "hash_base_fqid": "!=null",
            "hash_size": "!=null"
        }
    }
},
{
    "kretprobe:fman_register_intr": {
        "description": "Used to register an event handler to be processed by FMan",
        "pre": {
            "fman": "!=null",
            "module": "in [CALLING_MODULE_1, CALLING_MODULE_2, ...]",
            "mod_id": ">=0",
            "intr_type": "in [ERROR, NORMAL]",
            "isr_cb": "!=null",
            "src_arg": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_register_intr": {
        "description": "Used to register an event handler to be processed by FMan",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]",
            "isr_cb": "!=null",
            "src_arg": "!=null"
        }
    }
},
{
    "kretprobe:fman_unregister_intr": {
        "description": "Unregister an event handler to be processed by FMan.",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]"
        },
        "post": {
            "return": "in [0, Error code]"
        }
    }
},
{
    "kprobe:fman_unregister_intr": {
        "description": "Unregister an event handler to be processed by FMan.",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]"
        },
        "post": {
            "return": "in [0, Error code]"
        }
    }
},
{
    "kretprobe:fman_set_port_params": {
        "description": "Set port parameters for FMan device.",
        "pre": {
            "fman": "!=null",
            "port_params": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:fman_set_port_params": {
        "description": "Set port parameters for FMan device.",
        "pre": {
            "fman": "!=null",
            "port_params": "!=null"
        }
    }
},
{
    "kretprobe:fman_reset_mac": {
        "description": "Reset a specific MAC",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null"
        }
    }
},
{
    "kprobe:fman_reset_mac": {
        "description": "Reset a specific MAC",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null"
        }
    }
},
{
    "kretprobe:fman_set_mac_max_frame": {
        "description": "Set maximum frame length of specific MAC in FMan driver",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null",
            "mfl": "!=null"
        }
    }
},
{
    "kprobe:fman_set_mac_max_frame": {
        "description": "Set maximum frame length of specific MAC in FMan driver",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null",
            "mfl": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_bmi_max_fifo_size": {
        "description": "Get FMan maximum FIFO size",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kprobe:fman_get_bmi_max_fifo_size": {
        "description": "Get FMan maximum FIFO size",
        "pre": {
            "fman": "!=null"
        },
        "post": {
            "return": "is u32"
        }
    }
},
S,
S,
{
    "kretprobe:fman_get_qman_channel_id": {
        "description": "Get QMan channel ID associated to the Port id",
        "pre": {
            "fman": "!=null",
            "port_id": "!=null"
        },
        "post": {
            "return": "is an integer"
        }
    }
},
{
    "kprobe:fman_get_qman_channel_id": {
        "description": "Get QMan channel ID associated to the Port id",
        "pre": {
            "fman": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_mem_region": {
        "description": "Get FMan memory region",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kprobe:fman_get_mem_region": {
        "description": "Get FMan memory region",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_max_frm": {
        "description": "Return: Max frame length configured in the FM driver",
        "pre": {
            "return_value": "!=null",
            "return_value": ">=0",
            "return_value": "<=65535"
        }
    }
},
{
    "kprobe:fman_get_max_frm": {
        "description": "Return: Max frame length configured in the FM driver",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_rx_extra_headroom": {
        "description": "Return: Extra headroom size configured in the FM driver",
        "pre": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:fman_get_rx_extra_headroom": {
        "description": "Return: Extra headroom size configured in the FM driver",
        "pre": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:fman_bind": {
        "description": "Bind to a specific FMan device.",
        "pre": {
            "fm_dev": "!=null"
        }
    }
},
{
    "kprobe:fman_bind": {
        "description": "Bind to a specific FMan device.",
        "pre": {
            "fm_dev": "!=null"
        }
    }
},
{
    "kretprobe:tx_credit": {
        "description": "Internal memory allocated for transmit buffering is guaranteed but not reserved. If the total transmit allocation is not used, then the unused portion is not left idle, it can be used for receive buffering but it will be reclaimed, if required, from receive by intelligently dropping already stored receive frames in the internal memory to ensure that the transmit allocation is respected. PaTXMBAR must be set to a value larger than PaTXBCR + 2 * max_frame_size + 32 if frame preemption is not enabled, or to 2 * PaTXBCR + 2 * p_max_frame_size (pMAC maximum frame size) + 2 * np_max_frame_size (eMAC maximum frame size) + 64 if frame preemption is enabled.",
        "pre": {
            "pdev": "!=null",
            "pf_pdev": "!=null",
            "ierb": "!=null",
            "port": ">=0",
            "tx_credit": ">=roundup(1000 + ENETC_MAC_MAXFRM_SIZE / 2, 100)"
        }
    }
},
{
    "kprobe:tx_credit": {
        "description": "Internal memory allocated for transmit buffering is guaranteed but not reserved; i.e. if the total transmit allocation is not used, then the unused portion is not left idle, it can be used for receive buffering but it will be reclaimed, if required, from receive by intelligently dropping already stored receive frames in the internal memory to ensure that the transmit allocation is respected. PaTXMBAR must be set to a value larger than PaTXBCR + 2 * max_frame_size + 32 if frame preemption is not enabled, or to 2 * PaTXBCR + 2 * p_max_frame_size (pMAC maximum frame size) + 2 * np_max_frame_size (eMAC maximum frame size) + 64 if frame preemption is enabled.",
        "pre": {
            "pdev": "struct platform_device",
            "pf_pdev": "struct pci_dev",
            "ierb": "!=null",
            "port": ">=0",
            "tx_credit": ">=roundup(1000 + ENETC_MAC_MAXFRM_SIZE / 2, 100)",
            "rx_credit": "!=null",
            "tx_alloc": "!=null"
        }
    }
},
{
    "kretprobe:comp->flags |= SLF_TOSS;if ( tslots > 0 )": {
        "description": "Set SLF_TOSS flag in comp->flags and check if tslots is greater than 0.",
        "pre": {
            "comp->flags": "& SLF_TOSS != 0",
            "tslots": "> 0"
        }
    }
},
{
    "kprobe:comp->flags |= SLF_TOSS;if ( tslots > 0 )": {
        "description": "Perform a bitwise OR operation between comp->flags and SLF_TOSS, and check if tslots is greater than 0.",
        "pre": {
            "comp->flags": "|= SLF_TOSS",
            "tslots": "> 0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:if(isize<sizeof(struct iphdr))return isize;ip = (struct iphdr *) icp;if (ip->version != 4 || ip->ihl < 5)return isize;/* Bail if this packet isn't TCP, or is an IP fragment": {
        "description": "Check if the packet is TCP and not an IP fragment",
        "pre": {
            "isize": "< sizeof(struct iphdr)",
            "ip->version": "== 4",
            "ip->ihl": ">= 5"
        }
    }
},
{
    "kprobe:if(isize<sizeof(struct iphdr))return isize;ip = (struct iphdr *) icp;if (ip->version != 4 || ip->ihl < 5)return isize;/* Bail if this packet isn't TCP, or is an IP fragment `": {
        "description": "Helper function for checking packet conditions.",
        "pre": {
            "isize": "< sizeof(struct iphdr)",
            "ip->version": "== 4",
            "ip->ihl": ">= 5"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:can_eth_ioctl_hwts": {
        "description": "Handle hardware timestamping configuration for a network device.",
        "post": {
            "return": {
                "value": "in [-EFAULT, 0, -ERANGE]"
            }
        }
    }
},
{
    "kprobe:can_eth_ioctl_hwts": {
        "description": "Handle hardware timestamping configuration for Ethernet devices.",
        "pre": {
            "netdev": "!=null",
            "ifr": "!=null",
            "cmd": "in [SIOCSHWTSTAMP, SIOCGHWTSTAMP]",
            "ifr->ifr_data": "!=null",
            "sizeof(hwts_cfg)": "==sizeof(struct hwtstamp_config)",
            "copy_from_user(&hwts_cfg, ifr->ifr_data, sizeof(hwts_cfg))": "==0",
            "hwts_cfg.tx_type": "==HWTSTAMP_TX_ON",
            "hwts_cfg.rx_filter": "==HWTSTAMP_FILTER_ALL"
        },
        "post": {
            "return": "in [0, -EFAULT, -ERANGE]"
        }
    }
},
{
    "kretprobe:arc_proto_map": {
        "description": "Set the value of arc_proto_map.",
        "pre": {
            "arc_proto_map": "!=null",
            "arc_proto_map[i]": "!=null for all i in [0, 255]"
        }
    }
},
{
    "kprobe:arc_proto_map": {
        "description": "Set the arc_proto_map to the specified value.",
        "pre": {
            "arc_proto_map": "!=null",
            "arc_proto_map[i]": "!=null for all i in [0, 255]"
        }
    }
},
{
    "kretprobe:arc_proto_map": {
        "description": "Update the value of the entry associated with *key* in *arc_proto_map* with *value*.",
        "pre": {
            "arc_proto_map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "arc_proto_default": "!=null"
        }
    }
},
S,
{
    "kretprobe:snprintf": {
        "description": "Format a string and store it in a buffer.",
        "pre": {
            "hdr": "!=null",
            "sizeof(hdr)": ">=32",
            "dev->name": "!=null",
            "desc": "!=null",
            "skb->data": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kprobe:snprintf": {
        "description": "Format a string and store it in a buffer.",
        "pre": {
            "hdr": "!=null",
            "sizeof(hdr)": ">=6",
            "dev->name": "!=null",
            "desc": "!=null",
            "skb->data": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancel the work synchronization for the reset_work",
        "pre": {
            "lp": "!=null",
            "dev": "!=null"
        }
    },
    "kretprobe:free_netdev": {
        "description": "Free the network device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cancel_work_sync": {
        "description": "Cancel the specified work item synchronously.",
        "pre": {
            "work": "!=null"
        }
    },
    "kprobe:free_netdev": {
        "description": "Free the specified network device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:arcnet_interrupt": {
        "description": "Interrupt handler for ARCnet devices.",
        "pre": {
            "irq": "int",
            "dev_id": "void",
            "dev": "struct net_device",
            "lp": "struct arcnet_local",
            "recbuf": "int",
            "status": "int",
            "diagstatus": "int",
            "didsomething": "int",
            "boguscount": "int",
            "flags": "unsigned long",
            "retval": "int"
        },
        "post": {
            "retval": "in [IRQ_NONE]"
        }
    }
},
{
    "kprobe:if (!netif_running(dev))": {
        "description": "Check if the network interface is not running.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:com20020_check": {
        "description": "Enable P1Mode for backplane mode",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "!=null",
            "ioaddr": "=dev->base_addr",
            "status": "!=null",
            "lp": "!=null",
            "lp->setup": "if lp->clockm != 0 then 0 else lp->clockp << 1",
            "lp->setup2": "(lp->clockm << 4) | 8"
        },
        "post": {
            "comment": "Should we do this for SOHARD cards?"
        }
    }
},
{
    "kprobe:/* Enable P1Mode for backplane mode */": {
        "description": "Enable P1Mode for backplane mode.",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "!=null",
            "status": "!=null",
            "netdev_priv(dev)": "!=null",
            "arcnet_outb(XTOcfg(3) | RESETcfg, ioaddr, COM20020_REG_W_CONFIG)": "!=null",
            "udelay(5)": "!=null",
            "arcnet_outb(XTOcfg(3), ioaddr, COM20020_REG_W_CONFIG)": "!=null",
            "mdelay(RESETtime)": "!=null",
            "lp->setup": "!=null",
            "lp->clockm": "!=null",
            "lp->clockp": "!=null",
            "lp->setup2": "!=null",
            "CHECK: should we do this for SOHARD cards ?": "!=null"
        }
    }
},
{
    "kretprobe:lp = netdev_priv(dev);lp->hw.owner = THIS_MODULE;lp->hw.command = com20020_command;lp->hw.status = com20020_status;lp->hw.intmask = com20020_setmask;lp->hw.reset = com20020_reset;lp->hw.copy_to_card = com20020_copy_to_card;lp->hw.copy_from_card = com20020_copy_from_card;lp->hw.close = com20020_close;/* FIXME: do this some other way! `": {
        "description": "Initialize the rest of the device structure.",
        "pre": {
            "dev": "!=null",
            "shared": "!=null",
            "lp": "!=null",
            "ioaddr": "!=null"
        }
    }
},
{
    "kprobe:lp = netdev_priv(dev);lp->hw.owner = THIS_MODULE;lp->hw.command = com20020_command;lp->hw.status = com20020_status;lp->hw.intmask = com20020_setmask;lp->hw.reset = com20020_reset;lp->hw.copy_to_card = com20020_copy_to_card;lp->hw.copy_from_card = com20020_copy_from_card;lp->hw.close = com20020_close;/* FIXME: do this some other way! `": {
        "description": "Initialize the rest of the device structure.",
        "pre": {
            "dev": "!=null",
            "shared": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:hdlc_start_xmit": {
        "description": "Call hardware driver directly",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "hdlc": "!=null",
            "hdlc->proto->xmit": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->xmit": "!=null"
        }
    }
},
{
    "kprobe:hdlc_start_xmit": {
        "description": "Call hardware driver directly",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "hdlc->proto->xmit": "!=null",
            "hdlc->xmit": "!=null"
        }
    }
},
{
    "kretprobe:if (hdlc->proto->open)": {
        "description": "Check if the `open` field of the `proto` struct in `hdlc` is true.",
        "pre": {
            "hdlc": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->proto->open": "==true"
        }
    }
},
{
    "kprobe:if (hdlc->proto->open)": {
        "description": "Check if the `open` field of the `proto` struct in `hdlc` is true.",
        "pre": {
            "hdlc": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->proto->open": "==true"
        }
    }
},
{
    "hdlc_ioctl": {
        "description": "Not handled by currently attached protocol (if any)",
        "pre": {
            "dev": "!=null",
            "ifs": "!=null",
            "proto": "!=null"
        },
        "post": {
            "result": "!= -EINVAL"
        }
    }
},
S,
{
    "kretprobe:cavium_mdiobus_write_c22": {
        "description": "Write a value to a register using Clause 22 MDIO protocol.",
        "pre": {
            "bus": "!=null",
            "phy_id": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:smi_cmd.s.phy_adr = phy_id; smi_cmd.s.reg_adr = regnum; oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD); do": {
        "description": "Write data to a register using MDIO protocol",
        "pre": {
            "phy_id": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:smi_cmd.s.phy_adr = phy_id;smi_cmd.s.reg_adr = devad;oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);do": {
        "description": "Write a value to a register using the MDIO bus in Clause 45 format.",
        "pre": {
            "bus": "!=null",
            "phy_id": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null",
            "p": "!=null",
            "timeout": ">=0",
            "r": ">=0",
            "smi_wr": "!=null",
            "smi_cmd": "!=null"
        }
    }
},
{
    "kprobe:smi_cmd.s.phy_adr = phy_id; smi_cmd.s.reg_adr = devad; oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD); do": {
        "description": "Write data to a specific register in a PHY device using MDIO protocol.",
        "pre": {
            "phy_id": "!=null",
            "devad": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_mdiobus_phy_device_register": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "mdio": "!=null",
            "phy": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "rc": "== -EPROBE_DEFER || > 0"
        }
    }
},
{
    "kprobe:fwnode_mdiobus_phy_device_register": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "mdio": "!=null",
            "phy": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "rc": "== -EPROBE_DEFER || > 0"
        }
    }
},
{
    "kretprobe:fwnode_mdiobus_register_phy": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "bus": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "mii_ts": "null",
            "psec": "null",
            "is_c45": "bool",
            "phy_id": "u32",
            "rc": "int",
            "phy": "!=null",
            "is_acpi_node": "bool"
        }
    }
},
{
    "kprobe:fwnode_mdiobus_register_phy": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle.",
        "pre": {
            "bus": "!=null",
            "child": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__of_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the device tree",
        "pre": {
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__of_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the device tree",
        "pre": {
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:of_mdio_find_device": {
        "description": "Given a device tree node, find the mdio_device",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_mdio_find_device": {
        "description": "Given a device tree node, find the mdio_device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_find_device": {
        "description": "Give a PHY node, find the phy_device",
        "pre": {
            "phy_np": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:of_phy_find_device": {
        "description": "Give a PHY node, find the phy_device",
        "pre": {
            "phy_np": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_connect": {
        "description": "Connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "phy_np": "!=null",
            "hndlr": "!=null",
            "flags": "!=null",
            "iface": "!=null"
        }
    }
},
{
    "kprobe:of_phy_connect": {
        "description": "Connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "phy_np": "!=null",
            "hndlr": "!=null",
            "flags": "!=null",
            "iface": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_get_and_connect": {
        "description": "Get phy node and connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "hndlr": "!=null"
        }
    }
},
{
    "kprobe:of_phy_get_and_connect": {
        "description": "Get phy node and connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "hndlr": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_is_fixed_link": {
        "description": "Check if the given device node has a fixed link specification.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_phy_is_fixed_link": {
        "description": "Check if the PHY is a fixed link.",
        "pre": {
            "np": "!=null",
            "old_dt_binding": {
                "fixed-link": {
                    "exists": true,
                    "cells": 5
                }
            },
            "new_dt_binding": {
                "Ethernet device": {
                    "sub-node": "fixed-link"
                }
            }
        }
    }
},
{
    "kretprobe:phy_device_free": {
        "description": "Free the resources associated with the phydev.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_device_free": {
        "description": "Free the resources associated with the phydev structure.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:__acpi_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the ACPI ASL.",
        "pre": {
            "mdio": "!=null",
            "fwnode": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__acpi_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the ACPI ASL.",
        "pre": {
            "mdio": "!=null",
            "fwnode": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:vmbus_sendpacket_getid": {
        "description": "Send the specified buffer on the given channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": ">=0",
            "requestid": ">=0",
            "trans_id": "!=null",
            "type": "in [negotiate, time packet, ...]",
            "flags": "in [0, VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED]"
        }
    }
},
{
    "kprobe:vmbus_sendpacket_getid": {
        "description": "Send the specified buffer on the given channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": ">=0",
            "requestid": ">=0",
            "trans_id": "!=null",
            "type": "in [negotiate, time packet, ...]",
            "flags": "in [0, VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED]"
        }
    }
},
{
    "kretprobe:__vmbus_recvpacket": {
        "description": "Retrieve the user packet on the specified channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": "!=null",
            "buffer_actual_len": "!=null",
            "requestid": "!=null",
            "raw": "in [true, false]"
        }
    }
},
{
    "kprobe:__vmbus_recvpacket": {
        "description": "Retrieve the user packet on the specified channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": "!=null",
            "buffer_actual_len": "!=null",
            "requestid": "!=null",
            "raw": "in [true, false]"
        }
    }
},
{
    "kretprobe:of_find_all_nodes": {
        "description": "Find all nodes in the device tree starting from the given previous node.",
        "pre": {
            "prev": "!=null",
            "np": "!=null",
            "np->parent": "!=null",
            "np->sibling": "!=null"
        }
    }
},
{
    "kprobe:of_find_all_nodes": {
        "description": "Find all nodes in the device tree starting from the given previous node.",
        "pre": {
            "prev": "!=null",
            "np": "!=null",
            "prev->child": "!=null",
            "np->parent": "!=null",
            "np->sibling": "!=null"
        }
    }
},
{
    "kretprobe:of_n_addr_cells": {
        "description": "Returns the number of address cells for the given device node.",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "OF_ROOT_NODE_ADDR_CELLS_DEFAULT"
        }
    }
},
{
    "kprobe:return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;}int of_n_addr_cells(struct device_node *np)": {
        "description": "This function returns the default value for the number of address cells in the root node.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:__of_device_is_compatible": {
        "description": "Check if the node matches given constraints",
        "pre": {
            "device": "!=null",
            "compat": "in [null, '']",
            "type": "in [null, '']",
            "name": "in [null, '']"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__of_device_is_compatible": {
        "description": "Check if the node matches given constraints",
        "pre": {
            "device": "!=null",
            "compat": "in [null, '']",
            "type": "in [null, '']",
            "name": "in [null, '']"
        }
    }
},
{
    "kretprobe:of_machine_is_compatible": {
        "description": "Test root of device tree for a given compatible value",
        "pre": {
            "compat": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:of_machine_is_compatible": {
        "description": "Test root of device tree for a given compatible value",
        "pre": {
            "compat": "!=null"
        }
    }
},
{
    "kretprobe:__of_device_is_available": {
        "description": "Check if a device is available for use",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:__of_device_is_available": {
        "description": "Check if a device is available for use.",
        "pre": {
            "device": "!=null",
            "device->status": "in [null, \"okay\", \"ok\"]"
        }
    }
},
{
    "kretprobe:of_device_is_big_endian": {
        "description": "Check if a device has big-endian registers",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:of_device_is_big_endian": {
        "description": "Check if a device has big-endian registers.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:of_get_parent": {
        "description": "Get a node's parent if any",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_get_parent": {
        "description": "Get a node's parent if any",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_parent": {
        "description": "Iterate to a node's parent",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_parent": {
        "description": "Iterate to a node's parent",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_child": {
        "description": "Iterate through the child nodes of a parent node.",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_child": {
        "description": "Iterate through the child nodes of a parent node.",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_available_child": {
        "description": "Find the next available child node",
        "pre": {
            "node": "!=null",
            "prev": "!=null or ==null"
        }
    }
},
{
    "kprobe:of_get_next_available_child": {
        "description": "Find the next available child node",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_cpu_node": {
        "description": "Iterate on cpu nodes",
        "pre": {
            "prev": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_cpu_node": {
        "description": "Iterate on cpu nodes",
        "pre": {
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_compatible_child": {
        "description": "Find compatible child node",
        "pre": {
            "parent": "!=null",
            "compatible": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_compatible_child": {
        "description": "Find compatible child node",
        "pre": {
            "parent": "!=null",
            "compatible": "!=null"
        }
    }
},
{
    "kretprobe:of_get_child_by_name": {
        "description": "Find the child node by name for a given parent",
        "pre": {
            "node": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_child_by_name": {
        "description": "Find the child node by name for a given parent",
        "pre": {
            "node": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_opts_by_path": {
        "description": "Find a node matching a full OF path",
        "pre": {
            "path": "!=null",
            "opts": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_opts_by_path": {
        "description": "Find a node matching a full OF path",
        "pre": {
            "path": "!=null",
            "opts": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_name": {
        "description": "Find a node by its \"name\" property",
        "pre": {
            "from": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_name": {
        "description": "Find a node by its \"name\" property",
        "pre": {
            "from": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_type": {
        "description": "Find a node by its \"device_type\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_type": {
        "description": "Find a node by its \"device_type\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:of_find_compatible_node": {
        "description": "Find a node based on type and one of the tokens in its \"compatible\" property.",
        "pre": {
            "from": "!=null",
            "type": "in [\"device_type\", null]",
            "compatible": "!=null"
        }
    }
},
{
    "kprobe:of_find_compatible_node": {
        "description": "Find a node based on type and one of the tokens in its \"compatible\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null",
            "compatible": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_with_property": {
        "description": "Find a node which has a property with the given name.",
        "pre": {
            "from": "!=null",
            "prop_name": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_with_property": {
        "description": "Find a node which has a property with the given name.",
        "pre": {
            "from": "!=null",
            "prop_name": "!=null"
        }
    }
},
{
    "kretprobe:of_match_node": {
        "description": "Tell if a device_node has a matching of_match structure",
        "pre": {
            "matches": "!=null",
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_match_node": {
        "description": "Tell if a device_node has a matching of_match structure",
        "pre": {
            "matches": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_find_matching_node_and_match": {
        "description": "Find a node based on an of_device_id match table.",
        "pre": {
            "from": "!=null",
            "matches": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kprobe:of_find_matching_node_and_match": {
        "description": "Find a node based on an of_device_id match table.",
        "pre": {
            "from": "!=null",
            "matches": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_phandle": {
        "description": "Find a node given a phandle",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_phandle": {
        "description": "Find a node given a phandle",
        "pre": {
            "handle": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:of_parse_phandle_with_args_map": {
        "description": "Find a node pointed by phandle in a list and remap it.",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "stem_name": "!=null",
            "index": ">=0",
            "out_args": "!=null"
        }
    }
},
{
    "kprobe:of_parse_phandle_with_args_map": {
        "description": "Find a node pointed by phandle in a list and remap it.",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "stem_name": "!=null",
            "index": ">=0",
            "out_args": "!=null"
        }
    }
},
{
    "kretprobe:of_count_phandle_with_args": {
        "description": "Find the number of phandles references in a property",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "cells_name": "!=null"
        }
    }
},
{
    "kprobe:of_count_phandle_with_args": {
        "description": "Find the number of phandles references in a property",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "cells_name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_device_by_node": {
        "description": "Find the platform_device associated with a node",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_find_device_by_node": {
        "description": "Find the platform_device associated with a node",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:of_device_alloc": {
        "description": "Allocate and initialize an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_device_alloc": {
        "description": "Allocate and initialize an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_platform_device_create_pdata": {
        "description": "Alloc, initialize and register an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "platform_data": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_platform_device_create_pdata": {
        "description": "Alloc, initialize and register an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "platform_data": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_platform_bus_probe": {
        "description": "Probe the device-tree for platform buses",
        "pre": {
            "root": "!=null",
            "matches": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_platform_bus_probe": {
        "description": "Probe the device-tree for platform buses",
        "pre": {
            "root": "!=null",
            "matches": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_get_cpu_node": {
        "description": "Get device node associated with the given logical CPU",
        "pre": {
            "cpu": "!=null",
            "thread": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_cpu_node": {
        "description": "Get device node associated with the given logical CPU",
        "pre": {
            "cpu": "!=null",
            "thread": "in [null, unsigned int]"
        }
    }
},
{
    "kretprobe:of_cpu_device_node_get": {
        "description": "Get the CPU device_node for a given logical CPU number",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:of_cpu_device_node_get": {
        "description": "Get the CPU device_node for a given logical CPU number",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:of_cpu_node_to_id": {
        "description": "Get the logical CPU number for a given device_node",
        "pre": {
            "cpu_node": "!=null"
        },
        "post": {
            "return_value": "is an integer",
            "return_value": ">= -ENODEV"
        }
    }
},
{
    "kprobe:of_cpu_node_to_id": {
        "description": "Get the logical CPU number for a given device_node",
        "pre": {
            "cpu_node": "!=null"
        },
        "post": {
            "return": "is_integer"
        }
    }
},
{
    "kretprobe:of_get_cpu_state_node": {
        "description": "Get CPU's idle state node at the given index",
        "pre": {
            "cpu_node": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:of_get_cpu_state_node": {
        "description": "Get CPU's idle state node at the given index",
        "pre": {
            "cpu_node": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:of_graph_is_present": {
        "description": "Check if the device node has a graph port or ports sub-node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_is_present": {
        "description": "Check if the device node has a graph port.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_parse_endpoint": {
        "description": "Parse common endpoint node properties",
        "pre": {
            "node": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:of_graph_parse_endpoint": {
        "description": "Parse common endpoint node properties",
        "pre": {
            "node": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_port_by_id": {
        "description": "Get the port matching a given id",
        "pre": {
            "parent": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_port_by_id": {
        "description": "Get the port matching a given id",
        "pre": {
            "parent": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_next_endpoint": {
        "description": "Get the next endpoint node",
        "pre": {
            "parent": "!=null",
            "prev": "in [null, !=null]"
        }
    }
},
{
    "kprobe:of_graph_get_next_endpoint": {
        "description": "Get the next endpoint node",
        "pre": {
            "parent": "!=null",
            "prev": "in [null, !=null]"
        }
    }
},
{
    "kretprobe:of_graph_get_endpoint_by_regs": {
        "description": "Get endpoint node of specific identifiers",
        "pre": {
            "parent": "!=null",
            "port_reg": "int",
            "reg": "int"
        }
    }
},
{
    "kprobe:of_graph_get_endpoint_by_regs": {
        "description": "Get endpoint node of specific identifiers",
        "pre": {
            "parent": "!=null",
            "port_reg": "int",
            "reg": "int"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_endpoint": {
        "description": "Get remote endpoint node associated with remote endpoint node linked to @node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_endpoint": {
        "description": "Get remote endpoint node associated with remote endpoint node linked to @node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_port_parent": {
        "description": "Get port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_port_parent": {
        "description": "Get port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_port_parent": {
        "description": "Get remote port's parent node",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_port_parent": {
        "description": "Get remote port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_node": {
        "description": "Get remote parent device_node for given portendpoint",
        "pre": {
            "node": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_node": {
        "description": "Get remote parent device_node for given portendpoint.",
        "pre": {
            "node": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:of_match_device": {
        "description": "Tell if a struct device matches an of_device_id list",
        "pre": {
            "matches": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_match_device": {
        "description": "Tell if a struct device matches an of_device_id list.",
        "pre": {
            "matches": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_pci_range_to_resource": {
        "description": "Create a resource from an of_pci_range",
        "pre": {
            "range": "!=null",
            "np": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:of_pci_range_to_resource": {
        "description": "Create a resource from an of_pci_range",
        "pre": {
            "range": "!=null",
            "np": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:of_range_to_resource": {
        "description": "Create a resource from a ranges entry",
        "pre": {
            "np": "!=null",
            "index": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [ENOENT, EINVAL]"
        }
    }
},
{
    "kprobe:of_range_to_resource": {
        "description": "Create a resource from a ranges entry",
        "pre": {
            "np": "!=null",
            "index": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [ENOENT, EINVAL]"
        }
    }
},
S,
S,
{
    "kretprobe:of_translate_dma_region": {
        "description": "Translate device tree address and size tuple",
        "pre": {
            "dev": "!=null",
            "prop": "!=null",
            "start": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:of_translate_dma_region": {
        "description": "Translate device tree address and size tuple",
        "pre": {
            "dev": "!=null",
            "prop": "!=null",
            "start": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:parent = of_get_parent(dev);if (parent == NULL)return NULL;bus = of_match_bus(parent);if (strcmp(bus->name, \"pci\") && (bar_no >= 0))": {
        "description": "Get parent & match bus type",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "bar_no": ">=0",
            "size": "!=null",
            "flags": "!=null",
            "prop": "!=null",
            "psize": "!=null",
            "parent": "!=null",
            "bus": "!=null",
            "onesize": "!=null",
            "i": "!=null",
            "na": "!=null",
            "ns": "!=null"
        }
    }
},
{
    "kprobe:parent = of_get_parent": {
        "description": "Get parent & match bus type",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "bar_no": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:if (parent == NULL)": {
        "description": "Check if parent is NULL",
        "pre": {
            "parent": "==null"
        }
    },
    "kprobe:return NULL;": {
        "description": "Return NULL"
    },
    "kprobe:bus = of_match_bus(parent)": {
        "description": "Match bus type",
        "pre": {
            "parent": "!=null"
        }
    },
    "kprobe:strcmp(bus->name, \"pci\") && (bar_no >= 0)": {
        "description": "Check if bus name is \"pci\" and bar_no is greater than or equal to 0",
        "pre": {
            "bus->name": "==\"pci\"",
            "bar_no": ">=0"
        }
    }
},
{
    "kretprobe:of_property_read_reg": {
        "description": "Retrieve the specified \"reg\" entry index without translating",
        "pre": {
            "np": "!=null",
            "idx": "!=null",
            "addr": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]",
            "addr": "if return == 0, then !=null",
            "size": "if return == 0, then !=null"
        }
    }
},
{
    "kprobe:of_property_read_reg": {
        "description": "Retrieve the specified \"reg\" entry index without translating",
        "pre": {
            "np": "!=null",
            "idx": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:of_iomap": {
        "description": "Maps the memory mapped IO for a given device_node",
        "pre": {
            "np": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:of_iomap": {
        "description": "Maps the memory mapped IO for a given device_node",
        "pre": {
            "np": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:of_io_request_and_map": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node.",
        "pre": {
            "device": "!=null",
            "index": ">=0",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_io_request_and_map": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node.",
        "pre": {
            "device": "!=null",
            "index": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_node_get": {
        "description": "Increment refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_node_get": {
        "description": "Increment refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_node_put": {
        "description": "Decrement refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_node_put": {
        "description": "Decrement refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:nubus_get_board_dir": {
        "description": "Get the board directory for a given nubus board.",
        "pre": {
            "dir": "!=null",
            "board.directory": "!=null",
            "dir.ptr": "initialized",
            "dir.base": "initialized",
            "dir.done": "initialized",
            "dir.mask": "initialized"
        },
        "post": {
            "return": {
                "constraints": "in [-1, 0]",
                "description": "0 on success, -1 on failure"
            }
        }
    }
},
{
    "kprobe:nubus_get_board_dir": {
        "description": "Get the board directory for the given nubus board.",
        "pre": {
            "board": "!=null",
            "dir": "!=null",
            "dir->ptr": "!=null",
            "dir->base": "!=null",
            "dir->done": ">=0",
            "dir->mask": ">=0"
        }
    }
},
{
    "kretprobe:nubus_get_subdir": {
        "description": "Set the base variable of ent to the value of nd->ptr.",
        "pre": {
            "nd": "!=null",
            "ent": "!=null",
            "nd->done": "==0",
            "nd->ptr": "!=null"
        },
        "post": {
            "ent->base": "==nd->ptr"
        }
    }
},
{
    "kprobe:ent->base = nd->ptr;/* This moves nd->ptr forward `": {
        "description": "Move nd->ptr forward",
        "pre": {
            "ent": "!=null",
            "nd": "!=null",
            "nd->ptr": "!=null"
        }
    }
},
{
    "kretprobe:pnp_start_dev": {
        "description": "Low-level start of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_start_dev": {
        "description": "Low-level start of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_stop_dev": {
        "description": "Low-level disable of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_stop_dev": {
        "description": "Low-level disable of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_activate_dev": {
        "description": "Activates a PnP device for use.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_activate_dev": {
        "description": "Activates a PnP device for use.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_disable_dev": {
        "description": "Disables the device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_disable_dev": {
        "description": "Disables the device.",
        "pre": {
            "dev": "!=null",
            "dev->protocol": "in [PNP_PROTOCOL_A, PNP_PROTOCOL_B, PNP_PROTOCOL_C]",
            "dev->resources": "can be used by other devices"
        }
    }
},
{
    "kretprobe:pnp_request_card_device": {
        "description": "Searches for a PnP device under the specified card",
        "pre": {
            "clink": "!=null",
            "id": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pnp_request_card_device": {
        "description": "Searches for a PnP device under the specified card.",
        "pre": {
            "clink": "!=null",
            "id": "!=null",
            "from": "any"
        }
    }
},
{
    "kretprobe:pnp_add_card_id": {
        "description": "adds an EISA id to the specified card",
        "pre": {
            "card": "!=null",
            "id": "!=null"
        }
    }
},
S,
{
    "kretprobe:pnp_register_card_driver": {
        "description": "Registers a PnP card driver with the PnP Layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pnp_register_card_driver": {
        "description": "Registers a PnP card driver with the PnP Layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pnp_unregister_card_driver": {
        "description": "Unregisters a PnP card driver from the PnP Layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pnp_unregister_card_driver": {
        "description": "Unregisters a PnP card driver from the PnP Layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pnp_is_active": {
        "description": "Determines if a device is active based on its current resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_is_active": {
        "description": "Determines if a device is active based on its current resources.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_for_each_dev": {
        "description": "Check for conflicts with other pnp devices",
        "pre": {
            "dev": "!=null",
            "i": "is an integer",
            "tres": "!=res",
            "tres->flags": "& IORESOURCE_IO",
            "tport": "!=null",
            "tend": "!=null",
            "port": "!=null",
            "end": "!=null",
            "ranged_conflict(port, end, tport, tend)": "!=0"
        }
    }
},
{
    "kprobe:pnp_for_each_dev": {
        "description": "Check for conflicts with other PnP devices.",
        "pre": {
            "dev": "!=null",
            "flags": "& IORESOURCE_IO != 0",
            "i": "valid_range",
            "tres": "!= res",
            "tres.flags": "& IORESOURCE_IO != 0",
            "tport": "valid_pointer",
            "tend": "valid_pointer",
            "ranged_conflict(port, end, tport, tend)": "false"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:isapnp_cfg_begin": {
        "description": "Begin ISAPnP configuration.",
        "pre": {
            "csn": ">=1 && <=isapnp_csn_count",
            "logdev": "<=10"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:/* we must set RDP to our value again */": {
        "description": "Helper function for setting RDP value.",
        "pre": {
            "csn": ">= 1",
            "csn": "<= isapnp_csn_count",
            "logdev": "<= 10"
        }
    }
},
S,
S,
{
    "kretprobe:isapnp_wait": {
        "description": "Place all PnP cards in wait-for-key state.",
        "pre": {
            "idx": "!=null",
            "val": "!=null",
            "code": "0x6a",
            "msb": "!=null",
            "i": ">=1",
            "msb": "((code & 0x01) ^ ((code & 0x02) >> 1)) << 7",
            "code": "(code >> 1) | msb"
        }
    }
},
{
    "kprobe:isapnp_wait": {
        "description": "place all pnp cards in wait-for-key state",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:port_bo = t_data->block_offset;}}}EXPORT_SYMBOL(sdw_compute_slave_ports": {
        "description": "This function computes the slave ports for a given master runtime and transport data.",
        "pre": {
            "m_rt": "!=null",
            "t_data": "!=null",
            "s_rt": "!=null",
            "p_rt": "!=null",
            "port_bo": "!=null",
            "sample_int": "!=null",
            "rate": "!=null",
            "bps": "!=null",
            "ch": "!=null",
            "slave_total_ch": "!=null",
            "b_params": "!=null"
        }
    }
},
{
    "kprobe:port_bo = t_data->block_offset;}}}EXPORT_SYMBOL(sdw_compute_slave_ports": {
        "description": "This function computes the slave ports for a given master runtime and transport data.",
        "pre": {
            "m_rt": "!=null",
            "t_data": "!=null",
            "s_rt": "!=null",
            "p_rt": "!=null",
            "port_bo": "!=null",
            "sample_int": "!=null",
            "rate": "!=null",
            "bps": "!=null",
            "ch": "!=null",
            "slave_total_ch": "!=null",
            "b_params": "!=null"
        }
    }
},
S,
{
    "kprobe:sdw_compute_params": {
        "description": "Compute bus, transport and port parameters",
        "pre": {
            "bus": "!=null",
            "transport": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_master_add": {
        "description": "Add a bus Master instance",
        "pre": {
            "bus": "!=null",
            "parent": "!=null",
            "fwnode": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_master_add": {
        "description": "Add a bus Master instance",
        "pre": {
            "bus": "!=null",
            "parent": "!=null",
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_master_delete": {
        "description": "delete the bus master instance",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_master_delete": {
        "description": "Delete the bus master instance",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_show_ping_status": {
        "description": "Direct report of PING status, to be used by Peripheral drivers",
        "pre": {
            "bus": "!=null",
            "sync_delay": ">=0"
        }
    }
},
{
    "kprobe:sdw_show_ping_status": {
        "description": "Direct report of PING status, to be used by Peripheral drivers",
        "pre": {
            "bus": "!=null",
            "sync_delay": ">=0"
        }
    }
},
{
    "kretprobe:sdw_nread_no_pm": {
        "description": "Read \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sdw_nread_no_pm": {
        "description": "Read \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:sdw_nwrite_no_pm": {
        "description": "Write \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sdw_nwrite_no_pm": {
        "description": "Write \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:sdw_write_no_pm": {
        "description": "Write a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:sdw_write_no_pm": {
        "description": "Write a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:sdw_read_no_pm": {
        "description": "Read a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:sdw_read_no_pm": {
        "description": "Read a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_prep_clk_stop": {
        "description": "Prepare Slave(s) for clock stop",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_prep_clk_stop": {
        "description": "Prepare Slave(s) for clock stop",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_clk_stop": {
        "description": "Stop the bus clock",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_clk_stop": {
        "description": "Stop bus clock",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_exit_clk_stop": {
        "description": "Exit clock stop mode",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_exit_clk_stop": {
        "description": "Exit clock stop mode",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_handle_slave_status": {
        "description": "Handle Slave status",
        "pre": {
            "bus": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kprobe:sdw_handle_slave_status": {
        "description": "Handle Slave status",
        "pre": {
            "bus": "!=null",
            "status": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:sdw_master_read_prop": {
        "description": "Read Master properties",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_master_read_prop": {
        "description": "Read Master properties",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_slave_read_prop": {
        "description": "Read Slave properties",
        "pre": {
            "slave": "!=null"
        }
    }
},
{
    "kprobe:sdw_slave_read_prop": {
        "description": "Read Slave properties",
        "pre": {
            "slave": "!=null"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy the contents of the memory pointed to by 'id' to the memory location pointed to by 'slave->id' with a size of 'sizeof(*id)'. Then, assign 'bus->dev' to 'slave->dev.parent' and assign 'fwnode' to 'slave->dev.fwnode'. Finally, check if 'id->unique_id' is equal to 'SDW_IGNORED_UNIQUE_ID'.",
        "pre": {
            "slave->id": "!=null",
            "id": "!=null",
            "sizeof(*id)": "!=null",
            "slave->dev.parent": "bus->dev",
            "slave->dev.fwnode": "fwnode",
            "id->unique_id": "SDW_IGNORED_UNIQUE_ID"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source address to destination address.",
        "pre": {
            "&slave->id": "!=null",
            "id": "!=null",
            "sizeof(*id)": "!=null",
            "slave->dev.parent": "bus->dev",
            "slave->dev.fwnode": "fwnode",
            "id->unique_id": "SDW_IGNORED_UNIQUE_ID"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:sdw_prep_deprep_ports": {
        "description": "De-prepare port(s) in the sdw_deprepare_stream function",
        "pre": {
            "m_rt": "!=null",
            "ret": "<0"
        }
    }
},
S,
{
    "kretprobe:sdw_alloc_stream": {
        "description": "Allocate and return stream runtime",
        "pre": {
            "stream_name": "!=null"
        }
    }
},
{
    "kprobe:sdw_alloc_stream": {
        "description": "Allocate and return stream runtime",
        "pre": {
            "stream_name": "!=null"
        }
    }
},
{
    "kretprobe:sdw_startup_stream": {
        "description": "Startup SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kprobe:sdw_startup_stream": {
        "description": "Startup SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_shutdown_stream": {
        "description": "Shutdown SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kprobe:sdw_shutdown_stream": {
        "description": "Shutdown SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_add_master": {
        "description": "Allocate and add master runtime to a stream",
        "pre": {
            "bus": "!=null",
            "stream_config": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_add_master": {
        "description": "Allocate and add master runtime to a stream",
        "pre": {
            "bus": "!=null",
            "stream_config": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_remove_master": {
        "description": "Remove master from sdw_stream",
        "pre": {
            "bus": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_remove_master": {
        "description": "Remove master from sdw_stream",
        "pre": {
            "bus": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_add_slave": {
        "description": "Allocate and add masterslave runtime to a stream",
        "pre": {
            "slave": "!=null",
            "stream_config": "!=null",
            "stream": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0"
        }
    }
},
{
    "kprobe:sdw_stream_add_slave": {
        "description": "Allocate and add masterslave runtime to a stream",
        "pre": {
            "slave": "!=null",
            "stream_config": "!=null",
            "stream": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0"
        }
    }
},
{
    "kretprobe:sdw_stream_remove_slave": {
        "description": "Remove slave from sdw_stream",
        "pre": {
            "slave": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_remove_slave": {
        "description": "Remove slave from sdw_stream",
        "pre": {
            "slave": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_cdns_config_update": {
        "pre": {
            "cdns": "!=null"
        },
        "ret": "is int"
    }
},
S,
{
    "kretprobe:sdw_cdns_config_update_set_wait": {
        "description": "Wait until configuration update bit is self-cleared",
        "pre": {
            "cdns": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_config_update_set_wait": {
        "description": "Wait until configuration update bit is self-cleared.",
        "pre": {
            "cdns": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:cdns_xfer_msg_defer": {
        "description": "Transfer deferred message on the sdw_bus.",
        "pre": {
            "bus": "!=null",
            "cdns": "!=null",
            "defer": "!=null",
            "msg": "!=null",
            "cmd": "int",
            "ret": "int",
            "defer->msg": "msg",
            "defer->msg->len": ">1"
        },
        "post": {
            "ret": "in [-ENOTSUPP, SDW_CMD_FAIL_OTHER]"
        }
    }
},
{
    "kprobe:cdns_xfer_msg_defer": {
        "description": "Transfer a deferred message on the sdw_bus.",
        "pre": {
            "bus": "!=null",
            "cdns": "!=null",
            "defer": "!=null",
            "msg": "!=null",
            "cmd": "int",
            "ret": "int",
            "defer->msg": "msg",
            "defer->msg->len": ">1",
            "ret": "=0",
            "cmd": "=0"
        }
    }
},
{
    "kretprobe:sdw_cdns_irq": {
        "description": "Cadence interrupt handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_irq": {
        "description": "Cadence interrupt handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:pm_runtime_resume_and_get": {
        "description": "Resume Master device. If this results in a bus reset, the Slave devices will re-attach and be re-enumerated.",
        "pre": {
            "bus": "!=null",
            "bus->dev": "!=null",
            "ret": "< 0 && ret != -EACCES"
        }
    }
},
{
    "kprobe:pm_runtime_resume_and_get": {
        "description": "Resume the Master device. If this results in a bus reset, the Slave devices will re-attach and be re-enumerated.",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "ret": "< 0 && ret != -EACCES"
        }
    }
},
{
    "kretprobe:sdw_cdns_enable_interrupt": {
        "description": "Enable SDW interrupts",
        "pre": {
            "cdns": "!=null",
            "state": "in [true, false]"
        }
    }
},
{
    "kprobe:sdw_cdns_enable_interrupt": {
        "description": "Enable SDW interrupts",
        "pre": {
            "cdns": "!=null",
            "state": "in [true, false]"
        }
    }
},
{
    "kretprobe:sdw_cdns_pdi_init": {
        "description": "PDI initialization routine",
        "pre": {
            "cdns": "!=null",
            "config": "!=null"
        },
        "post": {
            "return_value": "int"
        }
    }
},
S,
S,
{
    "kprobe:sdw_cdns_init": {
        "description": "Cadence initialization",
        "pre": {
            "cdns": "!=null"
        }
    }
},
{
    "kretprobe:cdns_bus_conf": {
        "description": "cdns_bus_conf function",
        "pre": {
            "bus": "!=null",
            "params": "!=null",
            "bus->prop": "!=null",
            "bus_to_cdns(bus)": "!=null",
            "params->curr_dr_freq": "!=null",
            "prop->mclk_freq": "!=null",
            "divider": "!=null"
        }
    }
},
{
    "kprobe:cdns_bus_conf": {
        "description": "Configure the bus parameters for the CDNS bus.",
        "pre": {
            "bus": "!=null",
            "params": "!=null",
            "params->curr_dr_freq": "!=null",
            "prop": "!=null",
            "cdns": "!=null",
            "mcp_clkctrl_off": "int",
            "divider": "int",
            "!params->next_bank": "true",
            "mcp_clkctrl_off": "CDNS_MCP_CLK_CTRL0",
            "divider": "prop->mclk_freq * (params->curr_dr_freq + 1) - 1"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:sdw_cdns_clock_stop": {
        "description": "Cadence clock stop configuration routine",
        "pre": {
            "cdns": "!=null",
            "block_wake": "is boolean"
        }
    }
},
{
    "kprobe:sdw_cdns_clock_stop": {
        "description": "Cadence clock stop configuration routine",
        "pre": {
            "cdns": "!=null",
            "block_wake": "!=null"
        }
    }
},
{
    "kretprobe:sdw_cdns_clock_restart": {
        "description": "Cadence PM clock restart configuration routine",
        "pre": {
            "cdns": "!=null",
            "bus_reset": "in [true, false]"
        }
    }
},
{
    "kprobe:sdw_cdns_clock_restart": {
        "description": "Cadence PM clock restart configuration routine",
        "pre": {
            "cdns": "!=null",
            "bus_reset": "is boolean"
        }
    }
},
{
    "kretprobe:sdw_cdns_probe": {
        "description": "Cadence probe routine",
        "pre": {
            "cdns": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_probe": {
        "description": "Cadence probe routine",
        "pre": {
            "cdns": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:sdw_cdns_config_stream": {
        "description": "Configure a stream",
        "pre": {
            "cdns": "!=null",
            "ch": "!=null",
            "dir": "!=null",
            "pdi": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_config_stream": {
        "description": "Configure a stream",
        "pre": {
            "cdns": "!=null",
            "ch": "!=null",
            "dir": "!=null",
            "pdi": "!=null"
        }
    }
},
{
    "kretprobe:sdw_cdns_alloc_pdi": {
        "description": "Allocate a PDI",
        "pre": {
            "cdns": "!=null",
            "stream": "!=null",
            "ch": ">=0",
            "dir": ">=0",
            "dai_id": ">=0"
        }
    }
},
{
    "kprobe:sdw_cdns_alloc_pdi": {
        "description": "Allocate a PDI",
        "pre": {
            "cdns": "!=null",
            "stream": "!=null",
            "ch": ">=0",
            "dir": "in [0, 1]",
            "dai_id": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_send_suspend": {
        "description": "Send suspend message to FW. This is useful for system freeze (non S3) case.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ishtp_send_suspend": {
        "description": "Send suspend message to FW",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:elsedev_err": {
        "description": "Initialize fixed client header",
        "pre": {
            "dev": "!=null",
            "devc": "!=null",
            "msg_hdr": "!=null",
            "msg_hdr->cmd": "!=null"
        }
    }
},
S,
{
    "kretprobe:ishtp_cl_io_rb_recycle": {
        "description": "Recycle IO request blocks",
        "pre": {
            "rb": "!=null"
        },
        "post": {
            "return_value": "in [0, -EFAULT]"
        }
    }
},
{
    "kprobe:ishtp_cl_io_rb_recycle": {
        "description": "Recycle IO request blocks",
        "pre": {
            "rb": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_tx_empty": {
        "description": "Test whether client device tx buffer is empty.",
        "pre": {
            "cl": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:ishtp_cl_tx_empty": {
        "description": "Test whether client device tx buffer is empty.",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_rx_get_rb": {
        "description": "Get a rb from client device rx buffer list",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_rx_get_rb": {
        "description": "Get a rb from client device rx buffer list",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_device_init": {
        "description": "ishtp device init",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ishtp_device_init": {
        "description": "ishtp device init",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_start": {
        "description": "Start ISHTP processing by sending query subscriber message",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "= 0"
        }
    }
},
{
    "kprobe:ishtp_start": {
        "description": "Start ISHTP processing by sending query subscriber message.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_flush_queues": {
        "description": "Flush all queues for a client",
        "pre": {
            "cl": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:ishtp_cl_flush_queues": {
        "description": "Flush all queues for a client",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_allocate": {
        "description": "Allocates client structure and sets it up.",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_allocate": {
        "description": "Allocates client structure and sets it up.",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_free": {
        "description": "Frees a client device",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_free": {
        "description": "Frees a client device",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_link": {
        "description": "Reserve a host id and link the client instance",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_link": {
        "description": "Reserve a host id and link the client instance",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_unlink": {
        "description": "Remove fw_cl from the client device list",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_unlink": {
        "description": "Remove fw_cl from the client device list",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_disconnect": {
        "description": "Send disconnect request to firmware",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_disconnect": {
        "description": "Send disconnect request to firmware",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_connect": {
        "description": "Send connect request to firmware",
        "pre": {
            "cl": "!=null"
        },
        "post": {
            "return_value": "in [0, error_code]",
            "RX_ring_buffers": "!=null",
            "TX_ring_buffers": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_connect": {
        "description": "Send connect request to firmware",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_send": {
        "description": "Send a message to firmware",
        "pre": {
            "cl": "!=null",
            "buf": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kprobe:ishtp_cl_send": {
        "description": "Send a message to firmware",
        "pre": {
            "cl": "!=null",
            "buf": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:ishtp_recv": {
        "description": "Process ishtp message",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ishtp_recv": {
        "description": "Process ishtp message",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_fw_cl_by_uuid": {
        "description": "Locate the index of the firmware client using UUID.",
        "pre": {
            "dev": "!=null",
            "uuid": "!=null"
        },
        "post": {
            "return": "is an integer",
            "return >= -ENOENT"
        }
    }
},
{
    "kprobe:ishtp_fw_cl_by_uuid": {
        "description": "Locate index of firmware client using UUID.",
        "pre": {
            "dev": "!=null",
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_fw_cl_get_client": {
        "description": "Return client information to client",
        "pre": {
            "dev": "!=null",
            "uuid": "!=null"
        }
    }
},
{
    "kprobe:ishtp_fw_cl_get_client": {
        "description": "Return client information to client",
        "pre": {
            "dev": "!=null",
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_get_fw_client_id": {
        "description": "Get fw client id",
        "pre": {
            "fw_client": "!=null"
        }
    }
},
{
    "kprobe:ishtp_get_fw_client_id": {
        "description": "Get fw client id",
        "pre": {
            "fw_client": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_driver_register": {
        "description": "Client driver register",
        "pre": {
            "driver": "!=null",
            "owner": "!=null"
        },
        "post": {
            "return_value": "in [driver_register_return_value, -ENODEV]"
        }
    }
},
{
    "kprobe:ishtp_cl_driver_register": {
        "description": "Client driver register",
        "pre": {
            "driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_cl_driver_unregister": {
        "description": "Client driver unregister",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:ishtp_cl_driver_unregister": {
        "description": "Client driver unregister",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_register_event_cb": {
        "description": "Register callback for events, called from client driver.",
        "pre": {
            "device": "!=null",
            "event_cb": "!=null"
        },
        "post": {
            "return": "in [0, -EALREADY]"
        }
    }
},
{
    "kprobe:ishtp_register_event_cb": {
        "description": "Register callback for events, called from client driver.",
        "pre": {
            "device": "!=null",
            "event_cb": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_get_device": {
        "description": "Update usage count for the device",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kprobe:ishtp_get_device": {
        "description": "Update usage count for the device",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_put_device": {
        "description": "Decrement usage count for the device.",
        "pre": {
            "cl_device": "!=null"
        },
        "post": {
            "cl_device": "!=null",
            "count": "==0"
        }
    }
},
{
    "kprobe:ishtp_put_device": {
        "description": "Decrement usage count for the device.",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_set_drvdata": {
        "description": "Set client driver data",
        "pre": {
            "cl_device": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ishtp_set_drvdata": {
        "description": "Set client driver data",
        "pre": {
            "cl_device": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_get_drvdata": {
        "description": "Get client driver data from cl_device->driver_data.",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kprobe:ishtp_get_drvdata": {
        "description": "Get client driver data from cl_device->driver_data.",
        "pre": {
            "cl_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_dev_to_cl_device": {
        "description": "Get ishtp_cl_device instance from device instance",
        "pre": {
            "device": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
S,
{
    "kretprobe:ishtp_bus_remove_all_clients": {
        "description": "Remove all clients",
        "pre": {
            "ishtp_dev": "!=null",
            "warm_reset": "in [true, false]"
        }
    }
},
{
    "kprobe:ishtp_bus_remove_all_clients": {
        "description": "Remove all clients",
        "pre": {
            "ishtp_dev": "!=null",
            "warm_reset": "in [true, false]"
        }
    }
},
{
    "kretprobe:ishtp_reset_handler": {
        "description": "ISHTP Handler for IPC_RESET notification",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ishtp_reset_handler": {
        "description": "IPC reset handler",
        "pre": {
            "dev": "!=null",
            "dev->ishtp_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_reset_compl_handler": {
        "description": "Reset completion handler for ISHTP device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ishtp_reset_compl_handler": {
        "description": "Reset completion handler",
        "pre": {
            "dev": "!=null",
            "dev->ishtp_device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_get_pci_device": {
        "description": "Return PCI device dev pointer",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:ishtp_get_pci_device": {
        "description": "Return PCI device dev pointer",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:ishtp_trace_callback": {
        "description": "Return trace callback",
        "pre": {
            "cl_device": "!=null"
        },
        "post": {
            "return_value": "ishtp_print_log()"
        }
    }
},
{
    "kprobe:ishtp_trace_callback": {
        "description": "Return trace callback",
        "pre": {
            "cl_device": "!=null"
        },
        "post": {
            "return_value": "ishtp_print_log()"
        }
    }
},
{
    "kretprobe:ish_hw_reset": {
        "description": "Call HW reset IPC callback",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:ish_hw_reset": {
        "description": "Call HW reset IPC callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cgc.cmd[4] = 1 << 4;/* media event": {
        "description": "Media event",
        "pre": {
            "cgc": {
                "cmd": {
                    "4": "== (1 << 4)"
                }
            }
        }
    }
},
{
    "kprobe:cgc.cmd[4] = 1 << 4;/* media event": {
        "description": "Media event",
        "pre": {
            "cgc.cmd[4]": "== 16"
        }
    }
},
{
    "kretprobe:cdrom_open_write": {
        "description": "Open the CD-ROM device for writing.",
        "pre": {
            "cdi": "!=null",
            "mrw": "in [0, 1]",
            "mrw_write": "!=null",
            "ram_write": "!=null",
            "ret": "in [0, 1]",
            "cdi->mask": "in [CDC_MRW, ~CDC_MRW, CDC_MRW_W, ~CDC_MRW_W, CDC_RAM, ~CDC_RAM]",
            "CDROM_CAN(CDC_MO_DRIVE)": "in [0, 1]",
            "CDROM_CAN(CDC_MRW_W)": "in [0, 1]",
            "CDROM_CAN(CDC_DVD_RAM)": "in [0, 1]",
            "CDROM_CAN(CDC_RAM)": "in [0, 1]",
            "CDROM_CAN(CDC_CD_R|CDC_CD_RW|CDC_DVD|CDC_DVD_R|CDC_MRW|CDC_MO_DRIVE)": "in [0, 1]",
            "cdrom_is_dvd_rw(cdi)": "in [0, 1]"
        }
    },
    "kretprobe:cdrom_dvd_rw_close_write": {
        "description": "Close the CD-ROM device after writing to a DVD+RW media.",
        "pre": {
            "cdi": "!=null",
            "cdi->mmc3_profile": "0x1a",
            "cdi->media_written": "in [0, 1]",
            "cgc": {
                "cmd": {
                    "0": "GPCMD_FLUSH_CACHE",
                    "2": "GPCMD_CLOSE_TRACK"
                },
                "timeout": "3000*HZ",
                "quiet": 1
            }
        }
    }
},
S,
{
    "kretprobe:cdrom_number_of_slots": {
        "description": "Calculate the number of slots in a CD-ROM changer.",
        "pre": {
            "cdi": "!=null",
            "cdi->capacity": "==0",
            "info": "=kmalloc(sizeof(*info), GFP_KERNEL)",
            "!info": "==null",
            "cdrom_read_mech_status(cdi, info)": "==0",
            "nslots": "==info->hdr.nslots",
            "kfree(info)": "called"
        },
        "post": {
            "return": "nslots"
        }
    }
},
"cdi->capacity": "!= 0",
S,
S,
{
    "kretprobe:cdrom_ioctl_multisession": {
        "description": "Handles the CDROMMULTISESSION ioctl command.",
        "pre": {
            "cdi": "!=null",
            "argp": "!=null"
        }
    },
    "kretprobe:cdrom_ioctl_eject": {
        "description": "Handles the CDROMEJECT ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_OPEN_TRAY)": "true",
            "cdi->use_count": "== 1",
            "cdi->keeplocked": "== 0"
        }
    },
    "kretprobe:cdrom_ioctl_closetray": {
        "description": "Handles the CDROMCLOSETRAY ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_CLOSE_TRAY)": "true"
        }
    },
    "kretprobe:cdrom_ioctl_eject_sw": {
        "description": "Handles the CDROMEJECT_SW ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_OPEN_TRAY)": "true",
            "cdi->keeplocked": "== 0",
            "arg": "in [0, 1]"
        }
    },
    "kretprobe:cdrom_ioctl_media_changed": {
        "description": "Handles the CDROM_MEDIA_CHANGED ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_MEDIA_CHANGED)": "true",
            "arg": ">= 0"
        }
    }
},
{
    "kprobe:cdrom_ioctl_multisession": {
        "description": "Handle the CDROMMULTISESSION ioctl command.",
        "pre": {
            "cdi": "!=null",
            "argp": "!=null"
        }
    },
    "kprobe:cdrom_ioctl_eject": {
        "description": "Handle the CDROMEJECT ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_OPEN_TRAY)": "true",
            "cdi->use_count": "== 1",
            "cdi->keeplocked": "== 0"
        }
    },
    "kprobe:cdrom_ioctl_closetray": {
        "description": "Handle the CDROMCLOSETRAY ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_CLOSE_TRAY)": "true"
        }
    },
    "kprobe:cdrom_ioctl_eject_sw": {
        "description": "Handle the CDROMEJECT_SW ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_OPEN_TRAY)": "true",
            "cdi->keeplocked": "== 0",
            "arg": "in [0, 1]"
        }
    },
    "kprobe:cdrom_ioctl_media_changed": {
        "description": "Handle the CDROM_MEDIA_CHANGED ioctl command.",
        "pre": {
            "cdi": "!=null",
            "CDROM_CAN(CDC_MEDIA_CHANGED)": "true",
            "arg": ">= 0"
        }
    }
},
{
    "kretprobe:cmdq_pkt_append_command": {
        "description": "Append a command to the cmdq_pkt structure.",
        "pre": {
            "pkt": "!=null",
            "inst.op": "==CMDQ_CODE_EOC",
            "inst.value": "==CMDQ_EOC_IRQ_EN"
        },
        "post": {
            "err": "<0"
        }
    }
},
{
    "kprobe:cmdq_pkt_append_command": {
        "description": "Append a command to the cmdq_pkt structure.",
        "pre": {
            "pkt": "!=null",
            "inst.op": "==CMDQ_CODE_EOC",
            "inst.value": "==CMDQ_EOC_IRQ_EN",
            "err": ">=0"
        }
    }
},
{
    "kretprobe:mbox_client_txdone": {
        "description": "Call txdone on the mbox client channel.",
        "pre": {
            "client->chan": "!=null",
            "0": "==0"
        }
    }
},
{
    "kprobe:mbox_client_txdone": {
        "description": "Flushes the packet asynchronously and calls txdone.",
        "pre": {
            "pkt": "!=null",
            "pkt->cl": "!=null",
            "pkt->cl->chan": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:clear_vdqcr": {
        "description": "Remove slowish-path stuff from the fast path and ensure it isn't inlined.",
        "pre": {
            "p": "!=null",
            "fq": "!=null",
            "is": "!=null"
        }
    }
},
S,
{
    "kretprobe:qman_create_fq": {
        "description": "Create a qman_fq structure with the given fqid, flags, and fq.",
        "pre": {
            "fqid": "==0 || >=num_fqids",
            "flags": "!=null",
            "fq": "!=null"
        }
    }
},
{
    "kprobe:qman_create_fq": {
        "description": "Create a qman_fq with the given fqid, flags, and fq.",
        "pre": {
            "fqid": "==0 || >=num_fqids",
            "flags": "&QMAN_FQ_FLAG_DYNAMIC_FQID",
            "ret": "!=0",
            "fq->fqid": "==fqid",
            "fq->flags": "==flags",
            "fq->state": "==qman_fq_state_oos",
            "fq->cgr_groupid": "==0"
        }
    }
},
S,
S,
{
    "kretprobe:if (be16_to_cpu(opts->we_mask) & QM_INITFQ_WE_TDTHRESH)": {
        "description": "Issue an INITFQ_[PARKED|SCHED] management command",
        "pre": {
            "be16_to_cpu(opts->we_mask)": "& QM_INITFQ_WE_TDTHRESH",
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if (be16_to_cpu(opts->we_mask) & QM_INITFQ_WE_TDTHRESH)return -EINVAL;}/* Issue an INITFQ_[PARKED|SCHED] management command `": {
        "description": "Helper function for issuing an INITFQ_[PARKED|SCHED] management command",
        "pre": {
            "opts": "!=null",
            "opts->we_mask": "& QM_INITFQ_WE_TDTHRESH == 0",
            "flags": "in [QMAN_INITFQ_FLAG_SCHED, QMAN_INITFQ_FLAG_PARKED]",
            "fq->state": "in [qman_fq_state_oos, qman_fq_state_parked]",
            "fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)": "== 0"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kretprobe:qman_schedule_fq": {
        "description": "Schedule a qman_fq",
        "pre": {
            "fq->state": "== qman_fq_state_parked",
            "fq_isset(fq, QMAN_FQ_STATE_CHANGING)": "== false"
        }
    }
},
S,
S,
{
    "kprobe:__poll_portal_fast": {
        "description": "Description of the function",
        "pre": {
            "p": "!=null",
            "poll_limit": ">=0",
            "sched_napi": "is boolean"
        }
    }
},
S,
{
    "kprobe:eq = qm_eqcr_start_stash": {
        "description": "Start stashing the qm_eqcr_entry structure pointed to by &p->p.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:qman_create_cgr": {
        "description": "Create a congestion group (CGR) in the qman subsystem.",
        "pre": {
            "cgr->cgrid": ">= CGR_NUM",
            "preempt_disable()": "called",
            "p": "!= null",
            "qman_cgr_cpus[cgr->cgrid]": "= smp_processor_id()",
            "preempt_enable()": "called",
            "cgr->chan": "= p->config->channel",
            "spin_lock(&p->cgr_lock)": "called",
            "opts": "!= null"
        }
    }
},
{
    "kprobe:qman_create_cgr": {
        "description": "Create a congestion group (CGR) in the qman subsystem.",
        "pre": {
            "cgr->cgrid": ">= CGR_NUM",
            "preempt_disable()": "called",
            "p": "!= null",
            "qman_cgr_cpus[cgr->cgrid]": "= smp_processor_id()",
            "preempt_enable()": "called",
            "cgr->chan": "= p->config->channel",
            "spin_lock(&p->cgr_lock)": "called",
            "opts": "!= null"
        }
    }
},
{
    "kretprobe:list_for_each_entry": {
        "description": "Iterate over a list of entries and perform a check on each entry.",
        "pre": {
            "i": "!=null",
            "&p->cgr_cbs": "!=null",
            "i->cgrid": "==cgr->cgrid",
            "i->cb": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:qman_query_cgr": {
        "description": "Query the CGR state for a given CGR object.",
        "pre": {
            "cgr": "!=null"
        },
        "post": {
            "ret": "!=0"
        }
    }
},
{
    "kprobe:list_for_each_entry": {
        "description": "Iterate over a list of entries and perform certain actions.",
        "pre": {
            "i": "!=null",
            "&p->cgr_cbs": "!=null",
            "i->cgrid": "==cgr->cgrid",
            "i->cb": "!=null"
        }
    },
    "kprobe:release_lock": {
        "description": "Release the lock and exit the loop.",
        "pre": {}
    },
    "kprobe:qman_query_cgr": {
        "description": "Query the CGR object and update the CGR state.",
        "pre": {
            "cgr": "!=null",
            "&cgr_state": "!=null"
        }
    },
    "kprobe:ret": {
        "description": "Store the return value of qman_query_cgr.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:dpaa2_io_get_cpu": {
        "description": "get the cpu associated with a given DPIO object",
        "pre": {
            "d": "!=null"
        }
    }
},
{
    "kprobe:dpaa2_io_get_cpu": {
        "description": "Get the CPU associated with a given DPIO object",
        "pre": {
            "d": "!=null"
        },
        "post": {
            "return": "is_cpu_number"
        }
    }
},
{
    "kretprobe:dpaa2_io_service_pull_fq": {
        "description": "Pull dequeue functions from a frame queue.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "s": "!=null"
        }
    }
},
{
    "kprobe:dpaa2_io_service_pull_fq": {
        "description": "Pull dequeue functions from a frame queue.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "s": "!=null"
        }
    }
},
{
    "kretprobe:dpaa2_io_service_enqueue_fq": {
        "description": "Enqueue a frame to a frame queue.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENODEV]"
        }
    }
},
{
    "kprobe:dpaa2_io_service_enqueue_fq": {
        "description": "Enqueue a frame to a frame queue.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null"
        }
    }
},
{
    "kretprobe:dpaa2_io_service_enqueue_multiple_fq": {
        "description": "Enqueue multiple frames to a frame queue using one fqid.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null",
            "nb": ">=0"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENODEV]"
        }
    }
},
{
    "kprobe:dpaa2_io_service_enqueue_multiple_fq": {
        "description": "Enqueue multiple frames to a frame queue using one fqid.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null",
            "nb": ">=0"
        }
    }
},
{
    "kretprobe:dpaa2_io_service_enqueue_multiple_desc_fq": {
        "description": "Enqueue multiple frames to different frame queue using a list of fqids.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null",
            "nb": ">=0"
        }
    }
},
{
    "kprobe:dpaa2_io_service_enqueue_multiple_desc_fq": {
        "description": "Enqueue multiple frames to different frame queue using a list of fqids.",
        "pre": {
            "d": "!=null",
            "fqid": "!=null",
            "fd": "!=null",
            "nb": ">=0"
        }
    }
},
{
    "kretprobe:dpaa2_io_create": {
        "description": "Create a dpaa2_io object.",
        "pre": {
            "desc": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dpaa2_io_create": {
        "description": "Create a dpaa2_io object.",
        "pre": {
            "desc": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dpaa2_io_get_irq_coalescing": {
        "description": "Get the current IRQ coalescing parameters",
        "pre": {
            "d": "!=null",
            "irq_holdoff": "!=null"
        }
    }
},
{
    "kprobe:dpaa2_io_get_irq_coalescing": {
        "description": "Get the current IRQ coalescing parameters",
        "pre": {
            "d": "!=null",
            "irq_holdoff": "!=null"
        }
    }
},
{
    "kretprobe:dpaa2_io_set_adaptive_coalescing": {
        "description": "Enable/disable adaptive coalescing",
        "pre": {
            "d": "!=null",
            "use_adaptive_rx_coalesce": "!=null"
        }
    }
},
S,
{
    "kretprobe:dpaa2_io_get_adaptive_coalescing": {
        "description": "Query adaptive coalescing state",
        "pre": {
            "d": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:dpaa2_io_get_adaptive_coalescing": {
        "description": "Query adaptive coalescing state",
        "pre": {
            "d": "!=null"
        }
    }
},
{
    "kretprobe:dpaa2_io_update_net_dim": {
        "description": "Update Net DIM",
        "pre": {
            "d": "!=null",
            "frames": ">=0",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:dpaa2_io_update_net_dim": {
        "description": "Update Net DIM",
        "pre": {
            "d": "!=null",
            "frames": ">=0",
            "bytes": ">=0"
        }
    }
},
S,
S,
S,
{
    "kprobe:pin_mask = (u32) (1 << (QE_PIO_PINS - 1 - pin)); tmp_val = ioread32be(&par_io[port].cpdata); if (val == 0) /* clear": {
        "description": "Calculate pin location and clear",
        "pre": {
            "port": "< num_par_io_ports",
            "pin": "< QE_PIO_PINS",
            "val": "== 0"
        }
    }
},
{
    "kretprobe:tsa_serial_get_byphandle": {
        "description": "Check if the serial id matches the phandle arg",
        "pre": {
            "tsa_serial": "!=null",
            "out_args": {
                "args_count": "==1",
                "args": {
                    "0": "!=null"
                }
            },
            "tsa": "!=null",
            "tsa->serials": "!=null",
            "tsa_serial->id": "!=null",
            "out_args.args[0]": "!=null",
            "tsa_serial->id": "!=out_args.args[0]"
        }
    }
},
{
    "kprobe:tsa_serial_get_byphandle": {
        "description": "Check if the serial id matches the phandle arg.",
        "pre": {
            "tsa_serial->id": "!= null",
            "out_args.args[0]": "< ARRAY_SIZE(tsa->serials)"
        }
    }
},
{
    "kretprobe:gumr = ioread32be": {
        "description": "Read a 32-bit value from the memory location pointed to by uf_regs->gumr.",
        "pre": {
            "uf_regs": "!=null",
            "gumr": "!=null"
        }
    },
    "kretprobe:if (mode & COMM_DIR_TX)": {
        "description": "Check if the mode has the COMM_DIR_TX flag set.",
        "pre": {
            "mode": "!=null",
            "mode & COMM_DIR_TX": "==true"
        }
    }
},
{
    "kprobe:gumr = ioread32be(&uf_regs->gumr);if (mode & COMM_DIR_TX)": {
        "description": "Disable reception and/or transmission on this UCC.",
        "pre": {
            "uf_regs": "!=null"
        }
    }
},
{
    "kretprobe:ucc_fast_init": {
        "description": "Check if the UCC port number is in range.",
        "pre": {
            "uf_info": "!=null",
            "uf_info.ucc_num": "< 0 || > UCC_MAX_NUM - 1"
        }
    }
},
{
    "kprobe:ucc_fast_init": {
        "description": "Check if the UCC port number is in range.",
        "pre": {
            "uf_info": "!=null",
            "uf_info->ucc_num": "< 0 || > UCC_MAX_NUM - 1"
        }
    }
},
S,
S,
{
    "kretprobe:qe_pin_request": {
        "description": "Request a QE pin",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "context": "non-atomic"
        }
    }
},
{
    "kprobe:qe_pin_request": {
        "description": "Request a QE pin",
        "pre": {
            "dev": "!=null",
            "index": "!=null"
        },
        "context": "non-atomic"
    }
},
{
    "kretprobe:qe_pin_free": {
        "description": "Free a pin",
        "pre": {
            "qe_pin": "!=null"
        }
    }
},
{
    "kprobe:qe_pin_free": {
        "description": "Free a pin",
        "pre": {
            "qe_pin": "!=null"
        }
    }
},
{
    "kretprobe:qe_pin_set_dedicated": {
        "description": "Revert a pin to a dedicated peripheral function mode",
        "pre": {
            "qe_pin": "!=null",
            "context": "any"
        }
    }
},
{
    "kprobe:qe_pin_set_dedicated": {
        "description": "Revert a pin to a dedicated peripheral function mode",
        "pre": {
            "qe_pin": "!=null",
            "Context": "any"
        }
    }
},
{
    "kretprobe:qe_pin_set_gpio": {
        "description": "Set a pin to the GPIO mode",
        "pre": {
            "qe_pin": "!=null"
        }
    }
},
{
    "kprobe:qe_pin_set_gpio": {
        "description": "Set a pin to the GPIO mode",
        "pre": {
            "qe_pin": "!=null"
        }
    }
},
{
    "kretprobe:qmc_chan_get_info": {
        "description": "Retrieve info from the TSA related serial",
        "pre": {
            "chan": "!=null",
            "info": "!=null",
            "tsa_info": "!=null",
            "ret": "int",
            "ret != 0": true,
            "info->mode": "chan->mode",
            "info->rx_fs_rate": "tsa_info.rx_fs_rate",
            "info->rx_bit_rate": "tsa_info.rx_bit_rate",
            "info->nb_tx_ts": "hweight64(chan->tx_ts_mask)",
            "info->tx_fs_rate": "tsa_info.tx_fs_rate",
            "info->tx_bit_rate": "tsa_info.tx_bit_rate",
            "info->nb_rx_ts": "hweight64(chan->rx_ts_mask)"
        }
    }
},
{
    "kprobe:qmc_chan_get_info": {
        "description": "Retrieve info from the TSA related serial",
        "pre": {
            "chan": "!=null",
            "info": "!=null",
            "tsa_info": "!=null",
            "ret": "int",
            "ret != 0": true,
            "info.mode": "chan.mode",
            "info.rx_fs_rate": "tsa_info.rx_fs_rate",
            "info.rx_bit_rate": "tsa_info.rx_bit_rate",
            "info.nb_tx_ts": "hweight64(chan.tx_ts_mask)",
            "info.tx_fs_rate": "tsa_info.tx_fs_rate",
            "info.tx_bit_rate": "tsa_info.tx_bit_rate",
            "info.nb_rx_ts": "hweight64(chan.rx_ts_mask)"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Lock the tx_lock and perform some operations",
        "pre": {
            "bd": "!=null",
            "ctrl": "!=null",
            "ctrl & (QMC_BD_TX_R | QMC_BD_TX_UB)": "true"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Lock the spinlock and save the IRQ state.",
        "pre": {
            "chan": "!=null",
            "flags": "!=null",
            "bd": "!=null",
            "ctrl": "!=null",
            "ctrl": "(& (QMC_BD_TX_R, QMC_BD_TX_UB))"
        }
    }
},
{
    "kretprobe:qmc_chan_read_submit": {
        "description": "Submit a read request to the qmc_chan",
        "pre": {
            "chan": "!=null",
            "addr": "!=null",
            "length": "!=null",
            "complete": "!=null",
            "context": "!=null",
            "xfer_desc": "!=null",
            "flags": "!=null",
            "bd": "!=null",
            "ctrl": "!=null",
            "ret": "!=null",
            "ctrl & (QMC_BD_RX_E | QMC_BD_RX_UB)": "true"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spin lock and disable IRQs.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:qmc_read16": {
        "description": "Read a 16-bit value from a memory location.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:qmc_chan_read_submit": {
        "description": "Submit a read transfer to a QMC channel.",
        "pre": {
            "chan": "!=null",
            "addr": "!=null",
            "length": "!=null",
            "complete": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kretprobe:qmc_chan_command": {
        "description": "Execute the qmc_chan_command function with the given arguments.",
        "pre": {
            "chan": "!=null",
            "ret": "!=null",
            "ret == 0": true
        }
    }
},
{
    "kprobe:qmc_chan_command": {
        "description": "Execute the qmc_chan_command function with the given arguments.",
        "pre": {
            "chan": "!=null",
            "ret": "!=null",
            "ret == 0x0"
        }
    }
},
S,
S,
{
    "kretprobe:qmc_setbits16": {
        "description": "Set the POL bit in the channel mode register",
        "pre": {
            "chan->s_param + QMC_SPE_CHAMR": "!=null",
            "QMC_SPE_CHAMR_ENT": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:mod": {
        "description": "Calculate the remainder of brg_clk divided by CLK_GRAN.",
        "pre": {
            "brg_clk": "!=null",
            "CLK_GRAN": "!=null",
            "mod": "!=null",
            "mod": ">= 0",
            "mod": "< CLK_GRAN"
        }
    }
},
{
    "kprobe:mod = brg_clk % CLK_GRAN;if (mod)": {
        "description": "Calculate the remainder of brg_clk divided by CLK_GRAN and assign it to mod.",
        "pre": {
            "brg_clk": "!=null",
            "qe": "!=null",
            "brg": "unsigned int",
            "brg_clk": "multiple of CLK_GRAN"
        }
    }
},
{
    "kretprobe:qe_setbrg": {
        "description": "Set the BRG (Baud Rate Generator) for a specific clock.",
        "pre": {
            "brg": "in [QE_BRG1, QE_BRG2, ..., QE_BRG16]",
            "rate": "!=null",
            "multiplier": "!=null",
            "divisor": "((qe_get_brg_clk() / (rate * multiplier)) <= QE_BRGC_DIVISOR_MAX + 1) ? (divisor == 16 ? div16 == QE_BRGC_DIV16 : (divisor % 2 == 0 ? divisor : divisor + 1)) : (div16 == QE_BRGC_DIV16 && divisor == 16)",
            "tempval": "((divisor - 1) << QE_BRGC_DIVISOR_SHIFT) | QE_BRGC_ENABLE | div16",
            "iowrite32be": "iowrite32be(tempval, &qe_immr->brg.brgc[brg - QE_BRG1])",
            "return": "0"
        }
    }
},
{
    "kprobe:qe_setbrg": {
        "description": "Set the BRG (Baud Rate Generator) for a specific clock.",
        "pre": {
            "qe_general4_errata": "true",
            "div16": "false",
            "divisor": {
                "&": [ "divisor", 1 ],
                ">": [ "divisor", 3 ]
            }
        }
    }
},
{
    "kretprobe:qe_upload_microcode": {
        "description": "Uploads the microcode.",
        "pre": {
            "base": "!=null",
            "ucode": "!=null"
        }
    }
},
{
    "kprobe:qe_upload_microcode": {
        "description": "Upload the microcode.",
        "pre": {
            "base": "!=null",
            "ucode": "!=null"
        }
    }
},
S,
{
    "kprobe:qe_get_firmware_info": {
        "description": "Get the firmware information for the QE firmware.",
        "pre": {
            "qe_firmware_info": "!=null"
        }
    }
},
{
    "kretprobe:gumr_l = ioread32be(&us_regs->gumr_l); if (mode & COMM_DIR_TX)": {
        "description": "Disable reception and/or transmission on this UCC.",
        "pre": {
            "gumr_l": "!=null",
            "us_regs": "!=null",
            "mode": "!=null",
            "mode & COMM_DIR_TX": "!=0"
        }
    }
},
{
    "kprobe:gumr_l = ioread32be(&us_regs->gumr_l);if (mode & COMM_DIR_TX)": {
        "description": "Disable reception and/or transmission on this UCC.",
        "pre": {
            "uccs": "!=null",
            "uccs->us_regs": "!=null",
            "mode": "!=null",
            "mode & COMM_DIR_TX": "!=0"
        }
    }
},
{
    "kretprobe:ucc_slow_init": {
        "description": "Check if the UCC port number is in range.",
        "pre": {
            "us_info": "!=null",
            "us_info->ucc_num": "< 0 || > UCC_MAX_NUM - 1"
        }
    }
},
{
    "kprobe:ucc_slow_init": {
        "description": "Check if the UCC port number is in range.",
        "pre": {
            "us_info": "!=null",
            "us_info.ucc_num": "< 0 || > UCC_MAX_NUM - 1"
        }
    }
},
S,
{
    "kprobe:ucc_set_type": {
        "description": "Set UCC to slow type",
        "pre": {
            "us_info->ucc_num": "!=null",
            "UCC_SPEED_TYPE_SLOW": "!=null"
        }
    }
},
{
    "kretprobe:csel": {
        "description": "Calculate the value of csel based on the value of ucc_num.",
        "pre": {
            "ucc_num": "< 4"
        }
    },
    "kretprobe:siram_entry_valid": {
        "description": "Calculate the value of siram_entry_valid based on the value of csel.",
        "pre": {
            "csel": "!= null"
        }
    },
    "kretprobe:siram_entry_closed": {
        "description": "Calculate the value of siram_entry_closed.",
        "pre": {}
    },
    "kretprobe:for_loop": {
        "description": "Iterate over utdm->num_of_ts.",
        "pre": {
            "i": ">= 0",
            "i": "< utdm->num_of_ts"
        }
    }
},
{
    "kprobe:csel": {
        "description": "Calculate csel based on ucc_num",
        "pre": {
            "ucc_num": "< 4"
        }
    },
    "kprobe:siram_entry_valid": {
        "description": "Set siram_entry_valid based on csel",
        "pre": {
            "csel": "!= null"
        }
    },
    "kprobe:siram_entry_closed": {
        "description": "Set siram_entry_closed",
        "pre": {}
    },
    "kprobe:for_loop": {
        "description": "Iterate over utdm->num_of_ts",
        "pre": {
            "utdm->num_of_ts": "> 0"
        }
    }
},
{
    "kretprobe:cpm_muram_alloc_common": {
        "description": "cpm_muram_alloc common code",
        "pre": {
            "size": ">=0",
            "algo": "in [GENPOOL_DEFAULT, GENPOOL_LINEAR]",
            "data": "!=null"
        }
    }
},
{
    "kprobe:cpm_muram_alloc_common": {
        "description": "cpm_muram_alloc common code",
        "pre": {
            "size": ">=0",
            "algo": "in [GENPOOL_DEFAULT, GENPOOL_LINEAR]",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:cpm_muram_alloc": {
        "description": "Allocate the requested size worth of multi-user ram.",
        "pre": {
            "size": "!=null",
            "align": "!=null"
        }
    }
},
{
    "kprobe:cpm_muram_alloc": {
        "description": "Allocate the requested size worth of multi-user ram.",
        "pre": {
            "size": ">=0",
            "align": ">=0"
        }
    }
},
{
    "kretprobe:cpm_muram_alloc_fixed": {
        "description": "Reserve a specific region of multi-user RAM.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:cpm_muram_alloc_fixed": {
        "description": "Reserve a specific region of multi-user RAM.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:cpm_muram_dma": {
        "description": "Turn a muram virtual address into a DMA address",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:cpm_muram_dma": {
        "description": "Turn a muram virtual address into a DMA address",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:tegra_powergate_power_on": {
        "description": "Power on a partition identified by the given ID.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:tegra_powergate_power_on": {
        "description": "Power on partition identified by 'id'.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:tegra_powergate_power_off": {
        "description": "Power off partition identified by 'id'.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:tegra_powergate_power_off": {
        "description": "Power off a partition identified by the given ID.",
        "pre": {
            "id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tegra_powergate_sequence_power_up": {
        "description": "Power up partition",
        "pre": {
            "id": "!=null",
            "clk": "disabled",
            "rst": "!=null"
        },
        "post": {
            "clk": "enabled"
        }
    }
},
{
    "kprobe:tegra_powergate_sequence_power_up": {
        "description": "Power up partition",
        "pre": {
            "id": "!=null",
            "clk": "disabled",
            "rst": "!=null"
        },
        "post": {
            "clk": "enabled"
        }
    }
},
{
    "kretprobe:tegra_io_pad_power_enable": {
        "description": "Enable power to IO pad",
        "pre": {},
        "post": {
            "ret": "in [0, <negative error codes>]"
        }
    }
},
{
    "kprobe:tegra_io_pad_power_enable": {
        "description": "Enable power to IO pad",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:tegra_io_pad_power_disable": {
        "description": "Disable power to IO pad",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return_value": "in [0, <negative error codes>]"
        }
    }
},
{
    "kprobe:tegra_io_pad_power_disable": {
        "description": "Disable power to IO pad",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:tegra_io_rail_power_on": {
        "description": "Enable power to IO rail",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:tegra_io_rail_power_on": {
        "description": "Enable power to IO rail",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:tegra_io_rail_power_off": {
        "description": "disable power to IO rail",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:tegra_io_rail_power_off": {
        "description": "disable power to IO rail",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:qmgr_get_entry": {
        "description": "Get the entry from the queue manager at the specified queue index.",
        "pre": {
            "queue": "!=null",
            "queue": ">=0",
            "queue": "<QUEUES",
            "val": "!=null"
        }
    }
},
{
    "kprobe:printk": {
        "description": "Print a debug message with the queue name, queue index, and value.",
        "pre": {
            "queue": "!=null",
            "val": "!=null",
            "qmgr_queue_descs[queue]": "!=null",
            "qmgr_regs": "!=null",
            "qmgr_regs->acc[queue][0]": "!=null"
        }
    },
    "kprobe:__raw_writel": {
        "description": "Write the value to the specified address in the qmgr_regs structure.",
        "pre": {
            "val": "!=null",
            "&qmgr_regs->acc[queue][0]": "!=null"
        }
    },
    "kprobe:qmgr_get_entry": {
        "description": "Get the entry from the specified queue.",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:__qmgr_get_stat1": {
        "description": "Read a value from a register and print it using printk",
        "pre": {
            "queue": "!=null",
            "val": "!=null"
        },
        "post": {
            "val": "!=null"
        }
    }
},
{
    "kprobe:__qmgr_get_stat1": {
        "description": "Read a value from a register and print it using printk.",
        "pre": {
            "queue": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:qmgr_stat_empty": {
        "description": "checks if a hardware queue is empty",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:qmgr_stat_empty": {
        "description": "checks if a hardware queue is empty",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:qmgr_stat_below_low_watermark": {
        "description": "checks if a queue is below low watermark",
        "pre": {
            "queue": "!=null"
        },
        "post": {
            "return_value": "!=0"
        }
    }
},
{
    "kprobe:qmgr_stat_below_low_watermark": {
        "description": "Checks if a queue is below the low watermark.",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:qmgr_stat_full": {
        "description": "Checks if a hardware queue is full",
        "pre": {
            "queue": "!=null"
        },
        "post": {
            "return_value": "!=0"
        }
    }
},
{
    "kprobe:qmgr_stat_full": {
        "description": "Checks if a hardware queue is full",
        "pre": {
            "queue": "!=null",
            "queue": "unsigned int",
            "return_value": "int"
        }
    }
},
{
    "kretprobe:qmgr_stat_overflow": {
        "description": "Checks if a hardware queue experienced overflow",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:qmgr_stat_overflow": {
        "description": "Checks if a hardware queue experienced overflow",
        "pre": {
            "queue": "!=null",
            "queue": "unsigned int",
            "return_value": "int"
        }
    }
},
{
    "kretprobe:qmgr_set_irq": {
        "description": "Set the IRQ for a specific queue in the qmgr.",
        "pre": {
            "queue": "!=null",
            "src": "in [0, QUEUE_IRQ_SRC_NOT_FULL]",
            "handler": "!=null",
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:bit = (queue % 8) * 4; /* 3 bits + 1 reserved bit per queue `": {
        "description": "Calculate the bit value based on the queue number.",
        "pre": {
            "queue": "!=null",
            "queue": "< HALF_QUEUES",
            "src": "<= QUEUE_IRQ_SRC_NOT_FULL"
        }
    }
},
S,
S,
{
    "kretprobe:qmgr_request_queue": {
        "description": "Request a queue with the specified parameters.",
        "pre": {
            "queue": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:qmgr_request_queue": {
        "description": "Request queue for qmgr",
        "pre": {
            "queue": "!=null",
            "len": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:spin_lock_irq": {
        "description": "Acquire a spinlock with IRQs disabled.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kretprobe:__raw_readl": {
        "description": "Read a 32-bit value from a memory location.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kretprobe:BUG_ON": {
        "description": "Check if the given condition is true, and if so, trigger a BUG.",
        "pre": {
            "condition": "addr == 0"
        }
    }
},
{
    "kprobe:spin_lock_irq": {
        "description": "Acquire a spinlock with IRQs disabled.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:__raw_readl": {
        "description": "Read a 32-bit value from a memory location.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kprobe:BUG_ON": {
        "description": "Check if the given condition is true, and if so, trigger a BUG.",
        "pre": {
            "condition": "addr != 0"
        }
    }
},
S,
S,
{
    "kretprobe:rmap = syscon_regmap_lookup_by_compatible": {
        "description": "Look up the syscon regmap by compatible",
        "pre": {
            "rmap": "!=null"
        }
    },
    "kretprobe:IS_ERR(rmap)": {
        "description": "Check if rmap is an error",
        "pre": {
            "rmap": "is_error"
        }
    },
    "kretprobe:dev_err_probe(dev, PTR_ERR(rmap), \"failed to look up syscon\\n\")": {
        "description": "Return error message if rmap is an error",
        "pre": {
            "dev": "!=null",
            "PTR_ERR(rmap)": "!=null"
        }
    },
    "kretprobe:for (i = 0; i < NPE_COUNT; i++)": {
        "description": "Loop NPE_COUNT times",
        "pre": {
            "i": ">=0",
            "i": "<NPE_COUNT"
        }
    }
},
S,
S,
S,
{
    "kretprobe:wait_for_completion_timeout": {
        "description": "Waits until the completion variable is complete or the timeout expires.",
        "pre": {
            "completion": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:wait_for_completion_timeout": {
        "description": "Wait for completion with a timeout.",
        "pre": {
            "completion": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:qmi_encode_message": {
        "description": "Encode C structure as QMI encoded message",
        "pre": {
            "type": "!=null",
            "msg_id": "!=null",
            "len": "!=null",
            "txn_id": "!=null",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kprobe:qmi_encode_message": {
        "description": "Encode C structure as QMI encoded message",
        "pre": {
            "type": "!=null",
            "msg_id": "!=null",
            "len": "!=null",
            "txn_id": "!=null",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kretprobe:qmi_decode_message": {
        "description": "Decode QMI encoded message to C structure",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "ei": "!=null",
            "c_struct": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:qmi_decode_message": {
        "description": "Decode QMI encoded message to C structure",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kretprobe:pdr_add_lookup": {
        "description": "Register a tracking request for a PD",
        "pre": {
            "pdr": "!=null",
            "service_name": "!=null",
            "service_path": "!=null"
        },
        "post": {
            "return_value": "!=null",
            "return_value": "not in [ERR_PTR, -EALREADY]"
        }
    }
},
{
    "kprobe:pdr_add_lookup": {
        "description": "Register a tracking request for a PD.",
        "pre": {
            "pdr": "!=null",
            "service_name": "!=null",
            "service_path": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:pdr_restart_pd": {
        "description": "Restarts the PD tracked by the PDR client handle for a given service path.",
        "pre": {
            "pdr": "!=null",
            "pds": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pdr_restart_pd": {
        "description": "Restart PD",
        "pre": {
            "pdr": "!=null",
            "pds": "!=null"
        }
    }
},
{
    "kretprobe:pdr_handle_alloc": {
        "description": "Initialize the PDR client handle",
        "pre": {
            "status": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:pdr_handle_alloc": {
        "description": "Initialize the PDR client handle to allow for tracking restart of PDs.",
        "pre": {
            "status": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:pdr_handle_release": {
        "description": "Release the PDR client handle",
        "pre": {
            "pdr": "!=null"
        }
    }
},
{
    "kprobe:pdr_handle_release": {
        "description": "Release the PDR client handle",
        "pre": {
            "pdr": "!=null"
        }
    }
},
{
    "kretprobe:qmi_add_lookup": {
        "description": "Register a new lookup with the name service.",
        "pre": {
            "qmi": "!=null",
            "service": "!=null",
            "instance": "!=null",
            "version": "!=null"
        }
    }
},
{
    "kprobe:qmi_add_lookup": {
        "description": "Register a new lookup with the name service.",
        "pre": {
            "qmi": "!=null",
            "service": "!=null",
            "instance": "!=null",
            "version": "!=null"
        }
    }
},
{
    "kretprobe:qmi_add_server": {
        "description": "Register a service with the name service.",
        "pre": {
            "qmi": "!=null",
            "service": "!=null",
            "instance": "!=null",
            "version": "!=null"
        }
    }
},
{
    "kprobe:qmi_add_server": {
        "description": "Register a service with the name service.",
        "pre": {
            "qmi": "!=null",
            "service": "!=null",
            "instance": "!=null",
            "version": "!=null"
        }
    }
},
{
    "kretprobe:qmi_txn_init": {
        "description": "Initialize a QMI transaction",
        "pre": {
            "qmi": "!=null",
            "txn": "!=null",
            "ei": "!=null",
            "c_struct": "!=null"
        },
        "post": {
            "return_value": ">=0 || <0"
        }
    }
},
{
    "kprobe:qmi_txn_init": {
        "description": "Initialize a QMI transaction.",
        "pre": {
            "qmi": "!=null",
            "txn": "!=null",
            "ei": "!=null",
            "c_struct": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:qmi_handle_init": {
        "description": "Initialize a QMI client handle",
        "pre": {
            "qmi": "!=null",
            "recv_buf_size": ">=0",
            "ops": "!=null",
            "handlers": "!=null"
        }
    }
},
{
    "kprobe:qmi_handle_init": {
        "description": "Initialize a QMI client handle",
        "pre": {
            "qmi": "!=null",
            "recv_buf_size": ">=0",
            "ops": "!=null",
            "handlers": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:qmi_send_request": {
        "description": "Send a request QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "txn": "!=null",
            "msg_id": "int",
            "len": "size_t",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kprobe:qmi_send_request": {
        "description": "Send a request QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "txn": "!=null",
            "msg_id": "int",
            "len": "size_t",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kretprobe:qmi_send_response": {
        "description": "Send a response QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "txn": "!=null",
            "msg_id": "int",
            "len": "size_t",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kprobe:qmi_send_response": {
        "description": "Send a response QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "txn": "!=null",
            "msg_id": "int",
            "len": "size_t",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kretprobe:qmi_send_indication": {
        "description": "Send an indication QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "msg_id": "!=null",
            "len": ">=0",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kprobe:qmi_send_indication": {
        "description": "Send an indication QMI message",
        "pre": {
            "qmi": "!=null",
            "sq": "!=null",
            "msg_id": "!=null",
            "len": ">=0",
            "ei": "!=null",
            "c_struct": "!=null"
        }
    }
},
{
    "kretprobe:ocmem_allocate": {
        "description": "Allocate memory in ocmem for the specified client with the given size.",
        "pre": {
            "ocmem": "!=null",
            "client": "in [OCMEM_GRAPHICS]",
            "size": "> OCMEM_MIN_ALLOC",
            "!IS_ALIGNED(size, OCMEM_MIN_ALIGN)": "true",
            "test_and_set_bit_lock(BIT(client), &ocmem->active_allocations)": "true",
            "buf": "==null"
        },
        "post": {
            "return": "in [-ENODEV, -EINVAL, -EBUSY]",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ocmem_allocate": {
        "description": "Allocate memory in ocmem for the specified client with the given size.",
        "pre": {
            "ocmem": "!=null",
            "client": "in [OCMEM_GRAPHICS]",
            "size": "> OCMEM_MIN_ALLOC",
            "!IS_ALIGNED(size, OCMEM_MIN_ALIGN)": "false",
            "test_and_set_bit_lock(BIT(client), &ocmem->active_allocations)": "false",
            "buf": "==null"
        }
    }
},
{
    "kretprobe:ocmem_free": {
        "description": "Free the ocmem buffer for a specific client.",
        "pre": {
            "ocmem": "!=null",
            "client": "in [OCMEM_GRAPHICS]",
            "buf": "!=null"
        }
    }
},
S,
{
    "kretprobe:qcom_wcnss_open_channel": {
        "description": "Open additional SMD channel to WCNSS",
        "pre": {
            "wcnss": "!=null",
            "name": "!=null",
            "cb": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:qcom_wcnss_open_channel": {
        "description": "Open additional SMD channel to WCNSS.",
        "pre": {
            "wcnss": "!=null",
            "name": "!=null",
            "cb": "!=null",
            "priv": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:qmp_get": {
        "description": "get a qmp handle from a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": {
                "handle": "!=ERR_PTR()"
            }
        }
    }
},
{
    "kprobe:qmp_get": {
        "description": "Get a qmp handle from a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:qmp_put": {
        "description": "Release a qmp handle",
        "pre": {
            "qmp": "!=null"
        }
    }
},
{
    "kprobe:qmp_put": {
        "description": "Release a qmp handle",
        "pre": {
            "qmp": "!=null"
        }
    }
},
{
    "kretprobe:qcom_rpm_smd_write": {
        "description": "Write @buf to @type:@id",
        "pre": {
            "rpm": "!=null",
            "state": "!=null",
            "type": "!=null",
            "id": "!=null",
            "buf": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:qcom_rpm_smd_write": {
        "description": "Write data to the specified resource type and identifier.",
        "pre": {
            "rpm": "!=null",
            "state": "!=null",
            "type": "!=null",
            "id": "!=null",
            "buf": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:kryo_l2_set_indirect_reg": {
        "description": "Write value to an L2 register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:kryo_l2_set_indirect_reg": {
        "description": "Write value to an L2 register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:kryo_l2_get_indirect_reg": {
        "description": "Read an L2 register value",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:kryo_l2_get_indirect_reg": {
        "description": "Read an L2 register value",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:cmd_db_ready": {
        "description": "Indicates if command DB is available",
        "pre": {},
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:cmd_db_ready": {
        "description": "Indicates if command DB is available",
        "pre": {
            "return": "== 0"
        }
    }
},
{
    "kretprobe:cmd_db_read_addr": {
        "description": "Query command db for resource id address.",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return_value": "is u32",
            "return_value": "!=0"
        }
    }
},
{
    "kprobe:cmd_db_read_addr": {
        "description": "Query command db for resource id address.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:cmd_db_read_aux_data": {
        "description": "Query command db for aux data.",
        "pre": {
            "id": "!=null",
            "len": "!=null"
        },
        "post": {
            "return_value": "!=error_pointer"
        }
    }
},
{
    "kprobe:cmd_db_read_aux_data": {
        "description": "Query command db for aux data.",
        "pre": {
            "id": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:cmd_db_read_slave_id": {
        "description": "Get the slave ID for a given resource address",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return_value": "in [CMD_DB_HW_INVALID, CMD_DB_HW_TYPE_1, CMD_DB_HW_TYPE_2, ...]"
        }
    }
},
{
    "kprobe:cmd_db_read_slave_id": {
        "description": "Get the slave ID for a given resource address",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return": "in [CMD_DB_HW_INVALID, <other valid return values>]"
        }
    }
},
{
    "kretprobe:rpmh_write_async": {
        "description": "Write a set of RPMH commands",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVESLEEP_SET]",
            "cmd": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:rpmh_write_async": {
        "description": "Write a set of RPMH commands",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVESLEEP_SET]",
            "cmd": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:__rpmh_write": {
        "description": "Cache and send the RPMH request",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVE_ONLY, SLEEPWAKE_ONLY]",
            "rpm_msg": "!=null"
        }
    }
},
{
    "kprobe:__rpmh_write": {
        "description": "Cache and send the RPMH request",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVE_ONLY, SLEEPWAKE_ONLY]",
            "rpm_msg": "!=null"
        }
    }
},
{
    "kretprobe:rpmh_write_batch": {
        "description": "Write multiple sets of RPMH commands and wait for the batch to finish.",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVESLEEP]",
            "cmd": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:rpmh_write_batch": {
        "description": "Write multiple sets of RPMH commands and wait for the batch to finish.",
        "pre": {
            "dev": "!=null",
            "state": "in [ACTIVESLEEP]",
            "cmd": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:rpmh_invalidate": {
        "description": "Invalidate sleep and wake sets in batch_cache",
        "pre": {
            "dev": "!=null",
            "batch_cache.sleep": "invalidated",
            "batch_cache.wake": "invalidated"
        }
    }
},
{
    "kprobe:rpmh_invalidate": {
        "description": "Invalidate sleep and wake sets in batch_cache",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_get_qup_hw_version": {
        "description": "Read the QUP wrapper Hardware version",
        "pre": {
            "se": "!=null"
        }
    }
},
{
    "kprobe:geni_se_get_qup_hw_version": {
        "description": "Read the QUP wrapper Hardware version",
        "pre": {
            "se": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_init": {
        "description": "Initialize the GENI serial engine",
        "pre": {
            "se": "!=null",
            "rx_wm": "!=null",
            "rx_rfr": "!=null"
        }
    }
},
{
    "kprobe:geni_se_init": {
        "description": "Initialize the GENI serial engine",
        "pre": {
            "se": "!=null",
            "rx_wm": "!=null",
            "rx_rfr": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_select_mode": {
        "description": "Select the serial engine transfer mode",
        "pre": {
            "se": "!=null",
            "mode": "in [GENI_SE_XFER_MODE_1, GENI_SE_XFER_MODE_2, GENI_SE_XFER_MODE_3]"
        }
    }
},
S,
{
    "kretprobe:geni_se_config_packing": {
        "description": "Packing configuration of the serial engine",
        "pre": {
            "se": "!=null",
            "bpw": ">=0",
            "pack_words": ">=0",
            "msb_to_lsb": "in [true, false]",
            "tx_cfg": "in [true, false]",
            "rx_cfg": "in [true, false]"
        }
    }
},
{
    "kprobe:geni_se_config_packing": {
        "description": "Packing configuration of the serial engine",
        "pre": {
            "se": "!=null",
            "bpw": "!=null",
            "pack_words": "!=null",
            "msb_to_lsb": "in [true, false]",
            "tx_cfg": "in [true, false]",
            "rx_cfg": "in [true, false]"
        }
    }
},
{
    "kretprobe:geni_se_resources_off": {
        "description": "Turn off resources associated with the serial engine",
        "pre": {
            "se": "!=null"
        },
        "post": {
            "return": "in [0, standard Linux error codes]"
        }
    }
},
{
    "kprobe:geni_se_resources_off": {
        "description": "Turn off resources associated with the serial engine.",
        "pre": {
            "se": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_resources_on": {
        "description": "Turn on resources associated with the serial engine",
        "pre": {
            "se": "!=null"
        },
        "post": {
            "return": "in [0, <standard Linux error codes>]"
        }
    }
},
{
    "kprobe:geni_se_resources_on": {
        "description": "Turn on resources associated with the serial engine.",
        "pre": {
            "se": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_clk_tbl_get": {
        "description": "Get the clock table to program DFS",
        "pre": {
            "se": "!=null",
            "tbl": "!=null"
        }
    }
},
{
    "kprobe:geni_se_clk_tbl_get": {
        "description": "Get the clock table to program DFS.",
        "pre": {
            "se": "!=null",
            "tbl": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_clk_freq_match": {
        "description": "Get the matching or closest SE clock frequency",
        "pre": {
            "se": "!=null",
            "req_freq": "!=null",
            "index": "!=null",
            "res_freq": "!=null",
            "exact": "in [true, false]"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:geni_se_clk_freq_match": {
        "description": "Get the matching or closest SE clock frequency",
        "pre": {
            "se": "!=null",
            "req_freq": "!=null",
            "index": "!=null",
            "res_freq": "!=null",
            "exact": "in [true, false]"
        }
    }
},
{
    "kretprobe:geni_se_tx_init_dma": {
        "description": "Initiate TX DMA transfer on the serial engine",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:geni_se_tx_init_dma": {
        "description": "Initiate TX DMA transfer on the serial engine",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:geni_se_tx_dma_prep": {
        "description": "Prepare the serial engine for TX DMA transfer",
        "pre": {
            "se": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "iova": "!=null"
        }
    }
},
{
    "kprobe:geni_se_tx_dma_prep": {
        "description": "Prepare the serial engine for TX DMA transfer",
        "pre": {
            "se": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "iova": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_rx_init_dma": {
        "description": "Initiate RX DMA transfer on the serial engine",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:geni_se_rx_init_dma": {
        "description": "Initiate RX DMA transfer on the serial engine",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_rx_dma_prep": {
        "description": "Prepare the serial engine for RX DMA transfer",
        "pre": {
            "se": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "iova": "!=null"
        }
    }
},
{
    "kprobe:geni_se_rx_dma_prep": {
        "description": "Prepare the serial engine for RX DMA transfer",
        "pre": {
            "se": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "iova": "!=null"
        }
    }
},
{
    "kretprobe:geni_se_tx_dma_unprep": {
        "description": "Unprepare the serial engine after TX DMA transfer",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:geni_se_tx_dma_unprep": {
        "description": "Unprepare the serial engine after TX DMA transfer",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:geni_se_rx_dma_unprep": {
        "description": "Unprepare the serial engine after RX DMA transfer",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:geni_se_rx_dma_unprep": {
        "description": "Unprepare the serial engine after RX DMA transfer",
        "pre": {
            "se": "!=null",
            "iova": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:memstick_detect_change": {
        "description": "Schedule media detection on memstick host",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_detect_change": {
        "description": "Schedule media detection on memstick host.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_next_req": {
        "description": "Called by host driver to obtain next request to process.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "(*mrq)": "!=null",
            "(*mrq)->previous_request": "!=null",
            "(*mrq)->previous_request->status": "==0",
            "(*mrq)->previous_request->retry_count": "<=3"
        }
    }
},
{
    "kprobe:memstick_next_req": {
        "description": "Called by host driver to obtain next request to process.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:memstick_new_req": {
        "description": "Notify the host that some requests are pending.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_new_req": {
        "description": "Notify the host that some requests are pending.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_init_req_sg": {
        "description": "Set request fields needed for bulk data transfer.",
        "pre": {
            "mrq": "!=null",
            "tpc": "!=null",
            "sg": "!=null"
        }
    }
},
{
    "kprobe:memstick_init_req_sg": {
        "description": "Set request fields needed for bulk data transfer.",
        "pre": {
            "mrq": "!=null",
            "tpc": "!=null",
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:memstick_set_rw_addr": {
        "description": "Issue SET_RW_REG_ADDR request and wait for it to complete.",
        "pre": {
            "card": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:memstick_set_rw_addr": {
        "description": "Issue SET_RW_REG_ADDR request and wait for it to complete.",
        "pre": {
            "card": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:memstick_alloc_host": {
        "description": "Allocate a memstick_host structure",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:memstick_alloc_host": {
        "description": "Allocate a memstick_host structure",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:memstick_add_host": {
        "description": "Start request processing on memstick host",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_add_host": {
        "description": "Start request processing on memstick host.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_remove_host": {
        "description": "Stop request processing on memstick host.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_remove_host": {
        "description": "Stop request processing on memstick host.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_free_host": {
        "description": "Free memstick host",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_free_host": {
        "description": "Free memstick host",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_suspend_host": {
        "description": "Notify bus driver of host suspension",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_suspend_host": {
        "description": "Notify bus driver of host suspension",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:memstick_resume_host": {
        "description": "Notify the bus driver of host resumption.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:memstick_resume_host": {
        "description": "Notify bus driver of host resumption",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:host1x_channel_request": {
        "description": "Allocate a channel",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:host1x_channel_request": {
        "description": "Allocate a channel",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:host1x_job_alloc": {
        "description": "Allocate memory for host1x_job structure and related data.",
        "pre": {
            "ch": "!=null",
            "num_cmdbufs": ">=0",
            "num_relocs": ">=0",
            "skip_firewall": "in [true, false]"
        },
        "post": {
            "job": "!=null",
            "num_unpins": ">=num_relocs",
            "enable_firewall": "in [true, false]",
            "total": "<=ULONG_MAX",
            "mem": "!=null",
            "job->enable_firewall": "=enable_firewall",
            "job->channel": "=ch"
        }
    }
},
{
    "kprobe:host1x_job_alloc": {
        "description": "Allocate memory for host1x_job structure and related data.",
        "pre": {
            "ch": "!=null",
            "num_cmdbufs": ">=0",
            "num_relocs": ">=0",
            "skip_firewall": "bool",
            "num_unpins": ">=0",
            "enable_firewall": "bool",
            "total": "<=ULONG_MAX"
        }
    }
},
S,
S,
{
    "kretprobe:host1x_job_get": {
        "description": "Allocate and initialize a host1x_job structure.",
        "pre": {}
    }
},
{
    "kprobe:host1x_job_get": {
        "description": "Allocate and initialize a host1x_job structure.",
        "pre": {
            "mem": "!=null",
            "num_relocs": ">=0",
            "num_unpins": ">=0",
            "num_cmdbufs": ">=0"
        },
        "post": {
            "job": "!=null",
            "job->relocs": "if num_relocs != 0, then job->relocs = mem",
            "job->unpins": "if num_unpins != 0, then job->unpins = mem",
            "job->cmds": "if num_cmdbufs != 0, then job->cmds = mem",
            "job->addr_phys": "if num_unpins != 0, then job->addr_phys = mem",
            "job->reloc_addr_phys": "job->reloc_addr_phys = job->addr_phys",
            "job->gather_addr_phys": "job->gather_addr_phys = &job->addr_phys[num_relocs]",
            "return": "job"
        }
    }
},
{
    "kretprobe:host1x_device_init": {
        "description": "Initialize a host1x logical device",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:host1x_device_init": {
        "description": "Initialize a host1x logical device",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:host1x_device_exit": {
        "description": "Uninitialize host1x logical device",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:host1x_device_exit": {
        "description": "Uninitialize host1x logical device",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:host1x_driver_register_full": {
        "description": "Register a host1x driver",
        "pre": {
            "driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:host1x_driver_register_full": {
        "description": "Register a host1x driver",
        "pre": {
            "driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:host1x_driver_unregister": {
        "description": "Unregister a host1x driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:host1x_driver_unregister": {
        "description": "Unregister a host1x driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:__host1x_client_init": {
        "description": "Initialize a host1x client",
        "pre": {
            "client": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:__host1x_client_init": {
        "description": "Initialize a host1x client",
        "pre": {
            "client": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:host1x_client_exit": {
        "description": "Uninitialize a host1x client.",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:host1x_client_exit": {
        "description": "Uninitialize a host1x client.",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:__host1x_client_register": {
        "description": "Register a host1x client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:__host1x_client_register": {
        "description": "Register a host1x client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:host1x_client_unregister": {
        "description": "Unregister a host1x client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:host1x_client_unregister": {
        "description": "Unregister a host1x client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:host1x_bo_pin": {
        "description": "Pin a host1x_bo and return its mapping.",
        "pre": {
            "dev": "!=null",
            "bo": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]",
            "cache": "!=null"
        }
    }
},
{
    "kprobe:host1x_bo_pin": {
        "description": "Pins a host1x_bo object and returns a host1x_bo_mapping object.",
        "pre": {
            "dev": "!=null",
            "bo": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]",
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:host1x_bo_unpin": {
        "description": "When the last reference of the mapping goes away, make sure to remove the mapping from the cache.",
        "pre": {
            "mapping": "!=null",
            "mapping->cache": "==null"
        }
    }
},
{
    "kprobe:host1x_bo_unpin": {
        "description": "Unpin the host1x_bo_mapping and remove it from the cache.",
        "pre": {
            "mapping->cache": "==null"
        }
    }
},
{
    "kretprobe:tegra_mipi_start_calibration": {
        "description": "Start calibration for the MIPI device.",
        "pre": {
            "device": {
                "mipi": "!=null"
            },
            "device->mipi": {
                "soc": {
                    "pad_drive_down_ref": "!=null",
                    "pad_drive_up_ref": "!=null",
                    "pad_vclamp_level": "!=null",
                    "pad_vauxp_level": "!=null",
                    "hspdos": "!=null",
                    "hspuos": "!=null",
                    "termos": "!=null",
                    "hsclkpdos": "!=null",
                    "hsclkpuos": "!=null"
                },
                "clk": "!=null",
                "lock": "!=null",
                "pads": "!=null"
            },
            "soc": {
                "num_pads": "!=null",
                "has_clk_lane": "!=null",
                "pads": {
                    "data": "!=null",
                    "clk": "!=null"
                }
            }
        }
    }
},
{
    "kprobe:tegra_mipi_readl": {
        "pre": {
            "device->mipi": "!=null",
            "MIPI_CAL_STATUS": "!=null"
        }
    },
    "kprobe:tegra_mipi_writel": {
        "pre": {
            "device->mipi": "!=null",
            "value": "!=null",
            "MIPI_CAL_STATUS": "!=null"
        }
    },
    "kprobe:tegra_mipi_readl": {
        "pre": {
            "device->mipi": "!=null",
            "MIPI_CAL_CTRL": "!=null"
        }
    },
    "kprobe:tegra_mipi_writel": {
        "pre": {
            "device->mipi": "!=null",
            "value": "!=null",
            "MIPI_CAL_CTRL": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_alloc": {
        "description": "Allocate a syncpoint",
        "pre": {
            "host": "!=null",
            "flags": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_alloc": {
        "description": "Allocate a syncpoint",
        "pre": {
            "host": "!=null",
            "flags": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_id": {
        "description": "Retrieve syncpoint ID",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_id": {
        "description": "Retrieve syncpoint ID",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_incr_max": {
        "description": "Update the value sent to hardware",
        "pre": {
            "sp": "!=null",
            "incrs": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_incr_max": {
        "description": "Update the value sent to hardware.",
        "pre": {
            "sp": "!=null",
            "incrs": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_wait": {
        "description": "Wait for a syncpoint to reach a given value.",
        "pre": {
            "sp": "!=null",
            "thresh": "!=null",
            "timeout": ">=0",
            "value": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_wait": {
        "description": "Wait for a syncpoint to reach a given value.",
        "pre": {
            "sp": "!=null",
            "thresh": "!=null",
            "timeout": ">=0",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_request": {
        "description": "Request a host1x_syncpt for the given host1x_client with the specified flags.",
        "pre": {
            "client": "!=null",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:host1x_syncpt_request": {
        "description": "Request a host1x_syncpt for the given host1x_client with the specified flags.",
        "pre": {
            "client": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_read_max": {
        "description": "Read maximum syncpoint value",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_read_max": {
        "description": "Read maximum syncpoint value",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_read_min": {
        "description": "Read minimum syncpoint value",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_read_min": {
        "description": "Read minimum syncpoint value",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_put": {
        "description": "Free a requested syncpoint",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_put": {
        "description": "Free a requested syncpoint",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_get_by_id": {
        "description": "Obtain a syncpoint by ID",
        "pre": {
            "host": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_get_by_id": {
        "description": "Obtain a syncpoint by ID",
        "pre": {
            "host": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_get_by_id_noref": {
        "description": "Obtain a syncpoint by ID but don't increase the refcount.",
        "pre": {
            "host": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_get_by_id_noref": {
        "description": "Obtain a syncpoint by ID but don't increase the refcount.",
        "pre": {
            "host": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_get_base": {
        "description": "Obtain the wait base associated with a syncpoint",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_get_base": {
        "description": "Obtain the wait base associated with a syncpoint.",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_base_id": {
        "description": "Retrieve the ID of a syncpoint wait base",
        "pre": {
            "base": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_base_id": {
        "description": "Retrieve the ID of a syncpoint wait base",
        "pre": {
            "base": "!=null"
        }
    }
},
{
    "kretprobe:host1x_syncpt_release_vblank_reservation": {
        "description": "Make VBLANK syncpoint available for allocation",
        "pre": {
            "client": "!=null",
            "syncpt_id": "!=null"
        }
    }
},
{
    "kprobe:host1x_syncpt_release_vblank_reservation": {
        "description": "Make VBLANK syncpoint available for allocation",
        "pre": {
            "client": "!=null",
            "syncpt_id": "!=null"
        }
    }
},
{
    "kretprobe:host1x_get_dma_mask": {
        "description": "Query the supported DMA mask for host1x.",
        "pre": {
            "host1x": "!=null"
        }
    }
},
{
    "kprobe:host1x_get_dma_mask": {
        "description": "Query the supported DMA mask for host1x.",
        "pre": {
            "host1x": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_register_handler": {
        "description": "Register handler. Enable vga_switcheroo if two vga clients have already registered.",
        "pre": {
            "handler": "!=null",
            "handler_flags": "in [VGA_SWITCHEROO_HANDLER_FLAG_1, VGA_SWITCHEROO_HANDLER_FLAG_2, ...]"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vga_switcheroo_register_handler": {
        "description": "Register handler. Enable vga_switcheroo if two vga clients have already registered.",
        "pre": {
            "handler": "!=null",
            "handler_flags": "in [VGA_SWITCHEROO_HANDLER_FLAG_1, VGA_SWITCHEROO_HANDLER_FLAG_2, VGA_SWITCHEROO_HANDLER_FLAG_3, ...]"
        },
        "post": {
            "return": "0 on success, -EINVAL if a handler was already registered"
        }
    }
},
{
    "kretprobe:vga_switcheroo_unregister_handler": {
        "description": "Unregister handler. Disable vga_switcheroo.",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kprobe:vga_switcheroo_unregister_handler": {
        "description": "Unregister handler. Disable vga_switcheroo.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:vga_switcheroo_register_client": {
        "description": "Register a VGA switcheroo client.",
        "pre": {
            "pdev": "!=null",
            "ops": "!=null",
            "driver_power_control": "bool"
        },
        "post": {
            "return_value": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:vga_switcheroo_register_client": {
        "description": "Register a VGA switcheroo client.",
        "pre": {
            "pdev": "!=null",
            "ops": "!=null",
            "driver_power_control": "is boolean"
        },
        "helper": "vga_switcheroo_client_probe_defer() should be called to ensure all prerequisites are met. Return: 0 on success, -ENOMEM on memory allocation error."
    }
},
{
    "kretprobe:vga_switcheroo_register_audio_client": {
        "description": "Register audio client (audio device on a GPU). The client is assumed to use runtime PM. Beforehand, vga_switcheroo_client_probe_defer() shall be called to ensure that all prerequisites are met.",
        "pre": {
            "pdev": "!=null",
            "ops": "!=null",
            "vga_dev": "!=null"
        },
        "post": {
            "return": "in [0, -ENOMEM, -EINVAL]"
        }
    }
},
{
    "kprobe:vga_switcheroo_register_audio_client": {
        "description": "Register audio client (audio device on a GPU).",
        "pre": {
            "pdev": "!=null",
            "ops": "!=null",
            "vga_dev": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_get_client_state": {
        "description": "Obtain power state of a given client as seen from vga_switcheroo.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:vga_switcheroo_get_client_state": {
        "description": "Obtain power state of a given client as seen from vga_switcheroo.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_unregister_client": {
        "description": "Unregister client. Disable vga_switcheroo if this is a vga client (GPU).",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:vga_switcheroo_unregister_client": {
        "description": "Unregister client. Disable vga_switcheroo if this is a vga client (GPU).",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_client_fb_set": {
        "description": "Set framebuffer of a given client.",
        "pre": {
            "pdev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:vga_switcheroo_client_fb_set": {
        "description": "Set framebuffer of a given client.",
        "pre": {
            "pdev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_lock_ddc": {
        "description": "Lock DDC lines for VGA switcheroo.",
        "pre": {},
        "post": {
            "return_value": "in [-ENODEV, int]"
        }
    }
},
{
    "kprobe:vga_switcheroo_lock_ddc": {
        "description": "Lock the DDC lines for VGA switcheroo.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:vga_switcheroo_process_delayed_switch": {
        "description": "Helper for delayed switching. Process a delayed switch if one is pending.",
        "pre": {
            "return_value": "in [0, -EINVAL]",
            "pending_switch": "==true",
            "client_unregistered": "==false",
            "clients_blocking_switch": "==0"
        }
    }
},
{
    "kprobe:vga_switcheroo_process_delayed_switch": {
        "description": "Helper for delayed switching. Process a delayed switch if one is pending.",
        "pre": {
            "return": "==0",
            "pending_switch": "==1",
            "unregistered_client": "==0",
            "blocking_clients": "==0"
        }
    }
},
{
    "kretprobe:vga_switcheroo_power_switch": {
        "description": "Power switching in the VGA switcheroo subsystem.",
        "pre": {
            "pdev": "!=null",
            "state": "in [VGA_SWITCHEROO_ON, VGA_SWITCHEROO_OFF, VGA_SWITCHEROO_UNDEFINED]"
        }
    }
},
S,
{
    "kretprobe:drm_crtc_from_index": {
        "description": "Find the registered CRTC at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_from_index": {
        "description": "Find the registered CRTC at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_from_index": {
        "description": "Find the registered CRTC at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_from_index": {
        "description": "Find the registered CRTC at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_init_with_planes": {
        "description": "Initialize a DRM CRTC with planes.",
        "pre": {
            "dev": "!=null",
            "crtc": "!=null",
            "primary": "!=null",
            "cursor": "!=null",
            "funcs": "!=null",
            "name": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_crtc_init_with_planes": {
        "description": "Initialize a DRM CRTC with planes.",
        "pre": {
            "dev": "!=null",
            "crtc": "!=null",
            "primary": "!=null",
            "cursor": "!=null",
            "funcs": "!=null",
            "name": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_crtc_check_viewport": {
        "description": "Checks that a framebuffer is big enough for the CRTC viewport",
        "pre": {
            "crtc": "!=null",
            "x": "!=null",
            "y": "!=null",
            "mode": "!=null",
            "fb": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_check_viewport": {
        "description": "Checks that a framebuffer is big enough for the CRTC viewport",
        "pre": {
            "crtc": "!=null",
            "x": "!=null",
            "y": "!=null",
            "mode": "!=null",
            "fb": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_create_scaling_filter_property": {
        "description": "Create a new scaling filter property.",
        "pre": {
            "crtc": "!=null",
            "supported_filters": "!=null",
            "supported_filters": "& BIT(DRM_SCALING_FILTER_DEFAULT) != 0"
        }
    }
},
{
    "kprobe:drm_crtc_create_scaling_filter_property": {
        "description": "Create a new scaling filter property.",
        "pre": {
            "crtc": "!=null",
            "supported_filters": "!=null",
            "supported_filters & BIT(DRM_SCALING_FILTER_DEFAULT)": "!=0"
        }
    }
},
{
    "kretprobe:drm_compat_ioctl": {
        "description": "32-bit IOCTL compatibility handler for DRM drivers",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:drm_compat_ioctl": {
        "description": "32-bit IOCTL compatibility handler for DRM drivers",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:void__drm_atomic_helper_crtc_state_reset": {
        "description": "Reset the CRTC state",
        "pre": {
            "crtc_state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:void__drm_atomic_helper_crtc_state_reset": {
        "description": "reset the CRTC state",
        "pre": {
            "crtc_state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:void__drm_atomic_helper_crtc_reset": {
        "description": "Reset state on CRTC",
        "pre": {
            "crtc": "!=null",
            "crtc_state": "!=null"
        }
    }
},
{
    "kprobe:void__drm_atomic_helper_crtc_reset": {
        "description": "Reset state on CRTC",
        "pre": {
            "crtc": "!=null",
            "crtc_state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_crtc_duplicate_state": {
        "description": "Copy atomic CRTC state",
        "pre": {
            "crtc": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_crtc_duplicate_state": {
        "description": "Copy atomic CRTC state",
        "pre": {
            "crtc": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_crtc_destroy_state": {
        "description": "Release CRTC state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_crtc_destroy_state": {
        "description": "Release CRTC state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_plane_state_reset": {
        "description": "Resets plane state to default values",
        "pre": {
            "plane_state": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_plane_state_reset": {
        "description": "Resets plane state to default values.",
        "pre": {
            "plane_state": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_plane_reset": {
        "description": "Reset state on plane",
        "pre": {
            "plane": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_plane_reset": {
        "description": "Reset state on plane",
        "pre": {
            "plane": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_plane_duplicate_state": {
        "description": "Copy atomic plane state",
        "pre": {
            "plane": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_plane_duplicate_state": {
        "description": "Copy atomic plane state",
        "pre": {
            "plane": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:void__drm_atomic_helper_connector_state_reset": {
        "description": "Reset the connector state",
        "pre": {
            "conn_state": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kprobe:void__drm_atomic_helper_connector_state_reset": {
        "description": "Reset the connector state",
        "pre": {
            "conn_state": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:void__drm_atomic_helper_connector_reset": {
        "description": "Reset state on connector",
        "pre": {
            "connector": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kprobe:void__drm_atomic_helper_connector_reset": {
        "description": "Reset state on connector",
        "pre": {
            "connector": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_connector_tv_margins_reset": {
        "description": "Resets TV connector properties",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_connector_tv_margins_reset": {
        "description": "Resets TV connector properties",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_connector_tv_reset": {
        "description": "Resets Analog TV connector properties",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_connector_tv_reset": {
        "description": "Resets Analog TV connector properties",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_connector_tv_check": {
        "description": "Validate an analog TV connector state",
        "pre": {
            "connector": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_connector_tv_check": {
        "description": "Validate an analog TV connector state",
        "pre": {
            "connector": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:void__drm_atomic_helper_connector_duplicate_state": {
        "description": "Copy atomic connector state",
        "pre": {
            "connector": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:void__drm_atomic_helper_connector_duplicate_state": {
        "description": "Copy atomic connector state",
        "pre": {
            "connector": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_private_obj_duplicate_state": {
        "description": "Copy atomic private state",
        "pre": {
            "obj": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_private_obj_duplicate_state": {
        "description": "Copy atomic private state",
        "pre": {
            "obj": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_helper_bridge_duplicate_state": {
        "description": "Copy atomic bridge state",
        "pre": {
            "bridge": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_bridge_duplicate_state": {
        "description": "Copy atomic bridge state",
        "pre": {
            "bridge": "!=null",
            "state": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__drm_atomic_helper_bridge_reset": {
        "description": "Initialize a bridge state to its default",
        "pre": {
            "bridge": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_helper_bridge_reset": {
        "description": "Initialize a bridge state to its default",
        "pre": {
            "bridge": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_legacy_pci_init": {
        "description": "Shadow-attach a legacy DRM PCI driver",
        "pre": {
            "driver": "!=null",
            "pdriver": "!=null"
        }
    }
},
{
    "kprobe:drm_legacy_pci_init": {
        "description": "Shadow-attach a legacy DRM PCI driver",
        "pre": {
            "driver": "!=null",
            "pdriver": "!=null"
        }
    }
},
{
    "kretprobe:drm_legacy_pci_exit": {
        "description": "Unregister shadow-attach legacy DRM driver",
        "pre": {
            "driver": "!=null",
            "pdriver": "!=null"
        }
    }
},
{
    "kprobe:drm_legacy_pci_exit": {
        "description": "Unregister shadow-attach legacy DRM driver",
        "pre": {
            "driver": "!=null",
            "pdriver": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_check_plane_damage": {
        "description": "Verify plane damage on atomic_check.",
        "pre": {
            "state": "!=null",
            "plane_state": "!=null",
            "&drm_plane_state.fb_damage_clips": "==null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_check_plane_damage": {
        "description": "Verify plane damage on atomic_check.",
        "pre": {
            "state": "!=null",
            "plane_state": "!=null",
            "&drm_plane_state.fb_damage_clips": "==null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_dirtyfb": {
        "description": "Helper for dirtyfb.",
        "pre": {
            "fb": "!=null",
            "file_priv": "!=null",
            "flags": "!=null",
            "color": "!=null",
            "clips": "!=null",
            "num_clips": ">=0"
        }
    }
},
{
    "kprobe:drm_atomic_helper_dirtyfb": {
        "description": "Helper for dirtyfb.",
        "pre": {
            "fb": "!=null",
            "file_priv": "!=null",
            "flags": "!=null",
            "color": "!=null",
            "clips": "!=null",
            "num_clips": ">=0"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_damage_iter_init": {
        "description": "Initialize the damage iterator.",
        "pre": {
            "iter": "!=null",
            "old_state": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_damage_iter_init": {
        "description": "Initialize the damage iterator.",
        "pre": {
            "iter": "!=null",
            "old_state": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:booldrm_atomic_helper_damage_iter_next": {
        "description": "Advance the damage iterator.",
        "pre": {
            "iter": "!=null",
            "rect": "!=null"
        }
    }
},
{
    "kprobe:booldrm_atomic_helper_damage_iter_next": {
        "description": "Advance the damage iterator.",
        "pre": {
            "iter": "!=null",
            "rect": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_damage_merged": {
        "description": "Merged plane damage",
        "pre": {
            "old_state": "!=null",
            "state": "!=null",
            "rect": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_damage_merged": {
        "description": "Merged plane damage",
        "pre": {
            "old_state": "!=null",
            "state": "!=null",
            "rect": "!=null"
        }
    }
},
{
    "kretprobe:devm_aperture_acquire_from_firmware": {
        "description": "Acquires ownership of a firmware framebuffer on behalf of a DRM driver.",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:devm_aperture_acquire_from_firmware": {
        "description": "Acquires ownership of a firmware framebuffer on behalf of a DRM driver.",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, negative errno value]"
        }
    }
},
{
    "kretprobe:drm_gem_dma_print_info": {
        "description": "Print &drm_gem_dma_object info for debugfs",
        "pre": {
            "dma_obj": "!=null",
            "p": "!=null",
            "indent": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_dma_print_info": {
        "description": "Print &drm_gem_dma_object info for debugfs",
        "pre": {
            "dma_obj": "!=null",
            "p": "!=null",
            "indent": ">=0"
        }
    }
},
{
    "kretprobe:drm_gem_dma_prime_import_sg_table_vmap": {
        "description": "PRIME import another driver's scattergather table and get the virtual address of the buffer",
        "pre": {
            "dev": "!=null",
            "attach": "!=null",
            "sgt": "!=null"
        },
        "post": {
            "return": "is_a_pointer_to(struct drm_gem_object) or is_an_ERR_PTR"
        }
    }
},
{
    "kprobe:drm_gem_dma_prime_import_sg_table_vmap": {
        "description": "PRIME import another driver's scattergather table and get the virtual address of the buffer",
        "pre": {
            "dev": "!=null",
            "attach": "!=null",
            "sgt": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create": {
        "description": "Create a new DRM property.",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "num_values": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create": {
        "description": "Create a new DRM property",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "num_values": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create_enum": {
        "description": "Create a new enumeration property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "props": "!=null",
            "num_values": ">=0"
        }
    }
},
{
    "kprobe:drm_property_create_enum": {
        "description": "Create a new enumeration property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "props": "!=null",
            "num_values": ">=0"
        }
    }
},
S,
{
    "kprobe:drm_property_create_bitmask": {
        "description": "Create a new bitmask property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "props": "!=null",
            "num_props": ">=0",
            "supported_bits": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create_range": {
        "description": "Create a new unsigned ranged property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create_range": {
        "description": "Create a new unsigned ranged property type.",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create_signed_range": {
        "description": "Create a new signed ranged property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create_signed_range": {
        "description": "Create a new signed ranged property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create_object": {
        "description": "Create a new object property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "type": "!=null",
            "type": "in [DRM_MODE_OBJECT_]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create_object": {
        "description": "Create a new object property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "type": "!=null",
            "type": "in [DRM_MODE_OBJECT_]"
        }
    }
},
{
    "kretprobe:drm_property_create_bool": {
        "description": "Create a new boolean property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create_bool": {
        "description": "Create a new boolean property type",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_create_blob": {
        "description": "Create new blob property",
        "pre": {
            "dev": "!=null",
            "length": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:drm_property_create_blob": {
        "description": "Create new blob property",
        "pre": {
            "dev": "!=null",
            "length": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_blob_put": {
        "description": "Release a blob property reference",
        "pre": {
            "blob": "!=null"
        }
    }
},
{
    "kprobe:drm_property_blob_put": {
        "description": "Release a blob property reference",
        "pre": {
            "blob": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_blob_get": {
        "description": "Acquire blob property reference",
        "pre": {
            "blob": "!=null"
        }
    }
},
{
    "kprobe:drm_property_blob_get": {
        "description": "Acquire blob property reference",
        "pre": {
            "blob": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_lookup_blob": {
        "description": "Look up a blob property and take a reference.",
        "pre": {
            "dev": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:drm_property_lookup_blob": {
        "description": "Look up a blob property and take a reference.",
        "pre": {
            "dev": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_replace_global_blob": {
        "description": "Replace existing blob property",
        "pre": {
            "dev": "!=null",
            "replace": "!=null",
            "length": ">=0",
            "data": "!=null",
            "obj_holds_id": "!=null",
            "prop_holds_id": "!=null"
        }
    }
},
{
    "kprobe:drm_property_replace_global_blob": {
        "description": "Replace existing blob property",
        "pre": {
            "dev": "!=null",
            "replace": "!=null",
            "length": ">=0",
            "data": "!=null",
            "obj_holds_id": "!=null",
            "prop_holds_id": "!=null"
        }
    }
},
{
    "kretprobe:drm_property_replace_blob": {
        "description": "Replace a blob property",
        "pre": {
            "blob": "!=null",
            "new_blob": "!=null"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:drm_property_replace_blob": {
        "description": "Replace a blob property",
        "pre": {
            "blob": "!=null",
            "new_blob": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:drm_i2c_encoder_init": {
        "description": "Initialize an I2C slave encoder",
        "pre": {
            "dev": "!=null",
            "encoder": "!=null",
            "adap": "!=null",
            "info": "!=null",
            "info.addr": "!=null",
            "info.type": "!=null"
        }
    }
},
{
    "kprobe:drm_i2c_encoder_init": {
        "description": "Initialize an I2C slave encoder",
        "pre": {
            "dev": "!=null",
            "encoder": "!=null",
            "adap": "!=null",
            "info": "!=null",
            "info.addr": "!=null",
            "info.type": "!=null"
        }
    }
},
{
    "kretprobe:drm_i2c_encoder_destroy": {
        "description": "Unregister the I2C device backing an encoder",
        "pre": {
            "drm_encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_i2c_encoder_destroy": {
        "description": "Unregister the I2C device backing an encoder",
        "pre": {
            "drm_encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_create_alpha_property": {
        "description": "Create a new alpha property for a DRM plane.",
        "pre": {
            "plane": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_plane_create_alpha_property": {
        "description": "Create a new alpha property for a DRM plane.",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_create_rotation_property": {
        "description": "Create the rotation property for a DRM plane.",
        "pre": {
            "plane": "!=null",
            "rotation": ">=0 && <=360",
            "supported_rotations": ">=0 && <=360"
        }
    }
},
{
    "kprobe:drm_plane_create_rotation_property": {
        "description": "Create the rotation property for a DRM plane.",
        "pre": {
            "plane": "!=null",
            "rotation": "in [DRM_MODE_ROTATE_0, DRM_MODE_ROTATE_90, DRM_MODE_ROTATE_180, DRM_MODE_ROTATE_270, DRM_MODE_REFLECT_X, DRM_MODE_REFLECT_Y]",
            "supported_rotations": "!=null"
        }
    }
},
{
    "drm_plane_create_zpos_property": {
        "description": "Helper function for creating zpos property for DRM planes.",
        "pre": {
            "plane": "!=null",
            "zpos": "!=null",
            "min": "=0"
        }
    }
},
{
    "kprobe:drm_plane_create_zpos_property": {
        "description": "Create the zpos property for a DRM plane.",
        "pre": {
            "plane": "!=null",
            "zpos": "!=null",
            "min": "0",
            "max": "max_planes - 1"
        }
    }
},
{
    "kretprobe:drm_helper_move_panel_connectors_to_head": {
        "description": "Move panels to the front in the connector list.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_helper_move_panel_connectors_to_head": {
        "description": "Move panels to the front in the connector list.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_helper_mode_fill_fb_struct": {
        "description": "Fill out framebuffer metadata",
        "pre": {
            "dev": "!=null",
            "fb": "!=null",
            "mode_cmd": "!=null"
        }
    }
},
{
    "kprobe:drm_helper_mode_fill_fb_struct": {
        "description": "Fill out framebuffer metadata",
        "pre": {
            "dev": "!=null",
            "fb": "!=null",
            "mode_cmd": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_init": {
        "description": "Legacy CRTC initialization function",
        "pre": {
            "dev": "!=null",
            "crtc": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_init": {
        "description": "Legacy CRTC initialization function",
        "pre": {
            "dev": "!=null",
            "crtc": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_config_helper_suspend": {
        "description": "Modeset suspend helper",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": ">= -1"
        }
    }
},
{
    "kprobe:drm_mode_config_helper_suspend": {
        "description": "Modeset suspend helper",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_config_helper_resume": {
        "description": "Modeset resume helper",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_config_helper_resume": {
        "description": "Modeset resume helper",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_command_read": {
        "description": "MIPI DCS read command",
        "pre": {
            "dbi": "!=null",
            "cmd": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_command_read": {
        "description": "MIPI DCS read command",
        "pre": {
            "dbi": "!=null",
            "cmd": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_command_buf": {
        "description": "MIPI DCS command with parameter(s) in an array",
        "pre": {
            "dbi": "!=null",
            "cmd": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dbi_command_buf": {
        "description": "MIPI DCS command with parameter(s) in an array",
        "pre": {
            "dbi": "!=null",
            "cmd": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dbi_buf_copy": {
        "description": "Copy a framebuffer, transforming it if necessary",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null",
            "swap": "in [true, false]"
        },
        "post": {
            "return_value": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:mipi_dbi_buf_copy": {
        "description": "Copy a framebuffer, transforming it if necessary",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null",
            "swap": "in [true, false]"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_mode_valid": {
        "description": "MIPI DBI mode-valid helper",
        "pre": {
            "pipe": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_mode_valid": {
        "description": "MIPI DBI mode-valid helper",
        "pre": {
            "pipe": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_update": {
        "description": "Display pipe update helper",
        "pre": {
            "pipe": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_update": {
        "description": "Display pipe update helper",
        "pre": {
            "pipe": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_enable_flush": {
        "description": "MIPI DBI enable helper",
        "pre": {
            "dbidev": "!=null",
            "crtc_state": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_enable_flush": {
        "description": "MIPI DBI enable helper",
        "pre": {
            "dbidev": "!=null",
            "crtc_state": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_disable": {
        "description": "MIPI DBI pipe disable helper",
        "pre": {
            "pipe": "!=null"
        },
        "post": {
            "backlight_disabled": "if backlight is present",
            "display_memory_blank": "if backlight is not present",
            "regulator_disabled": "if regulator is in use"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_disable": {
        "description": "MIPI DBI pipe disable helper",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_begin_fb_access": {
        "description": "MIPI DBI pipe begin-access helper",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_begin_fb_access": {
        "description": "MIPI DBI pipe begin-access helper",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_end_fb_access": {
        "description": "MIPI DBI pipe end-access helper",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
S,
{
    "kretprobe:mipi_dbi_pipe_reset_plane": {
        "description": "MIPI DBI plane-reset helper",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_reset_plane": {
        "description": "MIPI DBI plane-reset helper",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_duplicate_plane_state": {
        "description": "Duplicates MIPI DBI plane state",
        "pre": {
            "pipe": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_duplicate_plane_state": {
        "description": "duplicates MIPI DBI plane state",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_pipe_destroy_plane_state": {
        "description": "Cleans up MIPI DBI plane state",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_pipe_destroy_plane_state": {
        "description": "Cleans up MIPI DBI plane state",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_dev_init_with_formats": {
        "description": "MIPI DBI device initialization with custom formats",
        "pre": {
            "dbidev": "!=null",
            "funcs": "!=null",
            "formats": "!=null",
            "format_count": ">=0",
            "mode": "!=null",
            "rotation": ">=0",
            "tx_buf_size": ">=0"
        }
    }
},
{
    "kprobe:mipi_dbi_dev_init_with_formats": {
        "description": "MIPI DBI device initialization with custom formats",
        "pre": {
            "dbidev": "!=null",
            "funcs": "!=null",
            "formats": "!=null",
            "format_count": ">=0",
            "mode": "!=null",
            "rotation": ">=0",
            "tx_buf_size": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dbi_hw_reset": {
        "description": "Hardware reset of controller",
        "pre": {
            "dbi": "!=null",
            "dbi->reset": "==1"
        }
    }
},
{
    "kprobe:mipi_dbi_hw_reset": {
        "description": "Hardware reset of controller",
        "pre": {
            "dbi": "!=null",
            "dbi->reset": "==1"
        }
    }
},
{
    "kretprobe:mipi_dbi_display_is_on": {
        "description": "Check if display is on",
        "pre": {
            "dbi": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_display_is_on": {
        "description": "Check if display is on",
        "pre": {
            "dbi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_poweron_reset_conditional": {
        "description": "MIPI DBI poweron and reset",
        "pre": {
            "dbidev": "!=null",
            "cond": "!=null",
            "dbidev->drm.dev": "!=null",
            "dbidev->dbi": "!=null",
            "dbidev->regulator": "!=null",
            "dbidev->io_regulator": "!=null",
            "mipi_dbi_display_is_on(dbi)": "cond == true",
            "mipi_dbi_hw_reset(dbi)": "always",
            "mipi_dbi_command(dbi, MIPI_DCS_SOFT_RESET)": "always"
        }
    }
},
{
    "kprobe:mipi_dbi_poweron_reset_conditional": {
        "description": "MIPI DBI poweron and reset",
        "pre": {
            "dbidev": "!=null",
            "cond": "bool",
            "dbidev->drm.dev": "!=null",
            "dbidev->dbi": "!=null",
            "dbidev->regulator": "!=null",
            "dbidev->io_regulator": "!=null",
            "mipi_dbi_display_is_on(dbi)": "bool",
            "mipi_dbi_hw_reset(dbi)": "void",
            "mipi_dbi_command(dbi, MIPI_DCS_SOFT_RESET)": "int"
        }
    }
},
{
    "kretprobe:mipi_dbi_poweron_conditional_reset": {
        "description": "MIPI DBI poweron and conditional reset",
        "pre": {
            "dbidev": "!=null"
        }
    }
},
{
    "kprobe:mipi_dbi_poweron_conditional_reset": {
        "description": "MIPI DBI poweron and conditional reset",
        "pre": {
            "dbidev": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dbi_spi_cmd_max_speed": {
        "description": "get the maximum SPI bus speed",
        "pre": {
            "spi": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:u32 mipi_dbi_spi_cmd_max_speed": {
        "description": "get the maximum SPI bus speed",
        "pre": {
            "spi": "!=null",
            "len": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mipi_dbi_spi_init": {
        "description": "Initialize MIPI DBI SPI interface",
        "pre": {
            "spi": "!=null",
            "dbi": "!=null",
            "dc": "in [null, gpio_desc]"
        }
    }
},
{
    "kprobe:mipi_dbi_spi_init": {
        "description": "Initialize MIPI DBI SPI interface",
        "pre": {
            "spi": "!=null",
            "dbi": "!=null",
            "dc": "null or !=null"
        }
    }
},
S,
{
    "kprobe:mipi_dbi_debugfs_init": {
        "description": "Create debugfs entries",
        "pre": {
            "minor": "!=null"
        }
    }
},
{
    "kretprobe:drm_put_dev": {
        "description": "Unregister and release a DRM device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_put_dev": {
        "description": "Unregister and release a DRM device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_put_dev": {
        "description": "Unregister and release a DRM device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_put_dev": {
        "description": "Unregister and release a DRM device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_ttm_print_info": {
        "description": "Print &ttm_buffer_object info for debugfs",
        "pre": {
            "p": "!=null",
            "indent": ">=0",
            "gem": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_ttm_print_info": {
        "description": "Print &ttm_buffer_object info for debugfs",
        "pre": {
            "p": "!=null",
            "indent": ">=0",
            "gem": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_ttm_vmap": {
        "description": "Maps a GEM object with ttm_bo_vmap().",
        "pre": {
            "gem": "!=null",
            "map": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_ttm_vmap": {
        "description": "Maps a GEM object with ttm_bo_vmap().",
        "pre": {
            "gem": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_ttm_vunmap": {
        "description": "Unmaps a GEM object with ttm_bo_vunmap(). This function can be used as &drm_gem_object_funcs.vmap callback.",
        "pre": {
            "gem": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_ttm_vunmap": {
        "description": "Unmaps a GEM object with ttm_bo_vunmap().",
        "pre": {
            "gem": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_ttm_mmap": {
        "description": "mmap &ttm_buffer_object",
        "pre": {
            "gem": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_ttm_mmap": {
        "description": "mmap &ttm_buffer_object",
        "pre": {
            "gem": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_ttm_dumb_map_offset": {
        "description": "Implements struct &drm_driver.dumb_map_offset",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "handle": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_ttm_dumb_map_offset": {
        "description": "Implements struct &drm_driver.dumb_map_offset",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "handle": "!=null",
            "offset": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_framebuffer_check_src_coords": {
        "description": "Check the source coordinates of a DRM framebuffer.",
        "pre": {
            "src_x": "!=null",
            "src_y": "!=null",
            "src_w": "!=null",
            "src_h": "!=null",
            "fb": "!=null"
        }
    }
},
{
    "kretprobe:drm_framebuffer_put": {
        "description": "Drop the reference picked up in framebuffer lookup.",
        "pre": {
            "dev": "!=null",
            "file_priv": "!=null",
            "fb_id": "!=null",
            "fb": "!=null",
            "fbs_lock": "!=null",
            "fbl": "!=null",
            "found": "in [0, 1]"
        },
        "post": {
            "return": "in [-ENOENT, 0]"
        }
    }
},
{
    "kprobe:drm_framebuffer_put": {
        "description": "Drop the reference we picked up in framebuffer lookup.",
        "pre": {
            "fb": "!=null",
            "fb in file_priv.fbs": "==true",
            "file_priv.fbs_lock": "locked",
            "list_del_init(&fb->filp_head)": "executed",
            "file_priv.fbs_lock": "unlocked"
        }
    }
},
{
    "kretprobe:drm_framebuffer_cleanup": {
        "description": "Remove a framebuffer object",
        "pre": {
            "fb": "!=null"
        }
    }
},
{
    "kprobe:drm_framebuffer_cleanup": {
        "description": "Remove a framebuffer object",
        "pre": {
            "fb": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_rmfb": {
        "description": "Remove an FB from the configuration",
        "pre": {
            "dev": "!=null",
            "fb_id": "!=null",
            "file_priv": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_rmfb": {
        "description": "Remove an FB from the configuration",
        "pre": {
            "dev": "!=null",
            "fb_id": "!=null",
            "file_priv": "!=null"
        }
    }
},
{
    "kretprobe:drm_framebuffer_plane_width": {
        "description": "Width of the plane given the first plane",
        "pre": {
            "width": "!=null",
            "fb": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kprobe:drm_framebuffer_plane_width": {
        "description": "Width of the plane given the first plane",
        "pre": {
            "width": "!=null",
            "fb": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_framebuffer_plane_height": {
        "description": "Height of the plane given the first plane",
        "pre": {
            "height": "!=null",
            "fb": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kprobe:drm_framebuffer_plane_height": {
        "description": "Height of the plane given the first plane",
        "pre": {
            "height": "!=null",
            "fb": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_flip_work_allocate_task": {
        "description": "Allocate a flip-work task",
        "pre": {
            "data": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:drm_flip_work_allocate_task": {
        "description": "Allocate a flip-work task",
        "pre": {
            "data": "!=null",
            "flags": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_flip_work_init": {
        "description": "Initialize flip-work",
        "pre": {
            "work": "!=null",
            "name": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kprobe:drm_flip_work_init": {
        "description": "Initialize flip-work",
        "pre": {
            "work": "!=null",
            "name": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kretprobe:drm_flip_work_cleanup": {
        "description": "Cleans up flip-work",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kprobe:drm_flip_work_cleanup": {
        "description": "Cleans up flip-work",
        "pre": {
            "work": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:valid = 0;list_for_each_entry(agp_entry, &dev->agp->memory, head)": {
        "description": "Iterate over the list of AGP entries in dev->agp->memory and set valid to 0.",
        "pre": {
            "valid": "== 0",
            "agp_entry": "!= null",
            "dev": "!= null",
            "dev->agp->memory": "!= null"
        }
    }
},
{
    "kprobe:valid = 0;list_for_each_entry(agp_entry, &dev->agp->memory, head)": {
        "description": "Iterate over the list of agp_entry in dev->agp->memory and set valid to 0.",
        "pre": {
            "dev": "!=null",
            "agp_entry": "!=null"
        }
    }
},
{
    "kretprobe:drm_legacy_addbufs_pci": {
        "description": "Add buffers to the legacy DRM device.",
        "pre": {
            "dev": "!=null",
            "request": "!=null",
            "dev->dma": "!=null",
            "count": "<=4096",
            "count": ">=0"
        }
    }
},
{
    "kprobe:drm_legacy_addbufs_pci": {
        "description": "Add buffers to the DRM device using legacy PCI interface.",
        "pre": {
            "dev": "!=null",
            "request": "!=null",
            "dev->dma": "!=null",
            "count": "< 0 || > 4096"
        }
    }
},
{
    "kretprobe:intdrm_atomic_helper_check_modeset": {
        "description": "Validate state object for modeset changes",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:intdrm_atomic_helper_check_modeset": {
        "description": "Validate state object for modeset changes",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_helper_check_wb_encoder_state": {
        "description": "Check writeback encoder state",
        "pre": {
            "encoder": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kprobe:intdrm_atomic_helper_check_wb_encoder_state": {
        "description": "Check writeback encoder state",
        "pre": {
            "encoder": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_check_plane_state": {
        "description": "Check plane state for validity",
        "pre": {
            "plane_state": "!=null",
            "crtc_state": "!=null",
            "min_scale": ">=0",
            "max_scale": ">=0",
            "can_position": "is_boolean",
            "can_update_disabled": "is_boolean"
        }
    }
},
{
    "kprobe:drm_atomic_helper_check_plane_state": {
        "description": "Check plane state for validity",
        "pre": {
            "plane_state": "!=null",
            "crtc_state": "!=null",
            "min_scale": "int",
            "max_scale": "int",
            "can_position": "bool",
            "can_update_disabled": "bool"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_check_crtc_primary_plane": {
        "description": "Check CRTC state for primary plane",
        "pre": {
            "crtc_state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_check_crtc_primary_plane": {
        "description": "Check CRTC state for primary plane",
        "pre": {
            "crtc_state": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_helper_check_planes": {
        "description": "Validate state object for planes changes",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:intdrm_atomic_helper_check_planes": {
        "description": "Validate state object for planes changes",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_atomic_helper_update_legacy_modeset_state": {
        "description": "Update legacy modeset state",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_update_legacy_modeset_state": {
        "description": "Update legacy modeset state",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_calc_timestamping_constants": {
        "description": "Update vblank timestamping constants",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_calc_timestamping_constants": {
        "description": "Update vblank timestamping constants",
        "pre": {
            "state": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_atomic_helper_commit_modeset_enables": {
        "description": "Modeset commit to enable outputs",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_commit_modeset_enables": {
        "description": "Modeset commit to enable outputs",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_wait_for_fences": {
        "description": "Wait for fences in the atomic helper function.",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_wait_for_fences": {
        "description": "Wait for fences in the atomic state before swapping.",
        "pre": {
            "dev": "!=null",
            "state": "!=null",
            "pre_swap": "in [true, false]"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:drm_atomic_crtc_effectively_active": {
        "description": "Check if the CRTC is effectively active.",
        "pre": {
            "new_state": "==null"
        }
    }
},
{
    "kprobe:drm_atomic_crtc_effectively_active": {
        "description": "Check if the CRTC is effectively active.",
        "pre": {
            "new_state": "==null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_async_commit": {
        "description": "Commit state asynchronously",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_async_commit": {
        "description": "Commit state asynchronously",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:for_each_new_crtc_in_state": {
        "description": "Commit work for each new CRTC in state.",
        "pre": {
            "old_state": "!=null",
            "crtc": "!=null",
            "new_crtc_state": "!=null",
            "i": "!=null",
            "new_crtc_state->self_refresh_active": "==true",
            "funcs": "!=null",
            "funcs->atomic_commit_tail": "!=null"
        }
    }
},
{
    "kprobe:for_each_new_crtc_in_state": {
        "description": "Commit work for each new CRTC in state.",
        "pre": {
            "old_state": "!=null",
            "crtc": "!=null",
            "new_crtc_state": "!=null",
            "i": "!=null",
            "new_crtc_state->self_refresh_active": "true",
            "funcs && funcs->atomic_commit_tail": "true",
            "commit_time_ms": ">0"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_commit_tail_rpm": {
        "description": "commit atomic update to hardware",
        "pre": {
            "old_state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_commit_tail_rpm": {
        "description": "commit atomic update to hardware",
        "pre": {
            "old_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_async_check": {
        "description": "Check if state can be committed asynchronously.",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_async_check": {
        "description": "Check if state can be committed asynchronously.",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_swap_state": {
        "description": "This function swaps the state of the DRM atomic helper.",
        "pre": {
            "state": "!=null",
            "true": "true"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:drm_atomic_helper_swap_state": {
        "description": "Swap the state of the DRM atomic helper.",
        "pre": {
            "state": "!=null",
            "true": "true"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_commit_planes": {
        "description": "Commit planes for a DRM device.",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_commit_planes": {
        "description": "Commit planes associated with a CRTC in the DRM subsystem.",
        "pre": {
            "dev": "!=null",
            "old_state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_disable_planes_on_crtc": {
        "description": "Helper to disable CRTC's planes",
        "pre": {
            "old_crtc_state": "!=null",
            "atomic": "bool"
        }
    }
},
{
    "kprobe:drm_atomic_helper_disable_planes_on_crtc": {
        "description": "Helper to disable CRTC's planes",
        "pre": {
            "old_crtc_state": "!=null",
            "atomic": "is_boolean"
        }
    }
},
{
    "kretprobe:drm_atomic_helper_update_plane": {
        "description": "Helper for primary plane update using atomic",
        "pre": {
            "plane": "!=null",
            "crtc": "!=null",
            "fb": "!=null",
            "crtc_x": "int",
            "crtc_y": "int",
            "crtc_w": "unsigned int",
            "crtc_h": "unsigned int",
            "src_x": "unsigned int",
            "src_y": "unsigned int",
            "src_w": "unsigned int",
            "src_h": "unsigned int",
            "ctx": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_helper_update_plane": {
        "description": "Helper for primary plane update using atomic",
        "pre": {
            "plane": "!=null",
            "crtc": "!=null",
            "fb": "!=null",
            "crtc_x": "int",
            "crtc_y": "int",
            "crtc_w": "unsigned int",
            "crtc_h": "unsigned int",
            "src_x": "uint32_t",
            "src_y": "uint32_t",
            "src_w": "uint32_t",
            "src_h": "uint32_t",
            "ctx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_atomic_helper_duplicate_state": {
        "description": "Duplicate an atomic state object",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null",
            "return_value": "!=null",
            "dev": "valid DRM device",
            "ctx": "valid lock acquisition context"
        }
    }
},
{
    "kprobe:drm_atomic_helper_duplicate_state": {
        "description": "Duplicate an atomic state object",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:drm_atomic_helper_page_flip": {
        "description": "Perform a page flip operation on the given CRTC with the provided framebuffer and event.",
        "pre": {
            "crtc": "!=null",
            "fb": "!=null",
            "event": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "ctx": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_atomic_helper_bridge_propagate_bus_fmt": {
        "description": "Propagate output format to the input end of a bridge",
        "pre": {
            "bridge": "!=null",
            "bridge_state": "!=null",
            "crtc_state": "!=null",
            "conn_state": "!=null",
            "output_fmt": "!=null",
            "num_input_fmts": "!=null"
        }
    }
},
{
    "kprobe:u32 *drm_atomic_helper_bridge_propagate_bus_fmt": {
        "description": "Propagate output format to the input end of a bridge",
        "pre": {
            "bridge": "!=null",
            "bridge_state": "!=null",
            "crtc_state": "!=null",
            "conn_state": "!=null",
            "output_fmt": "!=null",
            "num_input_fmts": "!=null"
        }
    }
},
{
    "kretprobe:drm_of_crtc_port_mask": {
        "description": "Find the mask of a registered CRTC by port OF node.",
        "pre": {
            "dev": "!=null",
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_of_crtc_port_mask": {
        "description": "Find the mask of a registered CRTC by port OF node.",
        "pre": {
            "dev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_of_find_possible_crtcs": {
        "description": "Find the possible CRTCs for an encoder port",
        "pre": {
            "dev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:drm_of_find_possible_crtcs": {
        "description": "Find the possible CRTCs for an encoder port.",
        "pre": {
            "dev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_of_component_probe": {
        "description": "Generic probe function for a component based master",
        "pre": {
            "dev": "!=null",
            "compare_of": "!=null",
            "m_ops": "!=null"
        }
    }
},
{
    "kprobe:drm_of_component_probe": {
        "description": "Generic probe function for a component based master",
        "pre": {
            "dev": "!=null",
            "compare_of": "!=null",
            "m_ops": "!=null"
        }
    }
},
{
    "kretprobe:drm_legacy_agp_init": {
        "description": "Initialize AGP for the DRM device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null",
            "head": "!=null",
            "head->bridge": "!=null",
            "head->agp_info": "!=null",
            "head->agp_info.chipset": "!=NOT_SUPPORTED",
            "head->memory": "is empty",
            "head->cant_use_aperture": "head->agp_info.cant_use_aperture",
            "head->page_mask": "head->agp_info.page_mask",
            "head->base": "head->agp_info.aper_base"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(drm_legacy_agp_init)": {
        "description": "Initialize the legacy AGP for the DRM device.",
        "pre": {
            "dev": "!=null",
            "dev->dev": "!=null",
            "head": "!=null",
            "head->bridge": "!=null",
            "head->agp_info": "!=null",
            "head->agp_info.chipset": "!=NOT_SUPPORTED",
            "head->memory": "is_empty",
            "head->cant_use_aperture": "!=null",
            "head->page_mask": "!=null",
            "head->base": "!=null"
        }
    }
},
{
    "kretprobe:drm_bridge_add": {
        "description": "Add the given bridge to the global bridge list.",
        "pre": {
            "bridge": "!=null",
            "bridge": "valid_bridge_control_structure"
        }
    }
},
{
    "kprobe:drm_bridge_add": {
        "description": "Add the given bridge to the global bridge list.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:devm_drm_bridge_add": {
        "description": "devm managed version of drm_bridge_add()",
        "pre": {
            "dev": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:devm_drm_bridge_add": {
        "description": "devm managed version of drm_bridge_add()",
        "pre": {
            "dev": "!=null",
            "bridge": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_bridge_chain_mode_fixup": {
        "description": "Fixes up the proposed mode for all bridges in the encoder chain.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null",
            "adjusted_mode": "!=null"
        }
    }
},
{
    "kprobe:drm_bridge_chain_mode_fixup": {
        "description": "Fixes up the proposed mode for all bridges in the encoder chain.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null",
            "adjusted_mode": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:of_drm_find_bridge": {
        "description": "Find the bridge corresponding to the device node in the global bridge list.",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:of_drm_find_bridge": {
        "description": "Find the bridge corresponding to the device node in the global bridge list.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:drm_is_current_master_locked": {
        "description": "Clients can authenticate against the current master (if it matches their own) using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters, this allows controlled access to the device for an entire group of mutually trusted clients.",
        "pre": {
            "fpriv": "!=null"
        }
    }
},
{
    "kprobe:drm_is_current_master_locked": {
        "description": "Check if the current master matches the authenticated client.",
        "pre": {
            "fpriv": "!=null"
        }
    }
},
{
    "kretprobe:drm_master_check_perm": {
        "description": "Check if the current file_priv has permission to become the master of the drm_device.",
        "pre": {
            "dev": "!=null",
            "file_priv": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_file_get_master": {
        "description": "Reference &drm_file.master of @file_priv",
        "pre": {
            "file_priv": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_file_get_master": {
        "description": "Reference &drm_file.master of @file_priv",
        "pre": {
            "file_priv": "!=null"
        }
    }
},
{
    "kretprobe:drm_clflush_pages": {
        "description": "Flush dcache lines of a set of pages.",
        "pre": {
            "pages": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kprobe:drm_clflush_pages": {
        "description": "Flush dcache lines of a set of pages.",
        "pre": {
            "pages": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kretprobe:drm_clflush_sg": {
        "description": "Flush dcache lines pointing to a scatter-gather.",
        "pre": {
            "st": "!=null"
        }
    }
},
{
    "kprobe:drm_clflush_sg": {
        "description": "Flush dcache lines pointing to a scatter-gather.",
        "pre": {
            "st": "!=null"
        }
    }
},
{
    "kretprobe:drm_clflush_virt_range": {
        "description": "Flush dcache lines of a region",
        "pre": {
            "addr": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:drm_clflush_virt_range": {
        "description": "Flush dcache lines of a region",
        "pre": {
            "addr": "!=null",
            "length": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:__drm_memcpy_from_wc": {
        "description": "Copies @len bytes from @src to @dst using non-temporal instructions where available.",
        "pre": {
            "dst": "aligned to 16 bytes",
            "src": "aligned to 16 bytes",
            "len": "multiple of 16"
        }
    }
},
{
    "kprobe:__drm_memcpy_from_wc": {
        "description": "Copies @len bytes from @src to @dst using non-temporal instructions where available.",
        "pre": {
            "dst": "aligned to 16 bytes",
            "src": "aligned to 16 bytes",
            "len": "multiple of 16"
        }
    }
},
{
    "kretprobe:drm_color_ctm_s31_32_to_qm_n": {
        "description": "Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement).",
        "pre": {
            "user_input": "!=null",
            "m": "<=32",
            "n": "<=32",
            "m": ">=0",
            "n": ">=0"
        },
        "post": {
            "return_value": ">=-2^(m-1)",
            "return_value": "<=2^(m-1) - 2^(-n)"
        }
    }
},
{
    "kprobe:drm_color_ctm_s31_32_to_qm_n": {
        "description": "Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement).",
        "pre": {
            "user_input": "!=null",
            "m": "<=32",
            "n": "<=32",
            "m+n-1": ">=0",
            "m+n-1": "<=63",
            "user_input": ">=-2^(m-1)",
            "user_input": "<=2^(m-1) - 2^-n"
        }
    }
},
{
    "kretprobe:drm_color_ctm_s31_32_to_qm_n": {
        "description": "Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement).",
        "pre": {
            "input_value": "!=null",
            "m": ">=0 and <=32",
            "n": ">=0 and <=32"
        },
        "post": {
            "output_value": ">=-2^(m-1) and <=2^(m-1) - 2^(-n)"
        }
    }
},
{
    "kprobe:drm_color_ctm_s31_32_to_qm_n": {
        "description": "Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement).",
        "pre": {
            "input value": "!=null",
            "number of integer bits": "<=32",
            "number of fractional bits": "<=32",
            "range of value": "[-2^(m-1), 2^(m-1) - 2^-n]"
        }
    }
},
{
    "kretprobe:drm_color_lut_check": {
        "description": "Check validity of lookup table",
        "pre": {
            "lut": "!=null",
            "tests": "!=null",
            "tests": "is bitmask",
            "tests": "in [DRM_COLOR_LUT_TEST_1, DRM_COLOR_LUT_TEST_2, ...]",
            "return": "== 0"
        }
    }
},
{
    "kprobe:drm_color_lut_check": {
        "description": "Check validity of lookup table",
        "pre": {
            "lut": "!=null",
            "tests": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_legacy_fb_format": {
        "description": "Compute drm fourcc code from legacy description",
        "pre": {
            "bpp": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_legacy_fb_format": {
        "description": "Compute drm fourcc code from legacy description",
        "pre": {
            "bpp": ">0",
            "depth": ">0",
            "bpp": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kretprobe:drm_driver_legacy_fb_format": {
        "description": "Compute drm fourcc code from legacy description",
        "pre": {
            "dev": "!=null",
            "bpp": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kprobe:drm_driver_legacy_fb_format": {
        "description": "Compute drm fourcc code from legacy description",
        "pre": {
            "dev": "!=null",
            "bpp": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kretprobe:__drm_format_info": {
        "description": "drm_format_info() for the public API.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kprobe:__drm_format_info": {
        "description": "Get the DRM format info for the given format.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_format_info": {
        "description": "Query information for a given framebuffer configuration",
        "pre": {
            "dev": "!=null",
            "mode_cmd": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_get_format_info": {
        "description": "Query information for a given framebuffer configuration",
        "pre": {
            "dev": "!=null",
            "mode_cmd": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_format_info_block_width": {
        "description": "Returns the width in pixels of a block, depending on the plane index.",
        "pre": {
            "info": "!=null",
            "plane": "int"
        }
    }
},
{
    "kprobe:drm_format_info_block_width": {
        "description": "Width in pixels of block.",
        "pre": {
            "info": "!=null",
            "plane": "!=null",
            "plane": ">=0"
        }
    }
},
{
    "kretprobe:drm_format_info_block_height": {
        "description": "Height in pixels of a block",
        "pre": {
            "info": "!=null",
            "plane": "!=null",
            "plane": ">=0"
        }
    }
},
{
    "kprobe:drm_format_info_block_height": {
        "description": "Height in pixels of a block",
        "pre": {
            "info": "!=null",
            "plane": "!=null",
            "plane": ">=0"
        }
    }
},
{
    "kretprobe:drm_format_info_bpp": {
        "description": "Number of bits per pixel",
        "pre": {
            "info": "!=null",
            "plane": "!=null",
            "plane": ">=0"
        }
    }
},
{
    "kprobe:drm_format_info_bpp": {
        "description": "Number of bits per pixel",
        "pre": {
            "info": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_format_info_min_pitch": {
        "description": "Computes the minimum required pitch in bytes for a buffer by taking into consideration the pixel format information and the buffer width.",
        "pre": {
            "info": "!=null",
            "plane": ">=0",
            "buffer_width": ">=0"
        }
    }
},
{
    "kprobe:drm_format_info_min_pitch": {
        "description": "Computes the minimum required pitch in bytes for a buffer by taking into consideration the pixel format information and the buffer width.",
        "pre": {
            "info": "!=null",
            "plane": ">=0",
            "buffer_width": ">=0"
        }
    }
},
{
    "kretprobe:drm_simple_encoder_funcs_cleanup": {
        "description": "Clean up the encoder functions for a simple display pipeline.",
        "pre": {
            "pipeline_initialized": "==true",
            "encoder_functions_valid": "==true",
            "resources_released": "==true"
        }
    }
},
S,
{
    "kretprobe:drm_simple_display_pipe_attach_bridge": {
        "description": "Attach a bridge to the display pipe",
        "pre": {
            "pipe": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:drm_simple_display_pipe_attach_bridge": {
        "description": "Attach a bridge to the display pipe",
        "pre": {
            "pipe": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_config_reset": {
        "description": "Call ->reset callbacks for crtc's, encoder's, and connector's.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_config_reset": {
        "description": "Call ->reset callbacks",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drmm_mode_config_init": {
        "description": "Managed DRM mode_configuration structure initialization",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drmm_mode_config_init": {
        "description": "Managed DRM mode_configuration structure initialization",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_universal_plane_init": {
        "description": "Initialize a plane in the DRM system.",
        "pre": {
            "plane_type": "in [PRIMARY, CURSOR, OVERLAY]",
            "possible_crtcs": "!=null",
            "primary_planes": "count == num_crtcs",
            "cursor_planes": "count <= num_crtcs"
        }
    }
},
{
    "drm_universal_plane_init": {
        "description": "Initialize a plane in the DRM system.",
        "pre": {
            "type": "in [PRIMARY, CURSOR, OVERLAY]",
            "possible_crtcs": "!=null",
            "primary_planes": "count == num_crtcs",
            "cursor_planes": "count <= num_crtcs"
        }
    }
},
{
    "kretprobe:drm_universal_plane_init": {
        "description": "Initialize a universal plane in the DRM subsystem.",
        "pre": {
            "dev": "!=null",
            "plane": "!=null",
            "possible_crtcs": ">=0",
            "funcs": "!=null",
            "formats": "!=null",
            "format_count": ">=0",
            "format_modifiers": "!=null",
            "type": "in [DRM_PLANE_TYPE_PRIMARY, DRM_PLANE_TYPE_OVERLAY, DRM_PLANE_TYPE_CURSOR]",
            "name": "!=null"
        }
    }
},
{
    "kprobe:drm_universal_plane_init": {
        "description": "Initialize a universal plane in the DRM subsystem.",
        "pre": {
            "dev": "!=null",
            "plane": "!=null",
            "possible_crtcs": ">=0",
            "funcs": "!=null",
            "formats": "!=null",
            "format_count": ">=0",
            "format_modifiers": "!=null",
            "type": "in [DRM_PLANE_TYPE_PRIMARY, DRM_PLANE_TYPE_OVERLAY, DRM_PLANE_TYPE_CURSOR]",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_from_index": {
        "description": "Find the registered plane at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_from_index": {
        "description": "Find the registered plane at an index",
        "pre": {
            "dev": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_force_disable": {
        "description": "Forcibly disable a plane",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_force_disable": {
        "description": "Forcibly disable a plane",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_plane_set_obj_prop": {
        "description": "Set the value of a property for a DRM plane object.",
        "pre": {
            "plane": "!=null",
            "property": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_plane_set_obj_prop": {
        "description": "Set the value of a property for a DRM plane object.",
        "pre": {
            "plane": "!=null",
            "property": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:drm_any_plane_has_format": {
        "description": "Check whether any plane supports this format and modifier combination",
        "pre": {
            "dev": "!=null",
            "format": "!=null",
            "modifier": "!=null"
        }
    }
},
{
    "kprobe:drm_any_plane_has_format": {
        "description": "Check whether any plane supports this format and modifier combination.",
        "pre": {
            "dev": "!=null",
            "format": "!=null",
            "modifier": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_enable_fb_damage_clips": {
        "description": "Enables plane fb damage clips property.",
        "pre": {
            "plane": "!=null",
            "drm_plane_state.src": "!=null",
            "drm_atomic_helper_damage_iter_init()": "called",
            "drm_atomic_helper_damage_iter_next()": "called"
        }
    }
},
{
    "kprobe:drm_plane_enable_fb_damage_clips": {
        "description": "Enables plane fb damage clips property.",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_get_damage_clips_count": {
        "description": "Returns damage clips count.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_get_damage_clips_count": {
        "description": "Returns damage clips count.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_create_scaling_filter_property": {
        "description": "Create a new scaling filter property.",
        "pre": {
            "plane": "!=null",
            "supported_filters": "!=null",
            "supported_filters": "& BIT(DRM_SCALING_FILTER_DEFAULT) != 0"
        }
    }
},
{
    "kprobe:drm_plane_create_scaling_filter_property": {
        "description": "Create a new scaling filter property.",
        "pre": {
            "plane": "!=null",
            "supported_filters": "!=null",
            "supported_filters & BIT(DRM_SCALING_FILTER_DEFAULT)": "!=0"
        }
    }
},
{
    "kretprobe:drm_mode_debug_printmodeline": {
        "description": "Print a mode to dmesg",
        "pre": {
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_debug_printmodeline": {
        "description": "Print a mode to dmesg",
        "pre": {
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_create": {
        "description": "Create a new display mode",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_create": {
        "description": "Create a new display mode",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_destroy": {
        "description": "Remove a mode",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_destroy": {
        "description": "Remove a mode",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_probed_add": {
        "description": "Add a mode to a connector's probed_mode list",
        "pre": {
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_probed_add": {
        "description": "Add a mode to a connector's probed_mode list",
        "pre": {
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_analog_tv_mode": {
        "description": "Create a display mode for an analog TV.",
        "pre": {
            "dev": "!=null",
            "tv_mode": "in [DRM_MODE_TV_MODE_]",
            "pixel_clock_hz": ">=0",
            "hdisplay": ">=0",
            "vdisplay": ">=0",
            "interlace": "bool"
        }
    }
},
{
    "kprobe:drm_analog_tv_mode": {
        "description": "Create a display mode for an analog TV.",
        "pre": {
            "dev": "!=null",
            "tv_mode": "in [DRM_MODE_TV_MODE_]",
            "pixel_clock_hz": ">=0",
            "hdisplay": ">=0",
            "vdisplay": ">=0",
            "interlace": "bool"
        }
    }
},
{
    "kretprobe:drm_cvt_mode": {
        "description": "Create a modeline based on the CVT algorithm.",
        "pre": {
            "dev": "!=null",
            "hdisplay": "!=null",
            "vdisplay": "!=null",
            "vrefresh": "!=null",
            "reduced": "in [true, false]",
            "interlaced": "in [true, false]",
            "margins": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_cvt_mode": {
        "description": "Create a modeline based on the CVT algorithm.",
        "pre": {
            "dev": "!=null",
            "hdisplay": ">=0",
            "vdisplay": ">=0",
            "vrefresh": ">=0",
            "reduced": "in [true, false]",
            "interlaced": "in [true, false]",
            "margins": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_gtf_mode_complex": {
        "description": "Create the modeline based on the full GTF algorithm",
        "pre": {
            "dev": "!=null",
            "hdisplay": "!=null",
            "vdisplay": "!=null",
            "vrefresh": "!=null",
            "interlaced": "in [true, false]",
            "margins": "!=null",
            "GTF_M": "!=null",
            "GTF_2C": "!=null",
            "GTF_K": "!=null",
            "GTF_2J": "!=null"
        }
    }
},
{
    "kprobe:drm_gtf_mode_complex": {
        "description": "Create the modeline based on the full GTF algorithm.",
        "pre": {
            "dev": "!=null",
            "hdisplay": "!=null",
            "vdisplay": "!=null",
            "vrefresh": "!=null",
            "interlaced": "is boolean",
            "margins": "!=null",
            "GTF_M": "!=null",
            "GTF_2C": "!=null",
            "GTF_K": "!=null",
            "GTF_2J": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_vrefresh": {
        "description": "Get the vrefresh of a mode",
        "pre": {
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_vrefresh": {
        "description": "Get the vrefresh of a mode",
        "pre": {
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_get_hv_timing": {
        "description": "Fetches hdisplay and vdisplay for given mode",
        "pre": {
            "mode": "!=null",
            "hdisplay": "!=null",
            "vdisplay": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_get_hv_timing": {
        "description": "Fetches hdisplay and vdisplay for given mode",
        "pre": {
            "mode": "!=null",
            "hdisplay": "!=null",
            "vdisplay": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_set_crtcinfo": {
        "description": "Set CRTC modesetting timing parameters",
        "pre": {
            "p": "!=null",
            "adjust_flags": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_set_crtcinfo": {
        "description": "Set CRTC modesetting timing parameters",
        "pre": {
            "p": "!=null",
            "adjust_flags": "is an integer"
        }
    }
},
{
    "kretprobe:drm_mode_copy": {
        "description": "Copy an existing mode into another mode, preserving the list head of the destination mode.",
        "pre": {
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_copy": {
        "description": "Copy an existing mode into another mode, preserving the list head of the destination mode.",
        "pre": {
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_duplicate": {
        "description": "Allocate and duplicate an existing mode.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_duplicate": {
        "description": "Allocate and duplicate an existing mode.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_match_flags": {
        "description": "Check if the clock values of two drm_display_mode objects match.",
        "pre": {
            "mode1->clock": "!=null",
            "mode2->clock": "!=null"
        },
        "post": {
            "if (mode1->clock && mode2->clock)": "KHZ2PICOS(mode1->clock) == KHZ2PICOS(mode2->clock)",
            "else": "mode1->clock == mode2->clock"
        }
    }
},
{
    "kprobe:drm_mode_match_flags": {
        "description": "Check if the clock values of two drm_display_mode objects match.",
        "pre": {
            "mode1->clock": "!=null",
            "mode2->clock": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_equal": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_equal": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_equal_no_clocks": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_equal_no_clocks": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_equal_no_clocks_no_stereo": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_equal_no_clocks_no_stereo": {
        "description": "Test modes for equality",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_validate_driver": {
        "description": "Make sure the mode is somewhat sane",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_validate_driver": {
        "description": "Make sure the mode is somewhat sane",
        "pre": {
            "dev": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_validate_size": {
        "description": "Make sure modes adhere to size constraints",
        "pre": {
            "mode": "!=null",
            "maxX": "!=null",
            "maxY": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_validate_size": {
        "description": "Make sure modes adhere to size constraints",
        "pre": {
            "mode": "!=null",
            "maxX": "!=null",
            "maxY": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_validate_ycbcr420": {
        "description": "Add 'ycbcr420-only' modes only when allowed",
        "pre": {
            "mode": "!=null",
            "connector": "!=null"
        },
        "post": {
            "return_value": "in [MODE_OK, MODE_YCBCR420_ONLY, MODE_BAD]"
        }
    }
},
{
    "kprobe:drm_mode_validate_ycbcr420": {
        "description": "Add 'ycbcr420-only' modes only when allowed",
        "pre": {
            "mode": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_prune_invalid": {
        "description": "Remove invalid modes from mode list",
        "pre": {
            "dev": "!=null",
            "mode_list": "!=null",
            "verbose": "bool"
        }
    }
},
{
    "kprobe:drm_mode_prune_invalid": {
        "description": "Remove invalid modes from mode list",
        "pre": {
            "dev": "!=null",
            "mode_list": "!=null",
            "verbose": "bool"
        }
    }
},
{
    "kretprobe:drm_mode_sort": {
        "description": "Sort @mode_list by favorability, moving good modes to the head of the list.",
        "pre": {
            "mode_list": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_sort": {
        "description": "Sorts the mode list by favorability, moving good modes to the head of the list.",
        "pre": {
            "mode_list": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_list_update": {
        "description": "Update the mode list for the connector",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_list_update": {
        "description": "Update the mode list for the connector.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_parse_command_line_for_connector": {
        "description": "Parse command line modeline for connector",
        "pre": {
            "mode_option": "!=null",
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_parse_command_line_for_connector": {
        "description": "Parse command line modeline for connector",
        "pre": {
            "mode_option": "!=null",
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_create_from_cmdline_mode": {
        "description": "Convert a command line modeline into a DRM display mode",
        "pre": {
            "dev": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_create_from_cmdline_mode": {
        "description": "Convert a command line modeline into a DRM display mode.",
        "pre": {
            "dev": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_is_420_also": {
        "description": "Check if a given videomode can be supported in YCBCR420 output format.",
        "pre": {
            "display": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_is_420_also": {
        "description": "Check if a given videomode can be supported in YCBCR420 output format.",
        "pre": {
            "display": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_fbdev_generic_setup": {
        "description": "Setup generic fbdev emulation",
        "pre": {
            "dev": "!=null",
            "preferred_bpp": "!=null"
        }
    }
},
{
    "kprobe:drm_fbdev_generic_setup": {
        "description": "Setup generic fbdev emulation",
        "pre": {
            "dev": "!=null",
            "preferred_bpp": "!=null"
        }
    }
},
S,
S,
"connector": "!=null",
{
    "kprobe:intdrm_helper_probe_detect": {
        "description": "Probe connector status",
        "pre": {
            "connector": "!=null",
            "ctx": "!=null",
            "force": "bool"
        }
    }
},
{
    "kretprobe:drm_mode_validate_flag": {
        "description": "Validate the DRM display mode with the given flags.",
        "pre": {
            "mode": "!=null",
            "flags": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_kms_helper_hotplug_event": {
        "description": "Handle hotplug events related to the DRM device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_kms_helper_hotplug_event": {
        "description": "Handle hotplug events for KMS helper in DRM.",
        "pre": {
            "dev": "!=null",
            "mode_setting_locks": "==0",
            "connector_changed": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_kms_helper_is_poll_worker": {
        "description": "Determine if the current task is an output poll worker.",
        "pre": {
            "current_task": "!=null",
            "output_poll_worker": "==true"
        }
    }
},
{
    "kprobe:drm_kms_helper_is_poll_worker": {
        "description": "Determine if the current task is an output poll worker.",
        "pre": {
            "current_task": "!=null",
            "output_poll_worker": "==true"
        }
    }
},
{
    "kretprobe:drm_kms_helper_poll_init": {
        "description": "Initialize and enable output polling for the given drm_device object.",
        "pre": {
            "dev": "!=null",
            "dev.type": "==drm_device",
            "dev.output_polling_enabled": "==true",
            "dev.connectors[].flags": "contains [DRM_CONNECTOR_POLL_CONNECT, DRM_CONNECTOR_POLL_DISCONNECT]",
            "dev.connectors[].flags": "not contains DRM_CONNECTOR_POLL_HPD",
            "dev.connectors[].flags": "not contains [DRM_CONNECTOR_POLL_CONNECT, DRM_CONNECTOR_POLL_DISCONNECT]"
        }
    }
},
{
    "kprobe:drm_kms_helper_poll_init": {
        "description": "initialize and enable output polling",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_kms_helper_poll_fini": {
        "description": "Disable output polling and clean it up.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_kms_helper_poll_fini": {
        "description": "Disable output polling and clean it up.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_helper_hpd_irq_event": {
        "description": "hotplug processing",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_helper_hpd_irq_event": {
        "description": "hotplug processing",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_helper_mode_valid_fixed": {
        "description": "Validates a display mode",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null",
            "fixed_mode": "!=null"
        },
        "post": {
            "return_value": "in [MODE_OK, ...]"
        }
    }
},
{
    "kprobe:drm_crtc_helper_mode_valid_fixed": {
        "description": "Validates a display mode",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null",
            "fixed_mode": "!=null"
        },
        "post": {
            "return": "in [MODE_OK, other mode-status codes]"
        }
    }
},
{
    "kretprobe:drm_connector_helper_get_modes_from_ddc": {
        "description": "Updates the connector's EDID property from the connector's DDC channel",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_connector_helper_get_modes_from_ddc": {
        "description": "Updates the connector's EDID property from the connector's DDC channel.",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:drm_connector_helper_get_modes_fixed": {
        "description": "Duplicates a display mode for a connector",
        "pre": {
            "connector": "!=null",
            "fixed_mode": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_helper_get_modes_fixed": {
        "description": "Duplicates a display mode for a connector",
        "pre": {
            "connector": "!=null",
            "fixed_mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_helper_tv_get_modes": {
        "description": "Fills the modes availables to a TV connector",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_helper_tv_get_modes": {
        "description": "Fills the modes availables to a TV connector",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_vblank_work_schedule": {
        "description": "Schedule a vblank work",
        "pre": {
            "work": "!=null",
            "count": ">=0",
            "nextonmiss": "in [true, false]"
        },
        "post": {
            "return": "in [1, 0, negative error code]"
        }
    }
},
{
    "kprobe:drm_vblank_work_schedule": {
        "description": "schedule a vblank work",
        "pre": {
            "work": "!=null",
            "count": "any",
            "nextonmiss": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_vblank_work_cancel_sync": {
        "description": "Cancel a vblank work and wait for it to finish executing.",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kprobe:drm_vblank_work_cancel_sync": {
        "description": "Cancel a vblank work and wait for it to finish executing",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kretprobe:drm_vblank_work_flush": {
        "description": "Wait for a scheduled vblank work to finish executing",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kprobe:drm_vblank_work_flush": {
        "description": "Wait for a scheduled vblank work to finish executing.",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kretprobe:drm_vblank_work_init": {
        "description": "Initialize a vblank work item for a specific crtc.",
        "pre": {
            "work": "!=null",
            "crtc": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kprobe:drm_vblank_work_init": {
        "description": "Initialize a vblank work item for a specific crtc.",
        "pre": {
            "work": "!=null",
            "crtc": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_object_init": {
        "description": "Initialize an allocated shmem-backed GEM object",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_object_init": {
        "description": "Initialize an allocated shmem-backed GEM object",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:drm_gem_private_object_init": {
        "description": "Initialize an allocated private GEM object",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_private_object_init": {
        "description": "Initialize an allocated private GEM object",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_private_object_fini": {
        "description": "Finalize a failed drm_gem_object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_private_object_fini": {
        "description": "Finalize a failed drm_gem_object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_gem_handle_delete": {
        "description": "Deletes the given file-private handle",
        "pre": {
            "filp": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:intdrm_gem_handle_delete": {
        "description": "Deletes the given file-private handle",
        "pre": {
            "filp": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_free_mmap_offset": {
        "description": "Release a fake mmap offset for an object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_free_mmap_offset": {
        "description": "Release a fake mmap offset for an object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_gem_create_mmap_offset_size": {
        "description": "Create a fake mmap offset for an object",
        "pre": {
            "obj": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:intdrm_gem_create_mmap_offset_size": {
        "description": "Create a fake mmap offset for an object",
        "pre": {
            "obj": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_gem_handle_create_tail": {
        "description": "Internal function to create a handle",
        "pre": {
            "file_priv": "!=null",
            "obj": "!=null",
            "handlep": "!=null",
            "ret": "==0",
            "offset": "!=null"
        },
        "post": {
            "obj": "==null"
        }
    }
},
{
    "kprobe:intdrm_gem_handle_create_tail": {
        "description": "Internal function to create a handle",
        "pre": {
            "file_priv": "!=null",
            "obj": "!=null",
            "handlep": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_get_pages": {
        "description": "Get the array of pages associated with the given DRM gem object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_get_pages": {
        "description": "Get the array of pages associated with the DRM gem object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_objects_lookup": {
        "description": "Look up GEM objects from an array of handles",
        "pre": {
            "filp": "!=null",
            "bo_handles": "!=null",
            "count": ">=0",
            "objs_out": "!=null"
        },
        "post": {
            "objs_out": "!=null",
            "return": "in [0, -ENOENT]"
        }
    }
},
{
    "kprobe:drm_gem_objects_lookup": {
        "description": "Look up GEM objects from an array of handles.",
        "pre": {
            "filp": "!=null",
            "bo_handles": "!=null",
            "count": ">=0",
            "objs_out": "!=null"
        }
    }
},
{
    "kretprobe:if (obj->import_attach)": {
        "description": "Check if the `import_attach` field of `obj` is true.",
        "pre": {
            "obj": "!=null",
            "obj->import_attach": "==true"
        }
    }
},
{
    "kprobe:if (obj->import_attach)": {
        "description": "Check if the `import_attach` field of `obj` is true.",
        "pre": {
            "obj": {
                "import_attach": "==true"
            }
        }
    }
},
{
    "kretprobe:drm_gem_dma_resv_wait": {
        "description": "Wait on GEM object's reservation's objects shared and/or exclusive fences.",
        "pre": {
            "filep": "!=null",
            "handle": "!=null",
            "wait_all": "in [true, false]",
            "timeout": ">=0"
        },
        "post": {
            "return_value": "in [-ERESTARTSYS, 0, >0]"
        }
    }
},
{
    "kprobe:drm_gem_dma_resv_wait": {
        "description": "Wait on GEM object's reservation's objects shared and/or exclusive fences.",
        "pre": {
            "filep": "!=null",
            "handle": "!=null",
            "wait_all": "in [true, false]",
            "timeout": ">=0"
        },
        "post": {
            "return": "in [-ERESTARTSYS, 0, >0]"
        }
    }
},
{
    "kretprobe:drm_gem_object_handle_free": {
        "description": "Free the handle associated with the DRM GEM object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_object_handle_free": {
        "description": "Free the handle associated with the DRM gem object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_gem_vm_open": {
        "description": "Open virtual memory for a DRM gem object.",
        "pre": {
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_mmap_obj": {
        "description": "Memory map a GEM object",
        "pre": {
            "obj": "!=null",
            "obj_size": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_mmap_obj": {
        "description": "Memory map a GEM object.",
        "pre": {
            "obj": "!=null",
            "obj_size": "!=null",
            "vma": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:intdrm_gem_lock_reservations": {
        "description": "Lock reservations for drm_gem_objects",
        "pre": {
            "objs": "!=null",
            "count": ">=0",
            "acquire_ctx": "!=null"
        }
    }
},
{
    "kprobe:intdrm_gem_lock_reservations": {
        "description": "Lock reservations for drm_gem_objects",
        "pre": {
            "objs": "!=null",
            "count": ">=0",
            "acquire_ctx": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_lru_init": {
        "description": "Initialize a LRU",
        "pre": {
            "lru": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_lru_init": {
        "description": "Initialize a LRU",
        "pre": {
            "lru": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_object_free": {
        "description": "Free a GEM object",
        "pre": {
            "kref": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_gem_lru_move_tail_locked": {
        "description": "Move the object to the tail of the LRU",
        "pre": {
            "lru": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_lru_move_tail_locked": {
        "description": "Move the object to the tail of the LRU.",
        "pre": {
            "lru": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_lru_scan": {
        "description": "Helper to implement shrinker.scan_objects",
        "pre": {
            "lru": "!=null",
            "nr_to_scan": ">=0",
            "remaining": "!=null",
            "shrink": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_lru_scan": {
        "description": "Helper to implement shrinker.scan_objects",
        "pre": {
            "lru": "!=null",
            "nr_to_scan": ">=0",
            "remaining": "!=null",
            "shrink": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_evict": {
        "description": "Helper to evict backing pages for a GEM object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_evict": {
        "description": "Helper to evict backing pages for a GEM object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_fb_destroy": {
        "description": "Free GEM backed framebuffer",
        "pre": {
            "fb": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_fb_destroy": {
        "description": "Free GEM backed framebuffer",
        "pre": {
            "fb": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_fb_create_handle": {
        "description": "Create handle for GEM backed framebuffer",
        "pre": {
            "fb": "!=null",
            "file": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_fb_create_handle": {
        "description": "Create handle for GEM backed framebuffer",
        "pre": {
            "fb": "!=null",
            "file": "!=null",
            "handle": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_gem_fb_begin_cpu_access": {
        "description": "Prepares GEM buffer objects for CPU access",
        "pre": {
            "fb": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]"
        }
    }
},
{
    "kprobe:drm_gem_fb_begin_cpu_access": {
        "description": "Prepares GEM buffer objects for CPU access.",
        "pre": {
            "fb": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]"
        }
    }
},
S,
S,
{
    "kretprobe:drmm_kmalloc": {
        "description": "Allocate memory using the drmm_kmalloc helper function.",
        "pre": {
            "dev": "!=null",
            "size": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:drmm_kmalloc": {
        "description": "Allocate memory using the drmm_kmalloc helper function.",
        "pre": {
            "dev": "!=null",
            "size": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:drm_mm_reserve_node": {
        "description": "Insert a pre-initialized node into the drm_mm allocator.",
        "pre": {
            "mm": "!=null",
            "node": "!=null",
            "node.start": "!=null",
            "node.size": "!=null",
            "node.color": "!=null",
            "node.other_fields": "==0"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_mm_reserve_node": {
        "description": "Insert a pre-initialized node into the drm_mm allocator.",
        "pre": {
            "mm": "!=null",
            "node": "!=null",
            "node.start": "!=null",
            "node.size": "!=null",
            "node.color": "!=null",
            "node.<other_fields>": "==0"
        },
        "post": {
            "return": "in [0, -ENOSPC]"
        }
    }
},
{
    "kretprobe:drm_mm_insert_node_in_range": {
        "description": "Ranged search for space and insert node.",
        "pre": {
            "mm": "!=null",
            "node": "!=null",
            "size": ">0",
            "alignment": ">0",
            "color": ">=0",
            "range_start": ">=0",
            "range_end": ">=0",
            "mode": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]"
        }
    }
},
{
    "kprobe:drm_mm_insert_node_in_range": {
        "description": "Ranged search for space and insert node.",
        "pre": {
            "mm": "!=null",
            "node": "!=null",
            "size": "!=null",
            "alignment": "!=null",
            "color": "!=null",
            "range_start": "!=null",
            "range_end": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mm_remove_node": {
        "description": "Remove a memory node from the allocator.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:drm_mm_remove_node": {
        "description": "Remove a memory node from the allocator.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:drm_mm_replace_node": {
        "description": "Move an allocation from @old to @new.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:drm_mm_replace_node": {
        "description": "Move an allocation from @old to @new.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:drm_mm_scan_init_with_range": {
        "description": "Initialize range-restricted lru scanning",
        "pre": {
            "scan": "!=null",
            "mm": "!=null",
            "size": ">=0",
            "alignment": ">=0",
            "color": ">=0",
            "start": ">=0",
            "end": ">=0",
            "mode": ">=0"
        }
    }
},
{
    "kprobe:drm_mm_scan_init_with_range": {
        "description": "Initialize range-restricted lru scanning",
        "pre": {
            "scan": "!=null",
            "mm": "!=null",
            "size": "!=null",
            "alignment": "!=null",
            "color": "!=null",
            "start": "!=null",
            "end": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_mm_init": {
        "description": "Initialize a drm-mm allocator",
        "pre": {
            "mm": "==null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_mm_init": {
        "description": "Initialize a drm-mm allocator",
        "pre": {
            "mm": "==null",
            "start": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:drm_mm_takedown": {
        "description": "Clean up a drm_mm allocator",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kprobe:drm_mm_takedown": {
        "description": "Clean up a drm_mm allocator",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kretprobe:drm_mm_print": {
        "description": "Print allocator state",
        "pre": {
            "mm": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:drm_mm_print": {
        "description": "Print allocator state",
        "pre": {
            "mm": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_panel_orientation_quirk": {
        "description": "Check for panel orientation quirks",
        "pre": {
            "width": "!=null",
            "height": "!=null"
        }
    }
},
{
    "kprobe:drm_get_panel_orientation_quirk": {
        "description": "Check for panel orientation quirks",
        "pre": {
            "width": "!=null",
            "height": "!=null"
        }
    }
},
{
    "kretprobe:drm_debugfs_create_files": {
        "description": "Initialize a given set of debugfs files for DRM minor",
        "pre": {
            "files": "!=null",
            "count": ">=0",
            "root": "!=null",
            "minor": "!=null"
        }
    }
},
{
    "kprobe:drm_debugfs_create_files": {
        "description": "Initialize a given set of debugfs files for DRM minor",
        "pre": {
            "files": "!=null",
            "count": ">=0",
            "root": "!=null",
            "minor": "!=null"
        }
    }
},
{
    "kretprobe:drm_debugfs_add_file": {
        "description": "Add a given file to the DRM device debugfs file list.",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "show": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:drm_debugfs_add_file": {
        "description": "Add a given file to the DRM device debugfs file list.",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "show": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_intersect": {
        "description": "Intersect two rectangles",
        "pre": {
            "r1": "!=null",
            "r2": "!=null"
        }
    }
},
{
    "kprobe:drm_rect_intersect": {
        "description": "Intersect two rectangles",
        "pre": {
            "r1": "!=null",
            "r2": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_clip_scaled": {
        "description": "Perform a scaled clip operation",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "clip": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_rect_clip_scaled": {
        "description": "Perform a scaled clip operation",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_calc_hscale": {
        "description": "Calculate the horizontal scaling factor",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "min_hscale": "!=null",
            "max_hscale": "!=null"
        }
    }
},
{
    "kprobe:drm_rect_calc_hscale": {
        "description": "Calculate the horizontal scaling factor",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "min_hscale": "!=null",
            "max_hscale": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_calc_vscale": {
        "description": "Calculate the vertical scaling factor",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "min_vscale": "!=null",
            "max_vscale": "!=null"
        }
    }
},
{
    "kprobe:drm_rect_calc_vscale": {
        "description": "Calculate the vertical scaling factor",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "min_vscale": "!=null",
            "max_vscale": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_debug_print": {
        "description": "Print the rectangle information",
        "pre": {
            "prefix": "!=null",
            "r": "!=null",
            "fixed_point": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_rect_debug_print": {
        "description": "Print the rectangle information",
        "pre": {
            "prefix": "!=null",
            "r": {
                "x1": "!=null",
                "y1": "!=null",
                "x2": "!=null",
                "y2": "!=null"
            },
            "fixed_point": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_rect_rotate": {
        "description": "Rotate the rectangle",
        "pre": {
            "r": "!=null",
            "width": "!=null",
            "height": "!=null",
            "rotation": "!=null"
        }
    }
},
{
    "kprobe:drm_rect_rotate": {
        "description": "Rotate the rectangle",
        "pre": {
            "r": "!=null",
            "width": "!=null",
            "height": "!=null",
            "rotation": "!=null"
        }
    }
},
{
    "kretprobe:drm_rect_rotate_inv": {
        "description": "Inverse rotate the rectangle",
        "pre": {
            "r": "!=null",
            "width": "!=null",
            "height": "!=null",
            "rotation": "!=null"
        }
    }
},
{
    "kprobe:drm_rect_rotate_inv": {
        "description": "Inverse rotate the rectangle",
        "pre": {
            "r": "!=null",
            "width": ">=0",
            "height": ">=0",
            "rotation": ">=0"
        }
    }
},
{
    "kretprobe:__drm_debug": {
        "description": "Enable debug output for DRM",
        "pre": {
            "__drm_debug": "!=null",
            "bitmask": "in [DRM_UT_NONE, DRM_UT_CORE, DRM_UT_DRIVER, DRM_UT_KMS, DRM_UT_MODESET, DRM_UT_PRIME, DRM_UT_IOCTLS, DRM_UT_LEASE, DRM_UT_CRTC, DRM_UT_PLANE, DRM_UT_FB, DRM_UT_TRACE, DRM_UT_STATE, DRM_UT_PROBE, DRM_UT_DP, DRM_UT_ATOMIC, DRM_UT_VBLANK, DRM_UT_MODEFIXUP, DRM_UT_GEM, DRM_UT_PRIME_HELPER, DRM_UT_TEST, DRM_UT_INVALID]"
        }
    }
},
{
    "kprobe:__drm_debug": {
        "description": "Enable debug output.",
        "pre": {
            "__drm_debug": "!=null",
            "__drm_debug": "is a bitmask of DRM_UT_x"
        }
    }
},
S,
S,
{
    "kretprobe:len = snprintf": {
        "description": "Generate conditions for len = snprintf(NULL, 0, \"%pV\", vaf)",
        "pre": {
            "first_parameter": "!=null",
            "second_parameter": ">=0",
            "format_string": "any valid format string",
            "vaf": "any valid struct va_format object"
        }
    }
},
{
    "kprobe:drm_printfn_coredump": {
        "description": "Figure out how big the string will be",
        "pre": {
            "p": "!=null",
            "vaf": "!=null"
        }
    }
},
{
    "kretprobe:__drm_printfn_debug": {
        "description": "Prints debug information using printk.",
        "pre": {
            "p": "!=null",
            "vaf": "!=null",
            "p->prefix": "!=null",
            "vaf": "is of type struct va_format",
            "p->prefix": "is a string",
            "vaf": "is a valid pointer"
        }
    }
},
{
    "kprobe:__drm_printfn_debug": {
        "description": "Helper function for printing debug information.",
        "pre": {
            "p": "!=null",
            "vaf": "!=null",
            "p->prefix": "is string",
            "vaf": "is valid va_format structure"
        }
    }
},
{
    "kretprobe:drm_print_bits": {
        "description": "Print bits (in flag fields for example) in human readable form.",
        "pre": {
            "p": "!=null",
            "value": "!=null",
            "bits": "!=null",
            "nbits": "!=null"
        }
    }
},
{
    "kprobe:drm_print_bits": {
        "description": "Print bits (in flag fields for example) in human readable form.",
        "pre": {
            "p": "!=null",
            "value": "!=null",
            "bits": "!=null",
            "nbits": "!=null"
        }
    }
},
{
    "kretprobe:__drm_dev_dbg": {
        "description": "Print debug information for DRM devices.",
        "pre": {
            "desc": "!=null",
            "dev": "!=null",
            "category": "!=null",
            "format": "!=null",
            "...": "varies based on usage"
        }
    }
},
{
    "kprobe:__drm_dev_dbg": {
        "description": "Print debug information for DRM device.",
        "pre": {
            "desc": "!=null",
            "dev": "!=null",
            "category": "in [DRM_DEBUG_NONE, DRM_DEBUG_DRIVER, DRM_DEBUG_KMS, DRM_DEBUG_ATOMIC, DRM_DEBUG_DP, DRM_DEBUG_MODESET, DRM_DEBUG_PAGEFLIP, DRM_DEBUG_PRIME, DRM_DEBUG_VBL, DRM_DEBUG_MM, DRM_DEBUG_SCHED, DRM_DEBUG_IOCTL, DRM_DEBUG_LEGACY, DRM_DEBUG_MISC, DRM_DEBUG_TRACEFS, DRM_DEBUG_SYSLOG]",
            "format": "!=null",
            "...": "any"
        }
    }
},
{
    "kretprobe:drm_print_regset32": {
        "description": "Print the contents of registers to a &drm_printer stream.",
        "pre": {
            "p": "!=null",
            "regset": "!=null"
        }
    }
},
{
    "kprobe:drm_print_regset32": {
        "description": "Print the contents of registers to a &drm_printer stream.",
        "pre": {
            "p": "!=null",
            "regset": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_dev_has_vblank": {
        "description": "Check if the DRM device has vblank support.",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_client_dev_hotplug": {
        "description": "Send hotplug event to clients",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_client_dev_hotplug": {
        "description": "Send hotplug event to clients",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_client_buffer_vmap": {
        "description": "Maps a client buffer throughout its lifetime and returns a copy of the internal value.",
        "pre": {
            "buffer": "!=null",
            "map_copy": "!=null"
        },
        "post": {
            "return_value": "in [0, -errno]"
        }
    }
},
{
    "kprobe:intdrm_client_buffer_vmap": {
        "description": "Maps a client buffer throughout its lifetime.",
        "pre": {
            "buffer": "!=null",
            "map_copy": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kretprobe:drm_client_framebuffer_create": {
        "description": "Create a client framebuffer in the DRM subsystem.",
        "pre": {
            "client": "!=null",
            "width": "!=null",
            "height": "!=null",
            "format": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_client_framebuffer_create": {
        "description": "Create a client framebuffer with the specified width, height, and format.",
        "pre": {
            "client": "!=null",
            "width": ">=0",
            "height": ">=0",
            "format": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_client_framebuffer_flush": {
        "description": "Manually flush client framebuffer",
        "pre": {
            "buffer": "!=null",
            "rect": "!=null"
        }
    }
},
{
    "kprobe:drm_client_framebuffer_flush": {
        "description": "Manually flush client framebuffer",
        "pre": {
            "buffer": "!=null",
            "rect": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_privacy_screen_get": {
        "description": "Get a privacy-screen provider for a privacy-screen attached to the display described by the @dev and @con_id parameters.",
        "pre": {
            "dev": "!=null",
            "con_id": "!=null"
        },
        "post": {
            "return": "in [struct drm_privacy_screen*, ERR_PTR(-ENODEV), ERR_PTR(-EPROBE_DEFER)]"
        }
    }
},
{
    "kprobe:drm_privacy_screen_get": {
        "description": "Get a privacy-screen provider for a privacy-screen attached to the display described by the @dev and @con_id parameters.",
        "pre": {
            "dev": "!=null",
            "con_id": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_put": {
        "description": "Release a privacy-screen reference",
        "pre": {
            "priv": "!=null"
        }
    }
},
{
    "kprobe:drm_privacy_screen_put": {
        "description": "Release a privacy-screen reference",
        "pre": {
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_set_sw_state": {
        "description": "Set a privacy-screen's sw-state",
        "pre": {
            "priv": "!=null",
            "sw_state": "!=null"
        }
    }
},
{
    "kprobe:drm_privacy_screen_set_sw_state": {
        "description": "Set the sw-state of a privacy screen.",
        "pre": {
            "priv": "!=null",
            "sw_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_get_state": {
        "description": "Get the current state of a privacy-screen, both the sw-state and the hw-state.",
        "pre": {
            "priv": "!=null",
            "sw_state_ret": "!=null",
            "hw_state_ret": "!=null"
        }
    }
},
{
    "kprobe:drm_privacy_screen_get_state": {
        "description": "Get the current state of a privacy-screen, both the sw-state and the hw-state.",
        "pre": {
            "priv": "!=null",
            "sw_state_ret": "!=null",
            "hw_state_ret": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_register_notifier": {
        "description": "Register a notifier with the privacy-screen to be notified of changes made to the privacy-screen state from outside of the privacy-screen class.",
        "pre": {
            "priv": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:drm_privacy_screen_register_notifier": {
        "description": "Register a notifier with the privacy-screen to be notified of changes made to the privacy-screen state from outside of the privacy-screen class.",
        "pre": {
            "priv": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_unregister_notifier": {
        "description": "Unregister a notifier registered with drm_privacy_screen_register_notifier().",
        "pre": {
            "priv": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_privacy_screen_unregister_notifier": {
        "description": "Unregister a notifier registered with drm_privacy_screen_register_notifier().",
        "pre": {
            "priv": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:drm_privacy_screen_call_notifier_chain": {
        "description": "Notify consumers of state change",
        "pre": {
            "priv": "!=null",
            "sw_state": "!=null",
            "hw_state": "!=null"
        }
    }
},
{
    "kprobe:drm_privacy_screen_call_notifier_chain": {
        "description": "Notify consumers of state change",
        "pre": {
            "priv": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_gem_map_attach": {
        "description": "dma_buf attach implementation for GEM",
        "pre": {
            "dma_buf": "!=null",
            "attach": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_map_attach": {
        "description": "dma_buf attach implementation for GEM",
        "pre": {
            "dma_buf": "!=null",
            "attach": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_prime_mmap": {
        "description": "PRIME mmap function for GEM drivers",
        "pre": {
            "obj": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_prime_mmap": {
        "description": "PRIME mmap function for GEM drivers",
        "pre": {
            "obj": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:drm_prime_pages_to_sg": {
        "description": "Converts a page array into an sg list.",
        "pre": {
            "dev": "!=null",
            "pages": "!=null",
            "nr_pages": ">=0"
        }
    }
},
{
    "kprobe:drm_prime_pages_to_sg": {
        "description": "Converts a page array into an sg list.",
        "pre": {
            "dev": "!=null",
            "pages": "!=null",
            "nr_pages": ">=0"
        }
    }
},
{
    "kretprobe:drm_prime_get_contiguous_size": {
        "description": "Returns the contiguous size of the buffer",
        "pre": {
            "sgt": "!=null"
        }
    }
},
{
    "kprobe:drm_prime_get_contiguous_size": {
        "description": "Returns the contiguous size of the buffer.",
        "pre": {
            "sgt": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:drm_prime_sg_to_page_array": {
        "description": "Convert an sg table into a page array.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kprobe:drm_prime_sg_to_page_array": {
        "description": "Convert an sg table into a page array.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kretprobe:drm_prime_sg_to_dma_addr_array": {
        "description": "Convert an sg table into a dma addr array",
        "pre": {
            "sgt": "!=null",
            "addrs": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kprobe:drm_prime_sg_to_dma_addr_array": {
        "description": "Convert an sg table into a dma addr array.",
        "pre": {
            "sgt": "!=null",
            "addrs": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kretprobe:drm_atomic_set_mode_for_crtc": {
        "description": "Set mode for CRTC",
        "pre": {
            "state": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_set_mode_for_crtc": {
        "description": "Set mode for CRTC",
        "pre": {
            "state": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_set_mode_prop_for_crtc": {
        "description": "Set mode for CRTC",
        "pre": {
            "state": "!=null",
            "blob": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_set_mode_prop_for_crtc": {
        "description": "Set mode for CRTC",
        "pre": {
            "state": "!=null",
            "blob": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_set_crtc_for_plane": {
        "description": "Set CRTC for plane",
        "pre": {
            "plane_state": "!=null",
            "crtc": "!=null"
        },
        "post": {
            "return_value": "in [0, -EDEADLK, -ENOMEM]"
        }
    }
},
{
    "kprobe:intdrm_atomic_set_crtc_for_plane": {
        "description": "Set CRTC for plane",
        "pre": {
            "plane_state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_set_fb_for_plane": {
        "description": "Set framebuffer for plane",
        "pre": {
            "plane_state": "!=null",
            "fb": "!=null"
        }
    }
},
{
    "kprobe:voiddrm_atomic_set_fb_for_plane": {
        "description": "Set framebuffer for plane",
        "pre": {
            "plane_state": "!=null",
            "fb": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_set_crtc_for_connector": {
        "description": "Set CRTC for connector",
        "pre": {
            "conn_state": "!=null",
            "crtc": "!=null"
        },
        "post": {
            "return_value": "in [0, -EDEADLK, -ENOMEM]"
        }
    }
},
{
    "kprobe:intdrm_atomic_set_crtc_for_connector": {
        "description": "Set CRTC for connector",
        "pre": {
            "conn_state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_helper_update_primary": {
        "description": "Helper for updating primary planes",
        "pre": {
            "plane": "!=null",
            "crtc": "!=null",
            "fb": "!=null",
            "crtc_x": ">=0",
            "crtc_y": ">=0",
            "crtc_w": ">=0",
            "crtc_h": ">=0",
            "src_x": ">=0",
            "src_y": ">=0",
            "src_w": ">=0",
            "src_h": ">=0",
            "ctx": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_helper_update_primary": {
        "description": "Helper for updating primary planes",
        "pre": {
            "plane": "!=null",
            "crtc": "!=null",
            "fb": "!=null",
            "crtc_x": "int",
            "crtc_y": "int",
            "crtc_w": "unsigned int",
            "crtc_h": "unsigned int",
            "src_x": "unsigned int",
            "src_y": "unsigned int",
            "src_w": "unsigned int",
            "src_h": "unsigned int",
            "ctx": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_helper_disable_primary": {
        "description": "Helper for disabling primary planes",
        "pre": {
            "plane": "!=null",
            "ctx": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_helper_disable_primary": {
        "description": "Helper for disabling primary planes",
        "pre": {
            "plane": "!=null",
            "ctx": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_helper_destroy": {
        "description": "Helper for primary plane destruction",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_helper_destroy": {
        "description": "Helper for primary plane destruction",
        "pre": {
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_plane_helper_atomic_check": {
        "description": "Helper to check plane atomic-state",
        "pre": {
            "plane": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_plane_helper_atomic_check": {
        "description": "Helper to check plane atomic-state",
        "pre": {
            "plane": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_self_refresh_helper_update_avg_times": {
        "description": "Updates a crtc's SR time averages",
        "pre": {
            "state": "!=null",
            "commit_time_ms": ">=0",
            "new_self_refresh_mask": ">=0"
        }
    }
},
{
    "kprobe:drm_self_refresh_helper_update_avg_times": {
        "description": "Updates a crtc's SR time averages",
        "pre": {
            "state": "!=null",
            "commit_time_ms": ">=0",
            "new_self_refresh_mask": ">=0"
        }
    }
},
{
    "kretprobe:drm_self_refresh_helper_alter_state": {
        "description": "Alters the atomic state for SR exit",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_self_refresh_helper_alter_state": {
        "description": "Alters the atomic state for SR exit",
        "pre": {
            "state": "!=null"
        }
    }
},
S,
{
    "kprobe:SELF_REFRESH_AVG_SEED_MS": {
        "description": "Helper function for self-refresh functionality in DRM subsystem.",
        "pre": {
            "&drm_connector_state.self_refresh_aware": "==true",
            "&drm_crtc_state.self_refresh_active": "==true"
        }
    }
},
{
    "kretprobe:__drm_stack_depot_save": {
        "description": "Save the depot stack handle.",
        "pre": {
            "drm_modeset_lock_all_ctx": "called",
            "drm_modeset_acquire_ctx": "not needed",
            "drm_modeset_lock": "called with NULL context or drm_modeset_lock_single_interruptible() called",
            "drm_mode_config.mutex": "acquired"
        },
        "post": {
            "success": "function executed successfully",
            "locks_released": "drm_modeset_lock_all_ctx, drm_modeset_lock, drm_mode_config.mutex"
        }
    }
},
{
    "kprobe:static DEFINE_WW_CLASS(crtc_ww_class);#if IS_ENABLED(CONFIG_DRM_DEBUG_MODESET_LOCK)static noinline depot_stack_handle_t __drm_stack_depot_save(void)": {
        "description": "This function saves the depot stack handle.",
        "pre": {
            "drm_modeset_lock_all_ctx": "!=null",
            "drm_modeset_acquire_ctx": "not needed",
            "drm_modeset_lock": "NULL or drm_modeset_lock_single_interruptible()",
            "drm_modeset_unlock": "called afterwards",
            "ww_mutex": "used for per-object locks",
            "drm_mode_config.mutex": "used for overall protection",
            "drm core internal lists and lookup data structures": "protected by dedicated locks"
        }
    }
},
{
    "kretprobe:drm_modeset_lock_all": {
        "description": "This function allocates a lock acquisition context and stores it in &drm_device.mode_config.",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_modeset_unlock_all": {
        "description": "Drop all modeset locks taken by a previous call to the drm_modeset_lock_all() function.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_modeset_unlock_all": {
        "description": "Drop all modeset locks taken by a previous call to the drm_modeset_lock_all() function.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_modeset_lock_init": {
        "description": "Initialize the lock",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:drm_modeset_lock_init": {
        "description": "Initialize lock",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:drm_syncobj_find": {
        "description": "Lookup and reference a sync object.",
        "pre": {
            "file_private": "!=null",
            "handle": "!=null"
        },
        "post": {
            "return_value": "in [null, !=null]"
        }
    }
},
{
    "kprobe:drm_syncobj_find": {
        "description": "Lookup and reference a sync object.",
        "pre": {
            "file_private": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:drm_syncobj_add_point": {
        "description": "Add new timeline point to the syncobj",
        "pre": {
            "syncobj": "!=null",
            "chain": "!=null",
            "fence": "!=null",
            "point": ">=0"
        }
    }
},
{
    "kprobe:drm_syncobj_add_point": {
        "description": "Add new timeline point to the syncobj.",
        "pre": {
            "syncobj": "!=null",
            "chain": "!=null",
            "fence": "!=null",
            "point": ">=0"
        }
    }
},
{
    "kretprobe:drm_syncobj_replace_fence": {
        "description": "Replace fence in a sync object.",
        "pre": {
            "syncobj": "!=null",
            "fence": "!=null"
        }
    }
},
{
    "kprobe:drm_syncobj_replace_fence": {
        "description": "Replace fence in a sync object.",
        "pre": {
            "syncobj": "!=null",
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:drm_syncobj_find_fence": {
        "description": "Lookup and reference the fence in a sync object",
        "pre": {
            "file_private": "!=null",
            "handle": "!=null",
            "point": "!=null",
            "flags": "in [DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT, !DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT]",
            "fence": "==null"
        },
        "post": {
            "return": "in [0, negative error value]"
        }
    }
},
{
    "kprobe:drm_syncobj_find_fence": {
        "description": "Lookup and reference the fence in a sync object",
        "pre": {
            "file_private": "!=null",
            "handle": "!=null",
            "point": "!=null",
            "flags": "in [DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT, !DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT]",
            "fence": "==null"
        }
    }
},
{
    "kretprobe:drm_syncobj_free": {
        "description": "Free a sync object.",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kprobe:drm_syncobj_free": {
        "description": "Free a sync object.",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kretprobe:drm_syncobj_create": {
        "description": "Create a DRM sync object",
        "pre": {
            "out_syncobj": "!=null",
            "flags": "any",
            "fence": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_timeout_abs_to_jiffies": {
        "description": "Calculate jiffies timeout from absolute value",
        "pre": {
            "timeout_nsec": ">=0"
        }
    }
},
{
    "kprobe:drm_timeout_abs_to_jiffies": {
        "description": "Calculate jiffies timeout from absolute value",
        "pre": {
            "timeout_nsec": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:drm_encoder_init": {
        "description": "Initialize a DRM encoder",
        "pre": {
            "dev": "!=null",
            "encoder": "!=null",
            "funcs": "!=null",
            "encoder_type": "int",
            "name": "!=null",
            "...": "..."
        }
    }
},
S,
{
    "kretprobe:drm_file_alloc": {
        "description": "Allocate file context",
        "pre": {
            "minor": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_file_alloc": {
        "description": "Allocate file context",
        "pre": {
            "minor": "!=null"
        }
    }
},
{
    "kretprobe:drm_release_noglobal": {
        "description": "Release method for DRM file",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_release_noglobal": {
        "description": "Release method for DRM file",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:drm_event_reserve_init_locked": {
        "description": "Reserve and initialize a locked DRM event",
        "pre": {
            "dev": "!=null",
            "file_priv": "!=null",
            "p": "!=null",
            "e": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_send_event_timestamp_locked": {
        "description": "Send DRM event to file descriptor",
        "pre": {
            "dev": "!=null",
            "e": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kprobe:drm_send_event_timestamp_locked": {
        "description": "Send DRM event to file descriptor",
        "pre": {
            "dev": "!=null",
            "e": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kretprobe:drm_print_memory_stats": {
        "description": "A helper to print memory stats",
        "pre": {
            "p": "!=null",
            "stats": "!=null",
            "supported_status": "!=null",
            "region": "!=null"
        }
    }
},
{
    "kprobe:drm_print_memory_stats": {
        "description": "A helper to print memory stats",
        "pre": {
            "p": "!=null",
            "stats": "!=null",
            "supported_status": "!=null",
            "region": "!=null"
        }
    }
},
{
    "kretprobe:drm_show_memory_stats": {
        "description": "Helper to collect and show standard fdinfo memory stats",
        "pre": {
            "p": "!=null",
            "file": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_show_fdinfo": {
        "description": "Helper for drm file fops",
        "pre": {
            "m": "!=null",
            "f": "!=null"
        }
    }
},
{
    "kprobe:drm_show_fdinfo": {
        "description": "Helper for drm file fops",
        "pre": {
            "m": "!=null",
            "f": "!=null"
        }
    }
},
{
    "kretprobe:drm_noop": {
        "description": "DRM no-op ioctl implementation",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "file_priv": "!=null"
        }
    }
},
{
    "kprobe:drm_noop": {
        "description": "DRM no-op ioctl implementation",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "file_priv": "!=null"
        }
    }
},
{
    "kretprobe:getunique": {
        "description": "Copies the bus id from drm_device::unique into user space.",
        "pre": {
            "inode": "!=null",
            "file_priv": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_ioctl_kernel": {
        "description": "Enforce sane locking for modern driver ioctls.",
        "pre": {
            "file": "!=null",
            "func": "!=null",
            "kdata": "!=null",
            "flags": "!=null",
            "file_priv": "!=null",
            "dev": "!=null",
            "retcode": "!=null",
            "drm_dev_is_unplugged(dev)": "false",
            "drm_ioctl_permit(flags, file_priv)": "retcode == 0"
        }
    }
},
{
    "kprobe:drm_ioctl_kernel": {
        "description": "Enforce sane locking for modern driver ioctls.",
        "pre": {
            "file": "!=null",
            "func": "!=null",
            "kdata": "!=null",
            "flags": "!=null",
            "file_priv": "!=null",
            "dev": "!=null",
            "retcode": "!=null",
            "drm_dev_is_unplugged(dev)": "false",
            "drm_ioctl_permit(flags, file_priv)": "retcode == 0",
            "likely(!drm_core_check_feature(dev, DRIVER_LEGACY)) || (flags & DRM_UNLOCKED)": "true"
        }
    }
},
{
    "kretprobe:drm_ioctl_flags": {
        "description": "Check for core ioctl and return ioctl permission flags",
        "pre": {
            "nr": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:drm_ioctl_flags": {
        "description": "Check for core ioctl and return ioctl permission flags",
        "pre": {
            "nr": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:drm_fbdev_dma_setup": {
        "description": "Setup fbdev emulation for GEM DMA helpers",
        "pre": {
            "dev": "!=null",
            "preferred_bpp": ">=0"
        }
    }
},
{
    "kprobe:drm_fbdev_dma_setup": {
        "description": "Setup fbdev emulation for GEM DMA helpers",
        "pre": {
            "dev": "!=null",
            "preferred_bpp": ">=0"
        }
    }
},
{
    "kretprobe:drm_mode_object_find": {
        "description": "Find a DRM mode object based on the given device, file, ID, and type.",
        "pre": {
            "dev": "!=null",
            "file_priv": "!=null",
            "id": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_object_find": {
        "description": "Find a DRM mode object based on device, file, id, and type.",
        "pre": {
            "dev": "!=null",
            "file_priv": "!=null",
            "id": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_object_put": {
        "description": "Decrease the reference count of the DRM mode object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_object_put": {
        "description": "Decrement the reference count of a DRM mode object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_object_attach_property": {
        "description": "Attach a property to a modeset object",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "init_val": "!=null"
        }
    }
},
{
    "kprobe:drm_object_attach_property": {
        "description": "Attach a property to a modeset object",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "init_val": "!=null"
        }
    }
},
{
    "kretprobe:drm_object_property_set_value": {
        "description": "Set the value of a property",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:drm_object_property_set_value": {
        "description": "Set the value of a property for a given DRM mode object.",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:drm_object_property_get_value": {
        "description": "Retrieve the value of a property",
        "pre": {
            "drm_drv_uses_atomic_modeset(property->dev)": "==true",
            "!(property->flags & DRM_MODE_PROP_IMMUTABLE)": "==true",
            "obj": "!=null",
            "property": "!=null",
            "val": "!=null"
        },
        "post": {
            "return": {
                "drm_atomic_get_property(obj, property, val)": "!=null",
                "__drm_object_property_get_prop_value(obj, property, val)": "!=null"
            }
        }
    }
},
{
    "kprobe:drm_object_property_get_value": {
        "description": "Retrieve the value of a property for a DRM mode object.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:drm_object_property_get_default_value": {
        "description": "Retrieve the default value of a property when in atomic mode.",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:drm_object_property_get_default_value": {
        "description": "Retrieve the default value of a property when in atomic mode.",
        "pre": {
            "obj": "!=null",
            "property": "!=null",
            "val": "!=null"
        },
        "post": {
            "return": "in [0, error_code]"
        }
    }
},
S,
S,
{
    "kretprobe:drm_gem_shmem_pin": {
        "description": "Pin backing pages for a shmem GEM object",
        "pre": {
            "shmem": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_shmem_pin": {
        "description": "Pin backing pages for a shmem GEM object",
        "pre": {
            "shmem": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_shmem_unpin": {
        "description": "Unpin backing pages for a shmem GEM object",
        "pre": {
            "shmem": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_shmem_unpin": {
        "description": "Unpin backing pages for a shmem GEM object",
        "pre": {
            "shmem": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_gem_shmem_vmap": {
        "description": "Maps a shmem object to the iosys map.",
        "pre": {
            "shmem": "!=null",
            "map": "!=null"
        },
        "post": {
            "return_value": "in [0, -error_code]"
        }
    }
},
S,
{
    "kretprobe:shmem_truncate_range": {
        "description": "Truncate the range of a shared memory object.",
        "pre": {
            "file_inode(obj->filp)": "!=null",
            "0": ">=0",
            "(loff_t)-1": "<=0",
            "file_inode(obj->filp)->i_mapping": "!=null"
        }
    }
},
{
    "kprobe:shmem_truncate_range": {
        "description": "Truncate the range of a shared memory file.",
        "pre": {
            "file_inode(obj->filp)": "!=null",
            "0": "==0",
            "(loff_t)-1": "<=0",
            "file_inode(obj->filp)->i_mapping": "!=null"
        }
    },
    "kprobe:invalidate_mapping_pages": {
        "description": "Invalidate the mapping pages of a file.",
        "pre": {
            "file_inode(obj->filp)->i_mapping": "!=null",
            "0": "==0"
        }
    },
    "EXPORT_SYMBOL(drm_gem_shmem_purge_locked)": {}
},
{
    "kretprobe:shmem_truncate_range": {
        "description": "Truncate the range of a shared memory object.",
        "pre": {
            "file_inode(obj->filp)": "!=null",
            "0": "==0",
            "(loff_t)-1": "<=0"
        }
    }
},
{
    "kprobe:shmem_truncate_range": {
        "description": "Truncate a range of memory associated with a file.",
        "pre": {
            "file_inode(obj->filp)": "!=null",
            "0": "==0",
            "(loff_t)-1": "<=0",
            "file_inode(obj->filp)->i_mapping": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_shmem_print_info": {
        "description": "Print &drm_gem_shmem_object info for debugfs",
        "pre": {
            "shmem": "!=null",
            "p": "!=null",
            "indent": ">=0"
        }
    }
},
S,
{
    "kretprobe:drm_crtc_commit_wait": {
        "description": "Waits for a commit to complete",
        "pre": {
            "commit": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_commit_wait": {
        "description": "Waits for a commit to complete",
        "pre": {
            "commit": "!=null"
        },
        "post": {
            "return": "in [0, -MAX_ERRNO]"
        }
    }
},
S,
{
    "kprobe:drm_atomic_state_default_release": {
        "description": "Free all the memory allocated by drm_atomic_state_init.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_state_alloc": {
        "description": "Allocate atomic state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_state_alloc": {
        "description": "Allocate atomic state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_state_default_clear": {
        "description": "Clear base atomic state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_state_default_clear": {
        "description": "Clear base atomic state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_state_clear": {
        "description": "clear state object",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_state_clear": {
        "description": "Clear the state object",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_atomic_state_free": {
        "description": "Free all memory for an atomic state",
        "pre": {
            "ref": "!=null"
        }
    }
},
{
    "kprobe:__drm_atomic_state_free": {
        "description": "Free all memory for an atomic state",
        "pre": {
            "ref": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_crtc_state": {
        "description": "Get CRTC state",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_crtc_state": {
        "description": "Get CRTC state",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_plane_state": {
        "description": "Get plane state",
        "pre": {
            "state": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_plane_state": {
        "description": "Get plane state",
        "pre": {
            "state": "!=null",
            "plane": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_private_obj_init": {
        "description": "Initialize the private object, which can be embedded into any driver private object that needs its own atomic state.",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "state": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kprobe:voiddrm_atomic_private_obj_init": {
        "description": "Initialize the private object, which can be embedded into any driver private object that needs its own atomic state.",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "state": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_private_obj_fini": {
        "description": "Finalize the private object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_private_obj_fini": {
        "description": "Finalize the private object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_private_obj_init": {
        "description": "Initialize the private object, which can be embedded into any driver private object that needs its own atomic state.",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "state": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_private_obj_init": {
        "description": "Initialize the private object, which can be embedded into any driver private object that needs its own atomic state.",
        "pre": {
            "dev": "!=null",
            "obj": "!=null",
            "state": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_old_private_obj_state": {
        "description": "Returns the old private object state for the given private_obj, or NULL if not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_old_private_obj_state": {
        "description": "Returns the old private object state for the given private_obj, or NULL if not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_new_private_obj_state": {
        "description": "This function returns the new private object state for the given private_obj, or NULL if the private_obj is not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_new_private_obj_state": {
        "description": "This function returns the new private object state for the given private_obj, or NULL if the private_obj is not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_old_connector_for_encoder": {
        "description": "Get old connector for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_old_connector_for_encoder": {
        "description": "Get old connector for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_new_connector_for_encoder": {
        "description": "Get new connector for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_new_connector_for_encoder": {
        "description": "Get new connector for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_old_crtc_for_encoder": {
        "description": "Get old crtc for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_old_crtc_for_encoder": {
        "description": "Get old crtc for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_new_crtc_for_encoder": {
        "description": "Get new crtc for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_new_crtc_for_encoder": {
        "description": "Get new crtc for an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_connector_state": {
        "description": "Get connector state for the given connector, allocating it if needed.",
        "pre": {
            "state": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_connector_state": {
        "description": "Get connector state for the given connector, allocating it if needed.",
        "pre": {
            "state": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_bridge_state": {
        "description": "Get bridge state",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_bridge_state": {
        "description": "Get bridge state",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_old_bridge_state": {
        "description": "Get the old bridge state for the given bridge, or NULL if the bridge is not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_old_bridge_state": {
        "description": "Get the old bridge state for the given bridge, or NULL if the bridge is not part of the global atomic state.",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_new_bridge_state": {
        "description": "Get new bridge state, if it exists",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_new_bridge_state": {
        "description": "Get new bridge state, if it exists",
        "pre": {
            "state": "!=null",
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_add_encoder_bridges": {
        "description": "Add bridges attached to an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:intdrm_atomic_add_encoder_bridges": {
        "description": "Add bridges attached to an encoder",
        "pre": {
            "state": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_add_affected_connectors": {
        "description": "Add connectors for CRTC",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:intdrm_atomic_add_affected_connectors": {
        "description": "Add connectors for CRTC",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_atomic_add_affected_planes": {
        "description": "Add planes for CRTC",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:intdrm_atomic_add_affected_planes": {
        "description": "Add planes for CRTC",
        "pre": {
            "state": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_check_only": {
        "description": "Check whether a given config would work.",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "return_value": "in [0, -EDEADLK]"
        }
    }
},
{
    "kprobe:drm_atomic_check_only": {
        "description": "Check whether a given config would work.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_commit": {
        "description": "Commit configuration atomically",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_commit": {
        "description": "Commit configuration atomically",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_nonblocking_commit": {
        "description": "atomic nonblocking commit",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "return": "in [0, -EDEADLK]"
        }
    }
},
{
    "kprobe:drm_atomic_nonblocking_commit": {
        "description": "atomic nonblocking commit",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_state_dump": {
        "description": "Dump entire device atomic state",
        "pre": {
            "dev": "!=null",
            "p": "!=null",
            "take_locks": "bool"
        }
    }
},
{
    "kprobe:drm_state_dump": {
        "description": "Dump entire device atomic state.",
        "pre": {
            "dev": "!=null",
            "p": "!=null",
            "take_locks": "any"
        }
    }
},
{
    "kretprobe:drm_suballoc_manager_init": {
        "description": "Initialise the drm_suballoc_manager",
        "pre": {
            "sa_manager": "!=null",
            "size": ">=0",
            "align": ">=0"
        }
    }
},
{
    "kprobe:drm_suballoc_manager_init": {
        "description": "Initialise the drm_suballoc_manager",
        "pre": {
            "sa_manager": "!=null",
            "size": ">=0",
            "align": ">=0"
        }
    }
},
{
    "kretprobe:drm_suballoc_manager_fini": {
        "description": "Clean up the entire suballocation manager.",
        "pre": {
            "drm_suballoc_free_signaled": "==true"
        }
    }
},
{
    "kprobe:drm_suballoc_manager_fini": {
        "description": "Clean up the DRM suballocation manager.",
        "pre": {
            "sa_manager": "!=null",
            "drm_suballoc_free_signaled": "==true"
        }
    }
},
{
    "kretprobe:drm_suballoc_new": {
        "description": "Make a suballocation.",
        "pre": {
            "sa_manager": "!=null",
            "size": ">=0",
            "gfp": ">=0",
            "intr": "bool",
            "align": ">=0 && <= default_manager_alignment"
        }
    }
},
{
    "kprobe:drm_suballoc_new": {
        "description": "Make a suballocation.",
        "pre": {
            "sa_manager": "!=null",
            "size": ">=0",
            "gfp": ">=0",
            "intr": "bool",
            "align": ">=0 && <= default_manager_alignment"
        }
    }
},
{
    "kretprobe:drm_writeback_connector_init": {
        "description": "Initialize a writeback connector and its properties",
        "pre": {
            "dev": "!=null",
            "wb_connector": "!=null",
            "con_funcs": "!=null",
            "enc_helper_funcs": "!=null",
            "formats": "!=null",
            "n_formats": ">=0",
            "possible_crtcs": ">=0"
        }
    }
},
{
    "drm_writeback_connector_init": {
        "description": "Initialize a writeback connector and its properties",
        "pre": {
            "dev": "!=null",
            "wb_connector": "!=null",
            "con_funcs": "!=null",
            "enc_helper_funcs": "!=null",
            "formats": "!=null",
            "n_formats": ">=0",
            "possible_crtcs": "!=null"
        }
    }
},
{
    "kretprobe:drm_writeback_connector_init_with_encoder": {
        "description": "Initialize a writeback connector with a custom encoder",
        "pre": {
            "dev": "!=null",
            "wb_connector": "!=null",
            "enc": "!=null",
            "con_funcs": "!=null",
            "formats": "!=null",
            "n_formats": "!=null"
        }
    }
},
{
    "kprobe:drm_writeback_connector_init_with_encoder": {
        "description": "Initialize a writeback connector with a custom encoder",
        "pre": {
            "dev": "!=null",
            "wb_connector": "!=null",
            "enc": "!=null",
            "con_funcs": "!=null",
            "formats": "!=null",
            "n_formats": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:drm_edid_header_is_valid": {
        "description": "Sanity check the header of the base EDID block.",
        "pre": {
            "_edid": "!=null"
        },
        "post": {
            "return_value": "in [0, 1, 2, 3, 4, 5, 6, 7, 8]"
        }
    }
},
{
    "kprobe:drm_edid_header_is_valid": {
        "description": "Sanity check the header of the base EDID block.",
        "pre": {
            "_edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_are_equal": {
        "description": "Compare two edid blobs.",
        "pre": {
            "edid1": "!=null",
            "edid2": "!=null"
        }
    }
},
{
    "kprobe:drm_edid_are_equal": {
        "description": "Compare two edid blobs.",
        "pre": {
            "edid1": "!=null",
            "edid2": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_block_valid": {
        "description": "Sanity check the EDID block (base or extension)",
        "pre": {
            "_block": "!=null",
            "block_num": "int",
            "print_bad_edid": "bool",
            "edid_corrupt": "bool"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kprobe:drm_edid_block_valid": {
        "description": "Sanity check the EDID block (base or extension)",
        "pre": {
            "_block": "!=null",
            "block_num": "int",
            "print_bad_edid": "bool",
            "edid_corrupt": "bool"
        },
        "return": "bool"
    }
},
{
    "kretprobe:drm_edid_is_valid": {
        "description": "Sanity check EDID data",
        "pre": {
            "edid": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_edid_is_valid": {
        "description": "Sanity check EDID data",
        "pre": {
            "edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_valid": {
        "description": "Sanity check EDID data",
        "pre": {
            "drm_edid": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_edid_valid": {
        "description": "Sanity check EDID data",
        "pre": {
            "drm_edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_override_connector_update": {
        "description": "Update the connector's EDID override firmware.",
        "pre": {
            "connector": "!=null",
            "drm_get_edid()": "called",
            "return_value": {
                "type": "int",
                "constraints": ">= 0"
            }
        }
    }
},
{
    "kprobe:drm_edid_override_connector_update": {
        "description": "Override the firmware EDID for a DRM connector and return the number of modes added.",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:drm_edid_raw": {
        "description": "Get a pointer to the raw EDID data.",
        "pre": {
            "drm_edid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_edid_override_reset": {
        "description": "Reset the EDID override for a DRM connector.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null",
            "drm_edid_override": "!=null",
            "edid_override_mutex": "!=null"
        },
        "post": {
            "return": "-EINVAL",
            "drm_edid": "null",
            "drm_edid_override": "drm_edid",
            "edid_override_mutex": "unlocked"
        }
    }
},
{
    "kprobe:drm_edid_override_reset": {
        "description": "Reset the EDID override for a DRM connector.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null",
            "edid_override_mutex": "unlocked"
        },
        "post": {
            "drm_edid": "freed",
            "return_value": "-EINVAL",
            "debug_message": "printed",
            "edid_override_mutex": "locked",
            "edid_override": "freed",
            "connector.edid_override": "assigned drm_edid",
            "edid_override_mutex": "unlocked",
            "return_value": "0"
        }
    }
},
{
    "kretprobe:drm_edid_override_show": {
        "description": "For debugfs edid_override implementation",
        "pre": {
            "connector": "!=null",
            "m": "!=null",
            "connector->edid_override": "!=null",
            "&connector->edid_override_mutex": "!=null",
            "override": "!=null",
            "IS_ERR(override)": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_edid_override_show": {
        "description": "For debugfs edid_override implementation",
        "pre": {
            "connector": "!=null",
            "m": "!=null",
            "connector->edid_override": "!=null",
            "&connector->edid_override_mutex": "!=null",
            "override": "!=null",
            "IS_ERR(override)": "in [true, false]"
        }
    }
},
{
    "kretprobe:booldrm_probe_ddc": {
        "description": "Probe DDC presence on the specified I2C adapter.",
        "pre": {
            "adapter": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:booldrm_probe_ddc": {
        "description": "Probe DDC presence",
        "pre": {
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_read_custom": {
        "description": "Read EDID data using given EDID block read function",
        "pre": {
            "connector": "!=null",
            "read_block": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:drm_edid_read_custom": {
        "description": "Read EDID data using given EDID block read function",
        "pre": {
            "connector": "!=null",
            "read_block": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_get_panel_id": {
        "description": "Get a panel's ID through DDC",
        "pre": {
            "adapter": "!=null"
        }
    }
},
{
    "kprobe:drm_edid_get_panel_id": {
        "description": "Get a panel's ID through DDC",
        "pre": {
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_edid_switcheroo": {
        "description": "get EDID data for a vga_switcheroo output",
        "pre": {
            "connector": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kprobe:drm_get_edid_switcheroo": {
        "description": "Get EDID data for a vga_switcheroo output",
        "pre": {
            "connector": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_read_switcheroo": {
        "description": "Get EDID data for a vga_switcheroo output",
        "pre": {
            "connector": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kprobe:drm_edid_read_switcheroo": {
        "description": "Get EDID data for a vga_switcheroo output",
        "pre": {
            "connector": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_edid_duplicate": {
        "description": "Duplicate an EDID and the extensions",
        "pre": {
            "edid": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_edid_duplicate": {
        "description": "Duplicate an EDID and the extensions",
        "pre": {
            "edid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_find_dmt": {
        "description": "Create a copy of a mode if present in DMT",
        "pre": {
            "dev": "!=null",
            "hsize": "!=null",
            "vsize": "!=null",
            "fresh": "!=null",
            "rb": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_find_dmt": {
        "description": "Create a copy of a mode if present in DMT",
        "pre": {
            "dev": "!=null",
            "hsize": "!=null",
            "vsize": "!=null",
            "fresh": "!=null",
            "rb": "!=null"
        }
    }
},
{
    "kretprobe:drm_match_cea_mode_clock_tolerance": {
        "description": "Match the CEA mode clock with a given tolerance.",
        "pre": {
            "to_match->clock": "!=0",
            "clock_tolerance": ">=0",
            "match_flags": "in [DRM_MODE_MATCH_TIMINGS, DRM_MODE_MATCH_FLAGS]",
            "to_match->picture_aspect_ratio": "!=null",
            "vic": ">=1",
            "vic": "< cea_num_vics()",
            "cea_mode": "initialized with cea_mode_for_vic(vic)",
            "clock1": "!=null",
            "clock2": "!=null",
            "abs(to_match->clock - clock1)": "> clock_tolerance",
            "abs(to_match->clock - clock2)": "> clock_tolerance"
        }
    }
},
{
    "kprobe:drm_match_cea_mode_clock_tolerance": {
        "description": "Matches the CEA mode clock with a given tolerance.",
        "pre": {
            "to_match->clock": "!=0",
            "clock_tolerance": ">=0",
            "match_flags": "in [DRM_MODE_MATCH_TIMINGS, DRM_MODE_MATCH_FLAGS]",
            "to_match->picture_aspect_ratio": "!=null",
            "vic": "in [1, cea_num_vics())",
            "cea_mode": "initialized with cea_mode_for_vic(vic)",
            "clock1": "initialized with cea_mode.clock",
            "clock2": "initialized with cea_mode_alternate_clock(&cea_mode)",
            "abs(to_match->clock - clock1)": "> clock_tolerance",
            "abs(to_match->clock - clock2)": "> clock_tolerance"
        }
    }
},
{
    "kretprobe:do_y420vdb_modes": {
        "description": "Parse YCBCR 420 only modes",
        "pre": {
            "connector": "!=null",
            "svds": "!=null",
            "svds_len": ">=0"
        }
    }
},
{
    "kprobe:do_y420vdb_modes": {
        "description": "Parse YCBCR 420 only modes",
        "pre": {
            "connector": "!=null",
            "svds": "!=null",
            "svds_len": ">=0"
        }
    }
},
{
    "kretprobe:drm_edid_get_monitor_name": {
        "description": "Fetch the monitor name from the edid",
        "pre": {
            "edid": "!=null",
            "name": "!=null",
            "bufsize": ">=14"
        }
    }
},
{
    "kprobe:drm_edid_get_monitor_name": {
        "description": "Fetch the monitor name from the edid",
        "pre": {
            "edid": "!=null",
            "name": "!=null",
            "bufsize": ">=14"
        }
    }
},
S,
S,
{
    "kretprobe:drm_edid_to_speaker_allocation": {
        "description": "Extracts Speaker Allocation Data Blocks from EDID",
        "pre": {
            "edid": "!=null",
            "sadb": "!=null"
        },
        "post": {
            "return_value": ">= -1"
        }
    }
},
{
    "kprobe:drm_edid_to_speaker_allocation": {
        "description": "Extracts Speaker Allocation Data Blocks from EDID",
        "pre": {
            "edid": "!=null",
            "sadb": "!=null"
        }
    }
},
{
    "kretprobe:drm_av_sync_delay": {
        "description": "Compute the HDMIDP sink audio-video sync delay.",
        "pre": {
            "connector": "!=null",
            "mode": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_av_sync_delay": {
        "description": "Compute the HDMIDP sink audio-video sync delay.",
        "pre": {
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:cea_db_iter_edid_begin": {
        "description": "Initialize the CEA DB iterator for the given DRM EDID.",
        "pre": {
            "drm_edid": "!=null"
        }
    },
    "kretprobe:cea_db_iter_for_each": {
        "description": "Iterate over the CEA DB using the given iterator.",
        "pre": {
            "db": "initialized",
            "iter": "initialized"
        }
    },
    "kretprobe:drm_detect_hdmi_monitor": {
        "description": "Detect if HDMI monitor is present using the given DRM EDID.",
        "pre": {
            "drm_edid": "!=null",
            "db": "initialized",
            "iter": "initialized",
            "hdmi": "false"
        },
        "post": {
            "hdmi": "true"
        }
    }
},
{
    "kprobe:cea_db_iter_edid_begin": {
        "description": "Initialize the CEA DB iterator with the given DRM EDID.",
        "pre": {
            "drm_edid": "!=null"
        }
    },
    "kprobe:cea_db_iter_for_each": {
        "description": "Iterate through the CEA DB using the given iterator.",
        "pre": {
            "db": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:drm_detect_monitor_audio": {
        "description": "Check monitor audio capability",
        "pre": {
            "edid": "!=null",
            "CEA_extension_block": "exists",
            "basic_audio_support": {
                "condition": "CEA_extension_block && (edid_ext[3] & EDID_BASIC_AUDIO)",
                "description": "Monitor has basic audio support"
            },
            "CEA_audio_blocks": {
                "condition": "CEA_extension_block && exists(cea_db_tag(db) == CTA_DB_AUDIO)",
                "description": "Monitor has CEA audio blocks"
            },
            "supported_audio_format": {
                "condition": "CEA_audio_blocks && exists(cea_db_payload_len(db) > 0)",
                "description": "Monitor has supported audio format"
            }
        },
        "post": {
            "has_audio": {
                "condition": "basic_audio_support || supported_audio_format",
                "description": "True if the monitor supports audio, false otherwise"
            }
        }
    }
},
"edid": "!=null",
S,
{
    "kprobe:enum hdmi_quantization_rangedrm_default_rgb_quant_range": {
        "description": "Determines the default RGB quantization range for the mode, as specified in CEA-861.",
        "pre": {
            "mode": "!=null",
            "return_value": "in [HDMI_QUANTIZATION_RANGE_DEFAULT, HDMI_QUANTIZATION_RANGE_LIMITED, HDMI_QUANTIZATION_RANGE_FULL]"
        }
    }
},
{
    "kretprobe:edid_block_check": {
        "description": "Check the status of the EDID block and fix the header if necessary.",
        "pre": {
            "block": "!=null",
            "is_base_block": "!=null",
            "status": "== EDID_BLOCK_OK",
            "edid_block_tag(block)": "!=null"
        },
        "post": {
            "status": "== EDID_BLOCK_HEADER_FIXED"
        }
    }
},
{
    "kprobe:edid_block_check": {
        "description": "Check the status of the EDID block.",
        "pre": {
            "block": "!=null",
            "is_base_block": "bool"
        }
    },
    "kprobe:edid_block_status_valid": {
        "description": "Check if the status of the EDID block is valid.",
        "pre": {
            "status": "==EDID_BLOCK_OK",
            "block": "!=null"
        }
    },
    "kprobe:edid_block_tag": {
        "description": "Get the tag of the EDID block.",
        "pre": {
            "block": "!=null"
        }
    }
},
{
    "kretprobe:num_modes += add_detailed_modes": {
        "description": "Add detailed modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_cvt_modes": {
        "description": "Add CVT modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_standard_modes": {
        "description": "Add standard modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_established_modes": {
        "description": "Add established modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_cea_modes": {
        "description": "Add CEA modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_alternate_cea_modes": {
        "description": "Add alternate CEA modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:num_modes += add_displayid_detailed_modes": {
        "description": "Add DisplayID detailed modes to the number of modes.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:if (drm_edid->edid->features & DRM_EDID_FEATURE_CONTINUOUS_FREQ)num_modes += add_inferred_modes": {
        "description": "Add inferred modes to the number of modes if DRM_EDID_FEATURE_CONTINUOUS_FREQ is set.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null",
            "drm_edid->edid->features": "& DRM_EDID_FEATURE_CONTINUOUS_FREQ != 0"
        }
    },
    "kretprobe:if (info->quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))edid_fixup_preferred": {
        "description": "Fix up preferred modes if EDID_QUIRK_PREFER_LARGE_60 or EDID_QUIRK_PREFER_LARGE_75 is set in info->quirks.",
        "pre": {
            "connector": "!=null",
            "info->quirks": "& (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75) != 0"
        }
    },
    "kretprobe:return num_modes": {
        "description": "Return the number of modes.",
        "pre": {}
    },
    "kretprobe:_drm_update_tile_info": {
        "description": "Update tile info for the DRM connector.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    },
    "kretprobe:_drm_edid_connector_property_update": {
        "description": "Update connector properties for the DRM connector.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    }
},
{
    "drm_edid_connector_add_modes": {
        "description": "Add modes to the DRM connector based on the DRM EDID.",
        "pre": {
            "connector": "!=null",
            "drm_edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_add_edid_modes": {
        "description": "Add modes from EDID data, if available",
        "pre": {
            "connector": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kprobe:drm_add_edid_modes": {
        "description": "Add modes from EDID data, if available.",
        "pre": {
            "connector": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_add_modes_noedid": {
        "description": "Add modes for the connectors without EDID",
        "pre": {
            "connector": "!=null",
            "hdisplay": "<= connector->max_hdisplay",
            "vdisplay": "<= connector->max_vdisplay"
        },
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:drm_add_modes_noedid": {
        "description": "Add modes for the connectors without EDID",
        "pre": {
            "connector": "!=null",
            "hdisplay": "<= connector->max_hdisplay",
            "vdisplay": "<= connector->max_vdisplay"
        }
    }
},
{
    "kretprobe:drm_set_preferred_mode": {
        "description": "Sets the preferred mode of a connector",
        "pre": {
            "connector": "!=null",
            "hpref": "!=null",
            "vpref": "!=null"
        }
    }
},
{
    "kprobe:drm_set_preferred_mode": {
        "description": "Sets the preferred mode of a connector",
        "pre": {
            "connector": "!=null",
            "hpref": "!=null",
            "vpref": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_hdmi_avi_infoframe_from_display_mode": {
        "description": "Fill an HDMI AVI infoframe with data from a DRM display mode",
        "pre": {
            "frame": "!=null",
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:intdrm_hdmi_avi_infoframe_from_display_mode": {
        "description": "Fill an HDMI AVI infoframe with data from a DRM display mode.",
        "pre": {
            "frame": "!=null",
            "connector": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_hdmi_avi_infoframe_quant_range": {
        "description": "Fill the HDMI AVI infoframe quantization range information.",
        "pre": {
            "frame": "!=null",
            "connector": "!=null",
            "mode": "!=null",
            "rgb_quant_range": "in [HDMI_QUANTIZATION_RANGE_DEFAULT, HDMI_QUANTIZATION_RANGE_LIMITED, HDMI_QUANTIZATION_RANGE_FULL]"
        }
    }
},
{
    "kprobe:drm_hdmi_avi_infoframe_quant_range": {
        "description": "Fill the HDMI AVI infoframe quantization range information.",
        "pre": {
            "frame": "!=null",
            "connector": "!=null",
            "mode": "!=null",
            "rgb_quant_range": "in [HDMI_QUANTIZATION_RANGE_DEFAULT, HDMI_QUANTIZATION_RANGE_LIMITED, HDMI_QUANTIZATION_RANGE_FULL]"
        }
    }
},
S,
{
    "kprobe:intdrm_hdmi_vendor_infoframe_from_display_mode": {
        "description": "Fill an HDMI infoframe with data from a DRM display mode.",
        "pre": {
            "frame": "!=null",
            "connector": "!=null",
            "mode": "!=null",
            "mode->flags": "in [DRM_MODE_FLAG_4K, DRM_MODE_FLAG_3D]",
            "return": "==0"
        }
    }
},
{
    "kretprobe:drm_fb_clip_offset": {
        "description": "Returns the clipping rectangles byte-offset in a framebuffer",
        "pre": {
            "pitch": "!=null",
            "format": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_clip_offset": {
        "description": "Returns the clipping rectangles byte-offset in a framebuffer",
        "pre": {
            "pitch": "!=null",
            "format": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_memcpy": {
        "description": "Copy clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_memcpy": {
        "description": "Copy clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_swab": {
        "description": "Swap bytes into clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null",
            "cached": "is_boolean"
        }
    }
},
{
    "kprobe:drm_fb_swab": {
        "description": "Swap bytes into clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null",
            "cached": "is_boolean"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_rgb332": {
        "description": "Convert XRGB8888 to RGB332 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_rgb332": {
        "description": "Convert XRGB8888 to RGB332 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_rgb565_swab_line": {
        "description": "Conversion to RGB565|BIG_ENDIAN",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": ">0"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_rgb565_swab_line": {
        "description": "Converts XRGB8888 pixel format to RGB565 pixel format.",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": ">=0"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_xrgb1555": {
        "description": "Convert XRGB8888 to XRGB1555 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_xrgb1555": {
        "description": "Convert XRGB8888 to XRGB1555 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_argb1555_line": {
        "description": "Convert XRGB8888 to ARGB1555 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_argb1555_line": {
        "description": "Convert XRGB8888 to ARGB1555 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_rgba5551_line": {
        "description": "Convert XRGB8888 to RGBA5551 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_rgba5551_line": {
        "description": "Convert XRGB8888 to RGBA5551 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": ">=0"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_rgb888_line": {
        "description": "Convert XRGB8888 to RGB888 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_rgb888_line": {
        "description": "Convert XRGB8888 to RGB888 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_argb8888_line": {
        "description": "Convert XRGB8888 to ARGB8888 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_argb8888_line": {
        "description": "Convert XRGB8888 to ARGB8888 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_xrgb2101010": {
        "description": "Convert XRGB8888 to XRGB2101010 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_xrgb2101010": {
        "description": "Convert XRGB8888 to XRGB2101010 clip buffer",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_argb2101010_line": {
        "description": "Convert XRGB8888 to ARGB2101010 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_argb2101010_line": {
        "description": "Convert XRGB8888 to ARGB2101010 clip buffer",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": ">=0"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_gray8_line": {
        "description": "Convert XRGB8888 to grayscale",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_gray8_line": {
        "description": "Convert XRGB8888 to grayscale",
        "pre": {
            "dbuf": "!=null",
            "sbuf": "!=null",
            "pixels": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_blit": {
        "description": "Copy parts of a framebuffer to display memory",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "dst_format": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_blit": {
        "description": "Copy parts of a framebuffer to display memory",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "dst_format": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_xrgb8888_to_mono": {
        "description": "Convert XRGB8888 to monochrome",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_xrgb8888_to_mono": {
        "description": "Convert XRGB8888 to monochrome",
        "pre": {
            "dst": "!=null",
            "dst_pitch": "!=null",
            "src": "!=null",
            "fb": "!=null",
            "clip": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_build_fourcc_list": {
        "description": "Filters a list of supported color formats against the device's native formats.",
        "pre": {
            "dev": "!=null",
            "native_fourccs": "!=null",
            "native_nfourccs": ">=0",
            "fourccs_out": "!=null",
            "nfourccs_out": ">=0"
        }
    }
},
{
    "kprobe:drm_fb_build_fourcc_list": {
        "description": "Filters a list of supported color formats against the device's native formats.",
        "pre": {
            "dev": "!=null",
            "native_fourccs": "!=null",
            "native_nfourccs": ">=0",
            "fourccs_out": "!=null",
            "nfourccs_out": ">=0"
        }
    }
},
{
    "kretprobe:drm_vma_offset_manager_init": {
        "description": "Initialize new offset-manager",
        "pre": {
            "mgr": "!=null",
            "page_offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_vma_offset_manager_init": {
        "description": "Initialize new offset-manager",
        "pre": {
            "mgr": "!=null",
            "page_offset": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:drm_vma_offset_manager_destroy": {
        "description": "Destroy offset manager",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_vma_offset_manager_destroy": {
        "description": "Destroy offset manager",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_vma_offset_lookup_locked": {
        "description": "Find node in offset space",
        "pre": {
            "mgr": "!=null",
            "start": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kprobe:drm_vma_offset_lookup_locked": {
        "description": "Find node in offset space",
        "pre": {
            "mgr": "!=null",
            "start": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:drm_vma_offset_add": {
        "description": "Add a VMA offset to the DRM VMA offset manager.",
        "pre": {
            "mgr": "!=null",
            "node": "!=null",
            "pages": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
S,
{
    "kprobe:drm_vma_offset_manager_init": {
        "description": "Initialize new offset-manager",
        "pre": {
            "mgr": "!=null",
            "page_offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_vma_node_allow_once": {
        "description": "Add open-file to list of allowed users",
        "pre": {
            "node": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:drm_vma_node_allow_once": {
        "description": "Add open-file to list of allowed users",
        "pre": {
            "node": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:drm_vma_node_is_allowed": {
        "description": "Check whether an open-file is granted access",
        "pre": {
            "node": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:drm_vma_node_is_allowed": {
        "description": "Check whether an open-file is granted access",
        "pre": {
            "node": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:drm_helper_encoder_in_use": {
        "description": "Check if a given encoder is in use",
        "pre": {
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_helper_encoder_in_use": {
        "description": "Check if a given encoder is in use",
        "pre": {
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_helper_crtc_in_use": {
        "description": "Check if a given CRTC is in use by any connector.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_helper_crtc_in_use": {
        "description": "Check if a given CRTC is in use by any connector.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:encoder->crtc = NULL;}}drm_for_each_crtc(crtc, dev)": {
        "description": "Disable unused functions for DRM device",
        "pre": {
            "encoder": "!=null",
            "crtc": "!=null",
            "dev": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_crtc_helper_set_mode": {
        "description": "internal helper to set a mode",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null",
            "x": "int",
            "y": "int",
            "old_fb": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_helper_set_mode": {
        "description": "Internal helper to set a mode",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null",
            "x": "int",
            "y": "int",
            "old_fb": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_helper_atomic_check": {
        "description": "Helper to check CRTC atomic-state",
        "pre": {
            "crtc": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_helper_atomic_check": {
        "description": "Helper to check CRTC atomic-state",
        "pre": {
            "crtc": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_helper_encoder_in_use": {
        "description": "Check if a given encoder is in use",
        "pre": {
            "encoder": "!=null"
        },
        "post": {
            "return": "in [True, False]"
        }
    }
},
{
    "kprobe:drm_helper_encoder_in_use": {
        "description": "Check if a given encoder is in use by any connector in the current mode setting output configuration.",
        "pre": {
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_helper_connector_dpms": {
        "description": "connector dpms helper implementation",
        "pre": {
            "connector": "!=null",
            "mode": "in [DPMS_MODE_ON, DPMS_MODE_OFF, DPMS_MODE_STANDBY, DPMS_MODE_SUSPEND]"
        }
    }
},
{
    "kprobe:drm_helper_connector_dpms": {
        "description": "connector dpms helper implementation",
        "pre": {
            "connector": "!=null",
            "mode": "in [DPMS_MODE_ON, DPMS_MODE_OFF, DPMS_MODE_STANDBY, DPMS_MODE_SUSPEND]"
        }
    }
},
{
    "kretprobe:drm_helper_force_disable_all": {
        "description": "Forcibly turn off all enabled CRTCs",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_helper_force_disable_all": {
        "description": "Forcibly turn off all enabled CRTCs",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_client_modeset_probe": {
        "description": "Probe for displays",
        "pre": {
            "client": "!=null",
            "width": ">=0",
            "height": ">=0"
        }
    }
},
{
    "kprobe:drm_client_modeset_probe": {
        "description": "Probe for displays",
        "pre": {
            "client": "!=null",
            "width": ">=0",
            "height": ">=0"
        }
    }
},
{
    "kretprobe:drm_client_rotation": {
        "description": "Check the initial rotation value",
        "pre": {
            "modeset": "!=null",
            "rotation": "!=null",
            "rotation": "in [0, 180]"
        },
        "post": {
            "return": "in [True, False]"
        }
    }
},
{
    "kprobe:drm_client_rotation": {
        "description": "Check the initial rotation value",
        "pre": {
            "modeset": "!=null",
            "rotation": "!=null",
            "rotation": "in [0, 180]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_client_modeset_check": {
        "description": "Check modeset configuration",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:drm_client_modeset_check": {
        "description": "Check modeset configuration",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:drm_client_modeset_commit_locked": {
        "description": "Force commit CRTC configuration",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:drm_client_modeset_commit_locked": {
        "description": "Force commit CRTC configuration",
        "pre": {
            "client": "!=null",
            "drm_master_reference": "acquired with drm_master_internal_acquire()"
        }
    }
},
{
    "kretprobe:drm_client_modeset_commit_atomic": {
        "description": "Commit atomic modeset for DRM client",
        "pre": {
            "client": "!=null",
            "active": "bool",
            "check": "bool",
            "dev": "!=null",
            "plane": "!=null",
            "state": "!=null",
            "ctx": "!=null",
            "mode_set": "!=null",
            "ret": "int"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:drm_client_modeset_commit_atomic": {
        "description": "Commit atomic modeset for a DRM client device.",
        "pre": {
            "client": "!=null",
            "active": "bool",
            "check": "bool",
            "dev": "client->dev",
            "plane": "drm_for_each_plane(dev)",
            "state": "drm_atomic_state_alloc(dev)",
            "ctx": "drm_modeset_acquire_init(&ctx, 0)",
            "mode_set": "drm_mode_set",
            "ret": "int"
        },
        "post": {
            "ret": "int"
        }
    }
},
{
    "kretprobe:drm_client_modeset_dpms": {
        "description": "Set DPMS mode",
        "pre": {
            "client": "!=null",
            "mode": "in [DPMS_ON, DPMS_OFF, DPMS_STANDBY, DPMS_SUSPEND, DPMS_UNKNOWN]",
            "dev": "!=null",
            "connector": "!=null",
            "modeset": "!=null",
            "ctx": "!=null",
            "j": ">=0",
            "ret": "int"
        }
    }
},
{
    "kprobe:drm_client_modeset_dpms": {
        "description": "Set DPMS mode for DRM client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_connector_type_name": {
        "description": "Return a string for the connector type.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:drm_get_connector_type_name": {
        "description": "Return a string for connector type",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_find_by_fwnode": {
        "description": "Global connector list for drm_connector_find_by_fwnode().",
        "pre": {
            "connector": "!=null",
            "connector->lock": "acquired",
            "connector_list_lock": "acquired"
        }
    }
},
{
    "kprobe:drm_connector_find_by_fwnode": {
        "description": "Global connector list for drm_connector_find_by_fwnode(). Note drm_connector_[un]register() first take connector->lock and then take the connector_list_lock.",
        "pre": {
            "connector": "!=null",
            "connector->lock": "acquired",
            "connector_list_lock": "acquired"
        }
    }
},
{
    "kretprobe:drm_connector_init_with_ddc": {
        "description": "Init a preallocated connector",
        "pre": {
            "dev": "!=null",
            "connector": "!=null",
            "funcs": "!=null",
            "connector_type": "int",
            "ddc": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_init_with_ddc": {
        "description": "Init a preallocated connector",
        "pre": {
            "dev": "!=null",
            "connector": "!=null",
            "funcs": "!=null",
            "connector_type": "int",
            "ddc": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_connector_init": {
        "description": "Initialize a DRM connector structure.",
        "pre": {
            "dev": "!=null",
            "connector": "!=null",
            "funcs": "!=null",
            "connector_type": "int"
        }
    }
},
{
    "kretprobe:drm_connector_has_possible_encoder": {
        "description": "Check if the connector and encoder are associated with each other.",
        "pre": {
            "connector": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_has_possible_encoder": {
        "description": "Check if the connector and encoder are associated with each other.",
        "pre": {
            "connector": "!=null",
            "encoder": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_register": {
        "description": "Register userspace interfaces for a connector.",
        "pre": {
            "connector->tile_group": "is_null",
            "connector->probed_modes": "is_empty",
            "connector->modes": "is_empty",
            "connector->connector_type_id": "is_null",
            "connector->display_info.bus_formats": "is_null",
            "connector->display_info.vics": "is_null",
            "connector->name": "is_null",
            "connector->fwnode": "is_null",
            "connector->state": "is_null",
            "connector->funcs->atomic_destroy_state": "is_not_null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:drm_connector_register": {
        "description": "Register a connector",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_connector_status_name": {
        "description": "Return a string for the connector status.",
        "pre": {
            "status": "!=null"
        }
    }
},
{
    "kprobe:drm_get_connector_status_name": {
        "description": "Return a string for connector status",
        "pre": {
            "status": "in [DRM_CONNECTOR_STATUS_UNKNOWN, DRM_CONNECTOR_STATUS_DISCONNECTED, DRM_CONNECTOR_STATUS_CONNECTED, DRM_CONNECTOR_STATUS_DISCONNECTED, DRM_CONNECTOR_STATUS_UNPLUGGED, DRM_CONNECTOR_STATUS_NOTPRESENT, DRM_CONNECTOR_STATUS_BAD]"
        }
    }
},
S,
S,
{
    "kretprobe:drm_get_subpixel_order_name": {
        "description": "return a string for a given subpixel enum",
        "pre": {
            "order": "!=null"
        }
    }
},
{
    "kprobe:drm_get_subpixel_order_name": {
        "description": "Return a string for a given subpixel enum.",
        "pre": {
            "order": "!=null"
        }
    }
},
{
    "kretprobe:drm_display_info_set_bus_formats": {
        "description": "Set the supported bus formats",
        "pre": {
            "info": "!=null",
            "formats": "!=null",
            "num_formats": ">=0"
        }
    }
},
{
    "kprobe:drm_display_info_set_bus_formats": {
        "description": "Set the supported bus formats",
        "pre": {
            "info": "!=null",
            "formats": "!=null",
            "num_formats": ">=0"
        }
    }
},
{
    "kretprobe:drm_get_tv_mode_from_name": {
        "description": "Translates a TV mode name into its enum value",
        "pre": {
            "name": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_get_tv_mode_from_name": {
        "description": "Translates a TV mode name into its enum value",
        "pre": {
            "name": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:drm_mode_create_dvi_i_properties": {
        "description": "Create DVI-I specific connector properties",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_create_dvi_i_properties": {
        "description": "Create DVI-I specific connector properties",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_attach_dp_subconnector_property": {
        "description": "Create subconnector property for DP",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_attach_dp_subconnector_property": {
        "description": "Create subconnector property for DP",
        "pre": {
            "connector": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_connector_attach_tv_margin_properties": {
        "description": "Attach TV connector margin properties",
        "pre": {
            "connector": "!=null",
            "connector->dev": "!=null",
            "connector->dev->mode_config.content_type_property": "!=null",
            "connector->base": "!=null"
        }
    }
},
{
    "drm_connector_attach_tv_margin_properties": {
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_create_standard_properties": {
        "description": "Create standard properties for a DRM connector.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_create_standard_properties": {
        "description": "Create standard properties for a DRM connector.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_create_tv_margin_properties": {
        "description": "Create TV margin properties for a DRM device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL, -ENOMEM, ...]"
        }
    }
},
S,
S,
S,
{
    "kretprobe:drm_mode_create_scaling_mode_property": {
        "description": "Create scaling mode property",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_connector_attach_vrr_capable_property": {
        "description": "Creates the vrr_capable property on the connector.",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_connector_attach_vrr_capable_property": {
        "description": "Creates the vrr_capable property on the connector.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_create_aspect_ratio_property": {
        "description": "Create aspect ratio property for DRM device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_mode_create_aspect_ratio_property": {
        "description": "Create aspect ratio property",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_mode_create_colorspace_property": {
        "description": "Create colorspace property for DRM connector.",
        "pre": {
            "connector": "!=null",
            "supported_colorspaces": "!=null"
        }
    }
},
{
    "kretprobe:drm_mode_create_suggested_offset_properties": {
        "description": "Create the suggested xy offset property for connectors.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
S,
{
    "kretprobe:drm_connector_attach_hdr_output_metadata_property": {
        "description": "Attach 'HDR_OUTPUT_METADATA' property to the given connector.",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_connector_attach_hdr_output_metadata_property": {
        "description": "Attach \"HDR_OUTPUT_METADATA\" property to the given connector.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_attach_colorspace_property": {
        "description": "Attach \"Colorspace\" property to the connector.",
        "pre": {
            "connector": "!=null"
        },
        "post": {
            "return_value": "in [0, -errno]"
        }
    }
},
{
    "kprobe:drm_connector_attach_colorspace_property": {
        "description": "Attach \"Colorspace\" property to the given connector.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_atomic_hdr_metadata_equal": {
        "description": "Checks if the hdr metadata changed",
        "pre": {
            "old_state": "!=null",
            "new_state": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_atomic_hdr_metadata_equal": {
        "description": "Checks if the hdr metadata changed",
        "pre": {
            "old_state": "!=null",
            "new_state": "!=null"
        }
    }
},
{
    "kretprobe:ida_alloc_max": {
        "description": "Allocate an ID from the IDA object with a maximum ID limit.",
        "pre": {
            "ida": "!=null",
            "id": "31",
            "gfp": "GFP_KERNEL"
        }
    }
},
{
    "kprobe:ida_alloc_max": {
        "description": "Allocate a new ID from the IDA object with a maximum ID value.",
        "pre": {
            "config": "!=null",
            "config->connector_ida": "!=null",
            "31": ">=0",
            "GFP_KERNEL": "in [GFP_KERNEL, GFP_ATOMIC]"
        }
    }
},
{
    "kretprobe:drm_connector_set_orientation_from_panel": {
        "description": "Set the connector's panel_orientation from panel's callback.",
        "pre": {
            "connector": "!=null",
            "panel": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_connector_set_orientation_from_panel": {
        "description": "Set the connector's panel_orientation from panel's callback.",
        "pre": {
            "connector": "!=null",
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_create_privacy_screen_properties": {
        "description": "Create the drm connector's privacy-screen properties.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_create_privacy_screen_properties": {
        "description": "Create the drm connector's privacy-screen properties.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_attach_privacy_screen_properties": {
        "description": "Attach the drm connector's privacy-screen properties.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_attach_privacy_screen_properties": {
        "description": "Attach the drm connector's privacy-screen properties.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_attach_privacy_screen_provider": {
        "description": "Attach a privacy-screen to the connector.",
        "pre": {
            "connector": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_attach_privacy_screen_provider": {
        "description": "Attach a privacy-screen to the connector.",
        "pre": {
            "connector": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:drm_connector_oob_hotplug_event": {
        "description": "Report out-of-band hotplug event to connector",
        "pre": {
            "connector_fwnode": "!=null"
        }
    }
},
{
    "kprobe:drm_connector_oob_hotplug_event": {
        "description": "Report out-of-band hotplug event to connector",
        "pre": {
            "connector_fwnode": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:void__drm_gem_duplicate_shadow_plane_state": {
        "description": "duplicates shadow-buffered plane state",
        "pre": {
            "plane": "!=null",
            "new_shadow_plane_state": "!=null"
        }
    }
},
{
    "kprobe:void__drm_gem_duplicate_shadow_plane_state": {
        "description": "duplicates shadow-buffered plane state",
        "pre": {
            "plane": "!=null",
            "new_shadow_plane_state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_gem_destroy_shadow_plane_state": {
        "description": "Cleans up shadow-buffered plane state.",
        "pre": {
            "shadow_plane_state": "!=null"
        }
    }
},
{
    "kprobe:__drm_gem_destroy_shadow_plane_state": {
        "description": "Cleans up shadow-buffered plane state.",
        "pre": {
            "shadow_plane_state": "!=null"
        }
    }
},
{
    "kretprobe:__drm_gem_reset_shadow_plane": {
        "description": "Resets state for shadow-buffered planes.",
        "pre": {
            "plane": "!=null",
            "shadow_plane_state": "!=null"
        }
    }
},
{
    "kprobe:__drm_gem_reset_shadow_plane": {
        "description": "Resets state for shadow-buffered planes.",
        "pre": {
            "plane": "!=null",
            "shadow_plane_state": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_gem_simple_kms_begin_shadow_fb_access": {
        "description": "Prepares shadow framebuffers for CPU access.",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_simple_kms_begin_shadow_fb_access": {
        "description": "Prepares shadow framebuffers for CPU access.",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_simple_kms_end_shadow_fb_access": {
        "description": "Releases shadow framebuffers from CPU access",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_simple_kms_end_shadow_fb_access": {
        "description": "Releases shadow framebuffers from CPU access.",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_simple_kms_reset_shadow_plane": {
        "description": "Resets a shadow-buffered plane",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_simple_kms_reset_shadow_plane": {
        "description": "Resets a shadow-buffered plane.",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_simple_kms_duplicate_shadow_plane_state": {
        "description": "duplicates shadow-buffered plane state",
        "pre": {
            "pipe": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_simple_kms_duplicate_shadow_plane_state": {
        "description": "Duplicates shadow-buffered plane state",
        "pre": {
            "pipe": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_simple_kms_destroy_shadow_plane_state": {
        "description": "Resets shadow-buffered plane state",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_simple_kms_destroy_shadow_plane_state": {
        "description": "Resets shadow-buffered plane state",
        "pre": {
            "pipe": "!=null",
            "plane_state": "!=null",
            "plane_state.type": "==struct drm_shadow_plane_state",
            "shadow_buffer_mappings_released": "==true"
        }
    }
},
{
    "kretprobe:drm_panel_init": {
        "description": "Initialize a DRM panel.",
        "pre": {
            "panel": "!=null",
            "dev": "!=null",
            "funcs": "!=null",
            "connector_type": "int"
        }
    }
},
S,
{
    "kretprobe:drm_panel_remove": {
        "description": "Remove a panel from the global registry.",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_remove": {
        "description": "Remove a panel from the global registry.",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_prepare": {
        "description": "Power on a panel",
        "pre": {
            "panel": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_panel_prepare": {
        "description": "Power on a panel",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_unprepare": {
        "description": "Power off a panel",
        "pre": {
            "panel": "!=null"
        },
        "post": {
            "return": "in [0, -error_code]"
        }
    }
},
{
    "kprobe:drm_panel_unprepare": {
        "description": "Power off a panel",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_enable": {
        "description": "Enable a panel",
        "pre": {
            "panel": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_panel_enable": {
        "description": "Enable a panel",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_disable": {
        "description": "Disable a panel",
        "pre": {
            "panel": "!=null"
        },
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:drm_panel_disable": {
        "description": "Disable a panel",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_get_modes": {
        "description": "Probe the available display modes of a panel",
        "pre": {
            "panel": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_get_modes": {
        "description": "Probe the available display modes of a panel",
        "pre": {
            "panel": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:of_drm_find_panel": {
        "description": "Look up a panel using a device tree node",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "of_drm_find_panel": {
        "description": "Look up a panel using a device tree node",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:of_drm_get_panel_orientation": {
        "description": "Look up the orientation of the panel through the 'rotation' binding from a device tree node.",
        "pre": {
            "np": "!=null",
            "orientation": "!=null"
        },
        "post": {
            "return": "in [0, <negative error code>]"
        }
    }
},
{
    "kprobe:of_drm_get_panel_orientation": {
        "description": "Look up the orientation of the panel through the 'rotation' binding from a device tree node",
        "pre": {
            "np": "!=null",
            "orientation": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_of_backlight": {
        "description": "Use backlight device node for backlight",
        "pre": {
            "panel": "!=null",
            "drm_panel_init_called": "==true",
            "drm_panel_funcs.enable_called": "==true",
            "drm_panel_funcs.disable_called": "==true"
        }
    }
},
{
    "kprobe:drm_panel_of_backlight": {
        "description": "Use backlight device node for backlight",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_init": {
        "description": "Initialize the DRM buddy manager and its resources.",
        "pre": {
            "mm": "!=null",
            "size": ">=0",
            "chunk_size": ">=0"
        }
    }
},
{
    "kprobe:drm_buddy_init": {
        "description": "Initialize the DRM buddy manager and its resources.",
        "pre": {
            "mm": "!=null",
            "size": ">=0",
            "chunk_size": ">=0"
        }
    }
},
{
    "kretprobe:drm_buddy_fini": {
        "description": "Tear down the memory manager",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kprobe:drm_buddy_fini": {
        "description": "Tear down the memory manager",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kretprobe:drm_get_buddy": {
        "description": "Get the buddy address for a DRM buddy block",
        "pre": {
            "block": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_get_buddy": {
        "description": "Get the buddy address for a DRM buddy block",
        "pre": {
            "block": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_free_block": {
        "description": "free a block",
        "pre": {
            "mm": "!=null",
            "block": "!=null"
        }
    }
},
{
    "kprobe:drm_buddy_free_block": {
        "description": "Free a block",
        "pre": {
            "mm": "!=null",
            "block": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_free_list": {
        "description": "free blocks",
        "pre": {
            "mm": "!=null",
            "objects": "!=null"
        }
    }
},
{
    "kprobe:drm_buddy_free_list": {
        "description": "Free blocks in the DRM buddy manager.",
        "pre": {
            "mm": "!=null",
            "objects": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_block_trim": {
        "description": "Free unused pages",
        "pre": {
            "mm": "!=null",
            "new_size": "!=null",
            "blocks": "!=null",
            "blocks.length": "==1",
            "blocks[0].size": ">=new_size",
            "blocks[0].order": ">=0",
            "blocks[0].order": "<=31"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:drm_buddy_block_trim": {
        "description": "Free unused pages",
        "pre": {
            "mm": "!=null",
            "new_size": "!=null",
            "blocks": "!=null",
            "blocks.length": "==1",
            "blocks[0].size": ">=new_size",
            "blocks[0].size": "is_power_of_two",
            "blocks[0].order": ">=0",
            "blocks[0].order": "<=31"
        },
        "post": {
            "return": "is_success_code"
        }
    }
},
{
    "kretprobe:drm_buddy_alloc_blocks": {
        "description": "Allocate power-of-two blocks",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "end": "!=null",
            "size": "!=null",
            "min_page_size": "!=null",
            "blocks": "!=null",
            "flags": "unsigned long"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:drm_buddy_alloc_blocks": {
        "description": "Allocate power-of-two blocks",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "end": "!=null",
            "size": "!=null",
            "min_page_size": "!=null",
            "blocks": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_block_print": {
        "description": "print block information",
        "pre": {
            "mm": "!=null",
            "block": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:drm_buddy_block_print": {
        "description": "Print block information",
        "pre": {
            "mm": "!=null",
            "block": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:drm_buddy_print": {
        "description": "Print allocator state",
        "pre": {
            "mm": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:drm_buddy_print": {
        "description": "Print allocator state",
        "pre": {
            "mm": "!=null",
            "p": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_sysfs_connector_hotplug_event": {
        "description": "Generate a DRM uevent for any connector change",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_sysfs_connector_hotplug_event": {
        "description": "Generate a DRM uevent for any connector change.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_debug_enter": {
        "description": "Implementation for &fb_ops.fb_debug_enter",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_debug_enter": {
        "description": "Implementation for &fb_ops.fb_debug_enter",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_debug_leave": {
        "description": "Implementation for &fb_ops.fb_debug_leave",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_debug_leave": {
        "description": "Implementation for &fb_ops.fb_debug_leave",
        "pre": {
            "info": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_fb_helper_blank": {
        "description": "Implementation for &fb_ops.fb_blank",
        "pre": {
            "blank": "in [FB_BLANK_UNBLANK, FB_BLANK_NORMAL, FB_BLANK_HSYNC_SUSPEND, FB_BLANK_VSYNC_SUSPEND, FB_BLANK_POWERDOWN]",
            "info": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_blank": {
        "description": "Implementation for &fb_ops.fb_blank",
        "pre": {
            "blank": "in [FB_BLANK_UNBLANK, FB_BLANK_NORMAL, FB_BLANK_HSYNC_SUSPEND, FB_BLANK_VSYNC_SUSPEND, FB_BLANK_POWERDOWN]",
            "info": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_fb_helper_restore_lut_atomic": {
        "description": "Restore the lookup table (LUT) for a given DRM CRTC atomically.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_unprepare": {
        "description": "Clean up a drm_fb_helper structure.",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_unprepare": {
        "description": "Clean up a drm_fb_helper structure",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_alloc_info": {
        "description": "Allocate a fb_info structure for the given drm_fb_helper.",
        "pre": {
            "fb_helper": "!=null"
        },
        "post": {
            "return_value": {
                "type": "fb_info*",
                "constraints": [
                    "!=null",
                    "if error code, check error code constraints"
                ]
            }
        }
    }
},
{
    "kprobe:drm_fb_helper_alloc_info": {
        "description": "Allocate a struct fb_info for the given drm_fb_helper.",
        "pre": {
            "fb_helper": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_release_info": {
        "description": "Release fb_info and its members",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_release_info": {
        "description": "Release fb_info and its members",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_unregister_info": {
        "description": "Unregister fb_info framebuffer device",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_unregister_info": {
        "description": "Unregister fb_info framebuffer device",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_set_suspend": {
        "description": "Sets the suspend state of the drm_fb_helper.",
        "pre": {
            "fb_helper": "!=null",
            "suspend": "in [true, false]"
        }
    }
},
S,
{
    "kretprobe:drm_fb_helper_setcmap": {
        "description": "Implementation for &fb_ops.fb_setcmap",
        "pre": {
            "cmap": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_setcmap": {
        "description": "Implementation for &fb_ops.fb_setcmap",
        "pre": {
            "cmap": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_ioctl": {
        "description": "Legacy ioctl implementation",
        "pre": {
            "info": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_ioctl": {
        "description": "Legacy ioctl implementation",
        "pre": {
            "info": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_check_var": {
        "description": "Implementation for &fb_ops.fb_check_var",
        "pre": {
            "var": "!=null",
            "info": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_fb_helper_pan_display": {
        "description": "Implementation for &fb_ops.fb_pan_display",
        "pre": {
            "var": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_pan_display": {
        "description": "Implementation for &fb_ops.fb_pan_display",
        "pre": {
            "var": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_fill_info": {
        "description": "Initializes fbdev information",
        "pre": {
            "info": "!=null",
            "fb_helper": "!=null",
            "sizes": "!=null"
        }
    }
},
{
    "kprobe:drm_fb_helper_fill_info": {
        "description": "Initializes fbdev information",
        "pre": {
            "info": "!=null",
            "fb_helper": "!=null",
            "sizes": "!=null"
        }
    }
},
{
    "kretprobe:drm_fb_helper_restore_fbdev_mode_unlocked": {
        "description": "restore fbdev configuration",
        "pre": {
            "fb_helper": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    }
},
{
    "kprobe:drm_fb_helper_restore_fbdev_mode_unlocked": {
        "description": "Restore fbdev configuration",
        "pre": {
            "fb_helper": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_vram_create": {
        "description": "Creates a VRAM-backed GEM object",
        "pre": {
            "dev": "!=null",
            "size": "!=null",
            "pg_align": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_vram_create": {
        "description": "Creates a VRAM-backed GEM object",
        "pre": {
            "dev": "!=null",
            "size": "!=null",
            "pg_align": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_vram_put": {
        "description": "Releases a reference to a VRAM-backed GEM object",
        "pre": {
            "gbo": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_vram_put": {
        "description": "Releases a reference to a VRAM-backed GEM object",
        "pre": {
            "gbo": "!=null"
        }
    }
},
{
    "kretprobe:drmm_vram_helper_init": {
        "description": "Allocates and initializes an instance of struct drm_vram_mm in struct drm_device.vram_mm.",
        "pre": {
            "dev": "!=null",
            "vram_base": "!=null",
            "vram_size": "!=null"
        }
    }
},
{
    "kprobe:drmm_vram_helper_init": {
        "description": "The function allocates and initializes an instance of &struct drm_vram_mm in &struct drm_device.vram_mm.",
        "pre": {
            "dev": "!=null",
            "vram_base": "!=null",
            "vram_size": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_vram_fill_create_dumb": {
        "description": "Helper for implementing &struct drm_driver.dumb_create",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "pg_align": ">=0",
            "pitch_align": ">=0",
            "args": "!=null"
        }
    }
},
{
    "kprobe:drm_gem_vram_fill_create_dumb": {
        "description": "Helper for implementing &struct drm_driver.dumb_create",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "pg_align": ">=0",
            "pitch_align": ">=0",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_vram_driver_dumb_create": {
        "description": "Implements &struct drm_driver.dumb_create",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "args": "!=null",
            "dev.vram_mm": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_gem_vram_driver_dumb_create": {
        "description": "Implements &struct drm_driver.dumb_create",
        "pre": {
            "file": "!=null",
            "dev": "!=null",
            "args": "!=null",
            "dev.vram_mm": "!=null"
        }
    }
},
{
    "kretprobe:intdrm_gem_vram_plane_helper_prepare_fb": {
        "description": "Implements &struct drm_plane_helper_funcs.prepare_fb",
        "pre": {
            "plane": "!=null",
            "new_state": "!=null"
        }
    }
},
{
    "kprobe:intdrm_gem_vram_plane_helper_prepare_fb": {
        "description": "Implements &struct drm_plane_helper_funcs.prepare_fb",
        "pre": {
            "plane": "!=null",
            "new_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_gem_vram_simple_display_pipe_prepare_fb": {
        "description": "Prepares the framebuffer for a simple display pipe in DRM using GEM VRAM",
        "pre": {
            "pipe": "!=null",
            "new_state": "!=null"
        },
        "post": {
            "return_value": "int",
            "return_value >= 0": true
        }
    }
},
S,
{
    "kretprobe:drm_vram_mm_debugfs_init": {
        "description": "Register VRAM MM debugfs file.",
        "pre": {
            "minor": "!=null"
        }
    }
},
{
    "kprobe:drm_vram_mm_debugfs_init": {
        "description": "Register VRAM MM debugfs file.",
        "pre": {
            "minor": "!=null",
            "minor": "valid_pointer(struct drm_minor)"
        }
    }
},
{
    "kretprobe:drm_vram_helper_mode_valid": {
        "description": "Tests if a display mode's framebuffer fits into the available video memory.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "max_bpp": ">=0"
        }
    }
},
{
    "kprobe:drm_vram_helper_mode_valid": {
        "description": "Tests if a display mode's framebuffer fits into the available video memory.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "max_bpp": ">=0",
            "vmm": "dev->vram_mm",
            "fbsize": "mode->hdisplay * mode->vdisplay * max_bpp",
            "fbpages": "fbsize / PAGE_SIZE",
            "max_fbpages": "(vmm->vram_size / 2) >> PAGE_SHIFT",
            "fbpages > max_fbpages": "MODE_MEM",
            "fbpages <= max_fbpages": "MODE_OK"
        }
    }
},
{
    "kretprobe:of_find_mipi_dsi_device_by_node": {
        "description": "Find the MIPI DSI device matching a device tree node.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_find_mipi_dsi_device_by_node": {
        "description": "Find the MIPI DSI device matching a device tree node.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_device_register_full": {
        "description": "Create a MIPI DSI device",
        "pre": {
            "host": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_device_register_full": {
        "description": "Create a MIPI DSI device",
        "pre": {
            "host": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_device_unregister": {
        "description": "Unregister MIPI DSI device",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_device_unregister": {
        "description": "Unregister MIPI DSI device",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:of_find_mipi_dsi_host_by_node": {
        "description": "Find the MIPI DSI host matching a device tree node.",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_find_mipi_dsi_host_by_node": {
        "description": "Find the MIPI DSI host matching a device tree node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_host_register": {
        "description": "Register a MIPI DSI host",
        "pre": {
            "!of_property_present(node, \"reg\")": true,
            "of_mipi_dsi_device_add(host, node)": true,
            "mutex_lock(&host_lock)": true,
            "list_add_tail(&host->list, &host_list)": true,
            "mutex_unlock(&host_lock)": true,
            "return 0": true
        }
    }
},
{
    "kprobe:if (!of_property_present(node, \"reg\"))continue;of_mipi_dsi_device_add(host, node);}mutex_lock(&host_lock);list_add_tail(&host->list, &host_list);mutex_unlock(&host_lock);return 0;}EXPORT_SYMBOL(mipi_dsi_host_register": {
        "description": "Register a MIPI DSI host.",
        "pre": {
            "host": "!=null",
            "node": "!=null",
            "node.reg": "exists"
        }
    }
},
{
    "kretprobe:mipi_dsi_attach": {
        "description": "Attach a DSI device to its DSI host",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_attach": {
        "description": "Attach a DSI device to its DSI host.",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_packet_format_is_short": {
        "description": "Check if a packet is of the short format",
        "pre": {
            "type": "in [MIPI_DSI_GENERIC_SHORT_WRITE, MIPI_DSI_DCS_SHORT_WRITE]",
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:mipi_dsi_packet_format_is_short": {
        "description": "Check if a packet is of the short format",
        "pre": {
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]"
        }
    }
},
{
    "kretprobe:mipi_dsi_packet_format_is_long": {
        "description": "Check if a packet is of the long format",
        "pre": {
            "type": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:mipi_dsi_packet_format_is_long": {
        "description": "Check if a packet is of the long format",
        "pre": {
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]"
        }
    }
},
{
    "kretprobe:mipi_dsi_create_packet": {
        "description": "Create a packet from a message according to the DSI protocol",
        "pre": {
            "packet": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:mipi_dsi_create_packet": {
        "description": "Create a packet from a message according to the DSI protocol",
        "pre": {
            "packet": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_shutdown_peripheral": {
        "description": "Sends a Shutdown Peripheral command",
        "pre": {},
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:mipi_dsi_shutdown_peripheral": {
        "description": "Sends a Shutdown Peripheral command",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:mipi_dsi_turn_on_peripheral": {
        "description": "Sends a Turn On Peripheral command",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:mipi_dsi_turn_on_peripheral": {
        "description": "Sends a Turn On Peripheral command.",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_set_maximum_return_packet_size": {
        "description": "Specify the maximum size of the payload in a long packet transmitted from the peripheral back to the host processor.",
        "pre": {
            "dsi": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_set_maximum_return_packet_size": {
        "description": "Specify the maximum size of the payload in a long packet transmitted from the peripheral back to the host processor.",
        "pre": {
            "dsi": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_compression_mode": {
        "description": "Enable or disable Display Stream Compression on the peripheral using the default Picture Parameter Set and VESA DSC 1.1 algorithm.",
        "pre": {
            "dsi": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:mipi_dsi_compression_mode": {
        "description": "Enable or disable Display Stream Compression on the peripheral using the default Picture Parameter Set and VESA DSC 1.1 algorithm.",
        "pre": {
            "dsi": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:mipi_dsi_picture_parameter_set": {
        "description": "Transmit the VESA DSC 1.1 Picture Parameter Set to the peripheral.",
        "pre": {
            "dsi": "!=null",
            "pps": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:mipi_dsi_picture_parameter_set": {
        "description": "Transmit the DSC PPS to the peripheral",
        "pre": {
            "dsi": "!=null",
            "pps": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_generic_write": {
        "description": "Transmit data using a generic write packet",
        "pre": {
            "dsi": "!=null",
            "payload": "!=null",
            "size": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_generic_write": {
        "description": "Transmit data using a generic write packet",
        "pre": {
            "dsi": "!=null",
            "payload": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_generic_read": {
        "description": "Receive data using a generic read packet",
        "pre": {
            "dsi": "!=null",
            "params": "!=null",
            "num_params": ">=0",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_generic_read": {
        "description": "Receive data using a generic read packet",
        "pre": {
            "dsi": "!=null",
            "params": "!=null",
            "num_params": ">=0",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_write_buffer": {
        "description": "Transmit a DCS command with payload",
        "pre": {
            "dsi": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_write_buffer": {
        "description": "Transmit a DCS command with payload",
        "pre": {
            "dsi": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_read": {
        "description": "Send DCS read request command",
        "pre": {
            "dsi": "!=null",
            "cmd": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_read": {
        "description": "Send DCS read request command",
        "pre": {
            "dsi": "!=null",
            "cmd": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_nop": {
        "description": "Send DCS nop packet",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return_value": "in [0, -error_code]"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_nop": {
        "description": "Send DCS nop packet",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_soft_reset": {
        "description": "Perform a software reset of the display module",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "in [0, -1, -2, -3, ...]" 
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_soft_reset": {
        "description": "Perform a software reset of the display module.",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_get_power_mode": {
        "description": "Query the display module's current power mode.",
        "pre": {
            "dsi": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_get_power_mode": {
        "description": "Query the display module's current power mode.",
        "pre": {
            "dsi": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_get_pixel_format": {
        "description": "Gets the pixel format for the RGB image data used by the interface.",
        "pre": {
            "dsi": "!=null",
            "format": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_get_pixel_format": {
        "description": "Gets the pixel format for the RGB image data used by the interface.",
        "pre": {
            "dsi": "!=null",
            "format": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_enter_sleep_mode": {
        "description": "Disable all unnecessary blocks inside the display module except interface communication.",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_enter_sleep_mode": {
        "description": "Disable all unnecessary blocks inside the display module except interface communication.",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_exit_sleep_mode": {
        "description": "enable all blocks inside the display module",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_exit_sleep_mode": {
        "description": "enable all blocks inside the display module",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "in [0, -error_code]"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_display_off": {
        "description": "Stop displaying the image data on the display device",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_display_off": {
        "description": "Stop displaying the image data on the display device.",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_display_on": {
        "description": "Start displaying the image data on the display device.",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_display_on": {
        "description": "start displaying the image data on the display device",
        "pre": {
            "dsi": "!=null"
        },
        "return": {
            "value": "0",
            "type": "int"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_column_address": {
        "description": "Define the column extent of the frame memory accessed by the host processor.",
        "pre": {
            "dsi": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_column_address": {
        "description": "Define the column extent of the frame memory accessed by the host processor.",
        "pre": {
            "dsi": "!=null",
            "start": "!=null",
            "end": "!=null",
            "return": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_page_address": {
        "description": "Define the page extent of the frame memory accessed by the host processor.",
        "pre": {
            "dsi": "!=null",
            "start": "!=null",
            "end": "!=null",
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_page_address": {
        "description": "Define the page extent of the frame memory accessed by the host processor.",
        "pre": {
            "dsi": "!=null",
            "start": "!=null",
            "end": "!=null",
            "return": ">=0"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_tear_off": {
        "description": "Turn off the display module's Tearing Effect output signal on the TE signal line.",
        "pre": {
            "dsi": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_tear_off": {
        "description": "Turn off the display module's Tearing Effect output signal on the TE signal line",
        "pre": {
            "dsi": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_tear_on": {
        "description": "Turn on the display module's Tearing Effect output signal on the TE signal line.",
        "pre": {
            "dsi": "!=null",
            "mode": "in [mipi_dsi_dcs_tear_mode values]"
        },
        "post": {
            "return": "in [0, negative error codes]"
        }
    }
},
S,
{
    "kretprobe:mipi_dsi_dcs_set_pixel_format": {
        "description": "Sets the pixel format for the RGB image data used by the interface",
        "pre": {
            "dsi": "!=null",
            "format": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL, -ENODEV, -ETIMEDOUT, ...]"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_pixel_format": {
        "description": "Sets the pixel format for the RGB image data used by the interface.",
        "pre": {
            "dsi": "!=null",
            "format": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_tear_scanline": {
        "description": "Set the scanline to use as trigger for the Tearing Effect output signal of the display module.",
        "pre": {
            "dsi": "!=null",
            "scanline": "!=null"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_tear_scanline": {
        "description": "Set the scanline to use as trigger for the Tearing Effect output signal of the display module.",
        "pre": {
            "dsi": "!=null",
            "scanline": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_display_brightness": {
        "description": "Sets the brightness value of the display",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        },
        "post": {
            "return_value": "in [0, -1, -2, -3, ...]" // Replace "..." with other possible error codes
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_display_brightness": {
        "description": "Sets the brightness value of the display.",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_get_display_brightness": {
        "description": "gets the current brightness value of the display",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        },
        "post": {
            "return_value": "in [0, -1, -2, -3, ...]" 
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_get_display_brightness": {
        "description": "Gets the current brightness value of the display.",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_set_display_brightness_large": {
        "description": "Sets the 16-bit brightness value of the display",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_set_display_brightness_large": {
        "description": "Sets the 16-bit brightness value of the display.",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null",
            "brightness": ">=0",
            "brightness": "<=65535"
        }
    }
},
{
    "kretprobe:mipi_dsi_dcs_get_display_brightness_large": {
        "description": "Gets the current 16-bit brightness value of the display",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mipi_dsi_dcs_get_display_brightness_large": {
        "description": "Gets the current 16-bit brightness value of the display.",
        "pre": {
            "dsi": "!=null",
            "brightness": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_driver_register_full": {
        "description": "Register a driver for DSI devices",
        "pre": {
            "drv": "!=null",
            "owner": "!=null"
        },
        "return_value": "is_integer"
    }
},
{
    "kprobe:mipi_dsi_driver_register_full": {
        "description": "Register a driver for DSI devices",
        "pre": {
            "drv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:mipi_dsi_driver_unregister": {
        "description": "Unregister a driver for DSI devices.",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return": "in [0, -ERRNO]"
        }
    }
},
{
    "kprobe:mipi_dsi_driver_unregister": {
        "description": "Unregister a driver for DSI devices.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_accurate_vblank_count": {
        "description": "Interpolates to handle a race with vblank interrupts using high precision timestamping support.",
        "pre": {
            "crtc": "!=null",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_accurate_vblank_count": {
        "description": "Interpolates to handle a race with vblank interrupts using high precision timestamping support.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_handle_vblank": {
        "description": "In the vblank interrupt handler, handles working vblank support.",
        "pre": {
            "drm_crtc_vblank_get()": "called",
            "drm_crtc_vblank_put()": "called",
            "vblank interrupts": "enabled",
            "vblankoffdelay": "configured",
            "drm_vblank_init()": "not called",
            "drm_crtc_state.no_vblank": "disabled"
        }
    }
},
{
    "kprobe:drm_crtc_handle_vblank": {
        "description": "In the vblank interrupt handler, handles working vblank support.",
        "pre": {
            "drm_crtc_state.no_vblank": "!=null",
            "drm_crtc_vblank_get()": "called before",
            "drm_crtc_vblank_put()": "called after drm_crtc_vblank_get()",
            "vblank interrupts": "enabled between drm_crtc_vblank_get() and drm_crtc_vblank_put()",
            "vblank interrupt disabling": "done in a race-free manner",
            "vblankoffdelay": "configured through module parameter",
            "drm_vblank_init()": "not called for hardware without vertical-blanking interrupt support",
            "struct drm_crtc_state.no_vblank": "can be enabled or disabled by the driver"
        }
    }
},
{
    "kretprobe:drm_dev_has_vblank": {
        "description": "Test if vblanking has been initialized for a device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_dev_has_vblank": {
        "description": "Test if vblanking has been initialized for a device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_vblank_waitqueue": {
        "description": "Get vblank waitqueue for the CRTC",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_vblank_waitqueue": {
        "description": "Get vblank waitqueue for the CRTC",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_calc_timestamping_constants": {
        "description": "Calculate timestamping constants based on CRTC's true scanout timing.",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null"
        },
        "helper": "drm_crtc_vblank_helper_get_vblank_timestamp()"
    }
},
{
    "kprobe:drm_calc_timestamping_constants": {
        "description": "Calculate timestamping constants based on the CRTC's true scanout timing.",
        "pre": {
            "crtc": "!=null",
            "mode": "!=null"
        },
        "helper": "drm_crtc_vblank_helper_get_vblank_timestamp()"
    }
},
{
    "kretprobe:booldrm_crtc_vblank_helper_get_vblank_timestamp_internal": {
        "description": "precise vblank timestamp helper",
        "pre": {
            "crtc": "!=null",
            "max_error": "!=null",
            "vblank_time": "!=null",
            "in_vblank_irq": "bool",
            "get_scanout_position": "!=null"
        }
    }
},
{
    "kprobe:booldrm_crtc_vblank_helper_get_vblank_timestamp_internal": {
        "description": "precise vblank timestamp helper",
        "pre": {
            "crtc": "!=null",
            "max_error": "!=null",
            "vblank_time": "!=null",
            "in_vblank_irq": "bool",
            "get_scanout_position": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_vblank_count": {
        "description": "Provide the software vblank counter.",
        "pre": {
            "crtc": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_crtc_vblank_count": {
        "description": "Provide a barrier: Any writes done before calling drm_crtc_handle_vblank() will be visible to callers of the later functions, if the vblank count is the same or a later one.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_next_vblank_start": {
        "description": "Calculate the time of the next vblank",
        "pre": {
            "crtc": "!=null",
            "vblanktime": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_next_vblank_start": {
        "description": "Calculate the time of the next vblank",
        "pre": {
            "crtc": "!=null",
            "vblanktime": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_arm_vblank_event": {
        "description": "Send a vblank event and prevent race condition with hardware atomic update.",
        "pre": {
            "crtc": "!=null",
            "e": "!=null",
            "vblank_reference": "held",
            "vblank_reference_dropped": "on_next_vblank"
        }
    }
},
{
    "kprobe:drm_crtc_arm_vblank_event": {
        "description": "Send a vblank event and prevent races with hardware atomic update.",
        "pre": {
            "crtc": "!=null",
            "e": "!=null",
            "drm_crtc_vblank_get()": "called before this function",
            "next vblank arrives": "event reference dropped"
        }
    }
},
{
    "kretprobe:drm_wait_one_vblank": {
        "description": "Wait for the next vertical blanking interval on the specified pipe of the DRM device.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null"
        }
    }
},
{
    "kprobe:drm_wait_one_vblank": {
        "description": "Wait for the next vertical blanking interval on the specified pipe of the DRM device.",
        "pre": {
            "dev": "!=null",
            "pipe": ">=0",
            "pipe": "<=max_pipe_value"
        }
    }
},
{
    "kretprobe:drm_update_vblank_count": {
        "description": "Updates the vblank count for a DRM device and disables vblank for a specific pipe.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null",
            "false": "true"
        }
    },
    "kretprobe:__disable_vblank": {
        "description": "Disables vblank for a specific pipe on a DRM device.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null"
        }
    },
    "kretprobe:vblank->enabled": {
        "description": "Sets the 'enabled' flag of the vblank structure to false.",
        "pre": {
            "vblank": "!=null"
        }
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Releases the spin lock and restores the IRQ flags.",
        "pre": {
            "dev": "!=null",
            "irqflags": "!=null"
        }
    },
    "kretprobe:drm_crtc_vblank_off": {
        "description": "Helper function to turn off vblank for a CRTC in DRM.",
        "pre": {}
    }
},
{
    "kprobe:drm_update_vblank_count": {
        "description": "Updates the vblank count for a DRM device and disables vblank for a specific pipe.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null",
            "false": "true"
        }
    },
    "kprobe:__disable_vblank": {
        "description": "Disables vblank for a specific pipe on a DRM device.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null"
        }
    },
    "kprobe:vblank->enabled": {
        "description": "Sets the 'enabled' flag of the vblank structure to false.",
        "pre": {
            "vblank": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Unlocks the spinlock and restores the IRQ flags.",
        "pre": {
            "dev": "!=null",
            "irqflags": "!=null"
        }
    },
    "kprobe:vblank_disable_fn": {
        "description": "Callback function for disabling vblank using a timer.",
        "pre": {
            "t": "!=null"
        }
    },
    "kprobe:drm_crtc_vblank_off": {
        "description": "Helper function for turning off vblank for a CRTC.",
        "pre": {}
    }
},
{
    "kretprobe:drm_crtc_vblank_reset": {
        "description": "Reset vblank state to off on a CRTC",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_vblank_reset": {
        "description": "Reset vblank state to off on a CRTC.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_crtc_set_max_vblank_count": {
        "description": "Configure the hw max vblank counter value",
        "pre": {
            "crtc": "!=null",
            "max_vblank_count": ">=0"
        }
    }
},
{
    "kprobe:drm_crtc_set_max_vblank_count": {
        "description": "Configure the hw max vblank counter value",
        "pre": {
            "crtc": "!=null",
            "max_vblank_count": "!=null"
        }
    }
},
{
    "kretprobe:drm_reset_vblank_timestamp": {
        "description": "Reset the vblank timestamp for a DRM device and a specific pipe.",
        "pre": {
            "dev": "!=null",
            "pipe": "!=null",
            "vbl_lock": "held",
            "vblank_fields": "readable and writable"
        }
    }
},
{
    "kprobe:drm_reset_vblank_timestamp": {
        "description": "Reset the vblank timestamp for a DRM device and a specific pipe.",
        "pre": {
            "dev": "!=null",
            "pipe": ">=0"
        }
    }
},
{
    "kretprobe:drm_crtc_vblank_restore": {
        "description": "Estimate missed vblanks and update vblank count.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_crtc_vblank_restore": {
        "description": "Estimate missed vblanks and update vblank count.",
        "pre": {
            "crtc": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:rgb->encoder.possible_crtcs": {
        "description": "Assign the value of drm_crtc_mask(&tcon->crtc->crtc) to rgb->encoder.possible_crtcs.",
        "pre": {
            "rgb": "!=null",
            "encoder": "!=null",
            "tcon": "!=null",
            "crtc": "!=null",
            "rgb->encoder.possible_crtcs": "!=null",
            "tcon->crtc->crtc": "!=null"
        }
    },
    "kretprobe:rgb->panel": {
        "description": "Check if rgb->panel is true.",
        "pre": {
            "rgb": "!=null",
            "panel": "==true"
        }
    }
},
{
    "kprobe:rgb->encoder.possible_crtcs": {
        "description": "Assign the value of drm_crtc_mask(&tcon->crtc->crtc) to rgb->encoder.possible_crtcs.",
        "pre": {
            "rgb->encoder.possible_crtcs": "!=null",
            "tcon->crtc->crtc": "!=null"
        }
    },
    "kprobe:rgb->panel": {
        "description": "Check if rgb->panel is true.",
        "pre": {
            "rgb->panel": "==true"
        }
    }
},
{
    "kretprobe:lvds->encoder.possible_crtcs": {
        "description": "Set the possible CRTCs for the LVDS encoder.",
        "pre": {
            "lvds": "!=null",
            "tcon": "!=null",
            "tcon->crtc": "!=null",
            "lvds->encoder": "!=null",
            "lvds->encoder.possible_crtcs": "!=null"
        }
    },
    "kretprobe:if (lvds->panel)": {
        "description": "Check if the LVDS panel is present.",
        "pre": {
            "lvds": "!=null",
            "lvds->panel": "!=null"
        }
    }
},
{
    "kprobe:lvds->encoder.possible_crtcs = drm_crtc_mask(&tcon->crtc->crtc);if (lvds->panel)": {
        "description": "Initialize the LVDS encoder and set possible CRTCs.",
        "pre": {
            "lvds": "!=null",
            "encoder": "!=null",
            "tcon": "!=null",
            "drm": "!=null",
            "crtc": "!=null",
            "panel": "!=null",
            "bridge": "!=null",
            "ret": "!=null",
            "sun4i_lvds_enc_helper_funcs": "!=null"
        },
        "post": {
            "lvds->encoder.possible_crtcs": "!=null"
        }
    }
},
{
    "kretprobe:sun4i_frontend_update_buffer": {
        "description": "Update the buffer in the sun4i_frontend structure",
        "pre": {
            "frontend": "!=null",
            "plane": "!=null",
            "state": "!=null",
            "fb": "!=null",
            "strides": "!=null",
            "dma_addr": "!=null",
            "swap": "!=null",
            "width": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:sun4i_frontend_update_buffer": {
        "description": "Update the buffer in the sun4i_frontend structure with the given plane",
        "pre": {
            "frontend": "!=null",
            "plane": "!=null",
            "plane->state": "!=null",
            "plane->state->fb": "!=null",
            "plane->state->fb->modifier": "==DRM_FORMAT_MOD_ALLWINNER_TILED",
            "plane->state->src_w": ">>16",
            "plane->state->src_w": ">0",
            "plane->state->src_w": "<=65535",
            "plane->state->fb->pitches[0]": "!=null"
        }
    }
},
{
    "kretprobe:ch1_phase_idx": {
        "description": "The value of ch1_phase_idx is determined based on the number of planes in the format.",
        "pre": {
            "format->num_planes": "> 1",
            "ch1_phase_idx": "= 1 when format->num_planes > 1, = 0 otherwise",
            "frontend->regs": "!= null",
            "frontend->data->ch_phase[0]": "!= null",
            "frontend->data->ch_phase[ch1_phase_idx]": "!= null",
            "SUN4I_FRONTEND_CH0_HORZPHASE_REG": "!= null",
            "SUN4I_FRONTEND_CH1_HORZPHASE_REG": "!= null",
            "SUN4I_FRONTEND_CH0_VERTPHASE0_REG": "!= null",
            "SUN4I_FRONTEND_CH1_VERTPHASE0_REG": "!= null",
            "SUN4I_FRONTEND_CH0_VERTPHASE1_REG": "!= null",
            "SUN4I_FRONTEND_CH1_VERTPHASE1_REG": "!= null"
        }
    }
},
{
    "kprobe:ch1_phase_idx": {
        "description": "Set the value of ch1_phase_idx based on the number of planes in the format",
        "pre": {
            "format->num_planes": "> 1",
            "ch1_phase_idx": "= 1 if format->num_planes > 1, else 0",
            "frontend->regs": "!= null",
            "frontend->data->ch_phase[0]": "!= null",
            "frontend->data->ch_phase[ch1_phase_idx]": "!= null",
            "SUN4I_FRONTEND_CH0_HORZPHASE_REG": "!= null",
            "SUN4I_FRONTEND_CH1_HORZPHASE_REG": "!= null",
            "SUN4I_FRONTEND_CH0_VERTPHASE0_REG": "!= null",
            "SUN4I_FRONTEND_CH1_VERTPHASE0_REG": "!= null",
            "SUN4I_FRONTEND_CH0_VERTPHASE1_REG": "!= null",
            "SUN4I_FRONTEND_CH1_VERTPHASE1_REG": "!= null"
        }
    }
},
S,
{
    "kprobe:DRM_DEBUG_DRIVER": {
        "description": "Frontend size W: %u H: %u\n",
        "pre": {
            "state->crtc_w": "!=null",
            "state->crtc_h": "!=null",
            "state->src_w": "!=null",
            "state->src_h": "!=null",
            "fb->format->hsub": "!=null",
            "fb->format->vsub": "!=null",
            "frontend->regs": "!=null"
        }
    }
},
{
    "kretprobe:sun4i_tcon0_mode_set_cpu": {
        "description": "Set the mode of sun4i_tcon0 for CPU encoder.",
        "pre": {
            "tcon": "!=null",
            "encoder": "!=null",
            "mode": "!=null",
            "encoder->encoder_type": "==DRM_MODE_ENCODER_DSI"
        }
    }
},
{
    "kprobe:sun4i_tcon_mode_set": {
        "description": "Set the mode for sun4i_tcon",
        "pre": {
            "tcon": "any",
            "encoder": "!=null",
            "mode": "any"
        }
    }
},
S,
S,
{
    "kretprobe:ttm_kmap_iter_tt_init": {
        "description": "Initialize a struct ttm_kmap_iter_tt",
        "pre": {
            "iter_tt": "!=null",
            "tt": "!=null"
        }
    }
},
{
    "kprobe:ttm_kmap_iter_tt_init": {
        "description": "Initialize a struct ttm_kmap_iter_tt",
        "pre": {
            "iter_tt": "!=null",
            "tt": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_vm_reserve": {
        "description": "Reserve a buffer object in a retryable vm callback",
        "pre": {
            "bo": "!=null",
            "vmf": "!=null"
        },
        "post": {
            "return": "in [0, VM_FAULT_RETRY, VM_FAULT_NOPAGE]"
        }
    }
},
{
    "kprobe:ttm_bo_vm_reserve": {
        "description": "Reserve a buffer object in a retryable vm callback",
        "pre": {
            "bo": "!=null",
            "vmf": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_vm_fault_reserved": {
        "description": "TTM fault helper",
        "pre": {
            "vmf": "!=null",
            "prot": "!=null",
            "num_prefault": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_vm_fault_reserved": {
        "description": "TTM fault helper",
        "pre": {
            "vmf": "!=null",
            "prot": "!=null",
            "num_prefault": "!=null"
        }
    }
},
{
    "kretprobe:alloc_page": {
        "description": "Allocate a page with GFP_KERNEL and __GFP_ZERO flags.",
        "pre": {
            "GFP_KERNEL": "true",
            "__GFP_ZERO": "true"
        },
        "post": {
            "page": "!=null"
        }
    },
    "kretprobe:__alloc_pages_nodemask": {
        "description": "Allocate a page with GFP_KERNEL and __GFP_ZERO flags.",
        "pre": {
            "GFP_KERNEL": "true",
            "__GFP_ZERO": "true"
        },
        "post": {
            "page": "!=null"
        }
    },
    "kretprobe:ttm_bo_vm_dummy_page": {
        "description": "Allocate new dummy page to map all the VA range in this VMA to it.",
        "pre": {
            "vmf": "!=null",
            "prot": "!=null",
            "vma": "!=null",
            "bo": "!=null",
            "ddev": "!=null",
            "ret": "!=null",
            "address": "!=null",
            "pfn": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:alloc_page": {
        "description": "Allocate a page with specified flags.",
        "pre": {
            "GFP_KERNEL": "!=null",
            "__GFP_ZERO": "!=null"
        },
        "post": {
            "page": "!=null"
        }
    },
    "kprobe:VM_FAULT_OOM": {
        "description": "Handle out-of-memory error during page allocation.",
        "pre": {
            "page": "==null"
        }
    },
    "kprobe:drmm_release_action": {
        "description": "Free the allocated page using drmm release action.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_test_signaled": {
        "description": "Check if the DMA reservation object is signaled for kernel usage.",
        "pre": {
            "bo->base.resv": "!=null",
            "DMA_RESV_USAGE_KERNEL": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:dma_resv_test_signaled": {
        "description": "Check if the DMA reservation object is signaled for kernel usage.",
        "pre": {
            "bo->base.resv": "!=null",
            "DMA_RESV_USAGE_KERNEL": "true"
        },
        "post": {
            "return": "0"
        }
    }
},
S,
S,
S,
{
    "kprobe:ttm_bo_mmap_obj": {
        "description": "mmap memory backed by a ttm buffer object.",
        "pre": {
            "vma": "!=null",
            "bo": "!=null"
        }
    }
},
{
    "kretprobe:ttm_eu_backoff_reservation_reverse": {
        "description": "Reverse the backoff of the reservation for the given list and entry.",
        "pre": {
            "list": "!=null",
            "entry": "!=null",
            "ret": "== -EDEADLK"
        }
    }
},
{
    "kprobe:ttm_eu_backoff_reservation_reverse": {
        "description": "Back off the reservation and reverse the list if the return value is -EDEADLK.",
        "pre": {
            "list": "!=null",
            "entry": "!=null",
            "ret": "== -EDEADLK"
        }
    }
},
{
    "kretprobe:ttm_range_man_init_nocheck": {
        "description": "Initialise a generic range manager for the selected memory type.",
        "pre": {
            "bdev": "!=null",
            "type": "!=null",
            "use_tt": "!=null",
            "p_size": "!=null"
        }
    }
},
{
    "kprobe:ttm_range_man_init_nocheck": {
        "description": "Initialise a generic range manager for the selected memory type.",
        "pre": {
            "bdev": "!=null",
            "type": "!=null",
            "use_tt": "!=null",
            "p_size": "!=null"
        }
    }
},
{
    "kretprobe:ttm_range_man_fini_nocheck": {
        "description": "Remove the generic range manager from a slot and tear it down.",
        "pre": {
            "bdev": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:ttm_range_man_fini_nocheck": {
        "description": "Remove the generic range manager from a slot and tear it down.",
        "pre": {
            "bdev": "!=null",
            "type": "unsigned"
        }
    }
},
{
    "kretprobe:ttm_global_mutex": {
        "description": "Protecting the global state",
        "pre": {
            "mutex": "!=null"
        }
    }
},
{
    "kprobe:ttm_global_mutex": {
        "description": "Protecting the global state",
        "pre": {
            "ttm_global_mutex": "!=null"
        }
    }
},
{
    "kretprobe:ttm_device_swapout": {
        "description": "Swap out the TTM device.",
        "pre": {
            "bdev": "!=null",
            "ctx": "!=null",
            "gfp_flags": "!=null"
        },
        "post": {
            "ret": "==0": "num_pages": "!=null",
            "ret": "!= -EBUSY": "ret": "!=null"
        }
    }
},
{
    "kprobe:ttm_device_swapout": {
        "description": "Swap out a TTM device.",
        "pre": {
            "bdev": "!=null",
            "ctx": "!=null",
            "gfp_flags": "any"
        }
    }
},
{
    "kretprobe:ttm_device_init": {
        "description": "Initializes a struct ttm_device",
        "pre": {
            "bdev": "!=null",
            "funcs": "!=null",
            "dev": "!=null",
            "mapping": "!=null",
            "vma_manager": "!=null",
            "use_dma_alloc": "in [true, false]",
            "use_dma32": "in [true, false]"
        }
    }
},
{
    "kprobe:ttm_device_init": {
        "description": "Initializes a struct ttm_device",
        "pre": {
            "bdev": "!=null",
            "funcs": "!=null",
            "dev": "!=null",
            "mapping": "!=null",
            "vma_manager": "!=null",
            "use_dma_alloc": "in [true, false]",
            "use_dma32": "in [true, false]"
        },
        "post": {
            "return_value": "!=0"
        }
    }
},
{
    "kretprobe:if (order)gfp_flags |= __GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN |__GFP_KSWAPD_RECLAIM;if (!pool->use_dma_alloc)": {
        "description": "Allocate a page from the TTM pool.",
        "pre": {
            "pool": "!=null",
            "gfp_flags": "!=null",
            "order": "!=0",
            "pool->use_dma_alloc": "==0"
        }
    }
},
{
    "kprobe:ttm_pool_alloc_page": {
        "description": "Allocate a page from the TTM pool.",
        "pre": {
            "pool": "!=null",
            "gfp_flags": "!=null",
            "order": "!=null",
            "order > 0": true,
            "gfp_flags & (__GFP_NOMEMALLOC | __GFP_NORETRY | __GFP_NOWARN | __GFP_KSWAPD_RECLAIM)": true,
            "!pool->use_dma_alloc": true
        }
    }
},
{
    "kretprobe:ttm_pool_free_page": {
        "description": "Free a page in the TTM pool.",
        "pre": {
            "pool": "!=null",
            "caching": "!=ttm_cached",
            "PageHighMem(p)": "false",
            "order": ">=0",
            "p": "!=null"
        }
    }
},
{
    "kprobe:ttm_pool_free_page": {
        "description": "Free a page in the TTM pool.",
        "pre": {
            "pool": "!=null",
            "caching": "not in [ttm_cached]",
            "order": "!=null",
            "p": "!=null",
            "attr": "in [DMA_ATTR_FORCE_CONTIGUOUS]",
            "dma": "!=null",
            "vaddr": "!=null"
        }
    }
},
{
    "kretprobe:ttm_pool_init": {
        "description": "Initialize a pool",
        "pre": {
            "pool": "!=null",
            "dev": "!=null",
            "nid": "!=null",
            "use_dma_alloc": "in [true, false]",
            "use_dma32": "in [true, false]"
        }
    }
},
{
    "kprobe:ttm_pool_init": {
        "description": "Initialize a pool",
        "pre": {
            "pool": "!=null",
            "dev": "!=null",
            "nid": "!=null",
            "use_dma_alloc": "in [true, false]",
            "use_dma32": "in [true, false]"
        }
    }
},
{
    "kretprobe:ttm_pool_fini": {
        "description": "Cleanup a pool",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:ttm_pool_fini": {
        "description": "Cleanup a pool",
        "pre": {
            "pool": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ttm_move_memcpy": {
        "description": "Helper to perform a memcpy ttm move operation.",
        "pre": {
            "clear": "in [true, false]",
            "num_pages": ">= 0",
            "dst_iter": "!= null",
            "src_iter": "!= null"
        }
    }
},
{
    "kprobe:ttm_move_memcpy": {
        "description": "Helper to perform a memcpy ttm move operation.",
        "pre": {
            "clear": "in [true, false]",
            "num_pages": ">=0",
            "dst_iter": "!=null",
            "src_iter": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_move_memcpy": {
        "description": "Fallback move function for a mappable buffer object in mappable memory.",
        "pre": {
            "bo": "!=null",
            "ctx": "!=null",
            "dst_mem": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_move_memcpy": {
        "description": "Fallback move function for a mappable buffer object in mappable memory.",
        "pre": {
            "bo": "!=null",
            "ctx": "!=null",
            "dst_mem": "!=null"
        }
    }
},
{
    "kretprobe:ttm_io_prot": {
        "description": "Utility function that returns the pgprot_t that should be used for setting up a PTE with the caching model indicated by @c_state.",
        "pre": {
            "bo": "!=null",
            "res": "!=null",
            "tmp": "!=null"
        }
    }
},
{
    "kprobe:pgprot_t_ttm_io_prot": {
        "description": "Utility function that returns the pgprot_t that should be used for setting up a PTE with the caching model indicated by @c_state.",
        "pre": {
            "bo": "!=null",
            "res": "!=null",
            "tmp": "!=null"
        }
    }
},
{
    "kretprobe:map->bo_kmap_type = ttm_bo_map_kmap; map->page = ttm->pages[start_page]; map->virtual = kmap(map->page);": {
        "description": "Set the values of map->bo_kmap_type, map->page, and map->virtual.",
        "pre": {
            "map->bo_kmap_type": "ttm_bo_map_kmap",
            "map->page": "ttm->pages[start_page]",
            "map->virtual": "kmap(map->page)"
        }
    }
},
{
    "kprobe:ttm_bo_kmap_ttm": {
        "description": "Kernel probe for ttm_bo_kmap_ttm function",
        "pre": {
            "bo": "!=null",
            "start_page": ">=0",
            "num_pages": ">=0",
            "map": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_kunmap": {
        "description": "Unmaps a kernel map set up by ttm_bo_kmap.",
        "pre": {
            "map": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_kunmap": {
        "description": "Unmaps a kernel map set up by ttm_bo_kmap.",
        "pre": {
            "map": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_vmap": {
        "description": "Maps a TTM buffer object to a user space address range.",
        "pre": {
            "bo": "!=null",
            "map": "!=null"
        },
        "post": {
            "return_value": "in [-ENOMEM, -EINVAL]"
        }
    }
},
S,
{
    "kretprobe:ttm_bo_move_accel_cleanup": {
        "description": "Cleanup helper for hw copies",
        "pre": {
            "bo": "!=null",
            "fence": "!=null",
            "evict": "bool",
            "pipeline": "bool",
            "new_mem": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_move_accel_cleanup": {
        "description": "cleanup helper for hw copies",
        "pre": {
            "bo": "!=null",
            "fence": "!=null",
            "evict": "bool",
            "pipeline": "bool",
            "new_mem": "!=null"
        }
    }
},
{
    "kretprobe:ttm_buffer_object_transfer": {
        "description": "A utility function that may be called after an accelerated move has been scheduled. A new buffer object is created as a placeholder for the old data while it's being copied. When that buffer object is idle, it can be destroyed, releasing the space of the old placement.",
        "pre": {
            "bo": "!=null",
            "new_obj": "!=null"
        }
    }
},
{
    "kprobe:ttm_buffer_object_transfer": {
        "description": "A utility function that may be called after an accelerated move has been scheduled.",
        "pre": {
            "bo": "!=null",
            "new_obj": "!=null"
        }
    }
},
{
    "kretprobe:ttm_lru_bulk_move_init": {
        "description": "Initialize a bulk move structure",
        "pre": {
            "bulk": "!=null"
        }
    }
},
{
    "kprobe:ttm_lru_bulk_move_init": {
        "description": "Initialize a bulk move structure.",
        "pre": {
            "bulk": "!=null"
        }
    }
},
{
    "kretprobe:ttm_lru_bulk_move_tail": {
        "description": "Bulk move range of resources to the LRU tail.",
        "pre": {
            "bulk": "!=null"
        }
    }
},
{
    "kprobe:ttm_lru_bulk_move_tail": {
        "description": "Bulk move range of resources to the LRU tail.",
        "pre": {
            "bulk": "!=null"
        }
    }
},
S,
{
    "kprobe:ttm_resource_init": {
        "description": "Initialize the TTM resource for a given buffer object.",
        "pre": {
            "bo": "!=null",
            "place": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:ttm_resource_manager_init": {
        "description": "Initialise core parts of a manager object.",
        "pre": {
            "man": "!=null",
            "bdev": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:ttm_resource_manager_init": {
        "description": "Initialise core parts of a manager object.",
        "pre": {
            "man": "!=null",
            "bdev": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:ttm_resource_manager_evict_all": {
        "description": "Evict all the objects out of a memory manager until it is empty. Part of memory manager cleanup sequence.",
        "pre": {
            "bdev": "!=null",
            "man": "!=null"
        }
    }
},
{
    "kprobe:ttm_resource_manager_evict_all": {
        "description": "Evict all the objects out of a memory manager until it is empty. Part of memory manager cleanup sequence.",
        "pre": {
            "bdev": "!=null",
            "man": "!=null"
        }
    }
},
{
    "kretprobe:ttm_resource_manager_usage": {
        "description": "Return how many resources are currently used.",
        "pre": {
            "man": "!=null"
        }
    }
},
{
    "kprobe:ttm_resource_manager_usage": {
        "description": "Return how many resources are currently used.",
        "pre": {
            "man": "!=null"
        }
    }
},
{
    "kretprobe:ttm_resource_manager_debug": {
        "description": "Debug function for TTM resource manager",
        "pre": {
            "man": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:ttm_resource_manager_debug": {
        "description": "Debug function for TTM resource manager.",
        "pre": {
            "man": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:ttm_kmap_iter_iomap_init": {
        "description": "Initialize a struct ttm_kmap_iter_iomap",
        "pre": {
            "iter_io": "!=null",
            "iomap": "!=null",
            "st": "!=null",
            "start": "!=null"
        }
    }
},
{
    "kprobe:ttm_kmap_iter_iomap_init": {
        "description": "Initialize a struct ttm_kmap_iter_iomap",
        "pre": {
            "iter_io": "!=null",
            "iomap": "!=null",
            "st": "!=null",
            "start": "!=null"
        }
    }
},
{
    "kretprobe:ttm_resource_manager_create_debugfs": {
        "description": "Create debugfs entry for specified resource manager.",
        "pre": {
            "man": "!=null",
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:ttm_resource_manager_create_debugfs": {
        "description": "Create debugfs entry for specified resource manager.",
        "pre": {
            "man": "!=null",
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_move_to_lru_tail": {
        "description": "Move this BO to the tail of all lru lists used to lookup and reserve an object. This function must be called with struct ttm_global::lru_lock held, and is used to make a BO less likely to be considered for eviction.",
        "pre": {
            "bo": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_move_to_lru_tail": {
        "description": "Move this BO to the tail of all lru lists used to lookup and reserve an object.",
        "pre": {
            "bo": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_set_bulk_move": {
        "description": "Update BOs bulk move object, making sure that resources are added/removed.",
        "pre": {
            "bo": "!=null",
            "bulk": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_set_bulk_move": {
        "description": "Update BOs bulk move object, making sure that resources are added/removed.",
        "pre": {
            "bo": "!=null",
            "bulk": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ttm_bo_eviction_valuable": {
        "description": "Check if it is valuable to evict the BO to make room for the given placement.",
        "pre": {
            "bo": "!=null",
            "place": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_eviction_valuable": {
        "description": "Check if it is valuable to evict the BO to make room for the given placement.",
        "pre": {
            "bo": "!=null",
            "place": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_pin": {
        "description": "Pin a TTM buffer object.",
        "pre": {
            "bo": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_pin": {
        "description": "Pin a TTM buffer object.",
        "pre": {
            "bo": "!=null"
        }
    }
},
{
    "kretprobe:ttm_bo_validate": {
        "description": "Validates a buffer object and changes its placement and caching policy according to the proposed placement.",
        "pre": {
            "bo": "!=null",
            "placement": "!=null",
            "ctx": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -ENOMEM, -EBUSY, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:ttm_bo_validate": {
        "description": "Validates a buffer object and changes its placement and caching policy according to the proposed placement.",
        "pre": {
            "bo": "!=null",
            "placement": "!=null",
            "ctx": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -ENOMEM, -EBUSY, -ERESTARTSYS]"
        }
    }
},
{
    "kretprobe:ttm_bo_init_reserved": {
        "description": "This function initializes a pre-allocated struct ttm_buffer_object.",
        "pre": {
            "@bdev": "!=null",
            "@bo": "!=null",
            "@type": "is one of [TTM_BO_TYPE_*]",
            "@placement": "!=null",
            "@alignment": "is an integer",
            "@ctx": "!=null",
            "@sg": "!=null",
            "@resv": "is one of [null, dma_resv]",
            "@destroy": "is a function pointer"
        }
    }
},
{
    "kprobe:ttm_bo_init_reserved": {
        "description": "This function initializes a pre-allocated struct ttm_buffer_object. As this object may be part of a larger structure, this function, together with the @destroy function, enables driver-specific objects derived from a ttm_buffer_object. On successful return, the caller owns an object kref to @bo. The kref and list_kref are usually set to 1, but note that in some situations, other tasks may already be holding references to @bo as well. Furthermore, if resv == NULL, the buffer's reservation lock will be held, and it is the caller's responsibility to call ttm_bo_unreserve. If a failure occurs, the function will call the @destroy function. Thus, after a failure, dereferencing @bo is illegal and will likely cause memory corruption.",
        "pre": {
            "bdev": "!=null",
            "bo": "!=null",
            "type": "in [TTM_BO_TYPE_DEVICE, TTM_BO_TYPE_VRAM, TTM_BO_TYPE_SYSTEM, TTM_BO_TYPE_CPU]",
            "placement": "!=null",
            "alignment": ">=0",
            "ctx": "!=null",
            "sg": "!=null",
            "resv": "in [null, !=null]",
            "destroy": "!=null"
        },
        "post": {
            "return": "in [-ENOMEM, -EINVAL, -ERESTARTSYS, 0]"
        }
    }
},
{
    "kretprobe:ttm_bo_init_validate": {
        "description": "Initialize a pre-allocated struct ttm_buffer_object.",
        "pre": {
            "bdev": "!=null",
            "bo": "!=null",
            "type": "in [TTM_BO_TYPE_DEFAULT, TTM_BO_TYPE_DEVICE, TTM_BO_TYPE_VRAM, TTM_BO_TYPE_SYSTEM, TTM_BO_TYPE_GTT]",
            "placement": "!=null",
            "alignment": ">=0",
            "interruptible": "in [true, false]",
            "sg": "!=null",
            "resv": "!=null",
            "destroy": "!=null"
        }
    }
},
{
    "kprobe:ttm_bo_init_validate": {
        "description": "Initializes a pre-allocated struct ttm_buffer_object.",
        "pre": {
            "bdev": "!=null",
            "bo": "!=null",
            "type": "in [TTM_BO_TYPE_DEVICE, TTM_BO_TYPE_VRAM, TTM_BO_TYPE_SYSTEM, TTM_BO_TYPE_CPU]",
            "placement": "!=null",
            "alignment": ">=0",
            "interruptible": "in [true, false]",
            "sg": "!=null",
            "resv": "!=null",
            "destroy": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:drm_sched_fault": {
        "description": "Immediately start timeout handler when a hardware fault is detected.",
        "pre": {
            "sched": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_sched_suspend_timeout": {
        "description": "Suspend scheduler job timeout",
        "pre": {
            "sched": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_sched_suspend_timeout": {
        "description": "Suspend scheduler job timeout",
        "pre": {
            "sched": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_resume_timeout": {
        "description": "Resume scheduler job timeout",
        "pre": {
            "sched": "!=null",
            "remaining": ">=0"
        }
    }
},
{
    "kprobe:drm_sched_resume_timeout": {
        "description": "Resume scheduler job timeout",
        "pre": {
            "sched": "!=null",
            "remaining": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:drm_sched_start_timeout": {
        "description": "Start timeout for reset worker",
        "pre": {
            "sched": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_sched_resubmit_jobs": {
        "description": "Deprecated, don't use in new code! Re-submitting jobs was a concept AMD came up as cheap way to implement recovery after a job timeout. This turned out to be not working very well. First of all there are many problem with the dma_fence implementation and requirements. Either the implementation is risking deadlocks with core memory management or violating documented implementation details of the dma_fence object. Drivers can still save and restore their state for recovery operations, but we shouldn't make this a general scheduler feature around the dma_fence interface.",
        "pre": {
            "sched": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_resubmit_jobs": {
        "description": "Deprecated, don't use in new code! Re-submitting jobs was a concept AMD came up as cheap way to implement recovery after a job timeout. This turned out to be not working very well. First of all there are many problem with the dma_fence implementation and requirements. Either the implementation is risking deadlocks with core memory management or violating documented implementation details of the dma_fence object. Drivers can still save and restore their state for recovery operations, but we shouldn't make this a general scheduler feature around the dma_fence interface.",
        "pre": {
            "sched": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_job_init": {
        "description": "Initialize a DRM scheduling job.",
        "pre": {
            "job": "!=null",
            "entity": "!=null",
            "owner": "!=null"
        },
        "post": {
            "return_value": "in [0, -ENOENT]"
        }
    }
},
{
    "kprobe:drm_sched_job_init": {
        "description": "Initialize a DRM scheduling job.",
        "pre": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:drm_sched_job_add_dependency": {
        "description": "Adds the fence as a job dependency",
        "pre": {
            "job": "!=null",
            "fence": "!=null"
        },
        "post": {
            "return": "= 0"
        }
    }
},
{
    "kprobe:drm_sched_job_add_dependency": {
        "description": "Adds the fence as a job dependency.",
        "pre": {
            "job": "!=null",
            "fence": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kretprobe:drm_sched_job_add_syncobj_dependency": {
        "description": "Adds a syncobj's fence as a job dependency",
        "pre": {
            "job": "!=null",
            "file": "!=null",
            "handle": "!=null",
            "point": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_job_add_syncobj_dependency": {
        "description": "Adds a syncobj's fence as a job dependency",
        "pre": {
            "job": "!=null",
            "file": "!=null",
            "handle": "!=null",
            "point": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_job_add_resv_dependencies": {
        "description": "Add all fences from the resv to the job",
        "pre": {
            "job": "!=null",
            "resv": "!=null",
            "usage": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_job_add_resv_dependencies": {
        "description": "Add all fences from the resv to the job.",
        "pre": {
            "job": "!=null",
            "resv": "!=null",
            "usage": "in [DMA_RESV_READ, DMA_RESV_WRITE, DMA_RESV_EXCLUSIVE]"
        }
    }
},
{
    "kretprobe:drm_sched_job_add_implicit_dependencies": {
        "description": "Adds implicit dependencies as job dependencies.",
        "pre": {
            "job": "!=null",
            "obj": "!=null",
            "write": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_sched_job_add_implicit_dependencies": {
        "description": "Adds implicit dependencies as job dependencies.",
        "pre": {
            "job": "!=null",
            "obj": "!=null",
            "write": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_sched_pick_best": {
        "description": "Get a drm sched from a sched_list with the least load",
        "pre": {
            "sched_list": "!=null",
            "num_sched_list": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_pick_best": {
        "description": "Get a drm sched from a sched_list with the least load",
        "pre": {
            "sched_list": "!=null",
            "num_sched_list": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_init": {
        "description": "Init a gpu scheduler instance",
        "pre": {
            "sched": "!=null",
            "ops": "!=null",
            "hw_submission": ">=0",
            "hang_limit": ">=0",
            "timeout": ">=0",
            "timeout_wq": "!=null",
            "score": "!=null",
            "name": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_init": {
        "description": "Init a gpu scheduler instance",
        "pre": {
            "sched": "!=null",
            "ops": "!=null",
            "hw_submission": ">=0",
            "hang_limit": ">=0",
            "timeout": ">=0",
            "timeout_wq": "!=null",
            "score": "!=null",
            "name": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_fini": {
        "description": "Destroy a gpu scheduler",
        "pre": {
            "sched": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_fini": {
        "description": "Destroy a gpu scheduler",
        "pre": {
            "sched": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_increase_karma": {
        "description": "Update sched_entity guilty flag",
        "pre": {
            "bad": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_increase_karma": {
        "description": "Update sched_entity guilty flag",
        "pre": {
            "bad": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_fence_free": {
        "description": "Free up an uninitialized fence",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_fence_free": {
        "description": "Free up an uninitialized fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_entity_init": {
        "description": "Initialize a DRM scheduling entity",
        "pre": {
            "entity": "!=null",
            "priority": "in [DRM_SCHED_PRIORITY_MIN, DRM_SCHED_PRIORITY_MAX]",
            "sched_list": "!=null",
            "num_sched_list": ">=0",
            "guilty": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_entity_init": {
        "description": "Initialize a DRM scheduling entity.",
        "pre": {
            "entity": "!=null",
            "priority": "in [DRM_SCHED_PRIORITY_MIN, DRM_SCHED_PRIORITY_MAX]",
            "sched_list": "!=null",
            "num_sched_list": ">=0",
            "guilty": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_entity_error": {
        "description": "Return the error of the last scheduled job for the given scheduler entity.",
        "pre": {
            "entity": "!=null"
        }
    }
},
{
    "kprobe:drm_sched_entity_error": {
        "description": "Return the error of the last scheduled job.",
        "pre": {
            "entity": "!=null"
        }
    }
},
{
    "kretprobe:drm_sched_entity_flush": {
        "description": "Flush a context entity",
        "pre": {
            "entity": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:drm_sched_entity_flush": {
        "description": "Flush a context entity",
        "pre": {
            "entity": "!=null",
            "timeout": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:drm_bridge_is_panel": {
        "description": "Checks if a drm_bridge is a panel_bridge.",
        "pre": {
            "bridge": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_bridge_is_panel": {
        "description": "Checks if a drm_bridge is a panel_bridge.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_bridge_add": {
        "description": "Add a DRM bridge for the given DRM panel.",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_bridge_add": {
        "description": "Add a DRM bridge for the given DRM panel.",
        "pre": {
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_bridge_add_typed": {
        "description": "Creates a &drm_bridge and &drm_connector with an explicit connector type.",
        "pre": {
            "panel": "!=null",
            "connector_type": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_bridge_add_typed": {
        "description": "Creates a &drm_bridge and &drm_connector with an explicit connector type.",
        "pre": {
            "panel": "!=null",
            "connector_type": "!=null"
        }
    }
},
{
    "kretprobe:panel_bridge_atomic_pre_enable": {
        "description": "Cleanup the connector if we know it was initialized.",
        "pre": {
            "connector->dev": "!=null",
            "bridge": "!=null",
            "old_bridge_state": "!=null"
        }
    }
},
{
    "kprobe:panel_bridge_atomic_pre_enable": {
        "description": "Cleanup the connector if we know it was initialized.",
        "pre": {
            "connector->dev": "!=null",
            "bridge": "!=null",
            "old_bridge_state": "!=null"
        }
    }
},
{
    "kretprobe:devm_drm_panel_bridge_add_typed": {
        "description": "Creates a managed &drm_bridge and &drm_connector with an explicit connector type.",
        "pre": {
            "dev": "!=null",
            "panel": "!=null",
            "connector_type": "in [DRM_MODE_CONNECTOR_]"
        }
    }
},
{
    "kprobe:devm_drm_panel_bridge_add_typed": {
        "description": "Creates a managed &drm_bridge and &drm_connector with an explicit connector type.",
        "pre": {
            "dev": "!=null",
            "panel": "!=null",
            "connector_type": "!=null"
        }
    }
},
{
    "kretprobe:drmm_panel_bridge_add": {
        "description": "Creates a DRM-managed &drm_bridge and &drm_connector that just calls the appropriate functions from &drm_panel.",
        "pre": {
            "drm": "!=null",
            "panel": "!=null"
        }
    }
},
{
    "kprobe:drmm_panel_bridge_add": {
        "description": "Creates a DRM-managed &drm_bridge and &drm_connector that just calls the appropriate functions from &drm_panel.",
        "pre": {
            "drm": "!=null",
            "panel": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_bridge_connector": {
        "description": "Return the connector for the panel bridge.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_bridge_connector": {
        "description": "Return the connector for the panel bridge.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:devm_drm_of_get_bridge": {
        "description": "Return next bridge in the chain",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:devm_drm_of_get_bridge": {
        "description": "Return next bridge in the chain",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:drmm_of_get_bridge": {
        "description": "Return next bridge in the chain",
        "pre": {
            "drm": "!=null",
            "np": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:drmm_of_get_bridge": {
        "description": "Return next bridge in the chain",
        "pre": {
            "drm": "!=null",
            "np": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:rockchip_drm_wait_vact_end": {
        "description": "Wait for vact_end line flag irq or timeout.",
        "pre": {
            "crtc": "!=null",
            "mstimeout": ">=0"
        }
    }
},
{
    "kprobe:rockchip_drm_wait_vact_end": {
        "description": "Wait for vact_end line flag irq or timeout.",
        "pre": {
            "crtc": "!=null",
            "mstimeout": ">=0"
        }
    }
},
{
    "kretprobe:drm_connector_attach_content_protection_property": {
        "description": "Update the content protection state of a connector.",
        "pre": {
            "connector": "!=null",
            "hdcp_content_type": "any"
        }
    }
},
{
    "kprobe:drm_connector_attach_content_protection_property": {
        "description": "Attach content protection property to a DRM connector.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_dp_pps_header_init": {
        "description": "Initializes the PPS Header for DisplayPort as per the DP 1.4 spec.",
        "pre": {
            "pps_header": "!=null"
        }
    }
},
{
    "kprobe:drm_dsc_dp_pps_header_init": {
        "description": "Initializes the PPS Header for DisplayPort as per the DP 1.4 spec.",
        "pre": {
            "pps_header": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_dp_rc_buffer_size": {
        "description": "Get the RC buffer size in bytes.",
        "pre": {
            "rc_buffer_block_size": "!=null",
            "rc_buffer_size": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_dsc_dp_rc_buffer_size": {
        "description": "get rc buffer size in bytes",
        "pre": {
            "rc_buffer_block_size": "!=null",
            "rc_buffer_size": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_pps_payload_pack": {
        "description": "Populates the DSC PPS",
        "pre": {
            "pps_payload": "!=null",
            "dsc_cfg": "!=null"
        }
    }
},
{
    "kprobe:drm_dsc_pps_payload_pack": {
        "description": "Populates the DSC PPS",
        "pre": {
            "pps_payload": "!=null",
            "dsc_cfg": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_set_const_params": {
        "description": "Set DSC parameters considered typically constant across operation modes.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kprobe:drm_dsc_set_const_params": {
        "description": "Set DSC parameters considered typically constant across operation modes.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_set_rc_buf_thresh": {
        "description": "Set thresholds for the RC model in accordance with the DSC 1.2 specification.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kprobe:drm_dsc_set_rc_buf_thresh": {
        "description": "Set thresholds for the RC model in accordance with the DSC 1.2 specification.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_setup_rc_params": {
        "description": "Set parameters and limits for RC model in accordance with the DSC 1.1 or 1.2 specification and DSC C Model. Required bits_per_pixel and bits_per_component to be set before calling this function.",
        "pre": {
            "vdsc_cfg": "!=null",
            "type": "in [DSC_MODE_1_1, DSC_MODE_1_2]"
        },
        "post": {
            "return": "in [0, -error code]"
        }
    }
},
{
    "kprobe:drm_dsc_setup_rc_params": {
        "description": "Set parameters and limits for RC model in accordance with the DSC 1.1 or 1.2 specification and DSC C Model. Required bits_per_pixel and bits_per_component to be set before calling this function.",
        "pre": {
            "vdsc_cfg": "!=null",
            "type": "in [DSC_MODE_1_1, DSC_MODE_1_2]"
        }
    }
},
{
    "kretprobe:drm_dsc_compute_rc_parameters": {
        "description": "Write rate control parameters to the dsc configuration defined in struct drm_dsc_config in accordance with the DSC 1.2 specification. Some configuration fields must be present beforehand.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kprobe:drm_dsc_compute_rc_parameters": {
        "description": "Write rate control parameters to the dsc configuration defined in &struct drm_dsc_config in accordance with the DSC 1.2 specification.",
        "pre": {
            "vdsc_cfg": "!=null"
        }
    }
},
{
    "kretprobe:drm_dsc_get_bpp_int": {
        "description": "Get integer bits per pixel value for the given DRM DSC config",
        "pre": {
            "vdsc_cfg": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:drm_dsc_get_bpp_int": {
        "description": "Get integer bits per pixel value for the given DRM DSC config",
        "pre": {
            "vdsc_cfg": "!=null"
        },
        "post": {
            "return": "is_integer"
        }
    }
},
S,
{
    "kprobe:drm_dsc_initial_scale_value": {
        "description": "Calculate the initial scale value for the given DSC config",
        "pre": {
            "dsc": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_dp_128b132b_read_aux_rd_interval": {
        "description": "Read the auxiliary read interval for DP 128b/132b training.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_128b132b_read_aux_rd_interval": {
        "description": "Read the auxiliary read interval for DP 128b/132b training.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_phy_name": {
        "description": "Get the name of the given DP PHY",
        "pre": {
            "dp_phy": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_phy_name": {
        "description": "Get the name of the given DP PHY",
        "pre": {
            "dp_phy": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_link_rate_to_bw_code": {
        "description": "Converts the link rate to a bandwidth code.",
        "pre": {
            "link_rate": "!=null",
            "link_rate": "is integer",
            "link_rate": ">= 0"
        },
        "post": {
            "return_value": {
                "constraints": {
                    "return_value": "in [DP_LINK_BW_10, DP_LINK_BW_13_5, DP_LINK_BW_20]"
                }
            }
        }
    }
},
S,
{
    "kretprobe:drm_dp_bw_code_to_link_rate": {
        "description": "Converts the link bandwidth code to the corresponding link rate.",
        "pre": {
            "link_bw": "in [DP_LINK_BW_10, DP_LINK_BW_13_5, DP_LINK_BW_20]"
        },
        "post": {
            "return_value": "link_bw * 27000"
        }
    }
},
{
    "kprobe:drm_dp_bw_code_to_link_rate": {
        "description": "Converts the link bandwidth code to the corresponding link rate.",
        "pre": {
            "link_bw": "in [DP_LINK_BW_10, DP_LINK_BW_13_5, DP_LINK_BW_20]"
        },
        "post": {
            "link_rate": "= link_bw * 27000"
        }
    }
},
{
    "kretprobe:drm_dp_dpcd_probe": {
        "description": "Probe a given DPCD address with a 1-byte read access.",
        "pre": {
            "aux": "!=null",
            "offset": "!=null"
        },
        "post": {
            "return": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:drm_dp_dpcd_probe": {
        "description": "Probe a given DPCD address with a 1-byte read access.",
        "pre": {
            "aux": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_clock_recovery_delay": {
        "description": "Read the clock recovery delay for DP",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null",
            "dp_phy": "in [DP_PHY_1_1, DP_PHY_1_2, DP_PHY_2_0]",
            "uhbr": "is boolean"
        },
        "post": {
            "return": "400"
        }
    }
},
S,
{
    "kretprobe:drm_dp_dpcd_write": {
        "description": "Write a series of bytes to the DPCD.",
        "pre": {
            "aux": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dpcd_write": {
        "description": "Write a series of bytes to the DPCD.",
        "pre": {
            "aux": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dpcd_read_link_status": {
        "description": "Read DPCD link status (bytes 0x202-0x207)",
        "pre": {
            "aux": "!=null",
            "status": "!=null",
            "status.length": ">=6"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_dpcd_read_link_status": {
        "description": "Read DPCD link status (bytes 0x202-0x207)",
        "pre": {
            "aux": "!=null",
            "status": "!=null",
            "status.length": ">=6"
        }
    }
},
{
    "kretprobe:drm_dp_dpcd_read_phy_link_status": {
        "description": "Get the link status information for a DP PHY",
        "pre": {
            "aux": "!=null",
            "dp_phy": "in [DP_PHY_1, DP_PHY_2, DP_PHY_3]",
            "link_status": "!=null"
        },
        "post": {
            "return_value": "in [0, negative_error_code]"
        }
    }
},
{
    "kprobe:drm_dp_dpcd_read_phy_link_status": {
        "description": "Get the link status information for a DP PHY",
        "pre": {
            "aux": "!=null",
            "dp_phy": "in [DP_PHY_1, DP_PHY_2, DP_PHY_3]",
            "link_status": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_is_type": {
        "description": "Check if the downstream facing port matches the given type.",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "type": "in [DP_DS_PORT_TYPE_DP, DP_DS_PORT_TYPE_VGA, DP_DS_PORT_TYPE_DVI, DP_DS_PORT_TYPE_HDMI, DP_DS_PORT_TYPE_NON_EDID, DP_DS_PORT_TYPE_DP_DUALMODE, DP_DS_PORT_TYPE_WIRELESS]"
        }
    }
},
{
    "kprobe:drm_dp_downstream_is_type": {
        "description": "Check if the downstream facing port matches the given type.",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "type": "in [DP_DS_PORT_TYPE_DP, DP_DS_PORT_TYPE_VGA, DP_DS_PORT_TYPE_DVI, DP_DS_PORT_TYPE_HDMI, DP_DS_PORT_TYPE_NON_EDID, DP_DS_PORT_TYPE_DP_DUALMODE, DP_DS_PORT_TYPE_WIRELESS]"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_is_tmds": {
        "description": "Check if the downstream facing port is TMDS (HDMI/DVI).",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_is_tmds": {
        "description": "Check if the downstream facing port is TMDS (HDMI/DVI).",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_send_real_edid_checksum": {
        "description": "Send back real edid checksum value",
        "pre": {
            "aux": "!=null",
            "real_edid_checksum": "!=null"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:drm_dp_send_real_edid_checksum": {
        "description": "Send back real edid checksum value",
        "pre": {
            "aux": "!=null",
            "real_edid_checksum": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_dpcd_caps": {
        "description": "Read DPCD caps and extended DPCD caps if available.",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_read_dpcd_caps": {
        "description": "Read DPCD caps and extended DPCD caps if available.",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_dp_downstream_max_dotclock": {
        "description": "Extract downstream facing port max dot clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_downstream_max_dotclock": {
        "description": "Extract downstream facing port max dot clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_max_tmds_clock": {
        "description": "Extract downstream facing port max TMDS clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_downstream_max_tmds_clock": {
        "description": "Extract downstream facing port max TMDS clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_min_tmds_clock": {
        "description": "Extract downstream facing port min TMDS clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_downstream_min_tmds_clock": {
        "description": "Extract downstream facing port min TMDS clock",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_420_passthrough": {
        "description": "Determine downstream facing port YCbCr 4:2:0 pass-through capability",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_dp_downstream_420_passthrough": {
        "description": "determine downstream facing port YCbCr 4:2:0 pass-through capability",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_444_to_420_conversion": {
        "description": "Determines downstream facing port YCbCr 4:4:4->4:2:0 conversion capability.",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_444_to_420_conversion": {
        "description": "determine downstream facing port YCbCr 4:4:4->4:2:0 conversion capability",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_rgb_to_ycbcr_conversion": {
        "description": "Determine downstream facing port RGB->YCbCr conversion capability.",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "color_spc": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_rgb_to_ycbcr_conversion": {
        "description": "Determine downstream facing port RGB->YCbCr conversion capability.",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null",
            "color_spc": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_mode": {
        "description": "Return a mode for downstream facing port",
        "pre": {
            "dev": "!=null",
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_mode": {
        "description": "Return a mode for downstream facing port",
        "pre": {
            "dev": "!=null",
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_id": {
        "description": "Identify branch device",
        "pre": {
            "aux": "!=null",
            "id": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_id": {
        "description": "Identify branch device",
        "pre": {
            "aux": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_downstream_debug": {
        "description": "Debug DP branch devices",
        "pre": {
            "m": "!=null",
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null",
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_downstream_debug": {
        "description": "Debug DP branch devices",
        "pre": {
            "m": "!=null",
            "dpcd": "!=null",
            "port_cap": "!=null",
            "edid": "!=null",
            "aux": "!=null"
        }
    }
},
S,
{
    "kprobe:enum_drm_mode_subconnectordrm_dp_subconnector_type": {
        "description": "Get DP branch device type",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_set_subconnector_property": {
        "description": "Set subconnector for DP connector",
        "pre": {
            "connector": "!=null",
            "status": "in [DRM_CONNECTOR_CONNECTED, DRM_CONNECTOR_DISCONNECTED, DRM_CONNECTOR_UNKNOWN]",
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_set_subconnector_property": {
        "description": "Set subconnector for DP connector",
        "pre": {
            "connector": "!=null",
            "status": "in [DRM_CONNECTOR_CONNECTED, DRM_CONNECTOR_DISCONNECTED, DRM_CONNECTOR_UNKNOWN]",
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_sink_count_cap": {
        "description": "Check whether a given connector has a valid sink count.",
        "pre": {
            "connector": "!=null",
            "dpcd": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_read_sink_count_cap": {
        "description": "Check whether a given connector has a valid sink count.",
        "pre": {
            "connector": "!=null",
            "dpcd": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_remote_aux_init": {
        "description": "Minimally initialise a remote aux channel",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_remote_aux_init": {
        "description": "Minimally initialise a remote aux channel",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_aux_init": {
        "description": "Initialize the auxiliary DP channel",
        "pre": {
            "aux": "!=null"
        },
        "post": {
            "aux->initialized": "true",
            "aux->drm_dev": "!=null",
            "debug_output": "contains(aux->drm_dev)"
        }
    }
},
S,
{
    "kretprobe:drm_dp_aux_register": {
        "description": "Register the AUX channel for a DRM device.",
        "pre": {
            "aux": "!=null",
            "drm_dev": "!=null"
        },
        "post": {
            "return_value": "int"
        }
    }
},
{
    "kprobe:drm_dp_aux_register": {
        "description": "Register the DRM DP auxiliary channel.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_psr_setup_time": {
        "description": "PSR setup in time usec",
        "pre": {
            "psr_cap": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
S,
{
    "kretprobe:drm_dp_start_crc": {
        "description": "Start capture of frame CRCs",
        "pre": {
            "aux": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_start_crc": {
        "description": "Start capture of frame CRCs",
        "pre": {
            "aux": "!=null",
            "crtc": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_stop_crc": {
        "description": "Stop capture of frame CRCs",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_stop_crc": {
        "description": "Stop capture of frame CRCs",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_desc": {
        "description": "Read sinkbranch descriptor from DPCD",
        "pre": {
            "aux": "!=null",
            "desc": "!=null",
            "is_branch": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_dp_read_desc": {
        "description": "Read sinkbranch descriptor from DPCD",
        "pre": {
            "aux": "!=null",
            "desc": "!=null",
            "is_branch": "is boolean"
        }
    }
},
{
    "kretprobe:drm_dp_dsc_sink_max_slice_count": {
        "description": "Get the max slice count supported by the DSC sink.",
        "pre": {
            "dsc_dpcd": "!=null",
            "is_edp": "is boolean"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:u8 drm_dp_dsc_sink_max_slice_count": {
        "description": "Get the max slice count supported by the DSC sink.",
        "pre": {
            "dsc_dpcd": "!=null",
            "is_edp": "is_boolean"
        }
    }
},
{
    "kretprobe:drm_dp_dsc_sink_line_buf_depth": {
        "description": "Get the line buffer depth in bits",
        "pre": {
            "dsc_dpcd": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_dsc_sink_line_buf_depth": {
        "description": "Get the line buffer depth in bits",
        "pre": {
            "dsc_dpcd": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dsc_sink_supported_input_bpcs": {
        "description": "Get all the input bits per component values supported by the DSC sink.",
        "pre": {
            "dsc_dpcd": "!=null",
            "dsc_bpc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_dsc_sink_supported_input_bpcs": {
        "description": "Get all the input bits per component values supported by the DSC sink.",
        "pre": {
            "dsc_dpcd": "!=null",
            "dsc_bpc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:drm_dp_read_lttpr_common_caps": {
        "description": "Read capabilities common to all LTTPRs.",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null",
            "caps": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_read_lttpr_common_caps": {
        "description": "Read capabilities common to all LTTPRs.",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null",
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_lttpr_phy_caps": {
        "description": "Read the capabilities for a given LTTPR PHY",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null",
            "dp_phy": "in [DP_PHY_1, DP_PHY_2, DP_PHY_3]",
            "caps": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_read_lttpr_phy_caps": {
        "description": "Read the capabilities for a given LTTPR PHY",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null",
            "dp_phy": "in [DP_PHY_LTTPR1, DP_PHY_LTTPR2]",
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_lttpr_count": {
        "description": "Get the number of detected LTTPRs",
        "pre": {
            "caps": "!=null"
        },
        "post": {
            "return_value": ">= -ERANGE",
            "return_value": "<= 8",
            "return_value": "!= -EINVAL"
        }
    }
},
{
    "kprobe:drm_dp_lttpr_count": {
        "description": "Get the number of detected LTTPRs",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_lttpr_max_link_rate": {
        "description": "get the maximum link rate supported by all LTTPRs",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_lttpr_max_link_rate": {
        "description": "get the maximum link rate supported by all LTTPRs",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_lttpr_max_lane_count": {
        "description": "Get the maximum lane count supported by all LTTPRs.",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_lttpr_max_lane_count": {
        "description": "get the maximum lane count supported by all LTTPRs",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:booldrm_dp_lttpr_voltage_swing_level_3_supported": {
        "description": "Check for LTTPR vswing3 support",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kprobe:booldrm_dp_lttpr_voltage_swing_level_3_supported": {
        "description": "Check for LTTPR vswing3 support",
        "pre": {
            "caps": "!=null",
            "caps[DP_LTTPR_PHY_CAP_SIZE-1]": "& 0x0F == 0x03"
        }
    }
},
{
    "kretprobe:booldrm_dp_lttpr_pre_emphasis_level_3_supported": {
        "description": "Check for LTTPR preemph3 support",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kprobe:booldrm_dp_lttpr_pre_emphasis_level_3_supported": {
        "description": "Check for LTTPR preemph3 support",
        "pre": {
            "caps": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_get_phy_test_pattern": {
        "description": "Get the requested pattern from the sink.",
        "pre": {
            "aux": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:drm_dp_set_phy_test_pattern": {
        "description": "Set the pattern to the sink.",
        "pre": {
            "aux": "!=null",
            "data": "!=null",
            "dp_rev": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_set_phy_test_pattern": {
        "description": "Set the pattern to the sink.",
        "pre": {
            "aux": "!=null",
            "data": "!=null",
            "dp_rev": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_get_pcon_max_frl_bw": {
        "description": "maximum frl supported by PCON",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_get_pcon_max_frl_bw": {
        "description": "maximum frl supported by PCON",
        "pre": {
            "dpcd": "!=null",
            "port_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_frl_prepare": {
        "description": "Prepare PCON for FRL.",
        "pre": {
            "aux": "!=null",
            "enable_frl_ready_hpd": "is boolean"
        }
    }
},
{
    "kprobe:drm_dp_pcon_frl_prepare": {
        "description": "Prepare PCON for FRL.",
        "pre": {
            "aux": "!=null",
            "enable_frl_ready_hpd": "is boolean"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_is_frl_ready": {
        "description": "Is PCON ready for FRL",
        "pre": {
            "aux": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_dp_pcon_is_frl_ready": {
        "description": "Is PCON ready for FRL",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_frl_configure_1": {
        "description": "Set HDMI LINK Configuration-Step1",
        "pre": {
            "aux": "!=null",
            "max_frl_gbps": "!=null",
            "frl_mode": "in ['Concurrent', 'Sequential']"
        }
    }
},
{
    "kprobe:drm_dp_pcon_frl_configure_1": {
        "description": "Set HDMI LINK Configuration-Step1",
        "pre": {
            "aux": "!=null",
            "max_frl_gbps": "!=null",
            "frl_mode": "in ['Concurrent', 'Sequential']"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_frl_configure_2": {
        "description": "Set HDMI Link configuration Step-2",
        "pre": {
            "aux": "!=null",
            "max_frl_mask": "!=null",
            "frl_type": "in ['Extended', 'Normal']"
        },
        "post": {
            "return_value": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:drm_dp_pcon_frl_configure_2": {
        "description": "Set HDMI Link configuration Step-2",
        "pre": {
            "aux": "!=null",
            "max_frl_mask": "!=null",
            "frl_type": "in ['Extended', 'Normal']"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_reset_frl_config": {
        "description": "Re-Set HDMI Link configuration.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_pcon_reset_frl_config": {
        "description": "Re-Set HDMI Link configuration.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_frl_enable": {
        "description": "Enable HDMI link through FRL",
        "pre": {
            "aux": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_pcon_frl_enable": {
        "description": "Enable HDMI link through FRL",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_hdmi_link_active": {
        "description": "Check if the PCON HDMI LINK status is active.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_pcon_hdmi_link_active": {
        "description": "Check if the PCON HDMI LINK status is active.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_hdmi_link_mode": {
        "description": "get the PCON HDMI LINK MODE",
        "pre": {
            "aux": "!=null",
            "frl_trained_mask": "!=null"
        },
        "post": {
            "return_value": "in [TMDS, FRL, negative error code]"
        }
    }
},
{
    "kprobe:drm_dp_pcon_hdmi_link_mode": {
        "description": "Get the PCON HDMI LINK MODE",
        "pre": {
            "aux": "!=null",
            "frl_trained_mask": "!=null"
        }
    }
},
S,
{
    "kprobe:drm_dp_pcon_hdmi_frl_link_error_count": {
        "description": "Print the error count per lane during link failure between PCON and HDMI sink.",
        "pre": {
            "aux": "!=null",
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_enc_is_dsc_1_2": {
        "description": "Does PCON Encoder supports DSC 1.2",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_pcon_enc_is_dsc_1_2": {
        "description": "Does PCON Encoder supports DSC 1.2",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_dsc_max_slices": {
        "description": "Get max slices supported by PCON DSC Encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_pcon_dsc_max_slices": {
        "description": "Get max slices supported by PCON DSC Encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_dsc_max_slice_width": {
        "description": "Get max slice width for Pcon DSC encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_pcon_dsc_max_slice_width": {
        "description": "Get max slice width for Pcon DSC encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_dsc_bpp_incr": {
        "description": "Get bits per pixel increment for PCON DSC encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:drm_dp_pcon_dsc_bpp_incr": {
        "description": "Get bits per pixel increment for PCON DSC encoder",
        "pre": {
            "pcon_dsc_dpcd": "!=null"
        },
        "post": {
            "return": "is an integer"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_pps_default": {
        "description": "Let PCON fill the default PPS parameters for DSC 1.2 between PCON and HDMI 2.1 sink.",
        "pre": {
            "aux": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_dp_pcon_pps_default": {
        "description": "Let PCON fill the default pps parameters for DSC1.2 between PCON & HDMI2.1 sink.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_pps_override_buf": {
        "description": "Configure PPS encoder override buffer for HDMI sink",
        "pre": {
            "aux": "!=null",
            "pps_buf": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_pcon_pps_override_buf": {
        "description": "Configure PPS encoder override buffer for HDMI sink",
        "pre": {
            "aux": "!=null",
            "pps_buf": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_pps_override_param": {
        "description": "Write PPS parameters to DSC encoder override registers",
        "pre": {
            "aux": "!=null",
            "pps_param": "!=null",
            "pps_param[0]": ">=0",
            "pps_param[0]": "<=255",
            "pps_param[1]": ">=0",
            "pps_param[1]": "<=255",
            "pps_param[2]": ">=0",
            "pps_param[2]": "<=255"
        }
    }
},
{
    "kprobe:drm_dp_pcon_pps_override_param": {
        "description": "Write PPS parameters to DSC encoder override registers",
        "pre": {
            "aux": "!=null",
            "pps_param": "!=null",
            "pps_param[0]": ">=0",
            "pps_param[0]": "<=255",
            "pps_param[1]": ">=0",
            "pps_param[1]": "<=255",
            "pps_param[2]": ">=0",
            "pps_param[2]": "<=255",
            "pps_param[3]": ">=0",
            "pps_param[3]": "<=255",
            "pps_param[4]": ">=0",
            "pps_param[4]": "<=255",
            "pps_param[5]": ">=0",
            "pps_param[5]": "<=255"
        }
    }
},
{
    "kretprobe:drm_dp_pcon_convert_rgb_to_ycbcr": {
        "description": "Configure the PCon to convert RGB to Ycbcr",
        "pre": {
            "aux": "!=null",
            "color_spc": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]"
        }
    }
},
{
    "kprobe:drm_dp_pcon_convert_rgb_to_ycbcr": {
        "description": "Configure the PCon to convert RGB to Ycbcr",
        "pre": {
            "aux": "!=null",
            "color_spc": "is an integer",
            "color_spc >= 0"
        }
    }
},
{
    "kretprobe:drm_edp_backlight_set_level": {
        "description": "Sets the brightness level of an eDP panel's backlight.",
        "pre": {
            "aux": "!=null",
            "bl": "!=null",
            "level": "!=null"
        }
    }
},
{
    "kprobe:drm_edp_backlight_set_level": {
        "description": "Sets the brightness level of an eDP panel's backlight.",
        "pre": {
            "aux": "!=null",
            "bl": "!=null",
            "level": "!=null"
        }
    }
},
{
    "kretprobe:drm_edp_backlight_disable": {
        "description": "Disable an eDP backlight using DPCD, if supported",
        "pre": {
            "aux": "!=null",
            "bl": "!=null"
        }
    }
},
{
    "kprobe:drm_edp_backlight_disable": {
        "description": "Disable an eDP backlight using DPCD, if supported",
        "pre": {
            "aux": "!=null",
            "bl": "!=null"
        }
    }
},
{
    "kretprobe:drm_panel_dp_aux_backlight": {
        "description": "Create and use DP AUX backlight",
        "pre": {
            "panel": "!=null",
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_panel_dp_aux_backlight": {
        "description": "Create and use DP AUX backlight",
        "pre": {
            "panel": "!=null",
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_get_port_malloc": {
        "description": "Increment the malloc refcount of an MST port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_get_port_malloc": {
        "description": "Increment the malloc refcount of an MST port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_get_mstb_malloc": {
        "description": "Increment the malloc refcount of a branch device",
        "pre": {
            "mstb": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_get_mstb_malloc": {
        "description": "Increment the malloc refcount of a branch device",
        "pre": {
            "mstb": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_connector_late_register": {
        "description": "Late MST connector registration",
        "pre": {
            "connector": "!=null",
            "port": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:drm_dp_mst_connector_late_register": {
        "description": "Late MST connector registration",
        "pre": {
            "connector": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_connector_early_unregister": {
        "description": "Early MST connector unregistration",
        "pre": {
            "connector": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_connector_early_unregister": {
        "description": "Early MST connector unregistration",
        "pre": {
            "connector": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_send_query_stream_enc_status": {
        "description": "Sends a query for stream encryption status to the MST Branch device directly connected to the Source device.",
        "pre": {
            "mgr": "!=null",
            "port": "!=null",
            "status": "!=null",
            "txmsg->dst": "!=null",
            "payload->vcpi": "!=null",
            "nonce": "!=null",
            "state": "!=null",
            "payload": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_send_query_stream_enc_status": {
        "description": "Send a query for the stream encryption status.",
        "pre": {
            "mgr": "!=null",
            "port": "!=null",
            "status": "!=null"
        }
    },
    "kprobe:build_query_stream_enc_status": {
        "description": "Build the query for the stream encryption status.",
        "pre": {
            "txmsg": "!=null",
            "payload->vcpi": "!=null",
            "nonce": "!=null"
        }
    },
    "kprobe:drm_dp_queue_down_tx": {
        "description": "Queue down the transaction.",
        "pre": {
            "mgr": "!=null",
            "txmsg": "!=null"
        }
    },
    "kprobe:drm_dp_mst_wait_tx_reply": {
        "description": "Wait for the transaction reply.",
        "pre": {
            "mgr->mst_primary": "!=null",
            "txmsg": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_add_payload_part1": {
        "description": "Execute payload update part 1",
        "pre": {
            "mgr": "!=null",
            "mst_state": "!=null",
            "payload": "!=null",
            "payload.vc_start_slot": "==null",
            "payload.vc_start_slot": "==-1"
        }
    }
},
{
    "kprobe:drm_dp_add_payload_part1": {
        "description": "Execute payload update part 1",
        "pre": {
            "mgr": "!=null",
            "mst_state": "!=null",
            "payload": "!=null",
            "payload.vc_start_slot": "==null",
            "return": "==0"
        }
    }
},
{
    "kretprobe:drm_dp_remove_payload": {
        "description": "Remove an MST payload",
        "pre": {
            "mgr": "!=null",
            "mst_state": "!=null",
            "old_payload": "!=null",
            "new_payload": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_remove_payload": {
        "description": "Remove an MST payload",
        "pre": {
            "mgr": "!=null",
            "mst_state": "!=null",
            "old_payload": "!=null",
            "new_payload": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_add_payload_part2": {
        "description": "Execute payload update part 2",
        "pre": {
            "mgr": "!=null",
            "state": "!=null",
            "payload": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_add_payload_part2": {
        "description": "Execute payload update part 2",
        "pre": {
            "mgr": "!=null",
            "state": "!=null",
            "payload": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_get_vc_payload_bw": {
        "description": "Get the VC payload BW for an MST link",
        "pre": {
            "mgr": "!=null",
            "link_rate": "!=null",
            "link_lane_count": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_get_vc_payload_bw": {
        "description": "Get the VC payload BW for an MST link.",
        "pre": {
            "mgr": "!=null",
            "link_rate": "!=null",
            "link_lane_count": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_read_mst_cap": {
        "description": "Check whether or not a sink supports MST",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_dp_read_mst_cap": {
        "description": "Check whether or not a sink supports MST.",
        "pre": {
            "aux": "!=null",
            "dpcd": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_dp_mst_topology_mgr_suspend": {
        "description": "Suspend the MST manager",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_topology_mgr_suspend": {
        "description": "Suspend the MST manager",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_topology_mgr_resume": {
        "description": "Resume the MST manager",
        "pre": {
            "mgr": "!=null",
            "sync": "in [true, false]"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:drm_dp_mst_topology_mgr_resume": {
        "description": "Resume the MST manager",
        "pre": {
            "mgr": "!=null",
            "sync": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_dp_mst_hpd_irq_handle_event": {
        "description": "Handle an event related to high-priority data interrupts in the DisplayPort MST topology manager.",
        "pre": {
            "mgr": "!=null",
            "esi": "!=null",
            "ack": "!=null",
            "handled": "!=null"
        }
    }
},
"handled": "==true",
{
    "kretprobe:intdrm_dp_mst_detect_port": {
        "description": "Get connection status for an MST port",
        "pre": {
            "connector": "!=null",
            "ctx": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:intdrm_dp_mst_detect_port": {
        "description": "Get connection status for an MST port",
        "pre": {
            "connector": "!=null",
            "ctx": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_edid_read": {
        "description": "Get EDID for an MST port",
        "pre": {
            "connector": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_edid_read": {
        "description": "Get EDID for an MST port",
        "pre": {
            "connector": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_get_edid": {
        "description": "Get EDID for an MST port",
        "pre": {
            "connector": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_get_edid": {
        "description": "Get EDID for an MST port",
        "pre": {
            "connector": "!=null",
            "mgr": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_atomic_find_time_slots": {
        "description": "Total slots in the atomic state assigned for this port, or a negative error code if the port no longer exists.",
        "pre": {
            "state": "!=null",
            "mgr": "!=null",
            "port": "!=null",
            "pbn": "int"
        }
    }
},
{
    "kprobe:drm_dp_atomic_find_time_slots": {
        "description": "Find time slots in the atomic state assigned for a port.",
        "pre": {
            "state": "!=null",
            "mgr": "!=null",
            "port": "!=null",
            "pbn": "int"
        }
    }
},
{
    "kretprobe:drm_dp_mst_atomic_setup_commit": {
        "description": "setup_commit hook for MST helpers",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_atomic_setup_commit": {
        "description": "setup_commit hook for MST helpers",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_atomic_wait_for_dependencies": {
        "description": "Wait for all pending commits on MST topologies, prepare new MST state for commit",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_atomic_wait_for_dependencies": {
        "description": "Wait for all pending commits on MST topologies, prepare new MST state for commit.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_root_conn_atomic_check": {
        "description": "Serialize CRTC commits on MST-capable connectors operating in SST mode.",
        "pre": {
            "new_conn_state": "!=null",
            "mgr": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:drm_dp_mst_root_conn_atomic_check": {
        "description": "Serialize CRTC commits on MST-capable connectors operating in SST mode.",
        "pre": {
            "new_conn_state": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_update_slots": {
        "description": "Updates the slot info depending on the DP encoding format.",
        "pre": {
            "mst_state": "!=null",
            "link_encoding_cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_update_slots": {
        "description": "Updates the slot info depending on the DP encoding format.",
        "pre": {
            "mst_state": "!=null",
            "link_encoding_cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_check_act_status": {
        "description": "Polls for ACT handled status.",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_check_act_status": {
        "description": "Polls for ACT handled status.",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_calc_pbn_mode": {
        "description": "Calculate the PBN for a mode.",
        "pre": {
            "clock": "!=null",
            "bpp": "!=null",
            "dsc": "!=null",
            "bpp_units": "in [1, 116] when dsc == true"
        }
    }
},
{
    "kprobe:drm_dp_calc_pbn_mode": {
        "description": "Calculate the PBN for a mode.",
        "pre": {
            "clock": "!=null",
            "bpp": "!=null",
            "dsc": "in [true, false]",
            "bpp_units": "in [1, 16] when dsc == true"
        }
    }
},
{
    "kretprobe:drm_dp_mst_dump_topology": {
        "description": "Dump topology to seq file.",
        "pre": {
            "m": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_dump_topology": {
        "description": "Dump topology to seq file.",
        "pre": {
            "m": "!=null",
            "mgr": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:drm_atomic_get_mst_payload_state": {
        "description": "Get the payload state for the given topology state and port.",
        "pre": {
            "topology_state": "!=null",
            "port": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_atomic_get_old_mst_topology_state": {
        "description": "Get old MST topology state in atomic state, if any.",
        "pre": {
            "state": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_old_mst_topology_state": {
        "description": "Get old MST topology state in atomic state, if any.",
        "pre": {
            "state": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_atomic_get_new_mst_topology_state": {
        "description": "Get new MST topology state in atomic state, if any",
        "pre": {
            "state": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_atomic_get_new_mst_topology_state": {
        "description": "Get new MST topology state in atomic state, if any.",
        "pre": {
            "state": "!=null",
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_topology_mgr_init": {
        "description": "Initialise a topology manager",
        "pre": {
            "mgr": "!=null",
            "dev": "!=null",
            "aux": "!=null",
            "max_dpcd_transaction_bytes": "int",
            "max_payloads": "int",
            "conn_base_id": "int"
        }
    }
},
{
    "kprobe:drm_dp_mst_topology_mgr_init": {
        "description": "Initialise a topology manager",
        "pre": {
            "mgr": "!=null",
            "dev": "!=null",
            "aux": "!=null",
            "max_dpcd_transaction_bytes": ">=0",
            "max_payloads": ">=0",
            "conn_base_id": ">=0"
        }
    }
},
{
    "kretprobe:drm_dp_mst_topology_mgr_destroy": {
        "description": "Destroy the topology manager.",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_mst_topology_mgr_destroy": {
        "description": "Destroy topology manager.",
        "pre": {
            "mgr": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_mst_atomic_enable_dsc": {
        "description": "Set DSC Enable Flag to On/Off",
        "pre": {
            "state": "!=null",
            "port": "!=null",
            "pbn": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_dp_mst_atomic_enable_dsc": {
        "description": "Set DSC Enable Flag to On/Off",
        "pre": {
            "state": "!=null",
            "port": "!=null",
            "pbn": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_hdmi_infoframe_set_hdr_metadata": {
        "description": "Fill an HDMI DRM infoframe with HDR metadata from userspace",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        },
        "post": {
            "return_value": "in [0, <negative error codes>]"
        }
    }
},
{
    "kprobe:drm_hdmi_infoframe_set_hdr_metadata": {
        "description": "Fill an HDMI DRM infoframe with HDR metadata from userspace.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_hdmi_avi_infoframe_colorimetry": {
        "description": "Fill the HDMI AVI infoframe colorimetry information.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
S,
{
    "kretprobe:drm_hdmi_avi_infoframe_bars": {
        "description": "Fill the HDMI AVI infoframe bar information.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kprobe:drm_hdmi_avi_infoframe_bars": {
        "description": "Fill the HDMI AVI infoframe bar information.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_hdmi_avi_infoframe_content_type": {
        "description": "Fill the HDMI AVI infoframe content type information, based on correspondent DRM property.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kprobe:drm_hdmi_avi_infoframe_content_type": {
        "description": "Fill the HDMI AVI infoframe content type information, based on correspondent DRM property.",
        "pre": {
            "frame": "!=null",
            "conn_state": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_read": {
        "description": "Read from the DP dual mode adaptor register(s)",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_read": {
        "description": "Read from the DP dual mode adaptor register(s)",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_write": {
        "description": "Write to the DP dual mode adaptor register(s)",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_write": {
        "description": "Write to the DP dual mode adaptor register(s)",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_detect": {
        "description": "Identify the DP dual mode adaptor",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_detect": {
        "description": "Identify the DP dual mode adaptor.",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_max_tmds_clock": {
        "description": "Max TMDS clock for DP dual mode adaptor",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_max_tmds_clock": {
        "description": "Max TMDS clock for DP dual mode adaptor",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_get_tmds_output": {
        "description": "Get the state of the TMDS output buffers in the DP dual mode adaptor.",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null",
            "enabled": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_get_tmds_output": {
        "description": "Get the state of the TMDS output buffers in the DP dual mode adaptor.",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null",
            "enabled": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_dual_mode_set_tmds_output": {
        "description": "Enable/disable TMDS output buffers in the DP dual mode adaptor.",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null",
            "enable": "bool"
        }
    }
},
{
    "kprobe:drm_dp_dual_mode_set_tmds_output": {
        "description": "Enable/disable TMDS output buffers in the DP dual mode adaptor.",
        "pre": {
            "dev": "!=null",
            "type": "in [DP_DUAL_MODE_TYPE1, DP_DUAL_MODE_TYPE2]",
            "adapter": "!=null",
            "enable": "is_boolean"
        }
    }
},
{
    "kretprobe:drm_dp_get_dual_mode_type_name": {
        "description": "Get the name of the DP dual mode adaptor type as a string",
        "pre": {
            "type": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is_valid_string_representation_of_DP_dual_mode_adaptor_type"
        }
    }
},
S,
{
    "kretprobe:drm_lspcon_get_mode": {
        "description": "Get LSPCON's current mode of operation by reading offset (0x80, 0x41)",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:drm_lspcon_get_mode": {
        "description": "Get LSPCON's current mode of operation by reading offset (0x80, 0x41)",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:drm_lspcon_set_mode": {
        "description": "Change LSPCON's mode of operation by writing offset (0x80, 0x40).",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null",
            "mode": "in [enum drm_lspcon_mode]"
        },
        "post": {
            "return": "in [0, -error]"
        }
    }
},
{
    "kprobe:drm_lspcon_set_mode": {
        "description": "Change LSPCON's mode of operation",
        "pre": {
            "dev": "!=null",
            "adapter": "!=null",
            "mode": "in [MODE_1, MODE_2, MODE_3]"
        }
    }
},
{
    "kretprobe:drm_scdc_read": {
        "description": "Read a block of data from SCDC",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_scdc_read": {
        "description": "Read a block of data from SCDC",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_scdc_write": {
        "description": "Write a block of data to SCDC",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:drm_scdc_write": {
        "description": "Write a block of data to SCDC",
        "pre": {
            "adapter": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:drm_scdc_get_scrambling_status": {
        "description": "Reads the scrambler status over SCDC and checks the scrambling status.",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kprobe:drm_scdc_get_scrambling_status": {
        "description": "What is the status of scrambling?",
        "pre": {
            "connector": "!=null"
        }
    }
},
{
    "kretprobe:drm_scdc_set_scrambling": {
        "description": "Enable or disable scrambling for the TMDS config register over SCDC channel.",
        "pre": {
            "connector": "!=null",
            "enable": "in [0, 1]"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_scdc_set_scrambling": {
        "description": "Enable or disable scrambling for the TMDS config register over SCDC channel.",
        "pre": {
            "connector": "!=null",
            "enable": "in [0, 1]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:drm_scdc_set_high_tmds_clock_ratio": {
        "description": "Set TMDS clock ratio",
        "pre": {
            "connector": "!=null",
            "set": "in [0, 1]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:drm_scdc_set_high_tmds_clock_ratio": {
        "description": "Set TMDS clock ratio",
        "pre": {
            "connector": "!=null",
            "set": "in [0, 1]"
        }
    }
},
{
    "kretprobe:drm_dp_cec_irq": {
        "description": "Handle CEC interrupt, if any",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_cec_irq": {
        "description": "Handle CEC interrupt, if any",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_cec_set_edid": {
        "description": "Set the EDID for the given DRM DP auxiliary device.",
        "pre": {
            "aux": "!=null",
            "edid": "!=null",
            "aux->transfer": "==true",
            "CONFIG_MEDIA_CEC_RC": "defined",
            "cec_caps": "in [CEC_CAP_DEFAULTS, CEC_CAP_NEEDS_HPD, CEC_CAP_CONNECTOR_INFO]",
            "num_las": "==1",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_cec_set_edid": {
        "description": "Set the EDID for the CEC over DP auxiliary channel.",
        "pre": {
            "aux": "!=null",
            "edid": "!=null",
            "aux->transfer": "==true",
            "CONFIG_MEDIA_CEC_RC": "defined",
            "cec_caps": "in [CEC_CAP_DEFAULTS | CEC_CAP_NEEDS_HPD | CEC_CAP_CONNECTOR_INFO]",
            "num_las": "==1",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:drm_dp_cec_unset_edid": {
        "description": "No transfer function was set, so not a DP connector",
        "pre": {
            "aux": "!=null",
            "aux->transfer": "==false"
        },
        "post": {
            "aux->cec.unregister_work": "cancelled",
            "aux->cec.lock": "locked",
            "aux->cec.adap": "null",
            "aux->cec.adap->cec_phys_addr": "invalidated",
            "aux->cec.adap->cec_capable": "==true"
        }
    }
},
{
    "kprobe:if (!aux->transfer)return;cancel_delayed_work_sync(&aux->cec.unregister_work);mutex_lock(&aux->cec.lock);if (!aux->cec.adap)goto unlock;cec_phys_addr_invalidate(aux->cec.adap);/* * We're done if we want to keep the CEC device * (drm_dp_cec_unregister_delay is >= NEVER_UNREG_DELAY) or if the * DPCD still indicates the CEC capability (expected for an integrated * HDMI branch device). `": {
        "description": "Helper function for DRM DP CEC unset EDID",
        "pre": {
            "aux": {
                "transfer": "false"
            },
            "aux->cec.adap": "!=null",
            "drm_dp_cec_unregister_delay": ">= NEVER_UNREG_DELAY",
            "DPCD": "indicates CEC capability"
        }
    }
},
S,
{
    "kprobe:cec_s_phys_addr_from_edid": {
        "description": "Calculate the physical address from the EDID.",
        "pre": {
            "aux->cec.adap": "!=null",
            "edid": "==null"
        }
    }
},
{
    "kretprobe:drm_dp_cec_unregister_connector": {
        "description": "Unregister the CEC adapter, if any.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kprobe:drm_dp_cec_unregister_connector": {
        "description": "Unregister the CEC adapter, if any.",
        "pre": {
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:omap_mbox_enable_irq": {
        "description": "Enable the specified interrupt for the OMAP mailbox channel.",
        "pre": {
            "mbox": "!=null",
            "irq": "!=null",
            "fifo": "!=null",
            "bit": "!=null",
            "irqdisable": "!=null"
        }
    }
},
{
    "kprobe:omap_mbox_enable_irq": {
        "description": "Enable the specified interrupt for the OMAP mailbox channel.",
        "pre": {
            "mbox": "!=null",
            "irq": "!=null",
            "mbox->intr_type": "==0",
            "bit": "mbox_read_reg(mbox->parent, irqdisable) & ~bit",
            "irqdisable": "mbox_write_reg(mbox->parent, bit, irqdisable)"
        }
    }
},
{
    "kretprobe:zorro_register_driver": {
        "description": "Register a new Zorro driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return": "in [0, -MAX_ERR_VALUE]"
        }
    }
},
S,
{
    "kretprobe:zorro_unregister_driver": {
        "description": "Unregister a Zorro driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:zorro_unregister_driver": {
        "description": "Unregister a zorro driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:sa11xx_drv_pcmcia_probe": {
        "description": "Probe the sa11xx_drv_pcmcia driver.",
        "pre": {
            "dev": "!=null",
            "ops": "!=null",
            "first": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kprobe:for": {
        "description": "Loop for a specified number of iterations",
        "pre": {
            "i": ">= 0",
            "nr": ">= 0"
        }
    }
},
{
    "kretprobe:pcmcia_register_driver": {
        "description": "Register a PCMCIA driver with the bus core.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_register_driver": {
        "description": "Register a PCMCIA driver with the bus core.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:pcmcia_unregister_driver": {
        "description": "Unregister a PCMCIA driver with the bus core",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_unregister_driver": {
        "description": "Unregister a PCMCIA driver with the bus core.",
        "pre": {
            "driver": "!=null"
        }
    }
},
S,
{
    "kprobe:pcmcia_dev_present": {
        "description": "Returns NULL if the condition is probably really small.",
        "pre": {
            "condition": "probably really small"
        }
    }
},
{
    "kretprobe:pcmcia_register_socket": {
        "description": "Add a new pcmcia socket device",
        "pre": {
            "socket": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_register_socket": {
        "description": "Add a new pcmcia socket device",
        "pre": {
            "socket": "!=null"
        }
    }
},
{
    "kretprobe:pcmcia_unregister_socket": {
        "description": "Remove a pcmcia socket device",
        "pre": {
            "socket": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_unregister_socket": {
        "description": "Remove a pcmcia socket device",
        "pre": {
            "socket": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:pcmcia_parse_uevents": {
        "description": "Tell pccardd to issue manual commands",
        "pre": {
            "s": "!=null",
            "events": "in [PCMCIA_UEVENT_EJECT, PCMCIA_UEVENT_INSERT, PCMCIA_UEVENT_RESUME, PCMCIA_UEVENT_SUSPEND, PCMCIA_UEVENT_REQUERY]"
        }
    }
},
{
    "kprobe:pcmcia_parse_uevents": {
        "description": "Tell pccardd to issue manual commands.",
        "pre": {
            "s": "!=null",
            "events": "in [PCMCIA_UEVENT_EJECT, PCMCIA_UEVENT_INSERT, PCMCIA_UEVENT_RESUME, PCMCIA_UEVENT_SUSPEND, PCMCIA_UEVENT_REQUERY]"
        }
    }
},
S,
{
    "kprobe:mutex_lock": {
        "description": "Lock the mutex pointed to by s->skt_mutex.",
        "pre": {
            "s": {
                "skt_mutex": "!=null"
            },
            "c": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(pcmcia_reset_card)": {
        "description": "Reset the PCMCIA card in the given socket.",
        "pre": {
            "skt": "!=null",
            "skt->dev": "!=null",
            "skt->state": "& SOCKET_PRESENT != 0",
            "skt->state": "& SOCKET_SUSPEND == 0",
            "skt->state": "& SOCKET_CARDBUS == 0",
            "skt->callback": "!=null",
            "skt->callback->suspend": "!=null",
            "skt->ops_mutex": "locked",
            "ret": "== 0"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(pcmcia_reset_card)": {
        "description": "Reset the PCMCIA card in the given socket.",
        "pre": {
            "skt": "!=null",
            "skt->dev": "!=null",
            "skt->state": "& SOCKET_PRESENT != 0",
            "skt->state": "& SOCKET_SUSPEND == 0",
            "skt->state": "& SOCKET_CARDBUS == 0",
            "skt->callback": "!=null",
            "skt->callback->suspend": "!=null",
            "skt->ops_mutex": "locked",
            "ret": "== 0"
        }
    }
},
{
    "kretprobe:socket->cis_mem.flags = 0;socket->cis_mem.speed = cis_speed;INIT_LIST_HEAD(&socket->cis_cache);init_completion(&socket->socket_released);init_completion(&socket->thread_done);mutex_init(&socket->skt_mutex);mutex_init(&socket->ops_mutex);spin_lock_init(&socket->thread_lock);if (socket->resource_ops->init)": {
        "description": "Initialize various fields of the socket structure.",
        "pre": {
            "socket": "!=null",
            "cis_mem.flags": "==0",
            "cis_mem.speed": "==cis_speed",
            "cis_cache": "is empty",
            "socket_released": "is not completed",
            "thread_done": "is not completed",
            "skt_mutex": "is initialized",
            "ops_mutex": "is initialized",
            "thread_lock": "is initialized",
            "resource_ops.init": "!=null"
        }
    }
},
{
    "kprobe:socket->cis_mem.flags = 0;socket->cis_mem.speed = cis_speed;INIT_LIST_HEAD(&socket->cis_cache);init_completion(&socket->socket_released);init_completion(&socket->thread_done);mutex_init(&socket->skt_mutex);mutex_init(&socket->ops_mutex);spin_lock_init(&socket->thread_lock);if (socket->resource_ops->init)": {
        "description": "Initialize the socket structure and its associated members.",
        "pre": {
            "socket": "!=null",
            "cis_mem.flags": "==0",
            "cis_mem.speed": "==cis_speed",
            "cis_cache": "is empty",
            "socket_released": "is not completed",
            "thread_done": "is not completed",
            "skt_mutex": "is initialized",
            "ops_mutex": "is initialized",
            "thread_lock": "is initialized",
            "resource_ops.init": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:pcmcia_do_loop_config": {
        "description": "Internal callback for the call from pcmcia_loop_config to pccard_loop_tuple(). Data is transferred by a struct pcmcia_cfg_mem.",
        "pre": {
            "tuple": "!=null",
            "parse": "!=null",
            "priv": "!=null"
        }
    }
},
S,
{
    "kretprobe:pcmcia_do_loop_tuple": {
        "description": "Transfer data using pcmcia_cfg_mem",
        "pre": {
            "tuple": "!=null",
            "parse": "!=null",
            "priv": "!=null",
            "pcmcia_cfg_mem": "valid"
        }
    }
},
S,
{
    "kretprobe:pcmcia_do_get_tuple": {
        "description": "The internal callback for the call from pcmcia_get_tuple() to pcmcia_loop_tuple().",
        "pre": {
            "p_dev": "!=null",
            "tuple": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_do_get_tuple": {
        "description": "The internal callback for the call from pcmcia_get_tuple() to pcmcia_loop_tuple().",
        "pre": {
            "p_dev": "!=null",
            "tuple": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:pcmcia_do_get_mac": {
        "description": "Check if the tuple contains a proper LAN_NODE_ID of length 6 and copy the data to struct net_device->dev_addr[i].",
        "pre": {
            "p_dev": "!=null",
            "tuple": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_do_get_mac": {
        "description": "Internal callback for pcmcia_get_mac_from_cis() to pcmcia_loop_tuple().",
        "pre": {
            "p_dev": "!=null",
            "tuple": "!=null",
            "priv": "!=null",
            "tuple.LAN_NODE_ID": "length == 6",
            "net_device.dev_addr[i]": "copy(tuple.LAN_NODE_ID)"
        }
    }
},
S,
{
    "kprobe:soc_common_pcmcia_config_skt": {
        "description": "Configure soc_pcmcia_socket and perform related actions.",
        "pre": {
            "skt": "!=null",
            "dead_socket": "!=null"
        },
        "actions": [
            {
                "description": "Delete the poll timer.",
                "pre": {}
            },
            {
                "description": "Unregister the PCMCIA socket.",
                "pre": {}
            },
            {
                "description": "Unregister the CPU frequency notifier if frequency_change is true.",
                "pre": {
                    "skt->ops->frequency_change": "==true"
                }
            },
            {
                "description": "Shutdown the soc_pcmcia hardware.",
                "pre": {}
            }
        ]
    }
},
{
    "kretprobe:skt->ops->set_timing": {
        "description": "Initialize default socket timing",
        "pre": {
            "skt": "!=null",
            "skt->ops": "!=null",
            "skt->ops->set_timing": "!=null"
        }
    },
    "kretprobe:soc_pcmcia_hw_init": {
        "description": "Initialize hardware for PCMCIA socket",
        "pre": {
            "skt": "!=null",
            "ret": "!=null",
            "ret": "==0"
        }
    },
    "kretprobe:goto out_err_6": {
        "description": "Handle error case",
        "pre": {
            "ret": "!=null",
            "ret": "!=0"
        }
    },
    "kretprobe:skt->socket.ops": {
        "description": "Set socket operations",
        "pre": {
            "skt": "!=null",
            "skt->socket.ops": "!=null"
        }
    },
    "kretprobe:skt->socket.features": {
        "description": "Set socket features",
        "pre": {
            "skt": "!=null",
            "skt->socket.features": "!=null",
            "skt->socket.features": "& SS_CAP_STATIC_MAP|SS_CAP_PCCARD"
        }
    },
    "kretprobe:skt->socket.resource_ops": {
        "description": "Set socket resource operations",
        "pre": {
            "skt": "!=null",
            "skt->socket.resource_ops": "!=null"
        }
    },
    "kretprobe:skt->socket.irq_mask": {
        "description": "Set socket IRQ mask",
        "pre": {
            "skt": "!=null",
            "skt->socket.irq_mask": "==0"
        }
    },
    "kretprobe:skt->socket.map_size": {
        "description": "Set socket map size",
        "pre": {
            "skt": "!=null",
            "skt->socket.map_size": "==PAGE_SIZE"
        }
    },
    "kretprobe:skt->socket.io_offset": {
        "description": "Set socket IO offset",
        "pre": {
            "skt": "!=null",
            "skt->socket.io_offset": "== (unsigned long)skt->res_io_io.start"
        }
    },
    "kretprobe:skt->status": {
        "description": "Set socket status",
        "pre": {
            "skt": "!=null",
            "skt->status": "!=null"
        }
    },
    "kretprobe:skt->ops->frequency_change": {
        "description": "Check if frequency change is supported",
        "pre": {
            "skt": "!=null",
            "skt->ops": "!=null",
            "skt->ops->frequency_change": "!=null"
        }
    }
},
{
    "kprobe:skt->ops->set_timing(skt);ret = soc_pcmcia_hw_init(skt);if (ret)goto out_err_6;skt->socket.ops = &soc_common_pcmcia_operations;skt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;skt->socket.resource_ops = &pccard_static_ops;skt->socket.irq_mask = 0;skt->socket.map_size = PAGE_SIZE;skt->socket.io_offset = (unsigned long)skt->res_io_io.start;skt->status = soc_common_pcmcia_skt_state(skt);#ifdef CONFIG_CPU_FREQif (skt->ops->frequency_change)":
    {
        "description": "Helper function for skt->ops->set_timing(skt);ret = soc_pcmcia_hw_init(skt);if (ret)goto out_err_6;skt->socket.ops = &soc_common_pcmcia_operations;skt->socket.features = SS_CAP_STATIC_MAP|SS_CAP_PCCARD;skt->socket.resource_ops = &pccard_static_ops;skt->socket.irq_mask = 0;skt->socket.map_size = PAGE_SIZE;skt->socket.io_offset = (unsigned long)skt->res_io_io.start;skt->status = soc_common_pcmcia_skt_state(skt);#ifdef CONFIG_CPU_FREQif (skt->ops->frequency_change)",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:pcmcia_map_mem_page": {
        "description": "Modifies the iomem range previously enabled by pcmcia_request_window() by setting the card_offset value to the provided offset.",
        "pre": {
            "p_dev": "!=null",
            "res": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:pcmcia_map_mem_page": {
        "description": "Modifies what can be read and written by accessing an iomem range previously enabled by pcmcia_request_window()",
        "pre": {
            "p_dev": "!=null",
            "res": "!=null",
            "offset": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:pcmica_request_io": {
        "description": "Attempt to reserve port ranges for PCMCIA devices",
        "pre": {
            "p_dev": "!=null",
            "p_dev->resource[0].start": "!=null",
            "p_dev->resource[0].end": "!=null",
            "p_dev->resource[1].start": "!=null",
            "p_dev->resource[1].end": "!=null",
            "p_dev->io_lines": "!=null"
        }
    }
},
{
    "kprobe:pcmica_request_io": {
        "description": "Attempt to reserve port ranges for PCMCIA devices",
        "pre": {
            "p_dev": "!=null",
            "p_dev->resource[0].start": "!=null",
            "p_dev->resource[0].end": "!=null",
            "p_dev->resource[1].start": "!=null",
            "p_dev->resource[1].end": "!=null",
            "p_dev->io_lines": "!=null"
        }
    }
},
{
    "kretprobe:pcmica_request_irq": {
        "description": "Attempt to request an IRQ for a PCMCIA device",
        "pre": {
            "p_dev": "!=null",
            "handler": "!=null"
        }
    }
},
{
    "kprobe:pcmica_request_irq": {
        "description": "Attempt to request an IRQ for a PCMCIA device.",
        "pre": {
            "p_dev": "!=null",
            "handler": "!=null"
        }
    }
},
{
    "kretprobe:cpufreq_quick_get": {
        "description": "Get the CPU frequency (in kHz) from policy->cur",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:cpufreq_quick_get": {
        "description": "Get the CPU frequency (in kHz) from policy->cur",
        "pre": {
            "cpu": ">=0"
        }
    }
},
{
    "kretprobe:cpufreq_quick_get_max": {
        "description": "Get the max reported CPU frequency for this CPU",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:cpufreq_quick_get_max": {
        "description": "Get the max reported CPU frequency for this CPU",
        "pre": {
            "cpu": ">=0"
        }
    }
},
{
    "kretprobe:cpufreq_get_hw_max_freq": {
        "description": "Get the max hardware frequency of the CPU",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:cpufreq_get_hw_max_freq": {
        "description": "Get the max hardware frequency of the CPU",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:cpufreq_disabled": {
        "description": "Checks if the CPU frequency is disabled.",
        "pre": {
            "cpufreq_policy_notifier_list": "!=null",
            "cpufreq_transition_notifier_list": "!=null",
            "off": "__read_mostly",
            "mutex_lock": "acquired"
        }
    }
},
{
    "kprobe:cpufreq_disabled": {
        "description": "Checks if the CPU frequency is disabled.",
        "pre": {
            "cpufreq_policy_notifier_list": "!=null",
            "cpufreq_transition_notifier_list": "!=null",
            "off": "!=null"
        }
    }
},
{
    "kretprobe:cpufreq_register_notifier": {
        "description": "Register a notifier with cpufreq.",
        "pre": {
            "nb": "!=null",
            "list": "in [CPUFREQ_TRANSITION_NOTIFIER, CPUFREQ_POLICY_NOTIFIER]"
        }
    }
},
{
    "kprobe:cpufreq_register_notifier": {
        "description": "Register a notifier with cpufreq.",
        "pre": {
            "nb": "!=null",
            "list": "in [CPUFREQ_TRANSITION_NOTIFIER, CPUFREQ_POLICY_NOTIFIER]"
        }
    }
},
{
    "kretprobe:cpufreq_unregister_notifier": {
        "description": "Unregister a notifier from cpufreq.",
        "pre": {
            "nb": "!=null",
            "list": "in [CPUFREQ_TRANSITION_NOTIFIER, CPUFREQ_POLICY_NOTIFIER]"
        }
    }
},
{
    "kprobe:cpufreq_unregister_notifier": {
        "description": "Unregister a notifier from cpufreq.",
        "pre": {
            "nb": "!=null",
            "list": "in [CPUFREQ_TRANSITION_NOTIFIER, CPUFREQ_POLICY_NOTIFIER]"
        }
    }
},
{
    "kretprobe:cpufreq_get_policy": {
        "description": "Get the current cpufreq_policy",
        "pre": {
            "policy": "!=null",
            "cpu": "unsigned int"
        }
    }
},
{
    "kprobe:cpufreq_get_policy": {
        "description": "Get the current cpufreq_policy",
        "pre": {
            "policy": "!=null",
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:cpufreq_out_of_sync": {
        "description": "Function to handle out-of-sync events in cpufreq policy",
        "pre": {
            "policy": "!=null",
            "new_freq": "!=null"
        }
    }
},
S,
{
    "kretprobe:sync_file_create": {
        "description": "Creates a sync file containing @fence.",
        "pre": {
            "fence": "!=null"
        },
        "post": {
            "sync_file": "!=null"
        }
    }
},
{
    "kprobe:sync_file_create": {
        "description": "Creates a sync file containing the given fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:sync_file_get_fence": {
        "description": "Get the fence related to the sync_file fd",
        "pre": {
            "fd": "!=null",
            "fd_valid": "==true"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:sync_file_get_fence": {
        "description": "Get the fence related to the sync_file fd",
        "pre": {
            "fd": "!=null",
            "fd_valid": "==true",
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_init": {
        "description": "Initialize a reservation object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:dma_resv_init": {
        "description": "Initialize a reservation object",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_fini": {
        "description": "Destroys a reservation object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:dma_resv_fini": {
        "description": "Destroys a reservation object.",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_reserve_fences": {
        "description": "Reserve fences for a DMA reservation object.",
        "pre": {
            "obj": "!=null",
            "num_fences": ">=0"
        },
        "post": {
            "return_value": "in [0, -errno]"
        }
    }
},
{
    "kprobe:dma_resv_reserve_fences": {
        "description": "Reserve fences for a DMA reservation object.",
        "pre": {
            "obj": "!=null",
            "num_fences": ">=0"
        }
    }
},
{
    "kretprobe:dma_resv_reset_max_fences": {
        "description": "Reset fences for debugging",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kprobe:dma_resv_reset_max_fences": {
        "description": "Reset fences for debugging",
        "pre": {
            "obj": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_replace_fences": {
        "description": "Replace fences in the dma_resv obj",
        "pre": {
            "obj": "!=null",
            "context": "!=null",
            "replacement": "!=null",
            "usage": "in [DMA_RESV_WRITE, DMA_RESV_READ, DMA_RESV_SHARED]"
        }
    }
},
{
    "kprobe:dma_resv_replace_fences": {
        "description": "Replace fences in the dma_resv obj",
        "pre": {
            "obj": "!=null",
            "context": "!=null",
            "replacement": "!=null",
            "usage": "in [DMA_RESV_USE_NOOP, DMA_RESV_USE_WAIT, DMA_RESV_USE_SIGNAL]"
        }
    }
},
{
    "kretprobe:dma_resv_iter_first_unlocked": {
        "description": "Returns the first fence from an unlocked dma_resv obj.",
        "pre": {
            "cursor": "!=null"
        }
    }
},
{
    "kprobe:dma_resv_iter_first_unlocked": {
        "description": "Returns the first fence from an unlocked dma_resv obj.",
        "pre": {
            "cursor": "!=null",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:dma_resv_copy_fences": {
        "description": "Copy all fences from src to dst.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "dst-lock": "held"
        }
    }
},
{
    "kprobe:dma_resv_copy_fences": {
        "description": "Copy all fences from src to dst.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "dst-lock": "held"
        }
    }
},
{
    "kretprobe:dma_fence_get_stub": {
        "description": "Return a stub fence which is already signaled. The fence's timestamp corresponds to the first time after boot this function is called.",
        "pre": {
            "return_value": "!=null",
            "timestamp": ">= boot_time"
        }
    }
},
{
    "kprobe:dma_fence_get_stub": {
        "description": "Return a stub fence which is already signaled. The fence's timestamp corresponds to the first time after boot this function is called.",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_allocate_private_stub": {
        "description": "Return a newly allocated and signaled stub fence.",
        "pre": {
            "timestamp": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_allocate_private_stub": {
        "description": "Return a private, signaled fence.",
        "pre": {
            "dma_fence_stub": "!=null",
            "dma_fence_stub_lock": "unlocked",
            "dma_fence_get(&dma_fence_stub)": "!=null",
            "timestamp": "valid"
        }
    }
},
S,
S,
{
    "kretprobe:dma_fence_stub_get_name": {
        "description": "This function is used to get the name of a DMA fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_stub_get_name": {
        "description": "Get the name associated with the given DMA fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_signal_timestamp_locked": {
        "description": "Set the timestamp provided as the fence signal timestamp for the given dma_fence.",
        "pre": {
            "fence": "!=null",
            "timestamp": "!=null"
        },
        "post": {
            "return": "in [0, negative error value]"
        }
    }
},
{
    "kprobe:dma_fence_signal_timestamp_locked": {
        "description": "Set the timestamp provided as the fence signal timestamp for the given dma_fence.",
        "pre": {
            "fence": "!=null",
            "timestamp": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:dma_fence_context_alloc": {
        "description": "Allocate an array of fence contexts",
        "pre": {
            "num": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_context_alloc": {
        "description": "Allocate an array of fence contexts.",
        "pre": {
            "num": "!=null",
            "num": "unsigned",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:static_atomic64_t_dma_fence_context_counter": {
        "description": "DMA fences overview",
        "pre": {
            "dma_fence_context_counter": "= ATOMIC64_INIT(1)",
            "dma_fence_stub_lock": "is a spinlock",
            "dma_fence_stub": "is a struct dma_fence",
            "fence_context_counter": "each execution context should have its own fence context",
            "device_contexts": "multiple separate contexts can exist for one device",
            "engine_independence": "some engine can run independently of another"
        }
    }
},
{
    "kprobe:static atomic64_t dma_fence_context_counter = ATOMIC64_INIT(1);/** * DOC: DMA fences overview * * DMA fences, represented by &struct dma_fence, are the kernel internal * synchronization primitive for DMA operations like GPU rendering, video * encoding/decoding, or displaying buffers on a screen. * * A fence is initialized using dma_fence_init() and completed using * dma_fence_signal(). Fences are associated with a context, allocated through * dma_fence_context_alloc(), and all fences on the same context are * fully ordered. * * Since the purposes of fences is to facilitate cross-device and * cross-application synchronization, there's multiple ways to use one: * * - Individual fences can be exposed as a &sync_file, accessed as a file *   descriptor from userspace, created by calling sync_file_create(). This is *   called explicit fencing, since userspace passes around explicit *   synchronization points. * * - Some subsystems also have their own explicit fencing primitives, like *   &drm_syncobj. Compared to &sync_file, a &drm_syncobj allows the underlying *   fence to be updated. * * - Then there's also implicit fencing, where the synchronization points are *   implicitly passed around as part of shared &dma_buf instances. Such *   implicit fences are stored in &struct dma_resv through the *   &dma_buf.resv pointer. ": {
        "description": "fence context counter: each execution context should have its own   fence context, this allows checking if fences belong to the same   context or not. One device can have multiple separate contexts,   and they're used if some engine can run independently of another.",
        "pre": {
            "dma_fence_context_counter": "= ATOMIC64_INIT(1)"
        }
    }
},
{
    "kretprobe:dma_fence_wait_timeout": {
        "description": "Wait for the DMA fence to complete with a timeout.",
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:signed long dma_fence_wait_timeout": {
        "description": "Wait for the given DMA fence to complete with a timeout.",
        "pre": {
            "fence": "!=null",
            "intr": "in [true, false]",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:dma_fence_release": {
        "description": "Default release function for fences",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_release": {
        "description": "Default release function for fences",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_free": {
        "description": "Default release function for dma_fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_free": {
        "description": "Default release function for dma_fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_get_status": {
        "description": "Returns the status upon completion of the dma_fence.",
        "pre": {
            "fence": "!=null"
        },
        "post": {
            "return": "in [0, 1, <negative error code>]"
        }
    }
},
{
    "kprobe:dma_fence_get_status": {
        "description": "Returns the status upon completion of the dma_fence.",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:booldma_fence_remove_callback": {
        "description": "Remove a callback from the signaling list",
        "pre": {
            "fence": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kprobe:booldma_fence_remove_callback": {
        "description": "Remove a callback from the signaling list",
        "pre": {
            "fence": "!=null",
            "cb": "!=null",
            "callback_added": "==true"
        }
    }
},
{
    "kretprobe:dma_fence_set_deadline": {
        "description": "Set desired fence-wait deadline hint.",
        "pre": {
            "fence": "!=null",
            "deadline": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_set_deadline": {
        "description": "Set desired fence-wait deadline hint.",
        "pre": {
            "fence": "!=null",
            "deadline": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_describe": {
        "description": "Dump fence description into seq_file",
        "pre": {
            "fence": "!=null",
            "seq": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_describe": {
        "description": "Dump fence description into seq_file",
        "pre": {
            "fence": "!=null",
            "seq": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_chain_walk": {
        "description": "Chain walking function",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_chain_walk": {
        "description": "Chain walking function",
        "pre": {
            "fence": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_chain_find_seqno": {
        "description": "Find fence chain node by seqno",
        "pre": {
            "pfence": "!=null",
            "seqno": ">=0"
        },
        "post": {
            "pfence": "!=null",
            "seqno": ">=0"
        }
    }
},
{
    "kprobe:dma_fence_chain_find_seqno": {
        "description": "Find fence chain node by seqno",
        "pre": {
            "pfence": "!=null",
            "seqno": ">=0"
        }
    }
},
{
    "kretprobe:dma_fence_chain_init": {
        "description": "Initialize a fence chain",
        "pre": {
            "chain": "!=null",
            "prev": "!=null",
            "fence": "!=null",
            "seqno": ">=0"
        }
    }
},
{
    "kprobe:dma_fence_chain_init": {
        "description": "Initialize a fence chain",
        "pre": {
            "chain": "!=null",
            "prev": "!=null",
            "fence": "!=null",
            "seqno": ">=0"
        }
    }
},
{
    "kretprobe:dma_fence_array_create": {
        "description": "Create a custom fence array",
        "pre": {
            "num_fences": "!=null",
            "fences": "!=null",
            "context": "!=null",
            "seqno": "!=null",
            "signal_on_any": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_array_create": {
        "description": "Create a custom fence array",
        "pre": {
            "num_fences": "!=null",
            "fences": "!=null",
            "context": "!=null",
            "seqno": "!=null",
            "signal_on_any": "!=null"
        }
    }
},
{
    "kretprobe:dma_fence_match_context": {
        "description": "Check if all fences are from the given context",
        "pre": {
            "fence": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:dma_fence_match_context": {
        "description": "Check if all fences are from the given context",
        "pre": {
            "fence": "!=null",
            "context": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:return_0": {
        "description": "Function return value is 0 and doesn't have VID",
        "pre": {
            "return_value": "==0",
            "vid": "==null"
        }
    }
},
{
    "kprobe:vid_which_vrm": {
        "description": "Get the VID (Voltage ID) for the current CPU.",
        "pre": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:sch56xx_read_virtual_reg16": {
        "description": "Reads the virtual register at the given address and register number.",
        "pre": {
            "addr": "!=null",
            "reg": "!=null"
        },
        "post": {
            "lsb": ">= 0",
            "msb": ">= 0",
            "return_value": "lsb | (msb << 8)"
        }
    }
},
{
    "kprobe:sch56xx_read_virtual_reg16": {
        "description": "Reads the virtual register at the given address and register number.",
        "pre": {
            "addr": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:sch56xx_read_virtual_reg12": {
        "description": "Reads the virtual register values from the specified address.",
        "pre": {
            "addr": "!=null",
            "msb_reg": "!=null",
            "lsn_reg": "!=null",
            "high_nibble": "in [0, 1]"
        },
        "post": {
            "return": ">= -32768"
        }
    }
},
{
    "kprobe:sch56xx_read_virtual_reg12": {
        "description": "Reads the virtual register 12 from the sch56xx device.",
        "pre": {
            "addr": "!=null",
            "msb_reg": "!=null",
            "lsn_reg": "!=null",
            "high_nibble": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex.",
        "pre": {
            "io_lock": "!=null"
        }
    },
    "kretprobe:sch56xx_read_virtual_reg": {
        "description": "Reads the value of a virtual register.",
        "pre": {
            "addr": "!=null",
            "SCH56XX_REG_WDOG_CONTROL": "!=null",
            "SCH56XX_REG_WDOG_OUTPUT_ENABLE": "!=null"
        }
    },
    "kretprobe:mutex_unlock": {
        "description": "Unlocks the mutex.",
        "pre": {
            "io_lock": "!=null"
        }
    },
    "kretprobe:control < 0": {
        "description": "Checks if control is less than 0.",
        "pre": {}
    },
    "kretprobe:output_enable < 0": {
        "description": "Checks if output_enable is less than 0.",
        "pre": {}
    },
    "kretprobe:check_enabled && !(output_enable & SCH56XX_WDOG_OUTPUT_ENABLE)": {
        "description": "Checks if check_enabled is true and output_enable does not have SCH56XX_WDOG_OUTPUT_ENABLE flag set.",
        "pre": {}
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex.",
        "pre": {
            "io_lock": "!=null"
        }
    },
    "kprobe:sch56xx_read_virtual_reg": {
        "description": "Reads the value of a virtual register.",
        "pre": {
            "addr": "!=null",
            "reg": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlocks the mutex.",
        "pre": {
            "io_lock": "!=null"
        }
    },
    "kprobe:check_enabled": {
        "description": "Checks if the watchdog is enabled.",
        "pre": {}
    },
    "kprobe:return": {
        "description": "Returns from the function.",
        "pre": {}
    }
},
{
    "kretprobe:thermal_zone_device_critical": {
        "description": "Function to handle critical temperature reached in thermal zone device",
        "pre": {
            "tz": "!=null",
            "poweroff_delay_ms": ">0",
            "forced_emergency_poweroff_work": "scheduled"
        }
    }
},
{
    "kprobe:thermal_zone_device_critical": {
        "description": "Function to handle critical temperature reached in thermal zone device.",
        "pre": {
            "tz": "!=null",
            "poweroff_delay_ms": ">0"
        }
    }
},
{
    "kretprobe:acpi_parse_trt": {
        "description": "Thermal Relationship Table _TRT for passive cooling",
        "pre": {
            "handle": "!=null",
            "trt_count": "!=null",
            "trtp": "!=null",
            "create_dev": "in [true, false]"
        }
    }
},
{
    "kprobe:acpi_parse_trt": {
        "description": "Thermal Relationship Table _TRT for passive cooling",
        "pre": {
            "handle": "!=null",
            "trt_count": "!=null",
            "trtp": "!=null",
            "create_dev": "in [true, false]"
        }
    }
},
{
    "kretprobe:acpi_parse_art": {
        "description": "Parse Active Relationship Table _ART",
        "pre": {
            "handle": "!=null",
            "art_count": "!=null",
            "artp": "!=null",
            "create_dev": "in [true, false]"
        }
    }
},
{
    "kprobe:acpi_parse_art": {
        "description": "Parse Active Relationship Table _ART",
        "pre": {
            "handle": "!=null",
            "art_count": "!=null",
            "artp": "!=null",
            "create_dev": "in [true, false]"
        }
    }
},
{
    "kretprobe:nd_pfn_default_alignment": {
        "description": "This function returns the default alignment for nd_pfn.",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:nd_pfn_default_alignment": {
        "description": "This function returns the default alignment for nd_pfn.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "nd_pfn": "!=null",
            "nd_pfn->mode": "in [PFN_MODE_RAM, PFN_MODE_PMEM, PFN_MODE_NONE]",
            "nd_pfn->align": ">=0",
            "alignments": "!=null",
            "alignments[0]": "==PAGE_SIZE",
            "alignments[1]": "==HPAGE_PMD_SIZE",
            "alignments[2]": "==HPAGE_PUD_SIZE"
        }
    }
},
{
    "kretprobe:nd_pfn_validate": {
        "description": "Read and validate info-block",
        "pre": {
            "nd_pfn": "!=null",
            "sig": "in ['devdax', 'fsdax']"
        }
    }
},
{
    "kprobe:nd_pfn_validate": {
        "description": "Read and validate info-block",
        "pre": {
            "nd_pfn": "!=null",
            "sig": "in ['devdax', 'fsdax']"
        }
    }
},
{
    "kretprobe:nd_pfn->uuid = kmemdup(pfn_sb->uuid, 16, GFP_KERNEL); if (!nd_pfn->uuid) return -ENOMEM; nd_pfn->align = align; nd_pfn->mode = mode;": {
        "description": "Assigns values to nd_pfn->uuid, nd_pfn->align, and nd_pfn->mode.",
        "pre": {
            "pfn_sb->uuid": "!=null",
            "align": "!=null",
            "mode": "!=null"
        },
        "post": {
            "nd_pfn->uuid": "!=null",
            "nd_pfn->align": "align",
            "nd_pfn->mode": "mode"
        },
        "post_condition": "if (nd_pfn->uuid == NULL) return -ENOMEM;"
    }
},
{
    "kprobe:nd_pfn_probe": {
        "description": "Probe function for nd_pfn",
        "pre": {
            "nd_pfn->uuid": "==null",
            "pfn_sb->uuid": "!=null",
            "align": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:pmem_sector_size": {
        "description": "Get the sector size for a persistent memory namespace.",
        "pre": {
            "ndns": {
                "is_namespace_pmem": true,
                "dev": {
                    "nd_namespace_pmem": {
                        "lbasize": {
                            "==": 0,
                            "==": 512
                        }
                    }
                }
            }
        },
        "post": {
            "return": {
                "==": 4096
            }
        }
    }
},
S,
{
    "kretprobe:nvdimm_namespace_common_probe": {
        "description": "Probe the nvdimm namespace common",
        "pre": {
            "dev": "!=null",
            "nd_btt": "is_nd_btt(dev) ? to_nd_btt(dev) : null",
            "nd_pfn": "is_nd_pfn(dev) ? to_nd_pfn(dev) : null",
            "nd_dax": "is_nd_dax(dev) ? to_nd_dax(dev) : null",
            "ndns": "!=null",
            "ndns_condition": "(nd_btt || nd_pfn || nd_dax) && !ndns",
            "return_value": "-ENODEV"
        }
    }
},
{
    "kprobe:device_lock_device_unlock_if_ndns_dev_driver": {
        "description": "Lock and unlock the device, and check if the driver is present.",
        "pre": {
            "dev": "!=null",
            "dev.driver": "!=null"
        }
    }
},
{
    "kretprobe:nd_region_to_nstype": {
        "description": "Converts a region to an integer namespace type",
        "pre": {
            "nd_region": "!=null"
        }
    }
},
{
    "kprobe:nd_region_to_nstype": {
        "description": "Region to an integer namespace type",
        "pre": {
            "nd_region": "!=null"
        }
    }
},
{
    "kretprobe:nd_region_acquire_lane": {
        "description": "allocate and lock a lane",
        "pre": {
            "nd_region": "!=null"
        }
    }
},
{
    "kprobe:nd_region_acquire_lane": {
        "description": "Allocate and lock a lane",
        "pre": {
            "nd_region": "!=null"
        }
    }
},
{
    "kretprobe:nd_device_register": {
        "description": "Ensure that region devices always have their NUMA node set as early as possible.",
        "pre": {
            "dev": "!=null",
            "sync": "bool"
        }
    }
},
{
    "kprobe:nd_device_register": {
        "description": "Ensure that region devices always have their NUMA node set as early as possible.",
        "pre": {
            "dev": "!=null",
            "sync": "bool"
        }
    }
},
{
    "kretprobe:dev_set_drvdata": {
        "description": "Set the driver-specific data for the given device.",
        "pre": {
            "dev": "!=null",
            "nvdimm_bus->nd_desc": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:dev_set_drvdata": {
        "description": "Set the driver-specific data for the given device.",
        "pre": {
            "dev": "!=null",
            "nvdimm_bus->nd_desc": "!=null"
        }
    }
},
{
    "kretprobe:__nd_driver_register": {
        "description": "Register a region or a namespace driver",
        "pre": {
            "nd_drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kprobe:__nd_driver_register": {
        "description": "Register a region or a namespace driver",
        "pre": {
            "nd_drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kretprobe:nvdimm_check_and_set_ro": {
        "description": "Catch the disk up with the region ro state",
        "pre": {
            "disk_ro": "== nd_region->ro"
        },
        "post": {
            "dev": "!= null",
            "nd_region": "!= null",
            "disk": "!= null",
            "dev_name(&nd_region->dev)": "!= null",
            "nd_region->ro": "in [true, false]",
            "disk->disk_name": "!= null",
            "set_disk_ro(disk, nd_region->ro)": "executed"
        }
    }
},
{
    "kprobe:nvdimm_check_and_set_ro": {
        "description": "Catch the disk up with the region ro state.",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "nd_region": "!=null",
            "disk_ro": "!=null"
        }
    }
},
{
    "kretprobe:nd_sb_checksum": {
        "description": "compute checksum for a generic info block. Returns a fletcher64 checksum of everything in the given info block except the last field (since that's where the checksum lives).",
        "pre": {
            "nd_gen_sb": "!=null",
            "nd_gen_sb.field1": "!=null",
            "nd_gen_sb.field2": "!=null",
            "nd_gen_sb.field3": "!=null",
            ...
            "nd_gen_sb.fieldN-1": "!=null"
        }
    }
},
{
    "kprobe:nd_sb_checksum": {
        "description": "Compute checksum for a generic info block",
        "pre": {
            "nd_gen_sb": "!=null"
        }
    }
},
{
    "kretprobe:nd_btt_version": {
        "description": "This function is used to determine the version of nd_btt.",
        "pre": {
            "nd_btt": "!=null",
            "ndns": "!=null",
            "btt_sb": "!=null",
            "nd_btt->uuid": "!=null",
            "nd_btt->ndns": "!=null",
            "nd_btt->lbasize": "!=null",
            "size": ">= nd_btt->initial_offset",
            "rawsize": "< ARENA_MIN_SIZE"
        }
    }
},
{
    "kprobe:nd_btt_version": {
        "description": "Version the nd_btt structure based on the holder class",
        "pre": {
            "nd_btt": {
                "uuid": "!=null",
                "ndns": "!=null",
                "lbasize": "!=null"
            },
            "btt_sb": "!=null",
            "size": ">= 0",
            "rawsize": ">= ARENA_MIN_SIZE"
        }
    }
},
{
    "kretprobe:rc = -ENXIO;}device_unlock(dev);return rc;}static DEVICE_ATTR_RO(size);static ssize_t log_zero_flags_show(struct device *dev,struct device_attribute *attr, char *buf)": {
        "description": "This function is used to show the log zero flags.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        },
        "post": {
            "rc": "-ENXIO",
            "dev": "unlocked"
        }
    }
},
S,
{
    "kretprobe:nd_btt_arena_is_valid": {
        "description": "Check if the metadata layout is valid",
        "pre": {
            "nd_btt": "!=null",
            "super": "!=null"
        }
    }
},
{
    "kprobe:nd_btt_arena_is_valid": {
        "description": "Check if the metadata layout is valid",
        "pre": {
            "nd_btt": "!=null",
            "super": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ssb_pcicore_dev_irqvecs_enable": {
        "description": "Enable interrupts for the given SSB device on a PCI host-bus.",
        "pre": {
            "pc": "!=null",
            "dev": "!=null",
            "pdev": "!=null",
            "bus": "!=null",
            "err": "int",
            "tmp": "u32",
            "dev->bus->bustype": "==SSB_BUSTYPE_PCI"
        }
    }
},
{
    "kprobe:ssb_pcicore_dev_irqvecs_enable": {
        "description": "Enable interrupts for the given SSB device on a PCI host-bus.",
        "pre": {
            "pc": "!=null",
            "dev": "!=null",
            "pc->dev": "!=null",
            "dev->bus->bustype": "==SSB_BUSTYPE_PCI"
        }
    }
},
{
    "kretprobe:bus->mapped_device": {
        "description": "Set bus->mapped_device to NULL.",
        "pre": {
            "bus": "!=null"
        }
    },
    "kretprobe:bus->pcicore.setup_done": {
        "description": "Set bus->pcicore.setup_done to 0.",
        "pre": {
            "bus": "!=null",
            "#ifdef CONFIG_SSB_DRIVER_PCICORE": "true"
        }
    },
    "kretprobe:ssb_bus_powerup": {
        "description": "Power up the SSB bus.",
        "pre": {
            "bus": "!=null",
            "arg1": "0"
        }
    },
    "kretprobe:ssb_pcmcia_hardware_setup": {
        "description": "Setup the PCMCIA hardware for the SSB bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:bus->mapped_device": {
        "description": "Set bus->mapped_device to NULL.",
        "pre": {
            "bus": "!=null"
        }
    },
    "kprobe:bus->pcicore.setup_done": {
        "description": "Set bus->pcicore.setup_done to 0.",
        "pre": {
            "bus": "!=null",
            "#ifdef CONFIG_SSB_DRIVER_PCICORE": "true"
        }
    },
    "kprobe:ssb_bus_powerup": {
        "description": "Power up the SSB bus.",
        "pre": {
            "bus": "!=null",
            "err": "!=null"
        }
    },
    "kprobe:ssb_pcmcia_hardware_setup": {
        "description": "Setup the PCMCIA hardware for the SSB bus.",
        "pre": {
            "bus": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kretprobe:ssb_clockspeed": {
        "description": "Calculate the clock speed for the ssb_bus.",
        "pre": {
            "bus": "!=null",
            "bus->chipco.capabilities": "& SSB_CHIPCO_CAP_PMU == 0",
            "bus->extif_available(&bus->extif)": "==true",
            "bus->chipco.dev": "!=null",
            "bus->chip_id": "==0x5365",
            "plltype": "in [SSB_PLLTYPE_0, SSB_PLLTYPE_1, SSB_PLLTYPE_2, SSB_PLLTYPE_3]",
            "clkctl_n": "!=null",
            "clkctl_m": "!=null"
        }
    }
},
{
    "kprobe:ssb_clockspeed": {
        "description": "Calculate the clock speed for the ssb_bus.",
        "pre": {
            "bus": "!=null",
            "bus->chipco.capabilities": "& SSB_CHIPCO_CAP_PMU == 0",
            "bus->extif_available(&bus->extif)": "==true",
            "bus->chipco.dev": "!=null",
            "bus->chip_id": "==0x5365",
            "rate": "!=null",
            "plltype": "!=null",
            "clkctl_n": "!=null",
            "clkctl_m": "!=null",
            "plltype": "==SSB_PLLTYPE_3"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check if the condition is true",
        "pre": {
            "ssb_read32(dev, SSB_TMSHIGH) & SSB_TMSHIGH_SERR": "== 1",
            "ssb_read32(dev, SSB_IMSTATE) & (SSB_IMSTATE_IBE | SSB_IMSTATE_TO)": "!= 0"
        }
    }
},
S,
{
    "kretprobe:ssb_devices_freeze": {
        "description": "Freeze all devices on the bus. After freezing, no device driver will be handling a device on this bus anymore. ssb_devices_thaw() must be called after a successful freeze to reactivate the devices.",
        "pre": {
            "bus": "!=null",
            "ctx": "!=null"
        }
    }
},
{
    "kprobe:ssb_devices_freeze": {
        "description": "Freeze all devices on the bus. After freezing, no device driver will be handling a device on this bus anymore. ssb_devices_thaw() must be called after a successful freeze to reactivate the devices.",
        "pre": {
            "bus": "!=null",
            "ctx": "!=null"
        }
    }
},
{
    "kretprobe:ssb_broadcast_value": {
        "description": "Broadcast a value to all devices on the SSB bus.",
        "pre": {
            "dev": "!=null",
            "value": "==0xFD8",
            "flags": "==0",
            "bus": "!=null",
            "bus->chipco.dev": "!=null",
            "bus->pcicore.dev": "!=null",
            "dev == bus->chipco.dev || dev == bus->pcicore.dev": "==true"
        }
    },
    "kretprobe:ssb_commit_settings": {
        "description": "Commit settings for the SSB bus.",
        "pre": {
            "bus": "!=null",
            "bus->chipco.dev": "!=null",
            "bus->pcicore.dev": "!=null",
            "dev": "!=null",
            "dev == bus->chipco.dev || dev == bus->pcicore.dev": "==true"
        }
    }
},
{
    "kprobe:ssb_broadcast_value": {
        "description": "Broadcast a value to all devices on the SSB bus.",
        "pre": {
            "dev": "!=null",
            "value": "==0xFD8"
        }
    },
    "kprobe:ssb_commit_settings": {
        "description": "Forces an update of the cached registers.",
        "pre": {
            "bus": "!=null",
            "dev": "!=null"
        }
    }
},
S,
S,
S,
{
    "kprobe:size = ((adm & SSB_ADM_SZ1) >> SSB_ADM_SZ1_SHIFT);break;case SSB_ADM_TYPE2:WARN_ON(adm & SSB_ADM_NEG); /* unsupported": {
        "description": "The given function performs a switch case based on the value of adm & SSB_ADM_TYPE. It calculates the size based on the value of adm & SSB_ADM_SZ1 and SSB_ADM_SZ1_SHIFT. It also checks for the presence of SSB_ADM_NEG flag and throws a warning if it is set.",
        "pre": {
            "adm": "!=null",
            "SSB_ADM_SZ1": "!=null",
            "SSB_ADM_SZ1_SHIFT": "!=null",
            "SSB_ADM_TYPE": "in [SSB_ADM_TYPE0, SSB_ADM_TYPE1, SSB_ADM_TYPE2]",
            "SSB_ADM_NEG": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sparse_keymap_entry_from_scancode": {
        "description": "Perform sparse keymap lookup",
        "pre": {
            "dev": "!=null",
            "code": "!=null"
        }
    }
},
{
    "kprobe:sparse_keymap_entry_from_scancode": {
        "description": "Perform sparse keymap lookup",
        "pre": {
            "dev": "!=null",
            "code": "!=null"
        }
    }
},
{
    "kretprobe:sparse_keymap_entry_from_keycode": {
        "description": "Perform sparse keymap lookup",
        "pre": {
            "dev": "!=null",
            "keycode": "!=null"
        }
    }
},
{
    "kprobe:sparse_keymap_entry_from_keycode": {
        "description": "Perform sparse keymap lookup",
        "pre": {
            "dev": "!=null",
            "keycode": "!=null"
        }
    }
},
{
    "kretprobe:sparse_keymap_setup": {
        "description": "Set up sparse keymap for an input device",
        "pre": {
            "dev": "!=null",
            "keymap": "!=null",
            "setup": "!=null"
        }
    }
},
{
    "sparse_keymap_setup": {
        "description": "Set up sparse keymap for an input device.",
        "pre": {
            "dev": "any",
            "keymap": "any",
            "setup": "any"
        }
    }
},
{
    "kretprobe:sparse_keymap_report_entry": {
        "description": "Report event corresponding to given key entry",
        "pre": {
            "dev": "!=null",
            "ke": "!=null",
            "value": "!=null",
            "autorelease": "in [true, false]"
        }
    }
},
{
    "kprobe:sparse_keymap_report_entry": {
        "description": "Report event corresponding to given key entry",
        "pre": {
            "dev": "!=null",
            "ke": "!=null",
            "value": "!=null",
            "autorelease": "is boolean"
        }
    }
},
{
    "kretprobe:sparse_keymap_report_event": {
        "description": "Report event corresponding to given scancode",
        "pre": {
            "dev": "!=null",
            "code": "!=null",
            "value": "!=null",
            "autorelease": "in [true, false]"
        }
    }
},
{
    "kprobe:sparse_keymap_report_event": {
        "description": "Report event corresponding to given scancode",
        "pre": {
            "dev": "!=null",
            "code": "!=null",
            "value": "!=null",
            "autorelease": "in [true, false]"
        }
    }
},
{
    "kretprobe:matrix_keypad_build_keymap": {
        "description": "Convert platform keymap into matrix keymap",
        "pre": {
            "keymap_data": "!=null",
            "keymap_name": "!=null",
            "rows": "!=null",
            "cols": "!=null",
            "keymap": "!=null",
            "input_dev": "!=null"
        }
    }
},
{
    "kprobe:matrix_keypad_build_keymap": {
        "description": "Convert platform keymap into matrix keymap",
        "pre": {
            "keymap_data": "!=null",
            "keymap_name": "!=null",
            "rows": "!=null",
            "cols": "!=null",
            "keymap": "!=null",
            "input_dev": "!=null"
        }
    }
},
{
    "kretprobe:touchscreen_parse_properties": {
        "description": "Parse common touchscreen properties",
        "pre": {
            "input": "!=null",
            "multitouch": "in [true, false]",
            "prop": "!=null"
        }
    }
},
{
    "kprobe:touchscreen_parse_properties": {
        "description": "Parse common touchscreen properties",
        "pre": {
            "input": "!=null",
            "multitouch": "in [true, false]",
            "prop": "!=null"
        }
    }
},
{
    "kretprobe:touchscreen_set_mt_pos": {
        "description": "Set input_mt_pos coordinates",
        "pre": {
            "pos": "!=null",
            "prop": "!=null",
            "x": "!=null",
            "y": "!=null"
        }
    }
},
{
    "kprobe:touchscreen_set_mt_pos": {
        "description": "Set input_mt_pos coordinates",
        "pre": {
            "pos": "!=null",
            "prop": "!=null",
            "x": "!=null",
            "y": "!=null"
        }
    }
},
{
    "kretprobe:touchscreen_report_pos": {
        "description": "Report touchscreen coordinates",
        "pre": {
            "input": "!=null",
            "prop": "!=null",
            "x": "!=null",
            "y": "!=null",
            "multitouch": "in [true, false]"
        }
    }
},
{
    "kprobe:touchscreen_report_pos": {
        "description": "Report touchscreen coordinates",
        "pre": {
            "input": "!=null",
            "prop": "!=null",
            "x": "!=null",
            "y": "!=null",
            "multitouch": "in [true, false]"
        }
    }
},
{
    "kretprobe:input_mt_init_slots": {
        "description": "Initialize MT input slots",
        "pre": {
            "dev": "!=null",
            "num_slots": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:input_mt_init_slots": {
        "description": "Initialize MT input slots",
        "pre": {
            "dev": "!=null",
            "num_slots": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:input_mt_destroy_slots": {
        "description": "Frees the MT slots of the input device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:input_mt_destroy_slots": {
        "description": "Frees the MT slots of the input device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:input_mt_report_slot_state": {
        "description": "Reports a contact via ABS_MT_TRACKING_ID, and optionally ABS_MT_TOOL_TYPE.",
        "pre": {
            "dev": "!=null",
            "tool_type": "unsigned int",
            "active": "bool"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kprobe:input_mt_report_slot_state": {
        "description": "Reports a contact state",
        "pre": {
            "dev": "!=null",
            "tool_type": "!=null",
            "active": "!=null"
        }
    }
},
{
    "kretprobe:input_mt_report_finger_count": {
        "description": "Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP.",
        "pre": {
            "dev": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:input_mt_report_finger_count": {
        "description": "Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP.",
        "pre": {
            "dev": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:input_mt_report_pointer_emulation": {
        "description": "Performs legacy pointer emulation via BTN_TOUCH, ABS_X, ABS_Y and ABS_PRESSURE. Touchpad finger count is emulated if use_count is true.",
        "pre": {
            "dev": "!=null",
            "use_count": "bool"
        }
    }
},
{
    "kprobe:input_mt_report_pointer_emulation": {
        "description": "Common pointer emulation",
        "pre": {
            "dev": "!=null",
            "use_count": "bool"
        }
    }
},
{
    "kretprobe:input_mt_drop_unused": {
        "description": "Inactivate slots not seen in this frame",
        "pre": {
            "dev": "!=null",
            "mt": "!=null",
            "i": ">=0",
            "i": "< mt->num_slots",
            "input_mt_is_active(&mt->slots[i])": "==true",
            "!input_mt_is_used(mt, &mt->slots[i])": "==true"
        }
    }
},
{
    "kprobe:input_mt_drop_unused": {
        "description": "Inactivate slots not seen in this frame",
        "pre": {
            "dev": "!=null",
            "mt": "!=null",
            "dev->event_lock": "held",
            "mt->num_slots": ">0",
            "i": ">=0",
            "i": "<mt->num_slots",
            "input_mt_is_active(&mt->slots[i])": "true",
            "!input_mt_is_used(mt, &mt->slots[i])": "true"
        },
        "post": {
            "input_handle_event(dev, EV_ABS, ABS_MT_SLOT, i)": "called",
            "input_handle_event(dev, EV_ABS, ABS_MT_TRACKING_ID, -1)": "called"
        }
    }
},
{
    "kretprobe:input_mt_sync_frame": {
        "description": "Synchronize mt frame",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:input_mt_sync_frame": {
        "description": "Synchronize mt frame",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:input_mt_assign_slots": {
        "description": "Perform a best-match assignment",
        "pre": {
            "dev": "!=null",
            "slots": "!=null",
            "pos": "!=null",
            "num_pos": ">=0",
            "dmax": ">=0"
        }
    }
},
{
    "kprobe:input_mt_assign_slots": {
        "description": "Perform a best-match assignment",
        "pre": {
            "dev": "!=null",
            "slots": "!=null",
            "pos": "!=null",
            "num_pos": ">=0",
            "dmax": ">=0"
        }
    }
},
{
    "kretprobe:input_mt_get_slot_by_key": {
        "description": "Return slot matching key",
        "pre": {
            "dev": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:input_mt_get_slot_by_key": {
        "description": "Return slot matching key",
        "pre": {
            "dev": "!=null",
            "key": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:dev->timestamp[INPUT_CLK_MONO] = ktime_set(0, 0);} else if (dev->num_vals >= dev->max_vals - 2)": {
        "description": "Set the timestamp of dev->timestamp[INPUT_CLK_MONO] to the value returned by ktime_set(0, 0). If dev->num_vals is greater than or equal to dev->max_vals - 2, perform additional actions.",
        "pre": {
            "dev->timestamp[INPUT_CLK_MONO]": "= ktime_set(0, 0)",
            "dev->num_vals": ">= dev->max_vals - 2",
            "disposition & INPUT_PASS_TO_DEVICE": "true",
            "dev->event": "!= null",
            "dev->vals": "!= null",
            "disposition & INPUT_PASS_TO_HANDLERS": "true",
            "disposition & INPUT_SLOT": "true",
            "dev->vals[dev->num_vals++]": {
                "type": "EV_ABS",
                "code": "ABS_MT_SLOT",
                "value": "dev->mt->slot"
            },
            "dev->vals[dev->num_vals++]": {
                "type": "type",
                "code": "code",
                "value": "value"
            },
            "disposition & INPUT_FLUSH": "true",
            "dev->num_vals": ">= 2"
        },
        "post": {
            "dev->num_vals": "= 0"
        }
    }
},
{
    "kprobe:dev->timestamp[INPUT_CLK_MONO] = ktime_set(0, 0);} else if (dev->num_vals >= dev->max_vals - 2)": {
        "description": "Set the timestamp of dev->timestamp[INPUT_CLK_MONO] to ktime_set(0, 0) if dev->num_vals is greater than or equal to dev->max_vals - 2.",
        "pre": {
            "dev": "!=null",
            "disposition": "any",
            "type": "any",
            "code": "any",
            "value": "any"
        }
    }
},
{
    "kretprobe:input_event": {
        "description": "Seed the initial state of a switch or the initial position of an absolute axis.",
        "pre": {
            "dev": "!=null",
            "type": "!=null",
            "code": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:input_event": {
        "description": "Invoked to 'seed' initial state of a switch or initial position of absolute axis.",
        "pre": {
            "dev": "!=null",
            "type": "!=null",
            "code": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:input_alloc_absinfo": {
        "description": "Allocates array of input_absinfo structs",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:input_alloc_absinfo": {
        "description": "Allocates array of input_absinfo structs",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:input_copy_abs": {
        "description": "Copy absinfo from one input_dev to another",
        "pre": {
            "dst": "!=null",
            "dst_axis": "!=null",
            "src": "!=null",
            "src_axis": "!=null"
        }
    }
},
{
    "kprobe:input_copy_abs": {
        "description": "Copy absinfo from one input_dev to another",
        "pre": {
            "dst": "!=null",
            "dst_axis": "!=null",
            "src": "!=null",
            "src_axis": "!=null"
        }
    }
},
{
    "kretprobe:input_grab_device": {
        "description": "grabs device for exclusive use",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:input_grab_device": {
        "description": "Grabs device for exclusive use",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:synchronize_rcu": {
        "description": "Release previously grabbed device and synchronize device state with the rest of the system.",
        "pre": {
            "handle": "!=null",
            "dev": "!=null",
            "grabber": "!=null",
            "lockdep_is_held(&dev->mutex)": "true",
            "grabber == handle": "true",
            "dev->grab": "null"
        },
        "post": {
            "handle->open": "true",
            "handle->handler->start": "true",
            "handle->handler->start(handle)": "true"
        }
    }
},
{
    "kprobe:synchronize_rcu": {
        "description": "Release previously grabbed device and synchronize device state with the rest of the system.",
        "pre": {
            "handle": "!=null",
            "dev": "!=null",
            "dev->grab": "==handle",
            "dev->mutex": "held",
            "handle->open": "==true",
            "handle->handler->start": "!=null"
        }
    }
},
{
    "kretprobe:input_open_device": {
        "description": "Open input device",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:input_open_device": {
        "description": "Open input device",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:input_close_device": {
        "description": "Close input device",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:input_close_device": {
        "description": "Close input device",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:input_scancode_to_scalar": {
        "description": "Converts scancode in struct input_keymap_entry into scalar form understood by legacy keymap handling methods.",
        "pre": {
            "ke": "!=null",
            "scancode": "!=null"
        }
    }
},
{
    "kprobe:input_scancode_to_scalar": {
        "description": "Converts scancode in struct input_keymap_entry into scalar form understood by legacy keymap handling methods.",
        "pre": {
            "ke": "!=null",
            "scancode": "!=null"
        }
    }
},
{
    "kretprobe:input_get_keycode": {
        "description": "Retrieve keycode currently mapped to a given scancode",
        "pre": {
            "dev": "!=null",
            "ke": "!=null"
        }
    }
},
{
    "kprobe:input_get_keycode": {
        "description": "Retrieve keycode currently mapped to a given scancode",
        "pre": {
            "dev": "!=null",
            "ke": "!=null"
        }
    }
},
{
    "kretprobe:input_set_keycode": {
        "description": "Attribute a keycode to a given scancode",
        "pre": {
            "dev": "!=null",
            "ke": "!=null"
        }
    }
},
{
    "kprobe:input_set_keycode": {
        "description": "Attribute a keycode to a given scancode",
        "pre": {
            "dev": "!=null",
            "ke": "!=null"
        }
    }
},
{
    "kretprobe:input_reset_device": {
        "description": "Reset and restore the state of an input device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:input_reset_device": {
        "description": "Reset and restore the state of an input device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:devm_input_allocate_device": {
        "description": "Allocate managed input device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:devm_input_allocate_device": {
        "description": "Allocate managed input device",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:input_set_timestamp": {
        "description": "Set timestamp for input events",
        "pre": {
            "dev": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kprobe:input_set_timestamp": {
        "description": "Set timestamp for input events",
        "pre": {
            "dev": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kretprobe:input_get_timestamp": {
        "description": "Get timestamp for input events",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "!=null",
            "return_value_value": "!=0"
        }
    }
},
{
    "kprobe:input_get_timestamp": {
        "description": "Get timestamp for input events",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:input_enable_softrepeat": {
        "description": "Enable software autorepeat on the input device.",
        "pre": {
            "dev": "!=null",
            "delay": ">=0",
            "period": ">=0"
        }
    }
},
{
    "kprobe:input_enable_softrepeat": {
        "description": "Enable software autorepeat on the input device.",
        "pre": {
            "dev": "!=null",
            "delay": ">=0",
            "period": ">=0"
        }
    }
},
{
    "kretprobe:input_register_handler": {
        "description": "Register a new input handler",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kprobe:input_register_handler": {
        "description": "Register a new input handler",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kretprobe:input_unregister_handler": {
        "description": "Unregisters an input handler",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kprobe:input_unregister_handler": {
        "description": "Unregisters an input handler",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kretprobe:input_handler_for_each_handle": {
        "description": "Iterate over input handler's list of devices and call a function for each handle.",
        "pre": {
            "handler": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:input_handler_for_each_handle": {
        "description": "Handle iterator for input handler",
        "pre": {
            "handler": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:input_get_new_minor": {
        "description": "Allocates a new input minor number",
        "pre": {
            "legacy_base": "!=null",
            "legacy_num": "!=null",
            "allow_dynamic": "!=null"
        }
    }
},
{
    "kprobe:input_get_new_minor": {
        "description": "Allocates a new input minor number.",
        "pre": {
            "legacy_base": "!=null",
            "legacy_num": "!=null",
            "allow_dynamic": "!=null"
        }
    }
},
{
    "kretprobe:input_free_minor": {
        "description": "Release previously allocated minor",
        "pre": {
            "minor": "!=null"
        }
    }
},
{
    "kprobe:input_free_minor": {
        "description": "Release previously allocated minor",
        "pre": {
            "minor": "!=null"
        }
    }
},
{
    "kretprobe:ps2_sendbyte": {
        "description": "Sends a byte to the device and waits for acknowledgement.",
        "pre": {
            "ps2dev": "!=null",
            "byte": "!=null",
            "timeout": "!=null"
        }
    }
},
{
    "kprobe:ps2_sendbyte": {
        "description": "Sends a byte to the device and waits for acknowledgement.",
        "pre": {
            "ps2dev": "!=null",
            "byte": "!=null",
            "timeout": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ps2_drain": {
        "description": "Waits for device to transmit requested number of bytes and discards them.",
        "pre": {
            "ps2dev": "!=null",
            "maxbytes": ">=0",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:ps2_drain": {
        "description": "Waits for device to transmit requested number of bytes and discards them.",
        "pre": {
            "ps2dev": "!=null",
            "maxbytes": ">=0",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:ps2_is_keyboard_id": {
        "description": "Checks received ID byte against the list of known keyboard IDs.",
        "pre": {
            "id_byte": "!=null"
        }
    }
},
{
    "kprobe:ps2_is_keyboard_id": {
        "description": "Checks received ID byte against the list of known keyboard IDs.",
        "pre": {
            "id_byte": "!=null",
            "id_byte": "is in [known_keyboard_ids]"
        }
    }
},
{
    "kretprobe:__ps2_command": {
        "description": "Send a command to PS2 device",
        "pre": {
            "ps2dev": "!=null",
            "param": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kprobe:__ps2_command": {
        "description": "Send a command to PS2 device",
        "pre": {
            "ps2dev": "!=null",
            "param": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kretprobe:ps2_sliced_command": {
        "description": "sends an extended PS2 command to a mouse",
        "pre": {
            "ps2dev": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kprobe:ps2_sliced_command": {
        "description": "Sends an extended PS2 command to a mouse.",
        "pre": {
            "ps2dev": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kretprobe:ps2_init": {
        "description": "Initializes ps2dev structure",
        "pre": {
            "ps2dev": "!=null",
            "serio": "!=null",
            "pre_receive_handler": "!=null",
            "receive_handler": "!=null"
        }
    }
},
{
    "kprobe:ps2_init": {
        "description": "Initializes ps2dev structure",
        "pre": {
            "ps2dev": "!=null",
            "serio": "!=null",
            "pre_receive_handler": "!=null",
            "receive_handler": "!=null"
        }
    }
},
{
    "kretprobe:ps2_interrupt": {
        "description": "Common interrupt handler for PS2 devices",
        "pre": {
            "serio": "!=null",
            "data": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ps2_interrupt": {
        "description": "Common interrupt handler for PS2 devices.",
        "pre": {
            "serio": "!=null",
            "data": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:serio_bind_driver": {
        "description": "Bind a driver to a serio device.",
        "pre": {
            "serio": "!=null",
            "drv": "!=null"
        }
    }
},
{
    "kprobe:serio_bind_driver": {
        "description": "Bind a driver to a serio device.",
        "pre": {
            "serio": "!=null",
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:__serio_register_driver": {
        "description": "Register a serio driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null",
            "drv->manual_bind": "==true",
            "error": "not in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        }
    }
},
S,
{
    "kretprobe:serio_remove_pending_events": {
        "description": "Remove pending events for the serio driver and start over.",
        "pre": {
            "drv": "!=null",
            "serio_mutex": "locked",
            "drv.manual_bind": "==true"
        }
    }
},
{
    "kprobe:serio_remove_pending_events": {
        "description": "Remove any pending events for the given serio driver.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:serio_init_port": {
        "description": "Prepare serio port for registration.",
        "pre": {
            "serio": "!=null"
        }
    }
},
{
    "kprobe:serio_init_port": {
        "description": "Prepare serio port for registration.",
        "pre": {
            "serio": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:rmi_unregister_transport_device": {
        "description": "Unregister a transport device connection",
        "pre": {
            "xport": "!=null"
        }
    }
},
{
    "kprobe:rmi_unregister_transport_device": {
        "description": "Unregister a transport device connection",
        "pre": {
            "xport": "!=null"
        }
    }
},
{
    "kretprobe:cma3000_init": {
        "description": "Initialize the cma3000 device.",
        "pre": {
            "dev": "!=null",
            "irq": "==0",
            "bops": "!=null",
            "pdata": "!=null",
            "data": "!=null",
            "input_dev": "!=null",
            "rev": "!=null",
            "error": "!=null"
        }
    }
},
{
    "kprobe:cma3000_init": {
        "description": "Initialize the cma3000 device.",
        "pre": {
            "dev": "!=null",
            "irq": "==0",
            "bops": "!=null",
            "pdata": "!=null",
            "data": "!=null",
            "input_dev": "!=null",
            "rev": "!=null",
            "error": "!=null"
        }
    }
},
{
    "kretprobe:ad714x_hw_init": {
        "description": "Initialize the ad714x hardware.",
        "pre": {
            "dev": "!=null",
            "bus_type": "is an integer",
            "irq": "is an integer",
            "read": "!=null",
            "write": "!=null",
            "plat_data": "!=null",
            "slider_num": "is an integer",
            "wheel_num": "is an integer",
            "touchpad_num": "is an integer",
            "button_num": "is an integer"
        }
    }
},
{
    "kprobe:ad714x_hw_init": {
        "description": "Initialize the ad714x hardware.",
        "pre": {
            "ad714x": "!=null",
            "dev": "!=null",
            "irq": ">0"
        }
    }
},
{
    "kretprobe:drv->ignore = true": {
        "description": "Set drv->ignore to true.",
        "pre": {
            "drv": "!=null"
        }
    },
    "kretprobe:error = driver_register(&drv->driver)": {
        "description": "Call driver_register() function and assign the return value to error.",
        "pre": {
            "drv": "!=null",
            "drv->driver": "!=null",
            "error": "!=null"
        }
    },
    "kretprobe:if (error)": {
        "description": "Check if error is non-zero.",
        "pre": {
            "error": "!=0"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:iforce_send_packet": {
        "description": "Copy data to buffer",
        "pre": {
            "iforce": "!=null",
            "cmd": "!=null",
            "cmd": ">=0", // Assuming cmd is an unsigned integer
            "data": "!=null"
        }
    }
},
S,
{
    "kretprobe:input_report_abs": {
        "description": "Reports absolute input values to the device.",
        "pre": {
            "dev": "!=null",
            "ABS_X": "!=null",
            "data": "!=null",
            "ABS_Y": "!=null",
            "ABS_THROTTLE": "!=null",
            "len": ">=8",
            "ABS_RUDDER": "if test_bit(ABS_RUDDER, dev->absbit)",
            "iforce": "!=null"
        }
    },
    "kretprobe:iforce_report_hats_buttons": {
        "description": "Reports hat and button input values to the iforce device.",
        "pre": {
            "iforce": "!=null",
            "data": "!=null"
        }
    },
    "kretprobe:input_sync": {
        "description": "Synchronizes input events with the device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:input_report_abs": {
        "description": "Report absolute input event",
        "pre": {
            "dev": "!=null",
            "type": "in [ABS_X, ABS_Y, ABS_THROTTLE, ABS_RUDDER]",
            "value": "!=null"
        }
    },
    "kprobe:input_sync": {
        "description": "Synchronize input events",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:iforce_report_hats_buttons": {
        "description": "Report hats and buttons input event",
        "pre": {
            "iforce": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:input_dev->id.bustype = bustype;input_dev->dev.parent = parent;input_set_drvdata(input_dev, iforce);input_dev->name = \"Unknown I-Force device\";input_dev->open = iforce_open;input_dev->close = iforce_close;/* * On-device memory allocation. `": {
        "description": "Initialize the I-Force input device and allocate on-device memory.",
        "pre": {
            "parent": "!=null",
            "bustype": "!=null",
            "iforce": "!=null",
            "input_dev": "!=null",
            "input_dev->id.bustype": "==bustype",
            "input_dev->dev.parent": "==parent",
            "input_dev->name": "==\"Unknown I-Force device\"",
            "input_dev->open": "==iforce_open",
            "input_dev->close": "==iforce_close"
        }
    }
},
{
    "kprobe:input_dev->id.bustype = bustype;input_dev->dev.parent = parent;input_set_drvdata(input_dev, iforce);input_dev->name = \"Unknown I-Force device\";input_dev->open = iforce_open;input_dev->close = iforce_close;/* * On-device memory allocation. `": {
        "description": "Initialize the I-Force device",
        "pre": {
            "input_dev": "!=null",
            "bustype": "!=null",
            "parent": "!=null",
            "iforce": "!=null",
            "input_dev->name": "==\"Unknown I-Force device\"",
            "input_dev->open": "==iforce_open",
            "input_dev->close": "==iforce_close"
        }
    }
},
{
    "kretprobe:br->levels = kmalloc_array(obj->package.count + ACPI_VIDEO_FIRST_LEVEL, sizeof(*br->levels), GFP_KERNEL);if (!br->levels)": {
        "description": "Allocate memory for br->levels array and check if allocation was successful.",
        "pre": {
            "obj": "!=null",
            "obj->package.count": ">= ACPI_VIDEO_FIRST_LEVEL",
            "br": "!=null",
            "br->levels": "==null"
        }
    }
},
{
    "kprobe:br->levels = kmalloc_array(obj->package.count + ACPI_VIDEO_FIRST_LEVEL, sizeof(*br->levels), GFP_KERNEL);if (!br->levels)": {
        "description": "Allocate memory for br->levels array and check if allocation was successful.",
        "pre": {
            "obj": "!=null",
            "obj->package.count": ">= ACPI_VIDEO_FIRST_LEVEL",
            "br": "!=null",
            "br->levels": "!=null"
        }
    }
},
{
    "kretprobe:acpi_video_bus_remove": {
        "description": "This function is called to remove the ACPI video bus device.",
        "pre": {
            "device": "!=null",
            "video": "!=null",
            "__acpi_video_get_backlight_type(false, &auto_detect)": "== acpi_backlight_video && !auto_detect",
            "acpi_video_bus_register_backlight(video)": "!=null",
            "acpi_video_bus_add_notify_handler(video)": "!=null"
        },
        "post": {
            "return": "0",
            "error": "!=null",
            "device->driver_data": "== NULL"
        }
    }
},
S,
S,
{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "&init_mutex",
            "init_done": "==false"
        }
    }
},
{
    "kretprobe:acpi_has_method": {
        "description": "Check if the ACPI handle has the specified method.",
        "pre": {
            "handle": "!=null",
            "method": "in [\"_DOD\", \"_DOS\"]"
        }
    },
    "kretprobe:acpi_is_video_device": {
        "description": "Check if the ACPI handle represents a video device.",
        "pre": {
            "handle": "!=null"
        },
        "post": {
            "video_caps": "=0"
        }
    }
},
{
    "kprobe:acpi_has_method": {
        "description": "Check if the ACPI handle has the specified method.",
        "pre": {
            "handle": "!=null",
            "method": "in [_DOD, _DOS]"
        }
    },
    "kprobe:acpi_is_video_device": {
        "description": "Check if the ACPI handle represents a video device.",
        "pre": {
            "handle": "!=null"
        },
        "post": {
            "video_caps": "=0"
        }
    }
},
S,
S,
{
    "kretprobe:acpi_device_hotplug": {
        "description": "Handle ACPI device hotplug event",
        "pre": {
            "adev->handle": "== INVALID_ACPI_HANDLE",
            "adev->flags.is_dock_station": "== true"
        }
    }
},
{
    "kprobe:acpi_device_hotplug": {
        "description": "Handle ACPI hotplug events for a device.",
        "pre": {
            "adev->handle": "==INVALID_ACPI_HANDLE",
            "adev->flags.is_dock_station": "true"
        }
    }
},
{
    "kretprobe:acpi_node_prop_get": {
        "description": "Return an ACPI property with the given name.",
        "pre": {
            "fwnode": "!=null",
            "propname": "!=null",
            "valptr": "!=null"
        }
    }
},
S,
{
    "for (i = 0; i < format_count; i++)": {
        "description": "Loop over the elements in the format array",
        "pre": {
            "i": ">= 0",
            "i": "< format_count"
        }
    }
},
{
    "for (i = 0; i < format_count; i++)": {
        "description": "Loop over the objects specified by the format",
        "pre": {
            "format_count": ">= 0"
        }
    }
},
{
    "kretprobe:acpi_evaluate_object": {
        "description": "Evaluate an ACPI object.",
        "pre": {
            "handle": "!=null",
            "pathname": "!=null",
            "arguments": "!=null",
            "buffer": "!=null",
            "status": "==ACPI_SUCCESS",
            "buffer.length": "==0",
            "package": "!=null"
        }
    }
},
{
    "kprobe:acpi_evaluate_object": {
        "description": "Evaluate object",
        "pre": {
            "handle": "!=null",
            "pathname": "!=null",
            "arguments": "!=null",
            "buffer": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:acpi_statusacpi_evaluate_ost": {
        "description": "Evaluate _OST for hotplug operations.",
        "pre": {
            "handle": "!=null",
            "source_event": "!=null",
            "status_code": "!=null",
            "status_buf": "!=null"
        }
    }
},
{
    "kprobe:acpi_statusacpi_evaluate_ost": {
        "description": "Evaluate _OST for hotplug operations.",
        "pre": {
            "handle": "!=null",
            "source_event": "!=null",
            "status_code": "!=null",
            "status_buf": "!=null"
        }
    }
},
{
    "kretprobe:acpi_handle_printk": {
        "description": "Print message with ACPI prefix and object path",
        "pre": {
            "level": "!=null",
            "handle": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:acpi_handle_printk": {
        "description": "Print message with ACPI prefix and object path",
        "pre": {
            "level": "!=null",
            "handle": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:void__acpi_handle_debug": {
        "description": "Debug prints a message with ACPI prefix and object path.",
        "pre": {
            "descriptor": "!=null",
            "handle": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:void__acpi_handle_debug": {
        "description": "pr_debug with ACPI prefix and object path",
        "pre": {
            "descriptor": "!=null",
            "handle": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:acpi_has_method": {
        "description": "Check whether @handle has a method named @name.",
        "pre": {
            "handle": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:acpi_has_method": {
        "description": "Check whether @handle has a method named @name.",
        "pre": {
            "handle": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:acpi_evaluate_reg": {
        "description": "Evaluate _REG method to register OpRegion presence",
        "pre": {
            "handle": "!=null",
            "space_id": "in [ACPI_ADR_SPACE_SYSTEM_IO, ACPI_ADR_SPACE_SYSTEM_MEMORY, ACPI_ADR_SPACE_PCI_CONFIGURATION, ACPI_ADR_SPACE_EMBEDDED_CONTROLLER, ACPI_ADR_SPACE_SMBUS, ACPI_ADR_SPACE_CMOS, ACPI_ADR_SPACE_PCI_BAR_TARGET, ACPI_ADR_SPACE_IPMI, ACPI_ADR_SPACE_GPIO, ACPI_ADR_SPACE_GENERIC_SERIAL_BUS, ACPI_ADR_SPACE_PLATFORM_COMMUNICATION_CHANNEL, ACPI_ADR_SPACE_FUNCTIONAL_FIXED_HARDWARE, ACPI_ADR_SPACE_PLATFORM_COMMUNICATION_CHANNEL_EXCLUSIVE, ACPI_ADR_SPACE_POWER_BUTTON, ACPI_ADR_SPACE_SLEEP_BUTTON, ACPI_ADR_SPACE_PCI_ROOT_BRIDGE_WINDOW, ACPI_ADR_SPACE_FIXED_HARDWARE, ACPI_ADR_SPACE_FIRMWARE_DEVICE, ACPI_ADR_SPACE_NAMESPACE_DEVICE, ACPI_ADR_SPACE_GENERIC_SERIAL_BUS_CONTROLLER, ACPI_ADR_SPACE_PLATFORM_COMMUNICATION_CHANNEL_VALIDATION, ACPI_ADR_SPACE_RESERVED, ACPI_ADR_SPACE_SYSTEM_CMOS, ACPI_ADR_SPACE_PCI_CONFIGURATION_EXPANSION, ACPI_ADR_SPACE_MGMT_CONTROLLER, ACPI_ADR_SPACE_RESERVED_2, ACPI_ADR_SPACE_RESERVED_3, ACPI_ADR_SPACE_RESERVED_4, ACPI_ADR_SPACE_RESERVED_5, ACPI_ADR_SPACE_RESERVED_6, ACPI_ADR_SPACE_RESERVED_7, ACPI_ADR_SPACE_RESERVED_8, ACPI_ADR_SPACE_RESERVED_9, ACPI_ADR_SPACE_RESERVED_10, ACPI_ADR_SPACE_RESERVED_11, ACPI_ADR_SPACE_RESERVED_12, ACPI_ADR_SPACE_RESERVED_13, ACPI_ADR_SPACE_RESERVED_14, ACPI_ADR_SPACE_RESERVED_15, ACPI_ADR_SPACE_RESERVED_16, ACPI_ADR_SPACE_RESERVED_17, ACPI_ADR_SPACE_RESERVED_18, ACPI_ADR_SPACE_RESERVED_19, ACPI_ADR_SPACE_RESERVED_20, ACPI_ADR_SPACE_RESERVED_21, ACPI_ADR_SPACE_RESERVED_22, ACPI_ADR_SPACE_RESERVED_23, ACPI_ADR_SPACE_RESERVED_24, ACPI_ADR_SPACE_RESERVED_25, ACPI_ADR_SPACE_RESERVED_26, ACPI_ADR_SPACE_RESERVED_27, ACPI_ADR_SPACE_RESERVED_28, ACPI_ADR_SPACE_RESERVED_29, ACPI_ADR_SPACE_RESERVED_30, ACPI_ADR_SPACE_RESERVED_31, ACPI_ADR_SPACE_RESERVED_32, ACPI_ADR_SPACE_RESERVED_33, ACPI_ADR_SPACE_RESERVED_34, ACPI_ADR_SPACE_RESERVED_35, ACPI_ADR_SPACE_RESERVED_36, ACPI_ADR_SPACE_RESERVED_37, ACPI_ADR_SPACE_RESERVED_38, ACPI_ADR_SPACE_RESERVED_39, ACPI_ADR_SPACE_RESERVED_40, ACPI_ADR_SPACE_RESERVED_41, ACPI_ADR_SPACE_RESERVED_42, ACPI_ADR_SPACE_RESERVED_43, ACPI_ADR_SPACE_RESERVED_44, ACPI_ADR_SPACE_RESERVED_45, ACPI_ADR_SPACE_RESERVED_46, ACPI_ADR_SPACE_RESERVED_47, ACPI_ADR_SPACE_RESERVED_48, ACPI_ADR_SPACE_RESERVED_49, ACPI_ADR_SPACE_RESERVED_50, ACPI_ADR_SPACE_RESERVED_51, ACPI_ADR_SPACE_RESERVED_52, ACPI_ADR_SPACE_RESERVED_53, ACPI_ADR_SPACE_RESERVED_54, ACPI_ADR_SPACE_RESERVED_55, ACPI_ADR_SPACE_RESERVED_56, ACPI_ADR_SPACE_RESERVED_57, ACPI_ADR_SPACE_RESERVED_58, ACPI_ADR_SPACE_RESERVED_59, ACPI_ADR_SPACE_RESERVED_60, ACPI_ADR_SPACE_RESERVED_61, ACPI_ADR_SPACE_RESERVED_62, ACPI_ADR_SPACE_RESERVED_63, ACPI_ADR_SPACE_RESERVED_64, ACPI_ADR_SPACE_RESERVED_65, ACPI_ADR_SPACE_RESERVED_66, ACPI_ADR_SPACE_RESERVED_67, ACPI_ADR_SPACE_RESERVED_68, ACPI_ADR_SPACE_RESERVED_69, ACPI_ADR_SPACE_RESERVED_70, ACPI_ADR_SPACE_RESERVED_71, ACPI_ADR_SPACE_RESERVED_72, ACPI_ADR_SPACE_RESERVED_73, ACPI_ADR_SPACE_RESERVED_74, ACPI_ADR_SPACE_RESERVED_75, ACPI_ADR_SPACE_RESERVED_76, ACPI_ADR_SPACE_RESERVED_77, ACPI_ADR_SPACE_RESERVED_78, ACPI_ADR_SPACE_RESERVED_79, ACPI_ADR_SPACE_RESERVED_80, ACPI_ADR_SPACE_RESERVED_81, ACPI_ADR_SPACE_RESERVED_82, ACPI_ADR_SPACE_RESERVED_83, ACPI_ADR_SPACE_RESERVED_84, ACPI_ADR_SPACE_RESERVED_85, ACPI_ADR_SPACE_RESERVED_86, ACPI_ADR_SPACE_RESERVED_87, ACPI_ADR_SPACE_RESERVED_88, ACPI_ADR_SPACE_RESERVED_89, ACPI_ADR_SPACE_RESERVED_90, ACPI_ADR_SPACE_RESERVED_91, ACPI_ADR_SPACE_RESERVED_92, ACPI_ADR_SPACE_RESERVED_93, ACPI_ADR_SPACE_RESERVED_94, ACPI_ADR_SPACE_RESERVED_95, ACPI_ADR_SPACE_RESERVED_96, ACPI_ADR_SPACE_RESERVED_97, ACPI_ADR_SPACE_RESERVED_98, ACPI_ADR_SPACE_RESERVED_99, ACPI_ADR_SPACE_RESERVED_100, ACPI_ADR_SPACE_RESERVED_101, ACPI_ADR_SPACE_RESERVED_102, ACPI_ADR_SPACE_RESERVED_103, ACPI_ADR_SPACE_RESERVED_104, ACPI_ADR_SPACE_RESERVED_105, ACPI_ADR_SPACE_RESERVED_106, ACPI_ADR_SPACE_RESERVED_107, ACPI_ADR_SPACE_RESERVED_108, ACPI_ADR_SPACE_RESERVED_109, ACPI_ADR_SPACE_RESERVED_110, ACPI_ADR_SPACE_RESERVED_111, ACPI_ADR_SPACE_RESERVED_112, ACPI_ADR_SPACE_RESERVED_113, ACPI_ADR_SPACE_RESERVED_114, ACPI_ADR_SPACE_RESERVED_115, ACPI_ADR_SPACE_RESERVED_116, ACPI_ADR_SPACE_RESERVED_117, ACPI_ADR_SPACE_RESERVED_118, ACPI_ADR_SPACE_RESERVED_119, ACPI_ADR_SPACE_RESERVED_120, ACPI_ADR_SPACE_RESERVED_121, ACPI_ADR_SPACE_RESERVED_122, ACPI_ADR_SPACE_RESERVED_123, ACPI_ADR_SPACE_RESERVED_124, ACPI_ADR_SPACE_RESERVED_125, ACPI_ADR_SPACE_RESERVED_126, ACPI_ADR_SPACE_RESERVED_127, ACPI_ADR_SPACE_RESERVED_128, ACPI_ADR_SPACE_RESERVED_129, ACPI_ADR_SPACE_RESERVED_130, ACPI_ADR_SPACE_RESERVED_131, ACPI_ADR_SPACE_RESERVED_132, ACPI_ADR_SPACE_RESERVED_133, ACPI_ADR_SPACE_RESERVED_134, ACPI_ADR_SPACE_RESERVED_135, ACPI_ADR_SPACE_RESERVED_136, ACPI_ADR_SPACE_RESERVED_137, ACPI_ADR_SPACE_RESERVED_138, ACPI_ADR_SPACE_RESERVED_139, ACPI_ADR_SPACE_RESERVED_140, ACPI_ADR_SPACE_RESERVED_141, ACPI_ADR_SPACE_RESERVED_142, ACPI_ADR_SPACE_RESERVED_143, ACPI_ADR_SPACE_RESERVED_144, ACPI_ADR_SPACE_RESERVED_145, ACPI_ADR_SPACE_RESERVED_146, ACPI_ADR_SPACE_RESERVED_147, ACPI_ADR_SPACE_RESERVED_148, ACPI_ADR_SPACE_RESERVED_149, ACPI_ADR_SPACE_RESERVED_150, ACPI_ADR_SPACE_RESERVED_151, ACPI_ADR_SPACE_RESERVED_152, ACPI_ADR_SPACE_RESERVED_153, ACPI_ADR_SPACE_RESERVED_154, ACPI_ADR_SPACE_RESERVED_155, ACPI_ADR_SPACE_RESERVED_156, ACPI_ADR_SPACE_RESERVED_157, ACPI_ADR_SPACE_RESERVED_158, ACPI_ADR_SPACE_RESERVED_159, ACPI_ADR_SPACE_RESERVED_160, ACPI_ADR_SPACE_RESERVED_161, ACPI_ADR_SPACE_RESERVED_162, ACPI_ADR_SPACE_RESERVED_163, ACPI_ADR_SPACE_RESERVED_164, ACPI_ADR_SPACE_RESERVED_165, ACPI_ADR_SPACE_RESERVED_166, ACPI_ADR_SPACE_RESERVED_167, ACPI_ADR_SPACE_RESERVED_168, ACPI_ADR_SPACE_RESERVED_169, ACPI_ADR_SPACE_RESERVED_170, ACPI_ADR_SPACE_RESERVED_171, ACPI_ADR_SPACE_RESERVED_172, ACPI_ADR_SPACE_RESERVED_173, ACPI_ADR_SPACE_RESERVED_174, ACPI_ADR_SPACE_RESERVED_175, ACPI_ADR_SPACE_RESERVED_176, ACPI_ADR_SPACE_RESERVED_177, ACPI_ADR_SPACE_RESERVED_178, ACPI_ADR_SPACE_RESERVED_179, ACPI_ADR_SPACE_RESERVED_180, ACPI_ADR_SPACE_RESERVED_181, ACPI_ADR_SPACE_RESERVED_182, ACPI_ADR_SPACE_RESERVED_183, ACPI_ADR_SPACE_RESERVED_184, ACPI_ADR_SPACE_RESERVED_185, ACPI_ADR_SPACE_RESERVED_186, ACPI_ADR_SPACE_RESERVED_187, ACPI_ADR_SPACE_RESERVED_188, ACPI_ADR_SPACE_RESERVED_189, ACPI_ADR_SPACE_RESERVED_190, ACPI_ADR_SPACE_RESERVED_191, ACPI_ADR_SPACE_RESERVED_192, ACPI_ADR_SPACE_RESERVED_193, ACPI_ADR_SPACE_RESERVED_194, ACPI_ADR_SPACE_RESERVED_195, ACPI_ADR_SPACE_RESERVED_196, ACPI_ADR_SPACE_RESERVED_197, ACPI_ADR_SPACE_RESERVED_198, ACPI_ADR_SPACE_RESERVED_199, ACPI_ADR_SPACE_RESERVED_200, ACPI_ADR_SPACE_RESERVED_201, ACPI_ADR_SPACE_RESERVED_202, ACPI_ADR_SPACE_RESERVED_203, ACPI_ADR_SPACE_RESERVED_204, ACPI_ADR_SPACE_RESERVED_205, ACPI_ADR_SPACE_RESERVED_206, ACPI_ADR_SPACE_RESERVED_207, ACPI_ADR_SPACE_RESERVED_208, ACPI_ADR_SPACE_RESERVED_209, ACPI_ADR_SPACE_RESERVED_210, ACPI_ADR_SPACE_RESERVED_211, ACPI_ADR_SPACE_RESERVED_212, ACPI_ADR_SPACE_RESERVED_213, ACPI_ADR_SPACE_RESERVED_214, ACPI_ADR_SPACE_RESERVED_215, ACPI_ADR_SPACE_RESERVED_216, ACPI_ADR_SPACE_RESERVED_217, ACPI_ADR_SPACE_RESERVED_218, ACPI_ADR_SPACE_RESERVED_219, ACPI_ADR_SPACE_RESERVED_220, ACPI_ADR_SPACE_RESERVED_221, ACPI_ADR_SPACE_RESERVED_222, ACPI_ADR_SPACE_RESERVED_223, ACPI_ADR_SPACE_RESERVED_224, ACPI_ADR_SPACE_RESERVED_225, ACPI_ADR_SPACE_RESERVED_226, ACPI_ADR_SPACE_RESERVED_227, ACPI_ADR_SPACE_RESERVED_228, ACPI_ADR_SPACE_RESERVED_229, ACPI_ADR_SPACE_RESERVED_230, ACPI_ADR_SPACE_RESERVED_231, ACPI_ADR_SPACE_RESERVED_232, ACPI_ADR_SPACE_RESERVED_233, ACPI_ADR_SPACE_RESERVED_234, ACPI_ADR_SPACE_RESERVED_235, ACPI_ADR_SPACE_RESERVED_236, ACPI_ADR_SPACE_RESERVED_237, ACPI_ADR_SPACE_RESERVED_238, ACPI_ADR_SPACE_RESERVED_239, ACPI_ADR_SPACE_RESERVED_240, ACPI_ADR_SPACE_RESERVED_241, ACPI_ADR_SPACE_RESERVED_242, ACPI_ADR_SPACE_RESERVED_243, ACPI_ADR_SPACE_RESERVED_244, ACPI_ADR_SPACE_RESERVED_245, ACPI_ADR_SPACE_RESERVED_246, ACPI_ADR_SPACE_RESERVED_247, ACPI_ADR_SPACE_RESERVED_248, ACPI_ADR_SPACE_RESERVED_249, ACPI_ADR_SPACE_RESERVED_250, ACPI_ADR_SPACE_RESERVED_251, ACPI_ADR_SPACE_RESERVED_252, ACPI_ADR_SPACE_RESERVED_253, ACPI_ADR_SPACE_RESERVED_254, ACPI_ADR_SPACE_RESERVED_255]",
            "function": "in [ACPI_REG_CONNECT, ACPI_REG_DISCONNECT]"
        }
    }
},
{
    "kprobe:acpi_evaluate_reg": {
        "description": "Evaluate _REG method to register OpRegion presence",
        "pre": {
            "handle": "!=null",
            "space_id": "in [0, 1, 2, 3, 4, 5, 6, 7]",
            "function": "in [ACPI_REG_CONNECT, ACPI_REG_DISCONNECT]"
        }
    }
},
{
    "kretprobe:acpi_evaluate_dsm": {
        "description": "Evaluate device's _DSM method with specified GUID, revision id, and function number.",
        "pre": {
            "handle": "!=null",
            "guid": "!=null",
            "rev": "!=null",
            "func": "!=null",
            "argv4": "!=null"
        }
    }
},
{
    "kprobe:acpi_evaluate_dsm": {
        "description": "Evaluate device's _DSM method with specified GUID, revision id, and function number.",
        "pre": {
            "handle": "!=null",
            "guid": "!=null",
            "rev": "!=null",
            "func": "!=null",
            "argv4": "!=null"
        }
    }
},
{
    "kretprobe:acpi_check_dsm": {
        "description": "Check if _DSM method supports requested functions.",
        "pre": {
            "handle": "!=null",
            "guid": "!=null",
            "rev": ">=0",
            "funcs": ">=0"
        }
    }
},
{
    "kprobe:acpi_check_dsm": {
        "description": "Check if _DSM method supports requested functions.",
        "pre": {
            "handle": "!=null",
            "guid": "!=null",
            "rev": "!=null",
            "funcs": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_hid_uid_match": {
        "description": "Match device by supplied HID and UID",
        "pre": {
            "adev": "!=null",
            "hid2": "!=null",
            "uid2": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_hid_uid_match": {
        "description": "Match device by supplied HID and UID",
        "pre": {
            "adev": "!=null",
            "hid2": "!=null",
            "uid2": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_uid_to_integer": {
        "description": "Treat ACPI device _UID as integer",
        "pre": {
            "adev": "!=null",
            "integer": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_uid_to_integer": {
        "description": "Treat ACPI device _UID as integer",
        "pre": {
            "adev": "!=null",
            "integer": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_found": {
        "description": "Detect presence of a given ACPI device in the namespace.",
        "pre": {
            "hid": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_found": {
        "description": "Detect presence of a given ACPI device in the namespace.",
        "pre": {
            "hid": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_present": {
        "description": "Detect that a given ACPI device is present",
        "pre": {
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_present": {
        "description": "Detect that a given ACPI device is present",
        "pre": {
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_get_next_match_dev": {
        "description": "Return the next match of ACPI device",
        "pre": {
            "adev": "!=null",
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_get_next_match_dev": {
        "description": "Return the next match of ACPI device",
        "pre": {
            "adev": "!=null",
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kretprobe:acpi_dev_get_first_match_dev": {
        "description": "Return the first match of ACPI device",
        "pre": {
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kprobe:acpi_dev_get_first_match_dev": {
        "description": "Return the first match of ACPI device",
        "pre": {
            "hid": "!=null",
            "uid": "!=null",
            "hrv": "!=null"
        }
    }
},
{
    "kretprobe:acpi_match_platform_list": {
        "description": "Check if the system matches with a given list",
        "pre": {
            "plat": "!=null"
        },
        "post": {
            "return_value": ">= -1"
        }
    }
},
{
    "kprobe:acpi_match_platform_list": {
        "description": "Check if the system matches with a given list",
        "pre": {
            "plat": "!=null"
        },
        "post": {
            "return": ">= -1"
        }
    }
},
S,
S,
{
    "kretprobe:acpi_pm_device_sleep_state": {
        "description": "Get preferred power state of ACPI device.",
        "pre": {
            "dev": "!=null",
            "d_min_p": "!=null",
            "d_max_in": "!=null",
            "return_value": ">=0",
            "return_value": "not in [-ENODEV, -EINVAL, -ENODATA]"
        }
    }
},
{
    "kprobe:acpi_pm_device_sleep_state": {
        "description": "Get preferred power state of ACPI device.",
        "pre": {
            "dev": "!=null",
            "d_min_p": "!=null",
            "d_max_in": "!=null"
        }
    }
},
{
    "kretprobe:acpi_run_osc": {
        "description": "Setting up input parameters",
        "pre": {
            "handle": "!=null",
            "context": "!=null",
            "context->uuid_str": "!=null",
            "guid": "!=null",
            "guid_parse(context->uuid_str, &guid)": "return AE_ERROR",
            "context->ret.length": "ACPI_ALLOCATE_BUFFER",
            "context->ret.pointer": "NULL"
        },
        "post": {
            "status": "!=ACPI_FAILURE",
            "output.length": "!=0",
            "out_obj->type": "ACPI_TYPE_BUFFER",
            "out_obj->buffer.length": "context->cap.length"
        }
    }
},
{
    "kprobe:acpi_run_osc": {
        "description": "Run the _OSC method with the given input parameters.",
        "pre": {
            "handle": "!=null",
            "context": "!=null",
            "context->uuid_str": "is a valid GUID string",
            "context->ret.length": "ACPI_ALLOCATE_BUFFER",
            "context->ret.pointer": "NULL",
            "input.count": "4",
            "input.pointer": "!=null",
            "in_params[0].type": "ACPI_TYPE_BUFFER",
            "in_params[0].buffer.length": "16",
            "in_params[0].buffer.pointer": "!=null",
            "in_params[1].type": "ACPI_TYPE_INTEGER",
            "in_params[1].integer.value": "context->rev",
            "in_params[2].type": "ACPI_TYPE_INTEGER",
            "in_params[2].integer.value": "context->cap.length/sizeof(u32)",
            "in_params[3].type": "ACPI_TYPE_BUFFER",
            "in_params[3].buffer.length": "context->cap.length",
            "in_params[3].buffer.pointer": "context->cap.pointer",
            "status": "acpi_evaluate_object(handle, \"_OSC\", &input, &output)",
            "output.length": "!=0",
            "out_obj->type": "ACPI_TYPE_BUFFER",
            "out_obj->buffer.length": "context->cap.length"
        }
    }
},
{
    "kretprobe:acpi_bus_register_driver": {
        "description": "Register a driver with the ACPI bus.",
        "pre": {
            "driver": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:acpi_bus_register_driver": {
        "description": "Register a driver with the ACPI bus",
        "pre": {
            "driver": "!=null"
        }
    }
},
S,
{
    "kprobe:acpi_bus_unregister_driver": {
        "description": "Unregisters a driver with the ACPI bus.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:acpi_processor_notify_smm": {
        "description": "Notify SMM for ACPI processor",
        "pre": {
            "is_done": "!=0"
        }
    }
},
{
    "kprobe:acpi_processor_notify_smm": {
        "description": "Notify SMM for ACPI processor",
        "pre": {
            "is_done": "!=0"
        }
    }
},
S,
{
    "kprobe:for_each_possible_cpu": {
        "description": "Iterate over each possible CPU and perform an action.",
        "pre": {
            "i": "!=null"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy the value of gas->address to addr using memcpy and then call acpi_os_map_iomem.",
        "pre": {
            "addr": "!=null",
            "gas->address": "!=null",
            "gas->bit_width": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source address to destination address.",
        "pre": {
            "addr": "!=null",
            "gas->address": "!=null",
            "sizeof(addr)": "!=null",
            "!addr": true,
            "!gas->bit_width": true
        }
    }
},
{
    "kretprobe:acpi_os_unmap_generic_address": {
        "description": "Unmap a generic address in ACPI.",
        "pre": {
            "gas": "!=null",
            "gas->space_id": "==ACPI_ADR_SPACE_SYSTEM_MEMORY",
            "addr": "!=null",
            "gas->bit_width": "!=null",
            "!addr": "false",
            "!gas->bit_width": "false"
        },
        "post": {
            "map": "!=null"
        }
    }
},
{
    "kprobe:acpi_os_unmap_generic_address": {
        "description": "Unmap a generic address in ACPI.",
        "pre": {
            "gas->space_id": "== ACPI_ADR_SPACE_SYSTEM_MEMORY",
            "addr": "!= null",
            "gas->bit_width": "!= null",
            "map": "== null"
        }
    }
},
{
    "kretprobe:acpi_os_execute": {
        "description": "Depending on type, either queues function for deferred execution or immediately executes function on a separate thread.",
        "pre": {
            "type": "in [ACPI_NO_CALLBACK, ACPI_FULL_CALLBACK, ACPI_DEFERRED_CALLBACK]",
            "function": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:acpi_os_execute": {
        "description": "Depending on type, either queues function for deferred execution or immediately executes function on a separate thread.",
        "pre": {
            "type": "in [ACPI_NO_CALLBACK, ACPI_FULL_CALLBACK, ACPI_DEFERRED_CALLBACK]",
            "function": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kretprobe:acpi_os_wait_events_complete": {
        "description": "Make sure the GPE handler or the fixed event handler is not used on another CPU after removal.",
        "pre": {
            "acpi_sci_irq_valid()": "true",
            "synchronize_hardirq(acpi_sci_irq)": "called",
            "flush_workqueue(kacpid_wq)": "called",
            "flush_workqueue(kacpi_notify_wq)": "called"
        }
    }
},
{
    "kprobe:acpi_os_wait_events_complete": {
        "description": "Make sure the GPE handler or the fixed event handler is not used on another CPU after removal.",
        "pre": {
            "acpi_sci_irq_valid()": "true",
            "synchronize_hardirq(acpi_sci_irq)": "called",
            "flush_workqueue(kacpid_wq)": "called",
            "flush_workqueue(kacpi_notify_wq)": "called"
        }
    }
},
{
    "kretprobe:acpi_os_get_line": {
        "description": "Get a line from the input buffer.",
        "pre": {
            "buffer": "!=null",
            "buffer_length": "!=null",
            "bytes_read": "!=null"
        }
    }
},
{
    "kprobe:acpi_os_get_line": {
        "description": "Get a line of input from the debugger or console.",
        "pre": {
            "buffer": "!=null",
            "buffer_length": "!=null",
            "bytes_read": "!=null"
        }
    }
},
{
    "kretprobe:acpi_bus_generate_netlink_event": {
        "description": "Generate a netlink event for ACPI bus",
        "pre": {
            "skb": "!=null",
            "size": ">= sizeof(struct acpi_genl_event) + nla_total_size(0)",
            "return": "-ENOMEM if skb == null"
        }
    }
},
{
    "kprobe:acpi_bus_generate_netlink_event": {
        "description": "Generate a netlink event for ACPI bus",
        "pre": {
            "device_class": "any",
            "bus_id": "any",
            "type": "any",
            "data": "any"
        }
    }
},
{
    "kretprobe:acpi_ec_gpe_status_set": {
        "description": "Set the GPE status of the ACPI EC device.",
        "pre": {
            "ec": {
                "command_addr": "!=null",
                "data_addr": "!=null"
            }
        },
        "post": {
            "return value": "in [true, false]"
        }
    }
},
{
    "kprobe:acpi_ec_gpe_status_set": {
        "description": "Set the GPE status of the ACPI EC device.",
        "pre": {
            "ec": "!=null"
        }
    }
},
{
    "kretprobe:advance_transaction": {
        "description": "Advances the transaction for the acpi_ec",
        "pre": {
            "ec": "!=null",
            "interrupt": "bool"
        },
        "post": {
            "ec->curr->flags": "&= ~ACPI_EC_COMMAND_POLL",
            "ec->curr->flags": "&= ~ACPI_EC_COMMAND_COMPLETE"
        }
    },
    "kretprobe:acpi_ec_mask_events": {
        "description": "Masks events for the acpi_ec",
        "pre": {
            "ec": "!=null"
        }
    }
},
{
    "kprobe:if (t->irq_count == ec_storm_threshold)acpi_ec_mask_events(ec);}static void advance_transaction(struct acpi_ec *ec, bool interrupt)": {
        "description": "This function checks if the irq_count is equal to the ec_storm_threshold and calls the acpi_ec_mask_events function with the ec argument.",
        "pre": {
            "t->irq_count": "== ec_storm_threshold",
            "ec": "!= null"
        }
    }
},
S,
S,
{
    "kretprobe:i2c_of_match_device": {
        "description": "Check if the given client matches the OF style.",
        "pre": {
            "drv": {
                "of_match_table": "!=null"
            },
            "client": "!=null"
        }
    }
},
{
    "kprobe:i2c_of_match_device": {
        "description": "Attempt an OF style match",
        "pre": {
            "drv": {
                "of_match_table": "!=null"
            },
            "client": "!=null"
        },
        "post": {
            "return": 1
        }
    }
},
{
    "kretprobe:i2c_find_device_by_fwnode": {
        "description": "Find an i2c_client for the fwnode",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:i2c_find_device_by_fwnode": {
        "description": "Find an i2c_client for the fwnode.",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:i2c_verify_adapter": {
        "description": "Return parameter as i2c_adapter or NULL.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:i2c_verify_adapter": {
        "description": "Return parameter as i2c_adapter or NULL",
        "pre": {
            "dev": "!=null",
            "dev->type": "==I2C",
            "dev->parent": "!=null",
            "dev->parent->type": "==I2C",
            "dev->parent->driver": "!=null",
            "dev->parent->driver->name": "==i2c_driver"
        }
    }
},
{
    "kretprobe:i2c_add_adapter": {
        "description": "Declare i2c adapter, use dynamic bus number",
        "pre": {
            "adapter": "!=null",
            "adapter->nr": "==null",
            "adapter->bus_num": "==null"
        },
        "post": {
            "adapter->nr": "!=null",
            "adapter->bus_num": "!=null"
        }
    }
},
{
    "kprobe:i2c_add_adapter": {
        "description": "Declare i2c adapter, use dynamic bus number",
        "pre": {
            "adapter": "!=null",
            "adapter->nr": "==null"
        },
        "post": {
            "adapter->nr": "!=null"
        }
    }
},
{
    "kretprobe:i2c_del_adapter": {
        "description": "Unregister I2C adapter",
        "pre": {
            "adap": "!=null"
        },
        "context": "can sleep"
    }
},
{
    "kprobe:i2c_del_adapter": {
        "description": "Unregister I2C adapter",
        "pre": {
            "adap": "!=null"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:i2c_find_adapter_by_fwnode": {
        "description": "Find an i2c_adapter for the fwnode",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:i2c_find_adapter_by_fwnode": {
        "description": "Find an i2c_adapter for the fwnode.",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:i2c_get_adapter_by_fwnode": {
        "description": "Get the I2C adapter associated with the given firmware node handle.",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "adapter": "!=null"
        }
    }
},
S,
{
    "kretprobe:if (WARN_ON(!is_registered))return -EAGAIN;/* add the driver to the list of i2c drivers in the driver core `": {
        "description": "Register an I2C driver",
        "pre": {
            "owner": "!=null",
            "driver": "!=null"
        }
    }
},
{
    "kprobe:if (WARN_ON(!is_registered))return -EAGAIN;/* add the driver to the list of i2c drivers in the driver core `": {
        "description": "Register an I2C driver.",
        "pre": {
            "owner": "!=null",
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:i2c_del_driver": {
        "description": "Unregister I2C driver",
        "pre": {
            "driver": "!=null"
        },
        "context": "can sleep"
    }
},
{
    "kprobe:i2c_del_driver": {
        "description": "Unregister I2C driver",
        "pre": {
            "driver": "!=null"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:__i2c_transfer": {
        "description": "unlocked flavor of i2c_transfer",
        "pre": {
            "adap": "!=null",
            "msgs": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:__i2c_transfer": {
        "description": "unlocked flavor of i2c_transfer",
        "pre": {
            "adap": "!=null",
            "msgs": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:i2c_transfer_buffer_flags": {
        "description": "Issue a single I2C message transferring data to/from a buffer.",
        "pre": {
            "client": "!=null",
            "buf": "!=null",
            "count": "<=65535",
            "flags": "in [I2C_M_RD]"
        },
        "post": {
            "return_value": "<0 || >=0"
        }
    }
},
{
    "kprobe:i2c_transfer_buffer_flags": {
        "description": "Issue a single I2C message transferring data to/from a buffer.",
        "pre": {
            "client": "!=null",
            "buf": "!=null",
            "count": "<=65535",
            "flags": "in [I2C_M_RD]"
        },
        "post": {
            "return": "<0 || >=0"
        }
    }
},
{
    "kretprobe:i2c_smbus_pec": {
        "description": "Incremental CRC8 over the given input data array",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:i2c_smbus_pec": {
        "description": "Incremental CRC8 over the given input data array",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_read_byte": {
        "description": "SMBus \"receive byte\" protocol",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_read_byte": {
        "description": "SMBus 'receive byte' protocol",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_write_byte": {
        "description": "SMBus 'send byte' protocol",
        "pre": {
            "client": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_write_byte": {
        "description": "SMBus 'send byte' protocol",
        "pre": {
            "client": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_read_byte_data": {
        "description": "SMBus 'read byte' protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_read_byte_data": {
        "description": "SMBus 'read byte' protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_write_byte_data": {
        "description": "SMBus \"write byte\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_write_byte_data": {
        "description": "SMBus \"write byte\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_read_word_data": {
        "description": "SMBus \"read word\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_read_word_data": {
        "description": "SMBus \"read word\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_write_word_data": {
        "description": "SMBus \"write word\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_write_word_data": {
        "description": "SMBus \"write word\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:i2c_smbus_read_block_data": {
        "description": "SMBus \"block read\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "values": "!=null",
            "values_length": "<=32",
            "adapter_support": "I2C_FUNC_SMBUS_READ_BLOCK_DATA"
        }
    }
},
{
    "kprobe:i2c_smbus_read_block_data": {
        "description": "SMBus \"block read\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "values": "!=null",
            "values_length": "<=32",
            "adapter_support": "I2C_FUNC_SMBUS_READ_BLOCK_DATA"
        }
    }
},
{
    "kretprobe:i2c_smbus_write_block_data": {
        "description": "SMBus \"block write\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "length": ">=0 && <=32",
            "values": "!=null"
        }
    }
},
{
    "kprobe:i2c_smbus_write_block_data": {
        "description": "SMBus \"block write\" protocol",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "length": ">=0 && <=32",
            "values": "!=null"
        }
    }
},
{
    "kretprobe:trace_smbus_write": {
        "description": "Write data to an SMBus device.",
        "pre": {
            "adapter": "!=null",
            "addr": "!=null",
            "flags": "!=null",
            "read_write": "in ['read', 'write']",
            "command": "!=null",
            "protocol": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:trace_smbus_write": {
        "description": "Trace the smbus_write function",
        "pre": {
            "adapter": "!=null",
            "addr": "!=null",
            "flags": "!=null",
            "read_write": "in ['read', 'write']",
            "command": "!=null",
            "protocol": "!=null",
            "data": "!=null"
        }
    },
    "kprobe:trace_smbus_read": {
        "description": "Trace the smbus_read function",
        "pre": {
            "adapter": "!=null",
            "addr": "!=null",
            "flags": "!=null",
            "read_write": "in ['read', 'write']",
            "command": "!=null",
            "protocol": "!=null"
        }
    },
    "flags": {
        "description": "Update flags with specific values",
        "pre": {
            "flags": "&= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB"
        }
    },
    "xfer_func": {
        "description": "Assign xfer_func with adapter's smbus_xfer function",
        "pre": {
            "xfer_func": "= adapter->algo->smbus_xfer"
        }
    },
    "i2c_in_atomic_xfer_mode": {
        "description": "Check if in atomic transfer mode",
        "pre": {
            "i2c_in_atomic_xfer_mode()": "true"
        }
    }
},
{
    "kretprobe:i2c_smbus_read_i2c_block_data_or_emulated": {
        "description": "Read block or emulate",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "length": "!=null",
            "values": "!=null",
            "length": "<= I2C_SMBUS_BLOCK_MAX",
            "values.length": ">= length",
            "values.length": "<= I2C_SMBUS_BLOCK_MAX"
        }
    }
},
{
    "kprobe:i2c_smbus_read_i2c_block_data_or_emulated": {
        "description": "Read block or emulate",
        "pre": {
            "client": "!=null",
            "command": "!=null",
            "length": "!=null",
            "values": "!=null",
            "length": "<= I2C_SMBUS_BLOCK_MAX",
            "values.length": ">= length",
            "values.length": "<= I2C_SMBUS_BLOCK_MAX"
        }
    }
},
{
    "kretprobe:pci_read_config_byte": {
        "description": "Read a byte from the PCI configuration space of the device specified by *pdev* at the given *offset*.",
        "pre": {
            "pdev": "!=null",
            "offset": "!=null"
        }
    },
    "kretprobe:PCI_FUNC": {
        "description": "Extract the PCI function number from the given *devfn*.",
        "pre": {
            "devfn": "!=null"
        }
    },
    "kretprobe:amd756_probe": {
        "description": "Probe function for the AMD756 PCI device.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null",
            "id->driver_data": "in [AMD756, AMD766, AMD768, NFORCE, AMD8111]"
        },
        "post": {
            "return": "in [-ENODEV, 0]"
        }
    }
},
{
    "kprobe:pci_read_config_byte": {
        "description": "Read a byte from the PCI configuration space of the device specified by *pdev* at the given *offset*.",
        "pre": {
            "pdev": "!=null",
            "offset": "!=null"
        }
    },
    "kprobe:PCI_FUNC": {
        "description": "Get the PCI function number from the given *devfn*.",
        "pre": {
            "devfn": "!=null"
        }
    },
    "kprobe:amd756_probe": {
        "description": "Probe function for the AMD756 chipset.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null",
            "id->driver_data": "in [AMD756, AMD766, AMD768, NFORCE, AMD8111]"
        }
    }
},
S,
{
    "kprobe:i2c_bit_add_bus": {
        "description": "Add a new I2C adapter to the i2c module.",
        "pre": {
            "adap": "!=null",
            "add_adapter": "!=null",
            "bit_adap": "!=null",
            "ret": "!=null",
            "bit_test": ">=0",
            "ret": ">=0"
        }
    }
},
{
    "kretprobe:i2c_pcf_add_bus": {
        "description": "Register a new adapter to the i2c module.",
        "pre": {
            "adap->algo": "== &pcf_algo",
            "rval = pcf_init_8584(pcf_adap)": "== 0",
            "if (rval)": "== 0",
            "rval = i2c_add_adapter(adap)": "== 0"
        }
    }
},
{
    "i2c_pcf_add_bus": {
        "pre": {
            "adap": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an unsigned char from the EISA bus at the specified port.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        },
        "post": {
            "return_value": "is_unsigned_char"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an 8-bit value from the EISA bus at the specified port.",
        "pre": {
            "EISA_bus": true,
            "port": {
                "type": "unsigned short",
                "constraints": [
                    "!=null",
                    "within_range(0, 65535)"
                ]
            },
            "gsc_readb(eisa_permute(port))": true
        }
    }
},
{
    "kretprobe:eisa_in8": {
        "description": "Reads an unsigned 8-bit value from the specified port.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    },
    "kretprobe:eisa_in16": {
        "description": "Reads an unsigned 16-bit value from the specified port.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
{
    "kprobe:eisa_in8": {
        "description": "Reads an unsigned 8-bit value from the specified port.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
{
    "kretprobe:eisa_in8": {
        "description": "Read an 8-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "in [0, 255]"
        }
    },
    "kretprobe:eisa_in16": {
        "description": "Read a 16-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "in [0, 65535]"
        }
    },
    "kretprobe:eisa_in32": {
        "description": "Read a 32-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "if EISA_bus then le32_to_cpu(gsc_readl(eisa_permute(port))) else 0xffffffff"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an 8-bit value from the specified port if EISA_bus is true.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an unsigned char from the specified port if EISA_bus is enabled.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_in16)": {
        "description": "Reads an unsigned short from the specified port if EISA_bus is enabled.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_in32)": {
        "description": "Reads an unsigned int from the specified port if EISA_bus is enabled.",
        "pre": {
            "port": "!=null",
            "EISA_bus": "==true"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_out8)": {
        "description": "Writes an unsigned char to the specified port if EISA_bus is enabled.",
        "pre": {
            "data": "!=null",
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an 8-bit value from the specified port if EISA_bus is true.",
        "pre": {
            "data": "!=null",
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
{
    "kretprobe:eisa_in8": {
        "description": "Reads an 8-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        }
    },
    "kretprobe:eisa_in16": {
        "description": "Reads a 16-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        }
    },
    "kretprobe:eisa_in32": {
        "description": "Reads a 32-bit value from the specified port.",
        "pre": {
            "port": "!=null"
        }
    },
    "kretprobe:eisa_out8": {
        "description": "Writes an 8-bit value to the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:eisa_out16": {
        "description": "Writes a 16-bit value to the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:eisa_in8": {
        "description": "Reads an 8-bit value from the specified EISA port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(eisa_in8)": {
        "description": "Reads an 8-bit value from the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_in16)": {
        "description": "Reads a 16-bit value from the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_in32)": {
        "description": "Reads a 32-bit value from the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_out8)": {
        "description": "Writes an 8-bit value to the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_out16)": {
        "description": "Writes a 16-bit value to the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(eisa_out32)": {
        "description": "Writes a 32-bit value to the specified port.",
        "pre": {
            "data": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:eisa_out32": {
        "description": "Writes the unsigned int data to the specified unsigned short port if EISA_bus is true.",
        "pre": {
            "data": "!=null",
            "port": "!=null",
            "EISA_bus": "==true"
        }
    }
},
S,
S,
{
    "kretprobe:txn_claim_irq": {
        "description": "Claim an IRQ for transaction processing.",
        "pre": {
            "i": "!=null",
            "irq": "!=null",
            "c": "not in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "irq + CPU_IRQ_BASE": ">=0"
        }
    }
},
{
    "kprobe:gsc_claim_irq": {
        "description": "Virtualize the IRQ first",
        "pre": {
            "irq": "!=null",
            "irq_modified": "true"
        }
    }
},
{
    "kretprobe:vlynq_enable_device": {
        "description": "Enable the VLYNQ device and negotiate clock generation.",
        "pre": {
            "dev": "!=null",
            "dev->dev.platform_data": "!=null",
            "dev->divisor": "in [vlynq_div_external, vlynq_div_auto]",
            "readl(&dev->remote->control) & VLYNQ_CTRL_CLOCK_INT": "!=0",
            "vlynq_linked(dev)": "==true"
        }
    }
},
{
    "kprobe:if (vlynq_linked(dev) && readl(&dev->remote->control) & VLYNQ_CTRL_CLOCK_INT)": {
        "description": "Check if the vlynq device is linked and if the control register has the VLYNQ_CTRL_CLOCK_INT bit set.",
        "pre": {
            "dev": "!=null",
            "dev->remote": "!=null",
            "dev->remote->control": "& VLYNQ_CTRL_CLOCK_INT != 0"
        }
    }
},
{
    "kretprobe:__vlynq_try_remote": {
        "description": "A VLYNQ remote device can clock the VLYNQ bus master using a dedicated clock line. In that case, both the remove device and the bus master should have the same serial clock dividers configured. Iterate through the 8 possible dividers until we actually link with the device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__vlynq_try_remote": {
        "description": "A VLYNQ remote device can clock the VLYNQ bus master using a dedicated clock line. In that case, both the remove device and the bus master should have the same serial clock dividers configured. Iterate through the 8 possible dividers until we actually link with the device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:vbg_get_gdev": {
        "description": "Retrieve the vbg_gdev value and unlock the vbg_gdev_mutex.",
        "pre": {
            "vbg_gdev": "!=null",
            "vbg_gdev_mutex": "locked"
        },
        "post": {
            "return_value": {
                "constraints": [
                    "vbg_gdev != null",
                    "ERR_PTR(-ENODEV)"
                ]
            }
        }
    }
},
{
    "kprobe:vbg_get_gdev": {
        "description": "Function to get vbg_gdev",
        "pre": {
            "mutex": "unlocked"
        }
    }
},
{
    "kretprobe:vbg_put_gdev": {
        "description": "This function stops vbg_pci_remove from removing the device from underneath vboxsf. vboxsf will only hold a reference for a short while.",
        "pre": {
            "vbg_gdev": "==true",
            "vbg_gdev_mutex": "unlocked"
        },
        "post": {
            "return_value": {
                "constraints": "==vbg_gdev"
            }
        }
    }
},
{
    "kprobe:vbg_put_gdev": {
        "description": "Stop vbg_pci_remove from removing the device from underneath vboxsf.",
        "pre": {
            "gdev": "!=null"
        }
    }
},
{
    "kretprobe:hgcm_call_preprocess": {
        "description": "Preprocess the parameters for the hgcm_call function.",
        "pre": {
            "parms": "!=null",
            "parm_count": "!=null",
            "bounce_bufs": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:hgcm_call_preprocess": {
        "description": "Preprocess the parameters for the HGCM call.",
        "pre": {
            "parms": "!=null",
            "parm_count": "!=null",
            "bounce_bufs": "!=null",
            "size": "!=null"
        }
    }
},
S,
{
    "kprobe:mtd_concat_create": {
        "description": "Create a concatenated MTD device from the given subdevices.",
        "pre": {
            "subdev": "!=null",
            "num_devs": ">=0"
        }
    }
},
{
    "kretprobe:mtk_ecc_get_stats": {
        "description": "Get statistics for MTK ECC",
        "pre": {
            "ecc": "!=null",
            "stats": "!=null",
            "sectors": ">=0",
            "bitflips": ">=0",
            "err": ">=0",
            "offset": ">=0",
            "i": ">=0",
            "err_shift": ">=0",
            "err_mask": ">=0",
            "uncorrectable errors": "not present"
        },
        "post": {
            "stats->failed": "stats->failed + 1",
            "stats->corrected": "stats->corrected + err",
            "bitflips": "max_t(u32, bitflips, err)",
            "stats->bitflips": "bitflips"
        }
    }
},
{
    "kprobe:mtk_ecc_get_stats": {
        "description": "Get statistics for MTK ECC",
        "pre": {
            "ecc": "!=null",
            "stats": "!=null",
            "sectors": ">=0",
            "bitflips": ">=0",
            "err": ">=0",
            "offset": ">=0",
            "i": ">=0",
            "err_shift": ">=0",
            "err_mask": ">=0",
            "uncorrectable errors": "not present"
        }
    }
},
{
    "kretprobe:of_mtk_ecc_get": {
        "description": "Get the MTK ECC structure for the given device node.",
        "pre": {
            "of_node": "!=null",
            "np": "==null"
        },
        "post": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_mtk_ecc_get": {
        "description": "Get the MTK ECC structure for the given device node.",
        "pre": {
            "of_node": "!=null",
            "np": "!=null"
        }
    }
},
{
    "kretprobe:mtk_ecc_enable": {
        "description": "Enable ECC for MTK chip",
        "pre": {
            "op": "in [ECC_ENCODE, ECC_DECODE]",
            "ret": "==0",
            "config->mode": "==ECC_NFI_MODE",
            "op != ECC_ENCODE || config->mode != ECC_NFI_MODE": {
                "ecc->caps->pg_irq_sel": "in [0, 1]"
            }
        }
    }
},
{
    "mtk_ecc_enable": {
        "description": "Enable MTK ECC",
        "pre": {
            "config->op": "!=null",
            "config->mode": "in [ECC_NFI_MODE]",
            "op": "in [ECC_ENCODE]",
            "ecc->lock": "!=null",
            "ecc->dev": "!=null"
        }
    }
},
{
    "kretprobe:mtk_ecc_disable": {
        "description": "Disable the ECC if the value read from ECC_CTL_REG(op) is not ECC_OP_ENABLE.",
        "pre": {
            "ecc": "!=null",
            "op": "in [ECC_ENCODE, ECC_DECODE]",
            "readw(ecc->regs + ECC_CTL_REG(op))": "!= ECC_OP_ENABLE"
        }
    }
},
{
    "kprobe:if (readw(ecc->regs + ECC_CTL_REG(op)) != ECC_OP_ENABLE)op = ECC_DECODE;/* disable it `": {
        "description": "Disable ECC if the value read from ECC_CTL_REG(op) is not ECC_OP_ENABLE.",
        "pre": {
            "ecc": {
                "regs": "!=null"
            },
            "op": {
                "in": ["ECC_ENCODE", "ECC_DECODE"]
            }
        }
    }
},
{
    "kretprobe:mtk_ecc_encode": {
        "description": "Encode data using MTK ECC",
        "pre": {
            "ecc": "!=null",
            "config": "!=null",
            "data": "!=null",
            "bytes": "!=null",
            "ecc->dev": "!=null",
            "config->op": "ECC_ENCODE",
            "config->addr": "dma_map_single(ecc->dev, data, bytes, DMA_TO_DEVICE)",
            "ret": "!dma_mapping_error(ecc->dev, config->addr)"
        },
        "post": {
            "ret": "0",
            "ecc->dev": "unchanged",
            "config->addr": "unchanged"
        }
    }
},
{
    "kprobe:mtk_ecc_encode": {
        "description": "Encode data using MTK ECC",
        "pre": {
            "config->strength": "!=null",
            "ecc->caps->parity_bits": "!=null"
        }
    }
},
S,
{
    "kprobe:nand_ecc_init_ctx": {
        "description": "Initialize the ECC context for a NAND device.",
        "pre": {
            "nand": "!=null"
        }
    }
},
{
    "kretprobe:nand_ecc_prepare_io_req": {
        "description": "Prepare an IO request",
        "pre": {
            "nand": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kprobe:nand_ecc_prepare_io_req": {
        "description": "Prepare an IO request",
        "pre": {
            "nand": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kretprobe:nand_ecc_finish_io_req": {
        "description": "Finish an IO request",
        "pre": {
            "nand": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kprobe:nand_ecc_finish_io_req": {
        "description": "Finish an IO request",
        "pre": {
            "nand": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kretprobe:nand_ecc_is_strong_enough": {
        "description": "Check if the chip configuration meets the datasheet requirements.",
        "pre": {
            "nand": "!=null",
            "A": ">= X",
            "B": ">= Y",
            "X": ">= 0",
            "Y": ">= 0",
            "A * B": ">= X * Y"
        }
    }
},
{
    "kprobe:nand_ecc_is_strong_enough": {
        "description": "Check if the chip configuration meets the datasheet requirements.",
        "pre": {
            "nand": "!=null",
            "A": ">= X",
            "B": ">= Y",
            "X": "!=null",
            "Y": "!=null",
            "A * B": ">= X * Y"
        }
    }
},
{
    "kretprobe:nand_ecc_register_on_host_hw_engine": {
        "description": "Register an on-host hardware engine for NAND ECC.",
        "pre": {
            "engine": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:nand_ecc_register_on_host_hw_engine": {
        "description": "Registers a NAND ECC engine on the host hardware.",
        "pre": {
            "engine": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
S,
S,
{
    "kretprobe:nand_ecc_sw_bch_calculate": {
        "description": "Calculate the ECC corresponding to a data block",
        "pre": {
            "nand": "!=null",
            "buf": "!=null",
            "code": "!=null"
        }
    }
},
S,
{
    "kretprobe:nand_ecc_sw_bch_correct": {
        "description": "Detect, correct and report bit error(s)",
        "pre": {
            "nand": "!=null",
            "buf": "!=null",
            "read_ecc": "!=null",
            "calc_ecc": "!=null"
        }
    }
},
{
    "kprobe:nand_ecc_sw_bch_correct": {
        "description": "Detect, correct and report bit error(s)",
        "pre": {
            "nand": "!=null",
            "buf": "!=null",
            "read_ecc": "!=null",
            "calc_ecc": "!=null"
        }
    }
},
{
    "kretprobe:nand_ecc_sw_bch_init_ctx": {
        "description": "Initialize the BCH ECC context for NAND devices.",
        "pre": {
            "nand": "!=null",
            "conf": "!=null",
            "mtd": "!=null",
            "engine_conf": "!=null",
            "code_size": ">=0",
            "nsteps": ">=0",
            "ret": ">=0",
            "mtd->oobsize": "<64"
        }
    }
},
{
    "kprobe:nand_ecc_sw_bch_init_ctx": {
        "description": "Initialize the software BCH ECC context for a NAND device.",
        "pre": {
            "nand": "!=null",
            "nand->ecc.ctx.conf": "!=null",
            "nand->ecc.ctx.conf->mtd": "!=null",
            "nand->ecc.ctx.conf->mtd->oobsize": "< 64"
        }
    }
},
{
    "kretprobe:u32 cur": {
        "description": "Calculate the accumulated parities per byte.",
        "pre": {
            "buf": "!=null",
            "step_size": "is an unsigned int",
            "code": "!=null",
            "sm_order": "is a boolean",
            "bp": "is a u32",
            "eccsize_mult": "is calculated based on step_size"
        }
    }
},
{
    "kprobe:u32 cur;/* rp0..rp17 are the various accumulated parities (per byte) */": {
        "description": "Helper function for calculating accumulated parities per byte.",
        "pre": {
            "buf": "!=null",
            "step_size": "is an unsigned int",
            "code": "!=null",
            "sm_order": "is a boolean",
            "bp": "is a u32",
            "eccsize_mult": "is a u32",
            "eccsize_mult == 1 when step_size == 256"
        }
    }
},
{
    "kretprobe:nand_ecc_sw_hamming_calculate": {
        "description": "Calculate 3-byte ECC for 256512-byte block",
        "pre": {
            "nand": "!=null",
            "buf": "!=null",
            "code": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:nand_ecc_sw_hamming_init_ctx": {
        "description": "Initialize the software Hamming ECC engine for NAND devices.",
        "pre": {
            "nand": "!=null",
            "nand->ecc.ctx.conf": "!=null",
            "nand->ecc.ctx.conf->engine_type": "==NAND_ECC_ENGINE_TYPE_SOFT",
            "nand->ecc.ctx.conf->algo": "==NAND_ECC_ALGO_HAMMING",
            "nand->ecc.ctx.conf->step_size": "!=256 && !=512",
            "nand->ecc.ctx.conf->strength": "==1",
            "nanddev_to_mtd(nand)": "!=null",
            "nanddev_to_mtd(nand)->ooblayout": "!=null",
            "nanddev_to_mtd(nand)->oobsize": "in [8, 16, 64, 128]",
            "nand_get_small_page_ooblayout()": "!=null",
            "nand_get_large_page_hamming_ooblayout()": "!=null",
            "mtd_set_ooblayout(nanddev_to_mtd(nand), nand_get_small_page_ooblayout())": "success",
            "mtd_set_ooblayout(nanddev_to_mtd(nand), nand_get_large_page_hamming_ooblayout())": "success",
            "nand_ecc_sw_hamming_init_ctx->ret": "==0",
            "kzalloc(sizeof(*engine_conf), GFP_KERNEL)": "!=null",
            "kzalloc(mtd->oobsize, GFP_KERNEL)": "!=null",
            "kzalloc(mtd->oobsize, GFP_KERNEL)": "!=null"
        }
    }
},
{
    "kprobe:nand_ecc_sw_hamming_init_ctx": {
        "description": "Initialize the software Hamming ECC engine for NAND devices.",
        "pre": {
            "nand": "!=null",
            "nand->ecc.ctx.conf": "!=null",
            "nand->ecc.ctx.conf->engine_type": "==NAND_ECC_ENGINE_TYPE_SOFT",
            "nand->ecc.ctx.conf->algo": "==NAND_ECC_ALGO_HAMMING",
            "nand->ecc.ctx.conf->step_size": "!=256 && !=512",
            "nand->ecc.ctx.conf->strength": "==1",
            "mtd": "!=null",
            "mtd->ooblayout": "!=null",
            "mtd->oobsize": "in [8, 16, 64, 128]",
            "mtd->oobsize == 8 || mtd->oobsize == 16": "mtd->ooblayout == nand_get_small_page_ooblayout()",
            "mtd->oobsize == 64 || mtd->oobsize == 128": "mtd->ooblayout == nand_get_large_page_hamming_ooblayout()",
            "ret": "==0",
            "engine_conf": "==null",
            "engine_conf = kzalloc(sizeof(*engine_conf), GFP_KERNEL)": "ret == 0",
            "!engine_conf": "ret == 0",
            "ret = nand_ecc_init_req_tweaking(&engine_conf->req_ctx, nand)": "engine_conf != null",
            "ret == 0": "engine_conf != null",
            "engine_conf->code_size = 3": "engine_conf != null",
            "engine_conf->calc_buf = kzalloc(mtd->oobsize, GFP_KERNEL)": "engine_conf != null",
            "engine_conf->code_buf = kzalloc(mtd->oobsize, GFP_KERNEL)": "engine_conf != null",
            "!engine_conf->calc_buf || !engine_conf->code_buf": "engine_conf != null"
        }
    }
},
{
    "kretprobe:flexonenand_addr": {
        "description": "Return address of the block",
        "pre": {
            "this": "!=null",
            "block": "!=null"
        }
    }
},
S,
{
    "kretprobe:flexonenand_region": {
        "description": "[Flex-OneNAND] Return erase region of addr",
        "pre": {
            "mtd": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:flexonenand_region": {
        "description": "[Flex-OneNAND] Return erase region of addr",
        "pre": {
            "mtd": "!=null",
            "addr": "!=null",
            "addr": ">=0",
            "addr": "<=mtd->size"
        }
    }
},
{
    "kretprobe:nand_check_erased_ecc_chunk": {
        "description": "Check if an ECC chunk contains (almost) only 0xff data.",
        "pre": {
            "data": "!=null",
            "datalen": ">=0",
            "ecc": "!=null",
            "ecclen": ">=0",
            "extraoob": "null or !=null",
            "extraooblen": ">=0",
            "bitflips_threshold": ">=0"
        }
    }
},
{
    "kprobe:nand_check_erased_ecc_chunk": {
        "description": "Check if an ECC chunk contains (almost) only 0xff data.",
        "pre": {
            "data": "!=null",
            "datalen": ">=0",
            "ecc": "!=null",
            "ecclen": ">=0",
            "extraoob": "null or !=null",
            "extraooblen": ">=0",
            "bitflips_threshold": ">=0"
        }
    }
},
{
    "kretprobe:nand_read_page_raw_notsupp": {
        "description": "dummy read raw page function",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        },
        "post": {
            "return": "-ENOTSUPP"
        }
    }
},
{
    "kprobe:nand_read_page_raw_notsupp": {
        "description": "dummy read raw page function",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        },
        "post": {
            "return": "-ENOTSUPP"
        }
    }
},
{
    "kretprobe:nand_monolithic_read_page_raw": {
        "description": "Monolithic page read in raw mode",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "in [0, 1]",
            "page": "!=null"
        }
    }
},
{
    "kprobe:nand_monolithic_read_page_raw": {
        "description": "Monolithic page read in raw mode",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "in [0, 1]",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:nand_read_oob_std": {
        "description": "The most common OOB data read function",
        "pre": {
            "chip": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:nand_read_oob_std": {
        "description": "[REPLACEABLE] the most common OOB data read function",
        "pre": {
            "chip": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:nand_write_oob_std": {
        "description": "[REPLACEABLE] the most common OOB data write function",
        "pre": {
            "chip": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:nand_write_oob_std": {
        "description": "[REPLACEABLE] the most common OOB data write function",
        "pre": {
            "chip": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:nand_write_page_raw_notsupp": {
        "description": "dummy raw page write function",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        },
        "post": {
            "return": "-ENOTSUPP"
        }
    }
},
{
    "kprobe:nand_write_page_raw_notsupp": {
        "description": "dummy raw page write function",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        },
        "post": {
            "return": "-ENOTSUPP"
        }
    }
},
{
    "kretprobe:nand_monolithic_write_page_raw": {
        "description": "Monolithic page write in raw mode",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:nand_monolithic_write_page_raw": {
        "description": "Monolithic page write in raw mode",
        "pre": {
            "chip": "!=null",
            "buf": "!=null",
            "oob_required": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:rawnand_dt_parse_gpio_cs": {
        "description": "Parse the gpio-cs property of a controller",
        "pre": {
            "dev": "!=null",
            "cs_array": "!=null",
            "ncs_array": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rawnand_dt_parse_gpio_cs": {
        "description": "Parse the gpio-cs property of a controller",
        "pre": {
            "dev": "!=null",
            "cs_array": "!=null",
            "ncs_array": "!=null"
        }
    }
},
{
    "kretprobe:nand_scan_with_ids": {
        "description": "[NAND Interface] Scan for the NAND device",
        "pre": {
            "chip": "!=null",
            "maxchips": ">=0",
            "ids": "optional"
        }
    }
},
{
    "kprobe:nand_scan_with_ids": {
        "description": "[NAND Interface] Scan for the NAND device",
        "pre": {
            "chip": "!=null",
            "maxchips": ">=0",
            "ids": "optional"
        }
    }
},
{
    "kretprobe:elm_config": {
        "description": "Configure ELM module",
        "pre": {
            "dev": "!=null",
            "bch_type": "in [BCH_TYPE_1, BCH_TYPE_2, BCH_TYPE_3]",
            "ecc_steps": ">=0",
            "ecc_step_size": ">=0",
            "ecc_syndrome_size": ">=0"
        }
    }
},
{
    "kprobe:elm_config": {
        "description": "Configure ELM module",
        "pre": {
            "dev": "!=null",
            "bch_type": "in [BCH_TYPE_1, BCH_TYPE_2, BCH_TYPE_3]",
            "ecc_steps": ">=0",
            "ecc_step_size": ">=0",
            "ecc_syndrome_size": ">=0"
        }
    }
},
{
    "kretprobe:elm_decode_bch_error_page": {
        "description": "Locate error position",
        "pre": {
            "dev": "!=null",
            "ecc_calc": "!=null",
            "err_vec": "!=null",
            "err_vec[].error_reported": "!=null"
        }
    }
},
S,
{
    "kretprobe:nand_get_set_features_notsupp": {
        "description": "setget features stub returning -ENOTSUPP",
        "pre": {
            "chip": "!=null",
            "addr": "!=null",
            "subfeature_param": "!=null"
        }
    }
},
{
    "kprobe:nand_get_set_features_notsupp": {
        "description": "Setget features stub returning -ENOTSUPP",
        "pre": {
            "chip": "!=null",
            "addr": "!=null",
            "subfeature_param": "!=null"
        }
    }
},
{
    "kretprobe:denali_calc_ecc_bytes": {
        "description": "BCH code. Denali requires ecc.bytes to be multiple of 2",
        "pre": {
            "step_size": "!=null",
            "strength": "!=null",
            "return": "is_multiple_of(2)"
        }
    }
},
{
    "kprobe:denali_calc_ecc_bytes": {
        "description": "BCH code. Denali requires ecc.bytes to be multiple of 2",
        "pre": {
            "step_size": "!=null",
            "strength": "!=null",
            "ecc.bytes": "% 2 == 0"
        }
    }
},
{
    "kretprobe:denali_init": {
        "description": "Initialize the denali controller",
        "pre": {
            "!denali->revision": true,
            "denali->revision": "= swab16(ioread32(denali->reg + REVISION))",
            "denali->nbanks": "= 1 << FIELD_GET(FEATURES__N_BANKS, features)"
        }
    }
},
{
    "kprobe:denali_init": {
        "description": "Initialize the denali controller.",
        "pre": {
            "!denali->revision": true,
            "denali->revision": "swab16(ioread32(denali->reg + REVISION))",
            "denali->nbanks": "(1 << FIELD_GET(FEATURES__N_BANKS, features))",
            "features": "ioread32(denali->reg + FEATURES)"
        }
    }
},
{
    "kretprobe:nand_create_bbt": {
        "description": "[NAND Interface] Select a default bad block table for the device",
        "pre": {
            "this": "!=null"
        }
    }
},
{
    "kprobe:nand_create_bbt": {
        "description": "[NAND Interface] Select a default bad block table for the device",
        "pre": {
            "this": "!=null"
        }
    }
},
{
    "kretprobe:devm_atmel_pmecc_get": {
        "description": "Get the Atmel PMECC structure for the given user device.",
        "pre": {
            "userdev": "!=null",
            "userdev->of_node": "!=null",
            "ecc-engine": "exists in userdev->of_node",
            "pmecc": "exists",
            "np": "exists"
        }
    }
},
{
    "kprobe:devm_atmel_pmecc_get": {
        "description": "Get the Atmel PMECC structure for the given device.",
        "pre": {
            "userdev": "!=null",
            "userdev->of_node": "!=null",
            "ecc-engine": "!=null",
            "pmecc": "!=null",
            "np": "!=null"
        }
    }
},
{
    "kretprobe:mtd->_read = lpddr_read;mtd->type = MTD_NORFLASH;mtd->flags = MTD_CAP_NORFLASH;mtd->flags &= ~MTD_BIT_WRITEABLE;mtd->_erase = lpddr_erase;mtd->_write = lpddr_write_buffers;mtd->_writev = lpddr_writev;mtd->_lock = lpddr_lock;mtd->_unlock = lpddr_unlock;if (map_is_linear(map))": {
        "description": "lpddr_cmdset function",
        "pre": {
            "mtd->_read": "= lpddr_read",
            "mtd->type": "= MTD_NORFLASH",
            "mtd->flags": "= MTD_CAP_NORFLASH",
            "mtd->flags &= ~MTD_BIT_WRITEABLE": "true",
            "mtd->_erase": "= lpddr_erase",
            "mtd->_write": "= lpddr_write_buffers",
            "mtd->_writev": "= lpddr_writev",
            "mtd->_lock": "= lpddr_lock",
            "mtd->_unlock": "= lpddr_unlock",
            "map_is_linear(map)": "true"
        }
    }
},
{
    "kprobe:mtd->_read = lpddr_read;mtd->type = MTD_NORFLASH;mtd->flags = MTD_CAP_NORFLASH;mtd->flags &= ~MTD_BIT_WRITEABLE;mtd->_erase = lpddr_erase;mtd->_write = lpddr_write_buffers;mtd->_writev = lpddr_writev;mtd->_lock = lpddr_lock;mtd->_unlock = lpddr_unlock;if (map_is_linear(map))": {
        "description": "lpddr_cmdset function",
        "pre": {
            "mtd->_read": "= lpddr_read",
            "mtd->type": "= MTD_NORFLASH",
            "mtd->flags": "= MTD_CAP_NORFLASH",
            "mtd->flags": "&= ~MTD_BIT_WRITEABLE",
            "mtd->_erase": "= lpddr_erase",
            "mtd->_write": "= lpddr_write_buffers",
            "mtd->_writev": "= lpddr_writev",
            "mtd->_lock": "= lpddr_lock",
            "mtd->_unlock": "= lpddr_unlock",
            "map_is_linear(map)": ""
        }
    }
},
{
    "kretprobe:cfi_build_cmd_addr": {
        "description": "Modify the unlock address if we are in compatibility mode.",
        "pre": {
            "cmd_ofs": "& 0xff == 0xaa",
            "map": "unknown",
            "cfi": "unknown",
            "bankwidth": "unknown",
            "interleave": "unknown",
            "type": "unknown"
        }
    }
},
{
    "cfi_build_cmd_addr": {
        "description": "Calculate the address based on the given arguments.",
        "pre": {
            "cmd_ofs": "any uint32_t value",
            "map": "!=null",
            "cfi": "!=null"
        }
    }
},
{
    "cfi_build_cmd_addr": {
        "description": "",
        "pre": {
            "cmd_ofs": "!=null",
            "map": "!=null",
            "cfi": "!=null",
            "bankwidth": "> (type * interleave)",
            "cmd_ofs & 0xff": "== 0xaa"
        },
        "post": {
            "addr": "updated with ((type >> 1) * interleave)"
        }
    }
},
{
    "cfi_build_cmd_addr": {
        "description": "Calculate the address based on the given parameters.",
        "pre": {
            "cmd_ofs": "(cmd_ofs & 0xff) == 0xaa",
            "map": "!=null",
            "cfi": "!=null"
        },
        "post": {
            "bankwidth": "map_bankwidth(map)",
            "interleave": "cfi_interleave(cfi)",
            "type": "cfi->device_type",
            "addr": "(type >> 1) * interleave"
        }
    }
},
S,
{
    "if (map_bankwidth_is_large(map))": {
        "description": "Check if the bankwidth of the map is large",
        "pre": {
            "map": {
                "bankwidth_is_large": true
            }
        }
    }
},
{
    "kretprobe:cfi_qry_mode_on": {
        "description": "Switch the CFI driver into Query Mode.",
        "pre": {
            "map": "!=null",
            "adr": "!=null",
            "size": "!=null",
            "name": "!=null",
            "cfi": "!=null",
            "base": "0",
            "ofs_factor": "!=null",
            "i": "!=null",
            "extp": "null"
        }
    }
},
{
    "kprobe:cfi_qry_mode_on": {
        "description": "Read in the Extended Query Table",
        "pre": {
            "base": "any",
            "map": "any",
            "cfi": "any"
        }
    }
},
S,
{
    "kprobe:i = 0;/* Skip all erase regions which are ended before the start of the requested erase. Actually, to save on the calculations, we skip to the first erase region which starts after the start of the requested erase, and then go back one.*/": {
        "description": "Skip erase regions before the start of the requested erase",
        "pre": {
            "mtd": "!=null",
            "frob": "!=null",
            "ofs": "!=null",
            "len": "!=null",
            "thunk": "!=null"
        }
    }
},
{
    "kretprobe:do_map_probe": {
        "description": "Probe a map and return the corresponding MTD info.",
        "pre": {
            "name": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kprobe:do_map_probe": {
        "description": "Probe the map with the given name and map info.",
        "pre": {
            "name": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kretprobe:module_put": {
        "description": "Destroy an MTD device which was created for a map device. Make sure the MTD device is already unregistered before calling this.",
        "pre": {
            "drv": "!=null",
            "drv->module": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:module_put": {
        "description": "Destroy an MTD device which was created for a map device. Make sure the MTD device is already unregistered before calling this.",
        "pre": {
            "drv": {
                "module": "!=null"
            },
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:genprobe_ident_chips": {
        "description": "Probe the map to identify chips and return the result.",
        "pre": {
            "map": "!=null",
            "cp": "!=null"
        },
        "post": {
            "cfi": "!=null",
            "map->fldrv_priv": "=cfi"
        }
    }
},
{
    "kprobe:genprobe_ident_chips": {
        "description": "Generate probe identification chips.",
        "pre": {
            "map": "!=null",
            "cp": "!=null"
        },
        "post": {
            "cfi": "!=null",
            "map->fldrv_priv": "cfi"
        }
    }
},
{
    "kretprobe:zcrypt_queue_register": {
        "description": "Register a crypto queue device.",
        "pre": {
            "zq": "!=null"
        }
    }
},
{
    "kprobe:zcrypt_queue_register": {
        "description": "Register a crypto queue device.",
        "pre": {
            "zq": "!=null"
        }
    }
},
{
    "kretprobe:zcrypt_queue_unregister": {
        "description": "Unregister a crypto queue device.",
        "pre": {
            "zq": "!=null"
        }
    }
},
{
    "kprobe:zcrypt_queue_unregister": {
        "description": "Unregister a crypto queue device.",
        "pre": {
            "zq": "!=null"
        }
    }
},
{
    "kretprobe:static DEFINE_SPINLOCK(ap_domain_lock);module_param_named(domain, ap_domain_index, int, 0440);MODULE_PARM_DESC(domain, \"domain index for ap devices\");EXPORT_SYMBOL(ap_domain_index)\": {
        "description": "Adjunct Processor Domain Index",
        "pre": {
            "ap_domain_index": "-1"
        }
    }
},
{
    "kprobe:static DEFINE_SPINLOCK(ap_domain_lock);module_param_named(domain, ap_domain_index, int, 0440);MODULE_PARM_DESC(domain, \"domain index for ap devices\");EXPORT_SYMBOL(ap_domain_index)\": {
        "description": "ap_domain_index = -1;  Adjunct Processor Domain Index",
        "pre": {
            "ap_domain_index": "-1"
        }
    }
},
{
    "kretprobe:ap_test_config_usage_domain": {
        "description": "Test whether an AP usage domain is configured.",
        "pre": {
            "domain": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:ap_test_config_usage_domain": {
        "description": "Test whether an AP usage domain is configured.",
        "pre": {
            "domain": "!=null"
        }
    }
},
{
    "kretprobe:ap_test_config_ctrl_domain": {
        "description": "Test whether an AP control domain is configured.",
        "pre": {
            "domain": "!=null"
        }
    }
},
{
    "kprobe:ap_test_config_ctrl_domain": {
        "description": "Test whether an AP control domain is configured.",
        "pre": {
            "domain": "!=null",
            "domain": "unsigned int",
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:ap_owned_by_def_drv": {
        "description": "Indicates whether an AP adapter is reserved for the default host driver or not.",
        "pre": {
            "card": "!=null",
            "queue": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ap_owned_by_def_drv": {
        "description": "Indicates whether an AP adapter is reserved for the default host driver or not.",
        "pre": {
            "card": "!=null",
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:ap_apqn_in_matrix_owned_by_def_drv": {
        "description": "Indicates whether every APQN contained in a set is reserved for the host drivers or not.",
        "pre": {
            "apm": "!=null",
            "aqm": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ap_apqn_in_matrix_owned_by_def_drv": {
        "description": "Indicates whether every APQN contained in a set is reserved for the host drivers or not.",
        "pre": {
            "apm": "!=null",
            "aqm": "!=null"
        }
    }
},
{
    "kretprobe:ap_bus_force_rescan": {
        "description": "Processing an asynchronous bus rescan",
        "pre": {
            "ap_config_timer": "!=null",
            "system_long_wq": "!=null",
            "ap_scan_work": "!=null"
        }
    }
},
{
    "kprobe:ap_bus_force_rescan": {
        "description": "Processing an asynchronous bus rescan",
        "pre": {
            "del_timer": {
                "arg": "&ap_config_timer"
            },
            "queue_work": {
                "arg1": "system_long_wq",
                "arg2": "&ap_scan_work"
            },
            "flush_work": {
                "arg": "&ap_scan_work"
            }
        },
        "post": {
            "EXPORT_SYMBOL": "ap_bus_force_rescan"
        }
    }
},
{
    "kretprobe:ap_parse_mask_str": {
        "description": "Parse the mask string and update the bitmap based on the given bits.",
        "pre": {
            "str": "!=null",
            "bitmap": "!=null",
            "bits": "% 8 == 0",
            "lock": "!=null"
        }
    }
},
{
    "kprobe:ap_parse_mask_str": {
        "description": "Parse the mask string and update the bitmap based on the given bits.",
        "pre": {
            "str": "!=null",
            "bitmap": "!=null",
            "bits": "% 8 == 0",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:ap_queue_status__ap_send": {
        "description": "Send message to adjunct processor queue.",
        "pre": {
            "qid": "!=null",
            "psmid": "!=null",
            "msg": "!=null",
            "msglen": "!=null",
            "special": "!=null"
        }
    }
},
{
    "kprobe:ap_queue_status__ap_send": {
        "description": "Send message to adjunct processor queue.",
        "pre": {
            "qid": "!=null",
            "psmid": "!=null",
            "msg": "!=null",
            "msglen": "!=null",
            "special": "!=null"
        }
    }
},
{
    "kretprobe:ap_queue_message": {
        "description": "Queue a request to an AP device.",
        "pre": {
            "aq": "!=null",
            "ap_msg": "!=null"
        }
    }
},
{
    "kprobe:ap_queue_message": {
        "description": "Queue a request to an AP device.",
        "pre": {
            "aq": "!=null",
            "ap_msg": "!=null"
        }
    }
},
{
    "kretprobe:ap_cancel_message": {
        "description": "Cancel a crypto request.",
        "pre": {
            "aq": "!=null",
            "ap_msg": "!=null"
        }
    }
},
{
    "kprobe:ap_cancel_message": {
        "description": "Cancel a crypto request.",
        "pre": {
            "aq": "!=null",
            "ap_msg": "!=null"
        }
    }
},
{
    "kretprobe:ap_q_supports_bind": {
        "description": "Check if AP queue supports bind operation.",
        "pre": {},
        "post": {
            "ret": "==true"
        }
    }
},
S,
S,
{
    "kprobe:cca_genseckey": {
        "description": "Generate secure key using the provided input arguments.",
        "pre": {
            "cardnr": "!=null",
            "domain": "!=null",
            "keybitsize": "!=null",
            "seckey": "!=null",
            "i": "not used in the function",
            "rc": "not used in the function",
            "keysize": "not used in the function",
            "seckeysize": "not used in the function",
            "mem": "not used in the function",
            "ptr": "not used in the function",
            "preqcblk": "not used in the function",
            "prepcblk": "not used in the function",
            "xcrb": "not used in the function",
            "preqparm": "not used in the function",
            "kgrepparm": "not used in the function"
        }
    }
},
S,
S,
{
    "kretprobe:cca_sec2protkey": {
        "description": "Converts a secure key to a protected key using the specified parameters.",
        "pre": {
            "cardnr": "!=null",
            "domain": "!=null",
            "seckey": "!=null",
            "protkey": "!=null",
            "protkeylen": "!=null",
            "protkeytype": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:cca_ecc2protkey": {
        "description": "The cca_ecc2protkey function",
        "pre": {
            "cardnr": "!=null",
            "domain": "!=null",
            "key": "!=null",
            "protkey": "!=null",
            "protkeylen": "!=null",
            "protkeytype": "!=null"
        }
    }
},
{
    "kprobe:cca_ecc2protkey": {
        "description": "Converts ECC key to protected key.",
        "pre": {
            "cardnr": "!=null",
            "domain": "!=null",
            "key": "!=null",
            "protkey": "!=null",
            "protkeylen": "!=null",
            "protkeytype": "!=null"
        }
    }
},
{
    "kretprobe:alloc_and_prep_cprbmem": {
        "description": "Allocate and prepare CPRB memory",
        "pre": {
            "parmbsize": ">0",
            "&mem": "!=null",
            "&preqcblk": "!=null",
            "&prepcblk": "!=null"
        }
    }
},
{
    "kprobe:alloc_and_prep_cprbmem": {
        "description": "Allocate and prepare CPRB memory for the given parameters.",
        "pre": {
            "parmbsize": "!=null",
            "mem": "!=null",
            "preqcblk": "!=null",
            "prepcblk": "!=null"
        }
    }
},
{
    "kretprobe:ep11_findcard2": {
        "description": "Fetch status of all crypto cards",
        "pre": {
            "apqns": "!=null",
            "nr_apqns": "!=null",
            "cardnr": "!=null",
            "domain": "!=null",
            "minhwtype": "!=null",
            "minapi": "!=null",
            "wkvp": "!=null",
            "device_status": "!=null",
            "_apqns": "null",
            "_nr_apqns": "0",
            "i": "!=null",
            "card": "!=null",
            "dom": "!=null",
            "rc": "-ENOMEM",
            "edi": "!=null",
            "eci": "!=null"
        }
    }
},
S,
{
    "kretprobe:ep11_get_card_info": {
        "description": "Get card information for the given card.",
        "pre": {
            "card": "!=null",
            "info": "!=null",
            "verify": "!=null"
        }
    }
},
{
    "kprobe:ep11_get_card_info": {
        "description": "Get card information for the specified card.",
        "pre": {
            "card": "!=null",
            "info": {
                "API_ord_nr": "!=null",
                "firmware_id": "!=null",
                "FW_major_vers": "!=null",
                "FW_minor_vers": "!=null",
                "CSP_major_vers": "!=null",
                "CSP_minor_vers": "!=null",
                "fwid": "!=null",
                "xcp_config_hash": "!=null",
                "CSP_config_hash": "!=null",
                "serial": "!=null",
                "module_date_time": "!=null",
                "op_mode": "!=null",
                "PKCS11_flags": "!=null",
                "ext_flags": "!=null",
                "domains": "!=null",
                "sym_state_bytes": "!=null",
                "digest_state_bytes": "!=null",
                "pin_blob_bytes": "!=null",
                "SPKI_bytes": "!=null",
                "priv_key_blob_bytes": "!=null",
                "sym_blob_bytes": "!=null",
                "max_payload_bytes": "!=null",
                "CP_profile_bytes": "!=null",
                "max_CP_index": "!=null"
            },
            "verify": "!=null"
        }
    }
},
S,
{
    "kprobe:ep11_get_domain_info": {
        "description": "domain info query",
        "pre": {
            "card": "!=null",
            "domain": "!=null",
            "info": "!=null",
            "info->dom_index": "!=null",
            "info->cur_WK_VP": "!=null",
            "info->new_WK_VP": "!=null",
            "info->dom_flags": "!=null",
            "info->op_mode": "!=null"
        }
    }
},
{
    "kretprobe:req = alloc_cprb": {
        "description": "Allocate memory for the cprb structure",
        "pre": {
            "sizeof(struct keygen_req_pl)": "!=null"
        }
    },
    "kretprobe:if (!req)goto out": {
        "description": "Check if the allocation was successful",
        "pre": {
            "req": "==null"
        }
    },
    "kretprobe:req_pl = (struct keygen_req_pl *)(((u8 *)req) + sizeof(*req))": {
        "description": "Calculate the pointer to the req_pl structure",
        "pre": {
            "req": "!=null"
        }
    },
    "kretprobe:api = (!keygenflags || keygenflags & 0x00200000) ? 4 : 1": {
        "description": "Calculate the value of the api variable",
        "pre": {
            "keygenflags": "==null"
        }
    },
    "kretprobe:prep_head(&req_pl->head, sizeof(*req_pl), api, 21)": {
        "description": "Prepare the head structure",
        "pre": {
            "req_pl": "!=null",
            "api": "!=null"
        }
    }
},
{
    "ep11_genaeskey": {
        "description": "Generate AES key",
        "pre": {
            "keybitsize": "in [128, 192, 256]",
            "keygenflags": "in [0, (1 << 20)]"
        }
    }
},
{
    "kretprobe:ep11_clr2keyblob": {
        "description": "Clear a key blob and allocate memory for the temporary kek.",
        "pre": {
            "card": "!=null",
            "domain": "!=null",
            "keybitsize": "!=null",
            "keygenflags": "!=null",
            "clrkey": "!=null",
            "keybuf": "!=null",
            "keybufsize": "!=null",
            "rc": "!=null",
            "kb": "!=null",
            "encbuf": "!=null",
            "kek": "==null",
            "clrkeylen": "!=null",
            "keklen": "!=null",
            "encbuflen": "!=null",
            "keybitsize": "in [128, 192, 256]"
        }
    }
},
{
    "kprobe:ep11_clr2keyblob": {
        "description": "Clear a key blob and allocate memory for the temporary kek.",
        "pre": {
            "card": "!=null",
            "domain": "!=null",
            "keybitsize": "!=null",
            "keygenflags": "!=null",
            "clrkey": "!=null",
            "keybuf": "!=null",
            "keybufsize": "!=null",
            "keklen": "MAXEP11AESKEYBLOBSIZE",
            "kek": "kmalloc(keklen, GFP_ATOMIC)",
            "!kek": "null"
        }
    }
},
{
    "kretprobe:ep11_kblob2protkey": {
        "description": "Converts an ep11 key blob to a protected key.",
        "pre": {
            "card": "!=null",
            "dom": "!=null",
            "keyblob": "!=null",
            "keybloblen": "!=null",
            "protkey": "!=null",
            "protkeylen": "!=null",
            "protkeytype": "!=null",
            "rc": "== -EIO",
            "wkbuf": "== NULL",
            "wkbuflen": "!=null",
            "keylen": "!=null",
            "wki": {
                "version": "!=null",
                "res1": "!=null",
                "pkeytype": "!=null",
                "pkeybitsize": "!=null",
                "pkeysize": "!=null",
                "res2": "!=null",
                "pkey": "!=null"
            },
            "key": "!=null",
            "hdr": {
                "type": "== TOKTYPE_NON_CCA",
                "version": "in [TOKVER_EP11_AES_WITH_HEADER, TOKVER_EP11_ECC_WITH_HEADER]",
                "is_ep11_keyblob": "==(keyblob + sizeof(struct ep11kblob_header))"
            }
        }
    }
},
{
    "kprobe:ep11_kblob2protkey": {
        "description": "Converts an ep11 key blob to a protected key.",
        "pre": {
            "card": "!=null",
            "dom": "!=null",
            "keyblob": "!=null",
            "keybloblen": "!=null",
            "protkey": "!=null",
            "protkeylen": "!=null",
            "protkeytype": "!=null",
            "rc": "==-EIO",
            "wkbuf": "!=null",
            "wkbuflen": "!=null",
            "keylen": "!=null",
            "wki": {
                "version": "!=null",
                "res1": "!=null",
                "pkeytype": "!=null",
                "pkeybitsize": "!=null",
                "pkeysize": "!=null",
                "res2": "!=null",
                "pkey": "!=null"
            },
            "key": "!=null",
            "hdr": {
                "type": "TOKTYPE_NON_CCA",
                "version": "in [TOKVER_EP11_AES_WITH_HEADER, TOKVER_EP11_ECC_WITH_HEADER]",
                "is_ep11_keyblob": "==(keyblob + sizeof(struct ep11kblob_header))"
            }
        }
    }
},
S,
S,
{
    "kretprobe:zcrypt_send_cprb": {
        "description": "Send a control program request block to a zcrypt card.",
        "pre": {
            "tdom": "< AP_DOMAINS",
            "!ap_test_config_usage_domain(tdom)": true,
            "ap_test_config_ctrl_domain(tdom)": true
        },
        "post": {
            "tdom": "AUTOSEL_DOM",
            "pref_zc": "null",
            "pref_zq": "null"
        }
    }
},
{
    "kprobe:zcrypt_send_cprb": {
        "description": "Send a control program request block to a zcrypt card.",
        "pre": {
            "tdom": "< AP_DOMAINS",
            "!ap_test_config_usage_domain(tdom)": true,
            "ap_test_config_ctrl_domain(tdom)": true
        }
    }
},
{
    "kretprobe:zcrypt_send_ep11_cprb": {
        "description": "Send an extended performance 11 (EP11) cryptographic request block (CPRB) to a zcrypt card.",
        "pre": {
            "userspace": "bool",
            "perms": "!=null",
            "tr": "!=null",
            "xcrb": "!=null",
            "zc": "!=null",
            "pref_zc": "!=null",
            "zq": "!=null",
            "pref_zq": "!=null",
            "targets": "!=null",
            "target_num": "!=0",
            "wgt": "unsigned int",
            "pref_wgt": "unsigned int",
            "func_code": "unsigned int",
            "domain": "unsigned int",
            "ap_msg": "!=null",
            "cpen": "int",
            "qpen": "int",
            "qid": "int",
            "rc": "int",
            "mod": "!=null"
        }
    }
},
{
    "kprobe:zcrypt_send_ep11_cprb": {
        "description": "Send an ep11 CPRB to the zcrypt device.",
        "pre": {
            "userspace": "bool",
            "perms": "struct ap_perms",
            "tr": "struct zcrypt_track",
            "xcrb": "struct ep11_urb",
            "targets": "struct ep11_target_dev",
            "target_num": "unsigned short",
            "wgt": "unsigned int",
            "pref_wgt": "unsigned int",
            "func_code": "unsigned int",
            "domain": "unsigned int",
            "ap_msg": "struct ap_message",
            "cpen": "int",
            "qpen": "int",
            "qid": "int",
            "rc": "int",
            "mod": "struct module"
        },
        "post": {}
    }
},
S,
S,
{
    "kretprobe:zcrypt_card_register": {
        "description": "Register a crypto card device.",
        "pre": {
            "zc": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:zcrypt_card_register": {
        "description": "Register a crypto card device.",
        "pre": {
            "zc": "!=null"
        }
    }
},
{
    "kretprobe:zcrypt_card_unregister": {
        "description": "Unregister a crypto card device.",
        "pre": {
            "zc": "!=null"
        }
    }
},
{
    "kprobe:zcrypt_card_unregister": {
        "description": "Unregister a crypto card device.",
        "pre": {
            "zc": "!=null"
        }
    }
},
S,
{
    "kprobe:dasd_log_sense_dbf": {
        "description": "Dump sense data to s390 debug feature.",
        "pre": {
            "cqr": "!=null",
            "irb": "!=null"
        }
    }
},
{
    "kretprobe:dasd_default_erp_action": {
        "description": "Retries the current cqr",
        "pre": {
            "cqr": "!=null",
            "device->mem_lock": "valid spin lock",
            "device->erp_chunks": "valid pointer",
            "device->ref_count": "valid atomic variable"
        }
    }
},
{
    "kprobe:dasd_default_erp_action": {
        "description": "Retries the current cqr",
        "pre": {
            "cqr": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kretprobe:while (cqr->refers != NULL)": {
        "description": "Check if the 'refers' field of 'cqr' is not NULL in a while loop.",
        "pre": {
            "cqr": "!=null",
            "cqr->refers": "!=null"
        }
    }
},
{
    "kprobe:while (cqr->refers != NULL)": {
        "description": "Loop while the refers field of cqr is not NULL.",
        "pre": {
            "cqr": {
                "refers": "!=null"
            }
        }
    }
},
{
    "kretprobe:BUG_ON": {
        "description": "Sanity checks",
        "pre": {
            "datasize": "> PAGE_SIZE || (cplength*sizeof(struct ccw1)) > PAGE_SIZE",
            "size": "(sizeof(struct dasd_ccw_req) + 7L) & -8L",
            "cplength": "> 0",
            "data": "(char *) cqr + ((sizeof(struct dasd_ccw_req) + 7L) & -8L)",
            "cqr->cpaddr": "NULL"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Sanity checks",
        "pre": {
            "datasize": "> PAGE_SIZE || (cplength*sizeof(struct ccw1)) > PAGE_SIZE",
            "size": "(sizeof(struct dasd_ccw_req) + 7L) & -8L",
            "cplength": "> 0",
            "device": "!= null"
        }
    },
    "kprobe:dasd_alloc_erp_request": {
        "description": "Sanity checks",
        "pre": {
            "magic": "unsigned int",
            "cplength": "int",
            "datasize": "int",
            "device": "struct dasd_device",
            "flags": "unsigned long",
            "cqr": "struct dasd_ccw_req",
            "data": "char",
            "size": "int"
        }
    }
},
{
    "kretprobe:dasd_log_sense_dbf": {
        "description": "Dump sense data",
        "pre": {
            "device": "!=null",
            "device->discipline": "!=null",
            "device->discipline->dump_sense": "!=null",
            "cqr": "!=null",
            "irb": "!=null"
        }
    }
},
{
    "kprobe:if (device->discipline && device->discipline->dump_sense) device->discipline->dump_sense(device, cqr, irb);": {
        "description": "Dump sense data",
        "pre": {
            "device": "!=null",
            "cqr": "!=null",
            "irb": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
S,
{
    "kretprobe:dasd_check_cqr": {
        "description": "Check the cqr",
        "pre": {
            "cqr": "!=null",
            "cqr.startdev": "!=null",
            "cqr.status": "== DASD_CQR_IN_IO",
            "retries": "< 5"
        }
    }
},
{
    "kprobe:dasd_check_cqr": {
        "description": "Check the cqr",
        "pre": {
            "cqr": "!=null",
            "cqr.startdev": "!=null",
            "cqr.status": "== DASD_CQR_IN_IO",
            "retries": "< 5"
        }
    }
},
S,
S,
{
    "kretprobe:dasd_state_basic_to_ready": {
        "description": "Do the initial analysis. The do_analysis function may return -EAGAIN in which case the device keeps the state DASD_STATE_BASIC until the discipline decides to continue the startup sequence by calling the function dasd_change_state. The eckd disciplines uses this to start a ccw that detects the format. The completion interrupt for this detection ccw uses the kernel event daemon to trigger the call to dasd_change_state. All this is done in the discipline code, see dasd_eckd.c. After the analysis ccw is done (do_analysis returned 0) the block device is setup. In case the analysis returns an error, the device setup is stopped (a fake disk was already added to allow formatting).",
        "pre": {
            "device": "!=null"
        },
        "post": {
            "return_value": "==0",
            "device->state": "==DASD_STATE_KNOWN"
        }
    }
},
{
    "kprobe:dasd_state_basic_to_ready": {
        "description": "Do the initial analysis. The do_analysis function may return -EAGAIN in which case the device keeps the state DASD_STATE_BASIC until the discipline decides to continue the startup sequence by calling the function dasd_change_state. The eckd disciplines uses this to start a ccw that detects the format. The completion interrupt for this detection ccw uses the kernel event daemon to trigger the call to dasd_change_state. All this is done in the discipline code, see dasd_eckd.c. After the analysis ccw is done (do_analysis returned 0) the block device is setup. In case the analysis returns an error, the device setup is stopped (a fake disk was already added to allow formatting).",
        "pre": {
            "device": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:dasd_kick_device": {
        "description": "Queue a call to dasd_kick_device to the kernel event daemon.",
        "pre": {
            "device": "!=null",
            "device->kick_work": "!=null",
            "!schedule_work(&device->kick_work)": "true"
        }
    }
},
{
    "kprobe:dasd_kick_device": {
        "description": "Schedule a call to dasd_kick_device to the kernel event daemon.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:dasd_schedule_device_bh": {
        "description": "Schedule a device for processing a request.",
        "pre": {
            "device": "!=null",
            "cqr": "!=null",
            "device->cdev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:dasd_schedule_device_bh": {
        "description": "Schedule a device for processing in the bottom half.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:dasd_schedule_device_bh": {
        "description": "Schedule a device for processing a CCW request.",
        "pre": {
            "cqr": "!=null",
            "cqr->startdev": "!=null",
            "cqr->startdev->cdev": "!=null",
            "device": "=cqr->startdev",
            "flags": "!=null",
            "device->ccw_queue": "!=null",
            "cqr->status": "=DASD_CQR_QUEUED"
        }
    }
},
{
    "kprobe:dasd_schedule_device_bh": {
        "description": "Let the bh start the request to keep them in order.",
        "pre": {
            "cqr": "!=null",
            "device": "!=null",
            "flags": "!=null",
            "cqr->startdev": "device",
            "get_ccwdev_lock(device->cdev)": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:dasd_sleep_on_immediatly": {
        "description": "Sleep on the immediate request",
        "pre": {
            "cqr": "!=null",
            "device": "!=null",
            "device->flags": "has bit DASD_FLAG_LOCK_STOLEN",
            "!test_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags)": "true"
        }
    }
},
{
    "list_add": {
        "description": "Add a new entry after the specified position in the list.",
        "pre": {
            "&cqr->devlist": "!=null",
            "device->ccw_queue.next": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:static int eer_pages = 5; module_param(eer_pages, int, S_IRUGO|S_IWUSR); struct eerbuffer": {
        "description": "The data can be written in several steps but you will have to compute the total size up front for the invocation of dasd_eer_start_record. If the ringbuffer is full, dasd_eer_start_record will remove the required number of old records. A record is typically read in two steps, first read the integer that specifies the size of the following data, then read the data. Both can be done by - dasd_eer_read_buffer For all mentioned functions you need to get the bufferlock first and keep it until a complete record is written or read. All information necessary to keep track of an internal buffer is kept in a struct eerbuffer. The buffer specific to a file pointer is stored in the private_data field of that file. To be able to write data to all existing buffers, each buffer is also added to the bufferlist. If the user does not want to read a complete record in one go, we have to keep track of the rest of the record. residual stores the number of bytes that are still to deliver. If the rest of the record is invalidated between two reads then residual will be set to -1 so that the next read will fail. All entries in the eerbuffer structure are protected with the bufferlock. To avoid races between writing to a buffer on the one side and creating and destroying buffers on the other side, the bufferlock must also be used to protect the bufferlist.",
        "pre": {
            "bufferlock": "acquired",
            "eerbuffer": "!=null",
            "private_data": "!=null",
            "bufferlist": "contains eerbuffer",
            "residual": ">= -1"
        }
    }
},
{
    "kprobe:static int eer_pages = 5; module_param(eer_pages, int, S_IRUGO|S_IWUSR); struct eerbuffer": {
        "description": "The data can be written in several steps but you will have to compute the total size up front for the invocation of dasd_eer_start_record. If the ringbuffer is full, dasd_eer_start_record will remove the required number of old records. A record is typically read in two steps, first read the integer that specifies the size of the following data, then read the data. Both can be done by - dasd_eer_read_buffer. For all mentioned functions you need to get the bufferlock first and keep it until a complete record is written or read. All information necessary to keep track of an internal buffer is kept in a struct eerbuffer. The buffer specific to a file pointer is stored in the private_data field of that file. To be able to write data to all existing buffers, each buffer is also added to the bufferlist. If the user does not want to read a complete record in one go, we have to keep track of the rest of the record. residual stores the number of bytes that are still to deliver. If the rest of the record is invalidated between two reads then residual will be set to -1 so that the next read will fail. All entries in the eerbuffer structure are protected with the bufferlock. To avoid races between writing to a buffer on the one side and creating and destroying buffers on the other side, the bufferlock must also be used to protect the bufferlist.",
        "pre": {
            "eer_pages": "= 5"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:request->device = NULL": {
        "description": "Setting request->device to NULL",
        "pre": {
            "request": "!=null"
        },
        "post": {
            "request->device": "==null"
        }
    },
    "kretprobe:tape_put_device(device)": {
        "description": "Calling tape_put_device() function",
        "pre": {
            "device": "!=null"
        },
        "post": {}
    },
    "kretprobe:request->rc = -EIO": {
        "description": "Setting request->rc to -EIO",
        "pre": {
            "request": "!=null"
        },
        "post": {
            "request->rc": "== -EIO"
        }
    },
    "kretprobe:request->callback != NULL": {
        "description": "Checking if request->callback is not NULL",
        "pre": {
            "request": "!=null"
        },
        "post": {
            "request->callback": "!=null"
        }
    },
    "kretprobe:request->callback(request, request->callback_data)": {
        "description": "Calling request->callback() function",
        "pre": {
            "request": "!=null",
            "request->callback": "!=null"
        },
        "post": {}
    }
},
{
    "request->device": "==null"
},
S,
S,
{
    "kretprobe:tape_alloc_device": {
        "description": "Allocate memory for a new device structure.",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kprobe:tape_alloc_device": {
        "description": "Allocate memory for a new device structure.",
        "pre": {
            "cdev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tape_medium_state_show": {
        "description": "Show the medium state of a tape device.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:static ssize_t tape_medium_state_show(struct device *dev, struct device_attribute *attr, char *buf)": {
        "description": "Some channel attached tape specific attributes. FIXME: In the future the first_minor and blocksize attribute should be replaced by a link to the cdev tree.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:tape_alloc_request": {
        "description": "Allocate channel program",
        "pre": {
            "cplength": ">0"
        }
    }
},
{
    "kprobe:tape_alloc_request": {
        "description": "Allocate channel program.",
        "pre": {
            "cplength": ">0"
        }
    }
},
{
    "kretprobe:request->status = TAPE_REQUEST_QUEUED;schedule_delayed_work(&device->tape_dnr, 0);rc = 0;} else": {
        "description": "This function sets the status of the request to TAPE_REQUEST_QUEUED and schedules a delayed work. If successful, it sets rc to 0.",
        "pre": {
            "request": "!=null",
            "device": "!=null",
            "device->tape_dnr": "!=null",
            "rc": "==0"
        }
    }
},
{
    "kprobe:request->status = TAPE_REQUEST_QUEUED;schedule_delayed_work(&device->tape_dnr, 0);rc = 0;} else": {
        "description": "Set the status of the request to TAPE_REQUEST_QUEUED and schedule a delayed work. If successful, set rc to 0; otherwise, handle the error.",
        "pre": {
            "request": "!=null",
            "device": "!=null",
            "device->cdev": "!=null",
            "request->cpaddr": "!=null",
            "request->cpdata": "!=null",
            "request->status": "== TAPE_REQUEST_QUEUED",
            "request->options": "in [0x00]",
            "rc": "== 0 or == -EBUSY"
        }
    }
},
{
    "kretprobe:static int__tape_start_request(struct tape_device *device, struct tape_request *request)": {
        "description": "IO helper function. Adds the request to the request queue and starts it if the tape is idle. Has to be called with the device lock held.",
        "pre": {
            "device": "!=null",
            "request": "!=null"
        }
    }
},
{
    "kprobe:static int__tape_start_request(struct tape_device *device, struct tape_request *request)": {
        "description": "IO helper function. Adds the request to the request queue and starts it if the tape is idle. Has to be called with the device lock held.",
        "pre": {
            "device": "!=null",
            "request": "!=null"
        }
    }
},
S,
{
    "kprobe:__tape_start_request": {
        "description": "Add the request to the request queue, try to start it if the tape is idle, and wait uninterruptible for its completion.",
        "pre": {
            "device": "!=null",
            "request": "!=null"
        }
    }
},
{
    "kretprobe:__tape_wake_up_interruptible": {
        "description": "Add the request to the request queue, try to start it if the tape is idle and wait uninterruptible for its completion.",
        "pre": {
            "request": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__tape_wake_up_interruptible": {
        "description": "Add the request to the request queue, try to start it if the tape is idle and wait uninterruptible for its completion.",
        "pre": {
            "request": "!=null",
            "data": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tape_mtop": {
        "description": "Perform tape operations based on the given tape operation code.",
        "pre": {
            "device": "!=null",
            "mt_op": "in [MTBSR, MTFSR, MTFSF, MTBSF, MTFSFM, MTBSFM]",
            "mt_count": "!=null"
        }
    }
},
{
    "kprobe:tape_mtop": {
        "description": "Perform tape operation.",
        "pre": {
            "device": "!=null",
            "mt_op": "in [MTBSR, MTFSR, MTFSF, MTBSF, MTFSFM, MTBSFM]",
            "mt_count": "<=500"
        }
    }
},
{
    "kretprobe:tape_std_assign_timeout": {
        "description": "Assigns a timeout to the tape_std_assign function.",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "tape_std_assign": {
        "description": "Assign a timeout value to the timer.",
        "pre": {
            "t": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
S,
{
    "kretprobe:tape_std_mtsetblk": {
        "description": "Set the block size for the tape device.",
        "pre": {
            "device": "!=null",
            "device->char_data.block_size": "==0",
            "device->char_data.idal_buf": "!=null",
            "device->char_data.idal_buf->size": "==count"
        }
    }
},
{
    "kprobe:device->char_data.block_size = 0;return 0;}if (device->char_data.idal_buf != NULL && device->char_data.idal_buf->size == count)/* We already have a idal buffer of that size.": {
        "description": "Set the block size of the tape device to 0 and return 0 if the idal buffer exists and its size is equal to the given count.",
        "pre": {
            "device": "!=null",
            "device->char_data.block_size": "==0",
            "device->char_data.idal_buf": "!=null",
            "device->char_data.idal_buf->size": "==count"
        }
    }
},
S,
S,
{
    "kretprobe:tape_std_mtfsfm": {
        "description": "Execute tape_std_mtfsfm function",
        "pre": {
            "request->cpaddr": "!=null",
            "device->modeset_byte": "!=null",
            "ccw": "!=null",
            "mt_count": "not specified",
            "FORSPACEFILE": "not specified",
            "NOP": "not specified"
        }
    }
},
{
    "kprobe:tape_std_mtfsfm": {
        "description": "Standard tape move to filemark operation.",
        "pre": {
            "device": "!=null",
            "mt_count": "!=null"
        }
    }
},
{
    "kretprobe:tape_std_mtfsr": {
        "description": "Standard tape move forward space record.",
        "pre": {
            "device": "!=null",
            "mt_count": ">0"
        },
        "post": {
            "rc": "int",
            "ccw": "updated correctly"
        }
    }
},
{
    "kprobe:tape_std_mtfsr": {
        "description": "Standard Move Tape Forward Space Record",
        "pre": {
            "device": "!=null",
            "mt_count": ">=0"
        }
    }
},
{
    "ccw = tape_ccw_cc": {
        "description": "Call tape_ccw_cc function",
        "pre": {
            "request->cpaddr": "!=null",
            "MODE_SET_DB": "!=null",
            "1": "!=null",
            "device->modeset_byte": "!=null"
        }
    },
    "ccw = tape_ccw_repeat": {
        "description": "Call tape_ccw_repeat function",
        "pre": {
            "ccw": "!=null",
            "BACKSPACEBLOCK": "!=null",
            "mt_count": "!=null"
        }
    },
    "ccw = tape_ccw_end": {
        "description": "Call tape_ccw_end function",
        "pre": {
            "ccw": "!=null",
            "NOP": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    }
},
S,
{
    "kretprobe:tape_std_mtweof": {
        "description": "Standard tape medium-to-end-of-file operation.",
        "pre": {
            "device": "!=null",
            "mt_count": ">=0"
        },
        "post": {
            "ccw": "!=null",
            "ccw->cpaddr": "==request->cpaddr",
            "ccw->flags": "==MODE_SET_DB",
            "ccw->count": "==1",
            "ccw->modeset_byte": "==device->modeset_byte",
            "ccw": "==tape_ccw_repeat(tape_ccw_cc(request->cpaddr, MODE_SET_DB, 1, device->modeset_byte), WRITETAPEMARK, mt_count)",
            "ccw": "==tape_ccw_end(ccw, NOP, 0, NULL)"
        }
    }
},
S,
S,
S,
{
    "kretprobe:tape_ccw_cc": {
        "description": "Call tape_ccw_cc function",
        "pre": {
            "request->cpaddr": "!=null",
            "MODE_SET_DB": "in [valid values]",
            "1": "==1",
            "device->modeset_byte": "!=null"
        }
    },
    "kretprobe:tape_ccw_cc": {
        "description": "Call tape_ccw_cc function",
        "pre": {
            "request->cpaddr + 1": "!=null",
            "REWIND": "in [valid values]",
            "0": "==0",
            "NULL": "==null"
        }
    },
    "kretprobe:tape_ccw_end": {
        "description": "Call tape_ccw_end function",
        "pre": {
            "request->cpaddr + 2": "!=null",
            "NOP": "in [valid values]",
            "0": "==0",
            "NULL": "==null"
        }
    }
},
{
    "kprobe:tape_ccw_cc": {
        "description": "Perform a tape control command.",
        "pre": {
            "request->cpaddr": "!=null",
            "MODE_SET_DB": "!=null",
            "1": "!=null",
            "device->modeset_byte": "!=null"
        }
    },
    "kprobe:tape_ccw_cc+1": {
        "description": "Rewind the tape.",
        "pre": {
            "request->cpaddr + 1": "!=null",
            "REWIND": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    },
    "kprobe:tape_ccw_end+2": {
        "description": "End the tape control command.",
        "pre": {
            "request->cpaddr + 2": "!=null",
            "NOP": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
{
    "tape_ccw_cc": {
        "pre": {
            "request->cpaddr": "!=null",
            "device->modeset_byte": "!=null"
        }
    }
},
{
    "kretprobe:tape_ccw_cc": {
        "description": "Perform a tape control command.",
        "pre": {
            "request->cpaddr": "!=null",
            "MODE_SET_DB": "!=null",
            "1": "!=null",
            "device->modeset_byte": "!=null"
        }
    },
    "kretprobe:tape_ccw_cc+1": {
        "description": "Rewind the tape.",
        "pre": {
            "request->cpaddr + 1": "!=null",
            "REWIND": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    },
    "kretprobe:tape_ccw_cc+2": {
        "description": "Erase the gap on the tape.",
        "pre": {
            "request->cpaddr + 2": "!=null",
            "ERASE_GAP": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    },
    "kretprobe:tape_ccw_cc+3": {
        "description": "Erase a data section on the tape.",
        "pre": {
            "request->cpaddr + 3": "!=null",
            "DATA_SEC_ERASE": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    },
    "kretprobe:tape_ccw_cc+4": {
        "description": "Rewind the tape.",
        "pre": {
            "request->cpaddr + 4": "!=null",
            "REWIND": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    },
    "kretprobe:tape_ccw_end": {
        "description": "End the tape control command sequence.",
        "pre": {
            "request->cpaddr + 5": "!=null",
            "NOP": "!=null",
            "0": "!=null",
            "NULL": "!=null"
        }
    }
},
{
    "kprobe:tape_ccw_cc": {
        "description": "Perform various operations on a tape device.",
        "pre": {
            "request->cpaddr": "!=null",
            "MODE_SET_DB": "is an integer",
            "1": "is an integer",
            "device->modeset_byte": "!=null"
        }
    },
    "kprobe:tape_ccw_cc+1": {
        "description": "Rewind the tape device.",
        "pre": {
            "request->cpaddr + 1": "!=null",
            "REWIND": "is an integer",
            "0": "is an integer",
            "NULL": "is null"
        }
    },
    "kprobe:tape_ccw_cc+2": {
        "description": "Erase the gap on the tape device.",
        "pre": {
            "request->cpaddr + 2": "!=null",
            "ERASE_GAP": "is an integer",
            "0": "is an integer",
            "NULL": "is null"
        }
    },
    "kprobe:tape_ccw_cc+3": {
        "description": "Erase a data section on the tape device.",
        "pre": {
            "request->cpaddr + 3": "!=null",
            "DATA_SEC_ERASE": "is an integer",
            "0": "is an integer",
            "NULL": "is null"
        }
    },
    "kprobe:tape_ccw_cc+4": {
        "description": "Rewind the tape device.",
        "pre": {
            "request->cpaddr + 4": "!=null",
            "REWIND": "is an integer",
            "0": "is an integer",
            "NULL": "is null"
        }
    },
    "kprobe:tape_ccw_end": {
        "description": "End the tape command chain.",
        "pre": {
            "request->cpaddr + 5": "!=null",
            "NOP": "is an integer",
            "0": "is an integer",
            "NULL": "is null"
        }
    }
},
S,
S,
{
    "kretprobe:tape_std_mtcompression": {
        "description": "Perform tape standard MT compression",
        "pre": {
            "mt_count": "== 0",
            "device->modeset_byte": "&= ~0x08",
            "device->modeset_byte": "|= 0x08"
        },
        "post": {
            "tape_ccw_cc": {
                "description": "Perform tape CCW CC operation",
                "pre": {
                    "request->cpaddr": "!= null",
                    "MODE_SET_DB": "!= null",
                    "1": "!= null",
                    "device->modeset_byte": "!= null"
                }
            },
            "tape_ccw_end": {
                "description": "Perform tape CCW END operation",
                "pre": {
                    "request->cpaddr + 1": "!= null",
                    "NOP": "!= null",
                    "0": "!= null",
                    "NULL": "!= null"
                }
            }
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
{
    "kretprobe:raw3270_request_alloc": {
        "description": "Allocate request structure",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:rq = kzalloc(sizeof(*rq), GFP_KERNEL | GFP_DMA);if (!rq)return ERR_PTR(-ENOMEM);/* alloc output buffer. `": {
        "description": "Allocate request structure",
        "pre": {
            "rq": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:if (oldview)": {
        "description": "Check if the oldview is not null.",
        "pre": {
            "oldview": "!=null"
        }
    }
},
{
    "kprobe:if (oldview)": {
        "description": "Check if the variable 'oldview' is not null.",
        "pre": {
            "oldview": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:list_for_each_entry": {
        "description": "Iterate over a list of entries, starting from the given entry.",
        "pre": {
            "nv": "!=null",
            "&rp->view_list": "!=null",
            "list": "!=null"
        }
    }
},
S,
S,
{
    "kprobe:TAPE_DBF_AREA": {
        "description": "Pointer to debug area.",
        "pre": {
            "TAPE_DBF_AREA": "!=null"
        }
    }
},
{
    "kretprobe:hmcdrv_ftp_do": {
        "description": "Perform a HMC drive FTP, with data from kernel-space",
        "pre": {
            "ftp": "!=null"
        },
        "post": {
            "return_value": ">=-1"
        }
    }
},
{
    "kprobe:hmcdrv_ftp_do": {
        "description": "Perform a HMC drive FTP, with data from kernel-space",
        "pre": {
            "ftp": "!=null"
        }
    }
},
{
    "kretprobe:hmcdrv_ftp_probe": {
        "description": "Probe for the HMC drive FTP service",
        "pre": {
            "return_value": "=0"
        }
    }
},
{
    "kprobe:hmcdrv_ftp_probe": {
        "description": "Probe for the HMC drive FTP service",
        "pre": {
            "return": "==0"
        }
    }
},
S,
S,
S,
{
    "kprobe:tty_port_tty_get": {
        "description": "Get the tty associated with the given tty_port.",
        "pre": {
            "kbd": "!=null",
            "kbd.port": "!=null",
            "cmd": "!=null",
            "arg": "!=null",
            "argp": "!=null",
            "ct": "!=null",
            "perm": "!=null",
            "tty": "!=null",
            "tty.owner": "!=null",
            "tty.cap_sys_tty_config": "!=null"
        }
    }
},
{
    "kretprobe:kbd_ebcasc": {
        "description": "Generate ebcdic -> ascii translation table from kbd_data.",
        "pre": {
            "kbd": "!=null",
            "ebcasc": "!=null"
        }
    }
},
{
    "kprobe:kbd_ebcasc": {
        "description": "Generate ebcdic -> ascii translation table from kbd_data.",
        "pre": {
            "kbd": "!=null",
            "ebcasc": "!=null"
        }
    }
},
S,
S,
S,
{
    "kprobe:kbd_keycode": {
        "description": "Handle the SysRq Hack",
        "pre": {
            "kbd": "!=null",
            "keycode": ">=0"
        }
    }
},
{
    "kretprobe:sclp_trace": {
        "description": "Trace the sclp request",
        "pre": {
            "req": "!=null",
            "req->sccb": "!=null",
            "__pa(req->sccb)": "!=null",
            "_RET_IP_": "!=null",
            "req->status": "= SCLP_REQ_QUEUED",
            "req->start_count": "= 0",
            "&req->list": "!=null",
            "&sclp_req_queue": "!=null",
            "req->queue_timeout": "!=null"
        }
    }
},
{
    "kprobe:sclp_trace": {
        "description": "Trace the sclp_trace function",
        "pre": {
            "req": "!=null",
            "req->sccb": "!=null",
            "__pa(req->sccb)": "!=null",
            "_RET_IP_": "!=null",
            "req->status": "in [SCLP_REQ_QUEUED]",
            "req->start_count": "0",
            "req->list": "!=null",
            "&req->list": "!=null",
            "&sclp_req_queue": "!=null",
            "rc": "0",
            "req->queue_timeout": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:sclp_trace_register": {
        "description": "Event listener unregistered (b=caller)",
        "pre": {
            "reg": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:sclp_trace_register": {
        "description": "Event listener unregistered (b=caller)",
        "pre": {
            "reg": "!=null",
            "flags": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
S,
{
    "kretprobe:void_fsm_modtimer": {
        "description": "Modifies the timer associated with the given fsm_timer instance.",
        "pre": {
            "this": "!=null",
            "millisec": ">=0",
            "event": ">=0",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:void_fsm_modtimer": {
        "description": "Modify the timer associated with the fsm_timer object.",
        "pre": {
            "this": "!=null",
            "millisec": ">=0",
            "event": ">=0",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_is_pathgroup": {
        "description": "Determine if paths to this device are grouped.",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": "in [0, !=0]"
        }
    }
},
{
    "kprobe:ccw_device_is_pathgroup": {
        "description": "Determine if paths to this device are grouped",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_is_multipath": {
        "description": "Determine if device is operating in multipath mode.",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_is_multipath": {
        "description": "Determine if device is operating in multipath mode",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_get_id": {
        "description": "Obtain a ccw device id",
        "pre": {
            "cdev": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_get_id": {
        "description": "Obtain a ccw device id",
        "pre": {
            "cdev": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_tm_start_timeout_key": {
        "description": "Perform the start function on the ccw device with the given parameters.",
        "pre": {
            "cdev": "!=null",
            "tcw": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_tm_start_timeout_key": {
        "description": "Perform the start function",
        "pre": {
            "cdev": "!=null",
            "tcw": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_tm_start_key": {
        "description": "Perform the start function on the ccw device.",
        "pre": {
            "cdev": "!=null",
            "tcw": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_tm_start_key": {
        "description": "Perform the start function on the ccw device.",
        "pre": {
            "cdev": "!=null",
            "tcw": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_get_mdc": {
        "description": "accumulate max data count",
        "pre": {
            "cdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_get_mdc": {
        "description": "Accumulate max data count for ccw device",
        "pre": {
            "cdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_tm_intrg": {
        "description": "Perform an interrogate function on the given ccw device.",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_tm_intrg": {
        "description": "Perform an interrogate function on the given ccw device.",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_set_options_mask": {
        "description": "Set some options and unset the rest for the given device.",
        "pre": {
            "cdev": "!=null",
            "flags": "!=null",
            "flags": "is a valid flag combination"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:ccw_device_set_options_mask": {
        "description": "Set some options and unset the rest for the given device.",
        "pre": {
            "cdev": "!=null",
            "flags": "!=null",
            "flags": "is a valid flag combination"
        },
        "post": {
            "return": "0 on success, -EINVAL on an invalid flag combination"
        }
    }
},
{
    "kretprobe:ccw_device_clear_options": {
        "description": "Clear some options for the given device.",
        "pre": {
            "cdev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_clear_options": {
        "description": "Clear some options for the specified device.",
        "pre": {
            "cdev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_start_timeout_key": {
        "description": "Start a s390 channel program with timeout and key.",
        "pre": {
            "cdev": "!=null",
            "cpa": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "flags": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kprobe:int ccw_device_start_timeout_key": {
        "description": "Start a s390 channel program with timeout and key.",
        "pre": {
            "cdev": "!=null",
            "cpa": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "flags": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_resume": {
        "description": "Resume channel program execution",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": "in [%0, -%ENODEV, -%EINVAL, -%EBUSY]"
        },
        "context": "Interrupts disabled, ccw device lock held"
    }
},
{
    "kprobe:ccw_device_resume": {
        "description": "Resume channel program execution",
        "pre": {
            "cdev": "!=null",
            "cdev->subchannel": "!=null",
            "cdev->subchannel->state": "in [OPERATIONAL, BUSY, INTERRUPT_PENDING]",
            "interrupts_disabled": "true",
            "ccw_device_lock_held": "true"
        },
        "post": {
            "return_value": "in [0, -ENODEV, -EINVAL, -EBUSY]"
        }
    }
},
{
    "kretprobe:ccw_device_start_key": {
        "description": "Start a s390 channel program with key",
        "pre": {
            "cdev": "!=null",
            "cpa": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_start_key": {
        "description": "Start a s390 channel program with key",
        "pre": {
            "cdev": "!=null",
            "cpa": "!=null",
            "intparm": "!=null",
            "lpm": "!=null",
            "key": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_get_ciw": {
        "description": "Search for CIW command in extended sense data.",
        "pre": {
            "cdev": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:ccw_device_get_ciw": {
        "description": "Search for CIW command in extended sense data.",
        "pre": {
            "cdev": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:ccw_device_get_path_mask": {
        "description": "get currently available paths",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return_value": "in [0, 255]"
        }
    }
},
{
    "kprobe:ccw_device_get_path_mask": {
        "description": "Get currently available paths for the ccw device's subchannel.",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": "in [0, 255]"
        }
    }
},
{
    "kretprobe:qdio_start_irq": {
        "description": "Enable interrupt processing for the device",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:qdio_start_irq": {
        "description": "Enable interrupt processing for the device",
        "pre": {
            "cdev": "!=null"
        },
        "return_codes": {
            "0": "success",
            "1": "irqs not started since new data is available"
        }
    }
},
{
    "kretprobe:qdio_stop_irq": {
        "description": "Disable interrupt processing for the device",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:qdio_stop_irq": {
        "description": "Disable interrupt processing for the device",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:itcw_get_tcw": {
        "description": "Return pointer to tcw associated with the itcw",
        "pre": {
            "itcw": "!=null"
        }
    }
},
{
    "kprobe:itcw_get_tcw": {
        "description": "Return pointer to tcw associated with the itcw.",
        "pre": {
            "itcw": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:itcw_set_data": {
        "description": "Set data address and tida flag of the itcw",
        "pre": {
            "itcw": "!=null",
            "addr": "!=null",
            "use_tidal": "is_int"
        }
    }
},
{
    "kprobe:itcw_set_data": {
        "description": "Set data address and tida flag of the itcw",
        "pre": {
            "itcw": "!=null",
            "addr": "!=null",
            "use_tidal": "is_integer"
        }
    }
},
{
    "kretprobe:register_adapter_interrupt": {
        "description": "Register adapter interrupt handler",
        "pre": {
            "airq": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:register_adapter_interrupt": {
        "description": "Register adapter interrupt handler",
        "pre": {
            "airq": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:unregister_adapter_interrupt": {
        "description": "unregister adapter interrupt handler",
        "pre": {
            "airq": "!=null"
        }
    }
},
{
    "kprobe:unregister_adapter_interrupt": {
        "description": "Unregister adapter interrupt handler",
        "pre": {
            "airq": "!=null"
        }
    }
},
{
    "kretprobe:airq_iv_create": {
        "description": "Create an interrupt vector",
        "pre": {
            "bits": "!=null",
            "flags": "!=null",
            "vec": "!=null"
        }
    }
},
{
    "kprobe:airq_iv_create": {
        "description": "Create an interrupt vector",
        "pre": {
            "bits": "!=null",
            "flags": "!=null",
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:airq_iv_release": {
        "description": "Release an interrupt vector",
        "pre": {
            "iv": "!=null"
        }
    }
},
{
    "kprobe:airq_iv_release": {
        "description": "Release an interrupt vector",
        "pre": {
            "iv": "!=null"
        }
    }
},
{
    "kretprobe:airq_iv_alloc": {
        "description": "Allocate irq bits from an interrupt vector",
        "pre": {
            "iv": "!=null",
            "num": ">=0"
        },
        "post": {
            "return": ">=0 or -1UL"
        }
    }
},
{
    "kprobe:airq_iv_alloc": {
        "description": "allocate irq bits from an interrupt vector",
        "pre": {
            "iv": "!=null",
            "num": "!=null",
            "num": ">=0",
            "num": "<=MAX_NUM_IRQ_BITS",
            "return": ">=0",
            "return": "<=MAX_NUM_IRQ_BITS",
            "return": "!=4294967295"
        }
    }
},
{
    "kretprobe:airq_iv_free": {
        "description": "Free irq bits of an interrupt vector",
        "pre": {
            "iv": "!=null",
            "bit": ">=0",
            "num": ">=0"
        }
    }
},
{
    "kprobe:airq_iv_free": {
        "description": "Free irq bits of an interrupt vector.",
        "pre": {
            "iv": "!=null",
            "bit": ">=0",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:airq_iv_scan": {
        "description": "Scan interrupt vector for non-zero bits",
        "pre": {
            "iv": "!=null",
            "start": ">=0",
            "end": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:airq_iv_scan": {
        "description": "Scan interrupt vector for non-zero bits.",
        "pre": {
            "iv": "!=null",
            "start": ">=0",
            "end": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:tcw_get_intrg": {
        "description": "Return pointer to associated interrogate tcw",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kprobe:tcw_get_intrg": {
        "description": "Return pointer to associated interrogate tcw.",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kretprobe:tcw_get_data": {
        "description": "Return pointer to input/output data associated with tcw.",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kprobe:tcw_get_data": {
        "description": "Return pointer to input/output data associated with tcw.",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kretprobe:tcw_get_tccb": {
        "description": "Return pointer to tccb associated with tcw",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kprobe:tcw_get_tccb": {
        "description": "Return pointer to tccb associated with tcw",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kretprobe:tcw_get_tsb": {
        "description": "Return pointer to tsb associated with tcw",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kprobe:tcw_get_tsb": {
        "description": "Return pointer to tsb associated with tcw",
        "pre": {
            "tcw": "!=null"
        }
    }
},
{
    "kretprobe:tcw_init": {
        "description": "Initialize tcw data structure",
        "pre": {
            "tcw": "!=null",
            "r": "!=null",
            "w": "!=null"
        }
    }
},
{
    "kprobe:tcw_init": {
        "description": "Initialize tcw data structure",
        "pre": {
            "tcw": "!=null",
            "r": "!=null",
            "w": "!=null"
        }
    }
},
{
    "kretprobe:tcw_finalize": {
        "description": "Finalize tcw length fields and tidaw list",
        "pre": {
            "tcw": "!=null",
            "num_tidaws": ">=0"
        },
        "post": {
            "tcw->input_output_count": ">=0",
            "tcw->tccbl": ">=0",
            "tccb->tcat": "exists",
            "tidaw_list_terminated": "true"
        },
        "notes": {
            "tidaw_list_storage": "contiguous",
            "tcal_up_to_date": "true"
        }
    }
},
{
    "kprobe:tcw_finalize": {
        "description": "finalize tcw length fields and tidaw list",
        "pre": {
            "tcw": "!=null",
            "num_tidaws": ">=0"
        }
    }
},
{
    "kretprobe:tcw_set_intrg": {
        "description": "Set the interrogate tcw address of a tcw",
        "pre": {
            "tcw": "!=null",
            "intrg_tcw": "!=null"
        }
    }
},
{
    "kprobe:tcw_set_intrg": {
        "description": "Set the interrogate tcw address of a tcw",
        "pre": {
            "tcw": "!=null",
            "intrg_tcw": "!=null"
        }
    }
},
{
    "kretprobe:tcw_set_data": {
        "description": "Set data address and tidal flag of a tcw",
        "pre": {
            "tcw": "!=null",
            "data": "!=null",
            "use_tidal": "is_int"
        }
    }
},
{
    "kprobe:tcw_set_data": {
        "description": "Set data address and tida flag of a tcw",
        "pre": {
            "tcw": "!=null",
            "data": "!=null",
            "use_tidal": "is_int"
        }
    }
},
{
    "kretprobe:tcw_set_tccb": {
        "description": "Set the address of the tccb in the specified tcw.",
        "pre": {
            "tcw": "!=null",
            "tccb": "!=null"
        }
    }
},
{
    "kprobe:tcw_set_tccb": {
        "description": "Set the address of the tccb in the specified tcw.",
        "pre": {
            "tcw": "!=null",
            "tccb": "!=null"
        }
    }
},
{
    "kretprobe:tcw_set_tsb": {
        "description": "Set the address of the tsb in the specified tcw.",
        "pre": {
            "tcw": "!=null",
            "tsb": "!=null"
        }
    }
},
{
    "kprobe:tcw_set_tsb": {
        "description": "Set the address of the tsb in the specified tcw.",
        "pre": {
            "tcw": "!=null",
            "tsb": "!=null"
        }
    }
},
{
    "kretprobe:tccb_init": {
        "description": "Initialize the header of the specified tccb by resetting all values to zero and filling in defaults for format, sac, and initial tcal fields.",
        "pre": {
            "tccb": "!=null",
            "size": ">=0",
            "sac": ">=0"
        }
    }
},
{
    "kprobe:tccb_init": {
        "description": "Initialize tccb",
        "pre": {
            "tccb": "!=null",
            "size": ">=0",
            "sac": ">=0"
        }
    }
},
{
    "kretprobe:tsb_init": {
        "description": "Initialize the specified tsb by resetting all values to zero.",
        "pre": {
            "tsb": "!=null"
        }
    }
},
{
    "kprobe:tsb_init": {
        "description": "Initialize the specified tsb by resetting all values to zero.",
        "pre": {
            "tsb": "!=null"
        }
    }
},
{
    "kretprobe:tccb_add_dcw": {
        "description": "Add a dcw to the tccb",
        "pre": {
            "tccb": "!=null",
            "tccb_size": "!=null",
            "cmd": "!=null",
            "flags": "!=null",
            "cd": "!=null",
            "cd_count": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:tccb_add_dcw": {
        "description": "Add a dcw to the tccb",
        "pre": {
            "tccb": "!=null",
            "tccb_size": "!=null",
            "cmd": "!=null",
            "flags": "!=null",
            "cd": "!=null",
            "cd_count": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:tcw_add_tidaw": {
        "description": "Add a tidaw to a tcw and return a pointer to the new tidaw.",
        "pre": {
            "tcw": "!=null",
            "num_tidaws": ">=0",
            "flags": ">=0",
            "addr": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:tcw_add_tidaw": {
        "description": "Add a tidaw to a tcw",
        "pre": {
            "tcw": "!=null",
            "num_tidaws": ">=0",
            "flags": ">=0",
            "addr": "!=null",
            "count": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:ccw_device_set_offline": {
        "description": "Disable a ccw device for IO",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ccw_device_set_offline": {
        "description": "Disable a ccw device for IO",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:ccw_driver_register": {
        "description": "Register a ccw driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kprobe:ccw_driver_register": {
        "description": "Register a ccw driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kretprobe:ccw_driver_unregister": {
        "description": "Deregister a ccw driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kprobe:ccw_driver_unregister": {
        "description": "Deregister a ccw driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kretprobe:get_ccwdev_by_busid": {
        "description": "Obtain device from a bus id",
        "pre": {
            "cdrv": "!=null",
            "bus_id": "!=null"
        }
    }
},
{
    "kprobe:get_ccwdev_by_busid": {
        "description": "Obtain device from a bus id",
        "pre": {
            "cdrv": "!=null",
            "bus_id": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_set_online": {
        "description": "Enable a ccwgroup device",
        "pre": {
            "gdev": "!=null"
        },
        "post": {
            "return_value": "in [0, <negative error values>]"
        }
    }
},
{
    "kprobe:ccwgroup_set_online": {
        "description": "Enable a ccwgroup device",
        "pre": {
            "gdev": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_set_offline": {
        "description": "Disable a ccwgroup device",
        "pre": {
            "gdev": "!=null",
            "call_gdrv": "in [true, false]"
        }
    }
},
{
    "kprobe:ccwgroup_set_offline": {
        "description": "Disable a ccwgroup device",
        "pre": {
            "gdev": "!=null",
            "call_gdrv": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_create_dev": {
        "description": "Create and register a ccw group device",
        "pre": {
            "parent": "!=null",
            "gdrv": "!=null",
            "num_devices": ">=0",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ccwgroup_create_dev": {
        "description": "Create and register a ccw group device",
        "pre": {
            "parent": "!=null",
            "gdrv": "!=null",
            "num_devices": ">=0",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_driver_register": {
        "description": "Register a ccw group driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kprobe:ccwgroup_driver_register": {
        "description": "Register a ccw group driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_driver_unregister": {
        "description": "Deregister a ccw group driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kprobe:ccwgroup_driver_unregister": {
        "description": "Deregister a ccw group driver",
        "pre": {
            "cdriver": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_probe_ccwdev": {
        "description": "Probe function for slave devices",
        "pre": {
            "cdev": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:ccwgroup_probe_ccwdev": {
        "description": "Probe function for slave devices",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:ccwgroup_remove_ccwdev": {
        "description": "Remove function for slave devices",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kprobe:ccwgroup_remove_ccwdev": {
        "description": "Remove function for slave devices",
        "pre": {
            "cdev": "!=null"
        }
    }
},
{
    "kretprobe:__parport_register_driver": {
        "description": "Registers a parport driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kprobe:__parport_register_driver": {
        "description": "Register a parallel port driver.",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kretprobe:parport_get_port": {
        "description": "Get the parport structure associated with the given port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:parport_get_port": {
        "description": "Get the parport structure associated with the given port.",
        "pre": {
            "port": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:parport_register_dev_model": {
        "description": "Register a device model on the parallel port.",
        "pre": {
            "port": "!=null",
            "name": "!=null",
            "par_dev_cb": "!=null",
            "id": ">=0"
        }
    }
},
{
    "kprobe:parport_register_dev_model": {
        "description": "Register a device model on the parallel port.",
        "pre": {
            "port": "!=null",
            "name": "!=null",
            "par_dev_cb": "!=null",
            "id": ">=0"
        }
    }
},
{
    "kretprobe:parport_unregister_device": {
        "description": "Deregister a device on a parallel port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:parport_unregister_device": {
        "description": "Deregister a device on a parallel port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:parport_find_number": {
        "description": "Find a parallel port by number",
        "pre": {
            "number": "!=null"
        }
    }
},
{
    "kprobe:parport_find_number": {
        "description": "Find a parallel port by number",
        "pre": {
            "number": "!=null"
        }
    }
},
{
    "kretprobe:parport_find_base": {
        "description": "Find a parallel port by base address",
        "pre": {
            "base": "!=null"
        }
    }
},
{
    "kprobe:parport_find_base": {
        "description": "Find a parallel port by base address",
        "pre": {
            "base": "!=null"
        }
    }
},
{
    "kretprobe:/* function name */": {
        "description": "/* description of the function */",
        "pre": {
            /* conditions for the pre-state of the function */
        }
    }
},
{
    "kprobe:/* The cad_lock is still held for writing here */": {
        "description": "The cad_lock is still held for writing at this point.",
        "pre": {
            "cad_lock": "!=null",
            "cad_lock_state": "==WRITE"
        }
    }
},
S,
S,
{
    "kretprobe:platform_device_register_simple": {
        "description": "Register a platform device with simple parameters.",
        "pre": {
            "base": "!=null",
            "base_hi": "!=null",
            "irq": "int",
            "dma": "int",
            "dev": "!=null",
            "irqflags": "int",
            "mode_mask": "unsigned int",
            "ecr_writable": "unsigned char"
        }
    },
    "kretprobe:dma_coerce_mask_and_coherent": {
        "description": "Coerce the DMA mask and set the coherent flag for a device.",
        "pre": {
            "dev": "!=null",
            "mask": "unsigned long int"
        }
    }
},
{
    "kprobe:pdev = platform_device_register_simple": {
        "description": "Register a platform device with simple parameters.",
        "pre": {
            "base": "!=null",
            "base_hi": "!=null",
            "irq": "int",
            "dma": "int",
            "dev": "!=null",
            "irqflags": "int",
            "mode_mask": "unsigned int",
            "ecr_writable": "unsigned char"
        }
    },
    "kprobe:IS_ERR(pdev)": {
        "description": "Check if the platform device registration failed.",
        "pre": {
            "pdev": "!=null"
        }
    },
    "kprobe:dev = &pdev->dev": {
        "description": "Assign the device pointer from the platform device.",
        "pre": {
            "pdev": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:ret = dma_coerce_mask_and_coherent": {
        "description": "Coerce the DMA mask and set coherent flag for the device.",
        "pre": {
            "dev": "!=null",
            "mask": "DMA_BIT_MASK(24)"
        }
    },
    "kprobe:if (ret)": {
        "description": "Check if the DMA mask coercion failed.",
        "pre": {
            "ret": "!=0"
        }
    }
},
{
    "kretprobe:parport_pc_unregister_port": {
        "description": "Unregister a parallel port",
        "pre": {
            "p": "!=null",
            "p->private_data": "!=null",
            "p->ops": "!=null",
            "p->dma": "in [PARPORT_DMA_NONE, ...]",
            "p->irq": "in [PARPORT_IRQ_NONE, ...]",
            "p->base": "!=null",
            "p->size": ">=3",
            "p->modes": "!=null",
            "p->base_hi": "!=null",
            "p->physport->dev": "!=null",
            "PAGE_SIZE": "!=null",
            "priv->dma_buf": "!=null"
        }
    }
},
{
    "kprobe:parport_pc_unregister_port": {
        "description": "Unregister a parallel port",
        "pre": {
            "p": "!=null",
            "p->private_data": "!=null",
            "p->ops": "!=null",
            "p->dma": "in [PARPORT_DMA_NONE, ...]",
            "p->irq": "in [PARPORT_IRQ_NONE, ...]",
            "p->base": "!=null",
            "p->size": ">=3",
            "p->modes": "!=null",
            "p->base_hi": "!=null",
            "p->physport->dev": "!=null",
            "p->private_data->dma_buf": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
S,
S,
S,
S,
S,
S,
S,
S,
{
    "kretprobe:parport_negotiate": {
        "description": "Negotiate an IEEE 1284 mode",
        "pre": {
            "port": "!=null",
            "mode": "in [IEEE1284_MODE_xxx]"
        },
        "post": {
            "return_value": "in [0, -1, 1]"
        }
    }
},
{
    "kprobe:parport_negotiate": {
        "description": "Negotiate an IEEE 1284 mode.",
        "pre": {
            "port": "!=null",
            "mode": "in [IEEE1284_MODE_xxx]"
        },
        "post": {
            "return": "in [-1, 0, 1]"
        }
    }
},
S,
S,
{
    "kretprobe:parport_wait_peripheral": {
        "description": "Waits for a peripheral on the specified parport.",
        "pre": {
            "port": "!=null",
            "mask": "!=null",
            "result": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
S,
S,
S,
{
    "kretprobe:parport_wait_event": {
        "description": "Wait for an event on a parallel port.",
        "pre": {
            "port": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:parport_wait_event": {
        "description": "Wait for an event on a parallel port.",
        "pre": {
            "port": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:parport_ieee1284_ack_data_avail": {
        "description": "Acknowledges the availability of data on the port.",
        "pre": {
            "port->name": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:pr_debug": {
        "description": "Print a debug message with the given format string and arguments.",
        "pre": {
            "format": "==\"%s: Data available\\n\"",
            "port->name": "!=null"
        }
    },
    "kprobe:parport_ieee1284_ack_data_avail": {
        "description": "Acknowledge the availability of data in the IEEE1284 port.",
        "pre": {
            "handle": "!=null"
        }
    }
},
S,
{
    "kprobe:hdmi_avi_infoframe_init": {
        "description": "Initialize an HDMI AVI infoframe.",
        "pre": {
            "frame": "!=null",
            "frame->valid": "==true"
        }
    }
},
{
    "kretprobe:hdmi_avi_infoframe_check": {
        "description": "Check a HDMI AVI infoframe",
        "pre": {
            "frame": "!=null",
            "frame->type": "==HDMI_INFOFRAME_TYPE_AVI",
            "frame->version": "==2",
            "frame->length": "==HDMI_AVI_INFOFRAME_SIZE",
            "frame->picture_aspect": "<=HDMI_PICTURE_ASPECT_16_9"
        }
    }
},
{
    "kprobe:hdmi_avi_infoframe_check": {
        "description": "Check a HDMI AVI infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_AVI",
            "frame->version": "== 2",
            "frame->length": "== HDMI_AVI_INFOFRAME_SIZE",
            "frame->picture_aspect": "<= HDMI_PICTURE_ASPECT_16_9"
        }
    }
},
{
    "kretprobe:hdmi_avi_infoframe_pack_only": {
        "description": "Write HDMI AVI infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:hdmi_avi_infoframe_pack_only": {
        "description": "Write HDMI AVI infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_spd_infoframe_init": {
        "description": "Initialize an HDMI SPD infoframe",
        "pre": {
            "frame": "!=null",
            "vendor": "!=null",
            "product": "!=null"
        }
    }
},
{
    "kprobe:hdmi_spd_infoframe_init": {
        "description": "Initialize an HDMI SPD infoframe",
        "pre": {
            "frame": "!=null",
            "vendor": "!=null",
            "product": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_spd_infoframe_check": {
        "description": "Check a HDMI SPD infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_SPD",
            "frame->version": "== 1",
            "frame->length": "== HDMI_SPD_INFOFRAME_SIZE"
        }
    }
},
{
    "kprobe:hdmi_spd_infoframe_check": {
        "description": "Check a HDMI SPD infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_SPD",
            "frame->version": "== 1",
            "frame->length": "== HDMI_SPD_INFOFRAME_SIZE"
        }
    }
},
{
    "kretprobe:hdmi_spd_infoframe_pack_only": {
        "description": "Write HDMI SPD infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:hdmi_spd_infoframe_pack_only": {
        "description": "Write HDMI SPD infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_audio_infoframe_init": {
        "description": "Initialize an HDMI audio infoframe.",
        "pre": {},
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:hdmi_audio_infoframe_init": {
        "description": "Initialize an HDMI audio infoframe",
        "pre": {
            "frame": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_audio_infoframe_check": {
        "description": "Check a HDMI audio infoframe",
        "pre": {
            "frame->type": "!= HDMI_INFOFRAME_TYPE_AUDIO",
            "frame->version": "!= 1",
            "frame->length": "!= HDMI_AUDIO_INFOFRAME_SIZE"
        }
    }
},
{
    "kprobe:hdmi_audio_infoframe_check": {
        "description": "Check a HDMI audio infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_AUDIO",
            "frame->version": "== 1",
            "frame->length": "== HDMI_AUDIO_INFOFRAME_SIZE"
        }
    }
},
{
    "kretprobe:hdmi_audio_infoframe_pack_only": {
        "description": "write HDMI audio infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:hdmi_audio_infoframe_pack_only": {
        "description": "write HDMI audio infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:ssize_thdmi_audio_infoframe_pack_for_dp": {
        "description": "Pack a HDMI Audio infoframe for DisplayPort",
        "pre": {
            "frame": "!=null",
            "sdp": "!=null",
            "dp_version": "!=null"
        }
    }
},
{
    "kprobe:ssize_thdmi_audio_infoframe_pack_for_dp": {
        "description": "Pack a HDMI Audio infoframe for DisplayPort",
        "pre": {
            "frame": "!=null",
            "sdp": "!=null",
            "dp_version": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_vendor_infoframe_init": {
        "description": "Initialize an HDMI vendor infoframe.",
        "pre": {
            "frame": "!=null"
        },
        "post": {
            "return_value": ">=0 || <0"
        }
    }
},
{
    "kprobe:hdmi_vendor_infoframe_init": {
        "description": "Initialize an HDMI vendor infoframe.",
        "pre": {
            "frame": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_vendor_infoframe_check_only": {
        "description": "Check a HDMI vendor infoframe and return 0 on success or a negative error code on failure.",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_VENDOR",
            "frame->version": "== 1",
            "frame->oui": "== HDMI_IEEE_OUI"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    },
    "kretprobe:hdmi_vendor_infoframe_check": {
        "description": "Check a HDMI vendor infoframe and update derived fields based on other fields.",
        "pre": {
            "frame->vic": "!= 0",
            "frame->s3d_struct": "!= HDMI_3D_STRUCTURE_INVALID",
            "frame->length": "== hdmi_vendor_infoframe_length(frame)"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:hdmi_vendor_infoframe_check_only": {
        "description": "Check a HDMI vendor infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_VENDOR",
            "frame->version": "== 1",
            "frame->oui": "== HDMI_IEEE_OUI"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    },
    "kprobe:hdmi_vendor_infoframe_check": {
        "description": "Check a HDMI vendor infoframe and update derived fields",
        "pre": {
            "frame->vic": "!= 0",
            "frame->s3d_struct": "!= HDMI_3D_STRUCTURE_INVALID",
            "frame->length": "== hdmi_vendor_infoframe_length(frame)"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:hdmi_vendor_infoframe_pack_only": {
        "description": "Write a HDMI vendor infoframe to binary buffer.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:hdmi_vendor_infoframe_pack_only": {
        "description": "Write a HDMI vendor infoframe to binary buffer.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_drm_infoframe_init": {
        "description": "Initialize an HDMI Dynamic Range and mastering infoframe.",
        "pre": {
            "frame": "!=null"
        }
    }
},
{
    "kprobe:hdmi_drm_infoframe_init": {
        "description": "Initialize an HDMI Dynamic Range and mastering infoframe.",
        "pre": {
            "frame": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_drm_infoframe_check": {
        "description": "Check a HDMI DRM infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_DRM",
            "frame->version": "== 1",
            "frame->length": "== HDMI_DRM_INFOFRAME_SIZE"
        }
    }
},
{
    "kprobe:hdmi_drm_infoframe_check": {
        "description": "Check a HDMI DRM infoframe",
        "pre": {
            "frame->type": "== HDMI_INFOFRAME_TYPE_DRM",
            "frame->version": "== 1",
            "frame->length": "== HDMI_DRM_INFOFRAME_SIZE"
        }
    }
},
{
    "kretprobe:hdmi_drm_infoframe_pack_only": {
        "description": "Write HDMI DRM infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:hdmi_drm_infoframe_pack_only": {
        "description": "Write HDMI DRM infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_infoframe_set_checksum": {
        "description": "Compute checksum for the given buffer.",
        "pre": {
            "buffer": "!=null",
            "size": ">0",
            "ptr": "!=null",
            "csum": ">=0",
            "i": ">=0",
            "i": "<size",
            "csum": "is sum of ptr[0] to ptr[size-1]",
            "return_value": "256 - csum"
        }
    }
},
{
    "kprobe:hdmi_infoframe_set_checksum": {
        "description": "Compute checksum for hdmi_infoframe_set_checksum function",
        "pre": {
            "ptr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:ssize_thdmi_infoframe_pack_only": {
        "description": "Write a HDMI infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:ssize_thdmi_infoframe_pack_only": {
        "description": "Write a HDMI infoframe to binary buffer",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_infoframe_log": {
        "description": "Log info of HDMI infoframe",
        "pre": {
            "level": "!=null",
            "dev": "!=null",
            "frame": "!=null"
        }
    }
},
{
    "kprobe:hdmi_infoframe_log": {
        "description": "Log info of HDMI infoframe",
        "pre": {
            "level": "!=null",
            "dev": "!=null",
            "frame": "!=null"
        }
    }
},
{
    "kretprobe:hdmi_drm_infoframe_unpack_only": {
        "description": "Unpacks CTA-861-G DRM infoframe DataBytes contained in the binary @buffer into a structured @frame of the HDMI Dynamic Range and Mastering (DRM) infoframe.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:hdmi_drm_infoframe_unpack_only": {
        "description": "Unpacks CTA-861-G DRM infoframe DataBytes contained in the binary @buffer into a structured @frame of the HDMI Dynamic Range and Mastering (DRM) infoframe.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:hdmi_infoframe_unpack": {
        "description": "Unpacks the information contained in binary buffer @buffer into a structured @frame of a HDMI infoframe. Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4 specification.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:hdmi_infoframe_unpack": {
        "description": "Unpacks the information contained in binary buffer @buffer into a structured @frame of a HDMI infoframe. Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4 specification.",
        "pre": {
            "frame": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
"misc": "!=null",
{
    "misc = vga_r(state->vgabase, VGA_MIS_R);iobase = (misc & 1) ? 0x3d0 : 0x3b0;vga_r(state->vgabase, iobase + 0xa);vga_w(state->vgabase, VGA_ATT_W, 0x00);attr10 = vga_rattr(state->vgabase, 0x10);vga_r(state->vgabase, iobase + 0xa);vga_w(state->vgabase, VGA_ATT_W, 0x20);if (attr10 & 1)return;/* save regs`": {
        "pre": {
            "state": {
                "vgabase": "!=null"
            },
            "fbbase": "!=null"
        }
    }
},
{
    "kretprobe:vga_rgfx": {
        "description": "Reads a value from the VGA graphics register.",
        "pre": {
            "state->vgabase": "!=null",
            "VGA_GFX_SR_ENABLE": "!=null"
        }
    },
    "kretprobe:vga_rseq": {
        "description": "Reads a value from the VGA sequencer register.",
        "pre": {
            "state->vgabase": "!=null",
            "VGA_SEQ_PLANE_WRITE": "!=null",
            "VGA_SEQ_MEMORY_MODE": "!=null"
        }
    }
},
{
    "vga_rgfx": {
        "pre": {
            "state->vgabase": "!=null",
            "VGA_GFX_SR_ENABLE": "!=null"
        }
    }
},
{
    "kretprobe:video_get_options": {
        "description": "Get kernel boot parameters for video options.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:video_get_options": {
        "description": "Get kernel boot parameters for video options.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:sti_font_convert_bytemode": {
        "description": "Converts the font to byte mode.",
        "pre": {
            "sti->wordmode": false,
            "f->raw": "!=null",
            "f->raw->bytes_per_char": ">0",
            "f->raw->last_char": ">0",
            "size": ">0",
            "old_font": "=f->raw_ptr",
            "n": "=kcalloc(4, size, STI_LOWMEM)",
            "f->raw_ptr": "=n",
            "n": "!=null",
            "p": "=n+3",
            "q": "=f->raw",
            "loop": {
                "condition": "size--",
                "body": {
                    "p": "++",
                    "p": "+=4"
                }
            },
            "new_ptr": "store",
            "old_font": "delete"
        }
    }
},
{
    "kprobe:sti_font_convert_bytemode": {
        "description": "Converts the font to byte mode and updates the font pointer.",
        "pre": {
            "sti": "!=null",
            "f": "!=null",
            "f->raw": "!=null",
            "f->raw->bytes_per_char": ">=0",
            "f->raw->last_char": ">=0",
            "sizeof(struct sti_rom_font)": ">=0",
            "sti->wordmode": "==0"
        }
    }
},
S,
S,
{
    "kretprobe:__aperture_remove_legacy_vga_devices": {
        "description": "Remove legacy VGA devices of a PCI device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:__aperture_remove_legacy_vga_devices": {
        "description": "Remove legacy VGA devices of a PCI device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:backlight_device_get_by_type": {
        "description": "Find the first backlight device of a specified type.",
        "pre": {
            "type": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:backlight_device_get_by_type": {
        "description": "Find the first backlight device of a specified type.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kretprobe:backlight_device_get_by_name": {
        "description": "Get backlight device by name",
        "pre": {
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:backlight_device_get_by_name": {
        "description": "Get backlight device by name",
        "pre": {
            "name": "!=null"
        }
    }
},
S,
{
    "kprobe:backlight_device_unregister": {
        "description": "Unregister a backlight device.",
        "pre": {
            "bd": "!=null"
        }
    }
},
{
    "kretprobe:backlight_register_notifier": {
        "description": "Get notified of backlight (un)registration",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:backlight_register_notifier": {
        "description": "Get notified of backlight (un)registration",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:backlight_unregister_notifier": {
        "description": "Unregister a backlight notifier",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:backlight_unregister_notifier": {
        "description": "Unregister a backlight notifier",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:of_find_backlight_by_node": {
        "description": "Find backlight device by device-tree node",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_find_backlight_by_node": {
        "description": "Find backlight device by device-tree node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:devm_of_find_backlight": {
        "description": "Find backlight for a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_of_find_backlight": {
        "description": "Find backlight for a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:lcd_device_register": {
        "description": "Register a new object of lcd_device class.",
        "pre": {
            "name": "!=null",
            "parent": "!=null",
            "devdata": "any",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:lcd_device_register": {
        "description": "Register a new object of lcd_device class.",
        "pre": {
            "name": "!=null",
            "parent": "!=null",
            "devdata": "any",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:lcd_device_unregister": {
        "description": "Unregisters a object of lcd_device class.",
        "pre": {
            "ld": "!=null"
        }
    }
},
{
    "kprobe:lcd_device_unregister": {
        "description": "Unregisters a object of lcd_device class.",
        "pre": {
            "ld": "!=null"
        }
    }
},
{
    "kretprobe:devm_lcd_device_register": {
        "description": "Managed lcd_device_register(). The lcd_device returned from this function are automatically freed on driver detach. See lcd_device_register() for more information.",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "parent": "!=null",
            "devdata": "any",
            "ops": "!=null"
        },
        "post": {
            "return": "struct lcd or ERR_PTR"
        }
    }
},
{
    "kprobe:devm_lcd_device_register": {
        "description": "Resource managed lcd_device_register()",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "parent": "!=null",
            "devdata": "any",
            "ops": "!=null"
        },
        "post": {
            "return": "struct lcd_device or ERR_PTR"
        }
    }
},
{
    "kretprobe:devm_lcd_device_unregister": {
        "description": "Deallocated a lcd allocated with devm_lcd_device_register(). Normally this function will not need to be called and the resource management code will ensure that the resource is freed.",
        "pre": {
            "dev": "!=null",
            "ld": "!=null"
        }
    }
},
{
    "kprobe:devm_lcd_device_unregister": {
        "description": "Deallocated a lcd allocated with devm_lcd_device_register(). Normally this function will not need to be called and the resource management code will ensure that the resource is freed.",
        "pre": {
            "dev": "!=null",
            "ld": "!=null"
        }
    }
},
{
    "kretprobe:locomolcd_power": {
        "description": "Power on or off the locomolcd device.",
        "pre": {
            "on": "==1",
            "comadj": "-1",
            "machine_is_collie()": "==1"
        }
    }
},
{
    "kprobe:locomolcd_power": {
        "description": "Power on or off the locomolcd device.",
        "pre": {
            "on": "!=null"
        }
    }
},
{
    "kretprobe:mac_vmode_to_var": {
        "description": "Converts vmodecmode pair to var structure",
        "pre": {
            "vmode": "!=null",
            "cmode": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kprobe:mac_vmode_to_var": {
        "description": "Converts vmodecmode pair to var structure",
        "pre": {
            "vmode": "!=null",
            "cmode": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kretprobe:mac_map_monitor_sense": {
        "description": "Convert monitor sense to vmode",
        "pre": {
            "sense": "!=null"
        }
    }
},
{
    "kprobe:mac_map_monitor_sense": {
        "description": "Convert monitor sense to vmode",
        "pre": {
            "sense": "!=null"
        }
    }
},
{
    "kretprobe:mac_find_mode": {
        "description": "Find a video mode",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "mode_option": "!=null",
            "default_bpp": "!=null"
        }
    }
},
{
    "kprobe:mac_find_mode": {
        "description": "Find a video mode",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "mode_option": "!=null",
            "default_bpp": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:omap_enable_lcd_dma": {
        "description": "Set the Enable bit only if an external controller is connected. Otherwise, the OMAP internal controller will start the transfer when it gets enabled.",
        "pre": {
            "cpu_is_omap15xx()": true,
            "!lcd_dma.ext_ctrl": true
        },
        "post": {
            "w": "!=null",
            "omap_readw(OMAP1610_DMA_LCD_CTRL)": "!=null",
            "w |= 1 << 8": true,
            "omap_writew(w, OMAP1610_DMA_LCD_CTRL)": true,
            "lcd_dma.active": 1,
            "omap_readw(OMAP1610_DMA_LCD_CCR)": "!=null",
            "w |= 1 << 7": true,
            "omap_writew(w, OMAP1610_DMA_LCD_CCR)": true
        }
    }
},
{
    "kprobe:omap_enable_lcd_dma": {
        "description": "Set the Enable bit only if an external controller is connected. Otherwise, the OMAP internal controller will start the transfer when it gets enabled.",
        "pre": {
            "cpu_is_omap15xx()": true,
            "!lcd_dma.ext_ctrl": true
        }
    }
},
S,
{
    "kprobe:omap_writew": {
        "description": "Write a 16-bit value to the specified address.",
        "pre": {
            "addr": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:set_b1_regs": {
        "description": "Set the B1 registers.",
        "pre": {}
    },
    "kprobe:cpu_is_omap15xx": {
        "description": "Check if the CPU is OMAP15xx.",
        "pre": {}
    }
},
{
    "kretprobe:omapfb_notify_clients": {
        "description": "Notify clients of omapfb device about an event.",
        "pre": {
            "fbdev": "!=null",
            "event": "!=null",
            "OMAPFB_PLANE_NUM": ">=0"
        }
    }
},
{
    "kprobe:omapfb_notify_clients": {
        "description": "Notify clients of omapfb_device about an event.",
        "pre": {
            "fbdev": "!=null",
            "event": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mpitch = (mpitch >> 1) | 0x8000; /* disable linearization `": {
        "description": "Disable linearization by modifying the value of mpitch.",
        "pre": {
            "mpitch": "!=null",
            "mpitch": "(mpitch >> 1) | 0x8000"
        }
    }
},
{
    "kprobe:mpitch = (mpitch >> 1) | 0x8000; /* disable linearization */": {
        "description": "Disable linearization by modifying mpitch.",
        "pre": {
            "minfo->fbcon.var.xres_virtual": "!=null"
        }
    }
},
{
    "kretprobe:hw->DACreg[POS1064_XOUTPUTCONN]": {
        "description": "Disable outputs",
        "pre": {
            "hw": "!=null",
            "POS1064_XOUTPUTCONN": "==0x00"
        }
    }
},
{
    "kprobe:hw->DACreg[POS1064_XOUTPUTCONN] = 0x00;/* disable outputs": {
        "description": "Disable outputs",
        "pre": {
            "hw": "is of type struct matrox_hw_state",
            "POS1064_XOUTPUTCONN": "is a valid index for DACreg array",
            "hw->DACreg[POS1064_XOUTPUTCONN]": "= 0x00"
        }
    }
},
S,
S,
S,
{
    "kprobe:matroxfb_unregister_driver": {
        "description": "Unregister a matroxfb driver.",
        "pre": {
            "b->vendor": "==null",
            "dev": ">0"
        }
    }
},
{
    "kretprobe:matrox_pan_var": {
        "description": "The matrox_pan_var function",
        "pre": {
            "minfo": "!=null",
            "var": "!=null"
        }
    }
},
"minfo": {
    "crtc1": {
        "vsync": "!=null"
    },
    "devflags": {
        "accelerator": "!=null"
    }
},
{
    "kretprobe:mga_outl": {
        "description": "Write the value of *bm* to the *M_ICLEAR* register.",
        "pre": {
            "bm": "!=null"
        }
    },
    "kretprobe:mga_outl": {
        "description": "Write the value of *mga_inl(M_IEN) | bm* to the *M_IEN* register.",
        "pre": {
            "mga_inl(M_IEN)": "!=null",
            "bm": "!=null"
        }
    },
    "kretprobe:reenable": {
        "description": "Check if *reenable* is true.",
        "pre": {
            "reenable": "==true"
        }
    }
},
{
    "kprobe:mga_outl": {
        "description": "Write the value of *bm* to the *M_ICLEAR* register.",
        "pre": {
            "bm": "!=null"
        }
    },
    "kprobe:mga_outl": {
        "description": "Write the value of *mga_inl(M_IEN) | bm* to the *M_IEN* register.",
        "pre": {
            "mga_inl(M_IEN)": "!=null",
            "bm": "!=null"
        }
    },
    "kprobe:reenable": {
        "description": "Check if *reenable* is true.",
        "pre": {
            "reenable": "==true"
        }
    }
},
{
    "kretprobe:g450_nextpll": {
        "description": "Calculate the next PLL value based on the given parameters.",
        "pre": {
            "minfo": "!=null",
            "pi": "!=null",
            "fvco": "!=null",
            "mnp": "!=null",
            "g450_mnp2f(minfo, mnp)": "!=null",
            "g450_vco2f(mnp, g450_mnp2vco(minfo, mnp))": "!=null",
            "pll_freq_delta(g450_mnp2f(minfo, mnp), g450_vco2f(mnp, g450_mnp2vco(minfo, mnp)))": ">= 0"
        }
    }
},
S,
S,
S,
S,
{
    "kprobe:matroxfb_var2my": {
        "description": "Converts the fb_var_screeninfo struct to my_timming struct.",
        "pre": {
            "var": "!=null",
            "mt": "!=null",
            "var->pixclock": "!=0",
            "var->pixclock": ">=10000",
            "mt->pixclock": "=1000000000 / var->pixclock",
            "mt->pixclock": ">=1",
            "mt->mnp": "=-1",
            "mt->dblscan": "=var->vmode & FB_VMODE_DOUBLE",
            "mt->interlaced": "=var->vmode & FB_VMODE_INTERLACED",
            "mt->HDisplay": "=var->xres",
            "mt->HSyncStart": "=mt->HDisplay + var->right_margin",
            "mt->HSyncEnd": "=mt->HSyncStart + var->hsync_len",
            "mt->HTotal": "=mt->HSyncEnd + var->left_margin",
            "mt->VDisplay": "=var->yres",
            "mt->VSyncStart": "=mt->VDisplay + var->lower_margin",
            "mt->VSyncEnd": "=mt->VSyncStart + var->vsync_len",
            "mt->VTotal": "=mt->VSyncEnd + var->upper_margin",
            "mt->sync": "=var->sync"
        }
    }
},
S,
S,
{
    "kretprobe:bd->output.tvout = 0;if (readb(vbios + 0x1D) != 'I' || readb(vbios + 0x1E) != 'B' || readb(vbios + 0x1F) != 'M' || readb(vbios + 0x20) != ' ')": {
        "description": "Set bd->output.tvout to 0 and check if the values at addresses vbios + 0x1D, vbios + 0x1E, vbios + 0x1F, and vbios + 0x20 are 'I', 'B', 'M', and ' ' respectively.",
        "pre": {
            "bd->output.tvout": "== 0",
            "readb(vbios + 0x1D)": "== 'I'",
            "readb(vbios + 0x1E)": "== 'B'",
            "readb(vbios + 0x1F)": "== 'M'",
            "readb(vbios + 0x20)": "== ' '"
        }
    }
},
{
    "kprobe:bd->output.tvout = 0;if (readb(vbios + 0x1D) != 'I' || readb(vbios + 0x1E) != 'B' || readb(vbios + 0x1F) != 'M' || readb(vbios + 0x20) != ' ')": {
        "description": "Set bd->output.tvout to 0 if the bytes at vbios + 0x1D, vbios + 0x1E, vbios + 0x1F, and vbios + 0x20 are not equal to 'I', 'B', 'M', and ' ' respectively.",
        "pre": {
            "bd": "!=null",
            "vbios": "!=null",
            "vbios + 0x1D": "!=null",
            "vbios + 0x1E": "!=null",
            "vbios + 0x1F": "!=null",
            "vbios + 0x20": "!=null",
            "readb(vbios + 0x1D)": "!='I'",
            "readb(vbios + 0x1E)": "!='B'",
            "readb(vbios + 0x1F)": "!='M'",
            "readb(vbios + 0x20)": "!=' '"
        }
    }
},
S,
{
    "kprobe:EXPORT_SYMBOL(matroxfb_vgaHWrestore);/* DAC1064, Ti3026 */": {
        "description": "DAC1064, Ti3026",
        "pre": {
            "minfo": "!=null",
            "minfo->pcidev": "!=null",
            "minfo->bios": "!=null",
            "minfo->devflags.fbResource": "!=null",
            "minfo->video.vbase": "!=null",
            "minfo->bios.bios_valid": "==true",
            "minfo->values.reg.opt": "!=null"
        }
    }
},
{
    "kretprobe:cfb_copyarea": {
        "description": "Copy an area from source to destination in a framebuffer.",
        "pre": {
            "p": "!=null",
            "area": "!=null",
            "dx": "==dy",
            "dy": "==sy",
            "sx": "<dx",
            "sy": "<dy"
        }
    }
},
{
    "kprobe:cfb_copyarea": {
        "description": "Copy an area from source to destination in a framebuffer.",
        "pre": {
            "dy": "!=null",
            "sy": "!=null",
            "dx": "!=null",
            "sx": "!=null",
            "condition": "(dy == sy && dx > sx) || (dy > sy)"
        }
    }
},
{
    "kretprobe:left": {
        "description": "Calculate the remainder of bits divided by bpp and check if it is zero.",
        "pre": {
            "bits": "!=null",
            "bpp": "!=null",
            "p->fbops->fb_sync": "!=null",
            "p->state": "==FBINFO_STATE_RUNNING",
            "p->fix.visual": "in [FB_VISUAL_TRUECOLOR, FB_VISUAL_DIRECTCOLOR]",
            "rect->color": "!=null",
            "rect->dy": "!=null",
            "rect->dx": "!=null",
            "p->screen_base": "!=null",
            "p->fix.line_length": "!=null",
            "bpp": "in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]"
        }
    }
},
{
    "kprobe:left = bits % bpp;if (p->fbops->fb_sync)p->fbops->fb_sync(p);if (!left)": {
        "description": "Calculate left as bits modulo bpp and perform additional operations based on the value of left.",
        "pre": {
            "p": {
                "type": "struct fb_info",
                "state": "FBINFO_STATE_RUNNING",
                "fix.visual": {
                    "in": ["FB_VISUAL_TRUECOLOR", "FB_VISUAL_DIRECTCOLOR"],
                    "pseudo_palette": "is_array",
                    "rect->color": "is_valid_index(pseudo_palette)"
                },
                "fix.visual": {
                    "not_in": ["FB_VISUAL_TRUECOLOR", "FB_VISUAL_DIRECTCOLOR"],
                    "rect->color": "is_valid_color"
                }
            },
            "rect": {
                "type": "const struct fb_fillrect",
                "width": "!=null",
                "height": "!=null",
                "dy": "!=null",
                "dx": "!=null",
                "p->fix.line_length": "!=null"
            },
            "bpp": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:fb_var_to_videomode": {
        "description": "Convert fb_var_screeninfo to fb_videomode",
        "pre": {
            "mode": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kprobe:fb_var_to_videomode": {
        "description": "Convert fb_var_screeninfo to fb_videomode",
        "pre": {
            "mode": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kretprobe:fb_mode_is_equal": {
        "description": "Compare two videomodes and return 1 if equal, 0 if not.",
        "pre": {
            "mode1": "!=null",
            "mode2": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
S,
{
    "kretprobe:fb_add_videomode": {
        "description": "Adds videomode entry to modelist",
        "pre": {
            "mode": "!=null",
            "head": "!=null"
        }
    }
},
S,
{
    "kretprobe:fb_match_mode": {
        "description": "Find a videomode which exactly matches the timings in var.",
        "pre": {
            "var": "!=null",
            "head": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
S,
{
    "kretprobe:fb_find_best_mode": {
        "description": "Find best matching videomode",
        "pre": {
            "var": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kprobe:fb_find_best_mode": {
        "description": "Find best matching videomode",
        "pre": {
            "var": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kretprobe:fb_find_nearest_mode": {
        "description": "Find closest videomode",
        "pre": {
            "mode": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kprobe:fb_find_nearest_mode": {
        "description": "Find closest videomode",
        "pre": {
            "mode": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kretprobe:fb_videomode_to_modelist": {
        "description": "Convert mode array to mode list",
        "pre": {
            "modedb": "!=null",
            "num": ">=0",
            "head": "!=null"
        }
    }
},
{
    "kprobe:fb_videomode_to_modelist": {
        "description": "Convert mode array to mode list.",
        "pre": {
            "modedb": "!=null",
            "num": ">=0",
            "head": "!=null"
        }
    }
},
{
    "kretprobe:fb_find_mode": {
        "description": "Finds a valid video mode",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "mode_option": "!=null",
            "db": "!=null",
            "dbsize": ">=0",
            "default_mode": "!=null",
            "default_bpp": ">=0"
        }
    }
},
{
    "kprobe:fb_find_mode": {
        "description": "Finds a valid video mode",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "mode_option": "!=null",
            "db": "!=null",
            "dbsize": ">=0",
            "default_mode": "!=null",
            "default_bpp": ">=0"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check the conditions for the if statement",
        "pre": {
            "db": "!=modedb",
            "info->monspecs.vfmin": "!=null",
            "info->monspecs.vfmax": "!=null",
            "info->monspecs.hfmin": "!=null",
            "info->monspecs.hfmax": "!=null",
            "info->monspecs.dclkmax": "!=null"
        }
    }
},
S,
{
    "kretprobe:fb_alloc_cmap_gfp": {
        "description": "Allocate a colormap",
        "pre": {
            "cmap": "!=null",
            "len": ">=0",
            "transp": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:fb_alloc_cmap_gfp": {
        "description": "Allocates memory for a colormap cmap.",
        "pre": {
            "cmap": "!=null",
            "len": ">=0",
            "transp": "in [0, 1]",
            "flags": "is_valid_flags"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kretprobe:fb_dealloc_cmap": {
        "description": "Deallocate a colormap that was previously allocated with fb_alloc_cmap().",
        "pre": {
            "cmap": "!=null"
        }
    }
},
{
    "kprobe:fb_dealloc_cmap": {
        "description": "Deallocate a colormap that was previously allocated with fb_alloc_cmap().",
        "pre": {
            "cmap": "!=null"
        }
    }
},
{
    "kretprobe:fb_set_cmap": {
        "description": "Set the colormap for a screen of device",
        "pre": {
            "cmap": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:fb_set_cmap": {
        "description": "Set the colormap for a screen of device.",
        "pre": {
            "cmap": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fb_invert_cmaps": {
        "description": "Invert all default colormaps.",
        "pre": {}
    }
},
{
    "kprobe:fb_invert_cmaps": {
        "description": "Invert all default colormaps.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kretprobe:fb_register_client": {
        "description": "Register a client notifier",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:fb_register_client": {
        "description": "Register a client notifier",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:fb_unregister_client": {
        "description": "Unregister a client notifier",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:fb_unregister_client": {
        "description": "Unregister a client notifier",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:fb_get_options": {
        "description": "Get kernel boot parameters",
        "pre": {
            "name": "!=null",
            "option": "!=null",
            "*option": "!=null"
        }
    }
},
{
    "kprobe:fb_get_options": {
        "description": "Get kernel boot parameters for a specific framebuffer name.",
        "pre": {
            "name": "!=null",
            "option": "!=null",
            "*option": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:fb_prepare_logo": {
        "description": "Prepare the logo for the framebuffer.",
        "pre": {
            "info": "!=null",
            "rotate": "!=null",
            "depth": ">=0",
            "yres": ">=0",
            "height": ">=0",
            "fb_logo_count": ">=0",
            "info->flags": "& FBINFO_MISC_TILEBLITTING == 0",
            "info->fbops->owner": "== null",
            "info->fix.visual": "in [FB_VISUAL_DIRECTCOLOR, FB_VISUAL_STATIC_PSEUDOCOLOR]",
            "info->var.blue.length": ">=0",
            "info->var.red.length": ">=0",
            "info->var.green.length": ">=0"
        }
    }
},
{
    "kprobe:fb_prepare_logo": {
        "description": "Prepare the logo for the given framebuffer info.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fb_show_logo_line": {
        "description": "Return if the frame buffer is not mapped or suspended",
        "pre": {
            "info->logo": "!=null",
            "info->state": "!=FBINFO_STATE_RUNNING",
            "info->fbops->owner": "!=null"
        },
        "post": {
            "return": "0",
            "image.depth": "8",
            "image.data": "logo->data",
            "fb_logo.needs_cmapreset": "true",
            "fb_logo.needs_truepalette": "true",
            "fb_logo.needs_directpalette": "true"
        }
    }
},
{
    "kprobe:fb_show_logo_line": {
        "description": "Show a line of the logo on the frame buffer.",
        "pre": {
            "info->state": "!= FBINFO_STATE_RUNNING",
            "info->fbops->owner": "!= null",
            "logo == null": true
        }
    }
},
S,
S,
{
    "kretprobe:printk": {
        "description": "Print a warning message if unable to create device for framebuffer.",
        "pre": {
            "i": "!=null",
            "fb_info->dev": "==null",
            "fb_info->pixmap.addr": "==null"
        }
    }
},
{
    "kprobe:printk": {
        "description": "Print a warning message if unable to create device for framebuffer.",
        "pre": {
            "i": "!=null",
            "fb_info->dev": "!=null",
            "fb_info->pixmap.addr": "==null"
        }
    }
},
{
    "kretprobe:put_fb_info": {
        "description": "Registers a frame buffer device.",
        "pre": {
            "fb_info": "!=null"
        },
        "post": {
            "return_value": ">= -errno"
        }
    }
},
{
    "kprobe:put_fb_info": {
        "description": "Registers a frame buffer device.",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fb_set_suspend": {
        "description": "Low level driver signals suspend",
        "pre": {
            "info": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:fb_set_suspend": {
        "description": "Low level driver signals suspend.",
        "pre": {
            "info": "!=null",
            "state": "int"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:svga_wseq_multi": {
        "description": "Write a sequencer register value spread across multiple registers",
        "pre": {
            "regbase": "!=null",
            "regset": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:svga_wseq_multi": {
        "description": "Write a sequencer register value spread across multiple registers",
        "pre": {
            "regbase": "!=null",
            "regset": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:/* Set graphics controller registers to sane values ": {
        "description": "Set graphics controller registers to sane values.",
        "pre": {
            "regbase": "!=null",
            "regset": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:/* Set graphics controller registers to sane values */": {
        "description": "Set graphics controller registers to sane values.",
        "pre": {
            "regbase": "!=null",
            "regset": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:vga_wgfx": {
        "description": "Set default values for all standard GFX registers in the SVGA context.",
        "pre": {
            "regbase": "!=null",
            "VGA_GFX_SR_VALUE": "!=null",
            "VGA_GFX_SR_ENABLE": "!=null",
            "VGA_GFX_COMPARE_VALUE": "!=null",
            "VGA_GFX_DATA_ROTATE": "!=null",
            "VGA_GFX_PLANE_READ": "!=null",
            "VGA_GFX_MODE": "!=null"
        }
    }
},
{
    "kprobe:vga_wgfx": {
        "description": "Set the value of a VGA graphics register.",
        "pre": {
            "regbase": "!=null",
            "VGA_GFX_SR_VALUE": "==0x00"
        }
    }
},
S,
S,
{
    "kretprobe:vga_wseq": {
        "description": "Set VGA sequencer registers",
        "pre": {
            "vga_wseq_1": {
                "description": "Set VGA sequencer clock mode to VGA_SR01_CHAR_CLK_8DOTS",
                "pre": {
                    "regbase": "!=null",
                    "VGA_SEQ_CLOCK_MODE": "==VGA_SR01_CHAR_CLK_8DOTS"
                }
            },
            "vga_wseq_2": {
                "description": "Set VGA sequencer plane write mode to VGA_SR02_ALL_PLANES",
                "pre": {
                    "regbase": "!=null",
                    "VGA_SEQ_PLANE_WRITE": "==VGA_SR02_ALL_PLANES"
                }
            },
            "vga_wseq_3": {
                "description": "Set VGA sequencer character map to 0x00",
                "pre": {
                    "regbase": "!=null",
                    "VGA_SEQ_CHARACTER_MAP": "==0x00"
                }
            }
        }
    }
},
{
    "kprobe:vga_wseq": {
        "description": "Write a value to a VGA sequencer register.",
        "pre": {
            "regbase": "!=null",
            "reg": "in [VGA_SEQ_CLOCK_MODE, VGA_SEQ_PLANE_WRITE, VGA_SEQ_CHARACTER_MAP]",
            "value": "!=null"
        }
    }
},
S,
{
    "kprobe:svga_wcrt_mask": {
        "description": "Enable vertical retrace EVRA",
        "pre": {
            "regbase": "!=null",
            "0x03": "!=null",
            "0x80": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:svga_tilecopy": {
        "description": "Copy area in text (tileblit) mode",
        "pre": {
            "info": "!=null",
            "area": "!=null",
            "info->screen_base": "!=null",
            "area->data": "!=null",
            "area->width": "==8",
            "area->height": "==16",
            "area->depth": "==1",
            "area->length": "==256"
        }
    }
},
{
    "kprobe:svga_tilecopy": {
        "description": "Copy area in text (tileblit) mode",
        "pre": {
            "info": "!=null",
            "area": "!=null",
            "info->screen_base": "!=null",
            "area->data": "!=null",
            "area->width": "==8",
            "area->height": "==16",
            "area->depth": "==1",
            "area->length": "==256"
        }
    }
},
{
    "kretprobe:svga_tilecopy": {
        "description": "The svga_tilecopy function copies a tile from the source area to the destination area in the framebuffer.",
        "pre": {
            "info": "!=null",
            "area": "!=null",
            "dx": "!=null",
            "dy": "!=null",
            "colstride": "==(1 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK)) / 2",
            "rowstride": "==(1 << (info->fix.type_aux & FB_AUX_TEXT_SVGA_MASK)) / 2 * (info->var.xres_virtual / 8)",
            "fb": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "area->sy > area->dy || (area->sy == area->dy && area->sx > area->dx)": "true"
        }
    }
},
{
    "kprobe:svga_tilecopy": {
        "description": "svga_tilecopy function",
        "pre": {
            "info": "!=null",
            "area": "!=null",
            "info.fix.type_aux": "& FB_AUX_TEXT_SVGA_MASK != 0",
            "colstride": "1 << (info.fix.type_aux & FB_AUX_TEXT_SVGA_MASK)",
            "rowstride": "colstride * (info.var.xres_virtual / 8)",
            "fb": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "area.sy > area.dy": "true",
            "area.sy == area.dy && area.sx > area.dx": "true"
        }
    }
},
{
    "kretprobe:svga_tileblit": {
        "description": "Write text in text (tileblit) mode",
        "pre": {
            "info": "!=null",
            "blit": "!=null",
            "info->fix.type_aux": "!=null",
            "info->var.xres_virtual": "!=null",
            "rect->bg": "!=null",
            "rect->fg": "!=null",
            "info->screen_base": "!=null",
            "rect->sx": "!=null",
            "rect->sy": "!=null",
            "rect->height": "!=null",
            "rect->width": "!=null",
            "rect->index": "!=null"
        }
    }
},
{
    "kprobe:svga_tileblit": {
        "description": "Write text in text (tileblit) mode",
        "pre": {
            "info": "!=null",
            "blit": "!=null",
            "info->fix.type_aux": "!=null",
            "info->var.xres_virtual": "!=null",
            "rect->bg": "!=null",
            "rect->fg": "!=null",
            "info->screen_base": "!=null",
            "rect->sx": "!=null",
            "rect->sy": "!=null",
            "rect->height": "!=null",
            "rect->width": "!=null",
            "rect->index": "!=null"
        }
    }
},
{
    "kretprobe:svga_tilecursor": {
        "description": "Set cursor in text (tileblit) mode",
        "pre": {
            "regbase": "!=null",
            "info": "!=null",
            "cursor": "!=null",
            "info->fix.type_aux": ">=0",
            "info->var.xres_virtual": ">=0",
            "blit->bg": ">=0",
            "blit->fg": ">=0",
            "blit->sx": ">=0",
            "blit->sy": ">=0",
            "blit->width": ">=0",
            "blit->height": ">=0",
            "blit->length": ">=0"
        }
    }
},
{
    "kprobe:svga_tilecursor": {
        "description": "Set cursor in text (tileblit) mode",
        "pre": {
            "regbase": "!=null",
            "info": "!=null",
            "cursor": "!=null",
            "info->fix.type_aux": "!=null",
            "info->var.xres_virtual": "!=null",
            "blit->bg": "!=null",
            "blit->fg": "!=null",
            "info->screen_base": "!=null",
            "blit->sx": "!=null",
            "blit->sy": "!=null",
            "blit->height": "!=null",
            "blit->width": "!=null",
            "blit->indices": "!=null",
            "blit->length": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:svga_get_caps": {
        "description": "Get capabilities of accelerator based on the mode",
        "pre": {
            "info": "!=null",
            "caps": "!=null",
            "var": "!=null",
            "svga_get_tilemax(info)": "==256"
        }
    }
},
{
    "kprobe:svga_get_caps": {
        "description": "Get capabilities of accelerator based on the mode",
        "pre": {
            "info": "!=null",
            "caps": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kretprobe:svga_compute_pll": {
        "description": "Compute the PLL for SVGA with given parameters.",
        "pre": {
            "(f_vco >> ar)": "!= f_wanted",
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:svga_compute_pll": {
        "description": "Compute the PLL for SVGA with the given parameters.",
        "pre": {
            "pll": "!=null",
            "f_wanted": "!=null",
            "m": "!=null",
            "n": "!=null",
            "r": "!=null",
            "node": "!=null",
            "ar": "!=null",
            "f_vco": "!=null",
            "f_current": "!=null",
            "delta_current": "!=null",
            "delta_best": "!=null"
        }
    }
},
{
    "kretprobe:svga_check_timings": {
        "description": "Check horizontal display and blank start",
        "pre": {
            "tm": "!=null",
            "var": "!=null",
            "node": "!=null",
            "var->xres": "!=null",
            "var->left_margin": "!=null",
            "var->right_margin": "!=null",
            "var->hsync_len": "!=null",
            "value": "!=null",
            "svga_regset_size(tm->h_total_regs)": "!=null",
            "(value / 8) - 5": ">= svga_regset_size(tm->h_total_regs)"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:svga_check_timings": {
        "description": "Check horizontal display and blank start",
        "pre": {
            "tm": "!=null",
            "var": "!=null",
            "node": "is integer"
        },
        "value": {
            "calculation": "var->xres + var->left_margin + var->right_margin + var->hsync_len",
            "condition": "(((value / 8) - 5) >= svga_regset_size(tm->h_total_regs))"
        },
        "return": "-EINVAL"
    }
},
{
    "kretprobe:regval = vga_r": {
        "description": "Read a value from the VGA register.",
        "pre": {
            "regbase": "!=null",
            "var": "!=null",
            "var->sync": "& FB_SYNC_HOR_HIGH_ACT"
        }
    }
},
S,
{
    "for_loop": {
        "condition": "i < specs->modedb_len",
        "body": {
            // code block conditions
        }
    }
},
{
    "for (i = 0; i < specs->modedb_len; i++)": {
        "description": "Loop over the `specs->modedb` array",
        "pre": {
            "i": ">= 0",
            "i": "< specs->modedb_len",
            "specs->modedb": "!= null",
            "specs->modedb_len": ">= 0"
        }
    }
},
S,
S,
{
    "kretprobe:fb_validate_mode": {
        "description": "Validates video mode against monitor capabilities specified in info->monspecs.",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "info->monspecs": "!=null"
        }
    }
},
{
    "kprobe:fb_validate_mode": {
        "description": "Validates video mode against monitor capabilities specified in info->monspecs.",
        "pre": {
            "var": "!=null",
            "info": "!=null",
            "info->monspecs": "!=null"
        }
    }
},
{
    "kretprobe:fb_destroy_modedb": {
        "description": "destroys mode database",
        "pre": {
            "modedb": "!=null"
        }
    }
},
{
    "kprobe:fb_destroy_modedb": {
        "description": "Destroys mode database",
        "pre": {
            "modedb": "!=null"
        }
    }
},
{
    "kretprobe:omap_vrfb_max_height": {
        "description": "Calculate the maximum height for a virtual view provided by VRFB.",
        "pre": {
            "phys_size": ">= 0",
            "width": ">= 0",
            "bytespp": ">= 0",
            "image_width_roundup": "= get_image_width_roundup(width, bytespp)",
            "extra": "= get_extra_physical_size(image_width_roundup, bytespp)",
            "image_width_roundup > OMAP_VRFB_LINE_LEN": "return 0",
            "phys_size < extra": "return 0",
            "height": "= (phys_size - extra) / (width * bytespp)",
            "height <= 2048": "true"
        }
    }
},
{
    "kprobe:return min_t(unsigned long, height, 2048);}EXPORT_SYMBOL(omap_vrfb_max_height": {
        "description": "Calculates the maximum height of a virtual view provided by VRFB.",
        "pre": {
            "phys_size": "!=null",
            "width": "!=null",
            "bytespp": "!=null",
            "image_width_roundup": "= get_image_width_roundup(width, bytespp)",
            "height": "!=null",
            "extra": "!=null",
            "image_width_roundup > OMAP_VRFB_LINE_LEN": "false",
            "phys_size < extra": "false",
            "height = (phys_size - extra) / (width * bytespp)": "true",
            "height <= 2048": "true"
        }
    }
},
{
    "kretprobe:if (yuv_mode)": {
        "description": "Condition for the if statement with yuv_mode",
        "pre": {
            "yuv_mode": "true"
        }
    }
},
{
    "kprobe:omap_vrfb_setup": {
        "description": "Setup VRFB with the given parameters.",
        "pre": {
            "vrfb": "!=null",
            "paddr": "!=null",
            "width": "!=null",
            "height": "!=null",
            "bytespp": "!=null",
            "yuv_mode": true
        }
    }
},
{
    "kretprobe:if (dssdev->dev->of_node)": {
        "description": "Check if the `of_node` field of `dssdev->dev` is not null.",
        "pre": {
            "dssdev": {
                "dev": {
                    "of_node": "!=null"
                }
            }
        }
    }
},
{
    "if (dssdev->dev->of_node)": {
        "description": "Check if the of_node field of dssdev->dev is not null.",
        "pre": {
            "dssdev": "!=null",
            "dssdev->dev": "!=null",
            "dssdev->dev->of_node": "!=null"
        }
    }
},
{
    "kretprobe:dispc_ovl_set_burst_size": {
        "description": "Set the burst size for the specified plane.",
        "pre": {
            "plane": "in [OMAP_DSS_GFX, OMAP_DSS_VIDEO1, OMAP_DSS_VIDEO2, OMAP_DSS_VIDEO3, OMAP_DSS_WB]",
            "burst_size": "in [BURST_SIZE_X8]"
        }
    }
},
{
    "kprobe:dispc_ovl_set_burst_size": {
        "description": "Set the burst size for the specified overlay plane.",
        "pre": {
            "plane": "in [OMAP_DSS_GFX, OMAP_DSS_VIDEO1, OMAP_DSS_VIDEO2, OMAP_DSS_VIDEO3]",
            "burst_size": "in [OMAP_BURST_SIZE_X8, OMAP_BURST_SIZE_X16, OMAP_BURST_SIZE_X32, OMAP_BURST_SIZE_X64, OMAP_BURST_SIZE_X128]"
        }
    }
},
{
    "kretprobe:dispc.fifo_assignment[fifo] = fifo;}/* * The GFX fifo on OMAP4 is smaller than the other fifos. The small fifo * causes problems with certain use cases, like using the tiler in 2D * mode. The below hack swaps the fifos of GFX and WB planes, thus * giving GFX plane a larger fifo. WB but should work fine with a * smaller fifo. */": {
        "description": "Assigns the value of `fifo` to `dispc.fifo_assignment[fifo]`.",
        "pre": {
            "channel": "in [OMAP_DSS_CHANNEL_DIGIT]",
            "enable": "bool"
        },
        "post": {
            "dispc.fifo_assignment[fifo]": "== fifo"
        }
    }
},
{
    "kprobe:dispc.fifo_assignment[fifo] = fifo;}/* * The GFX fifo on OMAP4 is smaller than the other fifos. The small fifo * causes problems with certain use cases, like using the tiler in 2D * mode. The below hack swaps the fifos of GFX and WB planes, thus * giving GFX plane a larger fifo. WB but should work fine with a * smaller fifo. */": {
        "description": "Assigns the value of `fifo` to `dispc.fifo_assignment[fifo]`.",
        "pre": {
            "fifo": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:dispc_clear_irqstatus": {
        "description": "Clear the irqstatus for newly enabled irqs",
        "pre": {
            "mask": "!=null",
            "old_mask": "!=null"
        }
    },
    "kretprobe:dispc_write_reg": {
        "description": "Write the value of `mask` to the DISPC_IRQENABLE register",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kprobe:dispc_clear_irqstatus": {
        "description": "Clear the irqstatus for newly enabled irqs",
        "pre": {
            "mask": "!=null",
            "old_mask": "!=null"
        }
    },
    "kprobe:dispc_write_reg": {
        "description": "Write the value of `mask` to the DISPC_IRQENABLE register",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:smp_wmb": {
        "description": "Memory barrier that ensures that all memory operations before the barrier are completed before any memory operation after the barrier.",
        "pre": {},
        "post": {
            "r": "!=null"
        }
    },
    "kretprobe:devm_request_irq": {
        "description": "Request an interrupt line for a device.",
        "pre": {
            "dev": "!=null",
            "irq": "!=null",
            "handler": "!=null",
            "flags": "in [IRQF_SHARED]",
            "name": "==\"OMAP DISPC\"",
            "dev_id": "!=null"
        },
        "post": {
            "r": "!=null"
        }
    }
},
S,
{
    "kretprobe:omap_dispc_register_isr": {
        "description": "Register an interrupt service routine for omap_dispc.",
        "pre": {
            "isr": "!=null",
            "arg": "no specific constraint mentioned",
            "mask": "no specific constraint mentioned"
        },
        "post": {
            "ret": "no specific constraint mentioned"
        }
    }
},
S,
{
    "kretprobe:omap_dispc_unregister_isr": {
        "description": "Unregister an ISR (Interrupt Service Routine) from the OMAP Display Controller.",
        "pre": {
            "isr_data->isr": "==null",
            "isr_data->arg": "==null",
            "isr_data->mask": "==0",
            "ret": "==0"
        },
        "post": {
            "_omap_dispc_set_irqs()": "called",
            "spin_unlock_irqrestore(&dispc_compat.irq_lock, flags)": "called",
            "ret": "return value"
        }
    }
},
{
    "kprobe:omap_dispc_unregister_isr": {
        "description": "Unregister an ISR (Interrupt Service Routine) from OMAP Display Controller.",
        "pre": {
            "isr": "!=null",
            "arg": "!=null",
            "mask": "=0"
        }
    }
},
{
    "kretprobe:clkdev_drop": {
        "description": "Remove a clock dynamically allocated.",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kprobe:clkdev_drop": {
        "description": "Remove a clock dynamically allocated.",
        "pre": {
            "cl": "!=null"
        }
    }
},
{
    "kretprobe:clk_register_clkdev": {
        "description": "Register one clock lookup for a struct clk.",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null",
            "ap": "!=null"
        },
        "post": {
            "cl": "!=null",
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:clk_register_clkdev": {
        "description": "Register one clock lookup for a struct clk.",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null",
            "ap": "!=null"
        }
    }
},
{
    "kretprobe:clk_hw_register_clkdev": {
        "description": "Register one clock lookup for a struct clk_hw",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:clk_hw_register_clkdev": {
        "description": "Register one clock lookup for a struct clk_hw",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:devm_clk_hw_register_clkdev": {
        "description": "Managed clk lookup registration for clk_hw",
        "pre": {
            "dev": "!=null",
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:devm_clk_hw_register_clkdev": {
        "description": "Managed clk lookup registration for clk_hw",
        "pre": {
            "dev": "!=null",
            "hw": "!=null",
            "con_id": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:clk_hw_get_clk": {
        "description": "Get clk consumer given a clk_hw",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null"
        }
    }
},
{
    "kprobe:clk_hw_get_clk": {
        "description": "Get clk consumer given a clk_hw",
        "pre": {
            "hw": "!=null",
            "con_id": "!=null"
        }
    }
},
{
    "kretprobe:clk_core_get": {
        "description": "Find the clk_core parent of a clk",
        "pre": {
            "core": "!=null",
            "p_index": "!=null"
        }
    }
},
{
    "kprobe:clk_core_get": {
        "description": "Find the clk_core parent of a clk",
        "pre": {
            "core": "!=null",
            "p_index": "!=null"
        }
    }
},
{
    "kretprobe:of_clk_get_by_name": {
        "description": "Parse and lookup a clock referenced by a device node",
        "pre": {
            "np": "!=null",
            "name": "!=null or ==null"
        }
    }
},
{
    "kprobe:of_clk_get_by_name": {
        "description": "Parse and lookup a clock referenced by a device node",
        "pre": {
            "np": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:tegra_dfll_runtime_resume": {
        "description": "Enable all clocks needed by the DFLL.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:tegra_dfll_runtime_resume": {
        "description": "Enable all clocks needed by the DFLL.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:tegra_dfll_runtime_suspend": {
        "description": "Disable all clocks needed by the DFLL. Assumes that other code will later call clk_unprepare().",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:tegra_dfll_runtime_suspend": {
        "description": "Disable all clocks needed by the DFLL. Assumes that other code will later call clk_unprepare().",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:tegra_dfll_suspend": {
        "description": "Check if DFLL is disabled",
        "pre": {
            "dev": "!=null",
            "DFLL_clock_disabled": "true",
            "DFLL_clocks_disabled": "true"
        }
    }
},
S,
{
    "kretprobe:tegra_dfll_resume": {
        "description": "Reinitialize DFLL on resume.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:tegra_dfll_resume": {
        "description": "Reinitialize DFLL on resume",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:tegra_dfll_register": {
        "description": "Probe and initialize a Tegra DFLL device instance.",
        "pre": {
            "pdev": "!=null",
            "soc": "!=null"
        }
    }
},
{
    "kprobe:tegra_dfll_register": {
        "description": "Probe and initialize a Tegra DFLL device instance.",
        "pre": {
            "pdev": "!=null",
            "soc": "!=null"
        }
    }
},
{
    "kretprobe:tegra_dfll_unregister": {
        "description": "Release all of the DFLL driver resources for a device",
        "pre": {
            "pdev": "!=null",
            "pdev->dfll_enabled": "==0"
        },
        "post": {
            "retval": "!=null",
            "retval": "in [soc pointer, -EBUSY]"
        }
    }
},
{
    "kprobe:tegra_dfll_unregister": {
        "description": "Release all of the DFLL driver resources for a device",
        "pre": {
            "pdev": "!=null",
            "pdev->dfll_enabled": "==false"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:tegra114_clock_tune_cpu_trimmers_high": {
        "description": "Use high-voltage propagation delays. When the CPU rail voltage is in the high-voltage range, use the built-in hardwired clock propagation delays in the CPU clock shaper.",
        "pre": {}
    }
},
S,
S,
S,
{
    "kretprobe:tegra114_clock_assert_dfll_dvco_reset": {
        "description": "Assert the reset line of the DFLL's DVCO.",
        "pre": {
            "reset_line": "asserted"
        }
    }
},
S,
{
    "kretprobe:tegra114_clock_deassert_dfll_dvco_reset": {
        "description": "Deassert the reset line of the DFLL's DVCO, allowing it to operate.",
        "pre": {}
    }
},
{
    "kprobe:tegra114_clock_deassert_dfll_dvco_reset": {
        "description": "Deassert the reset line of the DFLL's DVCO, allowing it to operate.",
        "pre": {}
    }
},
{
    "kretprobe:ptp_clock_register": {
        "description": "Initialize a clock structure.",
        "pre": {
            "info": "!=null",
            "parent": "!=null",
            "err": "=-ENOMEM",
            "ptp": "=kzalloc(sizeof(struct ptp_clock), GFP_KERNEL)",
            "ptp == NULL": "goto no_memory",
            "index": "=ida_alloc_max(&ptp_clocks_map, MINORMASK, GFP_KERNEL)",
            "index < 0": ""
        }
    }
},
{
    "kprobe:ptp_clock_register": {
        "description": "Initialize a clock structure.",
        "pre": {
            "info.n_alarm": "<= PTP_MAX_ALARMS",
            "parent": "!= null"
        }
    }
},
{
    "kretprobe:ptp_clock_unregister": {
        "description": "Release the clock's resources.",
        "pre": {
            "ptp": {
                "pps_source": "!=null"
            }
        }
    }
},
{
    "kprobe:ptp_clock_unregister": {
        "description": "Release the clock's resources.",
        "pre": {
            "ptp": {
                "pps_source": "!=null",
                "clock": "!=null",
                "kworker": "!=null"
            }
        }
    }
},
S,
S,
{
    "kretprobe:pch_set_station_address": {
        "description": "This API sets the station address used by IEEE 1588 hardware when looking at PTP traffic on the ethernet interface.",
        "pre": {
            "addr": "!=null",
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pch_set_station_address": {
        "description": "This API sets the station address used by IEEE 1588 hardware when looking at PTP traffic on the ethernet interface.",
        "pre": {
            "addr": "!=null",
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:mcp_set_telecom_divisor": {
        "description": "Set the telecom divisor on the MCP interface.",
        "pre": {
            "mcp": "!=null",
            "div": "!=null"
        }
    }
},
{
    "kprobe:mcp_set_telecom_divisor": {
        "description": "Set the telecom divisor",
        "pre": {
            "mcp": "!=null",
            "div": "!=null",
            "div": ">=0"
        }
    }
},
{
    "kretprobe:mcp_set_audio_divisor": {
        "description": "Set the audio divisor on the MCP interface.",
        "pre": {
            "mcp": "!=null",
            "div": "!=null"
        }
    }
},
{
    "kprobe:mcp_set_audio_divisor": {
        "description": "Set the audio divisor on the MCP interface.",
        "pre": {
            "mcp": "!=null",
            "div": "!=null",
            "div": ">=0"
        }
    }
},
{
    "kretprobe:mcp_reg_write": {
        "description": "Write a device register.",
        "pre": {
            "mcp": "!=null",
            "reg": "!=null",
            "val": "!=null",
            "mcp_interface_enabled": "==true"
        }
    }
},
{
    "kprobe:mcp_reg_write": {
        "description": "Write a device register.",
        "pre": {
            "mcp": "!=null",
            "reg": "is a 4-bit value",
            "val": "is a 16-bit value"
        }
    }
},
{
    "kretprobe:mcp_reg_read": {
        "description": "Read a device register and return its value.",
        "pre": {
            "mcp": "!=null",
            "reg": "!=null",
            "reg": "is an integer between 0 and 15"
        }
    }
},
{
    "kprobe:mcp_reg_read": {
        "description": "Read a device register and return its value.",
        "pre": {
            "mcp": "!=null",
            "reg": "is an integer between 0 and 15"
        }
    }
},
S,
S,
{
    "kretprobe:if (sdev->usid % ctx->num_usids == 0)return sdev;function_parent_usid = sdev->usid;/* * Walk through the list of PMICs until we find the sibling USID. * The goal is to find the first USID which is less than the * number of USIDs in the PMIC array, e.g. for a PMIC with 2 USIDs * where the function device is under USID 3, we want to find the * device for USID 2.": {
        "description": "Helper function to get the base USID for a given device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:if (sdev->usid % ctx->num_usids == 0)return sdev;function_parent_usid = sdev->usid;/* * Walk through the list of PMICs until we find the sibling USID. * The goal is to find the first USID which is less than the * number of USIDs in the PMIC array, e.g. for a PMIC with 2 USIDs * where the function device is under USID 3, we want to find the * device for USID 2.": {
        "description": "Helper function to find the sibling USID for a given function device in the PMIC array.",
        "pre": {
            "sdev": "!=null",
            "ctx": "!=null",
            "sdev->usid": "% ctx->num_usids == 0",
            "function_parent_usid": "= sdev->usid",
            "pmic_addr": "!=null",
            "other_usid": "= null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:chip->osc_vote |= client;/* If reference group is off - turn on": {
        "description": "Update voting status",
        "pre": {
            "chip": "!=null",
            "client": "!=null",
            "chip->id": "in [CHIP_PM8606]",
            "chip->client": "!=null",
            "chip->companion": "!=null",
            "chip->dev": "!=null",
            "chip->osc_vote": "!=null",
            "chip->osc_status": "!=null",
            "chip->osc_lock": "!=null"
        }
    }
},
{
    "kprobe:pm8606_osc_enable": {
        "description": "Update voting status",
        "pre": {
            "chip": "!=null",
            "client": "!=null",
            "chip->id": "in [CHIP_PM8606]",
            "chip->client": "!=null",
            "chip->companion": "!=null",
            "chip->dev": "!=null",
            "chip->osc_vote": "!=null",
            "chip->osc_status": "!=null",
            "chip->osc_lock": "!=null"
        }
    }
},
{
    "kretprobe:chip->osc_vote &= ~(client);/* * If reference group is off and this is the last client to release * - turn off": {
        "description": "Disable the osc_vote if the reference group is off and this is the last client to release.",
        "pre": {
            "chip->osc_vote": "&= ~(client)",
            "chip->osc_status": "== 0"
        }
    }
},
{
    "kprobe:chip->osc_vote &= ~(client);/* * If reference group is off and this is the last client to release * - turn off": {
        "description": "Disable the osc_vote in the chip structure based on the client value.",
        "pre": {
            "chip": "!=null",
            "client": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:axp20x_device_probe": {
        "description": "The AXP806 supports either master standalone or slave mode.",
        "pre": {
            "axp20x": "!=null",
            "axp20x->variant": "==AXP806_ID"
        }
    }
},
{
    "kprobe:axp20x_device_probe": {
        "description": "The AXP806 supports either master standalone or slave mode.",
        "pre": {
            "axp20x": "!=null",
            "axp20x->variant": "==AXP806_ID"
        }
    }
},
S,
S,
{
    "kretprobe:db8500_prcmu_load_a9wdog": {
        "description": "Load A9 watchdog with specified ID and timeout.",
        "pre": {
            "id": "!=null",
            "timeout": "!=null",
            "timeout & 0xf": "==0",
            "(timeout >> 4) & 0xf": "==0",
            "(timeout >> 12) & 0xf": "==0",
            "(timeout >> 20) & 0xf": "==0"
        }
    }
},
{
    "kprobe:db8500_prcmu_load_a9wdog": {
        "description": "Load A9 watchdog with specified ID and timeout.",
        "pre": {
            "id": "!=null",
            "timeout": "!=null",
            "timeout_bits_0_3": "==(timeout & 0x0F)",
            "timeout_bits_4_31": "==(timeout >> 4)"
        }
    }
},
{
    "kretprobe:wm8994_irq_init": {
        "description": "Initialize the WM8994 IRQ.",
        "pre": {
            "wm8994": "!=null",
            "ret": "!=null",
            "irqflags": "in [IRQF_TRIGGER_HIGH, IRQF_ONESHOT]",
            "pdata": "!=null",
            "wm8994->irq": "!=null",
            "wm8994->irq_base": "==0"
        }
    }
},
{
    "kprobe:wm8994_irq_init": {
        "description": "Initialize the WM8994 IRQ.",
        "pre": {
            "wm8994": "!=null",
            "ret": "!=null",
            "irqflags": "in [IRQF_TRIGGER_HIGH | IRQF_ONESHOT, pdata->irq_flags]",
            "pdata": "!=null",
            "wm8994->irq": "!=null",
            "wm8994->irq_base": "==0"
        }
    }
},
{
    "kretprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kretprobe:tps65010_set_vbus_draw": {
        "description": "Set the VBUS draw of the tps65010 device.",
        "pre": {
            "mA": "!=null",
            "the_tps": "!=null"
        }
    },
    "kretprobe:the_tps->vbus": {
        "description": "Assign the value of mA to the vbus field of the_tps.",
        "pre": {
            "mA": "!=null"
        }
    },
    "kretprobe:the_tps->chgstatus & TPS_CHG_USB": {
        "description": "Check if the TPS_CHG_USB flag is set in the chgstatus field of the_tps.",
        "pre": {
            "the_tps": "!=null"
        }
    },
    "kretprobe:test_and_set_bit(FLAG_VBUS_CHANGED, &the_tps->flags)": {
        "description": "Set the FLAG_VBUS_CHANGED bit in the flags field of the_tps.",
        "pre": {
            "the_tps": "!=null"
        }
    }
},
{
    "kprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kprobe:tps65010_set_vbus_draw": {
        "description": "Set the VBUS draw of the tps65010 device.",
        "pre": {
            "mA": "!=null",
            "the_tps": "!=null"
        }
    },
    "kprobe:the_tps->vbus": {
        "description": "Assign the value of mA to the vbus field of the_tps.",
        "pre": {
            "mA": ">= 0",
            "the_tps": "!=null"
        }
    },
    "kprobe:the_tps->chgstatus & TPS_CHG_USB": {
        "description": "Check if the TPS_CHG_USB flag is set in the chgstatus field of the_tps.",
        "pre": {
            "the_tps": "!=null"
        }
    },
    "kprobe:test_and_set_bit(FLAG_VBUS_CHANGED, &the_tps->flags)": {
        "description": "Set the FLAG_VBUS_CHANGED bit in the flags field of the_tps.",
        "pre": {
            "the_tps": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tps65010_set_low_pwr": {
        "description": "Set the low power mode of the tps65010 device.",
        "pre": {
            "mode": "in ['ON', 'OFF']"
        }
    }
},
{
    "kprobe:tps65010_set_low_pwr": {
        "description": "Set the low power mode of the tps65010 device.",
        "pre": {
            "mode": "in ['ON', 'OFF']"
        }
    }
},
{
    "kretprobe:tps65010_config_vregs1": {
        "description": "Configures the VREGS1 register with the provided value.",
        "pre": {
            "value": "!=null"
        }
    }
},
{
    "kprobe:tps65010_config_vregs1": {
        "description": "Configure VREGS1 register with the given value.",
        "pre": {
            "value": "!=null"
        }
    }
},
{
    "kretprobe:tps65013_set_low_pwr": {
        "description": "Set the low power mode of the tps65013 chip.",
        "pre": {
            "mode": "in [\"ON\", \"OFF\"]"
        }
    }
},
{
    "kprobe:/* FIXME: Assumes AC or USB power is present. Setting AUA bit is not required if power supply is through a battery */": {
        "description": "Set the low power mode of the tps65013 chip.",
        "pre": {
            "mode": "in [ON, OFF]"
        }
    }
},
{
    "kretprobe:dln2_transfer_complete": {
        "description": "The dln2_transfer_complete function is woke up and will be resubmitted.",
        "pre": {
            "dln2": "!=null",
            "urb": "!=null",
            "handle": "!=null",
            "rx_slot": "!=null"
        }
    }
},
{
    "kprobe:dln2_transfer_complete": {
        "description": "dln2_transfer is woke up. It will be resubmitted there.",
        "pre": {
            "dln2": "!=null",
            "urb": "!=null",
            "handle": "!=null",
            "rx_slot": "!=null"
        }
    }
},
{
    "kretprobe:ucb1x00_io_set_dir": {
        "description": "Set IO direction",
        "pre": {
            "ucb": "!=null",
            "in": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kprobe:ucb1x00_io_set_dir": {
        "description": "Set IO direction",
        "pre": {
            "ucb": "!=null",
            "in": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kretprobe:ucb1x00_io_write": {
        "description": "Set or clear IO outputs",
        "pre": {
            "ucb": "!=null",
            "set": "!=null",
            "clear": "!=null"
        }
    }
},
{
    "kprobe:ucb1x00_io_write": {
        "description": "Set or clear IO outputs",
        "pre": {
            "ucb": "!=null",
            "set": "!=null",
            "clear": "!=null"
        }
    }
},
{
    "kretprobe:ucb1x00_io_read": {
        "description": "Read the current state of the IO pins.",
        "pre": {
            "ucb": "!=null"
        }
    }
},
{
    "kprobe:ucb1x00_io_read": {
        "description": "Read the current state of the IO pins.",
        "pre": {
            "ucb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ucb1x00_adc_read": {
        "description": "Read the specified ADC channel",
        "pre": {
            "ucb": "!=null",
            "adc_channel": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kprobe:ucb1x00_adc_read": {
        "description": "Read the specified ADC channel",
        "pre": {
            "ucb": "!=null",
            "adc_channel": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mfd_add_devices": {
        "description": "Register child devices",
        "pre": {
            "parent": "!=null",
            "id": "int",
            "cells": "!=null",
            "n_devs": "int",
            "mem_base": "!=null",
            "irq_base": "int",
            "domain": "!=null"
        }
    }
},
{
    "kprobe:mfd_add_devices": {
        "description": "Register child devices",
        "pre": {
            "parent": "!=null",
            "id": "any",
            "cells": "!=null",
            "n_devs": ">=0",
            "mem_base": "!=null",
            "irq_base": "any",
            "domain": "any"
        }
    }
},
{
    "kretprobe:devm_mfd_add_devices": {
        "description": "Resource managed version of mfd_add_devices(). Returns 0 on success or an appropriate negative error number on failure. All child-devices of the MFD will automatically be removed when it gets unbinded.",
        "pre": {
            "dev": "!=null",
            "id": "int",
            "cells": "!=null",
            "n_devs": "int",
            "mem_base": "!=null",
            "irq_base": "int",
            "domain": "struct irq_domain*"
        }
    }
},
{
    "kprobe:devm_mfd_add_devices": {
        "description": "Resource managed version of mfd_add_devices(). Returns 0 on success or an appropriate negative error number on failure. All child-devices of the MFD will automatically be removed when it gets unbinded.",
        "pre": {
            "dev": "!=null",
            "id": "int",
            "cells": "!=null",
            "n_devs": "int",
            "mem_base": "!=null",
            "irq_base": "int",
            "domain": "!=null"
        }
    }
},
{
    "kretprobe:twl6030_interrupt_unmask": {
        "description": "Unmask interrupts in TWL6030 device.",
        "pre": {
            "bit_mask": "!=null",
            "offset": "!=null",
            "ret": "!=null",
            "unmask_value": "!=null",
            "twl_i2c_read_u8": "called with arguments (TWL_MODULE_PIH, &unmask_value, REG_INT_STS_A + offset)",
            "twl_i2c_write_u8": "called with arguments (TWL_MODULE_PIH, unmask_value, REG_INT_STS_A + offset)"
        }
    }
},
{
    "kprobe:return ret;}EXPORT_SYMBOL(twl6030_interrupt_unmask": {
        "description": "Unmask a specific interrupt bit in the TWL6030 device.",
        "pre": {
            "bit_mask": "!=null",
            "offset": "!=null",
            "ret": "!=null",
            "unmask_value": "!=null",
            "twl_i2c_read_u8(TWL_MODULE_PIH, &unmask_value,REG_INT_STS_A + offset)": "ret == 0",
            "unmask_value &= (~(bit_mask))": "unmask_value == (unmask_value & (~(bit_mask)))",
            "twl_i2c_write_u8(TWL_MODULE_PIH, unmask_value,REG_INT_STS_A + offset)": "ret == 0"
        }
    }
},
{
    "kretprobe:return ret;}EXPORT_SYMBOL(twl6030_interrupt_mask": {
        "description": "Mask interrupts in TWL6030 module.",
        "pre": {
            "bit_mask": "!=null",
            "offset": "!=null",
            "ret": "!=null",
            "mask_value": "!=null",
            "mask_value": "mask_value | bit_mask",
            "ret": "ret | twl_i2c_write_u8(TWL_MODULE_PIH, mask_value, REG_INT_STS_A + offset)",
            "twl_i2c_write_u8(TWL_MODULE_PIH, mask_value, REG_INT_STS_A + offset)": "success"
        }
    }
},
S,
S,
S,
{
    "kretprobe:twl6040_reg_write": {
        "description": "Write the value of ldoctl to the TWL6040_REG_LDOCTL register.",
        "pre": {
            "twl6040": "!=null",
            "TWL6040_REG_LDOCTL": "!=null",
            "ldoctl": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:usleep_range": {
        "description": "Sleep for a range of microseconds.",
        "pre": {
            "min": "10000",
            "max": "10500"
        }
    }
},
{
    "kprobe:ldoctl": {
        "description": "enable high-side LDO, reference system, and internal oscillator",
        "pre": {
            "twl6040": "!=null",
            "ldoctl": "TWL6040_HSLDOENA | TWL6040_REFENA | TWL6040_OSCENA",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:twl6040_set_pll": {
        "description": "Force full reconfiguration when switching between PLL",
        "pre": {
            "pll_id": "!= twl6040->pll"
        }
    }
},
S,
{
    "kretprobe:twl_i2c_write": {
        "description": "Writes a n bit register in TWL4030TWL5030TWL60X0",
        "pre": {
            "mod_no": "!=null",
            "value": "!=null",
            "reg": "!=null",
            "num_bytes": "!=null"
        },
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:twl_i2c_write": {
        "description": "Writes a n bit register in TWL4030TWL5030TWL60X0",
        "pre": {
            "mod_no": "!=null",
            "value": "!=null",
            "reg": "!=null",
            "num_bytes": ">=0"
        }
    }
},
{
    "kretprobe:twl_i2c_read": {
        "description": "Reads a n bit register in TWL4030TWL5030TWL60X0",
        "pre": {
            "mod_no": "!=null",
            "value": "!=null",
            "reg": "!=null",
            "num_bytes": "!=null"
        },
        "post": {
            "return": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:twl_i2c_read": {
        "description": "Reads a n bit register in TWL4030/TWL5030/TWL60X0",
        "pre": {
            "mod_no": "!=null",
            "value": "!=null",
            "reg": "!=null",
            "num_bytes": "!=null"
        }
    }
},
{
    "kretprobe:twl_set_regcache_bypass": {
        "description": "Configure the regcache bypass for the regmap associated with the module",
        "pre": {
            "mod_no": "!=null",
            "enable": "in [true, false]"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:twl_set_regcache_bypass": {
        "description": "Configure the regcache bypass for the regmap associated with the module",
        "pre": {
            "mod_no": "!=null",
            "enable": "!=null"
        }
    }
},
{
    "kretprobe:menelaus_set_mmc_slot": {
        "description": "Set the MMC slot configuration in the Menelaus device.",
        "pre": {
            "slot": "in [1, 2]",
            "enable": "in [0, 1]",
            "power": "in [0, 1, 2]",
            "cd_en": "in [0, 1]"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:menelaus_set_mmc_slot": {
        "description": "Set MMC slot configuration.",
        "pre": {
            "slot": "in [1, 2]",
            "enable": "in [0, 1]",
            "power": "< 3"
        }
    }
},
{
    "kretprobe:devm_nvmem_cell_put": {
        "description": "Release previously allocated nvmem cell from devm_nvmem_cell_get.",
        "pre": {
            "dev": "!=null",
            "cell": "!=null"
        }
    }
},
{
    "kprobe:devm_nvmem_cell_put": {
        "description": "Release previously allocated nvmem cell from devm_nvmem_cell_get.",
        "pre": {
            "dev": "!=null",
            "cell": "!=null"
        }
    }
},
{
    "kretprobe:virtio_dma_buf_export": {
        "description": "Creates a new dma-buf for a virtio exported object",
        "pre": {
            "exp_info": "!=null",
            "exp_info->ops": "!=null",
            "exp_info->ops->virtio_dma_buf_ops": "!=null"
        }
    }
},
{
    "kprobe:virtio_dma_buf_export": {
        "description": "Creates a new dma-buf for a virtio exported object",
        "pre": {
            "exp_info": "!=null",
            "exp_info->ops": "!=null",
            "exp_info->ops->virtio_dma_buf_ops": "!=null"
        }
    }
},
{
    "kretprobe:virtio_dma_buf_attach": {
        "description": "Mandatory attach callback for virtio dma-bufs",
        "pre": {
            "dma_buf": "!=null",
            "attach": "!=null",
            "virtio_ops->get_uuid": "==null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:virtio_dma_buf_attach": {
        "description": "Mandatory attach callback for virtio dma-bufs",
        "pre": {
            "dma_buf": "!=null",
            "attach": "!=null",
            "virtio_ops->get_uuid": "==null"
        },
        "post": {
            "return": "dma_buf_export(exp_info)"
        }
    }
},
{
    "kretprobe:is_virtio_dma_buf": {
        "description": "Returns true if the given dma-buf is a virtio dma-buf.",
        "pre": {
            "dma_buf": "!=null"
        }
    }
},
{
    "kprobe:is_virtio_dma_buf": {
        "description": "Returns true if the given dma-buf is a virtio dma-buf.",
        "pre": {
            "dma_buf": "!=null"
        }
    }
},
{
    "kretprobe:virtio_dma_buf_get_uuid": {
        "description": "Gets a virtio dma-buf's exported object's uuid",
        "pre": {
            "dma_buf": "!=null",
            "uuid": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:virtio_dma_buf_get_uuid": {
        "description": "Gets a virtio dma-buf's exported object's uuid",
        "pre": {
            "dma_buf": "!=null",
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:suni_init": {
        "description": "Initialize SUNI",
        "pre": {
            "dev": "!=null",
            "mri": "!=null",
            "dev->phy_data": "!=null",
            "sizeof(struct suni_priv)": "!=null",
            "GET(MRI)": "!=null"
        }
    }
},
{
    "kprobe:PRIV(dev)->type = (mri & SUNI_MRI_TYPE) >> SUNI_MRI_TYPE_SHIFT;PUT(mri | SUNI_MRI_RESET,MRI);PUT(mri,MRI);PUT((GET(MT) & SUNI_MT_DS27_53),MT); /* disable all tests": {
        "description": "Set the type of PRIV(dev) based on the value of mri and perform some PUT operations.",
        "pre": {
            "dev": "!=null",
            "mri": "!=null"
        }
    }
},
{
    "kretprobe:qnoc_probe": {
        "description": "Function qnoc_probe",
        "pre": {
            "!qcom_icc_rpm_smd_available()": true,
            "desc": "!=null",
            "!desc": true,
            "qnodes": "!=null",
            "num_nodes": "!=null",
            "desc->num_intf_clocks": true
        }
    }
},
{
    "kprobe:qnoc_probe": {
        "description": "Function qnoc_probe",
        "pre": {
            "!qcom_icc_rpm_smd_available()": true,
            "desc": "!=null",
            "!desc": true,
            "qnodes": "!=null",
            "num_nodes": "!=null",
            "desc->num_intf_clocks": true
        }
    }
},
S,
S,
{
    "kretprobe:make_kuid": {
        "description": "Map a user-namespace uid pair into a kuid.",
        "pre": {
            "ns": "!=null",
            "uid": "!=null"
        }
    }
},
{
    "kprobe:make_kuid": {
        "description": "Map a user-namespace uid pair into a kuid.",
        "pre": {
            "ns": "!=null",
            "uid": "!=null"
        }
    }
},
{
    "kretprobe:from_kuid": {
        "description": "Create a uid from a kuid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kuid": "!=null"
        }
    }
},
{
    "kprobe:from_kuid": {
        "description": "Create a uid from a kuid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kuid": "!=null"
        }
    }
},
{
    "kretprobe:from_kuid_munged": {
        "description": "Create a uid from a kuid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kuid": "!=null"
        }
    }
},
{
    "kprobe:from_kuid_munged": {
        "description": "Create a uid from a kuid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kuid": "!=null"
        }
    }
},
{
    "kretprobe:make_kgid": {
        "description": "Map a user-namespace gid pair into a kgid and return that kgid.",
        "pre": {
            "ns": "!=null",
            "gid": "!=null"
        },
        "post": {
            "return_value": {
                "constraints": "!=INVALID_GID",
                "description": "The returned kgid is valid."
            }
        }
    }
},
{
    "kprobe:make_kgid": {
        "description": "Map a user-namespace gid pair into a kgid.",
        "pre": {
            "ns": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:from_kgid": {
        "description": "Create a gid from a kgid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kgid": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "in [gid_t, -1]"
        }
    }
},
{
    "kprobe:from_kgid": {
        "description": "Create a gid from a kgid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kgid": "!=null"
        }
    }
},
{
    "kretprobe:from_kgid_munged": {
        "description": "Create a gid from a kgid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kgid": "!=null"
        }
    }
},
{
    "kprobe:from_kgid_munged": {
        "description": "Create a gid from a kgid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kgid": "!=null"
        }
    }
},
{
    "kretprobe:make_kprojid": {
        "description": "Map a user-namespace projid pair into a kprojid.",
        "pre": {
            "ns": "!=null",
            "projid": "!=null"
        },
        "post": {
            "return": "in [INVALID_PROJID, valid kprojid]"
        }
    }
},
{
    "kprobe:make_kprojid": {
        "description": "Map a user-namespace projid pair into a kprojid.",
        "pre": {
            "ns": "!=null",
            "projid": "!=null"
        }
    }
},
{
    "kretprobe:from_kprojid": {
        "description": "Create a projid from a kprojid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kprojid": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "in [projid_t, (projid_t)-1]"
        }
    }
},
{
    "kprobe:from_kprojid": {
        "description": "Create a projid from a kprojid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kprojid": "!=null"
        }
    }
},
{
    "kretprobe:from_kprojid_munged": {
        "description": "Create a projid from a kprojid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kprojid": "!=null"
        }
    }
},
{
    "kprobe:from_kprojid_munged": {
        "description": "Create a projid from a kprojid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kprojid": "!=null"
        }
    }
},
{
    "kretprobe:thread_group_exited": {
        "description": "Check if a thread group has exited",
        "pre": {
            "pid": "!=null"
        }
    }
},
{
    "kprobe:thread_group_exited": {
        "description": "Check that a thread group has exited.",
        "pre": {
            "pid": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__cpuhp_setup_state_cpuslocked": {
        "description": "Setup the callbacks for a hotplug machine state.",
        "pre": {
            "state": "!=null",
            "name": "!=null",
            "invoke": "in [true, false]",
            "startup": "!=null",
            "teardown": "!=null",
            "multi_instance": "in [true, false]"
        },
        "post": {
            "return": "in [Positive state number if state is CPUHP_AP_ONLINE_DYN, 0 for all other states, proper (negative) error code on failure]"
        }
    }
},
{
    "kprobe:__cpuhp_setup_state_cpuslocked": {
        "description": "Setup the callbacks for a hotplug machine state.",
        "pre": {
            "state": ">=0",
            "name": "!=null",
            "invoke": "bool",
            "startup": "!=null",
            "teardown": "!=null",
            "multi_instance": "bool"
        },
        "post": {
            "return": ">=0"
        }
    }
},
S,
{
    "kprobe:cpuhp_rollback_install": {
        "description": "__cpuhp_setup_state on a recoverable failure.",
        "pre": {
            "failedcpu": "!=null",
            "state": "in [CPHP_STATE_1, CPHP_STATE_2, CPHP_STATE_3]",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:__cpuhp_remove_state_cpuslocked": {
        "description": "Remove the callbacks for a hotplug machine state.",
        "pre": {
            "state": "!=null",
            "invoke": "in [true, false]"
        }
    }
},
{
    "kprobe:__cpuhp_remove_state_cpuslocked": {
        "description": "Remove the callbacks for a hotplug machine state.",
        "pre": {
            "state": "!=null",
            "invoke": "in [true, false]"
        }
    }
},
{
    "kretprobe:__post_watch_notification": {
        "description": "Post an event notification",
        "pre": {
            "wlist": "!=null",
            "n": "!=null",
            "cred": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:__post_watch_notification": {
        "description": "Post an event notification",
        "pre": {
            "wlist": "!=null",
            "n": "!=null",
            "cred": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:put_watch_queue": {
        "description": "Dispose of a ref on a watchqueue.",
        "pre": {
            "wqueue": "!=null",
            "wqueue->nr_pages": ">=0",
            "wqueue->notes": "!=null",
            "wqueue->notes_bitmap": "!=null",
            "wqueue->filter": "!=null"
        }
    }
},
{
    "kprobe:put_watch_queue": {
        "description": "Dispose of a ref on a watchqueue.",
        "pre": {
            "wqueue": "!=null"
        }
    }
},
{
    "kretprobe:add_watch_to_object": {
        "description": "Add a watch on an object to a watch list",
        "pre": {
            "watch": "!=null",
            "wlist": "!=null",
            "watch->queue": "!=null",
            "watch->cred": "!=null",
            "watch->queue->notifications": "!=null",
            "watch->cred->credentials": "!=null",
            "watch->queue->notifications->ref_count": ">0",
            "watch->cred->credentials->ref_count": ">0",
            "wlist->locked": "==true"
        }
    }
},
{
    "kprobe:add_watch_to_object": {
        "description": "Add a watch on an object to a watch list",
        "pre": {
            "watch": "!=null",
            "wlist": "!=null",
            "watch->queue": "!=null",
            "watch->cred": "!=null",
            "watch->queue->notifications": "!=null",
            "watch->cred->credentials": "!=null",
            "watch->queue->notifications->ref_count": ">0",
            "watch->cred->credentials->ref_count": ">0",
            "watch->queue->notifications->ref_count": "watch->queue->notifications->ref_count + 1",
            "watch->cred->credentials->ref_count": "watch->cred->credentials->ref_count + 1",
            "watch->queue->locked": "true"
        }
    }
},
{
    "kretprobe:remove_watch_from_object": {
        "description": "Remove a watch or all watches from an object.",
        "pre": {
            "wlist": "!=null",
            "wq": "!=null",
            "id": "!=null",
            "all": "in [true, false]"
        }
    }
},
{
    "kprobe:remove_watch_from_object": {
        "description": "Remove a watch or all watches from an object.",
        "pre": {
            "wlist": "!=null",
            "wq": "!=null",
            "id": "!=null",
            "all": "in [true, false]"
        }
    }
},
{
    "kretprobe:get_watch_queue": {
        "description": "Get a watch queue from its file descriptor.",
        "pre": {
            "fd": "!=null"
        }
    }
},
{
    "kprobe:get_watch_queue": {
        "description": "Get a watch queue from its file descriptor.",
        "pre": {
            "fd": "!=null"
        }
    }
},
S,
{
    "kprobe:audit_log_format": {
        "description": "Format an audit log message with the given parameters.",
        "pre": {
            "ab": "!=null",
            "function_name": "!=null",
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kretprobe:audit_log_task_info": {
        "description": "Logs task information to the audit subsystem.",
        "pre": {
            "ab": "!=null"
        }
    },
    "kretprobe:audit_log_format": {
        "description": "Formats and logs a message to the audit subsystem.",
        "pre": {
            "ab": "!=null",
            "format": "!=null",
            "which": "in [0, AUDIT_LAST_FEATURE]",
            "old_feature": "in [0, 1]",
            "new_feature": "in [0, 1]",
            "old_lock": "in [0, 1]",
            "new_lock": "in [0, 1]",
            "res": "in [0, 1]"
        }
    },
    "kretprobe:audit_log_end": {
        "description": "Ends the audit log entry.",
        "pre": {
            "ab": "!=null"
        }
    }
},
{
    "kprobe:audit_log_task_info": {
        "pre": {
            "ab": "!=null"
        }
    },
    "kprobe:audit_log_format": {
        "pre": {
            "ab": "!=null",
            "format": "!=null",
            "which": "!=null",
            "old_feature": "!=null",
            "new_feature": "!=null",
            "old_lock": "!=null",
            "new_lock": "!=null",
            "res": "!=null"
        }
    },
    "kprobe:audit_log_end": {
        "pre": {
            "ab": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt#include <linux/file.h>#include <linux/init.h>#include <linux/types.h>#include <linux/atomic.h>#include <linux/mm.h>#include <linux/export.h>#include <linux/slab.h>#include <linux/err.h>#include <linux/kthread.h>#include <linux/kernel.h>#include <linux/syscalls.h>#include <linux/spinlock.h>#include <linux/rcupdate.h>#include <linux/mutex.h>#include <linux/gfp.h>#include <linux/pid.h>#include <linux/audit.h>#include <net/sock.h>#include <net/netlink.h>#include <linux/skbuff.h>#ifdef CONFIG_SECURITY#include <linux/security.h>#endif#include <linux/freezer.h>#include <linux/pid_namespace.h>#include <net/netns/generic.h>#include \"audit.h\"": {
        "description": "No auditing will take place until audit_initialized == AUDIT_INITIALIZED. (Initialization happens after skb_init is called.)",
        "pre": {
            "audit_log": "called",
            "syscall_record": "generated automatically for the current syscall",
            "netlink_interface": "to user-space",
            "kernel-based_filtering": "low-overhead",
            "audit_userspace": "https:github.comlinux-audit"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
S,
{
    "kprobe:free_task_struct": {
        "description": "Free the memory allocated for a task_struct structure.",
        "pre": {
            "tsk": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:touch_softlockup_watchdog_sched": {
        "description": "Touch watchdog on scheduler stalls",
        "pre": {
            "scheduler_stalled": "==true"
        }
    }
},
{
    "kprobe:touch_softlockup_watchdog_sched": {
        "description": "Touch watchdog on scheduler stalls",
        "pre": {
            "scheduler_stalled": "==true"
        }
    }
},
{
    "kretprobe:has_capability": {
        "description": "Does a task have a capability in init_user_ns",
        "pre": {
            "t": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:has_capability": {
        "description": "Does a task have a capability in init_user_ns",
        "pre": {
            "t": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:has_capability_noaudit": {
        "description": "Does a task have a capability (unaudited) in the initial user ns",
        "pre": {
            "t": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:has_capability_noaudit": {
        "description": "Check if a task has a capability (unaudited) in the initial user ns.",
        "pre": {
            "t": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:ns_capable": {
        "description": "Determine if the current task has a superior capability in effect",
        "pre": {
            "ns": "!=null",
            "cap": "!=null",
            "opts": "!=null"
        }
    }
},
{
    "kprobe:ns_capable": {
        "description": "Determine if the current task has a superior capability in effect",
        "pre": {
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:ns_capable_noaudit": {
        "description": "Determine if the current task has a superior capability (unaudited) in effect",
        "pre": {
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:ns_capable_noaudit": {
        "description": "Determine if the current task has a superior capability (unaudited) in effect",
        "pre": {
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:ns_capable_setid": {
        "description": "Determine if the current task has a superior capability in effect, while signalling that this check is being done from within a setid or setgroups syscall.",
        "pre": {
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:ns_capable_setid": {
        "description": "Determine if the current task has a superior capability in effect, while signalling that this check is being done from within a setid or setgroups syscall.",
        "pre": {
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:file_ns_capable": {
        "description": "Determine if the file's opener had a capability in effect",
        "pre": {
            "file": "!=null",
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:file_ns_capable": {
        "description": "Determine if the file's opener had a capability in effect",
        "pre": {
            "file": "!=null",
            "ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:capable_wrt_inode_uidgid": {
        "description": "Check if the current task has the given capability targeted at its own user namespace and if the given inode's uid and gid are mapped into the current user namespace.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:capable_wrt_inode_uidgid": {
        "description": "Check if the current task has the given capability targeted at its own user namespace and if the given inode's uid and gid are mapped into the current user namespace.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "cap": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:set_groups": {
        "description": "Change a group subscription in a set of credentials",
        "pre": {
            "new": "!=null",
            "group_info": "!=null"
        }
    }
},
{
    "kprobe:set_groups": {
        "description": "Change a group subscription in a set of credentials",
        "pre": {
            "new": "!=null",
            "group_info": "!=null"
        }
    }
},
{
    "kretprobe:set_current_groups": {
        "description": "Change current's group subscription",
        "pre": {
            "group_info": "!=null"
        }
    }
},
{
    "kprobe:set_current_groups": {
        "description": "Change current's group subscription",
        "pre": {
            "group_info": "!=null"
        }
    }
},
{
    "kretprobe:ioremap_cache": {
        "description": "Map a physical memory range into the kernel's virtual address space.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:ioremap_cache": {
        "description": "Remap a physical address range into the kernel's virtual memory space with caching enabled.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:BUILD_BUG_ON": {
        "description": "'lowest_stack' should be aligned on the register width boundary",
        "pre": {
            "CONFIG_STACKLEAK_TRACK_MIN_SIZE": "> STACKLEAK_SEARCH_DEPTH"
        }
    }
},
{
    "kprobe:BUILD_BUG_ON": {
        "description": "'lowest_stack' should be aligned on the register width boundary",
        "pre": {
            "CONFIG_STACKLEAK_TRACK_MIN_SIZE": "> STACKLEAK_SEARCH_DEPTH"
        }
    }
},
{
    "kretprobe:proc_dobool": {
        "description": "Read/write a bool value from/to the user buffer.",
        "pre": {
            "table": "!=null",
            "write": "in [0, 1]",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:proc_dobool": {
        "description": "Read/write a bool value from/to the user buffer.",
        "pre": {
            "table": "!=null",
            "write": "is_boolean",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:bail_early:*ppos += *lenp;return err;}static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer, size_t *lenp, loff_t *ppos, int (*conv)(unsigned long *lvalp, unsigned int *valp, int write, void *data), void *data)": {
        "description": "This is the `do_proc_douintvec_r` function.",
        "pre": {
            "tbl_data": "!=null",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null",
            "conv": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:bail_early:*ppos += *lenp;return err;}static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,       size_t *lenp, loff_t *ppos,       int (*conv)(unsigned long *lvalp,   unsigned int *valp,   int write, void *data),       void *data)": {
        "description": "This is the bail_early function of do_proc_douintvec_r.",
        "pre": {
            "tbl_data": "!=null",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null",
            "conv": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:do_proc_dointvec_ms_jiffies_conv": {
        "description": "Converts milliseconds to jiffies and updates the value.",
        "pre": {
            "negp": "bool",
            "lvalp": "unsigned long",
            "valp": "int",
            "write": "int",
            "data": "void"
        },
        "post": {
            "ret": "int",
            "ip": "int *"
        }
    }
},
{
    "kprobe:do_proc_dointvec_ms_jiffies_conv": {
        "description": "Converts a value to milliseconds or jiffies based on the write flag.",
        "pre": {
            "negp": "bool",
            "lvalp": "unsigned long",
            "ip": "int *",
            "write": "int",
            "data": "void"
        }
    }
},
{
    "kretprobe:do_proc_dointvec_minmax_conv_param": {
        "description": "proc_dointvec_minmax() range checking structure",
        "pre": {
            "@min": "!=null",
            "@max": "!=null"
        }
    }
},
{
    "kprobe:do_proc_dointvec_minmax_conv_param": {
        "description": "Range checking structure for proc_dointvec_minmax()",
        "pre": {
            "@min": "!=null",
            "@max": "!=null"
        }
    }
},
{
    "kretprobe:proc_dostring": {
        "description": "Reads/writes a string from/to the user buffer.",
        "pre": {
            "table": "!=null",
            "write": "in [0, 1]",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:proc_dostring": {
        "description": "Reads/writes a string from/to the user buffer.",
        "pre": {
            "table": "!=null",
            "write": "in [0, 1]",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:proc_do_large_bitmap": {
        "description": "readwrite fromto a large bitmap",
        "pre": {
            "table": "!=null",
            "write": "is boolean",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:proc_do_large_bitmap": {
        "description": "readwrite fromto a large bitmap",
        "pre": {
            "table": "!=null",
            "write": "!=null",
            "buffer": "!=null",
            "lenp": "!=null",
            "ppos": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:param_set_bool": {
        "description": "Set the value of the boolean parameter.",
        "pre": {
            "val": "==null",
            "kp": "!=null"
        }
    }
},
{
    "kprobe:param_set_bool": {
        "description": "Set the boolean value of the parameter to the given value.",
        "pre": {
            "val": "==null || val in [\"y\", \"Y\", \"n\", \"N\", \"0\", \"1\"]"
        }
    }
},
{
    "kretprobe:return_sprintf": {
        "description": "Return the formatted string based on the value of *(bool *)kp->arg.",
        "pre": {
            "buffer": "!=null",
            "kp": {
                "arg": "!=null"
            }
        },
        "post": {
            "buffer": "!=null",
            "buffer[0]": "in ['Y', 'N']"
        }
    }
},
S,
{
    "kretprobe:param_set_bint": {
        "description": "Match bool exactly, by re-using it.",
        "pre": {
            "val": "!=null",
            "kp": "!=null",
            "kp.arg": "!=null",
            "ret": "int",
            "ret == 0": true,
            "*(int *)kp.arg": "bool"
        }
    }
},
{
    "kprobe:param_set_bint": {
        "description": "Match bool exactly, by re-using it.",
        "pre": {
            "val": "!=null",
            "kp": {
                "arg": "!=null"
            }
        }
    }
},
S,
S,
{
    "kretprobe:kthread_should_stop": {
        "description": "Check if the current kthread should stop.",
        "pre": {
            "none": "none"
        },
        "post": {
            "return_value": "==true"
        }
    }
},
{
    "kprobe:kthread_should_stop": {
        "description": "Check if the current kthread should stop.",
        "pre": {
            "none": ""
        }
    }
},
{
    "kretprobe:kthread_complete_and_exit": {
        "description": "Exit the current kthread.",
        "pre": {
            "comp": "!=null",
            "code": "!=null"
        }
    }
},
{
    "kprobe:kthread_complete_and_exit": {
        "description": "Exit the current kthread.",
        "pre": {
            "comp": "!=null",
            "code": "any"
        }
    }
},
{
    "kretprobe:wait_for_completion_killable": {
        "description": "Wait for completion in killable state, for I might be chosen by the OOM killer while kthreadd is trying to allocate memory for new kernel thread.",
        "pre": {
            "wait_for_completion_killable(&done)": "unlikely",
            "done": "!=null"
        }
    }
},
{
    "kprobe:wait_for_completion_killable": {
        "description": "Wait for completion in killable state, for I might be chosen by the OOM killer while kthreadd is trying to allocate memory for new kernel thread.",
        "pre": {
            "done": "!=null"
        }
    }
},
{
    "kretprobe:__kthread_bind": {
        "description": "Bind a kernel thread to a specific CPU.",
        "pre": {
            "p": "!=null",
            "cpu": ">=0",
            "state": ">=0",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:__kthread_bind": {
        "description": "Bind a kernel thread to a specific CPU.",
        "pre": {
            "p": "!=null",
            "cpu": ">=0",
            "state": ">=0",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:kthread_create_on_cpu": {
        "description": "Create a cpu bound kthread",
        "pre": {
            "threadfn": "!=null",
            "data": "!=null",
            "cpu": ">=0",
            "namefmt": "!=null"
        }
    }
},
{
    "kprobe:kthread_create_on_cpu": {
        "description": "Create a cpu bound kthread",
        "pre": {
            "threadfn": "!=null",
            "data": "!=null",
            "cpu": ">=0",
            "namefmt": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:kthread_create_worker_on_cpu": {
        "description": "Create a kthread worker and bind it to a given CPU and the associated NUMA node.",
        "pre": {
            "cpu": "!=null",
            "flags": "!=null",
            "namefmt": "!=null"
        }
    }
},
{
    "kprobe:kthread_create_worker_on_cpu": {
        "description": "Create a kthread worker and bind it to a given CPU and the associated NUMA node.",
        "pre": {
            "cpu": "!=null",
            "flags": "!=null",
            "namefmt": "!=null"
        }
    }
},
{
    "kretprobe:kthread_delayed_work_timer_fn": {
        "description": "Callback that queues the associated kthread delayed work when the timer expires.",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kprobe:kthread_delayed_work_timer_fn": {
        "description": "Callback that queues the associated kthread delayed work when the timer expires.",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kretprobe:kthread_destroy_worker": {
        "description": "Destroy a kthread worker",
        "pre": {
            "worker": "!=null"
        }
    }
},
{
    "kprobe:kthread_destroy_worker": {
        "description": "Destroy a kthread worker",
        "pre": {
            "worker": "!=null"
        }
    }
},
{
    "kretprobe:kthread_associate_blkcg": {
        "description": "Associate blkcg to current kthread",
        "pre": {
            "css": "!=null"
        }
    }
},
{
    "kprobe:kthread_associate_blkcg": {
        "description": "Associate blkcg to current kthread",
        "pre": {
            "css": "!=null"
        }
    }
},
{
    "kretprobe:recalc_sigpending_tsk": {
        "description": "After recalculating TIF_SIGPENDING, we need to make sure the task wakes up.",
        "pre": {
            "t->jobctl": "& (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE) == 0",
            "PENDING(&t->pending, &t->blocked)": "== false",
            "PENDING(&t->signal->shared_pending, &t->blocked)": "== false",
            "cgroup_task_frozen(t)": "== false"
        },
        "post": {
            "set_tsk_thread_flag(t, TIF_SIGPENDING)": "== true"
        }
    }
},
{
    "kprobe:recalc_sigpending_tsk": {
        "description": "After recalculating TIF_SIGPENDING, we need to make sure the task wakes up. This is superfluous when called on current, the wakeup is a harmless no-op.",
        "pre": {
            "t->jobctl": "& (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE) == 0",
            "PENDING(&t->pending, &t->blocked)": "== false",
            "PENDING(&t->signal->shared_pending, &t->blocked)": "== false",
            "cgroup_task_frozen(t)": "== false"
        }
    }
},
S,
S,
{
    "kretprobe:result = TRACE_SIGNAL_ALREADY_PENDING;if (legacy_queue(pending, sig))goto ret;result = TRACE_SIGNAL_DELIVERED;/* * Skip useless siginfo allocation for SIGKILL and kernel threads. `": {
        "description": "Helper function for sending a signal while holding the signal lock.",
        "pre": {
            "sig": "!=null",
            "info": "!=null",
            "t": "!=null",
            "type": "in [PIDTYPE_PID, PIDTYPE_TGID, PIDTYPE_PGID, PIDTYPE_SID]",
            "force": "bool"
        }
    }
},
{
    "kprobe:result = TRACE_SIGNAL_ALREADY_PENDING;if (legacy_queue(pending, sig))goto ret;result = TRACE_SIGNAL_DELIVERED;/* * Skip useless siginfo allocation for SIGKILL and kernel threads. `": {
        "description": "Helper function for sending a signal to a locked task.",
        "pre": {
            "sig": "!=null",
            "info": "!=null",
            "t": "!=null",
            "type": "in [PIDTYPE_PID, PIDTYPE_TGID, PIDTYPE_PGID, PIDTYPE_SID]",
            "force": "bool"
        }
    }
},
{
    "kretprobe:force_sig_info": {
        "description": "Forcefully send a signal to a task with additional information.",
        "pre": {
            "info": "!=null",
            "t": "!=null",
            "handler": "in [HANDLER_CURRENT, HANDLER_EXIT]"
        }
    }
},
{
    "kprobe:force_sig_info": {
        "description": "Force a signal with information to a task.",
        "pre": {
            "info": "!=null",
            "t": "!=null",
            "handler": "in [HANDLER_CURRENT, HANDLER_EXIT]",
            "flags": "unsigned long int",
            "ret": "int",
            "blocked": "int",
            "ignored": "int",
            "action": "!=null",
            "sig": "int",
            "flags2": "int"
        }
    }
},
{
    "kretprobe:__kill_pgrp_info": {
        "description": "Sends a signal to a process group.",
        "pre": {
            "sig": "!=null",
            "info": "!=null",
            "pgrp": "!=null",
            "tasklist_lock": "readlock"
        }
    }
},
{
    "kprobe:__kill_pgrp_info": {
        "description": "Sends a signal to a process group.",
        "pre": {
            "sig": "!=null",
            "info": "!=null",
            "pgrp": "!=null",
            "tasklist_lock": "readlock"
        }
    }
},
{
    "kretprobe:kill_proc_info": {
        "description": "Kill a process with signal and provide process information.",
        "pre": {
            "sig": "!=null",
            "info": "!=null",
            "pid": "!=null"
        }
    }
},
S,
{
    "kretprobe:sigprocmask": {
        "description": "Blocks or unblocks signals in the process's signal mask.",
        "pre": {
            "how": "in [SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK]",
            "set": "!=null",
            "oldset": "!=null"
        }
    }
},
{
    "kprobe:sigprocmask": {
        "description": "Blocks or unblocks signals in the process's signal mask.",
        "pre": {
            "how": "in [SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK]",
            "set": "!=null",
            "oldset": "!=null"
        }
    }
},
{
    "kretprobe:csdlock_debug": {
        "description": "Locking and debugging in the CSD lock",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kprobe:csdlock_debug": {
        "description": "Kernel boot parameter for CSD lock debugging.",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:smp_call_function_many_cond": {
        "description": "Call a function on multiple CPUs with conditional execution.",
        "pre": {
            "mask": "!=null",
            "func": "!=null",
            "info": "!=null",
            "scf_flags": "is an unsigned integer",
            "cond_func": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:smp_call_function_many_cond": {
        "description": "Call a function on multiple CPUs with conditional execution.",
        "pre": {
            "mask": "!=null",
            "func": "!=null",
            "info": "!=null",
            "scf_flags": "in [SCF_WAIT, SCF_RUN_LOCAL]",
            "cond_func": "!=null"
        }
    }
},
S,
{
    "kprobe:__flush_smp_call_function_queue": {
        "description": "Flushes the smp call function queue and runs irq work.",
        "pre": {
            "warn_cpu_offline": "false"
        }
    },
    "kprobe:irq_work_run": {
        "description": "Runs irq work.",
        "pre": {}
    },
    "kprobe:return": {
        "description": "Returns 0.",
        "pre": {}
    },
    "kprobe:call_function_init": {
        "description": "Initializes the call function.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:register_reboot_notifier": {
        "description": "Register function to be called at reboot time",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:register_reboot_notifier": {
        "description": "Register function to be called at reboot time",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:unregister_reboot_notifier": {
        "description": "Unregister previously registered reboot notifier",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:unregister_reboot_notifier": {
        "description": "Unregister previously registered reboot notifier",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:register_restart_handler": {
        "description": "Register function to be called to reset the system",
        "pre": {
            "nb": {
                "priority": "in [0, 128, 255]"
            }
        }
    }
},
{
    "kprobe:register_restart_handler": {
        "description": "Register function to be called to reset the system.",
        "pre": {
            "nb": "!=null",
            "nb->priority": "in [0, 128, 255]"
        }
    }
},
{
    "kretprobe:unregister_restart_handler": {
        "description": "Unregister previously registered restart handler",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "return_value": "= 0"
        }
    }
},
{
    "kprobe:unregister_restart_handler": {
        "description": "Unregister previously registered restart handler",
        "pre": {
            "nb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__local_bh_enable_ip": {
        "description": "Reenables soft interrupts",
        "pre": {
            "ip": "!=null",
            "cnt": "!=null",
            "preempt_on": "==true",
            "flags": "!=null",
            "curcnt": "!=null",
            "in_hardirq": "==false",
            "irqs_enabled": "==true"
        }
    }
},
{
    "kprobe:__local_bh_enable_ip": {
        "description": "Enable local bottom halves at the specified instruction pointer.",
        "pre": {
            "ip": "!=null",
            "cnt": "!=null",
            "preempt_on": "bool",
            "flags": "unsigned long",
            "pending": "u32",
            "curcnt": "int",
            "in_hardirq": "bool",
            "softirq_ctrl.cnt": "int"
        },
        "post": {
            "out": "label"
        }
    }
},
S,
S,
{
    "kretprobe:freezing_slow_path": {
        "description": "Slow path for testing whether a task needs to be frozen.",
        "pre": {
            "p": "!=null",
            "freezer_active": "!=0"
        }
    }
},
{
    "kprobe:freezing_slow_path": {
        "description": "Slow path for testing whether a task needs to be frozen.",
        "pre": {
            "p": "!=null",
            "freezer_active": "!=0"
        }
    }
},
{
    "kretprobe:set_freezable": {
        "description": "Mark %current freezable and enter refrigerator if necessary.",
        "pre": {},
        "post": {
            "%current": "is_freezable",
            "refrigerator": "is_entered_if_necessary"
        }
    }
},
{
    "kprobe:set_freezable": {
        "description": "Make %current freezable and enter refrigerator if necessary.",
        "pre": {
            "current": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:smp_mb();}static void clear_work_data(struct work_struct *work)": {
        "description": "This function clears the work data associated with the given work structure.",
        "pre": {
            "work": "!=null"
        }
    }
},
S,
{
    "kretprobe:__queue_work": {
        "description": "Queue a delayed work item",
        "pre": {
            "dwork": "!=null",
            "dwork->cpu": "!=null",
            "dwork->wq": "!=null",
            "dwork->work": "!=null",
            "irq": "off"
        }
    }
},
S,
{
    "kretprobe:queue_delayed_work_on": {
        "description": "Queue work on specific CPU after delay",
        "pre": {
            "cpu": ">=0",
            "wq": "!=null",
            "dwork": "!=null",
            "delay": ">=0"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:queue_delayed_work_on": {
        "description": "Queue work on specific CPU after delay",
        "pre": {
            "cpu": ">=0",
            "wq": "!=null",
            "dwork": "!=null",
            "delay": ">=0"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:queue_rcu_work": {
        "description": "Queue work after a RCU grace period",
        "pre": {
            "wq": "!=null",
            "rwork": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:queue_rcu_work": {
        "description": "Queue work after a RCU grace period",
        "pre": {
            "wq": "!=null",
            "rwork": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:__flush_workqueue": {
        "description": "Ensure that any scheduled work has run to completion.",
        "pre": {
            "wq": "!=null"
        }
    }
},
{
    "kprobe:__flush_workqueue": {
        "description": "Ensure that any scheduled work has run to completion.",
        "pre": {
            "wq": "!=null"
        }
    }
},
{
    "kretprobe:flush_delayed_work": {
        "description": "Wait for a delayed work to finish executing the last queueing",
        "pre": {
            "dwork": "!=null"
        }
    }
},
{
    "kprobe:flush_delayed_work": {
        "description": "Wait for a delayed work to finish executing the last queueing.",
        "pre": {
            "dwork": "!=null"
        }
    }
},
{
    "kretprobe:flush_rcu_work": {
        "description": "Wait for a rwork to finish executing the last queueing",
        "pre": {
            "rwork": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:flush_rcu_work": {
        "description": "Wait for a rwork to finish executing the last queueing",
        "pre": {
            "rwork": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:work_fixup_free": {
        "description": "Called when an active object is freed.",
        "pre": {
            "addr": "!=null",
            "state": "in [DEBUG_OBJ_ENABLED, DEBUG_OBJ_DISABLED, DEBUG_OBJ_WARN]"
        }
    }
},
{
    "kprobe:work_fixup_free": {
        "description": "Called when an active object is freed.",
        "pre": {
            "addr": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancel a work item synchronously.",
        "pre": {
            "work": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:cancel_work_sync": {
        "description": "Cancel a work item synchronously.",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kretprobe:move_linked_works": {
        "description": "Move linked works to a list",
        "pre": {
            "work": "!=null",
            "head": "!=null",
            "nextp": "!=null"
        }
    }
},
{
    "kprobe:move_linked_works": {
        "description": "Move linked works to a list",
        "pre": {
            "current_work": "==work",
            "worker->current_func": "==work->func"
        }
    }
},
{
    "kretprobe:call_usermodehelper_setup": {
        "description": "Prepare to call a usermode helper",
        "pre": {
            "path": "!=null",
            "argv": "!=null",
            "envp": "!=null",
            "gfp_mask": "!=null",
            "init": "!=null",
            "cleanup": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:call_usermodehelper_setup": {
        "description": "Prepare to call a usermode helper",
        "pre": {
            "path": "!=null",
            "argv": "!=null",
            "envp": "!=null",
            "gfp_mask": "!=null",
            "init": "!=null",
            "cleanup": "!=null",
            "data": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:crash_smp_send_stop": {
        "description": "Stop other CPUs in panic.",
        "pre": {
            "regs": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:add_taint": {
        "description": "Add a taint flag if not already set.",
        "pre": {
            "flag": "!=null",
            "lockdep_ok": "in [true, false]"
        }
    }
},
{
    "kprobe:add_taint": {
        "description": "Add a taint flag if not already set.",
        "pre": {
            "flag": "!=null",
            "lockdep_ok": "in [true, false]"
        }
    }
},
S,
S,
{
    "kretprobe:padata_set_cpumask": {
        "description": "Sets specified by @cpumask_type cpumask to the value equivalent to @cpumask.",
        "pre": {
            "pinst": "!=null",
            "cpumask_type": "in [PADATA_CPU_SERIAL, PADATA_CPU_PARALLEL]",
            "cpumask": "!=null"
        }
    }
},
{
    "kprobe:padata_set_cpumask": {
        "description": "Sets specified by @cpumask_type cpumask to the value equivalent to @cpumask.",
        "pre": {
            "pinst": "!=null",
            "cpumask_type": "in [PADATA_CPU_SERIAL, PADATA_CPU_PARALLEL]",
            "cpumask": "!=null"
        }
    }
},
{
    "kretprobe:padata_replace_one": {
        "description": "Replace the internal control structure with a new one.",
        "pre": {
            "ps": "!=null"
        }
    }
},
{
    "kprobe:padata_replace_one": {
        "description": "Replace the internal control structure with a new one.",
        "pre": {
            "ps": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:padata_alloc_shell": {
        "description": "Allocate and initialize padata shell.",
        "pre": {
            "pinst": "!=null"
        }
    }
},
{
    "kprobe:padata_alloc_shell": {
        "description": "Allocate and initialize padata shell.",
        "pre": {
            "pinst": "!=null"
        }
    }
},
{
    "kretprobe:padata_free_shell": {
        "description": "Free a padata shell",
        "pre": {
            "ps": "!=null"
        }
    }
},
{
    "kprobe:padata_free_shell": {
        "description": "Free a padata shell",
        "pre": {
            "ps": "!=null"
        }
    }
},
{
    "kretprobe:__put_cred": {
        "description": "Destroy a set of credentials",
        "pre": {
            "cred": "!=null"
        }
    }
},
{
    "kprobe:__put_cred": {
        "description": "Destroy a set of credentials",
        "pre": {
            "cred": "!=null"
        }
    }
},
{
    "kretprobe:get_task_cred": {
        "description": "Get another task's objective credentials",
        "pre": {
            "task": "!=null"
        }
    }
},
{
    "kprobe:get_task_cred": {
        "description": "Get another task's objective credentials",
        "pre": {
            "task": "!=null"
        }
    }
},
{
    "kretprobe:prepare_creds": {
        "description": "Prepare a new set of credentials for modification",
        "pre": {
            "new": "!=null"
        }
    }
},
{
    "kprobe:prepare_creds": {
        "description": "Prepare a new set of credentials for modification.",
        "pre": {
            "new": "!=null"
        }
    }
},
{
    "kretprobe:override_creds": {
        "description": "Override the current process's subjective credentials",
        "pre": {
            "new": "!=null"
        }
    }
},
{
    "kprobe:override_creds": {
        "description": "Override the current process's subjective credentials",
        "pre": {
            "new": "!=null"
        }
    }
},
{
    "kretprobe:revert_creds": {
        "description": "Revert a temporary subjective credentials override",
        "pre": {
            "old": "!=null"
        }
    }
},
{
    "kprobe:revert_creds": {
        "description": "Revert a temporary subjective credentials override",
        "pre": {
            "old": "!=null"
        }
    }
},
{
    "kretprobe:cred_fscmp": {
        "description": "Compare two credentials with respect to filesystem access.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:cred_fscmp": {
        "description": "Compare two credentials with respect to filesystem access.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:prepare_kernel_cred": {
        "description": "Prepare a set of credentials for a kernel service.",
        "pre": {
            "daemon": "!=null"
        }
    }
},
{
    "kprobe:prepare_kernel_cred": {
        "description": "Prepare a set of credentials for a kernel service.",
        "pre": {
            "daemon": "!=null"
        }
    }
},
{
    "kretprobe:set_security_override": {
        "description": "Set the security ID in a set of credentials",
        "pre": {
            "new": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kprobe:set_security_override": {
        "description": "Set the security ID in a set of credentials",
        "pre": {
            "new": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:set_security_override_from_ctx": {
        "description": "Set the security ID in a set of credentials",
        "pre": {
            "new": "!=null",
            "secctx": "!=null"
        }
    }
},
{
    "kprobe:set_security_override_from_ctx": {
        "description": "Set the security ID in a set of credentials",
        "pre": {
            "new": "!=null",
            "secctx": "!=null"
        }
    }
},
{
    "kretprobe:set_create_files_as": {
        "description": "Set the LSM file create context in a set of credentials",
        "pre": {
            "new": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:set_create_files_as": {
        "description": "Set the LSM file create context in a set of credentials",
        "pre": {
            "new": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:release_child_resources": {
        "description": "Release child resources",
        "pre": {
            "r": "!=null",
            "r->parent": "!=null",
            "r->parent->child": "!=null",
            "r->child": "==null",
            "r->sibling": "==null"
        },
        "post": {
            "r->parent": "==null",
            "r->child": "==null",
            "r->sibling": "==null",
            "r->start": "==0",
            "r->end": "==size - 1"
        }
    }
},
{
    "kprobe:release_child_resources": {
        "description": "Release child resources",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kretprobe:reallocate_resource": {
        "description": "Allocate a slot in the resource tree given range & alignment. The resource will be relocated if the new size cannot be reallocated in the current location.",
        "pre": {
            "root": "!=null",
            "old": "!=null",
            "newsize": ">=0",
            "constraint": "!=null"
        }
    }
},
{
    "kprobe:reallocate_resource": {
        "description": "Allocate a slot in the resource tree given range & alignment. The resource will be relocated if the new size cannot be reallocated in the current location.",
        "pre": {
            "root": "!=null",
            "old": "!=null",
            "newsize": "!=null",
            "constraint": "!=null"
        }
    }
},
{
    "kretprobe:adjust_resource": {
        "description": "Modify a resource's start and size.",
        "pre": {
            "res": "!=null",
            "start": "!=null",
            "size": "!=null",
            "parent": "!=null",
            "end": "start + size - 1",
            "result": "-EBUSY if it can't fit, 0 on success",
            "parent->start": "<= start",
            "end": "<= parent->end",
            "res->sibling->start": "> end",
            "tmp": "parent->child",
            "tmp != res": "true",
            "tmp->sibling != res": "true",
            "start": "<= tmp->end",
            "tmp": "res->child",
            "tmp->start": "< start",
            "tmp->end": "> end",
            "res->start": "= start",
            "res->end": "= end"
        }
    }
},
{
    "kprobe:adjust_resource": {
        "description": "Modify a resource's start and size.",
        "pre": {
            "res": "!=null",
            "start": "!=null",
            "size": "!=null",
            "res->parent": "!=null",
            "start < res->parent->start || start + size - 1 > res->parent->end": "false",
            "res->sibling && res->sibling->start <= start + size - 1": "false",
            "tmp = res->parent->child; tmp != res; tmp = tmp->sibling; start <= tmp->end": "false",
            "tmp = res->child; tmp; tmp = tmp->sibling; tmp->start < start || tmp->end > start + size - 1": "false"
        }
    }
},
{
    "kretprobe:if (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY)": {
        "description": "Check if the value of conflict->desc is equal to IORES_DESC_DEVICE_PRIVATE_MEMORY.",
        "pre": {
            "conflict": {
                "desc": "== IORES_DESC_DEVICE_PRIVATE_MEMORY"
            }
        }
    }
},
{
    "kprobe:if (conflict->desc == IORES_DESC_DEVICE_PRIVATE_MEMORY)": {
        "description": "Check if the description of the conflict resource is equal to IORES_DESC_DEVICE_PRIVATE_MEMORY.",
        "pre": {
            "conflict": {
                "desc": "== IORES_DESC_DEVICE_PRIVATE_MEMORY"
            }
        }
    }
},
{
    "kretprobe:__release_region": {
        "description": "Release a previously reserved resource region.",
        "pre": {
            "parent": "!=null",
            "start": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:__release_region": {
        "description": "Release a previously reserved resource region.",
        "pre": {
            "parent": "!=null",
            "start": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:devm_request_resource": {
        "description": "Request a resource for a device using managed resources.",
        "pre": {
            "dev": "!=null",
            "root": "!=null",
            "new": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:pos = READ_ONCE(area[0]) + 1;if (likely(pos < t->kcov_size))": {
        "description": "Read the value from area[0], add 1 to it, and assign it to pos. Then check if pos is less than t->kcov_size.",
        "pre": {
            "area[0]": "!=null",
            "pos": "!=null",
            "t->kcov_size": "!=null",
            "pos < t->kcov_size": "true"
        }
    }
},
{
    "kprobe:pos = READ_ONCE(area[0]) + 1;if (likely(pos < t->kcov_size))": {
        "description": "Read the value from area[0], add 1 to it, and assign it to pos. Then, check if pos is less than t->kcov_size.",
        "pre": {
            "area[0]": "!=null",
            "t->kcov_size": "!=null",
            "pos": "!=null",
            "pos < t->kcov_size": "true"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:kcov_mode_enabled": {
        "description": "Check if KCOV mode is enabled.",
        "pre": {
            "mode": "== 0"
        }
    }
},
S,
{
    "kretprobe:mutex_lock": {
        "description": "Acquire the mutex",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Acquire the mutex",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:__mutex_add_waiter": {
        "description": "Add @waiter to a given location in the lock wait_list and set the FLAG_WAITERS flag if it's the first waiter.",
        "pre": {
            "lock": "!=null",
            "waiter": "!=null",
            "list": "!=null",
            "lock->wait_list": "!=null",
            "waiter == list_first_entry(&lock->wait_list, struct mutex_waiter, list)": true
        }
    }
},
{
    "kprobe:__mutex_add_waiter": {
        "description": "Add @waiter to a given location in the lock wait_list and set the FLAG_WAITERS flag if it's the first waiter.",
        "pre": {
            "lock": "!=null",
            "waiter": "!=null",
            "list": "!=null",
            "lock->wait_list": "!=null",
            "waiter == list_first_entry(&lock->wait_list, struct mutex_waiter, list)": true
        }
    }
},
{
    "kretprobe:ww_mutex_unlock": {
        "description": "Release the ww mutex",
        "pre": {
            "lock": "!=null",
            "lock->locked": "==1",
            "lock->owner": "==current_task",
            "lock->acquire_context": "==null",
            "lock->interrupt_context": "==0"
        }
    }
},
{
    "kprobe:ww_mutex_unlock": {
        "description": "Release the ww mutex",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:ww_mutex_trylock": {
        "description": "Tries to acquire the ww mutex with optional acquire context",
        "pre": {
            "ww": "!=null",
            "ww_ctx": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ww_mutex_trylock": {
        "description": "Tries to acquire the ww mutex with optional acquire context",
        "pre": {
            "ww": "!=null",
            "ww_ctx": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:atomic_dec_and_mutex_lock": {
        "description": "Return holding mutex if we dec to 0",
        "pre": {
            "cnt": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]",
            "lock": "in [null, 'holding'] when return == true"
        }
    }
},
{
    "kprobe:atomic_dec_and_mutex_lock": {
        "description": "Return holding mutex if we dec to 0",
        "pre": {
            "cnt": "!=null",
            "lock": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:down": {
        "description": "Acquire the semaphore",
        "pre": {
            "sem": "!=null"
        }
    }
},
{
    "kprobe:down": {
        "description": "Acquire the semaphore",
        "pre": {
            "sem": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:in_lock_functions": {
        "description": "Check if the address is within the range of __lock_text_start and __lock_text_end.",
        "pre": {
            "addr": "!=null",
            "addr": ">= (unsigned long)__lock_text_start",
            "addr": "< (unsigned long)__lock_text_end"
        }
    }
},
{
    "kprobe:in_lock_functions": {
        "description": "Check if the given address is within the range of __lockfunc functions.",
        "pre": {
            "addr": ">= (unsigned long)__lock_text_start",
            "addr": "< (unsigned long)__lock_text_end"
        }
    }
},
{
    "kretprobe:rt_mutex_lock_nested": {
        "description": "Lock a rt_mutex with a specified subclass.",
        "pre": {
            "lock": "!=null",
            "subclass": "unsigned int"
        }
    }
},
{
    "kprobe:rt_mutex_lock_nested": {
        "description": "Lock a rt_mutex with a specified subclass.",
        "pre": {
            "lock": "!=null",
            "subclass": "unsigned int"
        }
    }
},
{
    "kretprobe:rt_mutex_lock_interruptible": {
        "description": "Lock a rt_mutex interruptible",
        "pre": {
            "lock": "!=null"
        },
        "post": {
            "return": "= 0 or = -EINTR"
        }
    }
},
{
    "kprobe:rt_mutex_lock_interruptible": {
        "description": "Lock a rt_mutex interruptible",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:rt_mutex_lock_killable": {
        "description": "Lock a rt_mutex killable",
        "pre": {
            "lock": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:rt_mutex_lock_killable": {
        "description": "Lock a rt_mutex killable",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:rt_mutex_trylock": {
        "description": "Try to lock a rt_mutex.",
        "pre": {
            "lock": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:rt_mutex_trylock": {
        "description": "Try to lock a rt_mutex.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:rt_mutex_unlock": {
        "description": "Unlock a rt_mutex.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:rt_mutex_unlock": {
        "description": "Unlock a rt_mutex.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:queued_read_lock_slowpath": {
        "description": "Acquire read lock of a queued rwlock",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:queued_read_lock_slowpath": {
        "description": "Acquire read lock of a queued rwlock",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:queued_write_lock_slowpath": {
        "description": "Acquire write lock of a queued rwlock",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:queued_write_lock_slowpath": {
        "description": "Acquire write lock of a queued rwlock",
        "pre": {
            "lock": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:if (ww_ctx->acquired == 0)ww_ctx->wounded = 0;if (__rt_mutex_trylock(&rtm->rtmutex))": {
        "description": "Reset the wounded flag after a kill. No other process can race and wound us here, since they can't have a valid owner pointer if we don't have any locks held.",
        "pre": {
            "ww_ctx": {
                "acquired": "== 0",
                "wounded": "= 0"
            },
            "__rt_mutex_trylock(&rtm->rtmutex)": "!= 0"
        }
    }
},
{
    "kprobe:if (ww_ctx->acquired == 0)ww_ctx->wounded = 0;if (__rt_mutex_trylock(&rtm->rtmutex))": {
        "description": "Try to acquire a ww_mutex lock and reset the wounded flag if successful.",
        "pre": {
            "ww_ctx": {
                "acquired": "== 0",
                "wounded": "= 0"
            },
            "__rt_mutex_trylock(&rtm->rtmutex)": "!= 0"
        }
    }
},
S,
{
    "kprobe:debug_check_no_locks_freed": {
        "description": "Initialize a read-write semaphore.",
        "pre": {
            "sem": "!=null",
            "name": "!=null",
            "key": "!=null"
        }
    },
    "kprobe:lockdep_init_map_wait": {
        "description": "Initialize a lock dependency map for a read-write semaphore.",
        "pre": {
            "map": "!=null",
            "name": "!=null",
            "key": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    },
    "kprobe:atomic_long_set": {
        "description": "Set the value of an atomic long variable.",
        "pre": {
            "atomic_long_var": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:raw_spin_lock_init": {
        "description": "Initialize a raw spinlock.",
        "pre": {
            "spinlock": "!=null"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize a linked list head.",
        "pre": {
            "list_head": "!=null"
        }
    },
    "kprobe:osq_lock_init": {
        "description": "Initialize an OSQ lock.",
        "pre": {
            "osq_lock": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL": {
        "description": "Export a symbol for use by other modules.",
        "pre": {
            "symbol": "!=null"
        }
    }
},
{
    "kretprobe:rwsem_`": {
        "description": "Description of the rwsem_` function.",
        "pre": {
            "condition1": "value1",
            "condition2": "value2",
            "condition3": "value3"
        }
    }
},
S,
{
    "kretprobe:__down_write_common": {
        "description": "Lock for writing",
        "pre": {
            "sem": "!=null",
            "state": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:__up_read": {
        "description": "Unlock after reading from a read-write semaphore.",
        "pre": {
            "sem": "!=null",
            "sem->magic": "==sem",
            "ret": "!=null"
        },
        "post": {
            "ret": "==ret"
        }
    }
},
{
    "kprobe:__up_read": {
        "description": "Unlock after reading a read-write semaphore",
        "pre": {
            "sem": "!=null",
            "sem->magic": "==sem",
            "ret": "not in [0, -EDEADLK]"
        }
    }
},
{
    "kretprobe:rwsem_clear_reader_owned": {
        "description": "Release the read lock on the reader-writer semaphore for non-owners.",
        "pre": {
            "sem": "!=null"
        }
    }
},
{
    "kprobe:rwsem_clear_reader_owned": {
        "description": "Clear the ownership of the reader lock held by a non-owner.",
        "pre": {
            "sem": "!=null"
        }
    }
},
{
    "kretprobe:rwsem_wake": {
        "description": "Wake up waiters on a read-write semaphore.",
        "pre": {
            "sem": "!=null",
            "sem->count": ">0",
            "sem->wait_lock": "locked",
            "sem->wait_list": "empty"
        }
    }
},
S,
{
    "kretprobe:DEBUG_RWSEMS_WARN_ON": {
        "description": "Check if the owner of the rwsem is not the current thread and print a warning if it is.",
        "pre": {
            "rwsem_owner(sem)": "!= current",
            "sem": "!= null"
        },
        "post": {
            "preempt_disable()": "called",
            "tmp": "atomic_long_fetch_add_release(-RWSEM_WRITER_LOCKED+RWSEM_READER_BIAS, &sem->count)",
            "rwsem_set_reader_owned(sem)": "called",
            "tmp & RWSEM_FLAG_WAITERS": "false",
            "rwsem_downgrade_wake(sem)": "called",
            "preempt_enable()": "called"
        }
    }
},
S,
{
    "kretprobe:__rwsem_set_reader_owned": {
        "description": "Set the owner value for a reader-owned lock.",
        "pre": {
            "sem": "!=null",
            "__down_read": "called",
            "might_sleep": "called"
        }
    }
},
{
    "kprobe:__rwsem_set_reader_owned": {
        "description": "Set the owner value for a reader-owned lock in a preempt-enabled context.",
        "pre": {
            "sem": "!=null"
        }
    }
},
{
    "kretprobe:__wake_up": {
        "description": "__wake_up - wake up threads blocked on a waitqueue.",
        "pre": {
            "wq_head": "!=null",
            "mode": "!=null",
            "nr_exclusive": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:__wake_up": {
        "description": "Wake up threads blocked on a waitqueue.",
        "pre": {
            "wq_head": "!=null",
            "mode": "unsigned int",
            "nr_exclusive": "int",
            "key": "void*"
        }
    }
},
S,
S,
{
    "kretprobe:finish_wait": {
        "description": "Clean up after waiting in a queue",
        "pre": {
            "wq_head": "!=null",
            "wq_entry": "!=null"
        }
    }
},
{
    "kprobe:finish_wait": {
        "description": "Clean up after waiting in a queue",
        "pre": {
            "wq_head": "!=null",
            "wq_entry": "!=null"
        }
    }
},
{
    "kretprobe:wait_woken": {
        "description": "Function to wake up a wait queue entry",
        "pre": {
            "wq_entry": "!=null",
            "mode": "!=null",
            "timeout": "!=null"
        },
        "post": {
            "p->state": "mode",
            "wq_entry->flags": "|= WQ_FLAG_WOKEN",
            "smp_mb()": null,
            "Atry_to_wake_up()": {
                "pre": {
                    "!(wq_entry->flags & WQ_FLAG_WOKEN)": true
                },
                "post": {
                    "<full barrier>": null,
                    "schedule()": null,
                    "if (p->state & mode)": {
                        "pre": {
                            "p->state": "mode"
                        },
                        "post": {
                            "p->state": "TASK_RUNNING",
                            "wq_entry->flags": "&= ~WQ_FLAG_WOKEN",
                            "smp_mb()": null
                        }
                    }
                }
            },
            "Bcondition": true,
            "smp_mb()": null,
            "C": null,
            "remove_wait_queue(&wq_head, &wait)": null,
            "wq_entry->flags": "|= WQ_FLAG_WOKEN"
        }
    }
},
{
    "kprobe:wait_woken": {
        "description": "Function to wait for a woken wait queue entry.",
        "pre": {
            "wq_entry": "!=null",
            "mode": "!=null",
            "timeout": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wake_q_add": {
        "description": "Add a task to the wake queue.",
        "pre": {
            "head": "!=null",
            "task": "!=null",
            "task->state": "==TASK_RUNNING"
        }
    }
},
{
    "kprobe:wake_q_add": {
        "description": "Add a task to the wake queue.",
        "pre": {
            "head": "!=null",
            "task": "!=null",
            "task->state": "==TASK_RUNNING"
        }
    }
},
{
    "kretprobe:if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))return;#endif__preempt_count_add(val);#ifdef CONFIG_DEBUG_PREEMPT/* * Spinlock count overflowing soon?": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "DEBUG_LOCKS_WARN_ON((preempt_count() < 0))": "true",
            "preempt_count()": "< 0",
            "val": "!= null",
            "CONFIG_DEBUG_PREEMPT": "defined"
        }
    }
},
{
    "kprobe:if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))return;#endif__preempt_count_add(val);#ifdef CONFIG_DEBUG_PREEMPT/* * Spinlock count overflowing soon?": {
        "description": "Helper function to add a value to the preempt count.",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kretprobe:if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))return;/* * Is the spinlock portion underflowing? `": {
        "description": "Check if the spinlock portion is underflowing.",
        "pre": {
            "val": "!=null",
            "preempt_count()": "!=null",
            "DEBUG_LOCKS_WARN_ON(val > preempt_count())": "true"
        }
    }
},
{
    "kprobe:if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))return;/* * Is the spinlock portion underflowing? `": {
        "description": "Check if the spinlock portion is underflowing.",
        "pre": {
            "val": "!=null",
            "preempt_count()": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:preempt_disable_notrace": {
        "description": "Disable preemption without fear of being traced.",
        "pre": {
            "preempt_count": "==0"
        }
    },
    "kretprobe:preempt_latency_start": {
        "description": "Start recording preemption latency.",
        "pre": {
            "preempt_count": "==0",
            "latency_id": "==1"
        }
    },
    "kretprobe:__schedule": {
        "description": "Schedule the next task to run.",
        "pre": {
            "preempt_count": "==0",
            "mode": "==SM_PREEMPT"
        }
    },
    "kretprobe:preempt_latency_stop": {
        "description": "Stop recording preemption latency.",
        "pre": {
            "preempt_count": "==0",
            "latency_id": "==1"
        }
    },
    "kretprobe:preempt_enable_no_resched_notrace": {
        "description": "Enable preemption without rescheduling.",
        "pre": {
            "preempt_count": "==0"
        }
    }
},
{
    "kprobe:preempt_disable_notrace": {
        "description": "Disable preemption without being traced.",
        "pre": {
            "preempt_count": "==0"
        }
    },
    "kprobe:preempt_latency_start": {
        "description": "Start recording preemption latency.",
        "pre": {
            "preempt_count": "==0",
            "latency_id": ">=0"
        }
    },
    "kprobe:__schedule": {
        "description": "Schedule a task.",
        "pre": {
            "preempt_count": "==0",
            "need_resched": "==1"
        }
    },
    "kprobe:preempt_latency_stop": {
        "description": "Stop recording preemption latency.",
        "pre": {
            "preempt_count": "==0",
            "latency_id": ">=0"
        }
    },
    "kprobe:preempt_enable_no_resched_notrace": {
        "description": "Enable preemption without rescheduling.",
        "pre": {
            "preempt_count": "==0"
        }
    }
},
{
    "kretprobe:raw_spin_rq_lock_nested": {
        "description": "Lock the runqueue *rq* with *subclass*.",
        "pre": {
            "rq": "!=null",
            "subclass": "int"
        }
    }
},
S,
{
    "kretprobe:__cond_resched": {
        "description": "Check if a reschedule is needed and perform it if necessary.",
        "pre": {
            "should_resched": "== 0",
            "preempt_schedule_common": "called"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:__cond_resched": {
        "description": "In preemptible kernels, ->rcu_read_lock_nesting tells the tick whether the current CPU is in an RCU read-side critical section, so the tick can report quiescent states even for CPUs looping in kernel context. In contrast, in non-preemptible kernels, RCU readers leave no in-memory hints, which means that CPU-bound processes executing in kernel context might never report an RCU quiescent state. Therefore, the following code causes cond_resched() to report a quiescent state, but only when RCU is in urgent need of one.",
        "pre": {
            "should_resched(0)": "true",
            "preempt_schedule_common()": "called"
        }
    }
},
{
    "kretprobe:__cond_resched_lock": {
        "description": "If a reschedule is pending, drop the given lock, call schedule, and on return reacquire the lock.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kprobe:__cond_resched_lock": {
        "description": "If a reschedule is pending, drop the given lock, call schedule, and on return reacquire the lock.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:if (unlikely(queued))": {
        "description": "Check if the 'queued' variable is unlikely to be true.",
        "pre": {
            "queued": "==false"
        }
    }
},
{
    "kprobe:if (unlikely(queued))": {
        "description": "Check if the 'queued' variable is unlikely to be true.",
        "pre": {
            "queued": "==false"
        }
    }
},
{
    "kretprobe:io_schedule_timeout": {
        "description": "This task is about to go to sleep on IO. Increment rq->nr_iowait so that process accounting knows that this is a task in IO wait state.",
        "pre": {
            "timeout": "!=null"
        }
    }
},
{
    "kprobe:io_schedule_timeout": {
        "description": "This task is about to go to sleep on IO. Increment rq->nr_iowait so that process accounting knows that this is a task in IO wait state.",
        "pre": {
            "timeout": "!=null"
        }
    }
},
{
    "kretprobe:WARN_ONCE": {
        "description": "Check if blocking operations are called when the task is not in TASK_RUNNING state.",
        "pre": {
            "state": "!= TASK_RUNNING",
            "current->task_state_change": "!= null"
        }
    }
},
S,
{
    "kretprobe:static unsigned long prev_jiffy;unsigned long preempt_disable_ip;/* WARN_ON_ONCE() by default, no rate limit required: `": {
        "description": "This is the kretprobe function for the given code snippet.",
        "pre": {
            "prev_jiffy": "!=null",
            "preempt_disable_ip": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:wake_up_bit": {
        "description": "Wake up a waiter on a bit.",
        "pre": {
            "wq_head": "!=null",
            "word": "!=null",
            "bit": "!=null"
        }
    }
},
{
    "kprobe:wake_up_bit": {
        "description": "Wake up a waiter on a bit.",
        "pre": {
            "wq_head": "!=null",
            "word": "!=null",
            "bit": "int"
        }
    }
},
{
    "kretprobe:complete": {
        "description": "Signals a single thread waiting on this completion.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:complete": {
        "description": "- signals a single thread waiting on this completion",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:complete": {
        "description": "Wakes up a task and executes a full memory barrier before accessing the task state.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:complete": {
        "description": "Completes the specified completion object.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:wait_for_completion": {
        "description": "Wait for the completion of a specific task.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:wait_for_completion": {
        "description": "Wait for the completion of a specific task.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:wait_for_completion_io": {
        "description": "Waits for completion of a task",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:wait_for_completion_io": {
        "description": "Waits for completion of a task",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:__schedwait_for_completion_io_timeout": {
        "description": "Waits for completion of a task with a timeout.",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__schedwait_for_completion_io_timeout": {
        "description": "Waits for completion of a task with a timeout.",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:wait_for_completion_interruptible": {
        "description": "Waits for completion of a task (wintr)",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "in [-ERESTARTSYS, 0]"
        }
    }
},
{
    "kprobe:wait_for_completion_interruptible": {
        "description": "Waits for completion of a task (wintr)",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:__schedwait_for_completion_interruptible_timeout": {
        "description": "Waits for completion (w(to,intr)).",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": "in [-ERESTARTSYS, 0, >=1]"
        }
    }
},
{
    "kprobe:__schedwait_for_completion_interruptible_timeout": {
        "description": "Waits for completion of a specific task or for a specified timeout to expire.",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:wait_for_completion_killable": {
        "description": "Waits for completion of a task (killable).",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "in [-ERESTARTSYS, 0]"
        }
    }
},
{
    "kprobe:wait_for_completion_killable": {
        "description": "Waits for completion of a task (killable).",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:__schedwait_for_completion_killable_timeout": {
        "description": "Waits for completion of a task with a timeout.",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": "in [-ERESTARTSYS, 0, >=1]"
        }
    }
},
{
    "kprobe:__schedwait_for_completion_killable_timeout": {
        "description": "Waits for completion of a task with a timeout.",
        "pre": {
            "x": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:try_wait_for_completion": {
        "description": "Try to decrement a completion without blocking.",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:try_wait_for_completion": {
        "description": "Try to decrement a completion without blocking.",
        "pre": {
            "x": "!=null"
        }
    }
},
S,
{
    "kprobe:complete_all": {
        "description": "Complete all waiters on the given completion variable.",
        "pre": {
            "x": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:list_del_init": {
        "description": "Delete and initialize the entry in the list.",
        "pre": {
            "wait": "!=null",
            "ret": "-ERESTARTSYS"
        }
    }
},
S,
S,
S,
{
    "kretprobe:pm_vt_switch_required": {
        "description": "Indicate VT switch at suspend requirements",
        "pre": {
            "dev": "!=null",
            "required": "in [true, false]"
        }
    }
},
{
    "kprobe:pm_vt_switch_required": {
        "description": "Indicate VT switch at suspend requirements",
        "pre": {
            "dev": "!=null",
            "required": "in [true, false]"
        }
    }
},
{
    "kretprobe:pm_vt_switch_unregister": {
        "description": "stop tracking a device's VT switching needs",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pm_vt_switch_unregister": {
        "description": "Stop tracking a device's VT switching needs",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:bpf_map_free_record": {
        "description": "Free the record associated with the bpf_map.",
        "pre": {
            "map": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_free_record": {
        "description": "Free the record associated with the bpf_map.",
        "pre": {
            "map": "!=null"
        }
    }
},
{
    "kretprobe:bpf_link_put": {
        "description": "Free the bpf_link structure",
        "pre": {
            "link": "!=null",
            "context": "sleepable"
        }
    }
},
{
    "kprobe:bpf_link_put": {
        "description": "Put a reference to a bpf_link object.",
        "pre": {
            "link": "!=null",
            "context": "in [atomic, sleepable]"
        }
    }
},
{
    "kretprobe:BPF_PROG_TEST_RUN": {
        "description": "This is the BPF_PROG_TEST_RUN function.",
        "pre": {
            "attr->test.data_in": "==null",
            "attr->test.data_out": "==null",
            "attr->test.ctx_out": "==null",
            "attr->test.duration": "==null",
            "attr->test.repeat": "==null",
            "attr->test.flags": "==null",
            "attr->test.prog_fd": "!=null",
            "attr->test.ctx_size_in": ">= prog->aux->max_ctx_offset && attr->test.ctx_size_in <= U16_MAX"
        }
    }
},
{
    "kprobe:BPF_PROG_TEST_RUN": {
        "description": "Test run a BPF program.",
        "pre": {
            "attr->test.data_in": "==null",
            "attr->test.data_out": "==null",
            "attr->test.ctx_out": "==null",
            "attr->test.duration": "==null",
            "attr->test.repeat": "==null",
            "attr->test.flags": "==null",
            "attr->test.prog_fd": "!=null",
            "attr->test.ctx_size_in": ">= prog->aux->max_ctx_offset && attr->test.ctx_size_in <= U16_MAX"
        }
    }
},
{
    "kretprobe:__cgroup_bpf_run_filter_skb": {
        "description": "Run a program for packet filtering",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "atype": "in [INET, INET6]"
        },
        "post": {
            "return_value": "in [0, -EPERM, NET_XMIT_SUCCESS, NET_XMIT_DROP, NET_XMIT_CN]"
        }
    }
},
{
    "kprobe:__cgroup_bpf_run_filter_skb": {
        "description": "Run a program for packet filtering",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "atype": "in [INET, INET6]"
        },
        "post": {
            "return": "in [0, -EPERM, NET_XMIT_SUCCESS, NET_XMIT_DROP, NET_XMIT_CN]"
        }
    }
},
{
    "kretprobe:__cgroup_bpf_run_filter_sock_addr": {
        "description": "Run a program on a sock and provided by user sockaddr",
        "pre": {
            "sk": "!=null",
            "uaddr": "!=null",
            "atype": "in [CGROUP_BPF_ATTACH_TYPE_1, CGROUP_BPF_ATTACH_TYPE_2, CGROUP_BPF_ATTACH_TYPE_3]",
            "t_ctx": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:__cgroup_bpf_run_filter_sock_addr": {
        "description": "Run a program on a sock and provided by user sockaddr",
        "pre": {
            "sk": "!=null",
            "uaddr": "!=null",
            "atype": "in [CGROUP_BPF_ATTACH_TYPE_1, CGROUP_BPF_ATTACH_TYPE_2, CGROUP_BPF_ATTACH_TYPE_3]",
            "t_ctx": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:__cgroup_bpf_run_filter_sock_ops": {
        "description": "Run a program on a sock",
        "pre": {
            "sk": "!=null",
            "sock_ops": "!=null",
            "atype": "in [CGROUP_BPF_ATTACH_TYPE_INET, CGROUP_BPF_ATTACH_TYPE_INET6]"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:__cgroup_bpf_run_filter_sock_ops": {
        "description": "Run a program on a sock",
        "pre": {
            "sk": "!=null",
            "sock_ops": "!=null",
            "atype": "in [CGROUP_BPF_ATTACH_TYPE_INET, CGROUP_BPF_ATTACH_TYPE_INET6]"
        },
        "post": {
            "return": "in [0, -EPERM]"
        }
    }
},
S,
S,
{
    "kretprobe:kcsan_nestable_atomic_begin": {
        "description": "Do not check and warn if we are in a flat atomic region: nestable and flat atomic regions are independent from each other. See include/linux/kcsan.h: struct kcsan_ctx comments for more comments.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:kcsan_nestable_atomic_begin": {
        "description": "Do not check and warn if we are in a flat atomic region: nestable and flat atomic regions are independent from each other. See include/linux/kcsan.h: struct kcsan_ctx comments for more comments.",
        "pre": {}
    }
},
S,
S,
S,
{
    "kprobe:is_atomic": {
        "description": "Check if the given context is atomic.",
        "pre": {
            "ctx": "!=null",
            "ptr": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head and set the values of sa->ptr, sa->size, sa->type, and sa->ip.",
        "post": {
            "sa->list": "is_initialized",
            "sa->ptr": "ptr",
            "sa->size": "size",
            "sa->type": "type",
            "sa->ip": "_RET_IP_",
            "ctx->scoped_accesses.prev": "null"
        }
    }
},
{
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head and set the values of sa->ptr, sa->size, sa->type, and sa->ip.",
        "pre": {
            "ptr": "!=null",
            "size": "!=null",
            "type": "!=null",
            "sa->list": "!=null",
            "sa->ptr": "==ptr",
            "sa->size": "==size",
            "sa->type": "==type",
            "sa->ip": "==_RET_IP_",
            "ctx->scoped_accesses.prev": "==null"
        }
    }
},
"pre": {
    "sa": "!=null",
    "ctx": "!=null",
    "ctx->scoped_accesses": "not empty"
},
{
    "kprobe:kcsan_end_scoped_access": {
        "description": "Disable KCSAN, in case list debugging is on.",
        "pre": {
            "sa": "!=null",
            "ctx->scoped_accesses.prev": "!=null",
            "ctx->disable_count": "incremented"
        }
    }
},
S,
S,
{
    "kretprobe:__tsan_atomic_signal_fence": {
        "description": "__tsan_atomic_signal_fence() function",
        "pre": {
            "memorder": "!=null"
        }
    }
},
S,
{
    "kretprobe:__tsan_memset": {
        "description": "Instead of not setting up watchpoints where accessed size is greater than MAX_ENCODABLE_SIZE, truncate checked size to MAX_ENCODABLE_SIZE.",
        "pre": {
            "s": "!=null",
            "c": "int",
            "count": "size_t"
        }
    }
},
{
    "kprobe:__tsan_memset": {
        "description": "Instead of not setting up watchpoints where accessed size is greater than MAX_ENCODABLE_SIZE, truncate checked size to MAX_ENCODABLE_SIZE.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:if (entry->map_err_type == MAP_ERR_NOT_CHECKED)": {
        "description": "Check if the map error type of the entry is MAP_ERR_NOT_CHECKED.",
        "pre": {
            "entry": "!=null",
            "entry->map_err_type": "== MAP_ERR_NOT_CHECKED"
        }
    }
},
{
    "kprobe:entry->map_err_type": {
        "description": "Check if the map error type is not checked.",
        "pre": {
            "entry": {
                "map_err_type": "MAP_ERR_NOT_CHECKED"
            }
        }
    }
},
{
    "kretprobe:dmam_free_coherent": {
        "description": "Managed dma_free_coherent().",
        "pre": {
            "dev": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma_handle": "!=null"
        }
    }
},
{
    "kprobe:dmam_free_coherent": {
        "description": "Managed dma_free_coherent().",
        "pre": {
            "dev": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma_handle": "!=null"
        }
    }
},
{
    "kretprobe:dmam_alloc_attrs": {
        "description": "Allocate non-coherent memory for a device.",
        "pre": {
            "dev": "!=null",
            "size": ">0",
            "dma_handle": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "attrs": "in [DMA_ATTR_...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:dmam_alloc_attrs": {
        "description": "Allocate non-coherent memory for a device.",
        "pre": {
            "dev": "!=null",
            "size": "!=null",
            "dma_handle": "!=null",
            "gfp": "!=null",
            "attrs": "in [DMA_ATTR_]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
S,
{
    "kprobe:dma_map_sg_attrs": {
        "description": "Map a scatterlist for DMA transfer with specified attributes.",
        "pre": {
            "dev": "!=null",
            "sg": "!=null",
            "nents": ">0",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]",
            "attrs": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:dma_can_mmap": {
        "description": "Check if DMA mappings can be mmaped to userspace.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dma_can_mmap": {
        "description": "Check if DMA mappings can be mmaped to userspace.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dma_set_mask": {
        "description": "Truncate the mask to the actually supported dma_addr_t width to avoid generating unsupportable addresses.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null",
            "mask": "is dma_addr_t",
            "!dev->dma_mask || !dma_supported(dev, mask)": "true"
        },
        "post": {
            "return": "in [-EIO, 0]"
        }
    }
},
{
    "kprobe:dma_set_mask": {
        "description": "Truncate the mask to the actually supported dma_addr_t width to avoid generating unsupportable addresses.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null",
            "dma_supported(dev, mask)": true,
            "dev->dma_mask": "!=null",
            "*dev->dma_mask": "mask"
        }
    }
},
{
    "kretprobe:dma_set_coherent_mask": {
        "description": "Truncate the mask to the actually supported dma_addr_t width to avoid generating unsupportable addresses.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null",
            "mask": "is dma_addr_t",
            "!dma_supported(dev, mask)": "return -EIO"
        },
        "post": {
            "dev->coherent_dma_mask": "mask",
            "return": "0"
        }
    }
},
{
    "kprobe:dma_set_coherent_mask": {
        "description": "Truncate the mask to the actually supported dma_addr_t width to avoid generating unsupportable addresses.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0))return vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);#endif/* * Use the main logbuf even in NMI. But avoid calling console * drivers that might have their own locks.": {
        "description": "This function checks if the conditions for calling vkdb_printf are met.",
        "pre": {
            "kdb_trap_printk": "==true",
            "kdb_printf_cpu": "<0"
        }
    }
},
{
    "kprobe:if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0))return vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);#endif/* * Use the main logbuf even in NMI. But avoid calling console * drivers that might have their own locks.": {
        "description": "This function checks if the conditions for printing a message using vkdb_printf are met.",
        "pre": {
            "kdb_trap_printk": "==true",
            "kdb_printf_cpu": "<0"
        }
    }
},
{
    "kretprobe:__control_devkmsg": {
        "description": "Control the devkmsg log.",
        "pre": {
            "str": "!=null"
        }
    }
},
S,
{
    "kretprobe:console_list_unlock": {
        "description": "Unlock the console list",
        "pre": {
            "console_list": "!=null"
        }
    }
},
{
    "kprobe:console_list_unlock": {
        "description": "Unlock the console list. Counterpart to console_list_lock().",
        "pre": {
            "none": "none"
        }
    }
},
S,
S,
{
    "kretprobe:devkmsg_write": {
        "description": "Write a message to the kernel log.",
        "pre": {
            "iocb": "!=null",
            "iocb->ki_filp": "!=null",
            "iocb->ki_filp->private_data": "!=null",
            "iov_iter_count(from)": "!=null",
            "iov_iter_count(from)": "<= PRINTKRB_RECORD_MAX",
            "default_message_loglevel": "!=null",
            "facility": "!=null",
            "facility": "== 1",
            "level": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kprobe:devkmsg_write": {
        "description": "Write data to devkmsg",
        "pre": {
            "file": "!=null",
            "user": "!=null",
            "len": ">0",
            "ret": "==len",
            "len > PRINTKRB_RECORD_MAX": "true"
        }
    }
},
{
    "kretprobe:MESSAGE_LOGLEVEL_DEFAULT": {
        "description": "Function MESSAGE_LOGLEVEL_DEFAULT with _printk helper",
        "pre": {
            "_printk[0]": "CONSOLE_LOGLEVEL_DEFAULT",
            "_printk[1]": "console_loglevel"
        }
    }
},
{
    "kprobe:MESSAGE_LOGLEVEL_DEFAULT": {
        "description": "Description of the MESSAGE_LOGLEVEL_DEFAULT function.",
        "pre": {
            "arg1": "!=null",
            "arg2": "CONSOLE_LOGLEVEL_DEFAULT",
            "arg3": "!=null",
            "arg4": "console_loglevel"
        }
    }
},
S,
S,
{
    "kretprobe:console_trylock_spinning": {
        "description": "Try to get console_lock by busy waiting.",
        "pre": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:console_trylock_spinning": {
        "description": "Try to get console_lock by busy waiting.",
        "pre": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:record_print_text": {
        "description": "Record and print text",
        "pre": {
            "r": "!=null",
            "syslog": "bool",
            "time": "bool"
        }
    }
},
{
    "kprobe:printk_timefalse#define prb_read_valid(rb, seq, r)false#define prb_first_valid_seq(rb)0#define prb_next_seq(rb)0static u64 syslog_seq;static size_t record_print_text(const struct printk_record *r,bool syslog, bool time)": {
        "description": "Function for printing text with printk.",
        "pre": {
            "r": "!=null",
            "syslog": "bool",
            "time": "bool"
        }
    }
},
{
    "kretprobe:console_conditional_schedule": {
        "description": "Yield the CPU if required. Must be called within console_lock().",
        "pre": {
            "console_code_allowed_to_sleep": "==true",
            "should_yield_to_another_task": "==true"
        }
    }
},
{
    "kprobe:console_conditional_schedule": {
        "description": "Yield the CPU if required. Must be called within console_lock().",
        "pre": {
            "console_code_allowed_to_sleep": "true",
            "should_yield_to_another_task": "true",
            "console_lock_held": "true"
        }
    }
},
{
    "kretprobe:console_stop": {
        "description": "Ensure that all SRCU list walks have completed. All contexts must be able to see that this console is disabled so that (for example) the caller can suspend the port without risk of another context using the port.",
        "pre": {
            "console": "!=null"
        }
    }
},
{
    "kprobe:synchronize_srcu(&console_srcu);}EXPORT_SYMBOL(console_stop": {
        "description": "Ensure that all SRCU list walks have completed. All contexts must be able to see that this console is disabled so that (for example) the caller can suspend the port without risk of another context using the port.",
        "pre": {
            "console": "!=null"
        }
    }
},
{
    "kretprobe:WARN_ON_ONCE(debug_lockdep_rcu_enabled() && srcu_read_lock_held(&console_srcu));mutex_lock(&console_mutex);}EXPORT_SYMBOL(console_list_lock);/** * console_list_unlock - Unlock the console list * * Counterpart to console_list_lock()": {
        "description": "Unlock the console list",
        "pre": {
            "debug_lockdep_rcu_enabled()": true,
            "srcu_read_lock_held(&console_srcu)": true,
            "console_list_lock": "not held",
            "srcu_lock": "not held"
        }
    }
},
{
    "kprobe:WARN_ON_ONCE(debug_lockdep_rcu_enabled() && srcu_read_lock_held(&console_srcu));mutex_lock(&console_mutex);}EXPORT_SYMBOL(console_list_lock);/** * console_list_unlock - Unlock the console list * * Counterpart to console_list_lock()": {
        "description": "",
        "pre": {
            "console_list_lock": "!=null"
        }
    }
},
{
    "kretprobe:printk_timed_ratelimit": {
        "description": "Caller-controlled printk ratelimiting",
        "pre": {
            "caller_jiffies": "!=null",
            "interval_msecs": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:printk_timed_ratelimit": {
        "description": "Caller-controlled printk ratelimiting",
        "pre": {
            "caller_jiffies": "!=null",
            "interval_msecs": "!=null",
            "interval_msecs > 0": true
        }
    }
},
{
    "kretprobe:__printk_cpu_sync_wait": {
        "description": "Busy wait until the printk cpu-reentrant spinning lock is not owned by any CPU.",
        "pre": {
            "context": "any"
        }
    }
},
{
    "kprobe:__printk_cpu_sync_wait": {
        "description": "Busy wait until the printk cpu-reentrant spinning lock is not owned by any CPU.",
        "pre": {
            "context": "any"
        }
    }
},
{
    "kretprobe:__printk_cpu_sync_try_get": {
        "description": "Try to acquire the printk cpu-reentrant spinning lock.",
        "pre": {
            "interrupts_disabled": "true"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:__printk_cpu_sync_try_get": {
        "description": "Try to acquire the printk cpu-reentrant spinning lock.",
        "pre": {
            "context": "any",
            "interrupts_disabled": true
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
S,
S,
{
    "kretprobe:rdmacg_uncharge_hierarchy": {
        "description": "Hierarchically uncharge rdma resource count",
        "pre": {
            "cg": "!=null",
            "device": "!=null",
            "stop_cg": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:rdmacg_uncharge_hierarchy": {
        "description": "Hierarchically uncharge rdma resource count",
        "pre": {
            "cg": "!=null",
            "device": "!=null",
            "stop_cg": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:rdmacg_try_charge": {
        "description": "Hierarchically try to charge the rdma resource",
        "pre": {
            "rdmacg": "!=null",
            "device": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "in [0, -EAGAIN, -ENOMEM, -EINVAL]",
            "rdmacg": "!=null when return == 0"
        }
    }
},
{
    "kprobe:rdmacg_try_charge": {
        "description": "Hierarchically try to charge the rdma resource",
        "pre": {
            "rdmacg": "!=null",
            "device": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "in [0, -EAGAIN, -ENOMEM, -EINVAL]",
            "rdmacg": "!=null when return == 0"
        }
    }
},
{
    "kretprobe:rdmacg_register_device": {
        "description": "Register rdmacg device to rdma controller.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:rdmacg_register_device": {
        "description": "Register rdmacg device to rdma controller.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:rdmacg_unregister_device": {
        "description": "Unregister rdmacg device from rdma controller.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:rdmacg_unregister_device": {
        "description": "Unregister rdmacg device from rdma controller.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:while (irqd_irq_inprogress(&desc->irq_data))cpu_relax();/* Ok, that indicated we're done: double-check carefully. `": {
        "description": "Wait until the irq is not in progress and double-check carefully.",
        "pre": {
            "desc": "!=null",
            "sync_chip": "bool"
        }
    }
},
{
    "kprobe:while (irqd_irq_inprogress(&desc->irq_data))cpu_relax();/* Ok, that indicated we're done: double-check carefully. `": {
        "description": "Wait until the irq is not in progress and double-check carefully.",
        "pre": {
            "desc": "!=null",
            "sync_chip": "bool",
            "irqd": "!=null",
            "inprogress": "bool",
            "flags": "unsigned long"
        }
    }
},
{
    "kretprobe:synchronize_irq": {
        "description": "Wait for pending IRQ handlers for a specific interrupt to complete.",
        "pre": {
            "irq": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:synchronize_irq": {
        "description": "Wait for pending IRQ handlers (on other CPUs).",
        "pre": {
            "irq": "!=null",
            "preemptible_code": "true",
            "interrupt_thread_associated": "true",
            "interrupt_pending": "not in [BPF_PENDING, BPF_WAITING]"
        }
    }
},
{
    "kretprobe:disable_irq_nosync": {
        "description": "Disable an IRQ without waiting.",
        "pre": {
            "irq": "!=null"
        }
    }
},
{
    "kprobe:disable_irq_nosync": {
        "description": "Disable an irq without waiting",
        "pre": {
            "irq": "!=null"
        }
    }
},
S,
{
    "kprobe:irq_settings_set_noprobe": {
        "description": "Call irq_startup() not irq_enable() here because the interrupt might be marked NOAUTOEN. So irq_startup() needs to be invoked when it gets enabled the first time. If it was already started up, then irq_startup() will invoke irq_enable() under the hood.",
        "pre": {
            "desc": "!=null",
            "desc->depth": "==0 || ==1",
            "desc->istate & IRQS_SUSPENDED": "==0"
        }
    }
},
{
    "kretprobe:irq_set_irq_wake": {
        "description": "Control irq power management wakeup.",
        "pre": {
            "irq": "!=null",
            "on": "in [0, 1]"
        }
    }
},
{
    "kprobe:irq_set_irq_wake": {
        "description": "Control irq power management wakeup.",
        "pre": {
            "irq": "!=null",
            "on": "in [0, 1]"
        }
    }
},
S,
S,
{
    "kretprobe:irq_default_primary_handler": {
        "description": "Handler function for the irq_default_primary_handler.",
        "pre": {
            "irq": ">= 0",
            "dev_id": "!= null",
            "handler": "== null"
        }
    }
},
{
    "kprobe:irq_default_primary_handler": {
        "description": "Handler function for the irq_default_primary_handler.",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null",
            "handler": "==null"
        }
    }
},
{
    "kretprobe:irq_domain_set_info": {
        "description": "Set the complete data for a @virq in @domain",
        "pre": {
            "domain": "!=null",
            "virq": "!=null",
            "hwirq": "!=null",
            "chip": "!=null",
            "chip_data": "!=null",
            "handler": "!=null",
            "handler_data": "!=null",
            "handler_name": "!=null"
        }
    }
},
{
    "kprobe:irq_domain_set_info": {
        "description": "Set the complete data for a @virq in @domain",
        "pre": {
            "domain": "!=null",
            "virq": "!=null",
            "hwirq": "!=null",
            "chip": "!=null",
            "chip_data": "!=null",
            "handler": "!=null",
            "handler_data": "!=null",
            "handler_name": "!=null"
        }
    }
},
{
    "kretprobe:irq_set_chip": {
        "description": "Set the irq chip for an irq.",
        "pre": {
            "irq": "unsigned int",
            "chip": "const struct irq_chip *"
        }
    }
},
{
    "kprobe:irq_set_chip": {
        "description": "Set the irq chip for an irq.",
        "pre": {
            "irq": "unsigned int",
            "chip": "struct irq_chip *"
        }
    }
},
{
    "kretprobe:irq_set_irq_type": {
        "description": "Set the irq trigger type for an irq.",
        "pre": {
            "irq": "!=null",
            "type": "in [IRQ_TYPE_LEVEL, IRQ_TYPE_EDGE]"
        }
    }
},
{
    "kprobe:irq_set_irq_type": {
        "description": "Set the irq trigger type for an irq.",
        "pre": {
            "irq": "unsigned int",
            "type": "unsigned int",
            "irq_type": "in [IRQ_TYPE_LEVEL, IRQ_TYPE_EDGE]"
        }
    }
},
{
    "kretprobe:irq_set_handler_data": {
        "description": "Set irq handler data for an irq.",
        "pre": {
            "irq": "unsigned int",
            "data": "void *"
        }
    }
},
{
    "kprobe:irq_set_handler_data": {
        "description": "Set irq handler data for an irq",
        "pre": {
            "irq": "unsigned int",
            "data": "void *"
        }
    }
},
{
    "kretprobe:irq_set_chip_data": {
        "description": "Set the hardware irq chip data for an irq",
        "pre": {
            "irq": "unsigned int",
            "data": "void *"
        }
    }
},
{
    "kprobe:irq_set_chip_data": {
        "description": "Set irq chip data for an irq.",
        "pre": {
            "irq": "unsigned int",
            "data": "void *"
        }
    }
},
{
    "kretprobe:handle_edge_irq": {
        "description": "Edge type IRQ handler",
        "pre": {
            "desc": "!=null"
        }
    }
},
{
    "kprobe:handle_edge_irq": {
        "description": "Edge type IRQ handler",
        "pre": {
            "desc": "!=null"
        }
    }
},
{
    "kretprobe:probe_irq_on": {
        "description": "Begin an interrupt autodetect. Commence probing for an interrupt. The interrupts are scanned and a mask of potential interrupt lines is returned.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:probe_irq_on": {
        "description": "Begin an interrupt autodetect. Commence probing for an interrupt. The interrupts are scanned and a mask of potential interrupt lines is returned.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:probe_irq_mask": {
        "description": "Scan a bitmap of interrupt lines",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kprobe:probe_irq_mask": {
        "description": "Scan a bitmap of interrupt lines.",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kretprobe:probe_irq_off": {
        "description": "End an interrupt autodetect",
        "pre": {
            "val": "!=null"
        },
        "post": {
            "return": ">=-1"
        }
    }
},
{
    "kprobe:probe_irq_off": {
        "description": "End an interrupt autodetect.",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kretprobe:devm_request_threaded_irq": {
        "description": "Request a threaded interrupt handler for a device.",
        "pre": {
            "dev": "!=null",
            "irq": ">=0",
            "handler": "!=null",
            "thread_fn": "!=null",
            "irqflags": ">=0",
            "devname": "!=null",
            "dev_id": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:devm_request_any_context_irq": {
        "description": "Allocate an interrupt line for a managed device.",
        "pre": {
            "dev": "!=null",
            "irq": "!=null",
            "handler": "!=null",
            "irqflags": "!=null",
            "devname": "!=null",
            "dev_id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_request_any_context_irq": {
        "description": "Allocate an interrupt line for a managed device.",
        "pre": {
            "dev": "!=null",
            "irq": "!=null",
            "handler": "!=null",
            "irqflags": "!=null",
            "devname": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:trace_hardirqs_on_prepare": {
        "description": "trace_hardirqs_on() but without the lockdep invocation. This is used in the low level entry code where the ordering vs. RCU is important and lockdep uses a staged approach which splits the lockdep hardirq tracking into a RCU on and a RCU off section.",
        "pre": {
            "lockdep_invocation": "false",
            "ordering_vs_rcu": "important"
        }
    }
},
{
    "kprobe:trace_hardirqs_on_prepare": {
        "description": "trace_hardirqs_on() but without the lockdep invocation. This is used in the low level entry code where the ordering vs. RCU is important and lockdep uses a staged approach which splits the lockdep hardirq tracking into a RCU on and a RCU off section.",
        "pre": {
            "lockdep_invocation": "false",
            "ordering_vs_rcu": "important"
        }
    }
},
{
    "kretprobe:trace_hardirqs_off_finish": {
        "description": "trace_hardirqs_off() but without the lockdep invocation. This is used in the low level entry code where the ordering vs. RCU is important and lockdep uses a staged approach which splits the lockdep hardirq tracking into a RCU on and a RCU off section.",
        "pre": {
            "lockdep_invocation": "==null",
            "ordering_vs_rcu": "important",
            "staged_approach": "true",
            "lockdep_hardirq_tracking": {
                "rcu_on_section": "true",
                "rcu_off_section": "true"
            }
        }
    }
},
S,
S,
S,
{
    "kretprobe:trace_print_hex_seq": {
        "description": "Print buffer as hex sequence",
        "pre": {
            "p": "!=null",
            "buf": "!=null",
            "buf_len": ">=0",
            "concatenate": "in [true, false]"
        }
    }
},
{
    "kprobe:trace_print_hex_seq": {
        "description": "Print buffer as hex sequence",
        "pre": {
            "p": "!=null",
            "buf": "!=null",
            "buf_len": ">=0",
            "concatenate": "in [true, false]"
        }
    }
},
{
    "kretprobe:trace_seq_acquire": {
        "description": "Acquire seq buffer with size len",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:trace_seq_acquire": {
        "description": "Acquire seq buffer with size len",
        "pre": {
            "s": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:ftrace_likely_update": {
        "description": "Update the ftrace_likely_data structure with the given values.",
        "pre": {
            "f": "!=null",
            "val": "!=null",
            "expect": "!=null",
            "is_constant": "is_constant"
        }
    }
},
{
    "ftrace_likely_update": {
        "description": "Update the ftrace likely data with the given values.",
        "pre": {
            "f": "!=null",
            "val": "!=null",
            "expect": "!=null",
            "is_constant": "is_constant"
        }
    }
},
{
    "kretprobe:ktime_get_real_ts64": {
        "description": "Returns the time of day in a timespec64 (WARN if suspended).",
        "pre": {
            "ts": "!=null"
        }
    }
},
{
    "kprobe:ktime_get_real_ts64": {
        "description": "Returns the time of day in a timespec64 (WARN if suspended).",
        "pre": {
            "ts": "!=null"
        }
    }
},
{
    "kretprobe:do_settimeofday64": {
        "description": "Sets the time of day.",
        "pre": {
            "ts": "!=null"
        }
    }
},
{
    "kprobe:do_settimeofday64": {
        "description": "Sets the time of day.",
        "pre": {
            "ts": "!=null"
        }
    }
},
{
    "kretprobe:ktime_get_raw_ts64": {
        "description": "Returns the raw monotonic time in a timespec",
        "pre": {
            "ts": "!=null"
        }
    }
},
{
    "kprobe:ktime_get_raw_ts64": {
        "description": "Returns the raw monotonic time in a timespec.",
        "pre": {
            "ts": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:kthread_run": {
        "description": "Run the specified function in a kernel thread.",
        "pre": {
            "function": "kthread_run",
            "arg1": "clocksource_watchdog_kthread",
            "arg2": "NULL",
            "arg3": "\"kwatchdog\""
        }
    },
    "kretprobe:__clocksource_unstable": {
        "description": "Handle an unstable clocksource.",
        "pre": {
            "cs": "!=null"
        }
    }
},
S,
{
    "kretprobe:clocksource_unregister": {
        "description": "Remove a registered clocksource.",
        "pre": {
            "cs": "!=null"
        }
    }
},
{
    "kprobe:clocksource_unregister": {
        "description": "Remove a registered clocksource.",
        "pre": {
            "cs": "!=null"
        }
    }
},
{
    "kretprobe:time64_to_tm": {
        "description": "Converts the calendar time to local broken-down time.",
        "pre": {
            "totalsecs": "!=null",
            "offset": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kprobe:time64_to_tm": {
        "description": "Converts the calendar time to local broken-down time.",
        "pre": {
            "totalsecs": "!=null",
            "offset": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:init_timer_key": {
        "description": "Initialize a timer",
        "pre": {
            "timer": "!=null",
            "func": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:init_timer_key": {
        "description": "Initialize a timer.",
        "pre": {
            "timer": "!=null",
            "func": "!=null",
            "flags": "!=null",
            "name": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:mod_timer_pending": {
        "description": "Modify a pending timer's timeout",
        "pre": {
            "timer": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kprobe:mod_timer_pending": {
        "description": "Modify a pending timer's timeout",
        "pre": {
            "timer": "!=null",
            "expires": ">=0"
        }
    }
},
{
    "kretprobe:mod_timer": {
        "description": "Modify a timer to have a new expiration time and options.",
        "pre": {
            "timer": "!=null",
            "expires": "!=null",
            "options": "!=null",
            "clk": "!=null",
            "flags": "!=null",
            "bucket_expiry": "!=null",
            "base": "!=null",
            "new_base": "!=null",
            "idx": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "==0",
            "timer": "unchanged",
            "expires": "unchanged",
            "options": "unchanged",
            "clk": "unchanged",
            "flags": "unchanged",
            "bucket_expiry": "unchanged",
            "base": "unchanged",
            "new_base": "unchanged",
            "idx": "unchanged"
        }
    }
},
{
    "kprobe:mod_timer": {
        "description": "Modify a timer",
        "pre": {
            "timer": "!=null",
            "expires": "!=null",
            "options": "!=null",
            "options & MOD_TIMER_NOTPENDING": "==0",
            "timer_pending(timer)": "==1"
        }
    }
},
{
    "kretprobe:timer_reduce": {
        "description": "Modify a timer's timeout if it would reduce the timeout",
        "pre": {
            "timer": "!=null",
            "expires": ">=0"
        }
    }
},
{
    "kprobe:timer_reduce": {
        "description": "Modify a timer's timeout if it would reduce the timeout",
        "pre": {
            "timer": "!=null",
            "expires": "!=null"
        }
    }
},
{
    "kretprobe:timer_fixup_init": {
        "description": "Called when an active object is initialized.",
        "pre": {
            "addr": "!=null",
            "state": "in [DEBUG_OBJ_ENABLED, DEBUG_OBJ_DISABLED, DEBUG_OBJ_WARN]"
        }
    }
},
{
    "kprobe:timer_fixup_init": {
        "description": "Initialize an active object.",
        "pre": {
            "addr": "!=null",
            "state": "in [DEBUG_OBJ_ENABLED, DEBUG_OBJ_DISABLED, DEBUG_OBJ_WARN]"
        }
    }
},
S,
S,
{
    "kretprobe:__try_to_del_timer_sync": {
        "description": "Try to deactivate a timer",
        "pre": {
            "timer": "!=null",
            "shutdown": "in [true, false]"
        },
        "post": {
            "return": "in [0, 1, -1]"
        }
    }
},
{
    "kprobe:__try_to_del_timer_sync": {
        "description": "Internal function: Try to deactivate a timer",
        "pre": {
            "timer": "!=null",
            "shutdown": "in [true, false]"
        },
        "post": {
            "return": "in [0, 1, -1]"
        }
    }
},
S,
S,
{
    "kretprobe:msleep": {
        "description": "Sleep safely even with waitqueue interruptions.",
        "pre": {
            "msecs": ">=0"
        }
    }
},
{
    "kprobe:msleep": {
        "description": "Sleep safely even with waitqueue interruptions.",
        "pre": {
            "msecs": ">=0"
        }
    }
},
{
    "kretprobe:msleep_interruptible": {
        "description": "Sleep waiting for signals",
        "pre": {
            "msecs": "!=null"
        }
    }
},
{
    "kprobe:msleep_interruptible": {
        "description": "Sleep waiting for signals.",
        "pre": {
            "msecs": "!=null"
        }
    }
},
{
    "kretprobe:usleep_range_state": {
        "description": "Sleep for an approximate time in a given state",
        "pre": {
            "min": ">=0",
            "max": ">=min",
            "state": ">=0"
        }
    }
},
{
    "kprobe:usleep_range_state": {
        "description": "Sleep for an approximate time in a given state",
        "pre": {
            "min": ">=0",
            "max": ">=min",
            "state": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:jiffies_to_usecs": {
        "description": "Converts jiffies to microseconds.",
        "pre": {
            "HZ": "<= MSEC_PER_SEC",
            "USEC_PER_SEC": "!= 0",
            "BITS_PER_LONG": "== 32",
            "USEC_PER_SEC % HZ": "== 0"
        },
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:BUILD_BUG_ON": {
        "description": "Check if HZ is greater than USEC_PER_SEC and return the result.",
        "pre": {
            "HZ": "> USEC_PER_SEC"
        }
    },
    "kprobe:jiffies_to_usecs": {
        "description": "Convert jiffies to microseconds.",
        "pre": {
            "j": "!=null",
            "Hz": "<= MSEC_PER_SEC"
        }
    },
    "kprobe:usecs_to_jiffies": {
        "description": "Convert microseconds to jiffies.",
        "pre": {
            "usecs": "!=null",
            "Hz": "<= MSEC_PER_SEC"
        }
    }
},
{
    "kretprobe:mktime64": {
        "description": "Converts Gregorian date to seconds since 1970-01-01 00:00:00.",
        "pre": {
            "year0": "!=null",
            "mon0": "!=null",
            "day": "!=null",
            "hour": "!=null",
            "min": "!=null",
            "sec": "!=null"
        }
    }
},
{
    "kprobe:mktime64": {
        "description": "Converts Gregorian date to seconds since 1970-01-01 00:00:00.",
        "pre": {
            "year0": ">=0",
            "mon0": ">=1",
            "day": ">=1",
            "hour": ">=0",
            "min": ">=0",
            "sec": ">=0"
        }
    }
},
{
    "kretprobe:set_normalized_timespec64": {
        "description": "Set timespec sec and nsec parts and normalize",
        "pre": {
            "ts": "!=null",
            "sec": "!=null",
            "nsec": "!=null",
            "sec_range": ">=0",
            "nsec_range": ">=0",
            "nsec_range_upper": "<1000000000"
        }
    }
},
{
    "kprobe:set_normalized_timespec64": {
        "description": "Set timespec sec and nsec parts and normalize.",
        "pre": {
            "ts": "!=null",
            "sec": "any",
            "nsec": ">=0 && <NSEC_PER_SEC"
        }
    }
},
{
    "kretprobe:__msecs_to_jiffies": {
        "description": "Convert milliseconds to jiffies",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:__msecs_to_jiffies": {
        "description": "Convert milliseconds to jiffies.",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:jiffies_to_timespec64": {
        "description": "Convert jiffies to nanoseconds and separate with one divide.",
        "pre": {
            "jiffies": "!=null",
            "value": "!=null",
            "value->tv_sec": "!=null",
            "value->tv_nsec": "!=null",
            "rem": "!=null"
        }
    }
},
{
    "kprobe:jiffies_to_timespec64": {
        "description": "Convert jiffies to nanoseconds and separate with one divide.",
        "pre": {
            "jiffies": "!=null",
            "value": "!=null",
            "value->tv_sec": "!=null",
            "value->tv_nsec": "!=null",
            "rem": "!=null"
        }
    }
},
{
    "kretprobe:clock_t_to_jiffies": {
        "description": "Converts a clock_t value to jiffies.",
        "pre": {
            "x": ">= ~0UL / HZ * USER_HZ"
        },
        "post": {
            "return": "== ~0UL"
        }
    }
},
{
    "kprobe:clock_t_to_jiffies": {
        "description": "Converts a clock_t value to jiffies.",
        "pre": {
            "x": ">= ~0UL / HZ * USER_HZ",
            "return": "~0UL"
        }
    }
},
S,
S,
{
    "kretprobe:nsecs_to_jiffies64": {
        "description": "Convert nsecs in u64 to jiffies64",
        "pre": {
            "n": "!=null"
        }
    }
},
{
    "kprobe:nsecs_to_jiffies64": {
        "description": "Convert nsecs in u64 to jiffies64",
        "pre": {
            "n": "!=null"
        }
    }
},
{
    "kretprobe:preempt_disable": {
        "description": "Disable preemption to prevent racing with other callers of klp_try_switch_task().",
        "pre": {
            "current": "not patched",
            "klp_patch_pending(current)": "false"
        }
    }
},
{
    "kprobe:preempt_disable": {
        "description": "Disable preemption to prevent racing with other callers of klp_try_switch_task().",
        "pre": {
            "current": "!klp_patch_pending(current)"
        }
    }
},
{
    "kretprobe:llvm_gcov_callback": {
        "description": "This design is much more stateless and unstructured than gcc's, and is intended to run at process exit. This forces us to keep some local state about which module we're dealing with at the moment. On the other hand, it also means we don't depend as much on how LLVM represents profiling data internally. See LLVM's libTransformsInstrumentationGCOVProfiling.cpp for more details on how this works, particularly GCOVProfiler::emitProfileArcs(), GCOVProfiler::insertCounterWriteout(), and GCOVProfiler::insertFlush().",
        "pre": {
            "llvm_gcov_callback": "!=null"
        }
    }
},
{
    "kprobe:llvm_gcda_end_file": {
        "description": "This design is much more stateless and unstructured than gcc's, and is intended to run at process exit. This forces us to keep some local state about which module we're dealing with at the moment. On the other hand, it also means we don't depend as much on how LLVM represents profiling data internally. See LLVM's libTransformsInstrumentationGCOVProfiling.cpp for more details on how this works, particularly GCOVProfiler::emitProfileArcs(), GCOVProfiler::insertCounterWriteout(), and GCOVProfiler::insertFlush().",
        "pre": {}
    }
},
S,
{
    "kprobe:__gcov_init": {
        "description": "__gcov_init is called by gcc-generated constructor code for each object file compiled with -fprofile-arcs.",
        "pre": {
            "info": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__gcov_merge_add": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
{
    "kprobe:__gcov_merge_add": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
{
    "kretprobe:__gcov_merge_single": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
{
    "kprobe:__gcov_merge_single": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">=0"
        }
    }
},
{
    "kretprobe:__gcov_merge_delta": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">=0"
        }
    }
},
{
    "kprobe:__gcov_merge_delta": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
{
    "kretprobe:__gcov_merge_ior": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
{
    "kprobe:__gcov_merge_ior": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
S,
{
    "kprobe:__gcov_merge_time_profile": {
        "description": "__gcov_merge_time_profile(gcov_type counters, unsigned int n_counters)",
        "pre": {
            "counters": "!=null",
            "n_counters": ">=0"
        }
    }
},
{
    "kretprobe:__gcov_merge_icall_topn": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">=0"
        }
    }
},
{
    "kprobe:__gcov_merge_icall_topn": {
        "description": "Unused.",
        "pre": {
            "counters": "!=null",
            "n_counters": ">0"
        }
    }
},
S,
S,
S,
{
    "kprobe:preempt_disable();if (!find_symbol(&fsa))": {
        "description": "Disable preemption and check if the symbol 'fsa' is not found.",
        "pre": {
            "preempt_disable()": "true",
            "find_symbol(&fsa)": "true"
        }
    }
},
{
    "kretprobe:__request_module": {
        "description": "Try to load a kernel module.",
        "pre": {
            "wait": "bool",
            "fmt": "!=null",
            "...": "arguments as specified in the format string"
        }
    }
},
{
    "kprobe:__request_module": {
        "description": "Try to load a kernel module.",
        "pre": {
            "wait": "bool",
            "fmt": "!=null",
            "...": "varargs"
        }
    }
},
{
    "kretprobe:module_refcount": {
        "description": "Return the refcount or -1 if unloading",
        "pre": {
            "mod": "!=null"
        },
        "post": {
            "return_value": "in [-1, >=0]"
        }
    }
},
{
    "kprobe:module_refcount": {
        "description": "Return the refcount or -1 if unloading.",
        "pre": {
            "mod": "!=null"
        }
    }
},
{
    "kretprobe:strong_try_module_get": {
        "description": "Try to increment the module's reference count.",
        "pre": {
            "mod": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:strong_try_module_get": {
        "description": "Tries to increment the module's reference count.",
        "pre": {
            "mod": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
S,
S,
{
    "kretprobe:kdbgetsymval": {
        "description": "Return the address of the given symbol.",
        "pre": {
            "symname": "!=null",
            "symtab": "!=null"
        },
        "post": {
            "return": "in [0, 1]",
            "symtab": "!=null"
        }
    }
},
{
    "kprobe:kdbgetsymval": {
        "description": "Return the address of the given symbol.",
        "pre": {
            "symname": "!=null",
            "symtab": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sock_alloc_file": {
        "description": "Bind a socket to a file",
        "pre": {
            "sock": "!=null",
            "flags": "!=null",
            "dname": "!=null"
        }
    }
},
{
    "kprobe:sock_alloc_file": {
        "description": "Bind a socket to a file",
        "pre": {
            "sock": "!=null",
            "flags": "!=null",
            "dname": "!=null"
        }
    }
},
{
    "kretprobe:sock_from_file": {
        "description": "Return the &socket bounded to @file.",
        "pre": {
            "file": "!=null"
        },
        "post": {
            "sock": "!=null"
        }
    }
},
{
    "kprobe:sock_from_file": {
        "description": "Return the &socket bounded to @file.",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kretprobe:sockfd_lookup": {
        "description": "Go from a file number to its socket slot",
        "pre": {
            "fd": "!=null",
            "err": "!=null"
        },
        "post": {
            "return": "!=null",
            "err": "< 0"
        }
    }
},
{
    "kprobe:sockfd_lookup": {
        "description": "Go from a file number to its socket slot",
        "pre": {
            "fd": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kretprobe:sock_release": {
        "description": "This module is effectively the top level interface to the BSD socket paradigm.",
        "pre": {
            "fd": "!=null",
            "file": "!=null",
            "inode": "!=null"
        }
    }
},
S,
{
    "kretprobe:__sock_tx_timestamp": {
        "description": "Helper function for timestamping socket transmission.",
        "pre": {
            "tsflags": "& SOF_TIMESTAMPING_BIND_PHC != 0",
            "flags": "|= SKBTX_HW_TSTAMP_USE_CYCLES if (tsflags & SOF_TIMESTAMPING_BIND_PHC) != 0",
            "tsflags": "& SOF_TIMESTAMPING_TX_SOFTWARE != 0",
            "flags": "|= SKBTX_SW_TSTAMP if (tsflags & SOF_TIMESTAMPING_TX_SOFTWARE) != 0",
            "tsflags": "& SOF_TIMESTAMPING_TX_SCHED != 0",
            "flags": "|= SKBTX_SCHED_TSTAMP if (tsflags & SOF_TIMESTAMPING_TX_SCHED) != 0",
            "tx_flags": "= flags"
        }
    }
},
{
    "kprobe:__sock_tx_timestamp": {
        "description": "__sock_tx_timestamp helper function",
        "pre": {
            "tsflags": "!=null",
            "tx_flags": "!=null",
            "flags": "in [SKBTX_HW_TSTAMP_USE_CYCLES, SKBTX_SW_TSTAMP, SKBTX_SCHED_TSTAMP]"
        }
    }
},
{
    "kretprobe:sock_sendmsg": {
        "description": "send a message through @sock",
        "pre": {
            "sock": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kprobe:sock_sendmsg": {
        "description": "Sends a message through the socket.",
        "pre": {
            "sock": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:kernel_sendmsg": {
        "description": "Send a message through @sock (kernel-space)",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kprobe:kernel_sendmsg": {
        "description": "Send a message through @sock (kernel-space)",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:kernel_sendmsg_locked": {
        "description": "Send a message through @sock (kernel-space)",
        "pre": {
            "sk": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kprobe:kernel_sendmsg_locked": {
        "description": "Send a message through @sock (kernel-space)",
        "pre": {
            "sk": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:sock_recvmsg": {
        "description": "Receive a message from @sock",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:sock_recvmsg": {
        "description": "Receive a message from @sock",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:kernel_recvmsg": {
        "description": "Receive a message from a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0",
            "flags": "in [MSG_DONTWAIT, ...]"
        }
    }
},
{
    "kprobe:kernel_recvmsg": {
        "description": "Receive a message from a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "msg": "!=null",
            "vec": "!=null",
            "num": ">=0",
            "size": ">=0",
            "flags": "in [MSG_DONTWAIT, ...]"
        }
    }
},
{
    "kretprobe:sock_create_lite": {
        "description": "Create a socket of the specified family, type, and protocol.",
        "pre": {
            "family": "in [AF_INET, AF_INET6, AF_UNIX, ...]",
            "type": "in [SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...]",
            "protocol": "in [IPPROTO_TCP, IPPROTO_UDP, IPPROTO_ICMP, ...]",
            "res": "==null"
        }
    }
},
{
    "kprobe:sock_create_lite": {
        "description": "Create a new socket of the specified family, type, and protocol.",
        "pre": {
            "family": "in [AF_INET, AF_INET6, AF_UNIX, ...]",
            "type": "in [SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...]",
            "protocol": "!=null",
            "res": "==null"
        }
    }
},
{
    "kretprobe:__sock_create": {
        "description": "Creates a new socket and assigns it to @res, passing through LSM.",
        "pre": {
            "net": "!=null",
            "family": "in [AF_INET, ...]",
            "type": "in [SOCK_STREAM, ...]",
            "protocol": ">=0",
            "res": "!=null",
            "kern": "in [0, 1]"
        }
    }
},
{
    "kprobe:__sock_create": {
        "description": "Creates a socket",
        "pre": {
            "net": "!=null",
            "family": "in [AF_INET, ...]",
            "type": "in [SOCK_STREAM, ...]",
            "protocol": ">=0",
            "res": "!=null",
            "kern": "boolean"
        }
    }
},
{
    "kretprobe:sock_create_kern": {
        "description": "Creates a socket (kernel space)",
        "pre": {
            "net": "!=null",
            "family": "in [AF_INET, ...]",
            "type": "in [SOCK_STREAM, ...]",
            "protocol": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kprobe:sock_create_kern": {
        "description": "Creates a socket (kernel space)",
        "pre": {
            "net": "!=null",
            "family": "in [AF_INET, ...]",
            "type": "in [SOCK_STREAM, ...]",
            "protocol": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:sock_register": {
        "description": "Add a socket protocol handler",
        "pre": {
            "ops": "!=null",
            "ops->family": "!=null"
        }
    }
},
{
    "kprobe:sock_register": {
        "description": "Add a socket protocol handler",
        "pre": {
            "ops": "!=null",
            "ops->family": "!=null"
        }
    }
},
{
    "kretprobe:sock_unregister": {
        "description": "Remove a protocol handler.",
        "pre": {
            "family": "!=null"
        }
    }
},
{
    "kprobe:sock_unregister": {
        "description": "Remove a protocol handler.",
        "pre": {
            "family": "!=null"
        }
    }
},
{
    "kretprobe:sock_ioctl": {
        "description": "Perform ioctl operation on a socket.",
        "pre": {
            "file": "!=null",
            "cmd": "is_unsigned",
            "arg": "!=null"
        },
        "post": {
            "return": "is_integer"
        }
    }
},
{
    "kprobe:sock_ioctl": {
        "description": "Perform an ioctl operation on a socket.",
        "pre": {
            "file": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:kernel_bind": {
        "description": "Bind an address to a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null",
            "addrlen": ">=0"
        }
    }
},
{
    "kprobe:kernel_bind": {
        "description": "Bind an address to a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null",
            "addrlen": ">=0"
        }
    }
},
{
    "kretprobe:kernel_listen": {
        "description": "Move socket to listening state (kernel space)",
        "pre": {
            "sock": "!=null",
            "backlog": ">=0"
        }
    }
},
{
    "kprobe:kernel_listen": {
        "description": "Move socket to listening state (kernel space)",
        "pre": {
            "sock": "!=null",
            "backlog": ">=0"
        }
    }
},
{
    "kretprobe:kernel_connect": {
        "description": "Connect a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null",
            "addrlen": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:kernel_connect": {
        "description": "Connect a socket (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null",
            "addrlen": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:kernel_getsockname": {
        "description": "Get the address which the socket is bound (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:kernel_getsockname": {
        "description": "Get the address which the socket is bound (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:kernel_getpeername": {
        "description": "Get the address which the socket is connected (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:kernel_getpeername": {
        "description": "Get the address which the socket is connected (kernel space)",
        "pre": {
            "sock": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:kernel_sock_shutdown": {
        "description": "Shut down part of a full-duplex connection (kernel space)",
        "pre": {
            "sock": "!=null",
            "how": "in [SHUT_RD, SHUT_WR, SHUT_RDWR]"
        }
    }
},
{
    "kprobe:kernel_sock_shutdown": {
        "description": "Shut down part of a full-duplex connection (kernel space)",
        "pre": {
            "sock": "!=null",
            "how": "in [SHUT_RD, SHUT_WR, SHUT_RDWR]"
        }
    }
},
{
    "kretprobe:kernel_sock_ip_overhead": {
        "description": "Returns the IP overhead imposed by a socket.",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kprobe:kernel_sock_ip_overhead": {
        "description": "Returns the IP overhead imposed by a socket.",
        "pre": {
            "sk": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kretprobe:devm_register_netdev": {
        "description": "Resource managed variant of register_netdev()",
        "pre": {
            "dev": "!=null",
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:devm_register_netdev": {
        "description": "Resource managed variant of register_netdev()",
        "pre": {
            "dev": "!=null",
            "ndev": "!=null"
        }
    }
},
{
    "kretprobe:nfc_digital_unregister_device": {
        "description": "Unregister a digital NFC device",
        "pre": {
            "ddev": "!=null",
            "ddev->nfc_dev": "!=null",
            "ddev->poll_lock": "!=null",
            "ddev->poll_tech_count": "==0",
            "ddev->poll_work": "is not scheduled",
            "ddev->cmd_work": "is not scheduled",
            "ddev->cmd_complete_work": "is not scheduled",
            "cmd": "!=null",
            "cmd->queue": "is in ddev->cmd_queue",
            "cmd->cmd_cb": "!=null",
            "cmd->cb_context": "!=null",
            "cmd->mdaa_params": "is freed",
            "cmd": "is freed"
        }
    }
},
{
    "nfc_digital_unregister_device": {
        "description": "Unregister a digital NFC device",
        "pre": {
            "ddev": "!=null"
        }
    }
},
{
    "kretprobe:nfc_fw_download_done": {
        "description": "Inform that a firmware download was completed.",
        "pre": {
            "dev": "!=null",
            "firmware_name": "!=null",
            "result": ">=0"
        }
    }
},
{
    "kprobe:nfc_fw_download_done": {
        "description": "Inform that a firmware download was completed.",
        "pre": {
            "dev": "!=null",
            "firmware_name": "!=null",
            "result": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:nfc_alloc_recv_skb": {
        "description": "Allocate a skb for data exchange responses",
        "pre": {
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:nfc_alloc_recv_skb": {
        "description": "Allocate a skb for data exchange responses.",
        "pre": {
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:nfc_targets_found": {
        "description": "Inform that targets were found",
        "pre": {
            "dev": "!=null",
            "targets": "!=null",
            "n_targets": ">=0"
        }
    }
},
{
    "kprobe:nfc_targets_found": {
        "description": "Inform that targets were found",
        "pre": {
            "dev": "!=null",
            "targets": "!=null",
            "n_targets": ">=0"
        }
    }
},
{
    "kretprobe:nfc_target_lost": {
        "description": "Inform that an activated target went out of field.",
        "pre": {
            "dev": "!=null",
            "target_idx": "!=null"
        }
    }
},
{
    "kprobe:nfc_target_lost": {
        "description": "Inform that an activated target went out of field.",
        "pre": {
            "dev": "!=null",
            "target_idx": "!=null"
        }
    }
},
{
    "kretprobe:nfc_allocate_device": {
        "description": "Allocate a new NFC device.",
        "pre": {
            "ops": "!=null",
            "supported_protocols": "!=null",
            "tx_headroom": "!=null",
            "tx_tailroom": "!=null"
        }
    }
},
{
    "kprobe:nfc_allocate_device": {
        "description": "Allocate a new NFC device.",
        "pre": {
            "ops": "!=null",
            "supported_protocols": "!=null",
            "tx_headroom": ">=0",
            "tx_tailroom": ">=0"
        }
    }
},
{
    "kretprobe:nfc_register_device": {
        "description": "Register a NFC device in the NFC subsystem",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:nfc_register_device": {
        "description": "Register a NFC device in the NFC subsystem.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:nfc_unregister_device": {
        "description": "Unregister a NFC device in the NFC subsystem.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:nfc_unregister_device": {
        "description": "Unregister a NFC device in the NFC subsystem.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:memset_skb_cb": {
        "description": "Clear CB data for netlink core to own from now on",
        "pre": {
            "skb": "!=null",
            "skb->cb": "!=null",
            "dev->cur_cmd_info": "!=null"
        }
    }
},
{
    "memset(skb->cb, 0, sizeof(skb->cb));if (WARN_ON(!dev->cur_cmd_info))": {
        "description": "Clear CB data for netlink core to own from now on",
        "pre": {
            "skb": "!=null",
            "skb->cb": "!=null",
            "dev": "!=null",
            "dev->cur_cmd_info": "!=null"
        }
    }
},
{
    "kretprobe:nfc_hci_target_discovered": {
        "description": "This function is called when a target is discovered in the NFC HCI device.",
        "pre": {
            "hdev": "!=null",
            "gate": "!=null",
            "targets": "!=null",
            "atqa_skb": "null",
            "sak_skb": "null",
            "uid_skb": "null",
            "r": "not in [0, -ENOMEM, -EPROTO]"
        },
        "post": {
            "targets->hci_reader_gate": "==0x00",
            "r": "in [0, -ENOMEM, -EPROTO]"
        },
        "exit": {
            "kfree(targets)": "always",
            "kfree_skb(atqa_skb)": "always",
            "kfree_skb(sak_skb)": "always",
            "kfree_skb(uid_skb)": "always",
            "return r": "always"
        }
    }
},
{
    "kprobe:nfc_hci_target_discovered": {
        "description": "This function is called when a target is discovered in the NFC HCI subsystem.",
        "pre": {
            "hdev": "!=null",
            "gate": "!=null",
            "targets": "!=null",
            "atqa_skb": "null",
            "sak_skb": "null",
            "uid_skb": "null",
            "r": "int",
            "atqa_skb.len": "2",
            "sak_skb.len": "1",
            "uid_skb.len": "0 < len <= NFC_NFCID1_MAXSIZE",
            "targets.supported_protocols": "0 <= supported_protocols <= 0xffffffff",
            "targets.sens_res": "16-bit big-endian integer",
            "targets.sel_res": "8-bit integer",
            "targets.nfcid1": "array of bytes",
            "targets.nfcid1_len": "integer",
            "hdev.ops.complete_target_discovered": "function",
            "hdev.ops.target_from_gate": "function"
        },
        "post": {
            "r": "int"
        }
    }
},
{
    "kretprobe:hdev->ops->load_session": {
        "description": "Load a session using the hdev->ops->load_session helper function.",
        "pre": {
            "hdev": "!=null",
            "r": "!=null"
        },
        "post": {
            "r": "< 0"
        }
    }
},
S,
{
    "kretprobe:pr_debug": {
        "description": "Prints a debug message with formatted output.",
        "pre": {
            "hdev": "!=null",
            "gate": "!=null",
            "idx": "!=null",
            "param": "!=null",
            "param_len": "!=null",
            "tmp": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kprobe:pr_debug": {
        "description": "Print a debug message with formatted output.",
        "pre": {
            "hdev": "!=null",
            "gate": "!=null",
            "idx": "!=null",
            "param": "!=null",
            "param_len": "!=null",
            "tmp": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kretprobe:nfc_hci_connect_gate": {
        "description": "Connects a gate in the NFC HCI device to a host and a pipe.",
        "pre": {
            "hdev": "!=null",
            "dest_host": "!=null",
            "dest_gate": "!=null",
            "pipe": "!=NFC_HCI_DO_NOT_CREATE_PIPE",
            "hdev->gate2pipe[dest_gate]": "==NFC_HCI_INVALID_PIPE",
            "pipe": "in [NFC_HCI_LINK_MGMT_PIPE, NFC_HCI_ADMIN_PIPE, nfc_hci_create_pipe(hdev, dest_host, dest_gate, &r)]",
            "r": "!=NFC_HCI_INVALID_PIPE"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:nfc_hci_connect_gate": {
        "description": "Connects a gate to a host in the NFC HCI device.",
        "pre": {
            "hdev->gate2pipe[dest_gate]": "!= NFC_HCI_INVALID_PIPE",
            "pipe": "!= NFC_HCI_INVALID_PIPE",
            "dest_gate": {
                "NFC_HCI_LINK_MGMT_GATE": {
                    "pipe": "NFC_HCI_LINK_MGMT_PIPE"
                },
                "NFC_HCI_ADMIN_GATE": {
                    "pipe": "NFC_HCI_ADMIN_PIPE"
                },
                "default": {
                    "pipe": "nfc_hci_create_pipe(hdev, dest_host, dest_gate, &r)",
                    "pipe": "!= NFC_HCI_INVALID_PIPE",
                    "pipe_created": "true"
                }
            }
        },
        "post": {
            "r": "< 0": {
                "pipe_created": "true",
                "nfc_hci_delete_pipe(hdev, pipe)": "< 0"
            }
        }
    }
},
{
    "kretprobe:nci_send_data": {
        "description": "Check if skb->len is less than or equal to conn_info->max_pkt_payload_len",
        "pre": {
            "skb->len": "<= conn_info->max_pkt_payload_len"
        }
    }
},
{
    "kprobe:if (skb->len <= conn_info->max_pkt_payload_len)": {
        "description": "Check if the packet length is less than or equal to the maximum payload length of the connection.",
        "pre": {
            "skb->len": "<= conn_info->max_pkt_payload_len"
        }
    }
},
S,
S,
{
    "kretprobe:nci_nfcc_loopback": {
        "description": "The nci_nfcc_loopback function",
        "pre": {
            "context": "!=null",
            "skb": "!=null",
            "err": "int",
            "ndev": "struct nci_dev",
            "conn_info": "!=null",
            "data": "const void",
            "data_len": "size_t",
            "resp": "struct sk_buff"
        }
    }
},
{
    "kprobe:conn_info->data_exchange_cb = nci_nfcc_loopback_cb;conn_info->data_exchange_cb_context = ndev;skb = nci_skb_alloc(ndev, NCI_DATA_HDR_SIZE + data_len, GFP_KERNEL);if (!skb)return -ENOMEM;skb_reserve(skb, NCI_DATA_HDR_SIZE);skb_put_data(skb, data, data_len);loopback_data.conn_id = conn_id;loopback_data.data = skb;ndev->cur_conn_id = conn_id;r = nci_request(ndev, nci_send_data_req, &loopback_data,msecs_to_jiffies(NCI_DATA_TIMEOUT));if (r == NCI_STATUS_OK && resp)*resp = conn_info->rx_skb;return r;}EXPORT_SYMBOL(nci_nfcc_loopback": {
        "description": "The nci_nfcc_loopback function performs a loopback operation in the NFC controller.",
        "pre": {
            "conn_info": "!=null",
            "data": "!=null",
            "data_len": ">=0",
            "ndev": "!=null",
            "skb": "!=null",
            "loopback_data.conn_id": ">=0",
            "loopback_data.data": "!=null",
            "ndev->cur_conn_id": ">=0",
            "r": "!=null",
            "resp": "!=null"
        }
    }
},
{
    "kretprobe:nci_nfcc_loopback": {
        "description": "This function is used for loopback communication with the NFCC.",
        "pre": {
            "conn_info": "!=null",
            "data": "!=null",
            "data_len": ">=0",
            "resp": "!=null"
        },
        "post": {
            "r": "in [NCI_STATUS_OK, NCI_STATUS_REJECTED]",
            "conn_info->rx_skb": "!=null"
        }
    },
    "kretprobe:nci_open_device": {
        "description": "This function is used to open an NCI device.",
        "pre": {
            "ndev": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:conn_info->data_exchange_cb = nci_nfcc_loopback_cb;conn_info->data_exchange_cb_context = ndev;skb = nci_skb_alloc(ndev, NCI_DATA_HDR_SIZE + data_len, GFP_KERNEL);if (!skb)return -ENOMEM;skb_reserve(skb, NCI_DATA_HDR_SIZE);skb_put_data(skb, data, data_len);loopback_data.conn_id = conn_id;loopback_data.data = skb;ndev->cur_conn_id = conn_id;r = nci_request(ndev, nci_send_data_req, &loopback_data,msecs_to_jiffies(NCI_DATA_TIMEOUT));if (r == NCI_STATUS_OK && resp)*resp = conn_info->rx_skb;return r;}EXPORT_SYMBOL(nci_nfcc_loopback);static int nci_open_device(struct nci_dev *ndev)",
    "description": "This function is used to perform a loopback operation in the NFC controller. It sends data to the NFC controller and receives the response.",
    "pre": {
        "conn_info->data_exchange_cb": "= nci_nfcc_loopback_cb",
        "conn_info->data_exchange_cb_context": "= ndev",
        "skb": "!= null",
        "data_len": ">= 0",
        "loopback_data.conn_id": ">= 0",
        "loopback_data.data": "!= null",
        "ndev->cur_conn_id": "= conn_id",
        "r": "= nci_request(ndev, nci_send_data_req, &loopback_data, msecs_to_jiffies(NCI_DATA_TIMEOUT))",
        "r == NCI_STATUS_OK && resp": "= conn_info->rx_skb"
    }
},
S,
S,
{
    "kretprobe:nci_allocate_device": {
        "description": "Allocate a new nci device",
        "pre": {
            "ops": "!=null",
            "supported_protocols": "!=null",
            "tx_headroom": "!=null",
            "tx_tailroom": "!=null"
        }
    }
},
{
    "kprobe:nci_allocate_device": {
        "description": "Allocate a new nci device",
        "pre": {
            "ops": "!=null",
            "supported_protocols": "!=null",
            "tx_headroom": "!=null",
            "tx_tailroom": "!=null"
        }
    }
},
{
    "kretprobe:nci_free_device": {
        "description": "Deallocate the nci device.",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:nci_free_device": {
        "description": "Deallocate the nci device.",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kretprobe:nci_register_device": {
        "description": "Register a nci device in the nfc subsystem",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:nci_register_device": {
        "description": "Register a nci device in the nfc subsystem",
        "pre": {
            "ndev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:nci_recv_frame": {
        "description": "Receive frame from NCI drivers",
        "pre": {
            "ndev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:nci_recv_frame": {
        "description": "Receive frame from NCI drivers",
        "pre": {
            "ndev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:skb_orphan": {
        "description": "Send a copy of the skb to the sniffer.",
        "pre": {
            "skb": "!=null",
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:skb_orphan": {
        "description": "Send a copy of the skb to the sniffer.",
        "pre": {
            "skb": "!=null",
            "ndev": "!=null"
        }
    }
},
S,
{
    "kprobe:nci_hci_connect_gate": {
        "description": "Connects a gate to a pipe in the NCI HCI device.",
        "pre": {
            "ndev->hci_dev->gate2pipe[dest_gate]": "!= NCI_HCI_INVALID_PIPE",
            "pipe": "!= NCI_HCI_INVALID_PIPE"
        }
    }
},
{
    "kretprobe:ndev->ops->hci_load_session": {
        "description": "Load a session for the HCI device.",
        "pre": {
            "ndev": "!=null",
            "ndev->ops": "!=null",
            "ndev->ops->hci_load_session": "!=null"
        },
        "post": {
            "r": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:llc_set_station_handler": {
        "description": "Ensure initialisation is complete before it's called",
        "pre": {
            "handler": "!=null",
            "initialization_complete": "==true"
        }
    }
},
{
    "kprobe:llc_set_station_handler": {
        "description": "Ensure initialisation is complete before it's called",
        "pre": {
            "handler": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:llc_mac_hdr_init": {
        "description": "Fills MAC header fields",
        "pre": {
            "skb": "!=null",
            "sa": "!=null",
            "da": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:llc_mac_hdr_init": {
        "description": "Fills MAC header fields, depending on MAC type.",
        "pre": {
            "skb": "!=null",
            "sa": "!=null",
            "da": "!=null"
        }
    }
},
{
    "kretprobe:llc_build_and_send_ui_pkt": {
        "description": "Unitdata request interface for upper layers",
        "pre": {
            "sap": "!=null",
            "skb": "!=null",
            "dmac": "!=null",
            "dsap": "!=null"
        }
    }
},
{
    "kprobe:llc_build_and_send_ui_pkt": {
        "description": "Unitdata request interface for upper layers",
        "pre": {
            "sap": "!=null",
            "skb": "!=null",
            "dmac": "!=null",
            "dsap": "!=null"
        }
    }
},
{
    "kretprobe:llc_sap_alloc": {
        "description": "Allocates and initializes sap.",
        "pre": {
            "sap": "!=null"
        }
    }
},
S,
{
    "kretprobe:llc_sap_find": {
        "description": "Searches a SAP in station",
        "pre": {
            "sap_value": "!=null"
        },
        "post": {
            "return": "sap",
            "sap": "in [null, not null]"
        }
    }
},
{
    "kprobe:llc_sap_find": {
        "description": "Searches for a SAP in the SAP list of the LLC's station based on the SAP ID.",
        "pre": {
            "sap_value": "!=null"
        }
    }
},
{
    "kretprobe:llc_sap_open": {
        "description": "Open interface to the upper layers.",
        "pre": {
            "lsap": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kprobe:llc_sap_open": {
        "description": "Open interface to the upper layers.",
        "pre": {
            "lsap": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kretprobe:llc_sap_close": {
        "description": "Close interface for upper layers.",
        "pre": {
            "sap": "!=null"
        }
    }
},
{
    "kprobe:llc_sap_close": {
        "description": "Close interface for upper layers.",
        "pre": {
            "sap": "!=null"
        }
    }
},
{
    "kretprobe:ax25_send_frame": {
        "description": "Take the default packet length for the device if zero is specified.",
        "pre": {
            "paclen": "== 0"
        }
    }
},
{
    "kprobe:ax25_send_frame": {
        "description": "Take the default packet length for the device if zero is specified.",
        "pre": {
            "paclen": "== 0"
        }
    }
},
{
    "kretprobe:ax25_ip_xmit": {
        "description": "Transmit an AX.25 packet over IP.",
        "pre": {
            "skb": "!=null",
            "skb->data": "!=null",
            "skb->dev": "!=null",
            "bp": "!=null",
            "bp[16]": "==AX25_P_IP",
            "dev": "==skb->dev",
            "ax25_dev": "!=null",
            "ax25_dev->values[AX25_VALUES_IPDEFMODE]": "!=null",
            "ip_mode": "in ['V', ' ']",
            "route": "!=null",
            "route->digipeat": "!=null",
            "route->dev": "!=null",
            "route->ip_mode": "!=null"
        }
    }
},
{
    "kprobe:ax25_ip_xmit": {
        "description": "Transmit an AX.25 packet over IP.",
        "pre": {
            "skb": "!=null",
            "src_c": "!=null",
            "dst_c": "!=null"
        }
    }
},
{
    "kretprobe:ax25cmp": {
        "description": "Compare two AX.25 addresses.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "ct": ">=0",
            "a->ax25_call[ct]": "!=null",
            "b->ax25_call[ct]": "!=null",
            "(a->ax25_call[ct] & 0x1E)": "==",
            "(b->ax25_call[ct] & 0x1E)": "=="
        }
    }
},
{
    "kprobe:return 1;ct++;}if ((a->ax25_call[ct] & 0x1E) == (b->ax25_call[ct] & 0x1E))/* SSID without control bit `": {
        "description": "Comparison of ax25_call arrays with SSID without control bit",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "ct": ">=0",
            "ct": "<6",
            "a->ax25_call[ct]": "!=null",
            "b->ax25_call[ct]": "!=null",
            "(a->ax25_call[ct] & 0x1E)": "== (b->ax25_call[ct] & 0x1E)"
        }
    }
},
{
    "kretprobe:l2cap_chan_create": {
        "description": "Create a new L2CAP channel.",
        "pre": {
            "chan->nesting": "L2CAP_NESTING_NORMAL",
            "chan_list_lock": "1",
            "chan->global_l": "!=null",
            "chan_list": "!=null",
            "chan_list_lock": "0",
            "chan->chan_timer": "!=null",
            "l2cap_chan_timeout": "!=null",
            "chan->retrans_timer": "!=null",
            "l2cap_retrans_timeout": "!=null",
            "chan->monitor_timer": "!=null",
            "l2cap_monitor_timeout": "!=null",
            "chan->ack_timer": "!=null",
            "l2cap_ack_timeout": "!=null",
            "chan->state": "BT_OPEN",
            "chan->kref.refcount": "1"
        }
    }
},
{
    "kprobe:atomic_set": {
        "description": "Set the value of the variable to the given value atomically.",
        "pre": {
            "variable": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:hci_dev_lock": {
        "description": "Lock the hci device.",
        "pre": {
            "hdev": "!=null"
        }
    },
    "kretprobe:list_empty": {
        "description": "Check if the user list is empty.",
        "pre": {
            "user->list": "empty"
        }
    }
},
{
    "kprobe:hci_dev_lock": {
        "description": "Lock the hci device.",
        "pre": {
            "hdev": "!=null"
        }
    },
    "kprobe:list_empty": {
        "description": "Check if the list is empty.",
        "pre": {
            "user->list": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:if (use_src)": {
        "description": "Condition for the if statement in the hci_get_route function",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "src_type": "!=null",
            "use_src": "!=null"
        }
    }
},
S,
{
    "kretprobe:hci_conn_security": {
        "description": "Check the security level of the HCI connection.",
        "pre": {
            "conn": "!=null",
            "sec_level": "==BT_SECURITY_SDP",
            "auth_type": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kprobe:hci_conn_security": {
        "description": "Check the security level of the HCI connection.",
        "pre": {
            "conn": "!=null",
            "sec_level": "==BT_SECURITY_SDP",
            "auth_type": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kretprobe:hci_conn_check_secure": {
        "description": "Accept if non-secure or higher security level is required",
        "pre": {
            "conn": "!=null",
            "sec_level": "!=BT_SECURITY_HIGH",
            "sec_level": "!=BT_SECURITY_FIPS"
        }
    }
},
{
    "kprobe:hci_conn_check_secure": {
        "description": "Accept if non-secure or higher security level is required",
        "pre": {
            "conn": "!=null",
            "sec_level": "not in [BT_SECURITY_HIGH, BT_SECURITY_FIPS]"
        }
    }
},
{
    "kretprobe:hci_cmd_sync_alloc": {
        "description": "Allocate a struct sk_buff for a synchronous HCI command and initialize it with the given parameters.",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "sk": "!=null"
        }
    }
},
S,
{
    "kretprobe:__hci_cmd_sync_status_sk": {
        "description": "This function is used to synchronize a HCI command and its status event using a socket.",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "event": "!=null",
            "timeout": "!=null",
            "sk": "!=null",
            "skb": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kprobe:__hci_cmd_sync_status_sk": {
        "description": "__hci_cmd_sync_status_sk function",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "event": "!=null",
            "timeout": "!=null",
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:__hci_cmd_sync_status": {
        "description": "Synchronize the status of a HCI command with a socket.",
        "pre": {
            "skb": "!=null",
            "status": "!=null"
        },
        "post": {
            "skb": "==null",
            "status": "==skb->data[0]"
        }
    }
},
{
    "kprobe:__hci_cmd_sync_status": {
        "description": "Function to synchronize HCI command status",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "event": "!=null",
            "timeout": "!=null",
            "sk": "!=null",
            "skb": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kretprobe:if (hdev->discovery.type == DISCOV_TYPE_LE)goto discov_stopped;if (hdev->discovery.type != DISCOV_TYPE_INTERLEAVED)goto _return;if (test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks))": {
        "description": "Condition for the given function",
        "pre": {
            "hdev->discovery.type": "== DISCOV_TYPE_LE",
            "hdev->discovery.type": "!= DISCOV_TYPE_INTERLEAVED",
            "test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks)": "== true"
        }
    }
},
{
    "function_name": {
        "description": "Description of the function",
        "pre": {
            "condition_1": "hdev->discovery.type == DISCOV_TYPE_LE",
            "condition_2": "hdev->discovery.type != DISCOV_TYPE_INTERLEAVED",
            "condition_3": "test_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks)"
        }
    }
},
{
    "kretprobe:hci_devcd_timeout": {
        "description": "Reports the available dump data.",
        "pre": {
            "hdev->dump.state": "==HCI_DEVCOREDUMP_TIMEOUT"
        }
    }
},
{
    "kprobe:hci_devcd_timeout": {
        "description": "Report the available dump data.",
        "pre": {
            "hdev->dump.state": "==HCI_DEVCOREDUMP_TIMEOUT"
        }
    }
},
S,
S,
{
    "kretprobe:sock_hold": {
        "description": "Increment the reference count of the socket.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kretprobe:lock_sock": {
        "description": "Lock the socket.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kretprobe:bt_accept_unlink": {
        "description": "Check if the socket has already been unlinked via bt_accept_unlink.",
        "pre": {
            "sk": "!=null",
            "bt_sk(parent)->accept_q": "contains sk"
        }
    },
    "kretprobe:sock_kill": {
        "description": "Kill the socket.",
        "pre": {
            "sk": "!=null"
        }
    }
},
S,
{
    "kretprobe:skb->len -= chunk;skb->data_len -= chunk;__skb_pull(frag, chunk);break;} else if (frag->len)": {
        "description": "Decrease the length of skb and data_len by chunk and pull data from frag.",
        "pre": {
            "skb": {
                "len": ">= chunk",
                "data_len": ">= chunk"
            },
            "frag": {
                "len": "> 0"
            }
        }
    }
},
S,
{
    "kretprobe:hci_alloc_dev_priv": {
        "description": "Allocate memory for `hdev` structure and return a pointer to it.",
        "pre": {
            "sizeof_priv": "==0",
            "alloc_size": "sizeof(hdev)"
        }
    }
},
S,
{
    "kretprobe:put_device": {
        "description": "Free the hdev structure via device release.",
        "pre": {
            "hdev": "!=null",
            "hdev->dev": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:BUG_ON(!list_empty(&hdev->mgmt_pending));hci_sock_dev_event(hdev, HCI_DEV_UNREG);if (hdev->rfkill)": {
        "description": "Unregister a Bluetooth HCI device.",
        "pre": {
            "hdev": "!=null",
            "hdev->name": "!=null",
            "hdev->bus": "!=null",
            "hdev->unregister_lock": "!=null",
            "hdev->list": "!=null",
            "hdev->power_on": "!=null",
            "hdev->flags": "!=null",
            "HCI_INIT": "!=null",
            "HCI_SETUP": "!=null",
            "HCI_CONFIG": "!=null"
        }
    }
},
{
    "kprobe:BUG_ON(!list_empty(&hdev->mgmt_pending));hci_sock_dev_event(hdev, HCI_DEV_UNREG);if (hdev->rfkill)": {
        "description": "Unregister a Bluetooth HCI device.",
        "pre": {
            "hdev": "!=null",
            "hdev->mgmt_pending": "empty",
            "hdev->rfkill": "!=null"
        }
    }
},
{
    "kretprobe:hci_dev_put": {
        "description": "Release HCI device.",
        "pre": {
            "hdev": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:hci_find_adv_instance": {
        "description": "Find the advertising instance associated with the given HCI device and instance number.",
        "pre": {
            "hdev": "!=null",
            "instance": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:hci_find_adv_instance": {
        "description": "Find the advertising instance associated with the given HCI device and instance number.",
        "pre": {
            "hdev": "!=null",
            "instance": "!=null"
        }
    }
},
{
    "kretprobe:hci_recv_frame": {
        "description": "Receive frame from HCI drivers",
        "pre": {
            "hdev": "!=null",
            "skb": "!=null"
        }
    }
},
S,
{
    "kretprobe:hci_skb_pkt_type": {
        "description": "Check if the packet type of an HCI socket buffer is HCI_DIAG_PKT with a time stamp.",
        "pre": {
            "skb": "!=null",
            "hci_skb_pkt_type(skb)": "=HCI_DIAG_PKT",
            "time_stamp(skb)": "!=null"
        }
    }
},
{
    "kprobe:hci_skb_pkt_type": {
        "description": "Check if the packet type of the HCI socket buffer is HCI_DIAG_PKT.",
        "pre": {
            "skb": "!=null",
            "hci_skb_pkt_type(skb)": "HCI_DIAG_PKT"
        }
    }
},
{
    "kretprobe:bt_dev_err": {
        "description": "Prints an error message and returns -EINVAL.",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "skb": "=null"
        }
    }
},
{
    "kprobe:bt_dev_err": {
        "description": "Print an error message and return -EINVAL.",
        "pre": {
            "hdev": "!=null",
            "opcode": "!=null",
            "plen": "!=null",
            "param": "!=null",
            "skb": "=null"
        }
    }
},
{
    "kretprobe:ethtool_virtdev_set_link_ksettings": {
        "description": "Set the link settings for a virtual device.",
        "pre": {
            "!ethtool_validate_speed(speed)": true,
            "!ethtool_validate_duplex(duplex)": true,
            "!ethtool_virtdev_validate_cmd(cmd)": true
        },
        "post": {
            "*dev_speed": "speed",
            "*dev_duplex": "duplex"
        }
    }
},
{
    "kprobe:ethtool_virtdev_set_link_ksettings": {
        "description": "Set the link settings for a virtual device using ethtool.",
        "pre": {
            "!ethtool_validate_speed(speed)": true,
            "!ethtool_validate_duplex(duplex)": true,
            "!ethtool_virtdev_validate_cmd(cmd)": true
        },
        "post": {
            "*dev_speed": "speed",
            "*dev_duplex": "duplex"
        },
        "return": 0
    }
},
{
    "kretprobe:flow->rule = flow_rule_alloc(1);if (!flow->rule)": {
        "description": "Allocate memory for 'flow->rule' and check if allocation was successful.",
        "pre": {
            "flow": {
                "rule": "==null"
            }
        }
    }
},
{
    "kprobe:flow->rule = flow_rule_alloc(1);if (!flow->rule)": {
        "description": "Allocate memory for 'flow->rule' and check if allocation was successful.",
        "pre": {
            "flow": {
                "rule": "==null"
            }
        }
    }
},
{
    "kretprobe:ethnl_default_notify": {
        "description": "Default notification handler",
        "pre": {
            "req_info.dev": "!=null",
            "ops->set_ntf_cmd": "!=null",
            "ret": "=0",
            "ethnl_ops_complete(req_info.dev)": "called",
            "rtnl_unlock()": "called",
            "ethnl_parse_header_dev_put(&req_info)": "called"
        }
    }
},
{
    "kprobe:ethnl_default_notify": {
        "description": "default notification handler",
        "pre": {
            "dev": "!=null",
            "cmd": ">=0",
            "data": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:iucv_path_sever": {
        "description": "iucv_path_sever called from tasklet.",
        "pre": {},
        "post": {
            "iucv_active_cpu": "== -1"
        }
    }
},
S,
S,
S,
{
    "kretprobe:iucv_message_receive_iprmdata": {
        "description": "__iucv_message_receive to receive RMDATA data stored in struct iucv_message.",
        "pre": {
            "path": "!=null",
            "msg": "!=null",
            "flags": "any",
            "buffer": "!=null",
            "size": ">0",
            "residual": "valid_pointer"
        }
    }
},
{
    "kprobe:iucv_message_receive_iprmdata": {
        "description": "__iucv_message_receive to receive RMDATA data stored in struct iucv_message.",
        "pre": {
            "path": "!=null",
            "msg": "!=null",
            "flags": "!=null",
            "buffer": "!=null",
            "size": "!=null",
            "residual": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:__iucv_message_send": {
        "description": "This function transmits data to another application. Data to be transmitted is in a buffer and this is a one-way message and the receiver will not reply to the message.",
        "pre": {
            "path": "!=null",
            "msg": "!=null",
            "flags": "in [IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST]",
            "srccls": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:__iucv_message_send": {
        "description": "This function transmits data to another application. Data to be transmitted is in a buffer and this is a one-way message and the receiver will not reply to the message.",
        "pre": {
            "path": "!=null",
            "msg": "!=null",
            "flags": "in [IUCV_IPRMDATA, IUCV_IPPRTY, IUCV_IPBUFLST]",
            "srccls": "!=null",
            "buffer": "!=null",
            "size": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:tcf_em_tree_validate": {
        "description": "validate ematch config TLV and build ematch tree",
        "pre": {
            "tp": "!=null",
            "nla": "!=null",
            "tree": "!=null"
        }
    }
},
{
    "kprobe:tcf_em_tree_validate": {
        "description": "Validate ematch config TLV and build ematch tree",
        "pre": {
            "tp": "!=null",
            "nla": "!=null",
            "tree": "!=null"
        }
    }
},
{
    "kretprobe:tcf_em_tree_destroy": {
        "description": "Destroy an ematch tree.",
        "pre": {
            "tree": "!=null"
        }
    }
},
{
    "kprobe:tcf_em_tree_destroy": {
        "description": "Destroy an ematch tree.",
        "pre": {
            "tree": "!=null"
        }
    }
},
{
    "kretprobe:tcf_em_tree_dump": {
        "description": "Dump ematch tree into a rtnl message",
        "pre": {
            "skb": "!=null",
            "tree": "!=null",
            "tlv": "!=null",
            "skb_tailroom": ">=0"
        },
        "post": {
            "return": "-1 if skb tailroom is insufficient"
        }
    }
},
{
    "kprobe:tcf_em_tree_dump": {
        "description": "Dump ematch tree into a rtnl message",
        "pre": {
            "skb": "!=null",
            "tree": "!=null",
            "tlv": "!=null",
            "skb_tailroom": ">=0"
        }
    }
},
{
    "kretprobe:if (strncmp(q->ops->id + 1, \"fifo\", 4) != 0)": {
        "description": "Check if the string starting at q->ops->id + 1 is not equal to \"fifo\".",
        "pre": {
            "q": "!=null",
            "q->ops": "!=null",
            "q->ops->id": "!=null",
            "strncmp(q->ops->id + 1, \"fifo\", 4)": "!= 0"
        }
    },
    "kretprobe:if (!q->ops->change)": {
        "description": "Check if q->ops->change is false.",
        "pre": {
            "q": "!=null",
            "q->ops": "!=null",
            "!q->ops->change": "true"
        }
    },
    "kretprobe:nla = kmalloc(nla_attr_size(sizeof(struct tc_fifo_qopt)), GFP_KERNEL)": {
        "description": "Allocate memory for nla using kmalloc.",
        "pre": {
            "nla": "!=null",
            "nla_attr_size(sizeof(struct tc_fifo_qopt))": "!=null",
            "GFP_KERNEL": "!=null"
        }
    }
},
{
    "kprobe:if (strncmp(q->ops->id + 1, \"fifo\", 4) != 0)return 0;if (!q->ops->change)return 0;nla = kmalloc(nla_attr_size(sizeof(struct tc_fifo_qopt)), GFP_KERNEL);if (nla)": {
        "description": "Check conditions for the given function",
        "pre": {
            "q->ops->id": "!=null",
            "q->ops->id + 1": "!=null",
            "strncmp(q->ops->id + 1, \"fifo\", 4)": "!=0",
            "q->ops->change": "!=0",
            "nla": "!=null",
            "nla_attr_size(sizeof(struct tc_fifo_qopt))": "!=null",
            "kmalloc(nla_attr_size(sizeof(struct tc_fifo_qopt)), GFP_KERNEL)": "!=null"
        }
    }
},
{
    "kretprobe:tcf_idr_release": {
        "description": "Release with strict==1 and bind==0 is only called through act API interface.",
        "pre": {
            "p": "!=null",
            "bind": "==0",
            "strict": "==1"
        }
    }
},
{
    "kprobe:if (p)": {
        "description": "Check if the condition p is true.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:return_tcf_idr_create": {
        "description": "Set cpustats according to actions flags.",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "est": "!=null",
            "a": "!=null",
            "ops": "!=null",
            "bind": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:tcf_idr_create_from_flags": {
        "description": "Set cpustats according to actions flags.",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "est": "!=null",
            "a": "!=null",
            "ops": "!=null",
            "bind": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:tcf_idr_cleanup": {
        "description": "Remove ERR_PTR(-EBUSY) allocated by tcf_idr_check_alloc",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "idrinfo": "!=null",
            "idrinfo->lock": "!=null",
            "idrinfo->action_idr": "!=null",
            "!IS_ERR(idr_remove(&idrinfo->action_idr, index))": "true",
            "mutex_unlock(&idrinfo->lock)": "true"
        }
    }
},
{
    "kprobe:tcf_idr_cleanup": {
        "description": "Remove ERR_PTR(-EBUSY) allocated by tcf_idr_check_alloc",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "idrinfo": {
                "lock": "!=null"
            }
        }
    }
},
{
    "kretprobe:tcf_idr_check_alloc": {
        "description": "Check if action with specified index exists. If actions is found, increments its reference and bind counters, and return 1. Otherwise insert temporary error pointer (to prevent concurrent users from inserting actions with same index) and return 0.",
        "pre": {
            "idrinfo": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:tcf_idr_check_alloc": {
        "description": "Check if action with specified index exists. If actions is found, increments its reference and bind counters, and return 1. Otherwise insert temporary error pointer (to prevent concurrent users from inserting actions with same index) and return 0.",
        "pre": {
            "idrinfo": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:register_pernet_subsys": {
        "description": "Register a pernet subsystem with the given operations.",
        "pre": {
            "ops": "!=null",
            "ops->id": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:register_pernet_subsys": {
        "description": "Register a pernet subsystem with the given operations.",
        "pre": {
            "ops": "!=null",
            "ret": "!=null",
            "ops->id": "!=null"
        }
    }
},
{
    "kretprobe:tcf_action_exec": {
        "description": "Matches actions per filter.",
        "pre": {
            "skb": "!=null",
            "actions": "!=null",
            "nr_actions": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kprobe:int i;int ret = TC_ACT_OK;if (skb_skip_tc_classify(skb))return TC_ACT_OK;restart_act_graph:for (i = 0; i < nr_actions; i++)": {
        "description": "Executes tcf_action_exec function with given parameters.",
        "pre": {
            "skb": "!=null",
            "actions": "!=null",
            "nr_actions": ">= 0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:tcf_idr_create": {
        "description": "Create a new tc_action and add it to the idr.",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "est": "!=null",
            "a": "!=null",
            "ops": "!=null",
            "bind": "!=null",
            "!(flags & TCA_ACT_FLAGS_NO_PERCPU_STATS)": "true",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:return_tcf_idr_create": {
        "description": "Create a new tc_action and add it to the idr.",
        "pre": {
            "tn": "!=null",
            "index": "!=null",
            "est": "!=null",
            "a": "!=null",
            "ops": "!=null",
            "bind": "!=null",
            "flags": "!=null",
            "!(flags & TCA_ACT_FLAGS_NO_PERCPU_STATS)": "true"
        }
    }
},
{
    "kretprobe:qdisc_watchdog_schedule_range_ns": {
        "description": "Schedule a watchdog timer for a network queue discipline.",
        "pre": {
            "wd": "!=null",
            "expires": "!=null",
            "delta_ns": "!=null",
            "deactivated": "in [true, false]",
            "hrtimer_is_queued(&wd->timer)": "in [true, false]",
            "softexpires": "!=null"
        },
        "post": {
            "hrtimer_start_range_ns(&wd->timer, ns_to_ktime(expires), delta_ns, HRTIMER_MODE_ABS_PINNED)": "executed"
        }
    }
},
{
    "kprobe:qdisc_watchdog_schedule_range_ns": {
        "description": "Schedule a watchdog timer for a qdisc with a given range of expiration time.",
        "pre": {
            "wd": "!=null",
            "expires": "!=null",
            "delta_ns": "!=null",
            "softexpires - expires": "<= delta_ns"
        }
    }
},
{
    "kretprobe:qdisc_class_hash_grow": {
        "description": "Rehash when load factor exceeds 0.75",
        "pre": {
            "sch": "!=null",
            "clhash": "!=null",
            "cl": "!=null",
            "next": "!=null",
            "nhash": "!=null",
            "ohash": "!=null",
            "nsize": "!=null",
            "nmask": "!=null",
            "osize": "!=null",
            "i": "!=null",
            "h": "!=null",
            "clhash->hashelems": "* 4 <= clhash->hashsize * 3",
            "nsize": "= clhash->hashsize * 2",
            "nmask": "= nsize - 1",
            "nhash": "= qdisc_class_hash_alloc(nsize)",
            "nhash": "== NULL",
            "ohash": "= clhash->hash",
            "osize": "= clhash->hashsize",
            "sch_tree_lock(sch)": "",
            "i": "< osize"
        }
    }
},
{
    "kprobe:qdisc_class_hash_grow": {
        "description": "Rehash when load factor exceeds 0.75",
        "pre": {
            "sch": "!=null",
            "clhash": "!=null",
            "cl": "!=null",
            "next": "!=null",
            "nhash": "!=null",
            "ohash": "!=null",
            "nsize": "!=null",
            "nmask": "!=null",
            "osize": "!=null",
            "i": "!=null",
            "h": "!=null",
            "clhash->hashelems": "* 4 <= clhash->hashsize * 3",
            "nsize": "= clhash->hashsize * 2",
            "nmask": "= nsize - 1",
            "nhash": "= qdisc_class_hash_alloc(nsize)",
            "nhash": "== NULL",
            "ohash": "= clhash->hash",
            "osize": "= clhash->hashsize",
            "sch": "= sch_tree_lock(sch)",
            "i": "< osize"
        }
    }
},
{
    "kretprobe:qdisc_tree_reduce_backlog": {
        "description": "Notify parent qdisc only if child qdisc becomes empty.",
        "pre": {
            "sch->q.qlen": "== 0",
            "n": "== 0",
            "qdisc_is_offloaded": "== false"
        }
    }
},
{
    "kprobe:qdisc_tree_reduce_backlog": {
        "description": "Reduce the backlog of a qdisc tree.",
        "pre": {
            "sch->q.qlen": "==0",
            "n": "==0",
            "qdisc_is_offloaded": "==false"
        }
    }
},
{
    "kretprobe:qdisc_offload_graft_helper": {
        "description": "Helper function for grafting offloaded qdiscs.",
        "pre": {
            "!err": true,
            "!new": true,
            "new": "&noop_qdisc"
        }
    }
},
{
    "kprobe:qdisc_offload_graft_helper": {
        "description": "Helper function for grafting offloaded qdiscs.",
        "pre": {
            "!err": true,
            "!new": true,
            "new": "&noop_qdisc"
        }
    }
},
S,
S,
{
    "kretprobe:tcf_get_next_chain": {
        "description": "Function to be used by all clients that want to iterate over all chains on block. It properly obtains block->lock and takes reference to chain before returning it. Users of this function must be tolerant to concurrent chain insertion/deletion or ensure that no concurrent chain modification is possible. Note that all netlink dump callbacks cannot guarantee to provide consistent dump because rtnl lock is released each time skb is filled with data and sent to user-space.",
        "pre": {
            "block": "!= null",
            "chain": "!= null",
            "block->lock": "locked",
            "tcf_chain_held_by_acts_only(chain)": "true",
            "list_is_last(&chain->list, &block->chain_list)": "true or false",
            "list_next_entry(chain, list)": "null or valid chain",
            "tcf_chain_hold(chain)": "optional",
            "mutex_unlock(&block->lock)": "optional"
        },
        "post": {
            "chain": "null or valid chain"
        }
    }
},
{
    "kprobe:tcf_get_next_chain": {
        "description": "Function to be used by all clients that want to iterate over all chains on block. It properly obtains block->lock and takes reference to chain before returning it. Users of this function must be tolerant to concurrent chain insertion/deletion or ensure that no concurrent chain modification is possible. Note that all netlink dump callbacks cannot guarantee to provide consistent dump because rtnl lock is released each time skb is filled with data and sent to user-space.",
        "pre": {
            "block": "!=null",
            "chain": "!=null"
        }
    }
},
{
    "kretprobe:tcf_get_next_proto": {
        "description": "Get the next protocol in the tcf_chain",
        "pre": {
            "chain": "!=null",
            "tp": "!=null",
            "prio": ">=0",
            "chain->filter_chain_lock": "locked",
            "tp->prio": ">=0",
            "tp->next": "!=null"
        }
    }
},
S,
{
    "kretprobe:tcf_block_refcnt_get": {
        "description": "Get the reference count of the tcf_block associated with the given net and block_index.",
        "pre": {
            "net": "!=null",
            "ei->block_index": "!=0"
        },
        "post": {
            "block": "==null"
        }
    }
},
{
    "kprobe:tcf_block_refcnt_get": {
        "description": "Get the reference count of the block associated with the given network.",
        "pre": {
            "net": "!=null",
            "ei->block_index": "!=0"
        }
    }
},
{
    "kretprobe:bool free_block = list_empty(&block->chain_list);mutex_unlock(&block->lock);if (tcf_block_shared(block))tcf_block_remove(block, block->net);if (q)tcf_block_offload_unbind(block, q, ei);if (free_block)tcf_block_destroy(block);elsetcf_block_flush_all_chains(block, rtnl_held);} else if (q)": {
        "description": "tcf_block_put(struct tcf_block  block, struct Qdisc  q,    struct tcf_block_ext_info  ei, bool rtnl_held)",
        "pre": {
            "block": "!=null",
            "q": "!=null",
            "ei": "!=null",
            "rtnl_held": "bool"
        }
    }
},
{
    "kprobe:bool free_block = list_empty(&block->chain_list);mutex_unlock(&block->lock);if (tcf_block_shared(block))tcf_block_remove(block, block->net);if (q)tcf_block_offload_unbind(block, q, ei);if (free_block)tcf_block_destroy(block);elsetcf_block_flush_all_chains(block, rtnl_held);} else if (q)": {
        "description": "tcf_block_put(struct tcf_block  block, struct Qdisc  q,    struct tcf_block_ext_info  ei, bool rtnl_held)",
        "pre": {
            "block": "!=null",
            "q": "!=null",
            "ei": "!=null",
            "rtnl_held": "bool"
        }
    }
},
{
    "kretprobe:tcf_classify": {
        "description": "Classify a packet using the tcf_proto structure.",
        "pre": {
            "skb": "!=null",
            "tp": "!=null",
            "orig_tp": "!=null",
            "res": "!=null",
            "compat_mode": "bool",
            "n": "!=null",
            "act_index": "int",
            "last_executed_chain": "u32"
        },
        "post": {
            "return": "TC_ACT_SHOT"
        }
    }
},
{
    "kprobe:tcf_classify": {
        "description": "Classify a packet using the tcf_classify function.",
        "pre": {
            "skb": "!=null",
            "tp": "!=null",
            "orig_tp": "!=null",
            "res": "!=null",
            "compat_mode": "bool",
            "n": "!=null",
            "act_index": "int",
            "last_executed_chain": "u32"
        }
    }
},
{
    "kretprobe:tcf_exts_init_ex": {
        "description": "Initialize tcf_exts structure with given parameters.",
        "pre": {
            "exts": "!=null",
            "net": "!=null",
            "action": "int",
            "police": "int",
            "tp": "struct tcf_proto",
            "handle": "u32",
            "use_action_miss": "bool"
        },
        "post": {
            "return": "int",
            "exts->net": "==net",
            "exts->actions": "==kcalloc(TCA_ACT_MAX_PRIO, sizeof(struct tc_action *), GFP_KERNEL)",
            "!exts->actions": "==null",
            "exts->action": "==action",
            "exts->police": "==police",
            "!use_action_miss": "==0",
            "err": "==tcf_exts_miss_cookie_base_alloc(exts, tp, handle)",
            "err": "goto err_miss_alloc",
            "return": "==0",
            "err_miss_alloc": "tcf_exts_destroy(exts)",
            "#ifdef CONFIG_NET_CLS_ACT": "exts->actions = NULL",
            "return": "==err"
        }
    }
},
{
    "kprobe:tcf_exts_init_ex": {
        "description": "Initialize the tcf_exts structure with the given parameters.",
        "pre": {
            "exts": "!=null",
            "net": "!=null",
            "action": "int",
            "police": "int",
            "tp": "!=null",
            "handle": "u32",
            "use_action_miss": "bool"
        }
    }
},
S,
S,
{
    "kretprobe:tc_setup_cb_destroy": {
        "description": "Destroy the tc_setup_cb for the given block, tp, type, type_data, err_stop, flags, in_hw_count, and rtnl_held.",
        "pre": {
            "block": "!=null",
            "tp": "!=null",
            "type": "in [TC_SETUP_TYPE_1, TC_SETUP_TYPE_2, TC_SETUP_TYPE_3]",
            "type_data": "!=null",
            "err_stop": "bool",
            "flags": "u32",
            "in_hw_count": "unsigned int",
            "rtnl_held": "bool",
            "take_rtnl": "bool",
            "ok_count": "int"
        },
        "post": {
            "rtnl_held": "false",
            "take_rtnl": "false",
            "block->lockeddevcnt": "!=0"
        }
    }
},
{
    "kprobe:tc_setup_cb_destroy": {
        "description": "Destroy the tc_setup_cb for the given block, tp, type, type_data, err_stop, flags, in_hw_count, and rtnl_held.",
        "pre": {
            "block": "!=null",
            "tp": "!=null",
            "type": "in [TC_SETUP_TYPE_1, TC_SETUP_TYPE_2, TC_SETUP_TYPE_3]",
            "type_data": "!=null",
            "err_stop": "bool",
            "flags": "u32",
            "in_hw_count": "unsigned int",
            "rtnl_held": "bool",
            "take_rtnl": "!READ_ONCE(block->lockeddevcnt) || rtnl_held",
            "ok_count": "int"
        }
    }
},
S,
{
    "if (block_index != qe->info.block_index)": {
        "pre": {
            "qe": "!=null",
            "block_index_attr": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:qdisc_restart": {
        "description": "Restarts the qdisc and checks if the queue is empty or throttled.",
        "pre": {
            "q": "!=null",
            "packets": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
S,
{
    "kretprobe:clear_bit": {
        "description": "Clears a specific bit in the state of the txq.",
        "pre": {
            "bit": "__QUEUE_STATE_FROZEN",
            "state": "&txq->state"
        }
    },
    "kretprobe:netif_schedule_queue": {
        "description": "Schedules the given txq for transmission.",
        "pre": {
            "txq": "!=null"
        }
    },
    "kretprobe:netif_tx_unlock": {
        "description": "Unlocks the txq on the given net_device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:clear_bit": {
        "description": "Clears the specified bit in the given variable.",
        "pre": {
            "__QUEUE_STATE_FROZEN": "== 0",
            "&txq->state": "!= null"
        }
    },
    "kprobe:netif_schedule_queue": {
        "description": "Schedules the given network interface queue for transmission.",
        "pre": {
            "txq": "!= null"
        }
    },
    "kprobe:netif_tx_unlock": {
        "description": "Unlocks the transmit queue of the specified network device.",
        "pre": {
            "dev": "!= null"
        }
    }
},
{
    "kretprobe:netif_carrier_on": {
        "description": "Set carrier for network device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netif_carrier_on": {
        "description": "Set carrier for network device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netif_carrier_off": {
        "description": "Clear carrier for network device",
        "pre": {
            "dev": "!=null",
            "dev->carrier": "==0"
        }
    }
},
{
    "kprobe:netif_carrier_off": {
        "description": "Clear carrier",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
{
    "kprobe:smp_mb__after_atomic": {
        "description": "Checking netif_xmit_frozen_or_stopped() again to make sure STATE_MISSED is set if the STATE_MISSED set by netif_tx_wake_queue()'s rescheduling of net_tx_action() is cleared by the above clear_bit().",
        "pre": {
            "q": "!=null",
            "txq": "!=null",
            "__QDISC_STATE_MISSED": "set",
            "netif_xmit_frozen_or_stopped()": "set"
        }
    }
},
S,
{
    "kprobe:qdisc_reset": {
        "description": "Reset the qdisc structure.",
        "pre": {
            "qdisc": "!=null",
            "qdisc->dev": "!=null",
            "qdisc->dev->type": "==HTB",
            "qdisc->dev->qdisc": "!=null",
            "qdisc->dev->qdisc->ops": "!=null",
            "qdisc->dev->qdisc->ops->reset": "!=null",
            "qdisc->dev->qdisc->ops->reset == qdisc_reset"
        }
    }
},
{
    "kretprobe:dev_graft_qdisc": {
        "description": "Graft a new qdisc to the dev_queue",
        "pre": {
            "dev_queue": "!=null",
            "qdisc": "!=null",
            "oqdisc": "!=null",
            "root_lock": "!=null"
        }
    }
},
{
    "kprobe:dev_graft_qdisc": {
        "description": "Graft a new qdisc to the dev_queue.",
        "pre": {
            "dev_queue": "!=null",
            "qdisc": "!=null"
        }
    }
},
{
    "kretprobe:dev_activate": {
        "description": "Activate the device",
        "pre": {
            "rtnl_dereference(dev->qdisc)": "== &noop_qdisc",
            "!netif_carrier_ok(dev)": "true"
        }
    }
},
{
    "kprobe:if (rtnl_dereference(dev->qdisc) == &noop_qdisc)attach_default_qdiscs(dev);if (!netif_carrier_ok(dev))/* Delay activation until next carrier-on event `": {
        "description": "Activate the device if necessary.",
        "pre": {
            "dev": "!=null",
            "dev->qdisc": "==&noop_qdisc",
            "!netif_carrier_ok(dev)": "true"
        }
    }
},
{
    "kretprobe:dev_deactivate_many": {
        "description": "Deactivate transmissions on several devices",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kprobe:dev_deactivate_many": {
        "description": "Deactivate transmissions on several devices",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:mq_change_real_num_tx": {
        "description": "Change the number of real transmit queues for a multi-queue qdisc.",
        "pre": {
            "sch": "!=null",
            "new_real_tx": "!=null",
            "dev": "!=null",
            "i": ">= new_real_tx",
            "qdisc": "!=null",
            "netdev_get_tx_queue(dev, i)->qdisc_sleeping": "!=null",
            "qdisc != &noop_qdisc": "true",
            "!qdisc->handle": "true"
        }
    }
},
{
    "kprobe:mq_change_real_num_tx": {
        "description": "Change the number of real transmit queues for a multi-queue qdisc.",
        "pre": {
            "sch": "!=null",
            "new_real_tx": "!=null",
            "dev": "!=null",
            "i": ">= new_real_tx",
            "qdisc": "!=null",
            "netdev_get_tx_queue(dev, i)->qdisc_sleeping": "!=null",
            "qdisc != &noop_qdisc": "true",
            "!qdisc->handle": "true"
        }
    }
},
{
    "kretprobe:psched_ratecfg_precompute__": {
        "description": "Pre-compute values for reciprocal division",
        "pre": {
            "rate": "!=null",
            "mult": "!=null",
            "shift": "!=null"
        }
    }
},
{
    "kprobe:psched_ratecfg_precompute__": {
        "description": "Pre-compute values for reciprocal division",
        "pre": {
            "rate": "!=null",
            "mult": "!=null",
            "shift": "!=null"
        }
    }
},
{
    "kretprobe:mini_qdisc_pair_swap": {
        "description": "Swap the mini_Qdisc_pair structure and the tcf_proto structure.",
        "pre": {
            "miniqp": "!=null",
            "tp_head": "!=null"
        },
        "post": {
            "miniq_old": "!=null",
            "miniq": "!=null",
            "tp_head": "==null"
        }
    }
},
{
    "kprobe:mini_qdisc_pair_swap": {
        "description": "Swap the mini_Qdisc_pair structure with the given tp_head.",
        "pre": {
            "miniqp": "!=null",
            "tp_head": "!=null"
        },
        "protected_with": "chain0->filter_chain_lock",
        "cannot_access": "chain directly because tp_head can be NULL"
    }
},
S,
S,
{
    "kretprobe:__rfkill_set_sw_state": {
        "description": "Set the software state of the rfkill device.",
        "pre": {
            "rfkill": "!=null",
            "sw": "bool",
            "hw": "bool",
            "flags": "unsigned long",
            "swprev": "bool",
            "hwprev": "bool"
        }
    },
    "kretprobe:rfkill_set_states": {
        "description": "Set the states of the rfkill device.",
        "pre": {
            "rfkill": "!=null",
            "sw": "bool",
            "hw": "bool",
            "flags": "unsigned long",
            "swprev": "bool",
            "hwprev": "bool"
        }
    }
},
{
    "kprobe:__rfkill_set_sw_state": {
        "description": "Set the software state of the rfkill device.",
        "pre": {
            "rfkill": "!=null",
            "sw": "bool",
            "hw": "bool",
            "flags": "unsigned long",
            "swprev": "bool",
            "hwprev": "bool"
        }
    },
    "kprobe:rfkill_set_states": {
        "description": "Set the software and hardware states of the rfkill device.",
        "pre": {
            "rfkill": "!=null",
            "sw": "bool",
            "hw": "bool",
            "flags": "unsigned long",
            "swprev": "bool",
            "hwprev": "bool"
        }
    }
},
{
    "kretprobe:genl_register_family": {
        "description": "Register a generic netlink family",
        "pre": {
            "family": "!=null",
            "family->ops": "!=null",
            "family->mcgrps": "!=null",
            "family->module": "!=null",
            "no_duplicate_family": "true"
        }
    }
},
{
    "kprobe:genl_register_family": {
        "description": "Register a generic netlink family",
        "pre": {
            "family": "!=null",
            "return": ">=0"
        }
    }
},
{
    "kretprobe:genl_unregister_family": {
        "description": "Unregister generic netlink family",
        "pre": {
            "family": "!=null"
        }
    }
},
{
    "kprobe:genl_unregister_family": {
        "description": "Unregister generic netlink family",
        "pre": {
            "family": "!=null"
        }
    }
},
{
    "kretprobe:genlmsg_put": {
        "description": "Add generic netlink header to netlink message",
        "pre": {
            "skb": "!=null",
            "portid": "!=null",
            "seq": "!=null",
            "family": "!=null",
            "flags": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:genlmsg_put": {
        "description": "Add generic netlink header to netlink message",
        "pre": {
            "skb": "!=null",
            "portid": "!=null",
            "seq": "!=null",
            "family": "!=null",
            "flags": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:if (!doit->policy && !dumpit->policy)return 0;hdr = ctrl_dumppolicy_prep(skb, cb);if (!hdr)return -ENOBUFS;nest_pol = nla_nest_start(skb, CTRL_ATTR_OP_POLICY);if (!nest_pol)goto err;nest_op = nla_nest_start(skb, doit->cmd);if (!nest_op)goto err;if (doit->policy)": {
        "description": "Condition for the if statement",
        "pre": {
            "doit->policy": "==false",
            "dumpit->policy": "==false"
        },
        "post": {
            "return": "0"
        }
    },
    "kretprobe:hdr = ctrl_dumppolicy_prep(skb, cb);if (!hdr)": {
        "description": "Condition for the if statement",
        "pre": {
            "hdr": "==null"
        },
        "post": {
            "return": "-ENOBUFS"
        }
    },
    "kretprobe:nest_pol = nla_nest_start(skb, CTRL_ATTR_OP_POLICY);if (!nest_pol)": {
        "description": "Condition for the if statement",
        "pre": {
            "nest_pol": "==null"
        },
        "post": {
            "goto": "err"
        }
    },
    "kretprobe:nest_op = nla_nest_start(skb, doit->cmd);if (!nest_op)": {
        "description": "Condition for the if statement",
        "pre": {
            "nest_op": "==null"
        },
        "post": {
            "goto": "err"
        }
    },
    "kretprobe:if (doit->policy)": {
        "description": "Condition for the if statement",
        "pre": {
            "doit->policy": "==true"
        }
    }
},
{
    "kprobe:genlmsg_multicast_allns": {
        "description": "Multicast a generic netlink message to all network namespaces.",
        "pre": {
            "genl_ctrl": "!=null",
            "msg": "!=null",
            "0": "0",
            "GFP_ATOMIC": "0"
        }
    },
    "kprobe:rcu_read_unlock": {
        "description": "Release the RCU read-side critical section.",
        "pre": {}
    },
    "kprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:struct ctrl_dump_policy_ctx": {
        "description": "Structure representing the context for dumping control policies.",
        "pre": {}
    },
    "kprobe:const struct genl_family rt": {
        "description": "Constant structure representing the generic netlink family.",
        "pre": {}
    },
    "kprobe:struct genl_op_iter i": {
        "description": "Structure representing the iterator for generic netlink operations.",
        "pre": {}
    },
    "kprobe:int err": {
        "description": "Integer variable to store error codes.",
        "pre": {}
    },
    "kprobe:BUILD_BUG_ON": {
        "description": "Macro to check build-time conditions.",
        "pre": {}
    },
    "kprobe:sizeof( ctx)": {
        "description": "Size of the context structure.",
        "pre": {}
    },
    "kprobe:tb[CTRL_ATTR_FAMILY_ID] && tb[CTRL_ATTR_FAMILY_NAME]": {
        "description": "Check if both CTRL_ATTR_FAMILY_ID and CTRL_ATTR_FAMILY_NAME are present.",
        "pre": {}
    },
    "kprobe:ctx->fam_id = nla_get_u16(tb[CTRL_ATTR_FAMILY_ID])": {
        "description": "Assign the value of CTRL_ATTR_FAMILY_ID to fam_id.",
        "pre": {}
    },
    "kprobe:rt = genl_family_find_byname(nla_data(tb[CTRL_ATTR_FAMILY_NAME]))": {
        "description": "Find the generic netlink family by name.",
        "pre": {}
    },
    "kprobe:ctx->fam_id = rt->id": {
        "description": "Assign the value of rt->id to fam_id.",
        "pre": {}
    },
    "kprobe:rt = genl_family_find_byid(ctx->fam_id)": {
        "description": "Find the generic netlink family by ID.",
        "pre": {}
    },
    "kprobe:ctx->single_op = true": {
        "description": "Set single_op flag to true.",
        "pre": {}
    },
    "kprobe:ctx->op = nla_get_u32(tb[CTRL_ATTR_OP])": {
        "description": "Assign the value of CTRL_ATTR_OP to op.",
        "pre": {}
    },
    "kprobe:err = genl_get_cmd_both(ctx->op, rt, &doit, &dump)": {
        "description": "Get the command information for the given operation.",
        "pre": {}
    },
    "kprobe:NL_SET_BAD_ATTR(cb->extack, tb[CTRL_ATTR_OP])": {
        "description": "Set the bad attribute error for the given operation.",
        "pre": {}
    },
    "kprobe:doit.policy": {
        "description": "Check if doit.policy is present.",
        "pre": {}
    },
    "kprobe:netlink_policy_dump_add_policy(&ctx->state, doit.policy, doit.maxattr)": {
        "description": "Add the policy to the policy dump state.",
        "pre": {}
    },
    "kprobe:dump.policy": {
        "description": "Check if dump.policy is present.",
        "pre": {}
    },
    "kprobe:netlink_policy_dump_add_policy(&ctx->state, dump.policy, dump.maxattr)": {
        "description": "Add the policy to the policy dump state.",
        "pre": {}
    },
    "kprobe:!ctx->state": {
        "description": "Check if the policy dump state is empty.",
        "pre": {}
    },
    "kprobe:ctx->dump_map = 1": {
        "description": "Set dump_map flag to 1.",
        "pre": {}
    },
    "kprobe:ctx->op_iter = kmalloc(sizeof( ctx->op_iter), GFP_KERNEL)": {
        "description": "Allocate memory for the operation iterator.",
        "pre": {}
    },
    "kprobe:genl_op_iter_init(rt, ctx->op_iter)": {
        "description": "Initialize the operation iterator.",
        "pre": {}
    },
    "kprobe:genl_op_iter_next(ctx->op_iter)": {
        "description": "Get the next operation from the iterator.",
        "pre": {}
    },
    "kprobe:i.doit.policy": {
        "description": "Check if i.doit.policy is present.",
        "pre": {}
    },
    "kprobe:netlink_policy_dump_add_policy(&ctx->state, i.doit.policy, i.doit.maxattr)": {
        "description": "Add the policy to the policy dump state.",
        "pre": {}
    },
    "kprobe:i.dumpit.policy": {
        "description": "Check if i.dumpit.policy is present.",
        "pre": {}
    },
    "kprobe:netlink_policy_dump_add_policy(&ctx->state, i.dumpit.policy, i.dumpit.maxattr)": {
        "description": "Add the policy to the policy dump state.",
        "pre": {}
    },
    "kprobe:!ctx->state": {
        "description": "Check if the policy dump state is empty.",
        "pre": {}
    },
    "kprobe:-ENODATA": {
        "description": "Return ENODATA error code.",
        "pre": {}
    },
    "kprobe:netlink_policy_dump_free(ctx->state)": {
        "description": "Free the policy dump state.",
        "pre": {}
    },
    "kprobe:kfree(ctx->op_iter)": {
        "description": "Free the memory allocated for the operation iterator.",
        "pre": {}
    },
    "kprobe:hdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq, &genl_ctrl, NLM_F_MULTI, CTRL_CMD_GETPOLICY)": {
        "description": "Prepare the generic netlink message header.",
        "pre": {}
    },
    "kprobe:nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, ctx->fam_id)": {
        "description": "Add the family ID attribute to the message.",
        "pre": {}
    },
    "kprobe:hdr = ctrl_dumppolicy_prep(skb, cb)": {
        "description": "Prepare the control policy dump message header.",
        "pre": {}
    },
    "kprobe:nla_nest_start(skb, CTRL_ATTR_OP_POLICY)": {
        "description": "Start nesting the policy attribute.",
        "pre": {}
    },
    "kprobe:nla_nest_start(skb, doit->cmd)": {
        "description": "Start nesting the command attribute.",
        "pre": {}
    },
    "kprobe:doit->policy": {
        "description": "Check if doit->policy is present.",
        "pre": {}
    }
},
{
    "kretprobe:__netlink_ns_capable": {
        "description": "General netlink message capability test",
        "pre": {
            "nsp": "!=null",
            "user_ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:__netlink_ns_capable": {
        "description": "General netlink message capability test",
        "pre": {
            "nsp": "!=null",
            "user_ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:netlink_capable": {
        "description": "Netlink global message capability test",
        "pre": {
            "skb": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:netlink_capable": {
        "description": "Netlink global message capability test",
        "pre": {
            "skb": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:netlink_net_capable": {
        "description": "Netlink network namespace message capability test",
        "pre": {
            "skb": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:netlink_net_capable": {
        "description": "Netlink network namespace message capability test",
        "pre": {
            "skb": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:skb_orphan": {
        "description": "Orphan the skb2 pointer.",
        "pre": {
            "p": "!=null",
            "p->skb2": "==null"
        }
    }
},
S,
{
    "kretprobe:netlink_set_err": {
        "description": "Report error to broadcast listeners.",
        "pre": {
            "ssk": "!=null",
            "portid": "!=null",
            "group": "!=null",
            "code": "<0"
        }
    }
},
{
    "kprobe:netlink_set_err": {
        "description": "Report error to broadcast listeners.",
        "pre": {
            "ssk": "!=null",
            "portid": "!=null",
            "group": "!=null",
            "code": "<0"
        }
    }
},
{
    "kretprobe:if (nlk->cb_running)": {
        "description": "Check if the callback is running in the netlink structure.",
        "pre": {
            "nlk": "!=null",
            "nlk->cb_running": "==true"
        }
    }
},
{
    "kprobe:__netlink_dump_start": {
        "description": "Start dumping netlink messages.",
        "pre": {
            "nlk->cb_running": "==true"
        }
    }
},
{
    "kretprobe:netlink_ack_tlv_fill": {
        "description": "This function is used to fill the TLV (Type-Length-Value) attributes for netlink acknowledgment.",
        "pre": {
            "err": "==0",
            "extack": "!=null",
            "extack->_msg": "!=null",
            "extack->cookie_len": "!=0"
        }
    }
},
{
    "kprobe:netlink_ack_tlv_fill": {
        "description": "Calculate the length of the TLV attributes to be included in the netlink acknowledgement message.",
        "pre": {
            "!err": true,
            "tlvlen": "return_value",
            "extack->bad_attr": "!=null",
            "tlvlen": "tlvlen + nla_total_size(sizeof(u32))",
            "extack->policy": "!=null",
            "tlvlen": "tlvlen + netlink_policy_dump_attr_size_estimate(extack->policy)",
            "extack->miss_type": "!=null",
            "tlvlen": "tlvlen + nla_total_size(sizeof(u32))",
            "extack->miss_nest": "!=null",
            "tlvlen": "tlvlen + nla_total_size(sizeof(u32))"
        }
    }
},
{
    "kretprobe:netlink_rcv_skb": {
        "description": "Receive a netlink message from a socket buffer.",
        "pre": {
            "skb": "!=null",
            "cb": "!=null",
            "extack": "!=null",
            "nlh": "!=null",
            "err": "int",
            "msglen": "int",
            "extack": "struct netlink_ext_ack",
            "nlh->nlmsg_len": ">= NLMSG_HDRLEN",
            "skb->len": ">= nlh->nlmsg_len"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:netlink_rcv_skb": {
        "description": "Handle netlink messages received in the kernel.",
        "pre": {
            "skb": "!=null",
            "cb": "!=null",
            "extack": "!=null",
            "nlh": "!=null",
            "err": "int",
            "msglen": "int",
            "extack": "struct netlink_ext_ack",
            "nlh->nlmsg_len": ">= NLMSG_HDRLEN",
            "skb->len": ">= nlh->nlmsg_len"
        }
    }
},
{
    "kretprobe:nlmsg_notify": {
        "description": "Send a notification netlink message",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "portid": ">=0",
            "group": ">=0",
            "report": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:nlmsg_notify": {
        "description": "Send a notification netlink message.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "portid": ">=0",
            "group": ">=0",
            "report": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:datalen = skb->len - protoff": {
        "description": "Calculate the length of the data in the skb packet.",
        "pre": {
            "skb": "!=null",
            "protoff": "!=null"
        }
    },
    "kretprobe:udph->len = htons(datalen)": {
        "description": "Update the length field of the UDP header.",
        "pre": {
            "udph": "!=null",
            "datalen": "!=null"
        }
    }
},
{
    "kprobe:datalen = skb->len - protoff;udph->len = htons(datalen);/* fix udp checksum if udp checksum was previously calculated `": {
        "description": "Update the length of the UDP packet and fix the UDP checksum if it was previously calculated.",
        "pre": {
            "skb": "!=null",
            "protoff": "!=null",
            "udph": "!=null",
            "datalen": "!=null",
            "skb->len": "!=null",
            "htons(datalen)": "!=null"
        }
    }
},
S,
{
    "kprobe:BUG_ON(ct->status & IPS_NAT_DONE_MASK);/* Change src to where master sends to `": {
        "description": "Check if the status of ct has the IPS_NAT_DONE_MASK bit set and trigger a bug if it does.",
        "pre": {
            "ct": {
                "status": "& IPS_NAT_DONE_MASK == 0"
            }
        }
    }
},
{
    "kretprobe:if (nf_ct_is_confirmed(ct))return NF_ACCEPT;WARN_ON(maniptype != NF_NAT_MANIP_SRC &&maniptype != NF_NAT_MANIP_DST);if (WARN_ON(nf_nat_initialized(ct, maniptype)))return NF_DROP;/* What we've got will look like inverse of reply. Normally * this is what is in the conntrack, except for prior * manipulations (future optimization: if num_manips == 0, * orig_tp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple) `": {
        "description": "Setup NAT info for the given nf_conn.",
        "pre": {
            "ct": "!=null",
            "range": "!=null",
            "maniptype": "in [NF_NAT_MANIP_SRC, NF_NAT_MANIP_DST]"
        },
        "post": {
            "return": "in [NF_ACCEPT, NF_DROP]"
        }
    }
},
S,
{
    "kretprobe:nf_register_queue_handler": {
        "description": "Register a queue handler for network traffic.",
        "pre": {
            "qh": "!=null"
        }
    }
},
{
    "kprobe:nf_register_queue_handler": {
        "description": "Register a queue handler for network filtering.",
        "pre": {
            "qh": "!=null",
            "nf_queue_handler": "assignableFrom(qh)"
        },
        "post": {
            "EXPORT_SYMBOL": "nf_register_queue_handler"
        }
    }
},
S,
{
    "kprobe:nf_queue": {
        "description": "Queue a packet for later reinjection into the network stack.",
        "pre": {
            "skb": "!=null",
            "state": "!=null",
            "index": ">=0",
            "verdict": ">=0"
        },
        "helper": "nf_reinject()"
    }
},
{
    "kretprobe:nf_remove_net_hook": {
        "description": "Remove a hook from blob",
        "pre": {
            "old": "!=null",
            "unreg": "!=null"
        }
    }
},
{
    "kprobe:nf_remove_net_hook": {
        "description": "Remove a hook from blob",
        "pre": {
            "oldp": "!=null",
            "unreg": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:nf_hook_slow_list": {
        "description": "Put passed packets back on main list",
        "pre": {
            "head": "!=null",
            "state": "!=null",
            "e": "!=null",
            "sublist": "!=null",
            "skb": "!=null",
            "next": "!=null",
            "ret": "!=null",
            "skb_list_del_init(skb)": "executes successfully",
            "nf_hook_slow(skb, state, e, 0)": "executes successfully",
            "list_add_tail(&skb->list, &sublist)": "executes successfully"
        }
    }
},
{
    "kprobe:list_splice": {
        "description": "Put passed packets back on main list",
        "pre": {
            "head": "!=null",
            "state": "!=null",
            "e": "!=null",
            "sublist": "!=null",
            "skb": "!=null",
            "next": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:xt_find_match": {
        "description": "Find a match in the family-independent list.",
        "pre": {
            "af": "!=NFPROTO_UNSPEC",
            "name": "!=null",
            "revision": "!=null"
        }
    }
},
{
    "kprobe:xt_find_match": {
        "description": "Find a match in the xt_match list based on the given arguments.",
        "pre": {
            "af": "!=null",
            "name": "!=null",
            "revision": "!=null"
        }
    }
},
{
    "kretprobe:xt_check_proc_name": {
        "description": "Check that name is suitable for proc file creation.",
        "pre": {
            "name": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:xt_check_proc_name": {
        "description": "Check that name is suitable for proc file creation.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "name_length": ">=0",
            "name_terminated": "==true",
            "name_special": "==false"
        }
    }
},
{
    "kretprobe:xt_check_table_hooks": {
        "description": "check hook entry points are sane",
        "pre": {
            "info": "!=null",
            "valid_hooks": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:xt_check_table_hooks": {
        "description": "Check hook entry points are sane",
        "pre": {
            "info": "!=null",
            "valid_hooks": "!=null"
        }
    }
},
{
    "kretprobe:xt_compat_check_entry_offsets": {
        "description": "Check entry offsets for compatibility",
        "pre": {
            "base": "!=null",
            "elems": "!=null",
            "target_offset": ">=0",
            "next_offset": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:xt_compat_check_entry_offsets": {
        "description": "Compatibility check for xt_entry_match structures.",
        "pre": {
            "base": "!=null",
            "elems": "!=null",
            "target_offset": ">=0",
            "next_offset": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:xt_check_entry_offsets": {
        "description": "validate arpipip6t_entry",
        "pre": {
            "base": "!=null",
            "elems": "!=null",
            "target_offset": ">=0",
            "next_offset": ">=0",
            "base to base + next_offset": "accessible",
            "well-formed entry": {
                "elems[]": "flexible array member at end of ip(6)arpt_entry struct",
                "target_offset + minlen <= next_offset": true,
                "sum of sizes of matches <= target_offset": true
            }
        }
    }
},
{
    "kprobe:xt_check_entry_offsets": {
        "description": "validate arpipip6t_entry",
        "pre": {
            "base": "!=null",
            "elems": "!=null",
            "target_offset": ">=0",
            "next_offset": ">=0",
            "target_offset + minlen": "<= next_offset",
            "sum of match sizes": "<= target_offset"
        }
    }
},
{
    "kretprobe:xt_alloc_entry_offsets": {
        "description": "Allocate array to store rule head offsets",
        "pre": {
            "size": "!=null"
        },
        "post": {
            "return_value": "in [NULL, zeroed kmalloc'd or vmalloc'd array]"
        }
    }
},
{
    "kprobe:xt_alloc_entry_offsets": {
        "description": "Allocate array to store rule head offsets",
        "pre": {
            "size": "!=null"
        },
        "post": {
            "return": "in [NULL, zeroed kmalloc'd or vmalloc'd array]"
        }
    }
},
{
    "kretprobe:xt_find_jump_offset": {
        "description": "Check if target is a valid jump offset.",
        "pre": {
            "offsets": "!=null",
            "target": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:xt_find_jump_offset": {
        "description": "Check if target is a valid jump offset.",
        "pre": {
            "offsets": "!=null",
            "target": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:WARN_ON": {
        "description": "Check if nf_ct_is_confirmed(ct) returns true.",
        "pre": {
            "ct": {
                "nf_ct_is_confirmed": "return == false"
            }
        }
    }
},
{
    "kprobe:WARN_ON(nf_ct_is_confirmed)": {
        "description": "Check if nf_ct_is_confirmed(ct) returns true and trigger a warning if it does.",
        "pre": {
            "ct": {
                "type": "struct nf_conn",
                "confirmed": "false"
            },
            "id": "enum nf_ct_ext_id",
            "gfp": "gfp_t"
        }
    }
},
S,
{
    "kprobe:nf_ct_tmpl_alloc": {
        "description": "Allocate a new connection template for the given network namespace, connection tracking zone, and flags.",
        "pre": {
            "net": "!=null",
            "zone": "!=null",
            "flags": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:dcbnl_setapp": {
        "description": "Helper function for setting application attributes.",
        "pre": {
            "app_tb[DCB_APP_ATTR_IDTYPE]": "!=null",
            "app_tb[DCB_APP_ATTR_ID]": "!=null",
            "app_tb[DCB_APP_ATTR_PRIORITY]": "!=null"
        }
    }
},
{
    "kprobe:dcbnl_setapp": {
        "description": "Set the application attributes for a network device.",
        "pre": {
            "app_tb[DCB_APP_ATTR_IDTYPE]": "!=null",
            "app_tb[DCB_APP_ATTR_ID]": "!=null",
            "app_tb[DCB_APP_ATTR_PRIORITY]": "!=null"
        }
    }
},
{
    "kretprobe:dcb_ieee_getapp_mask": {
        "description": "Retrieve the IEEE DCB application priority",
        "pre": {
            "dev": "!=null",
            "app": "!=null"
        }
    }
},
{
    "kprobe:dcb_ieee_getapp_mask": {
        "description": "Retrieve the IEEE DCB application priority",
        "pre": {
            "dev": "!=null",
            "app": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:dcbnl_getdcbx": {
        "description": "DCB configuration",
        "pre": {
            "netdev": "!=null",
            "nlh": "!=null",
            "seq": "is_uint32",
            "tb": "!=null",
            "skb": "!=null"
        }
    }
},
S,
{
    "kretprobe:dcb_getrewr_prio_pcp_mask_map": {
        "description": "For a given device, find mapping from priorities to the PCP and DEI values assigned to that priority.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kprobe:dcb_getrewr_prio_pcp_mask_map": {
        "description": "For a given device, find mapping from priorities to the PCP and DEI values assigned to that priority.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kretprobe:dcb_getrewr_prio_dscp_mask_map": {
        "description": "For a given device, find mapping from priorities to the DSCP values assigned to that priority.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kprobe:dcb_getrewr_prio_dscp_mask_map": {
        "description": "For a given device, find mapping from priorities to the DSCP values assigned to that priority.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kretprobe:dcb_ieee_getapp_prio_dscp_mask_map": {
        "description": "For a given device, find mapping from priorities to the DSCP values assigned to that priority. Initialize p_map such that each map element holds a bit mask of DSCP values configured for that priority by APP entries.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kprobe:dcb_ieee_getapp_prio_dscp_mask_map": {
        "description": "For a given device, find mapping from priorities to the DSCP values assigned to that priority. Initialize p_map such that each map element holds a bit mask of DSCP values configured for that priority by APP entries.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kretprobe:dcb_ieee_getapp_dscp_prio_mask_map": {
        "description": "For a given device, find mapping from DSCP values to the priorities assigned to that DSCP value. Initialize p_map such that each map element holds a bit mask of priorities configured for a given DSCP value by APP entries.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kprobe:voiddcb_ieee_getapp_dscp_prio_mask_map": {
        "description": "For a given device, find mapping from DSCP values to the priorities assigned to that DSCP value. Initialize p_map such that each map element holds a bit mask of priorities configured for a given DSCP value by APP entries.",
        "pre": {
            "dev": "!=null",
            "p_map": "!=null"
        }
    }
},
{
    "kretprobe:dcb_ieee_getapp_default_prio_mask": {
        "description": "For a given device, find all APP entries of the form {$PRIO, ETHERTYPE, 0} and construct a bit mask of all default priorities set by these entries.",
        "pre": {
            "dev": "!=null",
            "APP entry": {
                "form": "{$PRIO, ETHERTYPE, 0}",
                "pre": {
                    "$PRIO": "valid_priority_value",
                    "ETHERTYPE": "valid_ethertype_value"
                }
            },
            "bit mask": "valid_bit_mask_value"
        }
    }
},
{
    "kprobe:dcb_ieee_getapp_default_prio_mask": {
        "description": "For a given device, find all APP entries of the form {$PRIO, ETHERTYPE, 0} and construct a bit mask of all default priorities set by these entries.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:if (S_ISSOCK(inode->i_mode) && !(filp->f_mode & FMODE_PATH))": {
        "description": "Check if the file is a socket and does not have FMODE_PATH flag set.",
        "pre": {
            "inode": {
                "i_mode": "S_ISSOCK",
                "i_mode_constraints": "true"
            },
            "filp": {
                "f_mode": {
                    "&": {
                        "value": "FMODE_PATH",
                        "operator": "not in"
                    }
                }
            }
        }
    }
},
{
    "kprobe:if (S_ISSOCK(inode->i_mode) && !(filp->f_mode & FMODE_PATH))": {
        "description": "Check if the given file is a socket and the file mode does not have FMODE_PATH flag set.",
        "pre": {
            "inode": {
                "i_mode": "S_ISSOCK",
                "!=null": true
            },
            "filp": {
                "f_mode": {
                    "&": "FMODE_PATH",
                    "==": 0
                },
                "!=null": true
            }
        }
    }
},
{
    "kretprobe:unix_attach_fds": {
        "description": "Duplicate file references for the sake of garbage collection.",
        "pre": {
            "scm": "!=null",
            "skb": "!=null",
            "current": "!=null",
            "too_many_unix_fds(current)": "!=true"
        },
        "post": {
            "UNIXCB(skb).fp": "!=null",
            "UNIXCB(skb).fp": "!=0",
            "unix_inflight(scm->fp->user, scm->fp->fp[i])": "for i in range(scm->fp->count - 1, -1, -1)",
            "return": "==0"
        }
    }
},
{
    "kprobe:UNIXCB(skb).fp": {
        "description": "Assign the result of scm_fp_dup(scm->fp) to UNIXCB(skb).fp.",
        "pre": {
            "scm": "!=null",
            "skb": "!=null",
            "UNIXCB(skb).fp": "null",
            "scm->fp": "!=null",
            "scm_fp_dup(scm->fp)": "!=null"
        }
    },
    "kprobe:!UNIXCB(skb).fp": {
        "description": "Return -ENOMEM if UNIXCB(skb).fp is null.",
        "pre": {
            "UNIXCB(skb).fp": "null"
        }
    },
    "kprobe:for (i = scm->fp->count - 1; i >= 0; i--)": {
        "description": "Iterate over scm->fp->count from scm->fp->count - 1 to 0.",
        "pre": {
            "scm": "!=null",
            "scm->fp": "!=null",
            "scm->fp->count": ">= 0"
        }
    },
    "kprobe:unix_inflight(scm->fp->user, scm->fp->fp[i])": {
        "description": "Call unix_inflight(scm->fp->user, scm->fp->fp[i]).",
        "pre": {
            "scm": "!=null",
            "scm->fp": "!=null",
            "scm->fp->user": "!=null",
            "scm->fp->fp[i]": "!=null"
        }
    },
    "kprobe:return 0": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:EXPORT_SYMBOL(unix_attach_fds)": {
        "description": "Export the symbol unix_attach_fds.",
        "pre": {}
    }
},
S,
{
    "kprobe:/* So fscking what? fput() had been SMP-safe since the last Summer */": {
        "description": "Helper function for destructing scm in unix_destruct_scm",
        "pre": {
            "skb": "!=null",
            "UNIXCB(skb).pid": "!=null",
            "UNIXCB(skb).fp": "!=null => unix_detach_fds(&scm, skb)"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:WARN_ON": {
        "description": "Check if cr.ap_mld_addr and !cr.links[link_id].addr are both true.",
        "pre": {
            "cr.ap_mld_addr": "==true",
            "cr.links[link_id].addr": "==false"
        }
    },
    "kretprobe:BUG_ON": {
        "description": "Check if cr.links[link_id].bss->channel is null.",
        "pre": {
            "cr.links[link_id].bss->channel": "==null"
        }
    },
    "kretprobe:cr.links[link_id].bss->channel->band": {
        "description": "Check if cr.links[link_id].bss->channel->band is equal to NL80211_BAND_S1GHZ.",
        "pre": {
            "cr.links[link_id].bss->channel->band": "==NL80211_BAND_S1GHZ"
        }
    }
},
{
    "kprobe:WARN_ON": {
        "description": "Check if cr.ap_mld_addr is not null and cr.links[link_id].addr is not null.",
        "pre": {
            "cr.ap_mld_addr": "!=null",
            "cr.links[link_id].addr": "!=null"
        }
    },
    "kprobe:BUG_ON": {
        "description": "Check if cr.links[link_id].bss->channel is not null.",
        "pre": {
            "cr.links[link_id].bss->channel": "!=null"
        }
    },
    "kprobe:NL80211_BAND_S1GHZ": {
        "description": "Check if cr.links[link_id].bss->channel->band is equal to NL80211_BAND_S1GHZ.",
        "pre": {
            "cr.links[link_id].bss->channel->band": "==NL80211_BAND_S1GHZ"
        }
    }
},
{
    "kretprobe:/* Indicate the received Action frame to user space */": {
        "description": "Indicate the received Action frame to user space.",
        "pre": {
            "wdev": "!=null",
            "info": "!=null",
            "wiphy": "!=null",
            "rdev": "!=null",
            "reg": "!=null",
            "stypes": "!=null",
            "mgmt": "!=null",
            "data": "!=null",
            "data_len": "!=null",
            "result": "!=null",
            "ftype": "!=null",
            "stype": "!=null"
        }
    }
},
{
    "kprobe:/* Indicate the received Action frame to user space */": {
        "description": "Indicate the received Action frame to user space.",
        "pre": {
            "wdev": "!=null",
            "info": "!=null",
            "wiphy": "!=null",
            "rdev": "!=null",
            "reg": "!=null",
            "stypes": "!=null",
            "mgmt": "!=null",
            "data": "!=null",
            "data_len": "!=null",
            "result": "!=null",
            "ftype": "!=null",
            "stype": "!=null"
        }
    }
},
{
    "kretprobe:cfg80211_set_dfs_state": {
        "description": "Set the channel defined by chandef as unavailable if radar is detected on that channel.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null"
        }
    }
},
{
    "kprobe:cfg80211_set_dfs_state": {
        "description": "Set the DFS state for the given wireless device.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null",
            "offchan": "bool",
            "gfp": "gfp_t"
        }
    }
},
{
    "kretprobe:trace_cfg80211_cac_event": {
        "description": "cfg80211_cac_event function",
        "pre": {
            "wdev->valid_links": "==true",
            "event": "in [NL80211_RADAR_CAC_STARTED]",
            "wdev->cac_started": "==true"
        }
    }
},
{
    "kprobe:trace_cfg80211_cac_event": {
        "description": "Trace the cfg80211_cac_event function",
        "pre": {
            "wdev->valid_links": "!=null",
            "event": "in [NL80211_RADAR_CAC_STARTED]",
            "wdev->cac_started": "==true"
        }
    }
},
{
    "kretprobe:cfg80211_chandef_valid": {
        "description": "Check if the cfg80211_chan_def structure is valid.",
        "pre": {
            "chandef->chan": "!=null",
            "chandef->freq1_offset": "< 1000",
            "chandef->chan->center_freq": "!=null",
            "chandef->width": "in [NL80211_CHAN_WIDTH_5, NL80211_CHAN_WIDTH_10, NL80211_CHAN_WIDTH_20, NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_1, NL80211_CHAN_WIDTH_2, NL80211_CHAN_WIDTH_4, NL80211_CHAN_WIDTH_8, NL80211_CHAN_WIDTH_16, NL80211_CHAN_WIDTH_80P80]",
            "ieee80211_chandef_to_khz(chandef)": "== ieee80211_channel_to_khz(chandef->chan)",
            "chandef->center_freq2": "== null",
            "chandef->chan->band": "== NL80211_BAND_S1GHZ",
            "ieee80211_channel_to_khz(chandef->chan)": "== chandef->chan->center_freq",
            "ieee80211_chandef_to_khz(chandef)": "== cfg80211_chandef_to_khz(chandef)",
            "nl80211_chan_width_to_mhz(ieee80211_s1g_channel_width(chandef->chan))": ">= 0",
            "cfg80211_chandef_get_width(chandef)": ">= 0",
            "control_freq + MHZ_TO_KHZ(control_width) / 2": "<= oper_freq + MHZ_TO_KHZ(oper_width) / 2",
            "control_freq - MHZ_TO_KHZ(control_width) / 2": ">= oper_freq - MHZ_TO_KHZ(oper_width) / 2"
        }
    }
},
{
    "kprobe:cfg80211_chandef_valid": {
        "description": "Check if the given cfg80211_chan_def structure is valid.",
        "pre": {
            "chandef->chan": "!=null",
            "chandef->freq1_offset": "< 1000",
            "chandef->chan->center_freq": "!=null",
            "chandef->width": "in [NL80211_CHAN_WIDTH_5, NL80211_CHAN_WIDTH_10, NL80211_CHAN_WIDTH_20, NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_1, NL80211_CHAN_WIDTH_2, NL80211_CHAN_WIDTH_4, NL80211_CHAN_WIDTH_8, NL80211_CHAN_WIDTH_16, NL80211_CHAN_WIDTH_80P80]",
            "ieee80211_chandef_to_khz(chandef)": "== ieee80211_channel_to_khz(chandef->chan)",
            "chandef->center_freq2": "== null",
            "chandef->chan->band": "== NL80211_BAND_S1GHZ",
            "ieee80211_channel_to_khz(chandef->chan)": "== chandef->chan->center_freq",
            "ieee80211_chandef_to_khz(chandef)": "== cfg80211_chandef_to_khz(chandef)",
            "nl80211_chan_width_to_mhz(ieee80211_s1g_channel_width(chandef->chan))": ">= 0",
            "cfg80211_chandef_get_width(chandef)": ">= 0",
            "control_freq + MHZ_TO_KHZ(control_width) / 2": "<= oper_freq + MHZ_TO_KHZ(oper_width) / 2",
            "control_freq - MHZ_TO_KHZ(control_width) / 2": ">= oper_freq - MHZ_TO_KHZ(oper_width) / 2",
            "chandef->center_freq2": "== null"
        }
    }
},
{
    "kretprobe:cfg80211_chandef_identical": {
        "description": "Check if two cfg80211_chan_def structures are identical.",
        "pre": {
            "c1": "!=null",
            "c2": "!=null"
        },
        "post": {
            "return": "c1"
        }
    }
},
{
    "kprobe:cfg80211_chandef_identical": {
        "description": "Check if two cfg80211_chan_def structures are identical.",
        "pre": {
            "c1": "!=null",
            "c2": "!=null"
        }
    }
},
{
    "kretprobe:if (width > 20)prohibited_flags |= IEEE80211_CHAN_NO_OFDM;/* 5 and 10 MHz are only defined for the OFDM PHY `": {
        "description": "Check if the width is greater than 20 and update the prohibited_flags with IEEE80211_CHAN_NO_OFDM if true.",
        "pre": {
            "width": ">20",
            "prohibited_flags": "|= IEEE80211_CHAN_NO_OFDM"
        }
    }
},
{
    "kprobe:cfg80211_chandef_usable": {
        "description": "Check if the channel definition is usable.",
        "pre": {
            "width": "> 20",
            "prohibited_flags": "|= IEEE80211_CHAN_NO_OFDM"
        }
    }
},
{
    "kretprobe:cfg80211_reg_can_beacon": {
        "description": "Check if the given channel definition can be used for beaconing.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null",
            "iftype": "in [NL80211_IFTYPE_AP, NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_MESH_POINT]",
            "check_no_ir": "in [true, false]",
            "prohibited_flags": "in [IEEE80211_CHAN_DISABLED, IEEE80211_CHAN_RADAR]"
        }
    }
},
{
    "kprobe:cfg80211_reg_can_beacon": {
        "description": "Check if the given channel definition can be used for beaconing.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null",
            "iftype": "in [NL80211_IFTYPE_AP, NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_MESH_POINT]",
            "check_no_ir": "in [true, false]",
            "prohibited_flags": "in [IEEE80211_CHAN_DISABLED, IEEE80211_CHAN_RADAR]"
        }
    }
},
{
    "kretprobe:check_no_ir": {
        "description": "Check if relaxations for interfering channels are enabled and conditions are met.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null",
            "iftype": "!=null",
            "check_no_ir": "!cfg80211_ir_permissive_chan(wiphy, iftype, chandef->chan)",
            "_cfg80211_reg_can_beacon": "_cfg80211_reg_can_beacon(wiphy, chandef, iftype, check_no_ir)"
        }
    }
},
{
    "kprobe:cfg80211_reg_can_beacon_relax": {
        "description": "Under certain conditions suggested by some regulatory bodies, a GOSTA can IR on channels marked with IEEE80211_NO_IR. Set this flag only if such relaxations are not enabled and the conditions are not met.",
        "pre": {
            "wiphy": "!=null",
            "chandef": "!=null",
            "iftype": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_AP, NL80211_IFTYPE_MESH_POINT]"
        }
    }
},
S,
S,
{
    "kretprobe:cfg80211_valid_disable_subchannel_bitmap": {
        "description": "Check if the given bitmap is a valid disable subchannel bitmap for the provided channel definition.",
        "pre": {
            "bitmap": "!=null",
            "chandef": "!=null",
            "chandef->width": "in [NL80211_CHAN_WIDTH_80, NL80211_CHAN_WIDTH_160, NL80211_CHAN_WIDTH_320]",
            "chandef->center_freq1": "!=null"
        }
    }
},
{
    "kprobe:cfg80211_valid_disable_subchannel_bitmap": {
        "description": "Check if the given bitmap is a valid disable subchannel bitmap for the provided channel definition.",
        "pre": {
            "bitmap": "!=null",
            "chandef": "!=null",
            "chandef.width": "in [NL80211_CHAN_WIDTH_80, NL80211_CHAN_WIDTH_160, NL80211_CHAN_WIDTH_320]",
            "chandef.center_freq1": "!=null"
        }
    }
},
{
    "kretprobe:if (!spydata)return -EOPNOTSUPP;/* Disable spy collection while we copy the addresses. * While we copy addresses, any call to wireless_spy_update() * will NOP. This is OK, as anyway the addresses are changing. */": {
        "description": "Check if spydata is null and return -EOPNOTSUPP if true.",
        "pre": {
            "spydata": "==null"
        }
    }
},
{
    "kprobe:if (!spydata)return -EOPNOTSUPP;/* Disable spy collection while we copy the addresses. * While we copy addresses, any call to wireless_spy_update() * will NOP. This is OK, as anyway the addresses are changing. */": {
        "description": "Make sure driver is not buggy or using the old API",
        "pre": {
            "spydata": "==null"
        }
    }
},
{
    "kretprobe:iw_handler_get_spy": {
        "description": "Make sure driver is not buggy or using the old API",
        "pre": {
            "spydata": "!=null",
            "wrqu->data.length": "!=null",
            "address": "!=null"
        }
    }
},
{
    "kprobe:iw_handler_get_spy": {
        "description": "Make sure driver is not buggy or using the old API",
        "pre": {
            "spydata": "!=null",
            "wrqu": "!=null",
            "wrqu.data.length": "!=null",
            "extra": "!=null"
        }
    }
},
{
    "kretprobe:if (!spydata) return -EOPNOTSUPP;/* Just do it `": {
        "description": "Check if spydata is null and return -EOPNOTSUPP if true.",
        "pre": {
            "spydata": "==null"
        }
    }
},
{
    "kprobe:if (!spydata) return -EOPNOTSUPP;": {
        "description": "Check if spydata is null and return -EOPNOTSUPP if true.",
        "pre": {
            "spydata": "==null"
        }
    }
},
S,
S,
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spin lock and save the IRQ state.",
        "pre": {
            "info->lock": "!=null",
            "flags": "!=null",
            "info->crypt_quiesced": "==false"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Lock the spinlock and save the IRQ state. Check if crypt_quiesced is false.",
        "pre": {
            "info": "!=null",
            "crypt": "!=null"
        }
    }
},
{
    "kretprobe:id_len = non_inherit_elem->data[1];if (non_inherit_elem->datalen < 3 + id_len)": {
        "description": "Check if datalen is less than 3 + id_len",
        "pre": {
            "non_inherit_elem": "!=null",
            "non_inherit_elem->datalen": "< 3 + id_len"
        }
    },
    "kretprobe:ext_id_len = non_inherit_elem->data[2 + id_len];if (non_inherit_elem->datalen < 3 + id_len + ext_id_len)": {
        "description": "Check if datalen is less than 3 + id_len + ext_id_len",
        "pre": {
            "non_inherit_elem": "!=null",
            "non_inherit_elem->datalen": "< 3 + id_len + ext_id_len"
        }
    },
    "kretprobe:elem->id == WLAN_EID_EXTENSION": {
        "description": "Check if elem->id is WLAN_EID_EXTENSION",
        "pre": {
            "elem": "!=null",
            "elem->id": "== WLAN_EID_EXTENSION"
        }
    }
},
{
    "kprobe:id_len_check": {
        "description": "Check if the length of non_inherit_elem->data is valid for further processing.",
        "pre": {
            "non_inherit_elem": "!=null",
            "non_inherit_elem->datalen": ">= 3 + non_inherit_elem->data[1]",
            "non_inherit_elem->datalen": ">= 3 + non_inherit_elem->data[1] + non_inherit_elem->data[2 + non_inherit_elem->data[1]]",
            "elem->id": "== WLAN_EID_EXTENSION"
        }
    }
},
{
    "kretprobe:cfg80211_scan_done": {
        "description": "Function called when a scan is done.",
        "pre": {
            "rdev": "!=null",
            "send_message": "bool"
        }
    },
    "kretprobe:cfg80211_sme_scan_done": {
        "description": "Function called when a scan is done.",
        "pre": {
            "wdev": "!=null",
            "netdev": "!=null"
        }
    },
    "kretprobe:cfg80211_scan_6ghz": {
        "description": "Function called to scan the 6GHz band.",
        "pre": {
            "rdev": "!=null"
        }
    },
    "kretprobe:wdev_running": {
        "description": "Function called to check if a wireless device is running.",
        "pre": {
            "wdev": "!=null"
        }
    },
    "kretprobe:cfg80211_sme_scan_done_before_sending_events": {
        "description": "Function called before sending other events.",
        "pre": {
            "wdev": "!=null"
        }
    }
},
{
    "kprobe:cfg80211_sme_scan_done": {
        "description": "Indicates that the SME scan is done.",
        "pre": {
            "wdev->netdev": "!=null"
        }
    },
    "kprobe:NL80211_SCAN_FLAG_FLUSH": {
        "description": "Indicates that the scan request should be flushed.",
        "pre": {
            "!request->info.aborted": true,
            "request->flags & NL80211_SCAN_FLAG_FLUSH": true
        }
    }
},
{
    "kretprobe:cfg80211_sched_scan_results": {
        "description": "Function to handle scheduled scan results",
        "pre": {
            "wiphy": "!=null",
            "reqid": "!=null",
            "rdev": "!=null",
            "req": "!=null",
            "tmp": "!=null",
            "spin_lock_bh(&rdev->bss_lock)": "success",
            "__cfg80211_bss_expire(rdev, req->scan_start)": "success",
            "spin_unlock_bh(&rdev->bss_lock)": "success",
            "req->scan_start": "= jiffies",
            "nl80211_send_sched_scan(req, NL80211_CMD_SCHED_SCAN_RESULTS)": "success",
            "wiphy_unlock(&rdev->wiphy)": "success"
        }
    }
},
{
    "kprobe:spin_lock_bh": {
        "description": "Acquire a spinlock.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:__cfg80211_bss_expire": {
        "description": "Expire BSS entries.",
        "pre": {
            "rdev": "!=null",
            "req": "!=null",
            "req->scan_start": "!=null"
        }
    },
    "kprobe:spin_unlock_bh": {
        "description": "Release a spinlock.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:req->scan_start = jiffies": {
        "description": "Set req->scan_start to current jiffies.",
        "pre": {
            "req": "!=null"
        }
    },
    "kprobe:nl80211_send_sched_scan": {
        "description": "Send scheduled scan results.",
        "pre": {
            "req": "!=null",
            "req->cmd": "NL80211_CMD_SCHED_SCAN_RESULTS"
        }
    },
    "kprobe:wiphy_unlock": {
        "description": "Unlock a wireless device.",
        "pre": {
            "rdev": "!=null",
            "rdev->wiphy": "!=null"
        }
    },
    "kprobe:cfg80211_sched_scan_results": {
        "description": "Handle scheduled scan results.",
        "pre": {
            "wiphy": "!=null",
            "reqid": "!=null"
        }
    }
},
{
    "kretprobe:if (!sub && cfg80211_is_element_inherited(parent, non_inherit_elem))": {
        "description": "Copy from parent if not in subie and inherited",
        "pre": {
            "sub": "false or null",
            "parent": "unknown",
            "non_inherit_elem": "unknown"
        }
    }
},
{
    "kprobe:cfg80211_is_element_inherited": {
        "description": "Check if the element is inherited from the parent.",
        "pre": {
            "sub": "false",
            "parent": "!=null",
            "non_inherit_elem": "!=null"
        }
    }
},
{
    "kretprobe:cfg80211_get_bss": {
        "description": "Get BSS information for a given BSSID and SSID.",
        "pre": {
            "now": "> bss->ts + IEEE80211_SCAN_RESULT_EXPIRE",
            "atomic_read(&bss->hold)": "== 0",
            "is_bss(&bss->pub, bssid, ssid, ssid_len)": "== true"
        }
    }
},
{
    "kprobe:cfg80211_get_bss": {
        "description": "Get BSS information from the wireless device.",
        "pre": {
            "now": "> bss->ts + IEEE80211_SCAN_RESULT_EXPIRE",
            "atomic_read(&bss->hold)": "== 0",
            "is_bss(&bss->pub, bssid, ssid, ssid_len)": "== true"
        }
    }
},
{
    "kretprobe:next = (void *)(elem->data + elem->datalen);elem_datalen = elem->datalen;if (elem->id == WLAN_EID_EXTENSION)": {
        "description": "The given function assigns the value of (elem->data + elem->datalen) to 'next' and assigns the value of elem->datalen to 'elem_datalen'. It then checks if elem->id is equal to WLAN_EID_EXTENSION.",
        "pre": {
            "elem": "!=null",
            "elem->data": "!=null",
            "elem->datalen": "!=null",
            "elem->id": "== WLAN_EID_EXTENSION"
        }
    }
},
{
    "kprobe:next = (void *)(elem->data + elem->datalen); elem_datalen = elem->datalen; if (elem->id == WLAN_EID_EXTENSION)": {
        "description": "Assign the value of (elem->data + elem->datalen) to next. Assign the value of elem->datalen to elem_datalen. If elem->id is equal to WLAN_EID_EXTENSION, execute the following code block.",
        "pre": {
            "elem": "!=null",
            "elem->data": "!=null",
            "elem->datalen": "!=null",
            "elem->id": "== WLAN_EID_EXTENSION"
        }
    }
},
{
    "kretprobe:ieee80211_is_s1g_beacon": {
        "description": "Check if the frame control of the management frame is for an S1G beacon.",
        "pre": {
            "mgmt->frame_control": "!=null"
        }
    },
    "kretprobe:memcpy": {
        "description": "Copy the BSSID from the management frame to inform_data.",
        "pre": {
            "mgmt->bssid": "!=null",
            "inform_data.bssid": "!=null"
        }
    },
    "kretprobe:le64_to_cpu": {
        "description": "Convert the timestamp from little-endian to CPU byte order.",
        "pre": {
            "mgmt->u.probe_resp.timestamp": "!=null"
        }
    },
    "kretprobe:le16_to_cpu": {
        "description": "Convert the beacon interval from little-endian to CPU byte order.",
        "pre": {
            "mgmt->u.probe_resp.beacon_int": "!=null"
        }
    },
    "kretprobe:cfg80211_inform_single_bss_frame_data": {
        "description": "Inform the wireless core about a single BSS frame.",
        "pre": {
            "wiphy": "!=null",
            "data": "!=null",
            "mgmt": "!=null",
            "len": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "mgmt->frame_control": "is_s1g_beacon",
            "inform_data.ftype": "beacon_or_presp",
            "inform_data.bssid": "copied_from_mgmt_bssid",
            "inform_data.tsf": "le64_to_cpu(mgmt->u.probe_resp.timestamp)",
            "inform_data.beacon_interval": "le16_to_cpu(mgmt->u.probe_resp.beacon_int)"
        }
    }
},
{
    "kretprobe:cfg80211_unlink_bss": {
        "description": "Unlink a BSS entry from the list of hidden BSS entries.",
        "pre": {
            "rdev": "!=null",
            "bss": "!=null",
            "!bss->pub.hidden_beacon_bss": true
        }
    }
},
{
    "kprobe:cfg80211_unlink_bss": {
        "description": "Unlink a BSS entry from the list of hidden BSS entries.",
        "pre": {
            "rdev": "!=null",
            "bss": "!=null",
            "!bss->pub.hidden_beacon_bss": true
        }
    }
},
"pre": {
    "band_rule_found": "== false",
    "bw_fits": "== true",
    "band_rule_found": "== true",
    "bw_fits": "== true",
    "band_rule_found": "== false"
},
{
    "kprobe:freq_reg_info_regd": {
        "description": "Checks if one frequency rule was in center_freq's band.",
        "pre": {
            "center_freq": "!=null",
            "regd": "!=null",
            "bw": "!=null",
            "band_rule_found": "bool",
            "bw_fits": "bool",
            "!regd": "return ERR_PTR(-EINVAL)",
            "for (i = 0; i < regd->n_reg_rules; i++)": {
                "rr": "&regd->reg_rules[i]",
                "fr": "&rr->freq_range",
                "if (!band_rule_found)": {
                    "band_rule_found": "freq_in_rule_band(fr, center_freq)"
                },
                "bw_fits": "cfg80211_does_bw_fit_range(fr, center_freq, bw)",
                "if (band_rule_found && bw_fits)": {
                    "return rr"
                }
            },
            "if (!band_rule_found)": {
                "return ERR_PTR(-ERANGE)"
            },
            "return ERR_PTR(-EINVAL)"
        }
    }
},
{
    "kretprobe:wiphy_apply_custom_regulatory": {
        "description": "Apply custom regulatory settings to the wireless device.",
        "pre": {
            "wiphy": "!=null",
            "regd": "!=null",
            "bands_set": "==1",
            "new_regd": "!=null",
            "IS_ERR(new_regd)": "==false",
            "rtnl_lock": "called",
            "wiphy_lock": "called",
            "tmp": "!=null",
            "rcu_assign_pointer(wiphy->regd, new_regd)": "called",
            "rcu_free_regdom(tmp)": "called",
            "wiphy_unlock": "called",
            "rtnl_unlock": "called"
        }
    }
},
{
    "kprobe:wiphy_apply_custom_regulatory": {
        "description": "Apply custom regulatory settings to the wireless device.",
        "pre": {
            "wiphy": "!=null",
            "regd": "!=null",
            "wiphy->regulatory_flags": "& REGULATORY_CUSTOM_REG != 0",
            "for (band = 0; band < NUM_NL80211_BANDS; band++)": {
                "if (!wiphy->bands[band])": "continue",
                "else": {
                    "handle_band_custom(wiphy, wiphy->bands[band], regd)": "",
                    "bands_set": "++"
                }
            }
        }
    }
},
{
    "kretprobe:regulatory_hint_user": {
        "description": "User hints",
        "pre": {
            "alpha2": "!=null",
            "user_reg_hint_type": "in [NL80211_USER_REG_HINT_USER, NL80211_USER_REG_HINT_CELL_BASE]"
        }
    }
},
S,
S,
{
    "kprobe:reg_process_self_managed_hint": {
        "description": "Process self-managed hint for regulatory domain.",
        "pre": {
            "wiphy": "!=null",
            "rd": "!=null"
        }
    }
},
{
    "kretprobe:atomic_dec": {
        "description": "Decrements the value of the atomic variable *wiphy_counter*.",
        "pre": {
            "wiphy_counter": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Frees the memory allocated for *rdev*.",
        "pre": {
            "rdev": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Returns NULL.",
        "pre": {}
    }
},
{
    "kprobe:atomic_dec": {
        "description": "Decrements the value of the variable pointed to by wiphy_counter.",
        "pre": {
            "&wiphy_counter": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Frees the memory allocated for the rdev variable.",
        "pre": {
            "rdev": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Returns NULL.",
        "pre": {}
    }
},
S,
S,
     {
         "debugfs_remove_recursive": {
             "description": "Remove debugfs directory recursively",
             "pre": {
                 "rdev": "!=null",
                 "rdev->wiphy.debugfsdir": "!=null"
             }
         }
     }
     ```

2. `list_del_rcu(&rdev->list)`
   - The `list_del_rcu` function deletes an entry from a list in a read-copy-update (RCU) safe manner.
   - The condition for this function can be:
     ```json
     {
         "list_del_rcu": {
             "description": "Delete entry from list in RCU safe manner",
             "pre": {
                 "rdev": "!=null",
                 "rdev->list": "!=null"
             }
         }
     }
     ```

3. `synchronize_rcu()`
   - The `synchronize_rcu` function waits for all RCU read-side critical sections to complete.
   - There are no specific conditions for this function.

4. `wiphy_unregister(&rdev->wiphy)`
   - The `wiphy_unregister` function unregisters a wireless device.
   - The condition for this function can be:
     ```json
     {
         "wiphy_unregister": {
             "description": "Unregister wireless device",
             "pre": {
                 "rdev": "!=null",
                 "&rdev->wiphy": "!=null"
             }
         }
     }
     ```

5. `return res;`
   - There are no specific conditions for this return statement.

6. `return 0;`
   - There are no specific conditions for this return statement.

7. `wiphy_rfkill_start_polling(struct wiphy wiphy)`
   - The `wiphy_rfkill_start_polling` function starts polling for RF kill events on a wireless device.
   - The condition for this function can be:
     ```json
     {
         "wiphy_rfkill_start_polling": {
             "description": "Start polling for RF kill events",
             "pre": {
                 "wiphy": "!=null"
             }
         }
     }
     ```

8. `cfg80211_process_wiphy_works(struct cfg80211_registered_device rdev)`
   - The `cfg80211_process_wiphy_works` function processes pending works for a wireless device.
   - The condition for this function can be:
     ```json
     {
         "cfg80211_process_wiphy_works": {
             "description": "Process pending works for wireless device",
             "pre": {
                 "rdev": "!=null"
             }
         }
     }
     ```

9. `void wiphy_unregister(struct wiphy wiphy)`
   - The `wiphy_unregister` function unregisters a wireless device.
   - The condition for this function can be:
     ```json
     {
         "wiphy_unregister": {
             "description": "Unregister wireless device",
             "pre": {
                 "wiphy": "!=null"
             }
         }
     }
     ```

10. `wait_event(rdev->dev_wait, ({int __count;wiphy_lock(&rdev->wiphy);__count = rdev->opencount;wiphy_unlock(&rdev->wiphy);__count == 0; }))`
    - The `wait_event` macro waits until a condition is true.
    - The condition for this macro can be:
      ```json
      {
          "wait_event": {
              "description": "Wait until condition is true",
              "pre": {
                  "rdev": "!=null",
                  "rdev->dev_wait": "!=null",
                  "rdev->wiphy": "!=null",
                  "rdev->opencount": "==0"
              }
          }
      }
      ```

11. `if (rdev->wiphy.rfkill)`
    - There are no specific conditions for this if statement.

12. `rfkill_unregister(rdev->wiphy.rfkill)`
    - The `rfkill_unregister` function unregisters an RF kill switch.
    - The condition for this function can be:
      ```json
      {
          "rfkill_unregister": {
              "description": "Unregister RF kill switch",
              "pre": {
                  "rdev->wiphy.rfkill": "!=null"
              }
          }
      }
      ```

13. `rtnl_lock()`
    - There are no specific conditions for this function.

14. `wiphy_lock(&rdev->wiphy)`
    - The `wiphy_lock` function locks a wireless device.
    - The condition for this function can be:
      ```json
      {
          "wiphy_lock": {
              "description": "Lock wireless device",
              "pre": {
                  "&rdev->wiphy": "!=null"
              }
          }
      }
      ```

15. `nl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY)`
    - The `nl80211_notify_wiphy` function notifies the nl80211 layer about a wireless device removal.
    - The condition for this function can be:
      ```json
      {
          "nl80211_notify_wiphy": {
              "description": "Notify nl80211 layer about wireless device removal",
              "pre": {
                  "rdev": "!=null"
              }
          }
      }
      ```

16. `rdev->wiphy.registered = false`
    - There are no specific conditions for this assignment statement.

17. `WARN_ON(!list_empty(&rdev->wiphy.wdev_list))`
    - The `WARN_ON` macro generates a warning if the condition is true.
    - The condition for this macro can be:
      ```json
      {
          "WARN_ON": {
              "description": "Generate warning if condition is true",
              "pre": {
                  "!list_empty(&rdev->wiphy.wdev_list)": "==true"
              }
          }
      }
      ```

18. `INIT_LIST_HEAD(&rdev->wiphy_work_list)`
    - There are no specific conditions for this function.

After analyzing each part of the given function, we can generate the conditions in JSON format as follows:
,
{
    "kprobe:debugfs_remove_recursive": {
        "description": "Remove the debugfs directory recursively.",
        "pre": {
            "rdev": "!=null",
            "rdev->wiphy.debugfsdir": "!=null",
            "rdev->list": "!=null"
        }
    },
    "kprobe:list_del_rcu": {
        "description": "Delete the specified entry from the list.",
        "pre": {
            "rdev": "!=null",
            "rdev->list": "!=null"
        }
    },
    "kprobe:synchronize_rcu": {
        "description": "Synchronize the RCU (Read-Copy-Update) mechanism.",
        "pre": {}
    },
    "kprobe:wiphy_unregister": {
        "description": "Unregister the wireless device.",
        "pre": {
            "wiphy": "!=null",
            "rdev": "!=null",
            "rdev->wiphy.mtx": "held",
            "rdev->opencount": "==0",
            "rdev->wiphy.rfkill": "!=null",
            "rdev->wiphy.registered": "==true",
            "rdev->wiphy.wdev_list": "empty"
        }
    },
    "kprobe:wiphy_rfkill_start_polling": {
        "description": "Start polling the RFKill state for the wireless device.",
        "pre": {
            "wiphy": "!=null",
            "rdev": "!=null",
            "rdev->ops->rfkill_poll": "!=null",
            "wiphy->rfkill": "!=null"
        }
    },
    "kprobe:cfg80211_process_wiphy_works": {
        "description": "Process the work items for the wireless device.",
        "pre": {
            "rdev": "!=null",
            "rdev->wiphy.mtx": "held",
            "rdev->wiphy_work_list": "not empty"
        }
    }
},
{
    "kretprobe:wiphy_verify_combinations": {
        "description": "Verify combinations of wireless parameters for a given wireless device.",
        "pre": {
            "rdev->wiphy.retry_short": "= 7",
            "rdev->wiphy.retry_long": "= 4",
            "rdev->wiphy.frag_threshold": "= -1",
            "rdev->wiphy.rts_threshold": "= -1",
            "rdev->wiphy.coverage_class": "= 0",
            "rdev->wiphy.max_num_csa_counters": "= 1",
            "rdev->wiphy.max_sched_scan_plans": "= 1",
            "rdev->wiphy.max_sched_scan_plan_interval": "= U32_MAX"
        }
    }
},
{
    "kprobe:rdev->wiphy.retry_short = 7;rdev->wiphy.retry_long = 4;rdev->wiphy.frag_threshold = (u32) -1;rdev->wiphy.rts_threshold = (u32) -1;rdev->wiphy.coverage_class = 0;rdev->wiphy.max_num_csa_counters = 1;rdev->wiphy.max_sched_scan_plans = 1;rdev->wiphy.max_sched_scan_plan_interval = U32_MAX;return &rdev->wiphy;}EXPORT_SYMBOL(wiphy_new_nm);static int wiphy_verify_combinations(struct wiphy *wiphy)": {
        "description": "This function initializes the wiphy parameters to IEEE 802.11 MIB default values.",
        "pre": {
            "rdev->wiphy.retry_short": "== 7",
            "rdev->wiphy.retry_long": "== 4",
            "rdev->wiphy.frag_threshold": "== (u32) -1",
            "rdev->wiphy.rts_threshold": "== (u32) -1",
            "rdev->wiphy.coverage_class": "== 0",
            "rdev->wiphy.max_num_csa_counters": "== 1",
            "rdev->wiphy.max_sched_scan_plans": "== 1",
            "rdev->wiphy.max_sched_scan_plan_interval": "== U32_MAX"
        }
    }
},
S,
{
    "kprobe:cfg80211_process_wdev_events": {
        "description": "Process wireless device events in cfg80211.",
        "pre": {
            "wdev": "!=null",
            "wdev->iftype": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_P2P_CLIENT]"
        }
    }
},
{
    "kretprobe:cfg80211_register_netdevice": {
        "description": "Register a network device with cfg80211.",
        "pre": {
            "dev": "!=null",
            "dev->ieee80211_ptr": "!=null",
            "dev->ieee80211_ptr->wiphy": "!=null",
            "wiphy_to_rdev(dev->ieee80211_ptr->wiphy)": "!=null",
            "&wiphy_to_rdev(dev->ieee80211_ptr->wiphy)->wiphy.mtx": "held",
            "ret": "int",
            "wdev->registered": "true",
            "wdev->registering": "true"
        },
        "post": {
            "ret": "int",
            "wdev->registering": "false",
            "wdev->registered": "ret == 0"
        }
    }
},
{
    "kprobe:cfg80211_register_netdevice": {
        "description": "Register a network device with cfg80211.",
        "pre": {
            "dev": "!=null",
            "dev->ieee80211_ptr": "!=null",
            "dev->ieee80211_ptr->wiphy": "!=null",
            "wiphy_to_rdev(dev->ieee80211_ptr->wiphy)": "!=null",
            "rdev": "!=null",
            "rdev->wiphy.mtx": "held",
            "ret": "int",
            "ASSERT_RTNL()": "true",
            "WARN_ON(!wdev)": "false"
        }
    }
},
{
    "kretprobe:event_len": {
        "description": "Calculate the size of the event",
        "pre": {
            "dev": "!=null",
            "cmd": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "descr": "==null",
            "extra_len": ">=0",
            "event": "!=null"
        }
    }
},
{
    "kprobe:wireless_send_event": {
        "description": "Send a wireless event.",
        "pre": {
            "dev": "!=null",
            "cmd": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        }
    }
},
S,
S,
S,
{
    "kprobe:event_len -= IW_EV_LCP_LEN": {
        "description": "Subtract IW_EV_LCP_LEN from event_len.",
        "pre": {
            "event_len": "!=null",
            "IW_EV_LCP_LEN": "!=null"
        }
    }
},
{
    "kretprobe:BUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);switch (statype)": {
        "description": "Check if NL80211_STA_FLAG_MAX is equal to 7 and perform a switch statement based on the value of statype.",
        "pre": {
            "NL80211_STA_FLAG_MAX": "== 7",
            "statype": "in [CFG80211_STA_AP_CLIENT_UNASSOC]"
        }
    }
},
{
    "kprobe:BUILD_BUG_ON": {
        "description": "Check if NL80211_STA_FLAG_MAX is equal to 7.",
        "pre": {
            "NL80211_STA_FLAG_MAX": "== 7"
        }
    },
    "kprobe:switch_statype": {
        "description": "Perform actions based on the value of statype.",
        "pre": {
            "statype": "in [CFG80211_STA_AP_CLIENT_UNASSOC]"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Set the memory block starting at skb->cb to zero, with a size of sizeof(skb->cb). Then, nest the attribute list in skb, end the generic netlink message, and check if nlhdr->nlmsg_pid is not zero.",
        "pre": {
            "skb": "!=null",
            "skb->cb": "!=null",
            "sizeof(skb->cb)": ">0",
            "data": "!=null",
            "nlhdr": "!=null",
            "nlhdr->nlmsg_pid": "!=0"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set the memory at skb->cb to zero for the given size.",
        "pre": {
            "skb": {
                "cb": "!=null"
            },
            "data": "!=null",
            "hdr": "!=null",
            "nlhdr": {
                "nlmsg_pid": "!=null"
            }
        }
    },
    "kprobe:nla_nest_end": {
        "description": "End the nested attribute list in the given skb.",
        "pre": {
            "skb": "!=null",
            "data": "!=null"
        }
    },
    "kprobe:genlmsg_end": {
        "description": "End the generic netlink message in the given skb with the given header.",
        "pre": {
            "skb": "!=null",
            "hdr": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_channel_to_freq_khz": {
        "description": "Converts the channel number to frequency in kHz for IEEE 802.11 wireless networks.",
        "pre": {
            "chan": "<= 0"
        }
    }
},
{
    "kprobe:ieee80211_channel_to_freq_khz": {
        "description": "Converts the channel number to frequency in kHz for the given band.",
        "pre": {
            "chan": "<= 0"
        }
    }
},
{
    "kretprobe:ieee80211_s1g_channel_width": {
        "description": "Extract the channel width for S1G band.",
        "pre": {
            "chan": "!=null",
            "chan->band": "==NL80211_BAND_S1GHZ"
        },
        "post": {
            "return": "in [NL80211_CHAN_WIDTH_20_NOHT, NL80211_CHAN_WIDTH_1]"
        }
    }
},
{
    "kprobe:ieee80211_s1g_channel_width": {
        "description": "Extract the channel width for S1G band.",
        "pre": {
            "chan": "!=null",
            "chan->band": "==NL80211_BAND_S1GHZ"
        }
    }
},
{
    "kretprobe:ieee80211_freq_khz_to_channel": {
        "description": "Converts the frequency in kHz to the corresponding channel number in MHz for IEEE 802.11.",
        "pre": {
            "freq": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_freq_khz_to_channel": {
        "description": "Converts the frequency in kHz to the corresponding channel number in MHz.",
        "pre": {
            "freq": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_hdrlen": {
        "description": "Calculate the length of the header based on the value of fc.",
        "pre": {
            "fc": "!=null",
            "hdrlen": "in [10, 16]"
        },
        "post": {
            "hdrlen": "10 if (fc & cpu_to_le16(0x00E0)) == cpu_to_le16(0x00C0) else 16"
        }
    }
},
{
    "kprobe:ieee80211_hdrlen": {
        "description": "Calculate the header length based on the given fc value.",
        "pre": {
            "fc": "&= 0x00E0",
            "fc": "== 0x00C0",
            "hdrlen": "== 10"
        },
        "post": {
            "hdrlen": "== 10"
        }
    }
},
S,
S,
{
    "kretprobe:memcpy": {
        "description": "Copy data from source to destination memory.",
        "pre": {
            "tmp.h_dest": "!=null",
            "ieee80211_get_DA(hdr)": "!=null",
            "ETH_ALEN": "!=null",
            "tmp.h_source": "!=null",
            "ieee80211_get_SA(hdr)": "!=null",
            "hdr->frame_control": "!=null",
            "cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)": "!=null"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source to destination memory.",
        "pre": {
            "tmp.h_dest": "!=null",
            "ieee80211_get_DA(hdr)": "!=null",
            "ETH_ALEN": "!=null",
            "tmp.h_source": "!=null",
            "ieee80211_get_SA(hdr)": "!=null",
            "hdr->frame_control": "!=null",
            "cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_amsdu_to_8023s": {
        "description": "Converts an A-MSDU frame to 802.3s format.",
        "pre": {
            "skb": "!=null",
            "list": "!=null",
            "addr": "!=null",
            "iftype": "in [NL80211_IFTYPE_MESH_POINT, ...]", // Add other valid iftypes
            "extra_headroom": ">=0",
            "check_da": "in [0, 1]",
            "check_sa": "in [0, 1]",
            "mesh_control": ">=0",
            "hlen": ">=0",
            "frame": "==null",
            "offset": ">=0",
            "remaining": ">=0",
            "hdr": {
                "eth": "!=null",
                "flags": "!=null"
            },
            "reuse_frag": "in [true, false]",
            "reuse_skb": "in [true, false]",
            "last": "in [true, false]",
            "copy_len": ">=0",
            "len": ">=0",
            "mesh_len": ">=0",
            "padding": ">=0"
        }
    }
},
{
    "kprobe:ieee80211_amsdu_to_8023s": {
        "description": "Converts an A-MSDU frame to 802.3s format.",
        "pre": {
            "skb": "!=null",
            "iftype": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_MESH_POINT]",
            "extra_headroom": ">=0",
            "mesh_control": "in [0, 1]"
        }
    }
},
{
    "kretprobe:cfg80211_classify8021d": {
        "description": "Classify the skb based on 802.1d priority.",
        "pre": {
            "skb->priority": ">= 256 && <= 263"
        }
    }
},
{
    "kprobe:cfg80211_classify8021d": {
        "description": "Classify the 802.1d priority of the skb packet.",
        "pre": {
            "skb->priority": ">= 256 && <= 263"
        }
    }
},
{
    "kretprobe:cfg80211_calculate_bitrate_ht": {
        "description": "Calculate bitrate for HT",
        "pre": {
            "rate->mcs": ">= 32",
            "rate->bw": "== RATE_INFO_BW_40",
            "modulation": "< 4",
            "modulation": "== 4",
            "rate->flags & RATE_INFO_FLAGS_SHORT_GI": "!= 0"
        }
    }
},
{
    "kprobe:cfg80211_calculate_bitrate_ht": {
        "description": "Calculate the bitrate for HT (High Throughput) mode.",
        "pre": {
            "rate->mcs": "< 32",
            "rate->bw": "== RATE_INFO_BW_40",
            "rate->flags & RATE_INFO_FLAGS_SHORT_GI": "!= 0"
        }
    }
},
{
    "kretprobe:cfg80211_get_p2p_attr": {
        "description": "Check attribute continuation into this IE",
        "pre": {
            "ies": "!=null",
            "len": ">1",
            "attr": "!=null",
            "buf": "!=null",
            "bufsize": ">0",
            "out": "buf",
            "attr_remaining": "0",
            "desired_attr": "false",
            "desired_len": "0",
            "iedatalen": "ies[1]",
            "copy": "0",
            "iedata": "ies + 2",
            "cont": "undefined",
            "WLAN_EID_VENDOR_SPECIFIC": "0",
            "WFA_OUI": "undefined",
            "P2P_subtype": "undefined"
        },
        "post": {
            "return": "undefined"
        }
    }
},
{
    "kprobe:cfg80211_get_p2p_attr": {
        "description": "Check attribute continuation into this IE",
        "pre": {
            "ies": "!=null",
            "len": ">1",
            "attr": "!=null",
            "buf": "!=null",
            "bufsize": ">0",
            "out": "buf",
            "attr_remaining": "0",
            "desired_attr": "false",
            "desired_len": "0",
            "iedatalen": "ies[1]",
            "copy": "0",
            "iedata": "ies + 2",
            "cont": "undefined",
            "WLAN_EID_VENDOR_SPECIFIC": "0",
            "EILSEQ": "undefined",
            "WFA OUI": "undefined",
            "P2P subtype": "undefined"
        }
    }
},
{
    "kretprobe:ieee80211_chandef_to_operating_class": {
        "description": "Converts the channel definition to operating class.",
        "pre": {
            "chandef": "!=null",
            "op_class": "!=null",
            "vht_opclass": "!=null",
            "freq": ">= 2412 && <= 2472",
            "chandef->width": "== NL80211_CHAN_WIDTH_40"
        }
    }
},
{
    "kprobe:ieee80211_chandef_to_operating_class": {
        "description": "Converts the channel definition to operating class.",
        "pre": {
            "chandef->width": "== NL80211_CHAN_WIDTH_40"
        }
    }
},
{
    "kretprobe:cfg80211_iter_combinations": {
        "description": "Iterate over combinations of interfaces and call the provided iterator function.",
        "pre": {
            "beacon_int": "< 10 || > 10000"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:cfg80211_iter_combinations": {
        "description": "Iterate over combinations of interfaces and call the provided function for each combination.",
        "pre": {
            "beacon_int": "< 10 || > 10000"
        }
    }
},
{
    "kretprobe:dev_alloc_skb": {
        "description": "Allocate a socket buffer of size *msg*.",
        "pre": {
            "msg": "!=null"
        }
    },
    "kretprobe:skb_put": {
        "description": "Increase the size of the socket buffer *skb* by *sizeof(*msg)*.",
        "pre": {
            "skb": "!=null",
            "sizeof(*msg)": "!=null"
        }
    }
},
{
    "kprobe:dev_alloc_skb": {
        "description": "Allocate a socket buffer (skb) of size *msg*.",
        "pre": {
            "msg": "!=null"
        }
    },
    "kprobe:skb_put": {
        "description": "Increase the size of the socket buffer (skb) by *msg*.",
        "pre": {
            "skb": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_get_vht_max_nss": {
        "description": "Find max_vht_nss for the given MCS",
        "pre": {
            "i": "in [7, 6, 5, 4, 3, 2, 1, 0]"
        }
    }
},
{
    "kprobe:ieee80211_get_vht_max_nss": {
        "description": "Find max_vht_nss for the given MCS",
        "pre": {
            "i": {
                "type": "integer",
                "initial_value": 7,
                "decrement": 1,
                "termination_condition": "i == 0"
            }
        }
    }
},
{
    "kretprobe:if ((all_iftypes & used_iftypes) != used_iftypes) goto cont;if (beacon_int_gcd)": {
        "description": "Condition for the given function",
        "pre": {
            "all_iftypes": "&= used_iftypes",
            "used_iftypes": "!= 0",
            "beacon_int_gcd": "== 1"
        }
    }
},
{
    "kprobe:if ((all_iftypes & used_iftypes) != used_iftypes) goto cont;if (beacon_int_gcd)": {
        "description": "Condition for the given function",
        "pre": {
            "all_iftypes": "&= used_iftypes",
            "used_iftypes": "!= 0",
            "beacon_int_gcd": "== 1"
        }
    }
},
{
    "kretprobe:cfg80211_roamed": {
        "description": "This function is called when a wireless device roams to a new access point.",
        "pre": {
            "wdev": "!=null",
            "info": "!=null",
            "info->valid_links": "==true",
            "info->ap_mld_addr": "!=null",
            "info->links[link].addr": "!=null",
            "info->links[link].bss": "!=null"
        }
    }
},
{
    "kprobe:cfg80211_roamed": {
        "description": "Function called when a device roams to a new access point.",
        "pre": {
            "wdev": "!=null",
            "info": "!=null",
            "info->valid_links": "==true",
            "info->ap_mld_addr": "!=null",
            "info->links[link].addr": "!=null",
            "info->links[link].bss": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:list_add_tail": {
        "description": "Add a new entry to the tail of a doubly linked list.",
        "pre": {
            "new_entry": "!=null",
            "list": "!=null"
        }
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:queue_work": {
        "description": "Queue a work item to be executed by a workqueue.",
        "pre": {
            "workqueue": "!=null",
            "work": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(cfg80211_port_authorized)": {
        "description": "Export the symbol 'cfg80211_port_authorized'.",
        "pre": {}
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "pre": {
            "lock": "&wdev->event_lock",
            "flags": "!=null"
        }
    },
    "kprobe:list_add_tail": {
        "pre": {
            "list": "&ev->list",
            "head": "&wdev->event_list"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "pre": {
            "lock": "&wdev->event_lock",
            "flags": "!=null"
        }
    },
    "kprobe:queue_work": {
        "pre": {
            "workqueue": "cfg80211_wq",
            "work": "&rdev->event_work"
        }
    },
    "EXPORT_SYMBOL": {
        "pre": {
            "symbol": "cfg80211_port_authorized"
        }
    }
},
{
    "kretprobe:if (rdev->ops->crit_proto_stop && rdev->crit_proto_nlportid)": {
        "description": "Stop critical protocol if supported.",
        "pre": {
            "rdev->ops->crit_proto_stop": "!=null",
            "rdev->crit_proto_nlportid": "!=null"
        }
    }
},
{
    "kprobe:cfg80211_disconnected": {
        "description": "Function called when a device is disconnected from the network.",
        "pre": {
            "rdev->ops->crit_proto_stop": "==true",
            "rdev->crit_proto_nlportid": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_radiotap_iterator_init": {
        "description": "Initialize a semi-opaque iterator struct for parsing radiotap arguments.",
        "pre": {
            "iterator": "!=null",
            "radiotap_header": "!=null",
            "max_length": ">=0",
            "vns": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_radiotap_iterator_init": {
        "description": "Initialize the radiotap iterator for parsing radiotap headers.",
        "pre": {
            "iterator": "!=null",
            "radiotap_header": "!=null",
            "max_length": ">=0",
            "vns": "!=null"
        }
    }
},
{
    "kretprobe:caif_disconnect_client": {
        "description": "Disconnect a client in the CAIF network stack.",
        "pre": {
            "net": "!=null",
            "adap_layer": "!=null",
            "channel_id": "u8",
            "cfg": "get_cfcnfg(net)",
            "adap_layer != NULL": "caif_assert(adap_layer)",
            "cfctrl_cancel_req(cfg->ctrl, adap_layer)": "void",
            "channel_id": "adap_layer->id",
            "channel_id != 0": "if (channel_id != 0)",
            "servl": "struct cflayer",
            "servl = cfmuxl_remove_uplayer(cfg->mux, channel_id)": "struct cflayer servl = cfmuxl_remove_uplayer(cfg->mux, channel_id)",
            "cfctrl_linkdown_req(cfg->ctrl, channel_id, adap_layer)": "cfctrl_linkdown_req(cfg->ctrl, channel_id, adap_layer)",
            "servl != NULL": "if (servl != NULL)",
            "layer_set_up(servl, NULL)": "layer_set_up(servl, NULL)",
            "pr_debug(\"nothing to disconnect\\n\")": "pr_debug(\"nothing to disconnect\\n\")",
            "synchronize_rcu()": "synchronize_rcu()",
            "adap_layer->ctrlcmd != NULL": "if (adap_layer->ctrlcmd != NULL)",
            "adap_layer->ctrlcmd(adap_layer, CAIF_CTRLCMD_DEINIT_RSP, 0)": "adap_layer->ctrlcmd(adap_layer, CAIF_CTRLCMD_DEINIT_RSP, 0)",
            "return 0": "return 0",
            "EXPORT_SYMBOL(caif_disconnect_client)": "EXPORT_SYMBOL(caif_disconnect_client)"
        }
    }
},
{
    "kprobe:synchronize_rcu": {
        "description": "Synchronize RCU before initiating cleanup.",
        "pre": {}
    },
    "kprobe:adap_layer->ctrlcmd": {
        "description": "Call the control command function of the adap_layer.",
        "pre": {
            "adap_layer": "!=null",
            "adap_layer->ctrlcmd": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:EXPORT_SYMBOL(caif_disconnect_client": {
        "description": "Export the symbol caif_disconnect_client.",
        "pre": {}
    }
},
{
    "kretprobe:cfctrl_enum_req": {
        "description": "Enumerate initially when activating physical interface.",
        "pre": {
            "cfg->ctrl": "!=null",
            "param.phyid": "!=null"
        }
    },
    "kretprobe:cfctrl_linkup_request": {
        "description": "Link up request for cfctrl.",
        "pre": {
            "cfg->ctrl": "!=null",
            "&param": "!=null",
            "adap_layer": "!=null"
        }
    },
    "kretprobe:unlock:rcu_read_unlock": {
        "description": "Unlock and release the RCU read lock.",
        "pre": {}
    },
    "kretprobe:return err": {
        "description": "Return the error code.",
        "pre": {}
    },
    "EXPORT_SYMBOL(caif_connect_client": {
        "description": "Export the caif_connect_client symbol.",
        "pre": {}
    }
},
{
    "kprobe:caif_connect_client": {
        "description": "Connects a client using the CAIF protocol.",
        "pre": {
            "net": "!=null",
            "conn_req": "!=null",
            "adap_layer": "!=null",
            "ifindex": "!=null",
            "proto_head": "!=null",
            "proto_tail": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:cffrml_refcnt_read": {
        "description": "Check if the reference count of frm_layer is not zero.",
        "pre": {
            "phyinfo": "!=null",
            "phyinfo->frm_layer": "!=null",
            "cffrml_refcnt_read(phyinfo->frm_layer)": "!=0"
        }
    }
},
{
    "kprobe:cffrml_refcnt_read": {
        "description": "Read the reference count of the frm_layer.",
        "pre": {
            "phyinfo": "!=null",
            "phyinfo->frm_layer": "!=null",
            "cffrml_refcnt_read(phyinfo->frm_layer)": "!=0"
        }
    }
},
{
    "kretprobe:skb_tailroom": {
        "description": "Check if the tailroom of the skb is less than len.",
        "pre": {
            "skb": "!=null",
            "len": "!=null",
            "skb_tailroom(skb)": "< len"
        }
    }
},
{
    "kprobe:skb_tailroom": {
        "description": "Check if the tailroom of the skb is less than len",
        "pre": {
            "skb": "!=null",
            "len": "!=null",
            "skb_tailroom(skb)": "< len"
        }
    }
},
{
    "kretprobe:xdr_truncate_encode": {
        "description": "Truncate an encode buffer",
        "pre": {
            "xdr": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:xdr_truncate_encode": {
        "description": "Truncate an encode buffer",
        "pre": {
            "xdr": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:xdr_restrict_buflen": {
        "description": "Decrease available buffer space",
        "pre": {
            "xdr": "!=null",
            "newbuflen": "!=null",
            "xdr->buf->buflen": ">= newbuflen",
            "xdr->end": "<= xdr->buf->buflen - newbuflen"
        }
    }
},
{
    "kprobe:xdr_restrict_buflen": {
        "description": "Decrease available buffer space",
        "pre": {
            "xdr": "!=null",
            "newbuflen": "!=null",
            "xdr->buf->buflen": ">=0",
            "xdr->end": "<= xdr->buf->buflen",
            "xdr->buf->buflen": ">= newbuflen"
        }
    }
},
{
    "kretprobe:gss_mech_flavor2info": {
        "description": "Look up a GSS tuple for a given pseudoflavor",
        "pre": {
            "pseudoflavor": "!=null",
            "info": "!=null"
        },
        "post": {
            "return": {
                "constraints": "in [0, -errno]",
                "description": "Returns zero and fills in 'info' if pseudoflavor matches a supported mechanism. Otherwise, a negative errno is returned."
            }
        }
    }
},
{
    "kprobe:gss_mech_flavor2info": {
        "description": "Look up a GSS tuple for a given pseudoflavor",
        "pre": {
            "pseudoflavor": "!=null",
            "info": "unknown"
        }
    }
},
S,
S,
{
    "kretprobe:buff = xp_alloc": {
        "description": "Allocate memory from the pool and assign it to 'buff'.",
        "pre": {
            "pool": "!=null"
        },
        "post": {
            "buff": "!=null"
        }
    },
    "kretprobe:*xdp = buff": {
        "description": "Assign the value of 'buff' to '*xdp'.",
        "pre": {
            "buff": "!=null"
        },
        "post": {
            "*xdp": "buff"
        }
    },
    "kretprobe:return !!buff": {
        "description": "Return the boolean value of 'buff'.",
        "pre": {
            "buff": "!=null"
        },
        "post": {
            "return": "!!buff"
        }
    }
},
S,
{
    "kretprobe:xsk_tx_peek_desc": {
        "description": "This is the backpressure mechanism for the Tx path. Reserve space in the completion queue and only proceed if there is space in it. This avoids having to implement any buffering in the Tx path.",
        "pre": {
            "pool": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kprobe:xsk_tx_peek_desc": {
        "description": "This is the backpressure mechanism for the Tx path. Reserve space in the completion queue and only proceed if there is space in it. This avoids having to implement any buffering in the Tx path.",
        "pre": {
            "pool": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kretprobe:rcu_read_unlock": {
        "description": "Release the RCU read-side critical section.",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:xsk_tx_peek_release_fallback": {
        "description": "Peek and release a batch of packets from the XDP socket transmit queue.",
        "pre": {
            "pool": "!=null",
            "nb_pkts": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:list_first_or_null_rcu": {
        "description": "Return the first element in a list or NULL if the list is empty.",
        "pre": {
            "list": "!=null",
            "type": "struct xdp_sock",
            "member": "tx_list"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rcu_read_unlock": {
        "description": "Release the RCU read-side critical section.",
        "pre": {}
    },
    "kprobe:xsk_tx_peek_release_fallback": {
        "description": "Peek and release a batch of packets from the XDP socket transmit queue.",
        "pre": {
            "pool": "!=null",
            "nb_pkts": "!=null"
        }
    },
    "kprobe:list_first_or_null_rcu": {
        "description": "Return the first element in a list or NULL if the list is empty.",
        "pre": {
            "list": "!=null",
            "type": "struct xdp_sock",
            "member": "tx_list"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:base = private->entries;i = 0;while (i < nentries)": {
        "description": "Loop through the entries in the private structure",
        "pre": {
            "base": "!=null",
            "i": 0,
            "nentries": "!=null",
            "table": "!=null",
            "hook": "!=null",
            "point": "!=null",
            "counter_base": "!=null",
            "cb_base": "!=null",
            "t": "!=null",
            "verdict": "!=null",
            "sp": 0,
            "cs": "!=null",
            "chaininfo": "!=null",
            "base": "!=null",
            "private": "!=null",
            "acpar": "!=null",
            "acpar.state": "!=null",
            "acpar.hotdrop": false
        }
    }
},
{
    "kprobe:base = private->entries;i = 0;while (i < nentries)": {
        "description": "Loop through the entries in the private structure",
        "pre": {
            "private": "!=null",
            "entries": "!=null",
            "i": ">= 0",
            "nentries": ">= 0",
            "i < nentries": "true"
        }
    }
},
{
    "kretprobe:tipc_sk_fill_sock_diag": {
        "description": "Filter response with respect to sk_state."
    }
},
{
    "kprobe:tipc_sk_fill_sock_diag": {
        "description": "Filter response with respect to sk_state.",
        "pre": {
            "skb": "!=null",
            "cb": "!=null",
            "tsk": "!=null",
            "sk_filter_state": "!=null",
            "tipc_diag_gen_cookie": "!=null",
            "sk": "!=null",
            "attrs": "!=null",
            "stat": "!=null"
        },
        "post": {
            "return": "-EMSGSIZE"
        },
        "constraints": [
            "!((sk_filter_state & (1 << sk->sk_state)))",
            "attrs = nla_nest_start_noflag(skb, TIPC_NLA_SOCK)",
            "attrs != null",
            "goto msg_cancel",
            "__tipc_nl_add_sk_info(skb, tsk)",
            "goto attr_msg_cancel",
            "nla_put_u32(skb, TIPC_NLA_SOCK_TYPE, (u32)sk->sk_type)",
            "nla_put_u32(skb, TIPC_NLA_SOCK_TIPC_STATE, (u32)sk->sk_state)",
            "nla_put_u32(skb, TIPC_NLA_SOCK_INO, sock_i_ino(sk))",
            "nla_put_u32(skb, TIPC_NLA_SOCK_UID, from_kuid_munged(sk_user_ns(NETLINK_CB(cb->skb).sk), sock_i_uid(sk)))",
            "nla_put_u64_64bit(skb, TIPC_NLA_SOCK_COOKIE, tipc_diag_gen_cookie(sk), TIPC_NLA_SOCK_PAD)",
            "goto attr_msg_cancel",
            "stat = nla_nest_start_noflag(skb, TIPC_NLA_SOCK_STAT)",
            "stat != null",
            "goto attr_msg_cancel",
            "nla_put_u32(skb, TIPC_NLA_SOCK_STAT_RCVQ, skb_queue_len(&sk->sk_receive_queue))",
            "nla_put_u32(skb, TIPC_NLA_SOCK_STAT_SENDQ, skb_queue_len(&sk->sk_write_queue))",
            "nla_put_u32(skb, TIPC_NLA_SOCK_STAT_DROP, atomic_read(&sk->sk_drops))",
            "goto stat_msg_cancel",
            "tsk->cong_link_cnt && nla_put_flag(skb, TIPC_NLA_SOCK_STAT_LINK_CONG)",
            "goto stat_msg_cancel",
            "tsk_conn_cong(tsk) && nla_put_flag(skb, TIPC_NLA_SOCK_STAT_CONN_CONG)",
            "goto stat_msg_cancel",
            "nla_nest_end(skb, stat)",
            "tsk->group && tipc_group_fill_sock_diag(tsk->group, skb)",
            "goto stat_msg_cancel",
            "nla_nest_end(skb, attrs)",
            "return 0",
            "stat_msg_cancel:nla_nest_cancel(skb, stat)",
            "attr_msg_cancel:nla_nest_cancel(skb, attrs)",
            "msg_cancel:return -EMSGSIZE"
        ]
    }
},
S,
S,
{
    "kretprobe:eth_get_headlen": {
        "description": "Determine the length of header for an ethernet frame",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:eth_get_headlen": {
        "description": "Determine the length of header for an ethernet frame.",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:__be16 eth_type_trans": {
        "description": "Determine the packet's protocol ID.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:__be16 eth_type_trans(struct sk_buff *skb, struct net_device *dev)": {
        "description": "Determine the packet's protocol ID.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:eth_header_parse": {
        "description": "Extract hardware address from packet",
        "pre": {
            "skb": "!=null",
            "haddr": "!=null"
        }
    }
},
{
    "kprobe:eth_header_parse": {
        "description": "Extract hardware address from packet",
        "pre": {
            "skb": "!=null",
            "haddr": "!=null"
        }
    }
},
{
    "kretprobe:eth_header_cache": {
        "description": "Fill cache entry from neighbour",
        "pre": {
            "neigh": "!=null",
            "hh": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:eth_header_cache": {
        "description": "Fill cache entry from neighbour",
        "pre": {
            "neigh": "!=null",
            "hh": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:eth_header_cache_update": {
        "description": "Update cache entry",
        "pre": {
            "hh": "!=null",
            "dev": "!=null",
            "haddr": "!=null"
        }
    }
},
{
    "kprobe:eth_header_cache_update": {
        "description": "Update cache entry",
        "pre": {
            "hh": "!=null",
            "dev": "!=null",
            "haddr": "!=null"
        }
    }
},
{
    "kretprobe:eth_header_parse_protocol": {
        "description": "Extract protocol from L2 header",
        "pre": {
            "skb": "!=null"
        },
        "post": {
            "return_value": "is of type __be16"
        }
    }
},
{
    "kprobe:eth_header_parse_protocol": {
        "description": "Extract protocol from L2 header",
        "pre": {
            "skb": "!=null"
        },
        "post": {
            "return_value": "valid_protocol"
        }
    }
},
{
    "kretprobe:eth_prepare_mac_addr_change": {
        "description": "Prepare for MAC address change.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:eth_prepare_mac_addr_change": {
        "description": "Prepare for MAC address change.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:eth_commit_mac_addr_change": {
        "description": "Commit mac change",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:eth_commit_mac_addr_change": {
        "description": "Commit mac change",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:eth_mac_addr": {
        "description": "Set new Ethernet hardware address",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:eth_mac_addr": {
        "description": "Set new Ethernet hardware address",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:alloc_etherdev_mqs": {
        "description": "Allocates and sets up an Ethernet device",
        "pre": {
            "sizeof_priv": ">0",
            "txqs": ">=0",
            "rxqs": ">=0"
        }
    }
},
{
    "kprobe:alloc_etherdev_mqs": {
        "description": "Allocates and sets up an Ethernet device",
        "pre": {
            "sizeof_priv": ">=0",
            "txqs": ">=0",
            "rxqs": ">=0"
        }
    }
},
{
    "kretprobe:platform_get_ethdev_address": {
        "description": "Set netdev's MAC address from a given device",
        "pre": {
            "dev": "!=null",
            "netdev": "!=null"
        }
    }
},
{
    "kprobe:platform_get_ethdev_address": {
        "description": "Set netdev's MAC address from a given device",
        "pre": {
            "dev": "!=null",
            "netdev": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_get_mac_address": {
        "description": "Get the MAC from the firmware node",
        "pre": {
            "fwnode": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:fwnode_get_mac_address": {
        "description": "Get the MAC from the firmware node",
        "pre": {
            "fwnode": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:device_get_mac_address": {
        "description": "Get the MAC for a given device",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:device_get_mac_address": {
        "description": "Get the MAC for a given device",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:device_get_ethdev_address": {
        "description": "Set netdev's MAC address from a given device",
        "pre": {
            "dev": "!=null",
            "netdev": "!=null"
        }
    }
},
{
    "kprobe:device_get_ethdev_address": {
        "description": "Set netdev's MAC address from a given device",
        "pre": {
            "dev": "!=null",
            "netdev": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_vif_is_mld": {
        "description": "Check if the given VIF is MLD (Multicast Listener Discovery) capable.",
        "pre": {
            "sdata": "!=null"
        }
    },
    "kretprobe:sdata->deflink.csa_block_tx": {
        "description": "Check if the CSA (Channel Switch Announcement) is blocking transmission on the given sdata.",
        "pre": {
            "sdata": "!=null"
        }
    },
    "kretprobe:ifmgd->driver_disconnect": {
        "description": "Check if the driver is disconnected for the given ifmgd.",
        "pre": {
            "ifmgd": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_disconnect": {
        "description": "Disconnect the IEEE 802.11 sub-interface data.",
        "pre": {
            "sdata": "!=null",
            "sdata->local": "!=null",
            "sdata->u.mgd": "!=null",
            "sdata->u.mgd->associated": "true",
            "tx": "true"
        }
    }
},
{
    "kretprobe:ieee80211_config_puncturing": {
        "description": "Check if the puncturing configuration is valid.",
        "pre": {
            "!(*changed & BSS_CHANGED_BANDWIDTH)": true,
            "extracted == link->conf->eht_puncturing": true
        }
    },
    "kretprobe:ieee80211_rx_our_beacon": {
        "description": "Check if the received beacon belongs to our BSS.",
        "pre": {
            "ether_addr_equal(tx_bssid, bss->bssid)": true,
            "!bss->transmitted_bss": false,
            "ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid)": true
        }
    },
    "kretprobe:ieee80211_cqm_rssi_notify": {
        "description": "Notify CQM about RSSI threshold events.",
        "pre": {
            "sig > thold && (last_event == 0 || sig > last_event + hyst)": true,
            "bss_conf->cqm_rssi_low && link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT": true,
            "sig < low && (last_event == 0 || last_event >= low)": true,
            "sig > high && (last_event == 0 || last_event <= high)": true
        }
    },
    "kretprobe:cfg80211_valid_disable_subchannel_bitmap": {
        "description": "Check if the disable subchannel bitmap is valid.",
        "pre": {
            "bitmap != null",
            "link->conf->chandef != null"
        }
    }
},
{
    "kprobe:ieee80211_config_puncturing": {
        "description": "Check if the puncturing configuration is valid.",
        "pre": {
            "!(*changed & BSS_CHANGED_BANDWIDTH)": true,
            "extracted == link->conf->eht_puncturing": true
        }
    },
    "kprobe:ieee80211_rx_our_beacon": {
        "description": "Check if the received beacon belongs to our BSS.",
        "pre": {
            "ether_addr_equal(tx_bssid, bss->bssid)": true,
            "!bss->transmitted_bss": false,
            "ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid)": true
        }
    },
    "kprobe:ieee80211_cqm_rssi_notify": {
        "description": "Notify CQM about RSSI threshold events.",
        "pre": {
            "sdata->vif": "!=null",
            "event": "in [NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW, NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH]",
            "sig": "!=null",
            "GFP_KERNEL": "!=null"
        }
    },
    "kprobe:cfg80211_valid_disable_subchannel_bitmap": {
        "description": "Check if the disable subchannel bitmap is valid.",
        "pre": {
            "&bitmap": "!=null",
            "&link->conf->chandef": "!=null"
        }
    },
    "kprobe:ewma_beacon_signal_read": {
        "description": "Read the EWMA beacon signal value.",
        "pre": {
            "&link->u.mgd.ave_beacon_signal": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_ap_probereq_get": {
        "description": "This function is used to get the probe request from the AP.",
        "pre": {
            "sdata": "!=null",
            "vif": "!=null",
            "hw": "!=null"
        }
    }
},
S,
{
    "kretprobe:ieee80211_enable_rssi_reports": {
        "description": "Enable RSSI reports for the given sub-interface data.",
        "pre": {
            "sdata": "!=null",
            "rssi_min_thold": "!=null",
            "rssi_max_thold": "!=null",
            "rssi_min_thold_scaled": "rssi_min_thold * 16",
            "rssi_max_thold_scaled": "rssi_max_thold * 16"
        }
    }
},
{
    "kprobe:ieee80211_enable_rssi_reports": {
        "description": "Enable RSSI reports for the given IEEE 802.11 sub interface data.",
        "pre": {
            "sdata": "!=null",
            "rssi_min_thold": "!=null",
            "rssi_max_thold": "!=null"
        }
    }
},
{
    "kretprobe:WARN_ON(1);mutex_unlock(&rate_ctrl_mutex);return -EALREADY;}}alg = kzalloc(sizeof(*alg), GFP_KERNEL);if (alg == NULL)": {
        "description": "Register a rate control algorithm for IEEE 802.11.",
        "pre": {
            "ops": {
                "name": "!=null"
            },
            "rate_ctrl_mutex": "locked",
            "rate_ctrl_algs": "contains alg with alg->ops->name == ops->name"
        },
        "post": {
            "return": "-EALREADY"
        }
    }
},
{
    "kprobe:WARN_ON(1);mutex_unlock(&rate_ctrl_mutex);return -EALREADY;}}alg = kzalloc(sizeof(*alg), GFP_KERNEL);if (alg == NULL)": {
        "description": "Register a rate control algorithm for IEEE 802.11.",
        "pre": {
            "ops": {
                "name": "!=null"
            },
            "rate_ctrl_mutex": "locked",
            "rate_ctrl_algs": "contains alg with alg->ops->name == ops->name"
        }
    }
},
{
    "kretprobe:rate_control_set_rates": {
        "description": "Set rates for a given station in the rate control algorithm.",
        "pre": {
            "hw": "!=null",
            "pubsta": "!=null",
            "rates": "!=null",
            "sta": "!=null",
            "sband": "!=null"
        }
    }
},
{
    "kprobe:rate_control_set_rates": {
        "description": "Set rates for a given station.",
        "pre": {
            "hw": "any",
            "pubsta": "!=null",
            "rates": "any"
        }
    }
},
{
    "kretprobe:ieee80211_scan_completed": {
        "description": "Function called when an IEEE 802.11 scan is completed.",
        "pre": {
            "local->scanning": "==false",
            "aborted": "==false",
            "local->scan_req": "!=null",
            "scan_sdata": "!=null",
            "hw_scan": "==true",
            "!ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)": "==false",
            "ieee80211_prep_hw_scan(scan_sdata)": "==true"
        }
    }
},
{
    "kprobe:ieee80211_scan_completed": {
        "description": "Function called when an IEEE 802.11 scan is completed.",
        "pre": {
            "local->scanning": "==false",
            "aborted": "==false",
            "local->scan_req": "!=null",
            "scan_sdata": "!=null",
            "hw_scan": "==true",
            "!ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)": "==true",
            "ieee80211_prep_hw_scan(scan_sdata)": "==true"
        }
    }
},
{
    "kretprobe:ieee80211_sched_scan_stopped": {
        "description": "This function is called when the scheduled scan is stopped.",
        "pre": {
            "local": "!=null",
            "local->in_reconfig": "==0"
        }
    }
},
{
    "kprobe:ieee80211_sched_scan_stopped": {
        "description": "This function is called when the scheduled scan is stopped.",
        "pre": {
            "local": "!=null",
            "local->in_reconfig": "false"
        }
    }
},
{
    "kretprobe:ieee80211_sta_ps_transition": {
        "description": "Transition the power save state of a station.",
        "pre": {
            "pubsta": "!=null",
            "start": "bool"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:ieee80211_sta_ps_transition": {
        "description": "Transition the power save state of a station.",
        "pre": {
            "pubsta": "!=null",
            "start": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_sta_uapsd_trigger": {
        "description": "Trigger uAPSD for the given station and TID.",
        "pre": {
            "sta": {
                "uapsd_queues": "&= 0x1 << ac",
                "ac": "in [0, 1, 2, 3]"
            },
            "tid": "in [0, 1, 2, 3, 4, 5, 6, 7]"
        }
    }
},
{
    "kprobe:ieee80211_sta_uapsd_trigger": {
        "description": "Trigger uAPSD for the given station and TID.",
        "pre": {
            "sta": {
                "uapsd_queues": "&= 0x1 << ac",
                "ac": "in [0, 1, 2, 3]"
            },
            "tid": "!= IEEE80211_NUM_TIDS"
        }
    }
},
{
    "kretprobe:ieee80211_mark_rx_ba_filtered_frames": {
        "description": "This is OK -- must be QoS data frame",
        "pre": {
            "pubsta": "!=null",
            "tid": "!=null",
            "ssn": "!=null",
            "filtered": "!=null",
            "received_mpdus": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_mark_rx_ba_filtered_frames": {
        "description": "This is OK -- must be QoS data frame",
        "pre": {
            "pubsta": "!=null",
            "tid": "!=null",
            "ssn": "!=null",
            "filtered": "!=null",
            "received_mpdus": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_rx_list": {
        "description": "Check if local->quiescing or local->suspended is true",
        "pre": {
            "local->quiescing": "==false",
            "local->suspended": "==false"
        }
    }
},
{
    "kprobe:ieee80211_rx_list": {
        "description": "Receives an IEEE 802.11 frame and processes it.",
        "pre": {
            "local->quiescing": "==false",
            "local->suspended": "==false"
        }
    }
},
{
    "kretprobe:rcu_read_lock": {
        "description": "Acquire the RCU read lock.",
        "pre": {},
        "post": {
            "return": "==0"
        }
    },
    "kretprobe:ieee80211_rx_list": {
        "description": "Receive processing for IEEE 802.11 frames.",
        "pre": {
            "hw": "!=null",
            "pubsta": "!=null",
            "skb": "!=null",
            "list": "!=null"
        },
        "post": {}
    },
    "kretprobe:rcu_read_unlock": {
        "description": "Release the RCU read lock.",
        "pre": {},
        "post": {}
    },
    "kprobe:!napi": {
        "description": "Check if napi is null.",
        "pre": {},
        "post": {
            "return": "==1"
        }
    }
},
{
    "kprobe:rcu_read_lock": {
        "description": "Acquire the RCU read lock.",
        "pre": {}
    },
    "kprobe:ieee80211_rx_list": {
        "description": "Receive an IEEE 802.11 frame and add it to the receive list.",
        "pre": {
            "hw": "!=null",
            "pubsta": "!=null",
            "skb": "!=null",
            "list": "!=null",
            "napi": "==null"
        }
    },
    "kprobe:rcu_read_unlock": {
        "description": "Release the RCU read lock.",
        "pre": {}
    },
    "kprobe:!napi": {
        "description": "Check if napi is null.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:ieee80211_stop_rx_ba_session": {
        "description": "Stop the RX BA session for a given STA and TID.",
        "pre": {
            "sta": "!=null",
            "tid": "!=null",
            "initiator": "== WLAN_BACK_RECIPIENT",
            "reason": "!=null",
            "tx": "true"
        }
    }
},
{
    "kprobe:ieee80211_send_delba": {
        "description": "Send a DELBA frame to stop an ongoing Block Ack session.",
        "pre": {
            "sta->sdata": "!=null",
            "sta->sta.addr": "!=null",
            "tid": "any",
            "initiator": "WLAN_BACK_RECIPIENT",
            "reason": "any"
        }
    }
},
{
    "kretprobe:ieee80211_iter_keys_rcu": {
        "description": "Iterate over keys in the ieee80211_hw structure.",
        "pre": {
            "key->sta": "!=null",
            "key->sta->removed": "==true",
            "!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)": "==true"
        }
    }
},
{
    "ieee80211_iter_keys_rcu": {
        "pre": {
            "hw": "any",
            "sdata": "any",
            "iter": "any",
            "iter_data": "any"
        }
    }
},
S,
{
    "kprobe:ieee80211_sta_update_pending_airtime": {
        "description": "Update pending airtime for the given station.",
        "pre": {
            "local": "!=null",
            "sta": "!=null",
            "skb_get_queue_mapping(skb)": "!=null",
            "tx_time_est": "!=null",
            "true": "true"
        }
    },
    "kprobe:ieee80211_info_set_tx_time_est": {
        "description": "Set the transmission time estimate for the given skb.",
        "pre": {
            "IEEE80211_SKB_CB(skb)": "!=null",
            "0": "0"
        }
    },
    "kprobe:ieee80211_tx_get_rates": {
        "description": "Get the rates for transmission.",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "retry_count": "!=null"
        }
    },
    "kprobe:ieee80211_tx_status": {
        "description": "Handle the transmission status.",
        "pre": {
            "hw": "!=null",
            "status": "!=null"
        }
    },
    "kprobe:ieee80211_tx_status_ext": {
        "description": "Handle the extended transmission status.",
        "pre": {
            "hw": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Set the memory block starting at &info->control to zero, with a size of sizeof(info->control). Then, set info->control.jiffies to the value of jiffies. Set info->control.vif to the address of sta->sdata->vif. Set the IEEE80211_TX_INTCFL_NEED_TXPROCESSING flag in info->control.flags. Set the IEEE80211_TX_INTFL_RETRANSMISSION flag in info->flags. Clear the IEEE80211_TX_TEMPORARY_FLAGS flag in info->flags. Increment sta->deflink.status_stats.filtered. Clear the more-data bit on filtered frames.",
        "pre": {
            "&info->control": "!=null",
            "sizeof(info->control)": ">0",
            "jiffies": "!=null",
            "&sta->sdata->vif": "!=null",
            "info->control.flags": "|= IEEE80211_TX_INTCFL_NEED_TXPROCESSING",
            "info->flags": "|= IEEE80211_TX_INTFL_RETRANSMISSION",
            "info->flags": "&= ~IEEE80211_TX_TEMPORARY_FLAGS",
            "sta->deflink.status_stats.filtered": "++",
            "filtered frames.more-data bit": "= 0"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set the memory block starting at &info->control to zero, with a size of sizeof(info->control). Then, set info->control.jiffies to the value of jiffies. Set info->control.vif to the address of sta->sdata->vif. Set the IEEE80211_TX_INTCFL_NEED_TXPROCESSING flag in info->control.flags. Set the IEEE80211_TX_INTFL_RETRANSMISSION flag in info->flags. Clear the IEEE80211_TX_TEMPORARY_FLAGS flag in info->flags. Increment sta->deflink.status_stats.filtered. Clear the more-data bit on filtered frames.",
        "pre": {
            "&info->control": "!=null",
            "sizeof(info->control)": "!=0",
            "jiffies": "!=null",
            "&sta->sdata->vif": "!=null",
            "info->control.flags": "& IEEE80211_TX_INTCFL_NEED_TXPROCESSING",
            "info->flags": "| IEEE80211_TX_INTFL_RETRANSMISSION & ~IEEE80211_TX_TEMPORARY_FLAGS",
            "sta->deflink.status_stats.filtered": "++",
            "filtered frames.more-data bit": "=0"
        }
    }
},
{
    "kretprobe:skb_dequeue": {
        "description": "Dequeue a socket buffer from the tx.skbs queue.",
        "pre": {
            "tx.skbs": "!=null",
            "skb2": "!=null",
            "skb2": "==skb",
            "skb_queue_empty(&tx.skbs)": "==true"
        }
    }
},
{
    "kprobe:skb2 = __skb_dequeue(&tx.skbs);if (WARN_ON(skb2 != skb || !skb_queue_empty(&tx.skbs)))": {
        "description": "Dequeue an skb from the tx.skbs queue and check for warnings.",
        "pre": {
            "tx.skbs": "!=null",
            "skb2": "!=null",
            "skb2": "==skb",
            "!skb_queue_empty(&tx.skbs)": "true"
        }
    }
},
S,
S,
{
    "kretprobe:__ieee80211_schedule_txq": {
        "description": "__ieee80211_schedule_txq function",
        "pre": {
            "hw": "!=null",
            "txq": "!=null",
            "force": "bool",
            "local": "struct ieee80211_local",
            "txqi": "struct txq_info",
            "has_queue": "bool",
            "active_txq_lock": "!=null",
            "list_empty(&txqi->schedule_order)": "true",
            "has_queue || ieee80211_txq_keep_active(txqi)": "true"
        }
    }
},
{
    "kprobe:__ieee80211_schedule_txq": {
        "description": "__ieee80211_schedule_txq function",
        "pre": {
            "hw": "!=null",
            "txq": "!=null",
            "force": "bool",
            "local": "struct ieee80211_local",
            "txqi": "struct txq_info",
            "has_queue": "bool",
            "active_txq_lock": "!=null",
            "list_empty(&txqi->schedule_order)": "true",
            "has_queue || ieee80211_txq_keep_active(txqi)": "true"
        }
    }
},
{
    "kretprobe:ieee80211_beacon_update_cntdwn": {
        "description": "Update the countdown counter in the beacon data structure.",
        "pre": {
            "beacon": "!=null",
            "beacon->cntdwn_current_counter": ">0"
        }
    }
},
{
    "kprobe:ieee80211_beacon_update_cntdwn": {
        "description": "Update the countdown counter in the beacon data structure.",
        "pre": {
            "beacon": "!=null",
            "beacon->cntdwn_current_counter": ">0"
        }
    }
},
{
    "kretprobe:if (ema_index <= IEEE80211_INCLUDE_ALL_MBSSID_ELEMS) ema_index = beacon->mbssid_ies->cnt;": {
        "description": "Check if ema_index is less than or equal to IEEE80211_INCLUDE_ALL_MBSSID_ELEMS. If true, assign beacon->mbssid_ies->cnt to ema_index.",
        "pre": {
            "ema_index": "<= IEEE80211_INCLUDE_ALL_MBSSID_ELEMS",
            "beacon": {
                "mbssid_ies": {
                    "cnt": "!= null"
                }
            }
        }
    }
},
{
    "kprobe:if (ema_index <= IEEE80211_INCLUDE_ALL_MBSSID_ELEMS) ema_index = beacon->mbssid_ies->cnt;": {
        "description": "Condition for the given function",
        "pre": {
            "ema_index": "<= -1"
        }
    }
},
{
    "kretprobe:ieee80211_beacon_get_tim": {
        "description": "Copy the skb and perform some operations on it before returning it.",
        "pre": {
            "bcn": "!=null",
            "vif": "!=null",
            "hw": "!=null"
        },
        "post": {
            "copy": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kprobe:skb_copy": {
        "description": "Copy the given skb (socket buffer) using GFP_ATOMIC flag.",
        "pre": {
            "skb": "!=null"
        }
    },
    "kprobe:ieee80211_vif_get_shift": {
        "description": "Get the shift value for the given vif (virtual interface).",
        "pre": {
            "vif": "!=null"
        }
    },
    "kprobe:ieee80211_tx_monitor": {
        "description": "Monitor the transmission of the given copy of skb (socket buffer) with specified parameters.",
        "pre": {
            "hw": "!=null",
            "copy": "!=null",
            "shift": "!=null"
        }
    }
},
{
    "kretprobe:pspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);memcpy(pspoll->bssid, sdata->deflink.u.mgd.bssid, ETH_ALEN);memcpy(pspoll->ta, vif->addr, ETH_ALEN);return skb": {
        "description": "Function description goes here",
        "pre": {
            "pspoll": "!=null",
            "sdata": "!=null",
            "vif": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_pspoll_get": {
        "description": "Get the PS-Poll frame for the given IEEE 802.11 hardware and virtual interface.",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "vif->type": "==NL80211_IFTYPE_STATION",
            "sdata": "!=null",
            "local": "!=null",
            "skb": "!=null",
            "skb->len": ">=local->hw.extra_tx_headroom + sizeof(pspoll)",
            "pspoll": "!=null",
            "pspoll->frame_control": "==cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL)",
            "pspoll->aid": "==cpu_to_le16(sdata->vif.cfg.aid | (1 << 15) | (1 << 14))",
            "pspoll->bssid": "==memcpy(sdata->deflink.u.mgd.bssid, pspoll->bssid, ETH_ALEN)",
            "pspoll->ta": "==memcpy(vif->addr, pspoll->ta, ETH_ALEN)"
        }
    }
},
S,
S,
{
    "kretprobe:ieee80211_stop_queues_by_reason": {
        "description": "Stop all Rx during the reconfig. We don't want state changes or driver callbacks while this is in progress.",
        "pre": {
            "hw": "!=null",
            "IEEE80211_MAX_QUEUE_MAP": ">=0",
            "IEEE80211_QUEUE_STOP_REASON_SUSPEND": "==\"suspend\"",
            "false": "==false"
        }
    }
},
{
    "kprobe:ieee80211_stop_queues_by_reason": {
        "description": "Stop all Rx during the reconfig. We don't want state changes or driver callbacks while this is in progress.",
        "pre": {
            "hw": "!=null",
            "IEEE80211_MAX_QUEUE_MAP": "!=null",
            "IEEE80211_QUEUE_STOP_REASON_SUSPEND": "!=null",
            "false": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_alloc_hw_nm": {
        "description": "Allocate and initialize an ieee80211_hw structure with the given parameters.",
        "pre": {
            "priv_data_len": ">= 0",
            "ops": "!= null",
            "requested_name": "!= null",
            "ops->tx": "!= null",
            "ops->start": "!= null",
            "ops->stop": "!= null",
            "ops->config": "!= null",
            "ops->add_interface": "!= null",
            "ops->remove_interface": "!= null",
            "ops->configure_filter": "!= null",
            "ops->wake_tx_queue": "!= null",
            "ops->sta_state": "!= null",
            "ops->sta_add": "!= null",
            "ops->sta_remove": "!= null",
            "ops->link_info_changed": "!= null",
            "ops->vif_cfg_changed": "!= null",
            "ops->bss_info_changed": "!= null",
            "i": "in [0, 5]",
            "use_chanctx": "i == 5"
        }
    }
},
{
    "kprobe:i = !!ops->add_chanctx + !!ops->remove_chanctx + !!ops->change_chanctx + !!ops->assign_vif_chanctx + !!ops->unassign_vif_chanctx;if (WARN_ON(i != 0 && i != 5))return NULL;use_chanctx = i == 5;/* Ensure 32-byte alignment of our private data and hw private data. * We use the wiphy priv data for both our ieee80211_local and for * the driver's private data * * In memory it'll be like this: * * +-------------------------+ * | struct wiphy    | * +-------------------------+ * | struct ieee80211_local  | * +-------------------------+ * | driver's private data   | * +-------------------------+ * `": {
        "description": "Allocate and initialize an ieee80211_hw structure with the given parameters.",
        "pre": {
            "priv_data_len": "!=null",
            "ops": "!=null",
            "requested_name": "!=null",
            "ops->tx": "!=null",
            "ops->start": "!=null",
            "ops->stop": "!=null",
            "ops->config": "!=null",
            "ops->add_interface": "!=null",
            "ops->remove_interface": "!=null",
            "ops->configure_filter": "!=null",
            "ops->wake_tx_queue": "!=null",
            "ops->sta_state": "!=null",
            "ops->sta_add": "!=null",
            "ops->sta_remove": "!=null",
            "ops->link_info_changed": "!=null",
            "ops->vif_cfg_changed": "!=null",
            "ops->bss_info_changed": "!=null",
            "i": "in [0, 5]",
            "use_chanctx": "in [true, false]"
        }
    }
},
{
    "kretprobe:ieee80211_register_hw": {
        "description": "Register the IEEE 802.11 hardware.",
        "pre": {
            "local->use_chanctx": "!=null",
            "local->ops->link_info_changed": "!=null",
            "ieee80211_hw_check(hw, HAS_RATE_CONTROL)": "!=null",
            "ieee80211_hw_check(hw, AMPDU_AGGREGATION)": "!=null",
            "ieee80211_hw_check(hw, HOST_BROADCAST_PS_BUFFERING)": "!=null",
            "ieee80211_hw_check(hw, SUPPORTS_PS) && (!ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS) || ieee80211_hw_check(hw, PS_NULLFUNC_STACK))": "!=null",
            "ieee80211_hw_check(hw, MFP_CAPABLE)": "!=null",
            "ieee80211_hw_check(hw, CONNECTION_MONITOR)": "!=null",
            "ieee80211_hw_check(hw, NEED_DTIM_BEFORE_ASSOC)": "!=null",
            "ieee80211_hw_check(hw, TIMING_BEACON_ONLY)": "!=null",
            "ieee80211_hw_check(hw, AP_LINK_PS)": "!=null",
            "ieee80211_hw_check(hw, DEAUTH_NEED_MGD_TX_PREP)": "!=null",
            "hw->wiphy->wowlan && (!local->ops->suspend || !local->ops->resume)": "!=null",
            "!local->use_chanctx": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_register_hw": {
        "description": "Register the IEEE 802.11 hardware.",
        "pre": {
            "local->use_chanctx": "!=null",
            "local->ops->link_info_changed": "!=null",
            "ieee80211_hw_check(hw, HAS_RATE_CONTROL)": "!=null",
            "ieee80211_hw_check(hw, AMPDU_AGGREGATION)": "!=null",
            "ieee80211_hw_check(hw, HOST_BROADCAST_PS_BUFFERING)": "null",
            "ieee80211_hw_check(hw, SUPPORTS_PS) && (!ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS) || ieee80211_hw_check(hw, PS_NULLFUNC_STACK))": "null",
            "ieee80211_hw_check(hw, MFP_CAPABLE)": "!=null",
            "ieee80211_hw_check(hw, CONNECTION_MONITOR)": "!=null",
            "ieee80211_hw_check(hw, NEED_DTIM_BEFORE_ASSOC)": "null",
            "ieee80211_hw_check(hw, TIMING_BEACON_ONLY)": "null",
            "ieee80211_hw_check(hw, AP_LINK_PS)": "!=null",
            "ieee80211_hw_check(hw, DEAUTH_NEED_MGD_TX_PREP)": "null",
            "hw->wiphy->wowlan && (!local->ops->suspend || !local->ops->resume)": "null",
            "!local->use_chanctx": "null"
        }
    }
},
{
    "kretprobe:ieee80211_unregister_hw": {
        "description": "Unregister the IEEE 802.11 hardware.",
        "pre": {
            "hw": "!=null",
            "local": "!=null",
            "local->tx_pending_tasklet": "killed",
            "local->tasklet": "killed",
            "local->ifa_notifier": "unregistered",
            "local->ifa6_notifier": "unregistered",
            "rtnl_lock": "locked"
        }
    }
},
{
    "kprobe:ieee80211_remove_interfaces": {
        "description": "Removes interfaces and performs various cleanup tasks.",
        "pre": {
            "local": "!=null",
            "hw": "!=null",
            "local->tx_pending_tasklet": "killed",
            "local->tasklet": "killed",
            "local->ifa_notifier": "unregistered",
            "local->ifa6_notifier": "unregistered",
            "rtnl_lock": "locked"
        }
    }
},
{
    "kretprobe:ieee80211_get_bssid": {
        "description": "Get the BSSID (Basic Service Set Identifier) from the IEEE 802.11 header.",
        "pre": {
            "hdr": "!=null",
            "len": ">=24",
            "type": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC, NL80211_IFTYPE_AP, NL80211_IFTYPE_MESH_POINT, NL80211_IFTYPE_P2P_CLIENT, NL80211_IFTYPE_P2P_GO, NL80211_IFTYPE_MONITOR]"
        }
    },
    "kretprobe:ieee80211_has_a4": {
        "description": "Check if the IEEE 802.11 frame has the A4 address field.",
        "pre": {
            "fc": "!=null"
        }
    },
    "kretprobe:ieee80211_has_tods": {
        "description": "Check if the IEEE 802.11 frame has the To DS (Destination Station) flag set.",
        "pre": {
            "fc": "!=null",
            "hdr": "!=null"
        }
    },
    "kretprobe:ieee80211_has_fromds": {
        "description": "Check if the IEEE 802.11 frame has the From DS (Source Station) flag set.",
        "pre": {
            "fc": "!=null",
            "hdr": "!=null"
        }
    },
    "kretprobe:ieee80211_is_s1g_beacon": {
        "description": "Check if the IEEE 802.11 frame is an S1G (Sub-1 GHz) beacon frame.",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:return NULL;if (ieee80211_has_a4(fc))return NULL;if (ieee80211_has_tods(fc))return hdr->addr1;if (ieee80211_has_fromds(fc))return hdr->addr2;return hdr->addr3;}if (ieee80211_is_s1g_beacon(fc))": {
        "description": "Helper function to get the BSSID from the IEEE80211 header.",
        "pre": {
            "hdr": "!=null",
            "len": ">= 24",
            "type": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_AP, NL80211_IFTYPE_MESH_POINT, NL80211_IFTYPE_ADHOC]"
        }
    }
},
{
    "kretprobe:ieee80211_frame_duration": {
        "description": "Calculate the duration of a data frame.",
        "pre": {
            "sband->band": "!=null",
            "bitrate": "!=null",
            "erp": "!=null",
            "short_preamble": "!=null",
            "shift": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_frame_duration": {
        "description": "Data frame duration",
        "pre": {
            "sband->band": "!=null",
            "10": "!=null",
            "bitrate": "!=null",
            "erp": "!=null",
            "short_preamble": "!=null",
            "shift": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_frame_duration": {
        "description": "Calculate the duration of an IEEE 802.11 frame.",
        "pre": {
            "sband->band": "!=null",
            "frame_len": "!=null",
            "bitrate": "!=null",
            "erp": "!=null",
            "short_preamble": "!=null",
            "shift": "!=null",
            "frame_txctl->flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "frame_txctl->band": "!=null"
        }
    }
},
S,
{
    "kretprobe:ieee80211_txq_schedule_start": {
        "description": "Schedule the start of the transmission queue for IEEE 802.11.",
        "pre": {
            "hw": "!=null",
            "txq": "!=null",
            "txq->vif": "!=null",
            "txq->ac": "in [0, 1, 2, 3, 4, 5, 6, 7]",
            "hw_to_local(hw)": "!=null",
            "vif_to_sdata(txq->vif)": "!=null",
            "ieee80211_next_txq(hw, txq->ac)": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_txq_schedule_start": {
        "description": "Schedule the transmission queue for IEEE 802.11 packets.",
        "pre": {
            "hw": "!=null",
            "txq->ac": "!=null"
        }
    }
},
{
    "kretprobe:return;if (!skb_queue_empty(&local->pending[queue]))tasklet_schedule(&local->tx_pending_tasklet);/* * Calling _ieee80211_wake_txqs here can be a problem because it may * release queue_stop_reason_lock which has been taken by * __ieee80211_wake_queue's caller. It is certainly not very nice to * release someone's lock, but it is fine because all the callers of * __ieee80211_wake_queue call it right before releasing the lock. `": {
        "description": "This function is responsible for waking up a queue in the IEEE80211 subsystem.",
        "pre": {
            "hw": "!=null",
            "queue": ">=0",
            "reason": "in [QUEUE_STOP_REASON_1, QUEUE_STOP_REASON_2, ...]",
            "refcounted": "bool",
            "flags": "unsigned long"
        }
    }
},
{
    "kprobe:return;if (!skb_queue_empty(&local->pending[queue]))tasklet_schedule(&local->tx_pending_tasklet);/* * Calling _ieee80211_wake_txqs here can be a problem because it may * release queue_stop_reason_lock which has been taken by * __ieee80211_wake_queue's caller. It is certainly not very nice to * release someone's lock, but it is fine because all the callers of * __ieee80211_wake_queue call it right before releasing the lock. `": {
        "description": "Call _ieee80211_wake_txqs to wake up the transmit queues.",
        "pre": {
            "hw": "!=null",
            "queue": ">=0",
            "reason": "in [QUEUE_STOP_REASON_1, QUEUE_STOP_REASON_2, ...]",
            "refcounted": "bool",
            "flags": "unsigned long"
        }
    }
},
{
    "kretprobe:clear_sta_flag": {
        "description": "Clear the station flag.",
        "pre": {
            "sta": "!=null",
            "flag": "in [WLAN_STA_PS_DRIVER, WLAN_STA_PS_STA, WLAN_STA_PSPOLL, WLAN_STA_UAPSD]",
            "hw": "!=null",
            "sta->local": "!=null",
            "sta->drv_deliver_wk": "!=null"
        }
    }
},
{
    "clear_sta_flag": {
        "pre": {
            "block": true,
            "sta": {
                "WLAN_STA_PS_DRIVER": false,
                "WLAN_STA_PS_STA": false,
                "WLAN_STA_PSPOLL": true,
                "WLAN_STA_UAPSD": true
            }
        }
    }
},
{
    "kretprobe:sta_info_free": {
        "description": "Free STA information",
        "pre": {
            "local": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kprobe:sta_info_free": {
        "description": "Free STA information",
        "pre": {
            "local": "!=null",
            "sta": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:can_send": {
        "description": "Transmit a CAN frame (optional with local loopback)",
        "pre": {
            "skb": "!=null",
            "loop": "!=null"
        },
        "post": {
            "return": "in [0, -ENETDOWN, -ENOBUFS, -ENOMEM, -EPERM, -EMSGSIZE, -EINVAL]"
        }
    }
},
{
    "kprobe:can_send": {
        "description": "Transmit a CAN frame (optional with local loopback).",
        "pre": {
            "skb": "!=null",
            "loop": "!=null"
        }
    }
},
{
    "kretprobe:can_rx_register": {
        "description": "Subscribe CAN frames from a specific interface",
        "pre": {
            "net": "!=null",
            "dev": "!=null",
            "can_id": "!=null",
            "mask": "!=null",
            "func": "!=null",
            "data": "!=null",
            "ident": "!=null",
            "sk": "!=null"
        },
        "post": {
            "return_value": "in [0, -ENOMEM, -ENODEV]"
        }
    }
},
{
    "kprobe:can_rx_register": {
        "description": "Subscribe CAN frames from a specific interface",
        "pre": {
            "net": "!=null",
            "dev": "!=null",
            "can_id": "!=null",
            "mask": "!=null",
            "func": "!=null",
            "data": "!=null",
            "ident": "!=null",
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:can_rx_unregister": {
        "description": "Unsubscribe CAN frames from a specific interface.",
        "pre": {
            "net": "!=null",
            "dev": "!=null",
            "can_id": "!=null",
            "mask": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:can_rx_unregister": {
        "description": "Unsubscribe CAN frames from a specific interface.",
        "pre": {
            "net": "!=null",
            "dev": "!=null",
            "can_id": "!=null",
            "mask": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:can_proto_register": {
        "description": "register CAN transport protocol",
        "pre": {
            "cp": "!=null"
        },
        "post": {
            "return": {
                "constraints": [
                    "in [0, -EINVAL, -EBUSY, -ENOBUF]"
                ]
            }
        }
    }
},
{
    "kprobe:can_proto_register": {
        "description": "Register CAN transport protocol",
        "pre": {
            "cp": "!=null"
        }
    }
},
{
    "kretprobe:can_proto_unregister": {
        "description": "Unregister CAN transport protocol",
        "pre": {
            "cp": "!=null"
        }
    }
},
{
    "kprobe:can_proto_unregister": {
        "description": "Unregister CAN transport protocol",
        "pre": {
            "cp": "!=null"
        }
    }
},
{
    "kretprobe:__vlan_find_dev_deep_rcu": {
        "description": "Find a VLAN device deep in the network device hierarchy.",
        "pre": {
            "dev": "!=null",
            "vlan_proto": "!=null",
            "vlan_id": "!=null",
            "vlan_info": "!=null",
            "vlan_info->grp": "!=null"
        }
    }
},
{
    "kprobe:__vlan_find_dev_deep_rcu": {
        "description": "Find a VLAN device deep in the network device hierarchy.",
        "pre": {
            "dev": "!=null",
            "vlan_proto": "!=null",
            "vlan_id": "!=null"
        }
    }
},
{
    "kretprobe:netlbl_calipso_ops_register": {
        "description": "Register the CALIPSO packet engine operations.",
        "pre": {
            "ops": "!=null"
        }
    }
},
{
    "kprobe:netlbl_calipso_ops_register": {
        "description": "Register the CALIPSO packet engine operations.",
        "pre": {
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:netlbl_catmap_walk": {
        "description": "Walk a LSM secattr catmap looking for a bit",
        "pre": {
            "catmap": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:netlbl_catmap_walk": {
        "description": "Walk a LSM secattr catmap looking for a bit",
        "pre": {
            "catmap": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:netlbl_catmap_setbit": {
        "description": "Set a bit in a LSM secattr catmap",
        "pre": {
            "catmap": "!=null",
            "bit": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:netlbl_catmap_setbit": {
        "description": "Set a bit in a LSM secattr catmap",
        "pre": {
            "catmap": "!=null",
            "bit": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:netlbl_bitmap_walk": {
        "description": "Walk a bitmap looking for a bit",
        "pre": {
            "bitmap": "!=null",
            "bitmap_len": ">=0",
            "offset": ">=0",
            "state": "in [0, 1]"
        }
    }
},
{
    "kprobe:netlbl_bitmap_walk": {
        "description": "Walk a bitmap looking for a bit",
        "pre": {
            "bitmap": "!=null",
            "bitmap_len": ">=0",
            "offset": ">=0",
            "state": "in [0, 1]"
        }
    }
},
{
    "kretprobe:netlbl_bitmap_setbit": {
        "description": "Sets a single bit in a bitmap",
        "pre": {
            "bitmap": "!=null",
            "bit": "!=null",
            "state": "in [0, 1]"
        }
    }
},
{
    "kprobe:netlbl_bitmap_setbit": {
        "description": "Sets a single bit in a bitmap",
        "pre": {
            "bitmap": "!=null",
            "bit": "!=null",
            "state": "in [0, 1]"
        }
    }
},
{
    "kretprobe:netlbl_audit_start": {
        "description": "Start an audit message using the type specified in @type and fill the audit message with some fields common to all NetLabel audit messages.",
        "pre": {
            "type": "!=null",
            "audit_info": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:netlbl_audit_start": {
        "description": "Start an audit message using the type specified in @type and fill the audit message with some fields common to all NetLabel audit messages.",
        "pre": {
            "type": "!=null",
            "audit_info": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_send_data": {
        "description": "Allow a kernel service to send data on a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "msg": "!=null",
            "len": ">=0",
            "notify_end_tx": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_send_data": {
        "description": "Allow a kernel service to send data on a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "msg": "!=null",
            "len": ">=0",
            "notify_end_tx": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_abort_call": {
        "description": "Allow a kernel service to abort a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "abort_code": "!=null",
            "error": "!=null",
            "why": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_abort_call": {
        "description": "Allow a kernel service to abort a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "abort_code": "!=null",
            "error": "!=null",
            "why": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_set_tx_length": {
        "description": "Set the total Tx length on a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "tx_total_len": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_set_tx_length": {
        "description": "Set the total Tx length on a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "tx_total_len": ">=0"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_begin_call": {
        "description": "Allow a kernel service to begin a call on the nominated socket. This just sets up all the internal tracking structures and allocates connection and call IDs as appropriate. The call to be used is returned.",
        "pre": {
            "sock": "!=null",
            "srx": "!=null",
            "key": "!=null",
            "user_call_ID": ">=0",
            "tx_total_len": ">=-1",
            "hard_timeout": ">=0",
            "gfp": ">=0",
            "notify_rx": "!=null",
            "upgrade": "in [true, false]",
            "interruptibility": "in [RXRPC_INTERRUPTIBLE, RXRPC_UNINTERRUPTIBLE]",
            "debug_id": ">=0"
        }
    }
},
{
    "kprobe:rxrpc_kernel_begin_call": {
        "description": "Allow a kernel service to begin a call on the nominated socket. This just sets up all the internal tracking structures and allocates connection and call IDs as appropriate. The call to be used is returned. The default socket destination address and security may be overridden by supplying @srx and @key.",
        "pre": {
            "sock": "!=null",
            "srx": "!=null",
            "key": "!=null",
            "user_call_ID": "!=null",
            "tx_total_len": ">=-1",
            "hard_timeout": ">=0",
            "gfp": ">=0",
            "notify_rx": "!=null",
            "upgrade": "bool",
            "interruptibility": "in [RXRPC_INTERRUPTIBLE, RXRPC_UNINTERRUPTIBLE]",
            "debug_id": "unsigned int"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_shutdown_call": {
        "description": "Allow a kernel service to shut down a call it was using.",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_shutdown_call": {
        "description": "Allow a kernel service to shut down a call it was using.",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_put_call": {
        "description": "Release a reference to a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_put_call": {
        "description": "Release a reference to a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_check_life": {
        "description": "Check to see whether a call is still alive",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_check_life": {
        "description": "Check to see whether a call is still alive",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_get_epoch": {
        "description": "Retrieve the epoch value from a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_get_epoch": {
        "description": "Retrieve the epoch value from a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_new_call_notification": {
        "description": "Get notifications of new calls",
        "pre": {
            "sock": "!=null",
            "notify_new_call": "!=null",
            "discard_new_call": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_new_call_notification": {
        "description": "Get notifications of new calls",
        "pre": {
            "sock": "!=null",
            "notify_new_call": "!=null",
            "discard_new_call": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_set_max_life": {
        "description": "Set maximum lifespan on a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "hard_timeout": ">=0"
        }
    }
},
{
    "kprobe:rxrpc_kernel_set_max_life": {
        "description": "Set maximum lifespan on a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "hard_timeout": ">=0"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_charge_accept": {
        "description": "Charge up socket with preallocated calls",
        "pre": {
            "sock": "!=null",
            "notify_rx": "!=null",
            "user_attach_call": "!=null",
            "user_call_ID": "!=null",
            "gfp": "!=null",
            "debug_id": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_charge_accept": {
        "description": "Charge up socket with preallocated calls",
        "pre": {
            "sock": "!=null",
            "notify_rx": "!=null",
            "user_attach_call": "!=null",
            "user_call_ID": "!=null",
            "gfp": "!=null",
            "debug_id": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_get_null_key": {
        "description": "Generate a null RxRPC key",
        "pre": {
            "keyname": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_get_null_key": {
        "description": "Generate a null RxRPC key",
        "pre": {
            "keyname": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_sock_set_security_keyring": {
        "description": "Set the server security keyring on an rxrpc socket. This is used to provide the encryption keys for a kernel service.",
        "pre": {
            "sk": "!=null",
            "keyring": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_sock_set_security_keyring": {
        "description": "Set the security keyring for a kernel service",
        "pre": {
            "sk": "!=null",
            "keyring": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_get_peer": {
        "description": "Get the peer address of a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "_srx": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_get_peer": {
        "description": "Get the peer address of a call",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "_srx": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_get_srtt": {
        "description": "Get a call's peer smoothed RTT",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "_srtt": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_get_srtt": {
        "description": "Get a call's peer smoothed RTT",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "_srtt": "!=null"
        }
    }
},
{
    "kretprobe:rxrpc_kernel_recv_data": {
        "description": "Allow a kernel service to receive data and pick up information about the state of a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "iter": "!=null",
            "_len": "!=null",
            "want_more": "in [true, false]",
            "_abort": "!=null",
            "_service": "!=null"
        }
    }
},
{
    "kprobe:rxrpc_kernel_recv_data": {
        "description": "Allow a kernel service to receive data and pick up information about the state of a call.",
        "pre": {
            "sock": "!=null",
            "call": "!=null",
            "iter": "!=null",
            "_len": "!=null",
            "want_more": "in [true, false]",
            "_abort": "!=null",
            "_service": "!=null"
        }
    }
},
{
    "kretprobe:alloc_fcdev": {
        "description": "Register fibre channel device",
        "pre": {
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kprobe:alloc_fcdev": {
        "description": "Register fibre channel device",
        "pre": {
            "sizeof_priv": "!=null",
            "sizeof_priv": ">=0",
            "sizeof_priv": "is_integer",
            "sizeof_priv": "%32==0"
        }
    }
},
{
    "kretprobe:skb->dev = dev; skb_reset_mac_header(skb);": {
        "description": "Set the device of the skb to dev and reset the MAC header.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:skb->dev = dev; skb_reset_mac_header(skb);": {
        "description": "Set the device of the skb to dev and reset the MAC header of the skb.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:alloc_fddidev": {
        "description": "Register FDDI device",
        "pre": {
            "sizeof_priv": "!=null"
        }
    }
},
{
    "kprobe:alloc_fddidev": {
        "description": "Register FDDI device",
        "pre": {
            "sizeof_priv": "!=null"
        }
    }
},
{
    "kretprobe:skb->dev = dev; skb_reset_mac_header(skb); hip = (struct hippi_hdr *)skb_mac_header(skb); skb_pull(skb, HIPPI_HLEN);": {
        "description": "Set the device of the skb to dev, reset the MAC header of skb, cast skb_mac_header to struct hippi_hdr and assign it to hip, and pull HIPPI_HLEN bytes from skb.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "skb_mac_header(skb)": "!=null",
            "HIPPI_HLEN": ">=0"
        }
    }
},
{
    "kprobe:skb->dev = dev;skb_reset_mac_header(skb);hip = (struct hippi_hdr *)skb_mac_header(skb);skb_pull(skb, HIPPI_HLEN);/* * No fancy promisc stuff here now. `": {
        "description": "Set the device of the skb to dev, reset the MAC header of skb, and assign the skb_mac_header to hip as a struct hippi_hdr pointer. Then, pull HIPPI_HLEN bytes from skb.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "skb_mac_header(skb)": "!=null",
            "hip": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:alloc_hippi_dev": {
        "description": "Register HIPPI device",
        "pre": {
            "sizeof_priv": "!=null",
            "alignment": "==32"
        }
    }
},
{
    "kprobe:alloc_hippi_dev": {
        "description": "Register HIPPI device",
        "pre": {
            "sizeof_priv": "!=null",
            "sizeof_priv": ">=0",
            "sizeof_priv": "% 32 == 0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:read_lock_bh": {
        "description": "Read lock the atalk_interfaces_lock and iterate over atalk_interfaces.",
        "pre": {
            "atalk_interfaces_lock": "!=null",
            "atalk_interfaces": "!=null",
            "iface": "!=null"
        }
    }
},
S,
{
    "kretprobe:alloc_ltalkdev": {
        "description": "Allocates and sets up a localtalk device",
        "pre": {
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kprobe:alloc_ltalkdev": {
        "description": "Allocates and sets up a localtalk device",
        "pre": {
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:atomic_dec": {
        "description": "Decrements the value of the atomic variable.",
        "pre": {
            "wpan_phy_counter": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Frees the memory pointed to by the given pointer.",
        "pre": {
            "rdev": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Returns a NULL pointer.",
        "pre": {}
    }
},
{
    "kprobe:atomic_dec": {
        "description": "Decrements the value of the atomic variable *wpan_phy_counter* by 1.",
        "pre": {
            "wpan_phy_counter": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Frees the memory allocated for the object *rdev*.",
        "pre": {
            "rdev": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Returns NULL.",
        "pre": {}
    }
},
{
    "kretprobe:rtnl_unlock": {
        "description": "Unlock the rtnl mutex.",
        "pre": {
            "rtnl_mutex": "locked"
        }
    }
},
{
    "kprobe:rtnl_unlock": {
        "description": "Unlock the rtnl mutex.",
        "pre": {
            "phy": "!=null",
            "rdev": "!=null",
            "ret": "int",
            "ret != 0": true,
            "list": "!=null",
            "cfg802154_rdev_list": "!=null",
            "cfg802154_rdev_list_generation": "int"
        }
    }
},
S,
{
    "kprobe:wpan_phy_unregister": {
        "description": "Unregister a wireless PAN (Personal Area Network) PHY (Physical Layer) device.",
        "pre": {
            "phy": "!=null",
            "rdev": "!=null",
            "rdev->dev_wait": "!=null",
            "rdev->opencount": "==0"
        }
    }
},
{
    "kretprobe:ieee802154_alloc_hw": {
        "description": "Allocate and initialize an IEEE 802.15.4 hardware device.",
        "pre": {
            "priv_data_len": ">= 0",
            "ops": "!= null"
        },
        "post": {
            "phy": "!= null"
        }
    }
},
{
    "kprobe:priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;phy = wpan_phy_new(&mac802154_config_ops, priv_size);if (!phy)": {
        "description": "Allocate and initialize an ieee802154_hw structure.",
        "pre": {
            "priv_data_len": "valid size",
            "ops": "!=null",
            "ops->xmit_async || ops->xmit_sync": "present",
            "ops->ed": "present",
            "ops->start": "present",
            "ops->stop": "present",
            "ops->set_channel": "present"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:tcp_select_initial_window": {
        "description": "Select the initial TCP window size.",
        "pre": {
            "sk": "!=null",
            "__space": "int",
            "mss": "__u32",
            "rcv_wnd": "__u32",
            "window_clamp": "__u32",
            "wscale_ok": "int",
            "rcv_wscale": "__u8",
            "init_rcv_wnd": "__u32",
            "*window_clamp": "==0",
            "*window_clamp": "= (U16_MAX << TCP_MAX_WSCALE)",
            "space": "min(*window_clamp, space)"
        }
    }
},
{
    "kprobe:tcp_select_initial_window": {
        "description": "Select the initial TCP window size.",
        "pre": {
            "sk": "!=null",
            "__space": "int",
            "mss": "__u32",
            "rcv_wnd": "__u32",
            "window_clamp": "__u32",
            "wscale_ok": "int",
            "rcv_wscale": "__u8",
            "init_rcv_wnd": "__u32",
            "*window_clamp": "!=null",
            "*window_clamp == 0": true,
            "(*window_clamp) = (U16_MAX << TCP_MAX_WSCALE)": true,
            "space": "unsigned int",
            "space = (__space < 0 ? 0 : __space)": true,
            "space = min(*window_clamp, space)": true,
            "Quantize space offering to a multiple of mss if possible.": true
        }
    }
},
{
    "kretprobe:tcp_release_cb": {
        "description": "tcp release_sock() callback",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kprobe:tcp_release_cb": {
        "description": "tcp release_sock() callback",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:mss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set `": {
        "description": "Calculate the value of mss_now based on the given formula.",
        "pre": {
            "pmtu": "!=null",
            "icsk": {
                "icsk_af_ops": {
                    "net_header_len": "!=null"
                }
            }
        }
    }
},
{
    "kprobe:mss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set `": {
        "description": "Calculate the value of mss_now based on the given formula.",
        "pre": {
            "pmtu": "!=null",
            "icsk": {
                "icsk_af_ops": {
                    "net_header_len": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:if (icsk->icsk_af_ops->net_frag_header_len)": {
        "description": "Check if the net_frag_header_len field of icsk_af_ops is non-zero.",
        "pre": {
            "icsk": {
                "!=null": true,
                "icsk_af_ops": {
                    "!=null": true,
                    "net_frag_header_len": "!=0"
                }
            }
        }
    }
},
S,
{
    "kretprobe:tcp_sync_mss": {
        "description": "Synchronize the Maximum Segment Size (MSS) for TCP connections.",
        "pre": {
            "icsk->icsk_pmtu_cookie": "pmtu",
            "icsk->icsk_mtup.enabled": true,
            "mss_now": "min(mss_now, tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low))",
            "tp->mss_cache": "mss_now"
        },
        "post": {
            "return": "mss_now"
        }
    }
},
{
    "kprobe:tcp_sync_mss": {
        "description": "Synchronize the Maximum Segment Size (MSS) for a TCP connection.",
        "pre": {
            "sk": "!=null",
            "pmtu": "!=null"
        }
    }
},
{
    "kretprobe:tcp_make_synack": {
        "description": "Allocate one skb and build a SYNACK packet.",
        "pre": {
            "sk": "!=null",
            "dst": "!=null",
            "req": "!=null",
            "foc": "!=null",
            "synack_type": "in [SYNACK_TYPE1, SYNACK_TYPE2, SYNACK_TYPE3]",
            "syn_skb": "!=null or ==null"
        }
    }
},
{
    "kprobe:tcp_make_synack": {
        "description": "Allocate one skb and build a SYNACK packet.",
        "pre": {
            "sk": "!=null",
            "dst": "!=null",
            "req": "!=null",
            "foc": "!=null",
            "synack_type": "in [SYNACK_TYPE_1, SYNACK_TYPE_2, SYNACK_TYPE_3]",
            "syn_skb": "!=null"
        }
    }
},
{
    "kretprobe:tcp_connect_init": {
        "description": "Initialize TCP connection",
        "pre": {
            "sk": "!=null",
            "dst": "!=null",
            "tp": "!=null",
            "rcv_wscale": "is_valid",
            "rcv_wnd": "is_valid"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:tcp_rtx_synack": {
        "description": "Paired with WRITE_ONCE() in sock_setsockopt()",
        "pre": {
            "sk": "!=null",
            "req": "!=null",
            "af_ops": "!=null",
            "fl": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:tcp_rtx_synack": {
        "description": "Paired with WRITE_ONCE() in sock_setsockopt()",
        "pre": {
            "sk": "!=null",
            "req": "!=null",
            "af_ops": "!=null",
            "fl": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:cookie_timestamp_decode": {
        "description": "Echoed timestamp, lowest bits contain options",
        "pre": {
            "net": "!=null",
            "tcp_opt": "!=null",
            "tcp_opt->rcv_tsecr": "!=null",
            "tcp_opt->saw_tstamp": "==false"
        }
    }
},
{
    "kprobe:cookie_timestamp_decode": {
        "description": "Echoed timestamp, lowest bits contain options.",
        "pre": {
            "net": "!=null",
            "tcp_opt": {
                "rcv_tsecr": "!=null",
                "saw_tstamp": "false"
            }
        }
    }
},
{
    "kretprobe:__ip_dev_find": {
        "description": "Find the first device with a given source address.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "devref": "in [true, false]"
        }
    }
},
{
    "kprobe:__ip_dev_find": {
        "description": "Find the first device with a given source address.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "devref": "in [true, false]"
        }
    }
},
{
    "kretprobe:inet_select_addr": {
        "description": "Select the appropriate IP address for a given destination and scope.",
        "pre": {
            "master_idx": "!=0",
            "dev": "!=null",
            "in_dev": "!=null"
        }
    }
},
{
    "kprobe:inet_select_addr": {
        "description": "Select the appropriate IP address for a given destination and scope.",
        "pre": {
            "dev": "!=null",
            "dst": "!=null",
            "scope": "!=null",
            "ifa": "!=null",
            "addr": "!=null",
            "localnet_scope": "in [RT_SCOPE_HOST, RT_SCOPE_LINK]",
            "in_dev": "!=null",
            "net": "!=null",
            "master_idx": "!=null"
        }
    }
},
{
    "kretprobe:if (!inet->inet_rcv_saddr)": {
        "description": "Check if inet_rcv_saddr is null",
        "pre": {
            "inet": {
                "inet_rcv_saddr": "==null"
            }
        }
    }
},
{
    "kprobe:ip4_datagram_connect": {
        "description": "Connects an IPv4 datagram socket.",
        "pre": {
            "sk": "!=null",
            "uaddr": "!=null",
            "addr_len": ">= sizeof(struct sockaddr_in)",
            "uaddr->sin_family": "== AF_INET",
            "inet": "!=null",
            "usin": "!=null",
            "usin->sin_addr.s_addr": "!=null",
            "oif": "!=null",
            "inet->inet_saddr": "== null",
            "ipv4_is_multicast(usin->sin_addr.s_addr)": "== false",
            "oif": "!= null",
            "fl4": "!=null",
            "rt": "!=null",
            "rt->rt_flags & RTCF_BROADCAST": "== 0",
            "sock_flag(sk, SOCK_BROADCAST)": "== false",
            "inet->inet_saddr": "== null"
        }
    }
},
"network_header_len": ">0",
{
    "kprobe:ip_local_deliver": {
        "description": "Deliver IP Packets to the higher protocol layers.",
        "pre": {
            "net": "!=null",
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:ip_cmsg_recv_offset": {
        "description": "Check if the flags contain IP_CMSG_PKTINFO",
        "pre": {
            "flags": "& IP_CMSG_PKTINFO != 0"
        }
    }
},
{
    "kprobe:ip_cmsg_recv_offset": {
        "description": "Check if the IP_CMSG_PKTINFO bit is set in the flags variable.",
        "pre": {
            "flags": {
                "!=": "null",
                "&": "IP_CMSG_PKTINFO"
            }
        }
    }
},
{
    "kretprobe:ip_setsockopt": {
        "description": "Set socket options for IP protocol.",
        "pre": {
            "sk": "!=null",
            "level": "int",
            "optname": "in [IP_PKTINFO, IP_RECVTTL, IP_RECVOPTS, IP_RECVTOS, IP_RETOPTS, IP_TOS, IP_TTL, IP_HDRINCL, IP_MTU_DISCOVER, IP_RECVERR, IP_ROUTER_ALERT, IP_FREEBIND, IP_PASSSEC, IP_TRANSPARENT, IP_MINTTL, IP_NODEFRAG, IP_BIND_ADDRESS_NO_PORT, IP_UNICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_ALL, IP_MULTICAST_LOOP, IP_RECVORIGDSTADDR, IP_CHECKSUM, IP_RECVFRAGSIZE, IP_RECVERR_RFC4884, IP_LOCAL_PORT_RANGE]",
            "optval": "sockptr_t",
            "optlen": "unsigned int"
        },
        "post": {
            "return": "int",
            "constraints": {
                "optname == IP_ROUTER_ALERT": {
                    "description": "If optname is IP_ROUTER_ALERT, call ip_ra_control with val as 1 or 0 and NULL as the third argument.",
                    "pre": {
                        "val": "in [1, 0]"
                    },
                    "call": "ip_ra_control(sk, val ? 1 : 0, NULL)"
                },
                "ip_mroute_opt(optname)": {
                    "description": "If ip_mroute_opt returns true for the given optname, call ip_mroute_setsockopt with the provided arguments.",
                    "call": "ip_mroute_setsockopt(sk, optname, optval, optlen)"
                },
                "default": {
                    "description": "For other optnames, perform the necessary operations based on the optname.",
                    "pre": {
                        "err": "int",
                        "needs_rtnl": "bool"
                    },
                    "call": "switch (optname) { /* Cases for various optnames */ }"
                }
            }
        }
    }
},
{
    "kprobe:ip_setsockopt": {
        "description": "Set socket options for IP protocol.",
        "pre": {
            "sk": "!=null",
            "level": "int",
            "optname": "in [IP_PKTINFO, IP_RECVTTL, IP_RECVOPTS, IP_RECVTOS, IP_RETOPTS, IP_TOS, IP_TTL, IP_HDRINCL, IP_MTU_DISCOVER, IP_RECVERR, IP_ROUTER_ALERT, IP_FREEBIND, IP_PASSSEC, IP_TRANSPARENT, IP_MINTTL, IP_NODEFRAG, IP_BIND_ADDRESS_NO_PORT, IP_UNICAST_IF, IP_MULTICAST_TTL, IP_MULTICAST_ALL, IP_MULTICAST_LOOP, IP_RECVORIGDSTADDR, IP_CHECKSUM, IP_RECVFRAGSIZE, IP_RECVERR_RFC4884, IP_LOCAL_PORT_RANGE]",
            "optval": "sockptr_t",
            "optlen": "unsigned int",
            "val": "int",
            "err": "int",
            "needs_rtnl": "bool"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:ip_getsockopt": {
        "description": "Get socket options for IP protocol.",
        "pre": {
            "err": "== -ENOPROTOOPT",
            "optname": "!= IP_PKTOPTIONS",
            "!ip_mroute_opt(optname)": "true"
        }
    }
},
{
    "kprobe:ip_getsockopt": {
        "description": "Get socket options for IP protocol.",
        "pre": {
            "err": "== -ENOPROTOOPT",
            "optname": "!= IP_PKTOPTIONS",
            "!ip_mroute_opt(optname)": "true"
        }
    }
},
S,
S,
{
    "kretprobe:sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),skb, 0, 0, false);hdrlen = sizeof(struct guehdr) + optlen;skb_push(skb, hdrlen);guehdr = (struct guehdr *)skb->data;guehdr->control = 0;guehdr->version = 0;guehdr->hlen = optlen >> 2;guehdr->flags = 0;guehdr->proto_ctype = *protocol;data = &guehdr[1];if (need_priv)": {
        "description": "Generate conditions for the given function",
        "pre": {
            "e": "!=null",
            "skb": "!=null",
            "dev_net(skb->dev)": "!=null",
            "protocol": "!=null",
            "optlen": ">=0",
            "guehdr": "!=null",
            "guehdr->control": "==0",
            "guehdr->version": "==0",
            "guehdr->hlen": "==(optlen >> 2)",
            "guehdr->flags": "==0",
            "guehdr->proto_ctype": "!=null",
            "data": "!=null",
            "need_priv": "is boolean"
        }
    }
},
{
    "kprobe:sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),skb, 0, 0, false);hdrlen = sizeof(struct guehdr) + optlen;skb_push(skb, hdrlen);guehdr = (struct guehdr *)skb->data;guehdr->control = 0;guehdr->version = 0;guehdr->hlen = optlen >> 2;guehdr->flags = 0;guehdr->proto_ctype = *protocol;data = &guehdr[1];if (need_priv)": {
        "description": "Helper function for building GUE header.",
        "pre": {
            "skb": "!=null",
            "e": "!=null",
            "protocol": "!=null",
            "dev_net(skb->dev)": "!=null",
            "skb->ip_summed": "in [CHECKSUM_PARTIAL, CHECKSUM_NONE]",
            "e->flags": "!=null",
            "type": "!=null",
            "guehdr": "!=null",
            "hdrlen": "sizeof(struct guehdr) + optlen",
            "skb_push(skb, hdrlen)": "no error",
            "guehdr->control": "0",
            "guehdr->version": "0",
            "guehdr->hlen": "optlen >> 2",
            "guehdr->flags": "0",
            "guehdr->proto_ctype": "*protocol",
            "data": "&guehdr[1]",
            "need_priv": "false",
            "err": "0"
        }
    }
},
{
    "kretprobe:inet_csk_accept": {
        "description": "Accept an incoming connection on a listening socket.",
        "pre": {
            "sk": "!=null",
            "flags": "int",
            "err": "int",
            "kern": "bool",
            "sk->sk_state": "==TCP_LISTEN"
        },
        "post": {
            "error": "== -EINVAL"
        }
    }
},
{
    "kprobe:inet_csk_accept": {
        "description": "Accept an incoming connection on a listening socket.",
        "pre": {
            "sk": "!=null",
            "flags": "int",
            "err": "int",
            "kern": "bool",
            "sk->sk_state": "==TCP_LISTEN"
        }
    }
},
{
    "kretprobe:inet_csk_destroy_sock": {
        "description": "Destroy a socket in the INET connection-oriented protocol family.",
        "pre": {
            "sk": {
                "sk_state": "== TCP_CLOSE",
                "sk_flag": "SOCK_DEAD",
                "sk_unhashed": "true",
                "inet_sk(sk)->inet_num": "== 0"
            }
        }
    }
},
{
    "kprobe:WARN_ON(!sk_unhashed(sk));/* If it has not 0 inet_sk(sk)->inet_num, it must be bound */": {
        "description": "Check if the socket is unhashed and has inet_num equal to 0.",
        "pre": {
            "sk": {
                "sk_unhashed": true,
                "inet_sk": {
                    "inet_num": 0
                }
            }
        }
    }
},
{
    "kretprobe:inet_csk_prepare_forced_close": {
        "description": "Release lock, decrement reference count, prepare for destruction, and set inet_num to 0.",
        "pre": {
            "sk": "!=null",
            "sk->sk_lock.slock": "locked",
            "sk->refcnt": "==2"
        },
        "post": {
            "sk->sk_lock.slock": "unlocked",
            "sk->refcnt": "==1",
            "sk->inet_sk->inet_num": "==0"
        }
    }
},
{
    "kprobe:bh_unlock_sock": {
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:sock_put": {
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:inet_csk_prepare_for_destroy_sock": {
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:inet_sk": {
        "pre": {
            "sk": "!=null",
            "inet_num": "0"
        }
    }
},
{
    "kretprobe:inet_csk_clone_lock": {
        "description": "Clone an inet socket and lock its clone.",
        "pre": {
            "sk": "!=null",
            "req": "!=null",
            "priority": "is a valid priority value"
        }
    }
},
{
    "kprobe:inet_csk_clone_lock": {
        "description": "Clone an inet socket and lock its clone.",
        "pre": {
            "sk": "!=null",
            "req": "!=null",
            "priority": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_fastopen_defer_connect": {
        "description": "Defer TCP fast open connection",
        "pre": {
            "sk": "!=null",
            "err": "int",
            "tp->fastopen_req": "null",
            "tcp_fastopen_cookie_check(sk, &mss, &cookie)": "true",
            "inet_sk(sk)->defer_connect": "1"
        }
    }
},
{
    "kprobe:tcp_fastopen_defer_connect": {
        "description": "Function to defer TCP fast open connection",
        "pre": {
            "sk": "!=null",
            "err": "int",
            "tp->fastopen_req": "!=null",
            "tp->fastopen_req->cookie": "struct tcp_fastopen_cookie",
            "mss": "u16"
        }
    }
},
{
    "kretprobe:/* Out of window, send ACK */": {
        "description": "Out of window, send ACK",
        "pre": {
            "tw": "!=null",
            "skb": "!=null",
            "th": "!=null",
            "tmp_opt": "!=null",
            "tcptw": "!=null",
            "paws_reject": "bool",
            "tmp_opt.saw_tstamp": "int",
            "tmp_opt.rcv_tsecr": "int",
            "tmp_opt.ts_recent": "int",
            "tmp_opt.ts_recent_stamp": "int",
            "tw->tw_substate": "TCP_FIN_WAIT2"
        }
    }
},
{
    "kprobe:/* Out of window, send ACK */": {
        "description": "Out of window, send ACK",
        "pre": {
            "tw": "!=null",
            "skb": "!=null",
            "th": "!=null",
            "tmp_opt": "!=null",
            "tcptw": "!=null",
            "paws_reject": "!=null",
            "tmp_opt.saw_tstamp": "!=null",
            "tmp_opt.rcv_tsecr": "!=null",
            "tmp_opt.ts_recent": "!=null",
            "tmp_opt.ts_recent_stamp": "!=null",
            "tw->tw_substate": "TCP_FIN_WAIT2"
        }
    }
},
{
    "kretprobe:tcp_time_wait_init": {
        "description": "Initialize the time wait state for TCP connections.",
        "pre": {
            "sk": "!=null",
            "tcptw": "!=null",
            "tcptw->tw_md5_key": "==null",
            "!static_branch_unlikely(&tcp_md5_needed.key)": "true",
            "tp": "!=null",
            "tp->af_specific": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:tcp_time_wait_init": {
        "description": "Initialize the time wait state for TCP connections.",
        "pre": {
            "sk": "!=null",
            "tcptw": "!=null",
            "tcptw->tw_md5_key": "==null",
            "!static_branch_unlikely(&tcp_md5_needed.key)": "true",
            "tp": "!=null",
            "tp->af_specific": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:req->rsk_window_clamp": {
        "description": "Set the window clamp value for the request socket.",
        "pre": {
            "req": "!=null",
            "window_clamp": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:req->rsk_window_clamp = window_clamp ? : dst_metric(dst, RTAX_WINDOW)": {
        "description": "Limit the window selection if the user enforces a smaller rx buffer",
        "pre": {
            "req": "!=null",
            "sk_listener": "!=null",
            "dst": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_check_req": {
        "description": "Check for pure retransmitted SYN.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "req": "!=null",
            "fastopen": "bool",
            "req_stolen": "bool",
            "tmp_opt": {
                "saw_tstamp": "0",
                "ts_recent": "!=null",
                "rcv_tsecr": "!=null"
            },
            "th": "!=null",
            "flg": "in [TCP_FLAG_RST, TCP_FLAG_SYN, TCP_FLAG_ACK]",
            "paws_reject": "bool",
            "own_req": "bool"
        }
    }
},
{
    "kprobe:tcp_check_req": {
        "description": "Check for pure retransmitted SYN.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "req": "!=null",
            "fastopen": "boolean",
            "req_stolen": "boolean"
        }
    }
},
{
    "kretprobe:tcp_child_process": {
        "description": "Process TCP child socket",
        "pre": {
            "parent": "!=null",
            "child": "!=null",
            "skb": "!=null",
            "child->sk_lock.slock": "released",
            "child->sk_napi_id": "recorded",
            "child->sk_rx_queue_mapping": "recorded",
            "!sock_owned_by_user(child)": "true"
        }
    }
},
{
    "kprobe:sk_mark_napi_id_set": {
        "description": "Set the sk_napi_id of the child socket.",
        "pre": {
            "child": "!=null",
            "skb": "!=null"
        }
    },
    "kprobe:tcp_segs_in": {
        "description": "Process TCP segments for the child socket.",
        "pre": {
            "child": "!=null",
            "skb": "!=null"
        }
    },
    "kprobe:sock_owned_by_user": {
        "description": "Check if the child socket is owned by the user.",
        "pre": {
            "child": "!=null"
        }
    }
},
{
    "if (old_state != TCP_LISTEN)": {
        "description": "Check if the socket is not in the TCP_LISTEN state.",
        "pre": {
            "old_state": "!= TCP_LISTEN"
        }
    }
},
{
    "kprobe:inet_listen": {
        "description": "Listen for incoming connections on a socket.",
        "pre": {
            "sock": "!=null",
            "backlog": "!=null",
            "sock->state": "==SS_UNCONNECTED",
            "sock->type": "==SOCK_STREAM",
            "sk->sk_state": "!=TCP_LISTEN"
        }
    }
},
S,
S,
S,
{
    "kprobe:if (sk->sk_prot->bind)": {
        "description": "Check if the socket has its own bind function.",
        "pre": {
            "sk": "!=null",
            "sk->sk_prot": "!=null",
            "sk->sk_prot->bind": "!=null"
        }
    }
},
{
    "kretprobe:inet_dgram_connect": {
        "description": "Connects a datagram socket to the specified address.",
        "pre": {
            "sock": "!=null",
            "uaddr": "!=null",
            "addr_len": ">= sizeof(uaddr->sa_family)",
            "flags": "int",
            "sk": "!=null",
            "prot": "!=null",
            "err": "int"
        },
        "post": {
            "return": "err",
            "constraints": [
                {
                    "condition": "uaddr->sa_family == AF_UNSPEC",
                    "consequence": "return prot->disconnect(sk, flags)"
                },
                {
                    "condition": "BPF_CGROUP_PRE_CONNECT_ENABLED(sk)",
                    "consequence": "return -EINVAL"
                }
            ]
        }
    }
},
{
    "kprobe:inet_dgram_connect": {
        "description": "Connects a datagram socket to a remote address.",
        "pre": {
            "sock": "!=null",
            "uaddr": "!=null",
            "addr_len": ">= sizeof(uaddr->sa_family)",
            "flags": "int",
            "sk": "!=null",
            "prot": "!=null",
            "err": "int"
        }
    }
},
{
    "kretprobe:__inet_stream_connect": {
        "description": "Connect a socket to a remote address.",
        "pre": {
            "sock": "!=null",
            "uaddr": "!=null",
            "addr_len": "!=null",
            "flags": "!=null",
            "is_sendmsg": "!=null",
            "sk": "!=null",
            "TCP_FASTOPEN_CONNECT": "is_set",
            "valid_cookie": "exists"
        }
    }
},
{
    "kprobe:__inet_stream_connect": {
        "description": "__inet_stream_connect function",
        "pre": {
            "sock": "!=null",
            "uaddr": "!=null",
            "addr_len": ">=0",
            "flags": ">=0",
            "is_sendmsg": ">=0"
        }
    }
},
{
    "kretprobe:pr_fmt": {
        "description": "IPv4: pr_fmt",
        "pre": {
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:pr_fmt": {
        "description": "Set the format string for printk messages with 'IPv4: ' prefix.",
        "pre": {
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:inet_accept": {
        "description": "Accept a pending connection. The TCP layer now gives BSD semantics.",
        "pre": {
            "sock": "!=null",
            "newsock": "!=null",
            "newsk": "!=null",
            "newsk.sk_state": "in [TCPF_ESTABLISHED, TCPF_SYN_RECV, TCPF_CLOSE_WAIT, TCPF_CLOSE]",
            "test_bit(SOCK_SUPPORT_ZC, &sock->flags)": "==1",
            "set_bit(SOCK_SUPPORT_ZC, &newsock->flags)": "==1",
            "sock_graft(newsk, newsock)": "executes successfully",
            "newsock.state": "==SS_CONNECTED"
        }
    }
},
{
    "kprobe:inet_accept": {
        "description": "Accept a pending connection. The TCP layer now gives BSD semantics.",
        "pre": {
            "sock": "!=null",
            "newsock": "!=null",
            "flags": "any",
            "kern": "any"
        }
    }
},
{
    "kretprobe:how++; /* maps 0->1 has the advantage of making bit 1 rcvs and 1->2 bit 2 snds. 2->3 */": {
        "description": "Increment the value of 'how' and perform specific mappings.",
        "pre": {
            "sock": "!=null",
            "how": "is an integer",
            "sock->sk": "is a TCP socket"
        }
    }
},
{
    "kprobe:how++; /* maps 0->1 has the advantage of making bit 1 rcvs and 1->2 bit 2 snds. 2->3 */": {
        "description": "Increment the value of how and perform some mapping operations.",
        "pre": {
            "sock": "!=null",
            "how": "unknown"
        }
    }
},
{
    "kretprobe:last_perm": {
        "description": "Assign the address of the last protocol switch entry for the given type to last_perm and iterate over the list of protocol switch entries for the given type.",
        "pre": {
            "p": "!=null",
            "p->type": ">= 0",
            "&inetsw[p->type]": "!=null",
            "last_perm": "!=null",
            "lh": "!=null"
        }
    }
},
S,
{
    "kretprobe:if (rt) return 0;": {
        "description": "Check if the variable 'rt' is non-null.",
        "pre": {
            "rt": "!=null"
        }
    }
},
S,
{
    "kretprobe:__be32 inet_current_timestamp": {
        "description": "Return IP network timestamp. Return milliseconds since midnight in network byte order.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__be32 inet_current_timestamp": {
        "description": "Return IP network timestamp. Returns milliseconds since midnight in network byte order.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:if (!encap_type)return 1;/* If this is a paged skb, make sure we pull up * whatever data we need to look at. `": {
        "description": "Check if encap_type is false and return 1 if true.",
        "pre": {
            "encap_type": "==false"
        }
    }
},
{
    "kprobe:if (!encap_type)return 1;/* If this is a paged skb, make sure we pull up * whatever data we need to look at. `": {
        "description": "Check if encap_type is not zero and return 1 if it is zero.",
        "pre": {
            "encap_type": "!=0"
        }
    }
},
S,
{
    "kprobe:xfrm4_udp_encap_rcv": {
        "description": "Receives an encapsulated UDP packet and processes it.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:rcu_read_lock": {
        "description": "Lock the RCU read-side critical section.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "fl": "!=null",
            "tos": "!=null",
            "inet": "!=null",
            "inet_opt": "!=null",
            "fl4": "!=null",
            "rt": "!=null",
            "iph": "!=null",
            "res": "!=null"
        },
        "post": {
            "inet_opt": "rcu_dereference(inet->inet_opt)",
            "fl4": "&fl->u.ip4",
            "rt": "skb_rtable(skb)",
            "packet_routed": "rt != null"
        }
    }
},
{
    "kprobe:rcu_read_lock": {
        "description": "Lock the RCU read-side critical section.",
        "pre": {}
    },
    "kprobe:rcu_dereference": {
        "description": "Dereference the RCU-protected pointer.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:__ip_queue_xmit": {
        "description": "Transmit an IP packet.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "fl": "!=null",
            "tos": "!=null",
            "inet": "!=null",
            "net": "!=null",
            "inet_opt": "!=null",
            "fl4": "!=null",
            "rt": "!=null",
            "iph": "!=null",
            "res": "!=null"
        }
    },
    "kprobe:skb_rtable": {
        "description": "Get the routing table associated with the socket buffer.",
        "pre": {
            "skb": "!=null"
        }
    },
    "kprobe:packet_routed": {
        "description": "Jump to the packet_routed label.",
        "pre": {}
    }
},
{
    "kretprobe:ip_fragment": {
        "description": "Routing by source, use new route cache, fix broken PMTU recovery and remove some redundant tests, transparent proxy revived after year coma, replace ip_reply with ip_send_reply, split fast and slow ip_build_xmit path for decreased register pressure on x86 and more readability, when call_out_firewall returns FW_QUEUE, silently drop skb instead of failing with -EPERM, copy protocol for fragments, HW checksumming for outgoing UDP datagrams, sendfile() on UDP works now.",
        "pre": {
            "net": "!=null",
            "sk": "!=null",
            "skb": "!=null",
            "mtu": ">=0",
            "output": "!=null"
        }
    }
},
S,
{
    "kretprobe:ip_send_check": {
        "description": "Ready, complete checksum",
        "pre": {
            "skb": "!=null",
            "iter": "!=null",
            "hlen": "unsigned int",
            "iph": "struct iphdr",
            "frag": "struct sk_buff",
            "frag->ip_summed": "CHECKSUM_NONE",
            "skb_reset_transport_header(frag)": "void",
            "__skb_push(frag, hlen)": "void",
            "skb_reset_network_header(frag)": "void",
            "memcpy(skb_network_header(frag), iph, hlen)": "void",
            "iter->iph": "ip_hdr(frag)",
            "iph": "iter->iph",
            "iph->tot_len": "htons(frag->len)",
            "ip_copy_metadata(frag, skb)": "void",
            "iter->offset": "iter->offset + skb->len - hlen",
            "iph->frag_off": "htons(iter->offset >> 3)",
            "frag->next": "iph->frag_off |= htons(IP_MF)"
        }
    }
},
{
    "kprobe:ip_send_check(iph);}EXPORT_SYMBOL(ip_fraglist_prepare": {
        "description": "Prepare the IP fragment list for sending.",
        "pre": {
            "skb": "!=null",
            "iter": "!=null",
            "iter->hlen": "unsigned int",
            "iter->iph": "struct iphdr",
            "iter->frag": "struct sk_buff",
            "iter->frag->ip_summed": "CHECKSUM_NONE",
            "iter->frag->next": "null",
            "skb->len": ">= iter->hlen",
            "iter->offset": "int",
            "iter->offset >> 3": "int",
            "iter->iph->tot_len": "htons(frag->len)",
            "iter->iph->frag_off": "htons(iter->offset >> 3)",
            "iter->iph->frag_off | htons(IP_MF)": "htons(IP_MF)"
        }
    }
},
{
    "kretprobe:state->ptr = hlen;/* Where to start from `": {
        "description": "Set the value of state->ptr to hlen.",
        "pre": {
            "state": "!=null",
            "hlen": "!=null"
        }
    }
},
{
    "kprobe:ip6_frag_init": {
        "description": "Initialize the ip6_frag_state structure.",
        "pre": {
            "skb": "!=null",
            "hlen": "!=null",
            "mtu": "!=null",
            "needed_tailroom": "!=null",
            "hdr_room": "!=null",
            "prevhdr": "!=null",
            "nexthdr": "!=null",
            "frag_id": "!=null",
            "state": {
                "prevhdr": "=prevhdr",
                "nexthdr": "=nexthdr",
                "frag_id": "=frag_id",
                "hlen": "=hlen",
                "mtu": "=mtu",
                "left": "skb->len - hlen"
            }
        }
    }
},
{
    "kretprobe:ip6_frag_next": {
        "description": "The function ip6_frag_next is used to handle IPv6 fragmentation.",
        "pre": {
            "skb": "!=null",
            "state": "!=null",
            "state->prevhdr": "!=null",
            "state->fragnexthdr_offset": "!=null",
            "frag": "!=null",
            "fh": "!=null",
            "len": "!=null",
            "len > state->mtu": true,
            "len = state->mtu": "len = state->mtu",
            "len <= state->mtu": false
        }
    }
},
{
    "kprobe:ip6_frag_next": {
        "description": "The function ip6_frag_next is used to handle IPv6 fragmentation.",
        "pre": {
            "len": "> state->mtu"
        }
    }
},
{
    "kretprobe:ip_send_check": {
        "description": "Ready, complete checksum",
        "pre": {
            "iph": "!=null"
        }
    }
},
{
    "kprobe:ip_send_check": {
        "description": "Ready, complete checksum",
        "pre": {
            "iph": "!=null"
        }
    }
},
{
    "kretprobe:ip_frag_ecn_table": {
        "description": "At least one fragment had CE, and others ECT_0 or ECT_1",
        "pre": {
            "ip_frag_ecn_table": "!=null",
            "ip_frag_ecn_table[0]": "INET_ECN_CE",
            "ip_frag_ecn_table[1-15]": "in [INET_ECN_ECT_0, INET_ECN_ECT_1]"
        }
    }
},
{
    "kprobe:ip_frag_ecn_table": {
        "description": "At least one fragment had CE, and others ECT_0 or ECT_1",
        "pre": {
            "ip_frag_ecn_table": "!=null",
            "ip_frag_ecn_table[0]": "INET_ECN_CE",
            "ip_frag_ecn_table[1-15]": "INET_ECN_ECT_0 or INET_ECN_ECT_1",
            "ip_frag_ecn_table[0]": "INET_ECN_CE and ip_frag_ecn_table[1-15] != INET_ECN_CE",
            "ip_frag_ecn_table[0]": "INET_ECN_CE and ip_frag_ecn_table[1-15] != INET_ECN_CE and ip_frag_ecn_table[1-15] != INET_ECN_ECT_0 and ip_frag_ecn_table[1-15] != INET_ECN_ECT_1"
        }
    }
},
{
    "kretprobe:if (!READ_ONCE(fqdir->dead))": {
        "description": "Check if the 'dead' flag of the 'fqdir' structure is not set.",
        "pre": {}
    }
},
{
    "kprobe:if (!READ_ONCE(fqdir->dead))": {
        "description": "Check if fqdir->dead is false",
        "pre": {
            "fqdir": {
                "type": "struct",
                "members": {
                    "dead": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:kill_list = llist_del_all": {
        "description": "Delete all elements from the linked list fqdir_free_list and assign the deleted elements to kill_list.",
        "pre": {
            "kill_list": "!=null",
            "fqdir_free_list": "!=null"
        }
    }
},
S,
{
    "kretprobe:inet_frag_find": {
        "description": "This pairs with WRITE_ONCE() in fqdir_pre_exit().",
        "pre": {
            "fqdir": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:inet_frag_find": {
        "description": "This pairs with WRITE_ONCE() in fqdir_pre_exit().",
        "pre": {
            "fqdir": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:inet_frag_queue_insert": {
        "description": "Insert a fragment into the inet_frag_queue.",
        "pre": {
            "q": "!=null",
            "skb": "!=null",
            "offset": "!=null",
            "end": "!=null",
            "last": "==null"
        }
    }
},
{
    "kprobe:inet_frag_queue_insert": {
        "description": "Insert a fragment into the inet_frag_queue.",
        "pre": {
            "q": "!=null",
            "skb": "!=null",
            "offset": "!=null",
            "end": "!=null",
            "last": "==null"
        }
    }
},
{
    "kretprobe:inet_frag_reasm_prepare": {
        "description": "Prepare for reassembling fragmented packets in the inet_frag_queue.",
        "pre": {
            "q": "!=null",
            "skb": "!=null",
            "parent": "!=null",
            "head": "!=null",
            "nextp": "!=null",
            "delta": "int"
        },
        "post": {
            "return": "null"
        }
    }
},
{
    "kprobe:inet_frag_reasm_prepare": {
        "description": "Prepare for reassembling fragmented packets in the inet_frag_queue.",
        "pre": {
            "q": "!=null",
            "skb": "!=null",
            "parent": "!=null",
            "head": "!=null",
            "nextp": "!=null",
            "delta": "int"
        }
    }
},
S,
S,
S,
{
    "kprobe:fl4.daddr = iph->daddr;fl4.saddr = saddr;fl4.flowi4_tos = RT_TOS(iph->tos);fl4.flowi4_oif = sk ? sk->sk_bound_dev_if : 0;fl4.flowi4_l3mdev = l3mdev_master_ifindex(dev);fl4.flowi4_mark = skb->mark;fl4.flowi4_flags = flags;fib4_rules_early_flow_dissect(net, skb, &fl4, &flkeys);rt = ip_route_output_key(net, &fl4);if (IS_ERR(rt))return PTR_ERR(rt);/* Drop old route. `": {
        "description": "Generate conditions for the given function",
        "pre": {
            "fl4.daddr": "!=null",
            "fl4.saddr": "!=null",
            "fl4.flowi4_tos": "!=null",
            "fl4.flowi4_oif": "!=null",
            "fl4.flowi4_l3mdev": "!=null",
            "fl4.flowi4_mark": "!=null",
            "fl4.flowi4_flags": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:icmp_global_allow": {
        "description": "Are we allowed to send one more ICMP message?",
        "pre": {
            "sysctl_icmp_msgs_per_sec": "> 0",
            "BH_disabled": "true"
        },
        "post": {
            "return_value": "true"
        }
    }
},
{
    "kprobe:icmp_global_allow": {
        "description": "Are we allowed to send one more ICMP message?",
        "pre": {
            "BH_disabled": true
        }
    }
},
{
    "kretprobe:__icmp_send": {
        "description": "Send an ICMP packet.",
        "pre": {
            "skb_in": "!=null",
            "type": "!=null",
            "code": "!=null",
            "info": "!=null",
            "opt": "!=null",
            "iph": "!=null",
            "(u8 *)iph < skb_in->head || (skb_network_header(skb_in) + sizeof(*iph)) > skb_tail_pointer(skb_in)": "false"
        }
    }
},
{
    "kprobe:__icmp_send": {
        "description": "Send an ICMP packet.",
        "pre": {
            "skb_in": "!=null",
            "type": "!=null",
            "code": "!=null",
            "info": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kretprobe:__ip_select_ident": {
        "description": "Selects an IP identification value for outgoing packets.",
        "pre": {
            "net": "!=null",
            "iph": "!=null",
            "segs": "int"
        }
    }
},
{
    "kprobe:__ip_select_ident": {
        "description": "__ip_select_ident(struct net net, struct iphdr iph, int segs) - Selects an IP identification value for outgoing packets.",
        "pre": {
            "net": "!=null",
            "iph": "!=null",
            "segs": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:udp_lib_get_port": {
        "description": "UDP-Lite port lookup for IPv4 and IPv6",
        "pre": {
            "sk": "!=null",
            "snum": "!=null",
            "hash2_nulladdr": "!=null"
        }
    }
},
{
    "kprobe:udp_lib_get_port": {
        "description": "UDP-Lite port lookup for IPv4 and IPv6",
        "pre": {
            "sk": "!=null",
            "snum": "!=null",
            "hash2_nulladdr": "!=null"
        }
    }
},
{
    "kretprobe:if (msg->msg_flags & MSG_OOB)": {
        "description": "Mirror BSD error message compatibility",
        "pre": {
            "msg": {
                "msg_flags": "& MSG_OOB"
            }
        }
    }
},
{
    "kprobe:if (msg->msg_flags & MSG_OOB)": {
        "description": "Mirror BSD error message compatibility",
        "pre": {
            "msg->msg_flags": "& MSG_OOB"
        }
    }
},
{
    "kretprobe:__skb_recv_udp": {
        "description": "Receives a UDP packet from the socket receive queue.",
        "pre": {
            "sk_queue->lock": "locked",
            "queue->lock": "locked",
            "sk": "!=null",
            "flags": "!=null",
            "off": "!=null",
            "err": "!=null",
            "last": "!=null",
            "skb": "!=null",
            "flags & MSG_PEEK": "false",
            "sk_can_busy_loop(sk)": "true",
            "skb_queue_empty_lockless(sk_queue)": "true"
        }
    }
},
{
    "kprobe:spin_lock": {
        "description": "Acquire the spinlock associated with sk_queue->lock.",
        "pre": {
            "sk_queue": "!=null"
        }
    },
    "kprobe:skb_queue_splice_tail_init": {
        "description": "Append the sk_queue to the end of the queue.",
        "pre": {
            "sk_queue": "!=null",
            "queue": "!=null"
        }
    },
    "kprobe:__skb_try_recv_from_queue": {
        "description": "Try to receive a skb from the queue.",
        "pre": {
            "sk": "!=null",
            "queue": "!=null",
            "flags": "!=null",
            "off": "!=null",
            "err": "!=null",
            "last": "!=null"
        }
    },
    "kprobe:udp_skb_dtor_locked": {
        "description": "Destruct the skb if flags does not contain MSG_PEEK.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:spin_unlock": {
        "description": "Release the spinlock associated with sk_queue->lock.",
        "pre": {
            "sk_queue": "!=null"
        }
    },
    "kprobe:spin_unlock_bh": {
        "description": "Release the spinlock associated with queue->lock.",
        "pre": {
            "queue": "!=null"
        }
    },
    "kprobe:sk_busy_loop": {
        "description": "Perform busy loop if sk_can_busy_loop returns true.",
        "pre": {
            "sk": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:skb_queue_empty_lockless": {
        "description": "Check if sk_queue is empty.",
        "pre": {
            "sk_queue": "!=null"
        }
    }
},
{
    "kretprobe:udp_pre_connect": {
        "description": "This check is replicated from __ip4_datagram_connect() and intended to prevent BPF program called below from accessing bytes that are out of the bound specified by user in addr_len.",
        "pre": {
            "sk": "!=null",
            "uaddr": "!=null",
            "addr_len": "< sizeof(struct sockaddr_in)"
        }
    }
},
{
    "kprobe:udp_pre_connect": {
        "description": "This check is replicated from __ip4_datagram_connect() and intended to prevent BPF program called below from accessing bytes that are out of the bound specified by user in addr_len.",
        "pre": {
            "sk": "!=null",
            "uaddr": "!=null",
            "addr_len": "< sizeof(struct sockaddr_in)"
        }
    }
},
{
    "kretprobe:udp_disconnect": {
        "description": "Break association",
        "pre": {
            "sk->sk_state": "= TCP_CLOSE",
            "inet->inet_daddr": "= 0",
            "inet->inet_dport": "= 0",
            "sock_rps_reset_rxhash(sk)": "",
            "sk->sk_bound_dev_if": "= 0",
            "!(sk->sk_userlocks & SOCK_BINDADDR_LOCK)": ""
        }
    }
},
{
    "kprobe:udp_disconnect": {
        "description": "Break association.",
        "pre": {
            "sk->sk_state": "= TCP_CLOSE",
            "inet->inet_daddr": "= 0",
            "inet->inet_dport": "= 0",
            "sock_rps_reset_rxhash(sk)": "",
            "sk->sk_bound_dev_if": "= 0",
            "!(sk->sk_userlocks & SOCK_BINDADDR_LOCK)": ""
        }
    }
},
{
    "kretprobe:spin_lock_bh": {
        "description": "Acquire the spinlock associated with hslot->lock.",
        "pre": {
            "hslot": {
                "lock": "!=null"
            }
        }
    },
    "kretprobe:reuseport_detach_sock": {
        "description": "Detach the socket from the reuseport.",
        "pre": {
            "sk": {
                "sk_reuseport_cb": "!=null"
            }
        }
    },
    "kretprobe:hslot2_neq_nhslot2": {
        "description": "Check if hslot2 is not equal to nhslot2.",
        "pre": {
            "hslot2": "!=nhslot2"
        }
    }
},
{
    "kprobe:udp_lib_rehash": {
        "description": "Rehashes the UDP table for a given socket.",
        "pre": {
            "sk": "!=null",
            "newhash": "!=null"
        }
    }
},
{
    "kretprobe:udp_lib_setsockopt": {
        "description": "Set socket options for UDP.",
        "pre": {
            "up": "!=null",
            "sk": "!=null",
            "optlen": ">=sizeof(int)",
            "copy_from_sockptr(&val, optval, sizeof(val))": "success",
            "optname": "valid"
        },
        "post": {
            "err": "integer"
        }
    }
},
{
    "kprobe:udp_lib_setsockopt": {
        "description": "Set socket options for UDP.",
        "pre": {
            "sk": "!=null",
            "level": "int",
            "optname": "int",
            "optval": "sockptr_t",
            "optlen": "unsigned int",
            "push_pending_frames": "int (*)(struct sock)"
        }
    }
},
{
    "kretprobe:udp_lib_getsockopt": {
        "description": "Get socket options for UDP protocol.",
        "pre": {
            "sk": "!=null",
            "level": "!=null",
            "optname": "!=null",
            "optval": "!=null",
            "optlen": "!=null",
            "up": "!=null",
            "val": "!=null",
            "len": "!=null",
            "len": ">=0",
            "len": "<=sizeof(int)",
            "optname": "in [UDP_CORK, UDP_ENCAP, UDP_NO_CHECK6_TX, UDP_NO_CHECK6_RX, UDP_SEGMENT, UDP_GRO]",
            "optname": "not in [UDPLITE_SEND_CSCOV, UDPLITE_RECV_CSCOV]",
            "val": "!=null",
            "optval": "!=null",
            "optlen": "!=null",
            "optlen": ">=0",
            "optlen": "<=sizeof(int)"
        },
        "post": {
            "return": "in [-ENOPROTOOPT, -EFAULT, -EINVAL, 0]"
        }
    }
},
{
    "kprobe:udp_lib_getsockopt": {
        "description": "Helper function for getting socket options in UDP.",
        "pre": {
            "sk": "!=null",
            "level": "!=null",
            "optname": "!=null",
            "optval": "!=null",
            "optlen": "!=null",
            "up": "!=null",
            "val": "!=null",
            "len": "!=null",
            "len": ">=0",
            "len": "<=sizeof(int)",
            "optname": "in [UDP_CORK, UDP_ENCAP, UDP_NO_CHECK6_TX, UDP_NO_CHECK6_RX, UDP_SEGMENT, UDP_GRO]",
            "val": "!=null",
            "val": ">=0",
            "val": "<=READ_ONCE(up->corkflag)",
            "val": "<=up->encap_type",
            "val": "<=up->no_check6_tx",
            "val": "<=up->no_check6_rx",
            "val": "<=READ_ONCE(up->gso_size)",
            "val": "<=up->gro_enabled"
        },
        "post": {
            "return": "in [-ENOPROTOOPT, -EFAULT, -EINVAL, 0]"
        }
    }
},
{
    "kretprobe:udp_poll": {
        "description": "Wait for a UDP event.",
        "pre": {
            "file": "!=null",
            "sock": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kprobe:udp_poll": {
        "description": "Wait for a UDP event.",
        "pre": {
            "file": "!=null",
            "sock": "!=null",
            "wait": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:spec_dst_fill": {
        "description": "Fill the spec_dst with the computed destination address.",
        "pre": {
            "spec_dst": "!=null",
            "skb": "!=null",
            "ip_options_compile()": "called once",
            "fib_compute_spec_dst()": "called at most once"
        }
    }
},
{
    "kretprobe:ip_options_rcv_srr": {
        "description": "Receive IP options with source routing and record route.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "opt": "!=null",
            "opt->srr": "!=null",
            "optptr": "!=null",
            "rt": "!=null",
            "iph": "!=null",
            "opt->is_strictroute": "!=null",
            "icmp_send": "!=null",
            "optptr[2]": "!=null",
            "optptr[1]": "!=null",
            "nexthop": "!=null",
            "skb->_skb_refdst": "!=null",
            "ip_route_input": "!=null",
            "iph->saddr": "!=null",
            "iph->tos": "!=null",
            "skb_dst_drop": "!=null",
            "refdst_drop": "!=null",
            "rt2": "!=null",
            "rt2->rt_type": "!=null"
        }
    }
},
{
    "kprobe:iph->daddr = nexthop; opt->is_changed = 1; if (srrptr <= srrspace)": {
        "description": "Set destination address and update opt structure",
        "pre": {
            "iph->daddr": "!=null",
            "opt->is_changed": "==1",
            "srrptr <= srrspace": "true"
        }
    }
},
{
    "kretprobe:res_table = rcu_dereference(nhg->res_table)": {
        "description": "Assign the value of rcu_dereference(nhg->res_table) to res_table.",
        "pre": {
            "nhg": "!=null",
            "nhg->resilient": "==true",
            "num_buckets": "!=null",
            "res_table": "!=null",
            "res_table->num_nh_buckets": "==num_buckets",
            "i": ">=0",
            "i": "<num_buckets"
        }
    }
},
{
    "kprobe:res_table = rcu_dereference(nhg->res_table);if (num_buckets != res_table->num_nh_buckets)goto out;for (i = 0; i < num_buckets; i++)": {
        "description": "Update the activity of the nexthop resource group.",
        "pre": {
            "net": "!=null",
            "id": "!=null",
            "num_buckets": "!=null",
            "activity": "!=null",
            "res_table": "!=null",
            "nhg": "!=null",
            "nexthop": "!=null",
            "i": "!=null",
            "nexthop->is_group": "==true",
            "nhg->resilient": "==true",
            "num_buckets": "==res_table->num_nh_buckets"
        }
    }
},
{
    "kretprobe:__ip_mc_inc_group": {
        "description": "Increment the multicast group count for the given address in the specified mode.",
        "pre": {
            "in_dev": "!=null",
            "addr": "!=null",
            "mode": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "im->sfmode": "mode",
            "im->sfcount[mode]": 1,
            "refcount_read(&im->refcnt)": 1,
            "spin_is_locked(&im->lock)": true,
            "im->timer.function": "igmp_timer_expire",
            "im->timer.data": 0,
            "im->next_rcu": "in_dev->mc_list",
            "in_dev->mc_count": "in_dev->mc_count + 1",
            "in_dev->mc_list": "im",
            "ip_mc_hash_find(in_dev, im)": "im",
            "igmpv3_del_delrec(in_dev, im)": "if CONFIG_IP_MULTICAST is defined",
            "igmp_group_added(im)": true,
            "!in_dev->dead": true
        }
    }
},
{
    "kprobe:__ip_mc_inc_group": {
        "description": "Increment the multicast group for the given in_device.",
        "pre": {
            "in_dev": "!=null",
            "addr": "!=null",
            "mode": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:ip_mc_check_igmp_query": {
        "description": "Check if the transport length is not equal to the size of struct igmphdr.",
        "pre": {
            "transport_len": "!= sizeof(struct igmphdr)"
        }
    }
},
{
    "kprobe:ip_mc_check_igmp_query": {
        "description": "Check if the transport length is not equal to the size of struct igmphdr.",
        "pre": {
            "transport_len": "!= sizeof(struct igmphdr)"
        }
    }
},
{
    "kretprobe:ip_mc_join_group": {
        "description": "Join ASM (Any-Source Multicast) group",
        "pre": {
            "sk": "!=null",
            "imr": "!=null",
            "mode": "unsigned int"
        },
        "post": {
            "return_value": "int"
        }
    }
},
{
    "kprobe:ip_mc_join_group": {
        "description": "Join ASM (Any-Source Multicast) group",
        "pre": {
            "sk": "!=null",
            "imr": "!=null",
            "mode": "unsigned int",
            "addr": "imr->imr_multiaddr.s_addr",
            "iml": "!=null",
            "i": "struct ip_mc_socklist",
            "in_dev": "struct in_device",
            "inet": "struct inet_sock",
            "net": "struct net",
            "ifindex": "int",
            "count": "int",
            "err": "int"
        }
    }
},
{
    "kretprobe:atomic_sub": {
        "description": "Subtract the size of *iml* from the value pointed to by &sk->sk_omem_alloc.",
        "pre": {
            "iml": "!=null",
            "sk": "!=null",
            "sk->sk_omem_alloc": "!=null"
        }
    },
    "kretprobe:kfree_rcu": {
        "description": "Free the memory pointed to by *iml* using RCU.",
        "pre": {
            "iml": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kretprobe:EXPORT_SYMBOL": {
        "description": "Export the symbol ip_mc_leave_group.",
        "pre": {}
    }
},
{
    "kprobe:atomic_sub(sizeof(*iml), &sk->sk_omem_alloc);kfree_rcu(iml, rcu);return 0;}out:return ret;}EXPORT_SYMBOL(ip_mc_leave_group": {
        "description": "Leave a multicast group",
        "pre": {
            "sk": "!=null",
            "imr": {
                "imr_multiaddr.s_addr": "!=null",
                "imr_ifindex": "!=null",
                "imr_address.s_addr": "!=null",
                "imr_ifindex && imr_address.s_addr && !in_dev": "!=null"
            }
        }
    }
},
{
    "kretprobe:mr_mfc_seq_next": {
        "description": "Function mr_mfc_seq_next",
        "pre": {
            "seq": "!=null",
            "v": "!=null",
            "pos": "!=null",
            "it": "!=null",
            "net": "!=null",
            "mrt": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:mr_mfc_seq_next": {
        "description": "Description of the function mr_mfc_seq_next",
        "pre": {
            "seq": "!=null",
            "v": "!=null",
            "pos": ">=0",
            "it": {
                "mrt": "!=null",
                "cache": "!=null",
                "lock": "!=null"
            },
            "it->mrt": {
                "mfc_unres_queue": "!=null"
            },
            "it->cache": {
                "in [&mrt->mfc_unres_queue, NULL]"
            },
            "list_empty(it->cache)": true,
            "list_first_entry(it->cache, struct mr_mfc, list)": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:rcu_read_lock": {
        "description": "Acquire the RCU read lock.",
        "pre": {
            "vifi": ">= 0",
            "vifi": "< mrt->maxvif",
            "mrt": "!= null"
        }
    }
},
{
    "kprobe:rcu_read_lock": {
        "description": "Acquire the RCU read-side lock.",
        "pre": {
            "": ""
        }
    }
},
{
    "kretprobe:gre_parse_header": {
        "description": "Parse GRE header and update tnl_ptk_info structure.",
        "pre": {
            "greh.flags": "== 0",
            "tpi.proto": "== htons(ETH_P_WCCP)"
        }
    }
},
{
    "kprobe:gre_parse_header": {
        "description": "Parse GRE header",
        "pre": {
            "greh->flags": "== 0",
            "tpi->proto": "== htons(ETH_P_WCCP)"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(tcp_memory_allocated)": {
        "description": "Retrieve the current allocated memory for TCP connections.",
        "pre": {
            "tcp_memory_allocated": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(tcp_memory_allocated)": {
        "description": "Current allocated memory for TCP.",
        "pre": {
            "tcp_memory_allocated": "!=null"
        }
    }
},
{
    "kretprobe:tcp_snd_cwnd_set": {
        "description": "Set the congestion window size for the TCP socket.",
        "pre": {
            "tp": "!=null",
            "TCP_INIT_CWND": "!=null"
        }
    }
},
{
    "kprobe:tcp_snd_cwnd_set": {
        "description": "Initialize the congestion window size for a TCP connection.",
        "pre": {
            "tp": "!=null",
            "TCP_INIT_CWND": "!=null"
        }
    }
},
{
    "kretprobe:tcp_poll": {
        "description": "Poll a TCP socket",
        "pre": {
            "sock": "!=null",
            "wait": "!=null",
            "file": "!=null",
            "state": "inet_sk_state_load(sk)",
            "state == TCP_LISTEN": "inet_csk_listen_poll(sk)",
            "socket locked": "false",
            "protected from async events": "true",
            "correct handling of state changes": "impossible"
        }
    }
},
{
    "tcp_poll": {
        "description": "Poll a TCP socket",
        "pre": {
            "file": "!=null",
            "sock": "!=null",
            "wait": "!=null",
            "sk": "!=null",
            "tp": "!=null",
            "shutdown": "is u8",
            "state": "is int",
            "state == TCP_LISTEN": {
                "return": "inet_csk_listen_poll(sk)"
            }
        }
    }
},
S,
S,
{
    "kretprobe:tp->fastopen_req": {
        "description": "Allocate memory for tp->fastopen_req and assign values to its fields.",
        "pre": {
            "tp": "!=null",
            "sk": "!=null",
            "msg": "!=null",
            "copied": "int",
            "size": "size_t",
            "uarg": "struct ubuf_info",
            "inet": "!=null",
            "uaddr": "!=null",
            "err": "int",
            "flags": "int",
            "sock_net(sk)->ipv4.sysctl_tcp_fastopen": "& TFO_CLIENT_ENABLE != 0",
            "uaddr->sa_family": "AF_UNSPEC"
        },
        "post": {
            "tp->fastopen_req": "!=null"
        }
    }
},
{
    "kprobe:tp->fastopen_req": {
        "description": "Allocate memory for tcp_fastopen_request and assign values to its fields.",
        "pre": {
            "tp": "!=null",
            "sk": "!=null",
            "sk->sk_allocation": "!=null",
            "tp->fastopen_req": "==null",
            "msg": "!=null",
            "size": "!=null",
            "uarg": "!=null",
            "inet": "!=null",
            "inet->defer_connect": "!=null",
            "sock_net(sk)->ipv4.sysctl_tcp_fastopen": "!=null",
            "uaddr": "!=null",
            "msg->msg_name": "!=null",
            "msg->msg_namelen": ">= sizeof(uaddr->sa_family)",
            "uaddr->sa_family": "== AF_UNSPEC"
        },
        "post": {
            "tp->fastopen_req": "!=null",
            "tp->fastopen_req->data": "== msg",
            "tp->fastopen_req->size": "== size",
            "tp->fastopen_req->uarg": "== uarg"
        }
    }
},
{
    "kretprobe:tcp_eat_recv_skb": {
        "description": "Receive and process an incoming TCP socket buffer.",
        "pre": {
            "sk": "!=null",
            "seq": "!=null",
            "off": "!=null"
        }
    }
},
{
    "kprobe:tcp_eat_recv_skb": {
        "description": "Receives a TCP socket buffer and processes it.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "seq": "!=null",
            "off": "!=null"
        }
    }
},
{
    "kretprobe:tcp_splice_read": {
        "description": "splice data from TCP socket to a pipe",
        "pre": {
            "sock": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:tcp_splice_read": {
        "description": "splice data from TCP socket to a pipe",
        "pre": {
            "sock": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:tcp_read_done": {
        "description": "Clean up data we have read: This will do ACK frames.",
        "pre": {
            "sk": "!=null",
            "len": "!=null",
            "sk->sk_state": "== TCP_LISTEN",
            "left": "!= 0",
            "skb": "!=null",
            "offset": "!=null",
            "used": "!=null",
            "seq": "!=null",
            "skb->len": "> offset + used",
            "TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN": "!= 0"
        }
    }
},
{
    "kprobe:tcp_read_done": {
        "description": "Clean up data we have read: This will do ACK frames.",
        "pre": {
            "sk": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:tcp_data_ready": {
        "description": "Check if we need to signal EPOLLIN right now",
        "pre": {
            "sk": "!=null",
            "sk->sk_userlocks & SOCK_RCVBUF_LOCK": "==0",
            "val": ">=0",
            "val << 1": "<= sk->sk_rcvbuf"
        }
    }
},
{
    "kprobe:tcp_data_ready": {
        "description": "Check if TCP data is ready for processing.",
        "pre": {
            "sk": "!=null",
            "sk->sk_userlocks & SOCK_RCVBUF_LOCK": "==0",
            "val": ">=0",
            "val << 1": "<= sk->sk_rcvbuf"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:tcp_shutdown": {
        "description": "We need to grab some memory, and put together a FIN, and then put it into the queue to be sent.",
        "pre": {
            "sk": "!=null",
            "how": "& SEND_SHUTDOWN == 0"
        }
    }
},
{
    "kprobe:tcp_shutdown": {
        "description": "We need to grab some memory, put together a FIN, and then put it into the queue to be sent.",
        "pre": {
            "how": "& SEND_SHUTDOWN == 0"
        }
    }
},
{
    "kretprobe:tcp_shutdown": {
        "description": "Shutdown the sending side of a connection. Much like close except that we don't receive shut down or sock_set_flag(sk, SOCK_DEAD).",
        "pre": {
            "sk": "!=null",
            "how": "!=null"
        }
    }
},
{
    "kprobe:tcp_shutdown": {
        "description": "Shutdown the sending side of a connection.",
        "pre": {
            "sk": "!=null",
            "how": "!=null"
        }
    }
},
{
    "kretprobe:tcp_disconnect": {
        "description": "Deny disconnect if other threads are blocked in sk_wait_event() or inet_wait_for_connect().",
        "pre": {
            "sk->sk_wait_pending": "==true",
            "old_state": "!=TCP_CLOSE"
        }
    }
},
{
    "kprobe:tcp_disconnect": {
        "description": "Deny disconnect if other threads are blocked in sk_wait_event() or inet_wait_for_connect().",
        "pre": {
            "sk->sk_wait_pending": "==true",
            "old_state": "!=TCP_CLOSE"
        }
    }
},
{
    "kretprobe:tcp_sock_set_keepidle_locked": {
        "description": "Set the keepalive time for a TCP socket",
        "pre": {
            "sk": "!=null",
            "val": ">=1 && <=MAX_TCP_KEEPIDLE",
            "sock_flag(sk, SOCK_KEEPOPEN)": "==true",
            "!((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))": "==true"
        }
    }
},
{
    "kprobe:tcp_sock_set_keepidle_locked": {
        "description": "Set the keepalive time for a TCP socket.",
        "pre": {
            "sk": "!=null",
            "val": ">=1 && <=MAX_TCP_KEEPIDLE",
            "function_pair": "keepalive_time_when"
        }
    }
},
{
    "kretprobe:tcp_sock_set_keepcnt": {
        "description": "Set the value of keepalive_probes in tcp_sk structure.",
        "pre": {
            "sk": "!=null",
            "val": ">=1 && <=MAX_TCP_KEEPCNT"
        }
    }
},
{
    "kprobe:WRITE_ONCE(tcp_sk(sk)->keepalive_probes, val);release_sock(sk);return 0;}EXPORT_SYMBOL(tcp_sock_set_keepcnt": {
        "description": "Set the value of keepalive_probes in tcp_sk structure.",
        "pre": {
            "sk": "!=null",
            "val": ">=1",
            "val": "<=MAX_TCP_KEEPCNT"
        }
    }
},
S,
{
    "switch (optname)": {
        "description": "Handle different socket options based on the value of optname.",
        "pre": {
            "sk": "!=null",
            "level": "!=null",
            "optname": "!=null",
            "optval": "!=null",
            "optlen": "!=null"
        }
    }
},
{
    "kretprobe:tcp_bpf_bypass_getsockopt": {
        "description": "Optimized getsockopt implementation for TCP_ZEROCOPY_RECEIVE.",
        "pre": {
            "level": "== SOL_TCP",
            "optname": "== TCP_ZEROCOPY_RECEIVE"
        }
    }
},
{
    "kprobe:tcp_bpf_bypass_getsockopt": {
        "description": "TCP do_tcp_getsockopt has optimized getsockopt implementation to avoid extra socket lock for TCP_ZEROCOPY_RECEIVE.",
        "pre": {
            "level": "== SOL_TCP",
            "optname": "== TCP_ZEROCOPY_RECEIVE"
        }
    }
},
{
    "kretprobe:tcp_getsockopt": {
        "description": "Get socket options for TCP protocol.",
        "pre": {
            "level": "==SOL_TCP",
            "optname": "==TCP_ZEROCOPY_RECEIVE"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:tcp_getsockopt": {
        "description": "Get socket options for TCP protocol.",
        "pre": {
            "level": "==SOL_TCP",
            "optname": "==TCP_ZEROCOPY_RECEIVE"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_md5_hash_key": {
        "description": "Hashes the TCP MD5 signature key",
        "pre": {
            "hp": "!=null",
            "key": "!=null",
            "key->keylen": "!=null",
            "key->key": "!=null",
            "sg": "!=null",
            "sg->length": "keylen",
            "hp->md5_req": "!=null"
        },
        "post": {
            "hp->md5_req->sg": "sg",
            "hp->md5_req->crypt": "NULL",
            "hp->md5_req->cryptlen": "keylen"
        }
    }
},
{
    "kprobe:tcp_md5_hash_key": {
        "description": "Hashes the TCP MD5 signature key",
        "pre": {
            "hp": "!=null",
            "key": "!=null",
            "key->keylen": ">=0"
        }
    },
    "kprobe:sg_init_one": {
        "description": "Initializes a scatterlist with a single entry",
        "pre": {
            "sg": "!=null",
            "key->key": "!=null",
            "keylen": ">=0"
        }
    },
    "kprobe:ahash_request_set_crypt": {
        "description": "Sets the cryptographic parameters for an ahash request",
        "pre": {
            "hp->md5_req": "!=null",
            "&sg": "!=null",
            "keylen": ">=0"
        }
    }
},
{
    "kretprobe:tcp_inbound_md5_hash": {
        "description": "This gets called for each TCP segment that arrives so we want to be efficient. We have 3 drop cases: o No MD5 hash and one expected. o MD5 hash and we're not expecting one. o MD5 hash and its wrong.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "saddr": "!=null",
            "daddr": "!=null",
            "family": "in [AF_INET, AF_INET6]",
            "dif": "int",
            "sdif": "int"
        }
    }
},
{
    "kprobe:tcp_inbound_md5_hash": {
        "description": "This gets called for each TCP segment that arrives so we want to be efficient. We have 3 drop cases: o No MD5 hash and one expected. o MD5 hash and we're not expecting one. o MD5 hash and it's wrong.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "saddr": "!=null",
            "daddr": "!=null",
            "family": "in [AF_INET, AF_INET6]",
            "dif": "int",
            "sdif": "int"
        }
    }
},
S,
S,
{
    "kretprobe:skb_udp_tunnel_segment": {
        "description": "Segment UDP tunnel skb",
        "pre": {
            "skb": "!=null",
            "features": "!=null",
            "gso_inner_segment": "!=null",
            "new_protocol": "!=null",
            "is_ipv6": "!=null",
            "tnl_hlen": ">=0",
            "remcsum": "in [true, false]",
            "need_csum": "in [true, false]",
            "offload_csum": "in [true, false]",
            "gso_partial": "in [true, false]",
            "segs": "!=null",
            "uh": "!=null",
            "mac_offset": ">=0",
            "protocol": "!=null",
            "mac_len": ">=0",
            "udp_offset": ">=0",
            "outer_hlen": ">=0",
            "partial": "!=null",
            "need_ipsec": "in [true, false]"
        }
    }
},
{
    "skb_udp_tunnel_segment": {
        "description": "Segment an SKB for UDP tunneling.",
        "pre": {
            "skb": "!=null",
            "features": "not in [null, undefined]",
            "gso_inner_segment": "not in [null, undefined]",
            "new_protocol": "not in [null, undefined]",
            "is_ipv6": "not in [null, undefined]",
            "tnl_hlen": ">= 0",
            "remcsum": "not in [null, undefined]",
            "need_csum": "not in [null, undefined]",
            "offload_csum": "not in [null, undefined]",
            "gso_partial": "not in [null, undefined]",
            "segs": "not in [null, undefined]",
            "uh": "not in [null, undefined]",
            "mac_offset": "not in [null, undefined]",
            "protocol": "not in [null, undefined]",
            "mac_len": "not in [null, undefined]",
            "udp_offset": "not in [null, undefined]",
            "outer_hlen": "not in [null, undefined]",
            "partial": "not in [null, undefined]",
            "need_ipsec": "not in [null, undefined]"
        }
    }
},
{
    "kretprobe:udp_gro_receive_segment": {
        "description": "Check if uh->check is false.",
        "pre": {
            "uh": {
                "check": "==false"
            }
        }
    }
},
{
    "kprobe:udp_gro_receive_segment": {
        "description": "Receives and processes a UDP segment using GRO (Generic Receive Offload).",
        "pre": {
            "head": "!=null",
            "skb": "!=null",
            "uh->check": "==0"
        }
    }
},
{
    "kretprobe:NAPI_GRO_CB(skb)->encap_mark": {
        "description": "Set encapsulation before calling into inner gro_complete() functions to make them set up the inner offsets.",
        "pre": {
            "skb": "!=null",
            "NAPI_GRO_CB(skb)->encap_mark": "==0"
        }
    }
},
{
    "kprobe:NAPI_GRO_CB(skb)->encap_mark": {
        "description": "Set encapsulation before calling into inner gro_complete() functions to make them set up the inner offsets.",
        "pre": {
            "skb": "!=null"
        },
        "post": {
            "NAPI_GRO_CB(skb)->encap_mark": "0"
        }
    }
},
S,
{
    "kprobe:BPF_CGROUP_RUN_PROG_INET4_CONNECT": {
        "description": "This will initiate an outgoing connection.",
        "pre": {
            "addr_len": "< sizeof(struct sockaddr_in)",
            "sk": "sock_owned_by_me(sk)"
        }
    }
},
{
    "kretprobe:tcp_v4_mtu_reduced": {
        "description": "Check if the MTU of the TCP connection is reduced.",
        "pre": {
            "sk": "!=null",
            "inet": "!=null",
            "dst": "!=null",
            "mtu": "!=null",
            "sk->sk_state": "in [TCPF_LISTEN, TCPF_CLOSE]",
            "tcp_sk(sk)->mtu_info": "!=null"
        },
        "post": {
            "sk->sk_err_soft": "EMSGSIZE",
            "mtu": "dst_mtu(dst)",
            "inet->pmtudisc": "IP_PMTUDISC_DONT",
            "ip_sk_accept_pmtu(sk)": "true",
            "inet_csk(sk)->icsk_pmtu_cookie": "> mtu"
        }
    }
},
{
    "kprobe:tcp_v4_mtu_reduced": {
        "description": "Check if the MTU of the TCP connection is reduced.",
        "pre": {
            "sk": "!=null",
            "sk->sk_state": "in [TCPF_LISTEN, TCPF_CLOSE]",
            "tcp_sk(sk)->mtu_info": "!=null",
            "inet_csk_update_pmtu(sk, mtu)": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_retransmit_timer": {
        "description": "Retransmit TCP packets if necessary.",
        "pre": {
            "sk": "!=null",
            "seq": "==tp->snd_una",
            "icsk->icsk_retransmits": "!=null",
            "icsk->icsk_backoff": "!=null",
            "tcp_rtx_queue_head(sk)": "!=null"
        }
    }
},
{
    "kprobe:tcp_retransmit_timer": {
        "description": "Retransmit TCP packets if necessary.",
        "pre": {
            "sk": "!=null",
            "seq": "==tp->snd_una",
            "icsk->icsk_retransmits": "!=null",
            "icsk->icsk_backoff": "!=null",
            "tcp_rtx_queue_head(sk)": "!=null",
            "icsk->icsk_rto": "!=null",
            "tp->srtt_us": "!=null",
            "inet_csk_rto_backoff(icsk, TCP_RTO_MAX)": "!=null",
            "tp->tcp_mstamp": "!=null",
            "tcp_skb_timestamp_us(skb)": "!=null",
            "usecs_to_jiffies(delta_us)": "!=null"
        }
    }
},
{
    "kretprobe:tcp_v4_send_check": {
        "description": "This routine computes an IPv4 TCP checksum.",
        "pre": {
            "skb": "!=null",
            "saddr": "!=null",
            "daddr": "!=null"
        }
    }
},
{
    "kprobe:tcp_v4_send_check": {
        "description": "This routine computes an IPv4 TCP checksum.",
        "pre": {
            "skb": "!=null",
            "saddr": "!=null",
            "daddr": "!=null"
        }
    }
},
{
    "kretprobe:md5sig": {
        "description": "Lookup TCP MD5 signature information",
        "pre": {
            "tp": "!=null",
            "sk": "!=null",
            "md5sig": "!=null",
            "key": "!=null",
            "head": "!=null",
            "node": "!=null",
            "lockdep_sock_is_held(sk)": "true"
        }
    }
},
{
    "kprobe:__tcp_md5_do_lookup": {
        "description": "Perform a TCP MD5 lookup.",
        "pre": {
            "sk": "!=null",
            "l3index": "int",
            "addr": "!=null",
            "family": "int",
            "tp": "!=null",
            "md5sig": "!=null",
            "key": "!=null",
            "mask": "!=null",
            "best_match": "!=null",
            "match": "bool",
            "rcu_read_lock_held": "bool",
            "socket_lock_held": "bool"
        }
    }
},
{
    "kretprobe:tcp_md5_do_lookup_exact": {
        "description": "Lookup the exact TCP MD5 signature key for the given parameters.",
        "pre": {
            "sk": "!=null",
            "addr": "!=null",
            "family": "int",
            "prefixlen": "u8",
            "l3index": "int",
            "flags": "u8",
            "newkey": "u8",
            "newkeylen": "u8",
            "gfp": "gfp_t"
        }
    }
},
{
    "kprobe:tcp_md5_do_lookup_exact": {
        "description": "Lookup the exact TCP MD5 signature key for the given parameters.",
        "pre": {
            "sk": "!=null",
            "addr": "!=null",
            "family": "in [AF_INET, AF_INET6]",
            "prefixlen": ">=0",
            "l3index": ">=0",
            "flags": ">=0",
            "key": "null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_v4_conn_request": {
        "description": "Never answer to SYNs sent to broadcast or multicast addresses.",
        "pre": {
            "skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)": "== 0"
        }
    }
},
{
    "kprobe:tcp_v4_conn_request": {
        "description": "Never answer to SYNs sent to broadcast or multicast",
        "pre": {
            "skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)": "!= 0",
            "goto drop": true
        }
    }
},
{
    "kretprobe:if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))newinet->tos = tcp_rsk(req)->syn_tos & ~INET_ECN_MASK;if (!dst)": {
        "description": "Set the ToS of the new socket based on the value of the incoming SYN.",
        "pre": {
            "sock_net(sk)->ipv4.sysctl_tcp_reflect_tos": "!=null",
            "tcp_rsk(req)->syn_tos": "!=null",
            "dst": "==null"
        }
    }
},
{
    "kprobe:if (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))newinet->tos = tcp_rsk(req)->syn_tos & ~INET_ECN_MASK;if (!dst)": {
        "description": "Set the ToS of the new socket based on the value of the incoming SYN.",
        "pre": {
            "sock_net(sk)->ipv4.sysctl_tcp_reflect_tos": "!=null",
            "newinet->tos": "tcp_rsk(req)->syn_tos & ~INET_ECN_MASK",
            "dst": "==null"
        }
    }
},
S,
S,
{
    "kretprobe:skb_condense": {
        "description": "Condense the given socket buffer.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:skb_condense": {
        "description": "Condense the given socket buffer (skb).",
        "pre": {
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_simple_retransmit": {
        "description": "A fastopen SYN request is stored as two separate packets within the retransmit queue. Checking the MSS of the frames in the queue will not work for the SYN packet. If we are here, it indicates a path MTU issue, so we assume the fastopen SYN was lost and mark all frames in the retransmit queue as lost. We use an MSS of -1 to mark all frames as lost, otherwise, we compute the current MSS.",
        "pre": {
            "tp->syn_data": "!=null",
            "sk->sk_state": "== TCP_SYN_SENT"
        },
        "post": {
            "mss": "-1"
        }
    }
},
{
    "kprobe:tcp_simple_retransmit": {
        "description": "A fastopen SYN request is stored as two separate packets within the retransmit queue. Checking the MSS of the frames in the queue will not work for the SYN packet. If we are here, it indicates a path MTU issue, so we assume the fastopen SYN was lost and mark all frames in the retransmit queue as lost. We use an MSS of -1 to mark all frames as lost, otherwise, we compute the current MSS.",
        "pre": {
            "sk": "!=null",
            "tp->syn_data": "!=null",
            "sk->sk_state": "== TCP_SYN_SENT"
        },
        "post": {
            "mss": "-1"
        }
    }
},
{
    "kretprobe:length--;continue;default:if (length < 2)return;opsize = *ptr++;if (opsize < 2) /* \"silly options\"": {
        "description": "This is the given function.",
        "pre": {
            "net": "!=null",
            "skb": "!=null",
            "opt_rx": "!=null",
            "estab": "!=null",
            "foc": "!=null",
            "ptr": "!=null",
            "th": "!=null",
            "length": ">0",
            "opcode": "!=null",
            "opsize": "!=null"
        }
    }
},
{
    "kprobe:length--;continue;default:if (length < 2)return;opsize = *ptr++;if (opsize < 2) /* \"silly options\"": {
        "description": "This is the given function.",
        "pre": {
            "net": "!=null",
            "skb": "!=null",
            "opt_rx": "!=null",
            "estab": "!=null",
            "foc": "!=null",
            "ptr": "!=null",
            "th": "!=null",
            "length": ">= 0",
            "opcode": "!=null",
            "opsize": "!=null"
        }
    }
},
{
    "kretprobe:while (length >= TCPOLEN_MD5SIG)": {
        "description": "Check if there is enough data remaining for MD5 signature option.",
        "pre": {
            "length": ">= TCPOLEN_MD5SIG"
        }
    }
},
{
    "kprobe:while (length >= TCPOLEN_MD5SIG)": {
        "description": "Check if there is enough data remaining for MD5 signature option.",
        "pre": {
            "length": ">= TCPOLEN_MD5SIG"
        }
    }
},
{
    "kretprobe:trace_tcp_probe": {
        "description": "Trace TCP probe function",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    },
    "kretprobe:tcp_mstamp_refresh": {
        "description": "Refresh TCP mstamp",
        "pre": {
            "tp": "!=null"
        }
    },
    "kretprobe:inet_csk(sk)->icsk_af_ops->sk_rx_dst_set": {
        "description": "Set sk_rx_dst for inet_csk",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "rcu_access_pointer(sk->sk_rx_dst)": "!=null"
        }
    }
},
{
    "kprobe:trace_tcp_probe": {
        "description": "Trace TCP probe function.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    },
    "kprobe:tcp_mstamp_refresh": {
        "description": "Refresh TCP mstamp.",
        "pre": {
            "tp": "!=null"
        }
    },
    "kprobe:inet_csk(sk)->icsk_af_ops->sk_rx_dst_set": {
        "description": "Set sk_rx_dst for inet_csk.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "rcu_access_pointer(sk->sk_rx_dst)": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:tcp_conn_request": {
        "description": "Handle TCP connection request",
        "pre": {
            "syncookies": "==2 || inet_csk_reqsk_queue_is_full(sk)",
            "isn": "!isn"
        }
    }
},
{
    "if ((syncookies == 2 || inet_csk_reqsk_queue_is_full(sk)) && !isn)": {
        "pre": {
            "syncookies": "==2",
            "inet_csk_reqsk_queue_is_full(sk)": "true",
            "isn": "false"
        }
    }
},
{
    "kretprobe:skb_tunnel_check_pmtu": {
        "description": "Check, update PMTU and trigger ICMP reply as needed",
        "pre": {
            "skb": "!=null",
            "encap_dst": "!=null",
            "headroom": "int",
            "reply": "bool"
        },
        "post": {
            "return_value": "int",
            "return_value >= -1"
        }
    }
},
{
    "kprobe:skb_tunnel_check_pmtu": {
        "description": "Check, update PMTU and trigger ICMP reply as needed",
        "pre": {
            "skb": "!=null",
            "encap_dst": "!=null",
            "headroom": "int",
            "reply": "bool"
        },
        "return": {
            "type": "int",
            "description": "0 if ICMP error not needed, length if built, negative value on error"
        }
    }
},
{
    "kretprobe:ipt_register_table": {
        "description": "Register an iptables table",
        "pre": {
            "net": "!=null",
            "table": "!=null",
            "repl": "!=null",
            "template_ops": "!=null"
        }
    }
},
{
    "kprobe:ipt_register_table": {
        "description": "Register an iptables table",
        "pre": {
            "net": "!=null",
            "table": "!=null",
            "repl": "!=null",
            "template_ops": "!=null",
            "num_ops": "=0"
        }
    }
},
{
    "kretprobe:xt_register_targets": {
        "description": "Register targets for the xt module.",
        "pre": {
            "ipt_builtin_tg": "!=null",
            "ARRAY_SIZE(ipt_builtin_tg)": "!=null",
            "ret": "< 0"
        }
    }
},
{
    "kprobe:xt_register_targets": {
        "description": "Register targets in the xt_builtin_tg array.",
        "pre": {
            "ipt_builtin_tg": "!=null",
            "ARRAY_SIZE(ipt_builtin_tg)": ">=0"
        }
    }
},
{
    "kretprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "verdict": "NF_DROP",
    "indev": "!=null",
    "outdev": "!=null",
    "table_base": "!=null",
    "e": "!=null",
    "jumpstack": "!=null",
    "stackidx": "!=null",
    "cpu": "!=null",
    "private": "!=null",
    "acpar": "!=null",
    "addend": "!=null"
},
S,
S,
{
    "kretprobe:arpt_register_table": {
        "description": "Register an ARP table in the network stack.",
        "pre": {
            "net": "!=null",
            "table": "!=null",
            "table->me": "!=null",
            "private": "!=null",
            "loc_cpu_entry": "!=null",
            "iter": "!=null",
            "private->size": ">0",
            "private->number": ">=private->initial_entries",
            "table_owner": "!=null"
        }
    }
},
{
    "kprobe:arpt_register_table": {
        "description": "Register an ARP table in the network stack.",
        "pre": {
            "net": "!=null",
            "table": "!=null",
            "table->me": "!=null",
            "private": "!=null",
            "loc_cpu_entry": "!=null",
            "table_owner": "!=null",
            "iter": "!=null",
            "private = xt_unregister_table(table)": "!=null"
        }
    }
},
{
    "kretprobe:arpt_do_table": {
        "description": "The arpt_do_table function performs table lookup and applies the corresponding actions for the given packet.",
        "pre": {
            "priv": "!=null",
            "skb": "!=null",
            "state": "!=null",
            "table": "!=null",
            "hook": "!=null",
            "nulldevname": "!=null",
            "verdict": "in [NF_DROP]",
            "arp": "!=null",
            "e": "!=null",
            "jumpstack": "!=null",
            "indev": "!=null",
            "outdev": "!=null",
            "table_base": "!=null",
            "cpu": "!=null",
            "stackidx": "!=null",
            "private": "!=null",
            "acpar": "!=null",
            "addend": "!=null"
        }
    }
},
S,
{
    "kretprobe:tcph_psh_fin_rst": {
        "description": "Set the PSH, FIN, and RST flags of the tcph structure to 0.",
        "pre": {
            "tcph->psh": "== 0",
            "tcph->fin": "== 0",
            "tcph->rst": "== 0"
        }
    }
},
{
    "kprobe:tcph->psh = 0;tcph->fin = 0;tcph->rst = 0;}} else": {
        "description": "Set the TCP header flags psh, fin, and rst to 0.",
        "pre": {
            "skb": "!=null",
            "hdr": "!=null",
            "tso": "!=null",
            "size": ">=0",
            "is_last": "boolean"
        }
    }
},
{
    "kretprobe:tso->size -= size": {
        "description": "Decrease the value of tso->size by size.",
        "pre": {
            "tso": "!=null",
            "size": "!=null"
        }
    },
    "kretprobe:tso->data += size": {
        "description": "Increase the value of tso->data by size.",
        "pre": {
            "tso": "!=null",
            "size": "!=null"
        }
    },
    "kretprobe:(tso->size == 0) && (tso->next_frag_idx < skb_shinfo(skb)->nr_frags)": {
        "description": "Check if tso->size is 0 and tso->next_frag_idx is less than skb_shinfo(skb)->nr_frags.",
        "pre": {
            "tso": "!=null",
            "skb": "!=null",
            "skb_shinfo(skb)->nr_frags": "!=null"
        }
    }
},
{
    "kprobe:tso->size -= size": {
        "description": "Decrease the value of tso->size by size.",
        "pre": {
            "tso": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:tso->data += size": {
        "description": "Increase the value of tso->data by size.",
        "pre": {
            "tso": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:(tso->size == 0) && (tso->next_frag_idx < skb_shinfo(skb)->nr_frags)": {
        "description": "Check if tso->size is 0 and tso->next_frag_idx is less than skb_shinfo(skb)->nr_frags.",
        "pre": {
            "tso": "!=null",
            "skb": "!=null",
            "tso->size": "==0",
            "tso->next_frag_idx": "< skb_shinfo(skb)->nr_frags"
        }
    }
},
{
    "kretprobe:tso->size = skb_headlen(skb) - hdr_len": {
        "description": "Assign the value of skb_headlen(skb) - hdr_len to tso->size.",
        "pre": {
            "skb": "!=null",
            "tso": "!=null",
            "hdr_len": "!=null",
            "tso->size": "!=null",
            "skb_headlen(skb) - hdr_len": "= tso->size",
            "tso->next_frag_idx": "< skb_shinfo(skb)->nr_frags",
            "tso->size": "= 0"
        }
    }
},
{
    "kprobe:tso_start": {
        "description": "Build first data",
        "pre": {
            "skb": "!=null",
            "tso": "!=null",
            "skb_is_gso_tcp(skb)": "==true",
            "tcp_hdrlen(skb)": "!=null",
            "sizeof(struct udphdr)": "!=null",
            "skb_transport_offset(skb)": "!=null",
            "tso->tlen": "!=null",
            "ntohs(ip_hdr(skb)->id)": "!=null",
            "tlen != sizeof(struct udphdr)": "==true",
            "ntohl(tcp_hdr(skb)->seq)": "!=null",
            "tso->next_frag_idx": "!=null",
            "vlan_get_protocol(skb)": "!=null",
            "htons(ETH_P_IPV6)": "!=null"
        }
    }
},
{
    "kretprobe:stats->alloc_stats.fast += pool->alloc_stats.fast;stats->alloc_stats.slow += pool->alloc_stats.slow;stats->alloc_stats.slow_high_order += pool->alloc_stats.slow_high_order;stats->alloc_stats.empty += pool->alloc_stats.empty;stats->alloc_stats.refill += pool->alloc_stats.refill;stats->alloc_stats.waive += pool->alloc_stats.waive;for_each_possible_cpu(cpu)": {
        "description": "Update the allocation statistics of the page pool for each possible CPU.",
        "pre": {
            "stats": "!=null",
            "pool": "!=null",
            "stats->alloc_stats.fast": "!=null",
            "pool->alloc_stats.fast": "!=null",
            "stats->alloc_stats.slow": "!=null",
            "pool->alloc_stats.slow": "!=null",
            "stats->alloc_stats.slow_high_order": "!=null",
            "pool->alloc_stats.slow_high_order": "!=null",
            "stats->alloc_stats.empty": "!=null",
            "pool->alloc_stats.empty": "!=null",
            "stats->alloc_stats.refill": "!=null",
            "pool->alloc_stats.refill": "!=null",
            "stats->alloc_stats.waive": "!=null",
            "pool->alloc_stats.waive": "!=null",
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:stats->alloc_stats.fast += pool->alloc_stats.fast;stats->alloc_stats.slow += pool->alloc_stats.slow;stats->alloc_stats.slow_high_order += pool->alloc_stats.slow_high_order;stats->alloc_stats.empty += pool->alloc_stats.empty;stats->alloc_stats.refill += pool->alloc_stats.refill;stats->alloc_stats.waive += pool->alloc_stats.waive;for_each_possible_cpu(cpu)": {
        "description": "Update the allocation statistics of the page pool.",
        "pre": {
            "stats": "!=null",
            "pool": "!=null",
            "stats->alloc_stats.fast": "!=null",
            "pool->alloc_stats.fast": "!=null",
            "stats->alloc_stats.slow": "!=null",
            "pool->alloc_stats.slow": "!=null",
            "stats->alloc_stats.slow_high_order": "!=null",
            "pool->alloc_stats.slow_high_order": "!=null",
            "stats->alloc_stats.empty": "!=null",
            "pool->alloc_stats.empty": "!=null",
            "stats->alloc_stats.refill": "!=null",
            "pool->alloc_stats.refill": "!=null",
            "stats->alloc_stats.waive": "!=null",
            "pool->alloc_stats.waive": "!=null",
            "cpu": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:page_pool_alloc_pages_slow": {
        "description": "Allocate pages from the page pool.",
        "pre": {
            "pool": "!=null",
            "gfp": "!=null",
            "bulk": "==PP_ALLOC_CACHE_REFILL",
            "pp_flags": "!=null",
            "pp_order": "!=null",
            "page": "!=null",
            "i": "!=null",
            "nr_pages": "!=null"
        }
    }
},
{
    "kprobe:page_pool_alloc_pages_slow": {
        "description": "Allocate pages from the page pool.",
        "pre": {
            "pool": "!=null",
            "gfp": "!=null",
            "bulk": "PP_ALLOC_CACHE_REFILL",
            "pp_flags": "!=null",
            "pp_order": "!=null",
            "page": "!=null",
            "i": ">=0",
            "nr_pages": ">=0"
        }
    }
},
{
    "kretprobe:page_pool_release_page": {
        "description": "Release a page from the page pool",
        "pre": {
            "pool": "!=null",
            "page": "!=null",
            "dma": "=page_pool_get_dma_addr(page)",
            "page": "not unmapped"
        }
    }
},
S,
{
    "kretprobe:page_pool_put_defragged_page": {
        "description": "Put a defragged page back into the page pool.",
        "pre": {
            "pool": "!=null",
            "page": "!=null",
            "dma_sync_size": ">=0",
            "allow_direct": "in [true, false]"
        },
        "post": {
            "page": "null",
            "pool": "null"
        }
    }
},
{
    "kprobe:recycle_stat_inc": {
        "description": "Increment the recycle statistics for the given pool and ring_full value.",
        "pre": {
            "pool": "!=null",
            "ring_full": "!=null"
        }
    },
    "kprobe:page_pool_return_page": {
        "description": "Return the page to the page pool.",
        "pre": {
            "pool": "!=null",
            "page": "!=null"
        }
    },
    "kprobe:page_pool_put_defragged_page": {
        "description": "Put the defragged page into the page pool.",
        "pre": {
            "pool": "!=null",
            "page": "!=null",
            "dma_sync_size": ">=0",
            "allow_direct": "!=null"
        }
    }
},
{
    "kretprobe:page_pool_put_page_bulk": {
        "description": "Put a page into the page pool in bulk.",
        "pre": {
            "pool": "!=null",
            "data": "!=null",
            "count": ">=0",
            "i": ">=0",
            "bulk_len": ">=0",
            "in_softirq": "bool",
            "page": "!=null",
            "page_frag_case": "not last user"
        },
        "post": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:page_pool_put_page_bulk": {
        "description": "Put a page into the page pool in bulk.",
        "pre": {
            "pool": "!=null",
            "data": "!=null",
            "count": ">=0",
            "in_softirq": "bool",
            "page": "!=null",
            "!page_pool_is_last_frag(pool, page)": true
        }
    }
},
{
    "kretprobe:page_pool_unlink_napi": {
        "description": "To avoid races with recycling and additional barriers, make sure pool and NAPI are unlinked when NAPI is disabled.",
        "pre": {
            "pool->p.napi": "!=null",
            "!test_bit(NAPI_STATE_SCHED, &pool->p.napi->state)": "true",
            "READ_ONCE(pool->p.napi->list_owner)": "!= -1"
        },
        "post": {
            "WRITE_ONCE(pool->p.napi, NULL)": "true"
        }
    }
},
{
    "kprobe:page_pool_unlink_napi": {
        "description": "Unlink the page pool and NAPI when NAPI is disabled.",
        "pre": {
            "pool->p.napi": "!=null",
            "test_bit(NAPI_STATE_SCHED, &pool->p.napi->state)": "false",
            "READ_ONCE(pool->p.napi->list_owner)": "!= -1"
        },
        "post": {
            "WRITE_ONCE(pool->p.napi, NULL)": "true"
        }
    }
},
S,
S,
{
    "kretprobe:page_pool_return_skb_page": {
        "description": "Return a page to the page pool.",
        "pre": {
            "page": "!=null",
            "napi_safe": "in [true, false]",
            "page->pp_magic & ~0x3UL": "!= PP_SIGNATURE"
        },
        "post": {
            "return": "false",
            "pp": "!=null",
            "allow_direct": "in [true, false]"
        }
    }
},
{
    "kprobe:page_pool_return_skb_page": {
        "description": "Return the skb page to the page pool.",
        "pre": {
            "page": "!=null",
            "napi_safe": "bool",
            "napi": "struct napi_struct",
            "pp": "struct page_pool",
            "allow_direct": "bool",
            "page->pp_magic": "& ~0x3UL != PP_SIGNATURE"
        }
    }
},
{
    "kretprobe:dev_add_offload": {
        "description": "Register offload handlers",
        "pre": {
            "po": "!=null"
        }
    }
},
{
    "kprobe:dev_add_offload": {
        "description": "Register offload handlers",
        "pre": {
            "po": "!=null"
        }
    }
},
{
    "kretprobe:__dev_remove_offload": {
        "description": "Remove a protocol offload handler that was previously added to the kernel offload handlers by dev_add_offload().",
        "pre": {
            "po": "!=null"
        }
    }
},
{
    "kprobe:__dev_remove_offload": {
        "description": "Remove a protocol offload handler that was previously added to the kernel offload handlers by dev_add_offload().",
        "pre": {
            "po": "!=null"
        }
    }
},
{
    "kretprobe:napi_gro_flush": {
        "description": "Flushes the GRO (Generic Receive Offload) list for a given NAPI (Network API) structure.",
        "pre": {
            "napi": "!=null",
            "flush_old": "bool"
        }
    }
},
{
    "kprobe:napi_gro_flush": {
        "description": "Flushes the GRO (Generic Receive Offload) list for a given NAPI (New API) structure.",
        "pre": {
            "napi": "!=null",
            "flush_old": "bool"
        }
    }
},
S,
S,
{
    "kretprobe:sum = csum_fold(csum_add(NAPI_GRO_CB(skb)->csum, wsum))": {
        "description": "Calculate the checksum by folding the sum of NAPI_GRO_CB(skb)->csum and wsum using csum_fold.",
        "pre": {
            "skb": "!=null",
            "wsum": "!=null",
            "NAPI_GRO_CB(skb)->csum": "!=null"
        }
    }
},
{
    "kprobe:sum = csum_fold(csum_add(NAPI_GRO_CB(skb)->csum, wsum))": {
        "description": "Calculate the checksum by adding the pseudo checksum from NAPI_GRO_CB(skb)->csum and wsum, and then folding the result.",
        "pre": {
            "skb": "!=null",
            "wsum": "!=null",
            "NAPI_GRO_CB(skb)->csum": "!=null"
        }
    }
},
{
    "kretprobe:error = sock_error": {
        "description": "Get the error code associated with the socket.",
        "pre": {
            "sk": "!=null",
            "queue": "!=null",
            "err": "int",
            "timeo_p": "long",
            "skb": "!=null"
        },
        "post": {
            "error": "int",
            "queue->prev": "skb"
        }
    },
    "kretprobe:READ_ONCE(queue->prev) != skb": {
        "description": "Check if the previous packet in the queue is not equal to the current packet.",
        "pre": {
            "queue": "!=null",
            "skb": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:error = sock_error": {
        "description": "Check if there is an error in the socket.",
        "pre": {
            "sk": "!=null",
            "queue": "!=null",
            "err": "int",
            "timeo_p": "long",
            "skb": "!=null"
        },
        "post": {
            "error": "int"
        },
        "goto": {
            "out_err": "if (error)"
        },
        "goto2": {
            "out": "if (READ_ONCE(queue->prev) != skb)"
        }
    }
},
{
    "kretprobe:__skb_try_recv_datagram": {
        "description": "Receives a datagram from the socket buffer queue.",
        "pre": {
            "sk": "!=null",
            "queue": "!=null",
            "flags": "unsigned",
            "off": "!=null",
            "err": "!=null",
            "last": "!=null"
        },
        "post": {
            "return": {
                "value": "null",
                "err": "-EAGAIN or error value"
            }
        }
    }
},
{
    "kprobe:__skb_try_recv_datagram": {
        "description": "Returns NULL with @err set to -EAGAIN if no data was available or to some other value if an error was detected. It does not lock socket since today. This function is free of race conditions. This measure shouldcan improve significantly datagram socket latencies at high loads, when data copying to user space takes lots of time. (BTW I've just killed the last cli() in IPIPv6corenetlinkpacket 8) Great win.) --ANK (980729) The order of the tests when we find no data waiting are specified quite explicitly by POSIX 1003.1g, don't change them without having the standard around please.",
        "pre": {
            "sk": "!=null",
            "queue": "!=null",
            "flags": "!=null",
            "off": "!=null",
            "err": "!=null",
            "last": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__kfree_skb(skb);}EXPORT_SYMBOL(__skb_free_datagram_locked": {
        "description": "Free a socket buffer and its associated resources.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        },
        "post": {
            "return_value": "false",
            "sk_peek_offset_bwd": "called",
            "skb_orphan": "called",
            "unlock_sock_fast": "called"
        }
    }
},
{
    "kprobe:__kfree_skb(skb);}EXPORT_SYMBOL(__skb_free_datagram_locked": {
        "description": "__skb_free_datagram_locked(struct sock sk, struct sk_buff skb, int len) - Frees a datagram socket buffer.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:skb_kill_datagram": {
        "description": "Free a datagram skbuff forcibly",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:skb_kill_datagram": {
        "description": "Free a datagram skbuff forcibly",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:skb_copy_and_hash_datagram_iter": {
        "description": "Copy datagram to an iovec iterator and update a hash.",
        "pre": {
            "skb": "!=null",
            "offset": ">=0",
            "to": "!=null",
            "len": ">=0",
            "hash": "!=null"
        }
    }
},
{
    "kprobe:skb_copy_and_hash_datagram_iter": {
        "description": "Copy datagram to an iovec iterator and update a hash.",
        "pre": {
            "skb": "!=null",
            "offset": ">=0",
            "to": "!=null",
            "len": ">=0",
            "hash": "!=null"
        }
    }
},
{
    "kretprobe:skb_copy_datagram_iter": {
        "description": "Copy a datagram to an iovec iterator.",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "to": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:skb_copy_datagram_iter": {
        "description": "Copy a datagram to an iovec iterator.",
        "pre": {
            "skb": "!=null",
            "offset": ">=0",
            "to": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:skb_copy_datagram_from_iter": {
        "description": "Copy a datagram from an iov_iter.",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "from": "!=null",
            "len": "!=null"
        },
        "post": {
            "return_value": "in [0, -EFAULT]"
        }
    }
},
{
    "kprobe:skb_copy_datagram_from_iter": {
        "description": "Copy a datagram from an iov_iter.",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "from": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:last_head = head;refs++;continue;}}if (refs)": {
        "description": "This function updates the value of 'last_head' with 'head', increments 'refs', and continues execution. If 'refs' is non-zero, the following code block is executed.",
        "pre": {
            "msg": "!=null",
            "msg->msg_ubuf": "!=null",
            "msg->sg_from_iter": "!=null",
            "sk": "!=null",
            "skb": "!=null",
            "from": "!=null",
            "length": ">=0",
            "frag": "in [0, MAX_SKB_FRAGS]",
            "pages": "array of size MAX_SKB_FRAGS",
            "refs": ">=0",
            "order": ">=0",
            "n": ">=0",
            "start": ">=0",
            "copied": ">=0",
            "truesize": ">=0",
            "head": "!=null",
            "last_head": "!=null",
            "size": ">=0"
        }
    }
},
{
    "last_head = head;refs++;continue;}}if (refs)": {
        "description": "This function updates the value of `last_head` with the value of `head`, increments the value of `refs`, and continues execution if `refs` is non-zero.",
        "pre": {
            "msg": "!=null",
            "sk": "!=null",
            "skb": "!=null",
            "from": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:skb_copy_and_csum_datagram_msg": {
        "description": "Copy and checksum skb to user iovec.",
        "pre": {
            "skb": "!=null",
            "hlen": ">=0",
            "msg": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EFAULT]"
        }
    }
},
{
    "kprobe:skb_copy_and_csum_datagram_msg": {
        "description": "Copy and checksum skb to user iovec.",
        "pre": {
            "skb": "!=null",
            "hlen": ">=0",
            "msg": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EFAULT]"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:dst_dev_put": {
        "description": "Operations to mark dst as DEAD and clean up the net device referenced by dst.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kprobe:dst_dev_put": {
        "description": "Operations to mark dst as DEAD and clean up the net device referenced by dst.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:fib_default_rule_add": {
        "description": "Add a default rule to the rules list.",
        "pre": {
            "ops": "!=null",
            "pref": "!=null",
            "table": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:fib_default_rule_add": {
        "description": "Add a default rule to the rules list.",
        "pre": {
            "ops": "!=null",
            "pref": "!=null",
            "table": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:skb_flow_dissector_init": {
        "description": "Initialize the skb_flow_dissector structure with the given flow_dissector and key.",
        "pre": {
            "flow_dissector": "!=null",
            "key": "!=null",
            "key_count": ">=0",
            "key.target_offset": "<=USHRT_MAX"
        }
    }
},
{
    "kprobe:skb_flow_dissector_init": {
        "description": "Initialize the skb_flow_dissector structure with the given flow_dissector and key.",
        "pre": {
            "flow_dissector": "!=null",
            "key": "!=null",
            "key_count": ">=0",
            "key.target_offset": "<=USHRT_MAX"
        }
    }
},
{
    "kretprobe:__skb_flow_get_ports": {
        "description": "Extract the upper layer ports and return them.",
        "pre": {
            "skb": "!=null",
            "thoff": "int",
            "ip_proto": "u8",
            "data": "!=null",
            "hlen": "int"
        }
    }
},
{
    "kprobe:__skb_flow_get_ports": {
        "description": "Extract the upper layer ports and return them.",
        "pre": {
            "skb": "!=null",
            "thoff": ">=0",
            "ip_proto": ">=0",
            "data": "!=null",
            "hlen": ">=0"
        }
    }
},
{
    "kretprobe:skb_flow_get_icmp_tci": {
        "description": "Extract ICMP(6) Type, Code, and Identifier fields",
        "pre": {
            "skb": "!=null",
            "key_icmp": "!=null",
            "data": "!=null",
            "thoff": ">=0",
            "hlen": ">=0"
        }
    }
},
{
    "kprobe:skb_flow_get_icmp_tci": {
        "description": "Extract ICMP(6) Type, Code, and Identifier fields.",
        "pre": {
            "skb": "!=null",
            "key_icmp": "!=null",
            "data": "!=null",
            "thoff": ">=0",
            "hlen": ">=0"
        }
    }
},
{
    "kretprobe:skb_flow_dissect_ct": {
        "description": "Dissect the skb and extract connection tracking information.",
        "pre": {
            "skb": "!=null",
            "flow_dissector": "!=null",
            "target_container": "!=null",
            "ctinfo_map": "!=null",
            "mapsize": ">=0",
            "post_ct": "bool",
            "zone": ">=0"
        }
    }
},
{
    "kprobe:skb_flow_dissect_ct": {
        "description": "Dissect the flow of the skb and perform connection tracking.",
        "pre": {
            "skb": "!=null",
            "flow_dissector": "!=null",
            "target_container": "!=null",
            "ctinfo_map": "!=null",
            "mapsize": "!=null",
            "post_ct": "!=null",
            "zone": "!=null"
        }
    }
},
{
    "kretprobe:skb_flow_dissect_tunnel_info": {
        "description": "A quick check to see if there might be something to do.",
        "pre": {
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_KEYID)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_CONTROL)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_PORTS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IP)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_OPTS)": true,
            "return": true,
            "info": "!=null",
            "key": "!=null",
            "ip_tunnel_info_af(info)": "!=null"
        }
    }
},
{
    "kprobe:skb_flow_dissect_tunnel_info": {
        "description": "A quick check to see if there might be something to do.",
        "pre": {
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_KEYID)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_CONTROL)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_PORTS)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_IP)": true,
            "!dissector_uses_key(flow_dissector,FLOW_DISSECTOR_KEY_ENC_OPTS)": true,
            "return": true,
            "info": "!=null",
            "key": "!=null",
            "ip_tunnel_info_af(info)": "!=null"
        }
    }
},
{
    "kretprobe:skb_flow_dissect_ct": {
        "description": "This function is used to dissect the flow of a socket buffer (skb) and perform connection tracking (ct) operations.",
        "pre": {
            "skb": "!=null",
            "flow_dissector": "!=null",
            "target_container": "!=null",
            "ctinfo_map": "!=null",
            "mapsize": ">=0",
            "post_ct": "boolean",
            "zone": ">=0"
        }
    }
},
{
    "kprobe:skb_flow_dissect_ct": {
        "description": "Dissect the skb and extract connection tracking information.",
        "pre": {
            "skb": "!=null",
            "flow_dissector": "!=null",
            "target_container": "!=null",
            "ctinfo_map": "!=null",
            "mapsize": "!=null",
            "post_ct": "!=null",
            "zone": "!=null"
        }
    }
},
{
    "kretprobe:__skb_get_hash": {
        "description": "Calculate a flow hash based on src/dst addresses and src/dst port numbers.",
        "pre": {
            "skb": "!=null",
            "skb->hash": "!=0",
            "skb->l4_hash": "in [0, 1]"
        }
    }
},
{
    "kprobe:__skb_get_hash": {
        "description": "calculate a flow hash",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:sk_filter_trim_cap": {
        "description": "Run a packet through a socket filter",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "cap": ">=0"
        }
    }
},
{
    "kprobe:sk_filter_trim_cap": {
        "description": "Run a packet through a socket filter",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "cap": ">=0"
        }
    }
},
{
    "kretprobe:rtnl_net_notifyid": {
        "description": "This function returns the id of a peer netns. If no id is assigned, one will be allocated and returned.",
        "pre": {
            "net": "!=null",
            "cmd": "!=null",
            "id": "==NET_ID_ZERO || >0",
            "portid": "!=null",
            "nlh": "!=null",
            "gfp": "!=null"
        }
    },
    "helper:peernet2id": {
        "description": "Magic value for id 0.",
        "pre": {
            "net": "!=null",
            "peer": "!=null"
        }
    }
},
{
    "kprobe:rtnl_net_notifyid": {
        "description": "This function returns the id of a peer netns. If no id is assigned, one will be allocated and returned.",
        "pre": {
            "net": "!=null",
            "cmd": "!=null",
            "id": "==NET_ID_ZERO || >0",
            "portid": "!=null",
            "nlh": "!=null",
            "gfp": "!=null"
        }
    },
    "helper:peernet2id": {
        "description": "Magic value for id 0.",
        "pre": {
            "net": "!=null",
            "peer": "!=null"
        }
    }
},
{
    "kretprobe:net_ns_barrier": {
        "description": "Wait until concurrent net_cleanup_work is done. Cleanup_net runs from work queue and will first remove namespaces from the global list, then run net exit functions. Call this in module exit path to make sure that all netns ->exit ops have been invoked before the function is removed.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kprobe:net_ns_barrier": {
        "description": "Wait until concurrent net_cleanup_work is done. Cleanup_net runs from work queue and will first remove namespaces from the global list, then run net exit functions. Call this in module exit path to make sure that all netns ->exit ops have been invoked before the function is removed.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kretprobe:sk_ns_capable": {
        "description": "General socket capability test",
        "pre": {
            "sk": "!=null",
            "user_ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:sk_ns_capable": {
        "description": "General socket capability test",
        "pre": {
            "sk": "!=null",
            "user_ns": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:sk_capable": {
        "description": "Socket global capability test",
        "pre": {
            "sk": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:sk_capable": {
        "description": "Socket global capability test",
        "pre": {
            "sk": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:sk_net_capable": {
        "description": "Network namespace socket capability test",
        "pre": {
            "sk": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:sk_net_capable": {
        "description": "Network namespace socket capability test",
        "pre": {
            "sk": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:__sk_backlog_rcv": {
        "description": "Receives a backlog packet on a socket.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:__sk_backlog_rcv": {
        "description": "__sk_backlog_rcv function",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:__sock_queue_rcv_skb": {
        "description": "The __sock_queue_rcv_skb function",
        "pre": {
            "skb": "!=null",
            "list": "!=null",
            "sk": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:__sock_queue_rcv_skb": {
        "description": "Enqueue a received socket buffer into the receive queue of a socket.",
        "pre": {
            "list": "!=null",
            "flags": "!=null",
            "skb": "!=null",
            "sk": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:sock_bindtoindex_locked": {
        "description": "Binds a socket to a specific network interface.",
        "pre": {
            "ret": "-EPERM",
            "sk->sk_bound_dev_if": "!=null",
            "!ns_capable(net->user_ns, CAP_NET_RAW)": "true",
            "ifindex": "< 0",
            "ret": "-EINVAL"
        }
    }
},
{
    "kprobe:sock_bindtoindex_locked": {
        "description": "Binds a socket to a specific network interface.",
        "pre": {
            "sk": "!=null",
            "ifindex": ">= 0"
        }
    }
},
S,
S,
{
    "kretprobe:sk_mem_reclaim": {
        "description": "Reclaim the reserves and obey rmem limits again.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kretprobe:sk_clear_memalloc": {
        "description": "Clear the SOCK_MEMALLOC flag and reset the sk_allocation.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kretprobe:__sk_backlog_rcv": {
        "description": "Receive a backlog packet on a socket.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:sk_mem_reclaim": {
        "description": "Reclaim the reserves and obey rmem limits again.",
        "pre": {
            "sk": "!=null",
            "sk->sk_allocation": "&= ~__GFP_MEMALLOC",
            "static_branch_dec(&memalloc_socks_key)": "called",
            "SOCK_MEMALLOC": "cleared"
        }
    }
},
{
    "kretprobe:sk_alloc": {
        "description": "All socket objects are allocated here",
        "pre": {
            "net": "!=null",
            "family": "int",
            "priority": "gfp_t",
            "prot": "!=null",
            "kern": "int"
        }
    }
},
{
    "kprobe:sk_alloc": {
        "description": "All socket objects are allocated here.",
        "pre": {
            "net": "!=null",
            "family": "int",
            "priority": "gfp_t",
            "prot": "!=null",
            "kern": "int"
        }
    }
},
{
    "kretprobe:pr_fmt": {
        "description": "General socket capability test",
        "pre": {
            "sk": "!=null",
            "user_ns": "!=null",
            "cap": "!=null"
        }
    }
},
S,
{
    "kretprobe:refcount_add": {
        "description": "This function adds the truesize of skb to sk_wmem_alloc and takes a reference count on sk.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "skb->truesize": ">=0",
            "&sk->sk_wmem_alloc": "!=null"
        }
    }
},
{
    "kprobe:refcount_add": {
        "description": "Increments the reference count of the skb and updates the sk_wmem_alloc value of the sock.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "skb->truesize": ">=0",
            "&sk->sk_wmem_alloc": "!=null"
        }
    }
},
{
    "kretprobe:skb_orphan_partial": {
        "description": "Drivers depend on in-order delivery for crypto offload, partial orphan breaks out-of-order-OK logic.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:skb_orphan_partial": {
        "description": "Drivers depend on in-order delivery for crypto offload, partial orphan breaks out-of-order-OK logic.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:__sock_cmsg_send": {
        "description": "__sock_cmsg_send function",
        "pre": {
            "sk": "!=null",
            "cmsg": "!=null",
            "sockc": "!=null",
            "cmsg->cmsg_type": "in [SO_MARK, SO_TIMESTAMPING_OLD, SCM_TXTIME, SCM_RIGHTS, SCM_CREDENTIALS]",
            "cmsg->cmsg_type == SO_MARK": {
                "pre": {
                    "!ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW)": true,
                    "!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)": true
                },
                "post": {
                    "return": "-EPERM"
                }
            },
            "cmsg->cmsg_type == SO_TIMESTAMPING_OLD": {
                "pre": {
                    "cmsg->cmsg_len == CMSG_LEN(sizeof(u32))": true
                },
                "post": {
                    "tsflags": "(u32)CMSG_DATA(cmsg)",
                    "tsflags & ~SOF_TIMESTAMPING_TX_RECORD_MASK": "0"
                }
            },
            "cmsg->cmsg_type == SCM_TXTIME": {
                "pre": {
                    "!sock_flag(sk, SOCK_TXTIME)": true,
                    "cmsg->cmsg_len == CMSG_LEN(sizeof(u64))": true
                },
                "post": {
                    "sockc->transmit_time": "get_unaligned((u64)CMSG_DATA(cmsg))"
                }
            },
            "cmsg->cmsg_type == SCM_RIGHTS || cmsg->cmsg_type == SCM_CREDENTIALS": {
                "pre": {
                    "cmsg->cmsg_len == CMSG_LEN(sizeof(u32))": true
                },
                "post": {
                    "return": "-EINVAL"
                }
            },
            "default": {
                "post": {
                    "return": "-EINVAL"
                }
            }
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:__sock_cmsg_send": {
        "description": "__sock_cmsg_send function",
        "pre": {
            "sk": "!=null",
            "cmsg": "!=null",
            "sockc": "!=null",
            "cmsg->cmsg_type": "in [SO_MARK, SO_TIMESTAMPING_OLD, SCM_TXTIME, SCM_RIGHTS, SCM_CREDENTIALS]",
            "cmsg->cmsg_type == SO_MARK": {
                "pre": {
                    "!ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW)": true,
                    "!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)": true
                },
                "post": {
                    "return": "-EPERM"
                }
            },
            "cmsg->cmsg_type == SO_TIMESTAMPING_OLD": {
                "pre": {
                    "cmsg->cmsg_len": "CMSG_LEN(sizeof(u32))",
                    "tsflags": "=(u32)CMSG_DATA(cmsg)",
                    "tsflags & ~SOF_TIMESTAMPING_TX_RECORD_MASK": true
                },
                "post": {
                    "sockc->tsflags &= ~SOF_TIMESTAMPING_TX_RECORD_MASK": true,
                    "sockc->tsflags |= tsflags": true
                }
            },
            "cmsg->cmsg_type == SCM_TXTIME": {
                "pre": {
                    "!sock_flag(sk, SOCK_TXTIME)": true,
                    "cmsg->cmsg_len": "CMSG_LEN(sizeof(u64))",
                    "sockc->transmit_time": "get_unaligned((u64)CMSG_DATA(cmsg))"
                }
            },
            "cmsg->cmsg_type == SCM_RIGHTS || cmsg->cmsg_type == SCM_CREDENTIALS": {
                "pre": {
                    "cmsg->cmsg_type": "in SOL_UNIX"
                }
            },
            "default": {
                "post": {
                    "return": "-EINVAL"
                }
            }
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:sock_cmsg_send": {
        "description": "Send control message through a socket.",
        "pre": {
            "sk": "!=null",
            "cmsg": "!=null",
            "sockc": "!=null",
            "cmsg->cmsg_type": "in [SO_MARK, SO_TIMESTAMPING_OLD, SCM_TXTIME]",
            "cmsg->cmsg_len": {
                "SO_MARK": "== CMSG_LEN(sizeof(u32))",
                "SO_TIMESTAMPING_OLD": "== CMSG_LEN(sizeof(u32))",
                "SCM_TXTIME": "== CMSG_LEN(sizeof(u64))"
            },
            "ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW)": "== true",
            "ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)": "== true",
            "sock_flag(sk, SOCK_TXTIME)": "== true",
            "get_unaligned((u64)CMSG_DATA(cmsg))": "!= null"
        },
        "post": {
            "return": "in [0, -EPERM, -EINVAL]"
        }
    }
},
{
    "kprobe:sock_cmsg_send": {
        "description": "Send control message through a socket.",
        "pre": {
            "sk": "!=null",
            "cmsg": "!=null",
            "sockc": "!=null",
            "cmsg->cmsg_type": "in [SO_MARK, SO_TIMESTAMPING_OLD, SCM_TXTIME]",
            "cmsg->cmsg_len": "!=null",
            "cmsg->cmsg_len == CMSG_LEN(sizeof(u32)) when cmsg->cmsg_type == SO_MARK",
            "cmsg->cmsg_len == CMSG_LEN(sizeof(u32)) when cmsg->cmsg_type == SO_TIMESTAMPING_OLD",
            "cmsg->cmsg_len == CMSG_LEN(sizeof(u64)) when cmsg->cmsg_type == SCM_TXTIME",
            "ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW) || ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN) when cmsg->cmsg_type == SO_MARK",
            "cmsg->cmsg_len != CMSG_LEN(sizeof(u32)) when cmsg->cmsg_type != SO_MARK",
            "cmsg->cmsg_len != CMSG_LEN(sizeof(u32)) when cmsg->cmsg_type != SO_TIMESTAMPING_OLD",
            "cmsg->cmsg_len != CMSG_LEN(sizeof(u64)) when cmsg->cmsg_type != SCM_TXTIME",
            "tsflags & ~SOF_TIMESTAMPING_TX_RECORD_MASK == 0 when cmsg->cmsg_type == SO_TIMESTAMPING_OLD",
            "sock_flag(sk, SOCK_TXTIME) when cmsg->cmsg_type == SCM_TXTIME"
        }
    }
},
{
    "kretprobe:skb_page_frag_refill": {
        "description": "Check that a page_frag contains enough room",
        "pre": {
            "sz": "<= PAGE_SIZE",
            "pfrag": "!= null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:skb_page_frag_refill": {
        "description": "Check that a page_frag contains enough room.",
        "pre": {
            "sz": "<= PAGE_SIZE",
            "pfrag": "!= null",
            "gfp": "is a valid gfp_t value"
        }
    }
},
{
    "kretprobe:sk_wait_data": {
        "description": "Wait for data to arrive at sk_receive_queue",
        "pre": {
            "sk": "!=null",
            "timeo": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:sk_wait_data": {
        "description": "Wait for data to arrive at sk_receive_queue",
        "pre": {
            "sk": "!=null",
            "timeo": "!=null",
            "skb": "!=null"
        }
    }
},
S,
{
    "kprobe:__sk_mem_raise_allocated": {
        "description": "__sk_mem_schedule(), but does not update sk_forward_alloc",
        "pre": {
            "sk": "!=null",
            "size": ">=0",
            "amt": ">=0",
            "kind": ">=0"
        }
    }
},
{
    "kretprobe:__sk_mem_reduce_allocated": {
        "description": "__sk_mem_reduce_allocated(), but does not update sk_forward_alloc",
        "pre": {
            "sk": "!=null",
            "amount": "!=null"
        },
        "post": {
            "sk_forward_alloc": "==old(sk_forward_alloc)"
        }
    }
},
{
    "kprobe:__sk_mem_reduce_allocated": {
        "description": "Reduce the amount of memory allocated for the socket.",
        "pre": {
            "sk": "!=null",
            "amount": "!=null"
        }
    }
},
{
    "kretprobe:sock_no_mmap": {
        "description": "Mirror missing mmap method error code",
        "pre": {
            "file": "!=null",
            "sock": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return_value": "-ENODEV"
        }
    }
},
{
    "kprobe:return -ENODEV;}EXPORT_SYMBOL(sock_no_mmap": {
        "description": "Mirror missing mmap method error code",
        "pre": {
            "file": "!=null",
            "sock": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:smp_wmb();refcount_set(&sk->sk_refcnt, 1);atomic_set(&sk->sk_drops, 0);}EXPORT_SYMBOL(sock_init_data_uid": {
        "description": "Initialize socket data with a specific UID.",
        "pre": {
            "sock": "!=null",
            "sk": "!=null",
            "uid": "!=null"
        },
        "post": {
            "sk->sk_refcnt": "==1",
            "sk->sk_drops": "==0"
        }
    }
},
{
    "kprobe:sock_init_data_uid": {
        "description": "Initialize the sk (socket) structure with various values.",
        "pre": {
            "sock": "!=null",
            "sk": "!=null",
            "uid": "kuid_t"
        },
        "post": {
            "sk->sk_send_head": "null",
            "sk->sk_timer.function": "null",
            "sk->sk_timer.data": "0",
            "sk->sk_allocation": "GFP_KERNEL",
            "sk->sk_rcvbuf": "sysctl_rmem_default",
            "sk->sk_sndbuf": "sysctl_wmem_default",
            "sk->sk_state": "TCP_CLOSE",
            "sk->sk_use_task_frag": "true",
            "sk->sk_type": "sock->type",
            "sk->sk_wq": "&sock->wq",
            "sock->sk": "sk",
            "sk->sk_uid": "uid",
            "sk->sk_callback_lock.class": "af_kern_callback_keys + sk->sk_family",
            "sk->sk_callback_lock.name": "af_family_kern_clock_key_strings[sk->sk_family]",
            "sk->sk_state_change": "sock_def_wakeup",
            "sk->sk_data_ready": "sock_def_readable",
            "sk->sk_write_space": "sock_def_write_space",
            "sk->sk_error_report": "sock_def_error_report",
            "sk->sk_destruct": "sock_def_destruct",
            "sk->sk_frag.page": "null",
            "sk->sk_frag.offset": "0",
            "sk->sk_peek_off": "-1",
            "sk->sk_peer_pid": "null",
            "sk->sk_peer_cred": "null",
            "sk->sk_peer_lock": "spin_lock",
            "sk->sk_write_pending": "0",
            "sk->sk_rcvlowat": "1",
            "sk->sk_rcvtimeo": "MAX_SCHEDULE_TIMEOUT",
            "sk->sk_sndtimeo": "MAX_SCHEDULE_TIMEOUT",
            "sk->sk_stamp": "SK_DEFAULT_STAMP",
            "sk->sk_stamp_seq": "seqlock",
            "sk->sk_zckey": "0",
            "sk->sk_napi_id": "0",
            "sk->sk_ll_usec": "sysctl_net_busy_read",
            "sk->sk_max_pacing_rate": "~0UL",
            "sk->sk_pacing_rate": "~0UL",
            "sk->sk_pacing_shift": "10",
            "sk->sk_incoming_cpu": "-1"
        }
    }
},
S,
S,
{
    "kretprobe:sock_setbindtodevice": {
        "description": "Bind this socket to a particular device like 'eth0', as specified in the passed interface name. If the name is '' or the option length is zero, the socket is not bound.",
        "pre": {
            "sk": "!=null",
            "optval": "!=null",
            "optlen": "> IFNAMSIZ - 1",
            "devname": "memset(devname, 0, sizeof(devname))",
            "ret": "-EFAULT",
            "copy_from_sockptr(devname, optval, optlen)": "goto out",
            "devname[0]": "!= '\0'"
        }
    }
},
{
    "kprobe:if (optlen > IFNAMSIZ - 1)optlen = IFNAMSIZ - 1;memset(devname, 0, sizeof(devname));ret = -EFAULT;if (copy_from_sockptr(devname, optval, optlen))goto out;index = 0;if (devname[0] != '\\0')": {
        "description": "Bind this socket to a particular device like 'eth0', as specified in the passed interface name. If the name is '' or the option length is zero, the socket is not bound.",
        "pre": {
            "optlen": "> IFNAMSIZ - 1",
            "devname": "!= null",
            "ret": "== -EFAULT",
            "copy_from_sockptr(devname, optval, optlen)": "does not fail",
            "devname[0]": "!= '\\0'"
        }
    }
},
{
    "kretprobe:__lock_sock_fast": {
        "description": "Fast path return with bottom halves disabled and sock::sk_lock.slock held.",
        "pre": {
            "sk": "!=null",
            "__acquires(&sk->sk_lock.slock)": true,
            "!sock_owned_by_user_nocheck(sk)": true,
            "disable_bottom_halves": true,
            "release_sk_lock_slock": true
        }
    }
},
S,
{
    "kretprobe:if (timeval && !in_compat_syscall())": {
        "description": "Check if timeval is true and in_compat_syscall() is false.",
        "pre": {
            "timeval": "==true",
            "in_compat_syscall()": "==false"
        }
    }
},
{
    "kprobe:if (timeval && !in_compat_syscall())": {
        "description": "Check if timeval is true and in_compat_syscall() is false.",
        "pre": {
            "timeval": "==true",
            "in_compat_syscall()": "==false"
        }
    }
},
{
    "kretprobe:sock_common_getsockopt": {
        "description": "Get socket options for the given socket.",
        "pre": {
            "sock": "!=null",
            "level": "is int",
            "optname": "is int",
            "optval": "is char pointer",
            "optlen": "is int",
            "sk": "=sock->sk",
            "sk->sk_prot": "!=null",
            "sk->sk_prot.getsockopt": "exists"
        }
    }
},
{
    "kprobe:sock_common_getsockopt": {
        "description": "Get socket option",
        "pre": {
            "sock": "!=null",
            "level": "!=null",
            "optname": "!=null",
            "optval": "!=null",
            "optlen": "!=null"
        }
    }
},
{
    "kretprobe:sock_common_setsockopt": {
        "description": "Set socket options for the given socket.",
        "pre": {
            "sock": "!=null",
            "level": "is_integer",
            "optname": "is_integer",
            "optval": "!=null",
            "optlen": "is_unsigned_integer"
        }
    }
},
{
    "kprobe:sock_common_setsockopt": {
        "description": "Set socket options for the given socket.",
        "pre": {
            "sock": "!=null",
            "level": "!=null",
            "optname": "!=null",
            "optval": "!=null",
            "optlen": "!=null"
        }
    }
},
S,
{
    "kprobe:sk->sk_prot->unhash": {
        "description": "Unhashes the socket, preventing it from receiving new packets.",
        "pre": {
            "sk": "!=null",
            "sk->sk_prot": "!=null",
            "sk->sk_prot->unhash": "!=null"
        }
    }
},
{
    "kretprobe:sk_ioctl": {
        "description": "Process ioctl command on a socket.",
        "pre": {
            "sk": "!=null",
            "cmd": "!=null",
            "arg": "!=null",
            "sk->sk_type": "==SOCK_RAW",
            "sk->sk_family": "in [AF_INET, AF_INET6]",
            "rc": "<=0"
        }
    }
},
{
    "kprobe:if (rc <= 0)return rc;/* Otherwise call the default handler `": {
        "description": "Condition for the if statement in the given function.",
        "pre": {
            "rc": "<= 0"
        }
    }
},
S,
S,
{
    "kretprobe:in4_pton": {
        "description": "Convert an IPv4 address from literal to binary representation.",
        "pre": {
            "src": "!=null",
            "srclen": ">= -1",
            "dst": "!=null",
            "delim": ">= -1",
            "end": "!=null"
        },
        "post": {
            "return": "in [0, 1]",
            "end": "points to the end of the parsed string"
        }
    }
},
{
    "kprobe:in4_pton": {
        "description": "Convert an IPv4 address from literal to binary representation.",
        "pre": {
            "src": "!=null",
            "srclen": ">= -1",
            "dst": "!=null",
            "delim": ">= -1",
            "end": "!=null"
        }
    }
},
{
    "kretprobe:in6_pton": {
        "description": "Convert an IPv6 address from literal to binary representation.",
        "pre": {
            "src": "!=null",
            "srclen": ">= -1",
            "dst": "!=null",
            "delim": ">= -1",
            "end": "!=null"
        }
    }
},
{
    "kprobe:in6_pton": {
        "description": "Convert an IPv6 address from literal to binary representation.",
        "pre": {
            "src": "!=null",
            "srclen": ">= -1",
            "dst": "!=null",
            "delim": ">= -1",
            "end": "!=null"
        }
    }
},
{
    "kretprobe:inet_pton_with_scope": {
        "description": "Convert an IPv4/IPv6 address and port to a socket address.",
        "pre": {
            "net": "!=null",
            "af": "in [AF_INET, AF_INET6, AF_UNSPEC]",
            "src": "!=null",
            "port": "!=null or ==null",
            "addr": "!=null"
        },
        "post": {
            "return": "==0 or !=0"
        }
    }
},
{
    "kprobe:inet_pton_with_scope": {
        "description": "Convert an IPv4/IPv6 address and port to a socket address.",
        "pre": {
            "net": "!=null",
            "af": "in [AF_INET, AF_INET6, AF_UNSPEC]",
            "src": "!=null",
            "port": "!=null or ==null",
            "addr": "!=null"
        },
        "post": {
            "return": "in [0, errno]"
        }
    }
},
{
    "kretprobe:inet_proto_csum_replace16": {
        "description": "Update layer 4 header checksum field",
        "pre": {
            "sum": "!=null",
            "skb": "!=null",
            "from": "!=null",
            "to": "!=null",
            "pseudohdr": "in [true, false]"
        }
    }
},
{
    "kprobe:inet_proto_csum_replace16": {
        "description": "Update layer 4 header checksum field",
        "pre": {
            "sum": "!=null",
            "skb": "!=null",
            "from": "!=null",
            "to": "!=null",
            "pseudohdr": "in [true, false]"
        }
    }
},
{
    "kretprobe:of_find_net_device_by_node": {
        "description": "Lookup the net device for the device node",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_find_net_device_by_node": {
        "description": "Lookup the net device for the device node",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:neigh_blackhole": {
        "description": "Handles blackhole neighbors.",
        "pre": {
            "neigh": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:neigh_blackhole": {
        "description": "Function to handle blackhole neighbor entries.",
        "pre": {
            "neigh": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:__neigh_create": {
        "description": "Create a neighbor entry",
        "pre": {
            "tbl": {
                "constructor": "!=null"
            },
            "n": "!=null",
            "error": "< 0"
        }
    }
},
{
    "kprobe:if (tbl->constructor && (error = tbl->constructor(n)) < 0)": {
        "description": "Check if the constructor function of tbl is not null and if the constructor function returns a negative error code.",
        "pre": {
            "tbl": "!=null",
            "tbl->constructor": "!=null",
            "n": "!=null",
            "error": "< 0"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:WARN_ON(!list_empty(&net_todo_list));mutex_unlock(&rtnl_mutex);while (head)": {
        "description": "Ensure that we didn't actually add any TODO item when __rtnl_unlock() is used.",
        "pre": {
            "net_todo_list": "!list_empty(&net_todo_list)",
            "rtnl_mutex": "unlocked",
            "head": "!=null"
        }
    }
},
{
    "kprobe:WARN_ON": {
        "description": "Check if the list net_todo_list is empty.",
        "pre": {
            "list_empty(&net_todo_list)": "==false"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlock the mutex rtnl_mutex.",
        "pre": {
            "rtnl_mutex": "locked"
        }
    },
    "kprobe:while (head)": {
        "description": "Iterate over the list head.",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:if (metrics == dst_default_metrics.metrics)return 0;mx = nla_nest_start_noflag(skb, RTA_METRICS);if (mx == NULL)return -ENOBUFS;for (i = 0; i < RTAX_MAX; i++)": {
        "description": "rtnetlink_put_metrics function",
        "pre": {
            "metrics": "== dst_default_metrics.metrics",
            "mx": "!= null",
            "skb": "!= null",
            "RTA_METRICS": "!= null",
            "i": "< RTAX_MAX"
        }
    }
},
{
    "kprobe:if (metrics == dst_default_metrics.metrics)return 0;mx = nla_nest_start_noflag(skb, RTA_METRICS);if (mx == NULL)return -ENOBUFS;for (i = 0; i < RTAX_MAX; i++)": {
        "description": "rtnetlink_put_metrics function",
        "pre": {
            "metrics": "== dst_default_metrics.metrics",
            "mx": "!= null",
            "skb": "!= null",
            "RTA_METRICS": "!= null",
            "i": "< RTAX_MAX"
        }
    }
},
{
    "kretprobe:rtnl_link_get_net": {
        "description": "Examine the link attributes and figure out which network namespace we are talking about.",
        "pre": {
            "src_net": "!=null",
            "tb[IFLA_NET_NS_PID]": "!=null || tb[IFLA_NET_NS_FD] != null",
            "tb[IFLA_NET_NS_PID]": "null => tb[IFLA_NET_NS_FD] != null",
            "tb[IFLA_NET_NS_FD]": "null => tb[IFLA_NET_NS_PID] != null"
        },
        "post": {
            "net": "!=null"
        }
    }
},
{
    "kprobe:rtnl_link_get_net": {
        "description": "Examine the link attributes and figure out which network namespace we are talking about.",
        "pre": {
            "src_net": "!=null",
            "tb[IFLA_NET_NS_PID]": "!=null",
            "tb[IFLA_NET_NS_FD]": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kretprobe:ndo_dflt_fdb_add": {
        "description": "Default netdevice operation to add an FDB entry",
        "pre": {
            "ndm": "!=null",
            "tb": "!=null",
            "dev": "!=null",
            "addr": "!=null",
            "vid": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:ndo_dflt_fdb_add": {
        "description": "default netdevice operation to add an FDB entry",
        "pre": {
            "ndm": "!=null",
            "tb": "!=null",
            "dev": "!=null",
            "addr": "!=null",
            "vid": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ndo_dflt_fdb_del": {
        "description": "Default netdevice operation to delete an FDB entry.",
        "pre": {
            "ndm": "!=null",
            "tb": "!=null",
            "dev": "!=null",
            "addr": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kprobe:ndo_dflt_fdb_del": {
        "description": "Default netdevice operation to delete an FDB entry.",
        "pre": {
            "ndm": "!=null",
            "tb": "!=null",
            "dev": "!=null",
            "addr": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kretprobe:ndo_dflt_fdb_dump": {
        "description": "Default netdevice operation to dump an FDB table.",
        "pre": {
            "skb": "!=null",
            "cb": "!=null",
            "dev": "!=null",
            "filter_dev": "ignored",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:ndo_dflt_fdb_dump": {
        "description": "Default netdevice operation to dump an FDB table.",
        "pre": {
            "skb": "!=null",
            "cb": "!=null",
            "dev": "!=null",
            "filter_dev": "ignored",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:__hw_addr_sync_multiple": {
        "description": "Sync multiple hardware addresses from one list to another.",
        "pre": {
            "to_list": "!=null",
            "from_list": "!=null",
            "addr_len": ">=0"
        },
        "post": {
            "err": "==0",
            "ha->sync_cnt": "ha->sync_cnt - 1"
        }
    }
},
{
    "kprobe:__hw_addr_del_entry": {
        "description": "Delete an entry from the hardware address list.",
        "pre": {
            "from_list": "!=null",
            "ha": "!=null"
        }
    }
},
{
    "kretprobe:__hw_addr_sync_dev": {
        "description": "Synchonize device's multicast list",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "sync": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kprobe:__hw_addr_sync_dev": {
        "description": "Synchronize device's multicast list",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "sync": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kretprobe:__hw_addr_ref_sync_dev": {
        "description": "Synchronize device's multicast address list taking into account references",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "sync": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kprobe:__hw_addr_ref_sync_dev": {
        "description": "Synchronize device's multicast address list taking into account references",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "sync": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kretprobe:__hw_addr_ref_unsync_dev": {
        "description": "Remove synchronized addresses and references on it from device",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kprobe:__hw_addr_ref_unsync_dev": {
        "description": "Remove synchronized addresses and references on it from device",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kretprobe:__hw_addr_unsync_dev": {
        "description": "Remove synchronized addresses from device",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kprobe:__hw_addr_unsync_dev": {
        "description": "Remove synchronized addresses from device",
        "pre": {
            "list": "!=null",
            "dev": "!=null",
            "unsync": "!=null"
        }
    }
},
{
    "kretprobe:dev_addr_add": {
        "description": "Add a device address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "addr_type": "!=null"
        }
    }
},
{
    "kprobe:dev_addr_add": {
        "description": "Add a device address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "addr_type": "!=null"
        }
    }
},
{
    "kretprobe:dev_addr_del": {
        "description": "Release a device address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "addr_type": "!=null"
        }
    }
},
{
    "kprobe:dev_addr_del": {
        "description": "Release a device address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "addr_type": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_add_excl": {
        "description": "Add a global secondary unicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_add_excl": {
        "description": "Add a global secondary unicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_del": {
        "description": "Release secondary unicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_del": {
        "description": "Release secondary unicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_sync": {
        "description": "Synchronize device's unicast list to another device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_sync": {
        "description": "Synchronize device's unicast list to another device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_sync_multiple": {
        "description": "Synchronize device's unicast list to another device, but allow for multiple calls to sync to multiple devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_sync_multiple": {
        "description": "Synchronize device's unicast list to another device, but allow for multiple calls to sync to multiple devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_unsync": {
        "description": "Remove synchronized addresses from the destination device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_unsync": {
        "description": "Remove synchronized addresses from the destination device.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_flush": {
        "description": "Flush unicast addresses",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_flush": {
        "description": "Flush unicast addresses",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dev_uc_init": {
        "description": "Init unicast address list",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_uc_init": {
        "description": "Init unicast address list",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_add_excl": {
        "description": "Add a global secondary multicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_add_excl": {
        "description": "Add a global secondary multicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_add_global": {
        "description": "Add a global multicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_add_global": {
        "description": "Add a global multicast address",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_del": {
        "description": "Delete a multicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "global": "in [true, false]"
        }
    }
},
{
    "kprobe:dev_mc_del": {
        "description": "Delete a multicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "global": "bool"
        }
    }
},
{
    "kretprobe:dev_mc_del_global": {
        "description": "Delete a global multicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_del_global": {
        "description": "Delete a global multicast address.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_sync": {
        "description": "Synchronize device's multicast list to another device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_sync": {
        "description": "Synchronize device's multicast list to another device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_sync_multiple": {
        "description": "Synchronize device's multicast list to another device, but allow for multiple calls to sync to multiple devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_sync_multiple": {
        "description": "Synchronize device's multicast list to another device, but allow for multiple calls to sync to multiple devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_unsync": {
        "description": "Remove synchronized addresses from the destination device",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_unsync": {
        "description": "Remove synchronized addresses from the destination device.",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_flush": {
        "description": "Flush multicast addresses",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_flush": {
        "description": "Flush multicast addresses",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dev_mc_init": {
        "description": "Init multicast address list",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_mc_init": {
        "description": "Init multicast address list",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:intgnet_stats_start_copy_compat": {
        "description": "Start dumping procedure in compatibility mode",
        "pre": {
            "skb": "!=null",
            "type": "int",
            "tc_stats_type": "int",
            "xstats_type": "int",
            "lock": "!=null",
            "d": "!=null",
            "padattr": "int"
        }
    }
},
{
    "kprobe:intgnet_stats_start_copy_compat": {
        "description": "Start dumping procedure in compatibility mode",
        "pre": {
            "skb": "!=null",
            "type": "int",
            "tc_stats_type": "int",
            "xstats_type": "int",
            "lock": "!=null",
            "d": "!=null",
            "padattr": "int"
        }
    }
},
{
    "kretprobe:gnet_stats_copy": {
        "description": "Copy basic statistics into statistic TLV.",
        "pre": {
            "d": "!=null",
            "TCA_STATS_PKT64": "!=null",
            "&bstats_packets": "!=null",
            "sizeof(bstats_packets)": "!=null",
            "TCA_STATS_PAD": "!=null"
        }
    }
},
{
    "kprobe:gnet_stats_copy_basic": {
        "description": "Copy basic statistics into statistic TLV.",
        "pre": {
            "d": "!=null",
            "cpu": "!=null",
            "b": "!=null",
            "type": "int",
            "running": "bool"
        }
    }
},
{
    "kretprobe:intgnet_stats_copy_basic_hw": {
        "description": "Copy basic hardware statistics into statistic TLV.",
        "pre": {
            "d": "!=null",
            "cpu": "!=null",
            "b": "!=null",
            "running": "in [true, false]"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
S,
{
    "kretprobe:intgnet_stats_copy_rate_est": {
        "description": "Copy rate estimator statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "rate_est": "!=null"
        }
    }
},
{
    "kprobe:intgnet_stats_copy_rate_est": {
        "description": "Copy rate estimator statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "rate_est": "!=null"
        }
    }
},
{
    "kretprobe:intgnet_stats_copy_queue": {
        "description": "Copy queue statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "cpu_q": "!=null",
            "q": "!=null",
            "qlen": "!=null"
        }
    }
},
{
    "kprobe:intgnet_stats_copy_queue": {
        "description": "Copy queue statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "cpu_q": "!=null",
            "q": "!=null",
            "qlen": "!=null"
        }
    }
},
{
    "kretprobe:intgnet_stats_copy_app": {
        "description": "Copy application specific statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "st": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:intgnet_stats_copy_app": {
        "description": "Copy application specific statistics into statistics TLV",
        "pre": {
            "d": "!=null",
            "st": "!=null",
            "len": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:dev_load": {
        "description": "Load a network module",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:dev_load": {
        "description": "Load a network module",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:flow_rule_alloc": {
        "description": "Allocate a flow rule with the given number of actions.",
        "pre": {
            "num_actions": ">= 0"
        },
        "post": {
            "rule": "!= null",
            "rule->action.num_entries": "== num_actions",
            "rule->action.entries[i].hw_stats": "== FLOW_ACTION_HW_STATS_DONT_CARE for i in [0, num_actions)"
        }
    }
},
{
    "kprobe:flow_rule_alloc": {
        "description": "Allocate a flow rule with the given number of actions.",
        "pre": {
            "num_actions": ">= 0"
        }
    }
},
{
    "kretprobe:size = ksize(data)": {
        "description": "krealloc() will immediately return 'data' when 'ksize(data)' is requested: it is the existing upper bounds. As a result, GFP_ATOMIC will be ignored. Note that this 'new' pointer needs to be passed back to the caller for use so the __alloc_size hinting will be tracked correctly.",
        "pre": {
            "data": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:size = ksize(data)": {
        "description": "krealloc() will immediately return 'data' when 'ksize(data)' is requested: it is the existing upper bounds. As a result, GFP_ATOMIC will be ignored. Note that this 'new' pointer needs to be passed back to the caller for use so the __alloc_size hinting will be tracked correctly.",
        "pre": {
            "data": "!=null",
            "size": "!=null",
            "skb": "!=null",
            "resized": "!=null"
        }
    }
},
{
    "kretprobe:build_skb_around": {
        "description": "Build a network buffer.",
        "pre": {
            "skb": "!=null",
            "data": "!=null",
            "frag_size": "!=0"
        }
    }
},
{
    "kprobe:build_skb_around": {
        "description": "Build a network buffer.",
        "pre": {
            "skb": "!=null",
            "data": "!=null",
            "frag_size": "!=0"
        }
    }
},
{
    "kretprobe:__napi_build_skb": {
        "description": "Build a network buffer",
        "pre": {
            "data": "!=null",
            "frag_size": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__napi_build_skb": {
        "description": "Build a network buffer.",
        "pre": {
            "data": "!=null",
            "frag_size": "!=null"
        }
    }
},
{
    "kretprobe:__alloc_skb": {
        "description": "Allocate a network buffer",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "flags": "in [SKB_ALLOC_FCLONE, SKB_ALLOC_RX]",
            "node": "!=null"
        }
    }
},
{
    "kprobe:__alloc_skb": {
        "description": "Allocate a network buffer",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "flags": "in [SKB_ALLOC_FCLONE, SKB_ALLOC_RX]",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:__netdev_alloc_skb": {
        "description": "Allocate an skbuff for rx on a specific device",
        "pre": {
            "dev": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:__netdev_alloc_skb": {
        "description": "Allocate an skbuff for rx on a specific device.",
        "pre": {
            "dev": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:__napi_alloc_skb": {
        "description": "Allocate skbuff for rx in a specific NAPI instance",
        "pre": {
            "napi": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:__napi_alloc_skb": {
        "description": "Allocate skbuff for rx in a specific NAPI instance",
        "pre": {
            "napi": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:__kfree_skb": {
        "description": "Free an sk_buff. Release anything attached to the buffer. Clean the state.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:__kfree_skb": {
        "description": "Free an sk_buff. Release anything attached to the buffer. Clean the state.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:__fix_addresskfree_skb_reason": {
        "description": "Free an sk_buff with special reason",
        "pre": {
            "skb": "!=null",
            "reason": "in [valid_reasons_list]"
        }
    }
},
{
    "kprobe:__fix_addresskfree_skb_reason": {
        "description": "Free an sk_buff with special reason",
        "pre": {
            "skb": "!=null",
            "reason": "in [valid values of enum skb_drop_reason]"
        }
    }
},
{
    "kretprobe:skb->pp_recycle = 0": {
        "description": "Free an skbuff by memory without cleaning the state.",
        "pre": {
            "skb": "!=null",
            "skb->pp_recycle": "==0"
        }
    }
},
{
    "kprobe:skb->pp_recycle = 0;": {
        "description": "Free an skbuff by memory without cleaning the state.",
        "pre": {
            "skb": "!=null",
            "pp_recycle": "==0"
        }
    }
},
{
    "kretprobe:skb_tx_error": {
        "description": "Report an sk_buff xmit error",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:skb_tx_error": {
        "description": "Report an sk_buff xmit error",
        "pre": {
            "skb": "!=null"
        }
    }
},
S,
{
    "kprobe:napi_consume_skb": {
        "description": "Consume a socket buffer (skb) in NAPI context.",
        "pre": {
            "skb": "!=null",
            "budget": "==0"
        }
    }
},
S,
S,
{
    "kretprobe:skb_headers_offset_update": {
        "description": "Adjusts skb->csum_start if skb->ip_summed is CHECKSUM_PARTIAL.",
        "pre": {
            "skb": "!=null",
            "off": "int"
        },
        "post": {
            "skb->ip_summed": "==CHECKSUM_PARTIAL",
            "skb->csum_start": "+=off"
        }
    }
},
{
    "kprobe:skb_headers_offset_update": {
        "description": "Adjust skb->csum_start if skb->ip_summed == CHECKSUM_PARTIAL.",
        "pre": {
            "skb": "!=null",
            "off": "!=null",
            "skb->ip_summed": "== CHECKSUM_PARTIAL"
        }
    }
},
{
    "kretprobe:__pskb_copy_fclone": {
        "description": "Create a copy of an sk_buff with private head.",
        "pre": {
            "skb": "!=null",
            "headroom": "!=null",
            "gfp_mask": "!=null",
            "fclone": "!=null"
        }
    }
},
{
    "kprobe:__pskb_copy_fclone": {
        "description": "Create a copy of an sk_buff with private head.",
        "pre": {
            "skb": "!=null",
            "headroom": ">=0",
            "gfp_mask": ">=0",
            "fclone": "bool"
        }
    }
},
{
    "kretprobe:pskb_expand_head": {
        "description": "Reallocate header of sk_buff",
        "pre": {
            "skb": "!=null",
            "nhead": ">=0",
            "ntail": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:pskb_expand_head": {
        "description": "Reallocate header of sk_buff",
        "pre": {
            "skb": "!=null",
            "nhead": ">=0",
            "ntail": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:skb_copy_expand": {
        "description": "Copy and expand sk_buff",
        "pre": {
            "skb": "!=null",
            "newheadroom": "int",
            "newtailroom": "int",
            "gfp_mask": "gfp_t"
        }
    }
},
{
    "kprobe:skb_copy_expand": {
        "description": "Copy and expand sk_buff",
        "pre": {
            "skb": "!=null",
            "newheadroom": "int",
            "newtailroom": "int",
            "gfp_mask": "gfp_t"
        }
    }
},
{
    "kretprobe:__skb_pad": {
        "description": "__skb_pad - zero pad the tail of an skb",
        "pre": {
            "skb": "!=null",
            "pad": ">=0",
            "free_on_error": "in [true, false]"
        }
    }
},
{
    "kprobe:__skb_pad": {
        "description": "__skb_pad-zero pad the tail of an skb",
        "pre": {
            "skb": "!=null",
            "pad": ">=0",
            "free_on_error": "in [true, false]"
        }
    }
},
{
    "kretprobe:skb_panic": {
        "description": "Called via the wrapper skb_over_panic() or skb_under_panic(). Keep out of line to prevent kernel bloat. __builtin_return_address is not used because it is not always reliable.",
        "pre": {
            "skb": "!=null",
            "sz": ">0",
            "addr": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kprobe:skb_panic": {
        "description": "Called via the wrapper functions skb_over_panic() or skb_under_panic(). Keep out of line to prevent kernel bloat. __builtin_return_address is not used because it is not always reliable.",
        "pre": {
            "skb": "!=null",
            "sz": ">=0",
            "addr": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:skb_pull": {
        "description": "Remove data from the start of a buffer",
        "pre": {
            "skb": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:skb_pull": {
        "description": "Remove data from the start of a buffer",
        "pre": {
            "skb": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:skb_pull_data": {
        "description": "Remove data from the start of a buffer and return its original position.",
        "pre": {
            "skb": "!=null",
            "len": ">=0",
            "skb->data": "!=null",
            "skb->len": ">=len"
        }
    }
},
{
    "kprobe:skb_pull_data": {
        "description": "Remove data from the start of a buffer, returning its original position.",
        "pre": {
            "skb": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:if (!gfp_mask)": {
        "description": "Check if the gfp_mask is not set.",
        "pre": {
            "gfp_mask": "==0"
        }
    }
},
{
    "kprobe:if (!gfp_mask)": {
        "description": "Check if the gfp_mask is not set.",
        "pre": {
            "gfp_mask": "==0"
        }
    }
},
{
    "kretprobe:__pskb_pull_tail": {
        "description": "Advance tail of skb header",
        "pre": {
            "skb": "!=null",
            "delta": ">=0",
            "skb.is_fragmented": "==true",
            "skb.ref_count": "==1"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:/* Moves tail of skb head forward, copying data from fragmented part, * when it is necessary. * 1. It may fail due to malloc failure. * 2. It may change skb pointers. * * It is pretty complicated. Luckily, it is called only in exceptional cases. */": {
        "description": "Advance tail of skb header, copying data from fragmented part when necessary.",
        "pre": {
            "skb": "!=null",
            "delta": ">=0"
        }
    }
},
{
    "kretprobe:skb_store_bits": {
        "description": "Store bits from kernel buffer to skb",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "from": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:skb_store_bits": {
        "description": "Store bits from kernel buffer to skb",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "from": "!=null",
            "len": "!=null"
        }
    }
},
S,
{
    "kprobe:skb_copy_and_csum_bits": {
        "description": "Copy header.",
        "pre": {
            "skb": "!=null",
            "offset": "any",
            "to": "any",
            "len": "any"
        },
        "post": {
            "copy": ">0"
        }
    }
},
{
    "kretprobe:__skb_checksum_complete_head": {
        "description": "Check if the sum is zero",
        "pre": {
            "skb": "!=null",
            "len": ">=0",
            "skb->csum": "!=null",
            "sum": "==0"
        }
    }
},
S,
{
    "kretprobe:skb_dequeue": {
        "description": "Remove from the head of the queue",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:skb_dequeue": {
        "description": "Remove from the head of the queue",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:skb_dequeue_tail": {
        "description": "Remove from the tail of the queue",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:skb_dequeue_tail": {
        "description": "Remove from the tail of the queue",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:skb_queue_purge": {
        "description": "Empty a list",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:skb_queue_purge": {
        "description": "Empty a list",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:skb_queue_head": {
        "description": "Queue a buffer at the start of the list.",
        "pre": {
            "list": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kprobe:skb_queue_head": {
        "description": "Queue a buffer at the start of the list.",
        "pre": {
            "list": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kretprobe:skb_zerocopy_iter_stream": {
        "description": "This function is used to perform zero-copy iteration on an skb.",
        "pre": {
            "orig_uarg": "!=null",
            "uarg": "!=null",
            "orig_uarg == uarg": true,
            "return": "-EEXIST",
            "err": "!=null",
            "__zerocopy_sg_from_iter(msg, sk, skb, &msg->msg_iter, len)": "!=null",
            "err == -EFAULT || (err == -EMSGSIZE && skb->len == orig_len)": true
        }
    }
},
{
    "kprobe:skb_zerocopy_iter_stream": {
        "description": "This function is used to iterate over an skb and perform zero-copy operations.",
        "pre": {
            "orig_uarg": "!=null",
            "uarg": "!=null",
            "orig_uarg.len": "==skb->len",
            "uarg.len": "==skb->len",
            "success": "bool",
            "skb": "!=null",
            "msg": "!=null",
            "len": "int",
            "sk": "!=null"
        },
        "post": {
            "return": "-EEXIST if (orig_uarg && uarg != orig_uarg) else -EFAULT or -EMSGSIZE"
        }
    }
},
{
    "kretprobe:skb_unlink": {
        "description": "Remove a buffer from a list.",
        "pre": {
            "skb": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:skb_unlink": {
        "description": "Remove a buffer from a list.",
        "pre": {
            "skb": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:skb_append": {
        "description": "Place a packet after a given packet in a list.",
        "pre": {
            "old": "!=null",
            "newsk": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:skb_append": {
        "description": "Place a packet after a given packet in a list.",
        "pre": {
            "old": "!=null",
            "newsk": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:skb_split_no_header": {
        "description": "Split the given sk_buff into two sk_buffs at the specified position.",
        "pre": {
            "skb": "!=null",
            "skb1": "!=null",
            "len": ">=0",
            "pos": ">=0",
            "skb_shinfo(skb)->nr_frags": ">=0",
            "skb_shinfo(skb)->frags[i]": "!=null for i in range(skb_shinfo(skb)->nr_frags)",
            "skb_shinfo(skb1)->frags[i]": "!=null for i in range(skb_shinfo(skb)->nr_frags)",
            "skb_shinfo(skb1)->nr_frags": ">=0",
            "skb->data_len": ">=0",
            "skb1->data_len": ">=0",
            "skb->len": ">=0",
            "skb1->len": ">=0",
            "len <= skb->len",
            "pos <= skb->len",
            "skb_set_tail_pointer(skb, len)": "tail pointer set correctly"
        }
    }
},
{
    "kprobe:skb_split_no_header": {
        "description": "Split the given sk_buff into two sk_buffs at the specified position.",
        "pre": {
            "skb": "!=null",
            "skb1": "!=null",
            "len": ">=0",
            "pos": ">=0",
            "pos": "<=skb->len",
            "skb_shinfo(skb)->nr_frags": ">=0",
            "skb_shinfo(skb1)->nr_frags": ">=0",
            "skb_shinfo(skb)->nr_frags": "==0",
            "skb->data_len": ">=0",
            "skb1->data_len": ">=0",
            "skb1->len": ">=0",
            "skb->len": ">=0",
            "skb->len": "==len",
            "skb_set_tail_pointer(skb, len)": "true"
        }
    }
},
S,
S,
{
    "kretprobe:skb_abort_seq_read": {
        "description": "Abort a sequential read of skb data",
        "pre": {
            "st": "!=null"
        }
    }
},
{
    "kprobe:skb_abort_seq_read": {
        "description": "Abort a sequential read of skb data",
        "pre": {
            "st": "!=null"
        }
    }
},
{
    "kretprobe:skb_find_text": {
        "description": "Find a text pattern in skb data",
        "pre": {
            "skb": "!=null",
            "from": ">=0",
            "to": ">=from",
            "config": "!=null"
        }
    }
},
{
    "kprobe:skb_find_text": {
        "description": "Find a text pattern in skb data",
        "pre": {
            "skb": "!=null",
            "from": ">=0",
            "to": ">=from",
            "config": "!=null"
        }
    }
},
{
    "kretprobe:skb_dst_force": {
        "description": "Force the destination of the socket buffer.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "sk->sk_error_queue": "!=null",
            "sock_flag(sk, SOCK_DEAD)": "==false"
        },
        "post": {
            "return": "==0"
        }
    },
    "kretprobe:skb_queue_tail": {
        "description": "Add the socket buffer to the tail of the socket's error queue.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "sk->sk_error_queue": "!=null"
        }
    },
    "kretprobe:sk_error_report": {
        "description": "Report an error for the socket.",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kprobe:skb_dst_force": {
        "description": "Forcefully set the destination of the socket buffer.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "sk->sk_error_queue": "!=null",
            "sock_flag(sk, SOCK_DEAD)": "==false"
        }
    },
    "kprobe:skb_queue_tail": {
        "description": "Add the socket buffer to the tail of the socket's error queue.",
        "pre": {
            "skb": "!=null",
            "sk": "!=null",
            "sk->sk_error_queue": "!=null"
        }
    },
    "kprobe:sk_error_report": {
        "description": "Report the error associated with the socket.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(sock_queue_err_skb)": {
        "description": "Export the symbol for the sock_queue_err_skb function.",
        "pre": {}
    }
},
{
    "kretprobe:skb_clone_sk": {
        "description": "Create clone of skb, and take reference to socket",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:skb_clone_sk": {
        "description": "Create clone of skb, and take reference to socket",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:skb_checksum_setup_ipv4": {
        "description": "Set up checksum calculation for IPv4 packets in the skb.",
        "pre": {
            "skb": "!=null",
            "proto": "in [IPPROTO_TCP, IPPROTO_UDP]",
            "off": ">= 0"
        }
    }
},
{
    "kprobe:skb_checksum_setup_ipv4": {
        "description": "Set up the checksum for the IPv4 packet in the given skb.",
        "pre": {
            "skb": "!=null",
            "recalculate": "bool",
            "proto": "in [IPPROTO_TCP, IPPROTO_UDP]"
        },
        "post": {
            "return": "in [pointer to checksum field, error pointer]"
        }
    }
},
{
    "kretprobe:skb_checksum_trimmed": {
        "description": "Validate checksum of an skb",
        "pre": {
            "skb": "!=null",
            "transport_len": ">=0",
            "skb_chkf": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:skb_checksum_trimmed": {
        "description": "Validate checksum of an skb",
        "pre": {
            "skb": "!=null",
            "transport_len": ">=0",
            "skb_chkf": "!=null"
        }
    }
},
{
    "kretprobe:skb_try_coalesce": {
        "description": "Try to merge skb to prior one",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "fragstolen": "!=null",
            "delta_truesize": "!=null"
        }
    }
},
{
    "kprobe:skb_try_coalesce": {
        "description": "Try to merge skb to prior one",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "fragstolen": "!=null",
            "delta_truesize": "!=null"
        }
    }
},
{
    "kretprobe:return_skb": {
        "description": "Return skb",
        "pre": {
            "skb": "!=null",
            "skb_share_check(skb, GFP_ATOMIC)": "skb",
            "skb": "!=null",
            "vlan_set_encap_proto()": "access 2 bytes after vlan_hdr"
        }
    }
},
{
    "kprobe:skb_vlan_untag": {
        "description": "Untag the VLAN header from the given skb.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:skb_vlan_pop": {
        "description": "Pop a vlan tag either from hwaccel or from payload. Expects skb->data at mac header.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:int_skb_vlan_pop": {
        "description": "Pop a vlan tag either from hwaccel or from payload. Expects skb->data at mac header.",
        "pre": {
            "skb": "!=null",
            "vlan_tci": "!=null"
        }
    }
},
{
    "kretprobe:skb_eth_pop": {
        "description": "Drop the Ethernet header at the head of a packet",
        "pre": {
            "skb": "!=null",
            "skb->data": "!=null",
            "no VLAN tags": "not present"
        },
        "post": {
            "return value": "in [0, -errno]"
        }
    }
},
{
    "kprobe:skb_eth_pop": {
        "description": "Drop the Ethernet header at the head of a packet",
        "pre": {
            "skb": "!=null",
            "skb->data": "!=null",
            "no VLAN tags": "not present"
        },
        "post": {
            "return": "0 on success, -errno otherwise"
        }
    }
},
{
    "kretprobe:skb_eth_push": {
        "description": "Add a new Ethernet header at the head of a packet",
        "pre": {
            "skb": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:skb_eth_push": {
        "description": "Add a new Ethernet header at the head of a packet",
        "pre": {
            "skb": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:alloc_skb_with_frags": {
        "description": "Allocate skb with page frags",
        "pre": {
            "header_len": ">= 0",
            "data_len": ">= 0",
            "max_page_order": ">= 0",
            "errcode": "!= null",
            "gfp_mask": "valid gfp_t value"
        }
    }
},
{
    "kprobe:alloc_skb_with_frags": {
        "description": "Allocate skb with page frags",
        "pre": {
            "header_len": ">= 0",
            "data_len": ">= 0",
            "max_page_order": ">= 0",
            "errcode": "!= null",
            "gfp_mask": ">= 0"
        }
    }
},
{
    "kretprobe:pskb_trim_rcsum_slow": {
        "description": "Trim the packet length and update the checksum.",
        "pre": {
            "skb": "!=null",
            "len": ">=0"
        }
    }
},
S,
{
    "kretprobe:skb_ext_add": {
        "description": "Allocate space for given extension, COW if needed",
        "pre": {
            "skb": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:skb_ext_add": {
        "description": "Allocate space for given extension, COW if needed",
        "pre": {
            "skb": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:__skb_ext_set": {
        "description": "Attach the specified extension storage to this skb.",
        "pre": {
            "skb": "!=null",
            "id": "!=null",
            "ext": "!=null"
        }
    }
},
{
    "kprobe:__skb_ext_set": {
        "description": "Attach the specified extension storage to this skb.",
        "pre": {
            "skb": "!=null",
            "id": "!=null",
            "ext": "!=null"
        }
    }
},
{
    "kretprobe:ssize_t_skb_splice_from_iter": {
        "description": "Splice (or copy) pages to skbuff",
        "pre": {
            "skb": "!=null",
            "iter": "!=null",
            "maxsize": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:ssize_t_skb_splice_from_iter": {
        "description": "Splice (or copy) pages to skbuff",
        "pre": {
            "skb": "!=null",
            "iter": "!=null",
            "maxsize": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kretprobe:sk_stream_wait_connect": {
        "description": "Wait for a socket to get into the connected state",
        "pre": {
            "sk": "!=null",
            "timeo_p": "!=null"
        }
    }
},
{
    "kprobe:sk_stream_wait_connect": {
        "description": "Wait for a socket to get into the connected state",
        "pre": {
            "sk": "!=null",
            "timeo_p": "!=null"
        }
    }
},
{
    "kretprobe:sk_stream_wait_memory": {
        "description": "Wait for more memory for a socket",
        "pre": {
            "sk": "!=null",
            "timeo_p": "!=null"
        }
    }
},
{
    "kprobe:sk_stream_wait_memory": {
        "description": "Wait for more memory for a socket",
        "pre": {
            "sk": "!=null",
            "timeo_p": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:if (msg->msg_controllen < cmlen)": {
        "description": "Check if the length of the control message buffer is less than the calculated length.",
        "pre": {
            "msg": {
                "msg_controllen": "< cmlen"
            }
        }
    }
},
{
    "kretprobe:scm_detach_fds": {
        "description": "Detach file descriptors from the message control buffer.",
        "pre": {
            "msg->msg_control_is_user": "==true",
            "msg->msg_flags & MSG_CMSG_COMPAT": "==0"
        }
    }
},
{
    "kprobe:scm_detach_fds": {
        "description": "Detach file descriptors from a message header.",
        "pre": {
            "msg->msg_control_is_user": "==true",
            "msg->msg_flags & MSG_CMSG_COMPAT": "==0"
        }
    }
},
{
    "kretprobe:gen_new_estimator": {
        "description": "Create a new rate estimator",
        "pre": {
            "bstats": "!=null",
            "cpu_bstats": "!=null",
            "rate_est": "!=null",
            "lock": "!=null",
            "running": "in [true, false]",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:gen_new_estimator": {
        "description": "Create a new rate estimator",
        "pre": {
            "bstats": "!=null",
            "cpu_bstats": "!=null",
            "rate_est": "!=null",
            "lock": "!=null",
            "running": "in [true, false]",
            "opt": "!=null"
        }
    }
},
{
    "kretprobe:gen_kill_estimator": {
        "description": "Remove a rate estimator",
        "pre": {
            "rate_est": "!=null"
        }
    }
},
{
    "kprobe:gen_kill_estimator": {
        "description": "Remove a rate estimator",
        "pre": {
            "rate_est": "!=null"
        }
    }
},
{
    "kretprobe:gen_replace_estimator": {
        "description": "Replace rate estimator configuration",
        "pre": {
            "bstats": "!=null",
            "cpu_bstats": "!=null",
            "rate_est": "!=null",
            "lock": "!=null",
            "running": "in [true, false]",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:gen_replace_estimator": {
        "description": "Replace rate estimator configuration",
        "pre": {
            "bstats": "!=null",
            "cpu_bstats": "!=null",
            "rate_est": "!=null",
            "lock": "!=null",
            "running": "bool",
            "opt": "!=null"
        }
    }
},
{
    "kretprobe:gen_estimator_active": {
        "description": "Test if estimator is currently in use",
        "pre": {
            "rate_est": "!=null"
        }
    }
},
{
    "kprobe:gen_estimator_active": {
        "description": "Test if estimator is currently in use",
        "pre": {
            "rate_est": "!=null"
        }
    }
},
S,
{
    "kprobe:if (pdev)": {
        "description": "Check if the platform device `pdev` is not null.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_ethdev_address": {
        "description": "Search the device tree for the best MAC address to use. If found, set @dev->dev_addr to that address.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:of_get_ethdev_address": {
        "description": "Search the device tree for the best MAC address to use. If found, set @dev->dev_addr to that address.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:skb_eth_gso_segment": {
        "description": "Segmentation handler for ethernet protocols.",
        "pre": {
            "skb": "!=null",
            "features": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:skb_eth_gso_segment": {
        "description": "Segmentation handler for ethernet protocols.",
        "pre": {
            "skb": "!=null",
            "features": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:skb_mac_gso_segment": {
        "description": "Mac layer segmentation handler.",
        "pre": {
            "skb": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kprobe:skb_mac_gso_segment": {
        "description": "Mac layer segmentation handler.",
        "pre": {
            "skb": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kretprobe:__skb_gso_segment": {
        "description": "Perform segmentation on skb.",
        "pre": {
            "skb": "!=null",
            "features": "!=null",
            "tx_path": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__skb_gso_segment": {
        "description": "Perform segmentation on skb.",
        "pre": {
            "skb": "!=null",
            "features": "!=null",
            "tx_path": "!=null"
        }
    }
},
{
    "kretprobe:DEFINE_RWLOCK(dev_base_lock);EXPORT_SYMBOL(dev_base_lock)": {
        "description": "This function defines and exports the dev_base_lock.",
        "pre": {
            "dev_base_lock": "!=null",
            "rtnl_semaphore": "held",
            "dev_base_lock_usage": "writing"
        }
    }
},
{
    "DEFINE_RWLOCK(dev_base_lock);EXPORT_SYMBOL(dev_base_lock)": {
        "description": "Function for managing the dev_base_lock and rtnl semaphore.",
        "pre": {
            "dev_base_lock": "!=null",
            "rtnl": "!=null"
        }
    }
},
{
    "kretprobe:dev_add_pack": {
        "description": "Add a packet handler to the networking stack.",
        "pre": {
            "pt": "!=null"
        }
    }
},
{
    "kprobe:dev_add_pack": {
        "description": "Add packet handler to the networking stack.",
        "pre": {
            "pt": "!=null"
        }
    }
},
{
    "kretprobe:__dev_remove_pack": {
        "description": "Remove a protocol handler that was previously added to the kernel protocol handlers by dev_add_pack().",
        "pre": {
            "pt": "!=null"
        }
    }
},
{
    "kprobe:__dev_remove_pack": {
        "description": "Remove a protocol handler that was previously added to the kernel protocol handlers by dev_add_pack().",
        "pre": {
            "pt": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_iflink": {
        "description": "Get 'iflink' value of an interface",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_get_iflink": {
        "description": "Get 'iflink' value of an interface",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__dev_get_by_name": {
        "description": "Find an interface by name.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:__dev_get_by_name": {
        "description": "Find a device by its name.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_by_name_rcu": {
        "description": "Find a device by its name",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:dev_get_by_name_rcu": {
        "description": "Find a device by its name",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_by_name": {
        "description": "Get a network device by its name.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:dev_get_by_name": {
        "description": "Get a network device by its name.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:__dev_get_by_index": {
        "description": "Find a device by its ifindex.",
        "pre": {
            "net": "!=null",
            "ifindex": "!=null"
        }
    }
},
{
    "kprobe:__dev_get_by_index": {
        "description": "Find a device by its ifindex.",
        "pre": {
            "net": "!=null",
            "ifindex": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_by_index_rcu": {
        "description": "Find a device by its ifindex",
        "pre": {
            "net": "!=null",
            "ifindex": "!=null"
        }
    }
},
{
    "kprobe:dev_get_by_index_rcu": {
        "description": "Find a device by its ifindex.",
        "pre": {
            "net": "!=null",
            "ifindex": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_by_index": {
        "description": "Get the network device with the specified index.",
        "pre": {
            "net": "!=null",
            "ifindex": ">=0"
        }
    }
},
{
    "kprobe:dev_get_by_index": {
        "description": "Get the network device with the specified index.",
        "pre": {
            "net": "!=null",
            "ifindex": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_by_napi_id": {
        "description": "Find a device by NAPI ID.",
        "pre": {
            "napi_id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:dev_get_by_napi_id": {
        "description": "Find a device by NAPI ID.",
        "pre": {
            "napi_id": "!=null"
        }
    }
},
{
    "kretprobe:dev_getbyhwaddr_rcu": {
        "description": "Find a device by its hardware address.",
        "pre": {
            "net": "!=null",
            "type": "!=null",
            "ha": "!=null"
        }
    }
},
{
    "kprobe:dev_getbyhwaddr_rcu": {
        "description": "Find a device by its hardware address.",
        "pre": {
            "net": "!=null",
            "type": "!=null",
            "ha": "!=null"
        }
    }
},
{
    "kretprobe:__dev_get_by_flags": {
        "description": "Find any device with given flags",
        "pre": {
            "net": "!=null",
            "if_flags": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:__dev_get_by_flags": {
        "description": "Find any device with given flags.",
        "pre": {
            "net": "!=null",
            "if_flags": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:dev_valid_name": {
        "description": "Check if name is okay for network device",
        "pre": {
            "name": "!=null",
            "name": "does not contain whitespace",
            "name": "is a valid file name for sysfs"
        }
    }
},
{
    "kprobe:dev_valid_name": {
        "description": "Check if name is okay for network device",
        "pre": {
            "name": "!=null",
            "name": "is_valid_file_name",
            "name": "no_whitespace"
        }
    }
},
{
    "kretprobe:__dev_alloc_name": {
        "description": "Allocate a name for a device.",
        "pre": {
            "net": "!=null",
            "name": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:__dev_alloc_name": {
        "description": "Allocate a name for a device.",
        "pre": {
            "net": "!=null",
            "name": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:dev_set_alias": {
        "description": "Change ifalias of a device",
        "pre": {
            "dev": "!=null",
            "alias": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:dev_set_alias": {
        "description": "Change ifalias of a device",
        "pre": {
            "dev": "!=null",
            "alias": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:netdev_features_change": {
        "description": "Device changes features",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_features_change": {
        "description": "Device changes features",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_state_change": {
        "description": "Device changes state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_state_change": {
        "description": "Device changes state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__netdev_notify_peers": {
        "description": "Notify network peers about existence of @dev",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:__netdev_notify_peers": {
        "description": "Notify network peers about existence of @dev",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:dev_disable_lro": {
        "description": "Disable Large Receive Offload on a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_disable_lro": {
        "description": "Disable Large Receive Offload on a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:register_netdevice_notifier": {
        "description": "Register a network notifier block",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:register_netdevice_notifier": {
        "description": "Register a network notifier block",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:unregister_netdevice_notifier": {
        "description": "Unregister a network notifier block",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:unregister_netdevice_notifier": {
        "description": "Unregister a network notifier block",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:register_netdevice_notifier_net": {
        "description": "Register a per-netns network notifier block",
        "pre": {
            "net": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:register_netdevice_notifier_net": {
        "description": "Register a per-netns network notifier block",
        "pre": {
            "net": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:DEFINE_RWLOCK(dev_base_lock);EXPORT_SYMBOL(dev_base_lock);static DEFINE_MUTEX(ifalias_mutex);/* protects napi_hash addition/deletion and napi_gen_id": {
        "description": "This function defines and exports the dev_base_lock and ifalias_mutex variables. It also protects the napi_hash addition/deletion and napi_gen_id.",
        "pre": {},
        "ret": "bool"
    }
},
{
    "kprobe:call_netdevice_notifiers_extack": {
        "description": "Call netdevice notifiers with extended acknowledgment.",
        "pre": {
            "val": "!=null",
            "dev": "!=null",
            "extack": "!=null"
        }
    },
    "kprobe:napi_by_id": {
        "description": "Get NAPI structure by ID.",
        "pre": {
            "napi_id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:netif_set_xps_queue": {
        "description": "Set the XPS queue for a network device.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null",
            "index": "!=null",
            "type": "in [enum xps_map_type values]"
        },
        "post": {
            "return_value": "-EINVAL"
        }
    }
},
{
    "kprobe:netif_set_xps_queue": {
        "description": "Set XPS queue for a network device.",
        "pre": {
            "dev": "!=null",
            "mask": "!=null",
            "index": "!=null",
            "type": "!=null",
            "num_tc": "!=null",
            "num_tc < 0": true,
            "return": "-EINVAL",
            "dev->num_tc != 0": true
        }
    }
},
{
    "kretprobe:netdev_reset_tc": {
        "description": "Reset TC configuration of device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "dev->num_tc": "==0",
            "memset(dev->tc_to_txq, 0, sizeof(dev->tc_to_txq))": "true",
            "memset(dev->prio_tc_map, 0, sizeof(dev->prio_tc_map))": "true"
        }
    }
},
{
    "kprobe:netdev_reset_tc": {
        "description": "Reset TC configuration of device",
        "pre": {
            "dev": "!=null",
            "dev->num_tc": "==0",
            "dev->tc_to_txq": "all elements == 0",
            "dev->prio_tc_map": "all elements == 0"
        }
    }
},
S,
S,
{
    "kretprobe:netdev_bind_sb_channel_queue": {
        "description": "Make certain the sb_dev and dev are already configured",
        "pre": {
            "dev": "!=null",
            "sb_dev": "!=null",
            "tc": ">= 0",
            "count": ">= 0",
            "offset": ">= 0"
        }
    }
},
{
    "kprobe:netdev_bind_sb_channel_queue": {
        "description": "Make certain the sb_dev and dev are already configured",
        "pre": {
            "dev": "!=null",
            "sb_dev": "!=null",
            "tc": ">= 0",
            "count": ">= 0",
            "offset": ">= 0"
        }
    }
},
{
    "kretprobe:netdev_set_sb_channel": {
        "description": "Do not use a multiqueue device to represent a subordinate channel",
        "pre": {
            "dev": "!=null",
            "netif_is_multiqueue(dev)": true
        },
        "post": {
            "return": "-ENODEV"
        }
    }
},
{
    "kprobe:netif_is_multiqueue": {
        "description": "Check if the network device has multiple queues.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return the error code -ENODEV if the network device is a multiqueue device.",
        "pre": {
            "dev": "!=null",
            "channel": "in [1, 32767]"
        }
    },
    "kprobe:netdev_set_sb_channel": {
        "description": "Set the subordinate channel for a network device.",
        "pre": {
            "dev": "!=null",
            "channel": "!=null",
            "channel": "!=0"
        }
    }
},
S,
S,
{
    "kretprobe:netif_set_real_num_rx_queues": {
        "description": "Set actual number of RX queues used",
        "pre": {
            "dev": "!=null",
            "rxq": "!=null"
        }
    }
},
{
    "kprobe:netif_set_real_num_rx_queues": {
        "description": "Set actual number of RX queues used.",
        "pre": {
            "dev": "!=null",
            "rxq": "!=null"
        }
    }
},
{
    "kretprobe:netif_set_real_num_queues": {
        "description": "Set the actual number of RX and TX queues used.",
        "pre": {
            "dev": "!=null",
            "txq": "!=null",
            "rxq": "!=null"
        }
    }
},
{
    "kprobe:netif_set_real_num_queues": {
        "description": "Set actual number of RX and TX queues used",
        "pre": {
            "dev": "!=null",
            "txq": "!=null",
            "rxq": "!=null"
        }
    }
},
{
    "kretprobe:netif_set_tso_max_size": {
        "description": "Set the max size of TSO frames supported",
        "pre": {
            "dev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:netif_set_tso_max_size": {
        "description": "Set the max size of TSO frames supported",
        "pre": {
            "dev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:netif_set_tso_max_segs": {
        "description": "Set the max number of segs supported for TSO",
        "pre": {
            "dev": "!=null",
            "segs": ">=0"
        }
    }
},
{
    "kprobe:netif_set_tso_max_segs": {
        "description": "Set the max number of segs supported for TSO",
        "pre": {
            "dev": "!=null",
            "segs": ">=0"
        }
    }
},
{
    "kretprobe:netif_inherit_tso_max": {
        "description": "Copy all TSO limits from a lower device to an upper",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:netif_inherit_tso_max": {
        "description": "Copy all TSO limits from a lower device to an upper",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:netif_get_num_default_rss_queues": {
        "description": "default number of RSS queues. Default value is the number of physical cores if there are only 1 or 2, or divided by 2 if there are more.",
        "pre": {
            "return_value": "int",
            "return_value": ">= 1",
            "return_value": "if num_physical_cores == 1 or num_physical_cores == 2, return_value == num_physical_cores",
            "return_value": "if num_physical_cores > 2, return_value == num_physical_cores / 2"
        }
    }
},
{
    "kprobe:netif_get_num_default_rss_queues": {
        "description": "default number of RSS queues. Default value is the number of physical cores if there are only 1 or 2, or divided by 2 if there are more.",
        "pre": {
            "": ""
        }
    }
},
{
    "kretprobe:netif_device_detach": {
        "description": "Mark device as removed from system and therefore no longer available.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netif_device_detach": {
        "description": "Mark device as removed from system and therefore no longer available.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netif_device_attach": {
        "description": "Mark device as attached from system and restart if needed.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netif_device_attach": {
        "description": "Mark device as attached from system and restart if needed.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:skb_has_shared_frag": {
        "description": "Check if the sk_buff has shared fragments.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kprobe:skb_has_shared_frag": {
        "description": "Check if the sk_buff has shared fragments.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:netif_skb_features": {
        "description": "Verify hardware encapsulation features for the netdev if encapsulation offload request is present.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "features": "!=null",
            "skb_is_gso(skb)": "true",
            "gso_features_check(skb, dev, features)": "!=null"
        }
    }
},
{
    "kprobe:netif_skb_features": {
        "description": "Check the features of the skb and the associated net device.",
        "pre": {
            "skb": "!=null",
            "skb->dev": "!=null",
            "skb->dev->features": "!=null",
            "skb_is_gso(skb)": "==true",
            "gso_features_check(skb, dev, features)": "!=null"
        }
    }
},
{
    "kretprobe:dev_loopback_xmit": {
        "description": "Loop back the given skb buffer in the specified network namespace.",
        "pre": {
            "net": "!=null",
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:dev_loopback_xmit": {
        "description": "Loop back the given skb buffer in the specified network namespace.",
        "pre": {
            "net": "!=null",
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:__dev_queue_xmit": {
        "description": "Transmit a buffer to a network device.",
        "pre": {
            "skb": "!=null",
            "sb_dev": "!=null"
        },
        "post": {
            "return_value": "in [0, positive qdisc return code, negative errno]"
        }
    }
},
{
    "kprobe:__dev_queue_xmit": {
        "description": "Transmit a buffer to a network device.",
        "pre": {
            "skb": "!=null",
            "sb_dev": "!=null"
        }
    }
},
{
    "kretprobe:rps_may_expire_flow": {
        "description": "Check whether an RFS hardware filter may be removed.",
        "pre": {
            "dev": "!=null",
            "rxq_index": "!=null",
            "flow_id": "!=null",
            "filter_id": "!=null"
        }
    }
},
{
    "kprobe:rps_may_expire_flow": {
        "description": "Check whether an RFS hardware filter may be removed.",
        "pre": {
            "dev": "!=null",
            "rxq_index": "!=null",
            "flow_id": "!=null",
            "filter_id": "!=null"
        }
    }
},
{
    "kretprobe:__netif_rx": {
        "description": "Slightly optimized version of netif_rx",
        "pre": {
            "skb": "!=null",
            "context": "in [hard interrupt, soft interrupt]"
        }
    }
},
S,
{
    "kretprobe:skb->pkt_type = PACKET_OTHERHOST;} else if (eth_type_vlan(skb->protocol))": {
        "description": "Set the packet type of skb to PACKET_OTHERHOST if eth_type_vlan(skb->protocol) is true.",
        "pre": {
            "skb": "!=null",
            "skb->protocol": "!=null",
            "eth_type_vlan(skb->protocol)": "true"
        }
    }
},
S,
{
    "kretprobe:get_rps_cpu": {
        "description": "Returns the target CPU from the RPS map of the receiving queue for a given skb.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null",
            "rflowp": "!=null",
            "rcu_read_lock": "held"
        }
    }
},
{
    "kprobe:get_rps_cpu": {
        "description": "Returns the target CPU from the RPS map of the receiving queue for a given skb.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null",
            "rflowp": "!=null"
        }
    }
},
{
    "kretprobe:netif_receive_skb_list_ptype": {
        "description": "Process a list of sk_buffs with a specific packet type.",
        "pre": {
            "head": "!=null",
            "pt_prev": "!=null",
            "orig_dev": "!=null"
        }
    }
},
{
    "kprobe:netif_receive_skb_list_ptype": {
        "description": "Process a sublist of packets with a common ptype.",
        "pre": {
            "head": "!=null",
            "pt_prev": "!=null",
            "orig_dev": "!=null"
        }
    }
},
{
    "kretprobe:thread = READ_ONCE(napi->thread); if (thread)": {
        "description": "Read the value of napi->thread using READ_ONCE and assign it to thread. If thread is not null, execute the following code.",
        "pre": {
            "napi->thread": "!=null",
            "thread": "!=null"
        }
    }
},
{
    "kprobe:thread = READ_ONCE(napi->thread); if (thread)": {
        "description": "Read the value of napi->thread using READ_ONCE and assign it to thread variable. If thread is not null, execute the following code.",
        "pre": {
            "napi": "!=null",
            "thread": "!=null"
        }
    }
},
{
    "kretprobe:napi_schedule_prep": {
        "description": "Check if napi can be scheduled",
        "pre": {
            "n": "!=null",
            "n->state": "==NAPI_STATE_SCHED",
            "n->poll_owner": "==NULL",
            "n->poll_owner_cpu": "==smp_processor_id()",
            "n->disable_depth": "==0"
        }
    }
},
{
    "kprobe:napi_schedule_prep": {
        "description": "Check if napi can be scheduled",
        "pre": {
            "n": "!=null",
            "n->state": "==NAPI_STATE_SCHED",
            "n->poll_owner": "==NULL",
            "n->poll_owner_cpu": "==smp_processor_id()",
            "n->disable_depth": "==0"
        }
    }
},
{
    "kretprobe:enqueue_to_backlog": {
        "description": "Queue an skb to a per CPU backlog queue.",
        "pre": {
            "skb": "!=null",
            "cpu": "any",
            "qtail": "!=null"
        }
    }
},
{
    "kprobe:enqueue_to_backlog": {
        "description": "Queue an skb to a per CPU backlog queue.",
        "pre": {
            "skb": "!=null",
            "cpu": "integer",
            "qtail": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:netif_napi_add_weight": {
        "description": "Add weight to the NAPI structure for a network device.",
        "pre": {
            "dev": "!=null",
            "napi": "!=null",
            "poll": "!=null",
            "weight": ">=0"
        }
    }
},
{
    "kprobe:netif_napi_add_weight": {
        "description": "Create kthread for this napi if dev->threaded is set. Clear dev->threaded if kthread creation failed so that threaded mode will not be enabled in napi_enable().",
        "pre": {
            "dev": "!=null",
            "napi": "!=null",
            "poll": "!=null",
            "weight": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:netdev_has_upper_dev": {
        "description": "Check if device is linked to an upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        },
        "post": {
            "return": "upper_dev == dev"
        }
    }
},
{
    "kprobe:netdev_has_upper_dev": {
        "description": "Check if device is linked to an upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_has_upper_dev_all_rcu": {
        "description": "Check if device is linked to an upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_has_upper_dev_all_rcu": {
        "description": "Check if device is linked to an upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_has_any_upper_dev": {
        "description": "Check if device is linked to some device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kprobe:netdev_has_any_upper_dev": {
        "description": "Check if device is linked to some device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_master_upper_dev_get": {
        "description": "Get master upper device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_master_upper_dev_get": {
        "description": "Get master upper device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_upper_get_next_dev_rcu": {
        "description": "Get the next device from the dev's upper list, starting from iter position.",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kprobe:netdev_upper_get_next_dev_rcu": {
        "description": "Get the next dev from upper list",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:netdev_lower_get_next_private": {
        "description": "Get the next ->private from the lower neighbour list",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kprobe:netdev_lower_get_next_private": {
        "description": "Get the next ->private from the lower neighbour list",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:netdev_lower_get_next_private_rcu": {
        "description": "Get the next ->private from the lower neighbour list, RCU variant",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kprobe:netdev_lower_get_next_private_rcu": {
        "description": "Get the next ->private from the lower neighbour list, RCU variant",
        "pre": {
            "dev": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:netdev_lower_get_first_private_rcu": {
        "description": "Get the first ->private from the lower neighbour list, RCU variant",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_lower_get_first_private_rcu": {
        "description": "Get the first ->private from the lower neighbour list, RCU variant",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_master_upper_dev_get_rcu": {
        "description": "Get master upper device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_master_upper_dev_get_rcu": {
        "description": "Get master upper device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__netdev_has_upper_dev": {
        "description": "Check if the given upper device is attached to the given device.",
        "pre": {
            "upper_dev": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "-EBUSY"
        }
    },
    "kretprobe:(dev->lower_level + upper_dev->upper_level) > MAX_NEST_DEV": {
        "description": "Check if the sum of lower_level and upper_level exceeds MAX_NEST_DEV.",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        },
        "post": {
            "return": "-EMLINK"
        }
    },
    "kretprobe:!master": {
        "description": "Check if master is false.",
        "pre": {},
        "post": {
            "return": "-EMLINK"
        }
    }
},
{
    "kprobe:__netdev_has_upper_dev": {
        "description": "Check if the given upper device is attached to the given device.",
        "pre": {
            "upper_dev": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:__netdev_has_upper_dev:return": {
        "description": "Return -EBUSY if the upper device is attached to the given device.",
        "pre": {
            "upper_dev": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:__netdev_has_upper_dev:return:-EBUSY": {
        "description": "Return -EBUSY if the upper device is attached to the given device.",
        "pre": {
            "upper_dev": "==dev"
        }
    },
    "kprobe:__netdev_has_upper_dev:return:-EMLINK": {
        "description": "Return -EMLINK if the sum of lower_level and upper_level exceeds MAX_NEST_DEV.",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null",
            "dev->lower_level + upper_dev->upper_level": ">MAX_NEST_DEV"
        }
    },
    "kprobe:__netdev_has_upper_dev:return:-EMLINK:!(dev->lower_level + upper_dev->upper_level > MAX_NEST_DEV)": {
        "description": "Return -EMLINK if the sum of lower_level and upper_level exceeds MAX_NEST_DEV.",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null",
            "dev->lower_level + upper_dev->upper_level": "<=MAX_NEST_DEV"
        }
    },
    "kprobe:__netdev_has_upper_dev:return:-EMLINK:!master": {
        "description": "Return -EMLINK if master is not true.",
        "pre": {
            "master": "==false"
        }
    }
},
{
    "kretprobe:netdev_master_upper_dev_link": {
        "description": "Add a master link to the upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null",
            "upper_priv": "!=null",
            "upper_info": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:netdev_master_upper_dev_link": {
        "description": "Add a master link to the upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null",
            "upper_priv": "!=null",
            "upper_info": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:netdev_upper_dev_unlink": {
        "description": "Removes a link to upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_upper_dev_unlink": {
        "description": "Removes a link to upper device",
        "pre": {
            "dev": "!=null",
            "upper_dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_bonding_info_change": {
        "description": "Dispatch event about slave change",
        "pre": {
            "dev": "!=null",
            "bonding_info": "!=null"
        },
        "post": {
            "return_value": "not applicable"
        }
    }
},
{
    "kprobe:netdev_bonding_info_change": {
        "description": "Dispatch event about slave change",
        "pre": {
            "dev": "!=null",
            "bonding_info": "!=null"
        }
    }
},
{
    "kretprobe:netdev_hw_stats64_add": {
        "description": "Add hardware statistics to the destination structure.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest->rx_packets": "int",
            "dest->tx_packets": "int",
            "dest->rx_bytes": "int",
            "dest->tx_bytes": "int",
            "dest->rx_errors": "int",
            "dest->tx_errors": "int",
            "dest->rx_dropped": "int",
            "dest->tx_dropped": "int",
            "dest->multicast": "int"
        }
    }
},
{
    "kprobe:netdev_hw_stats64_add": {
        "description": "Add hardware statistics to the destination structure.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest->rx_packets": ">=0",
            "dest->tx_packets": ">=0",
            "dest->rx_bytes": ">=0",
            "dest->tx_bytes": ">=0",
            "dest->rx_errors": ">=0",
            "dest->tx_errors": ">=0",
            "dest->rx_dropped": ">=0",
            "dest->tx_dropped": ">=0",
            "dest->multicast": ">=0"
        }
    }
},
{
    "kretprobe:netdev_get_xmit_slave": {
        "description": "Get the xmit slave of master device",
        "pre": {
            "dev": "!=null",
            "skb": "!=null",
            "all_slaves": "bool"
        }
    }
},
{
    "kprobe:netdev_get_xmit_slave": {
        "description": "Get the xmit slave of master device",
        "pre": {
            "dev": "!=null",
            "skb": "!=null",
            "all_slaves": "bool"
        }
    }
},
{
    "kretprobe:netdev_sk_get_lowest_dev": {
        "description": "Get the lowest device in chain given device and socket.",
        "pre": {
            "dev": "!=null",
            "sk": "!=null"
        }
    }
},
{
    "kprobe:netdev_sk_get_lowest_dev": {
        "description": "Get the lowest device in chain given device and socket.",
        "pre": {
            "dev": "!=null",
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:netdev_lower_state_changed": {
        "description": "Dispatch event about lower device state change",
        "pre": {
            "lower_dev": "!=null",
            "lower_state_info": "!=null"
        }
    }
},
{
    "kprobe:netdev_lower_state_changed": {
        "description": "Dispatch event about lower device state change",
        "pre": {
            "lower_dev": "!=null",
            "lower_state_info": "!=null"
        }
    }
},
{
    "kretprobe:if (inc < 0)dev->flags &= ~IFF_PROMISC;else": {
        "description": "Set or unset the IFF_PROMISC flag based on the value of inc.",
        "pre": {
            "inc": "< 0",
            "dev": "!= null",
            "dev->flags": "& ~IFF_PROMISC when inc < 0"
        }
    }
},
{
    "kprobe:if (inc < 0)dev->flags &= ~IFF_PROMISC;else": {
        "description": "Set or unset the IFF_PROMISC flag based on the value of 'inc'.",
        "pre": {
            "inc": "< 0",
            "dev->flags": "&= ~IFF_PROMISC"
        }
    }
},
{
    "kretprobe:if (inc < 0)dev->flags &= ~IFF_ALLMULTI;else": {
        "description": "Update dev->flags based on the value of inc.",
        "pre": {
            "inc": "< 0",
            "dev": "!= null",
            "dev->flags": "&= ~IFF_ALLMULTI"
        }
    }
},
S,
{
    "kretprobe:dev_get_flags": {
        "description": "Get the combination of flag bits exported through APIs to userspace.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_get_flags": {
        "description": "Get the combination of flag bits exported through APIs to userspace.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dev_change_flags": {
        "description": "Set the flags on our device.",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "extack": "!=null",
            "old_flags": "=dev->flags",
            "ret": "int",
            "ASSERT_RTNL()": "true"
        }
    }
},
{
    "kprobe:dev_change_flags": {
        "description": "Set the flags on our device.",
        "pre": {
            "dev": "!=null",
            "flags": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:__dev_set_mtu": {
        "description": "Pairs with all the lockless reads of dev->mtu in the stack",
        "pre": {
            "dev": "!=null",
            "new_mtu": "any",
            "dev->netdev_ops": "!=null",
            "ops->ndo_change_mtu": "!=null"
        }
    }
},
{
    "kprobe:WRITE_ONCE(dev->mtu, new_mtu);return 0;}EXPORT_SYMBOL(__dev_set_mtu": {
        "description": "Sets the value of `dev->mtu` to `new_mtu` using a lockless write operation.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null"
        }
    }
},
{
    "kretprobe:WRITE_ONCE": {
        "description": "Write a value to a memory location once.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "extack": "!=null"
        }
    },
    "kretprobe:dev_validate_mtu": {
        "description": "Validate the MTU of a network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:WRITE_ONCE": {
        "description": "Write a value to a memory location once.",
        "pre": {
            "ptr": "!=null",
            "val": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL": {
        "description": "Export a symbol for use by other modules.",
        "pre": {
            "symbol": "!=null"
        }
    },
    "kprobe:dev_validate_mtu": {
        "description": "Validate the MTU of a network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:dev_pre_changeaddr_notify": {
        "description": "Call NETDEV_PRE_CHANGEADDR.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:dev_pre_changeaddr_notify": {
        "description": "Call NETDEV_PRE_CHANGEADDR.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:dev_set_mac_address": {
        "description": "Change Media Access Control Address",
        "pre": {
            "dev": "!=null",
            "sa": "!=null",
            "extack": "!=null"
        }
    }
},
S,
{
    "kretprobe:dev_get_port_parent_id": {
        "description": "Get the device's port parent identifier.",
        "pre": {
            "dev": "!=null",
            "ppid": "!=null",
            "recurse": "is boolean"
        }
    }
},
{
    "kprobe:dev_get_port_parent_id": {
        "description": "Get the device's port parent identifier",
        "pre": {
            "dev": "!=null",
            "ppid": "!=null",
            "recurse": "in [true, false]"
        }
    }
},
{
    "kretprobe:netdev_port_same_parent_id": {
        "description": "Indicate if two network devices have the same port parent identifier.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:netdev_port_same_parent_id": {
        "description": "Indicate if two network devices have the same port parent identifier.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:dev_disable_gro_hw": {
        "description": "Disable HW Generic Receive Offload on a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_disable_gro_hw": {
        "description": "Disable HW Generic Receive Offload on a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netdev_change_features": {
        "description": "Recalculate device features",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_change_features": {
        "description": "Recalculate device features",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:netif_stacked_transfer_operstate": {
        "description": "Transfer operational state from root to device.",
        "pre": {
            "rootdev": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netif_stacked_transfer_operstate": {
        "description": "Transfer operational state from root to device.",
        "pre": {
            "rootdev": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Set a block of memory to a specific value.",
        "pre": {
            "stats64": "!=null",
            "netdev_stats": "!=null",
            "n": "sizeof(netdev_stats) / sizeof(atomic_long_t)",
            "src": "(atomic_long_t)netdev_stats",
            "dst": "(u64)stats64",
            "sizeof(stats64) / sizeof(u64)": ">= n"
        }
    }
},
{
    "memset": {
        "description": "Set a block of memory to a specific value.",
        "pre": {
            "ptr": "!=null",
            "value": "0",
            "size": "sizeof(*stats64) - n * sizeof(u64)"
        }
    }
},
{
    "kretprobe:return READ_ONCE(dev->core_stats);}EXPORT_SYMBOL(netdev_core_stats_alloc": {
        "description": "Read the value of the core_stats field of the dev parameter.",
        "pre": {
            "dev": "!=null",
            "dev->core_stats": "!=null"
        }
    }
},
{
    "kprobe:return READ_ONCE(dev->core_stats);}EXPORT_SYMBOL(netdev_core_stats_alloc": {
        "description": "Allocate and initialize per-CPU core statistics for a network device.",
        "pre": {
            "dev": "!=null",
            "dev->core_stats": "==null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:dev_get_stats": {
        "description": "Get network device statistics",
        "pre": {
            "dev": "!=null",
            "storage": "!=null"
        }
    }
},
{
    "kprobe:dev_get_stats": {
        "description": "Get network device statistics",
        "pre": {
            "dev": "!=null",
            "storage": "!=null"
        }
    }
},
{
    "kretprobe:alloc_netdev_mqs": {
        "description": "Allocate network device",
        "pre": {
            "sizeof_priv": ">=0",
            "name": "!=null",
            "name_assign_type": "in [0, 1, 2, 3]",
            "setup": "!=null",
            "txqs": ">=0",
            "rxqs": ">=0"
        }
    }
},
{
    "kprobe:alloc_netdev_mqs": {
        "description": "Allocate network device",
        "pre": {
            "sizeof_priv": ">=0",
            "name": "!=null",
            "name_assign_type": "in [NET_NAME_UNKNOWN, NET_NAME_ENUM, NET_NAME_PREDICTABLE]",
            "setup": "!=null",
            "txqs": ">=0",
            "rxqs": ">=0"
        }
    }
},
S,
{
    "kprobe:dev->needs_free_netdev = false;unregister_netdevice_queue(dev, NULL);goto out;}/* *Prevent userspace races by waiting until the network *device is fully setup before sending notifications. `": {
        "description": "Prevent userspace races by waiting until the network device is fully setup before sending notifications.",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:register_netdevice": {
        "description": "Initialize a network device",
        "pre": {
            "dev->rtnl_link_ops": "==null || dev->rtnl_link_state == RTNL_LINK_INITIALIZED",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    },
    "kretprobe:rtmsg_ifinfo": {
        "description": "Send RTM_NEWLINK message with device information",
        "pre": {
            "dev->rtnl_link_ops": "!=null",
            "dev->rtnl_link_state": "==RTNL_LINK_INITIALIZED",
            "dev": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    },
    "kretprobe:call_netdevice_notifiers": {
        "description": "Call netdevice notifiers",
        "pre": {
            "dev": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    },
    "kretprobe:dev->netdev_ops->ndo_uninit": {
        "description": "Call ndo_uninit function",
        "pre": {
            "dev->netdev_ops->ndo_uninit": "!=null",
            "dev": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    },
    "kretprobe:dev->priv_destructor": {
        "description": "Call priv_destructor function",
        "pre": {
            "dev->priv_destructor": "!=null",
            "dev": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    },
    "kretprobe:netdev_name_node_free": {
        "description": "Free netdev name node",
        "pre": {
            "dev->name_node": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "ret"
        }
    }
},
{
    "kprobe:init_dummy_netdev": {
        "description": "Initialize a dummy network device for NAPI.",
        "pre": {
            "dev": "!=null",
            "dev->rtnl_link_ops": "==null",
            "dev->rtnl_link_state": "==RTNL_LINK_INITIALIZED"
        },
        "out": {
            "ret": "return value"
        },
        "err_uninit_notify": {
            "call_netdevice_notifiers": {
                "event": "NETDEV_PRE_UNINIT",
                "dev": "dev"
            }
        },
        "err_uninit": {
            "if": {
                "condition": "dev->netdev_ops->ndo_uninit",
                "then": {
                    "dev->netdev_ops->ndo_uninit": {
                        "arg": "dev"
                    }
                }
            },
            "if": {
                "condition": "dev->priv_destructor",
                "then": {
                    "dev->priv_destructor": {
                        "arg": "dev"
                    }
                }
            }
        },
        "err_free_name": {
            "netdev_name_node_free": {
                "arg": "dev->name_node"
            }
        },
        "goto": "out"
    }
},
S,
S,
{
    "kretprobe:netdev_increment_features": {
        "description": "Increment feature set by one",
        "pre": {
            "all": "!=null",
            "one": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:netdev_increment_features": {
        "description": "Increment feature set by one",
        "pre": {
            "all": "!=null",
            "one": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:defer": {
        "description": "Allocate memory for 'defer' using kmalloc and check if allocation was successful.",
        "pre": {
            "defer": "!=null"
        }
    }
},
{
    "kprobe:defer = kmalloc(sizeof(*defer), GFP_KERNEL | __GFP_NOWARN);if (likely(defer))": {
        "description": "Allocate memory for 'defer' using kmalloc and check if allocation was successful.",
        "pre": {
            "gcells": "!=null"
        }
    }
},
{
    "kretprobe:netpoll_poll_dev": {
        "description": "Don't do any rx activity if the dev_lock mutex is held. The dev_openclose paths use this to block netpoll activity while changing device state.",
        "pre": {
            "ni": "==null || down_trylock(&ni->dev_lock) != 0"
        }
    }
},
{
    "kprobe:netpoll_poll_dev": {
        "description": "Don't do any rx activity if the dev_lock mutex is held. The dev_openclose paths use this to block netpoll activity while changing device state.",
        "pre": {
            "dev": "!=null",
            "ni": "!=null",
            "!ni": true,
            "down_trylock(&ni->dev_lock)": true
        }
    }
},
{
    "kretprobe:netpoll_send_skb": {
        "description": "Send an skb over netpoll.",
        "pre": {
            "np": "!=null",
            "skb": "!=null",
            "dev": "!=null",
            "npinfo": "!=null",
            "lockdep_assert_irqs_disabled": "true",
            "netif_running(dev)": "true",
            "netif_device_present(dev)": "true"
        }
    }
},
{
    "kprobe:netpoll_send_skb": {
        "description": "Send an skb over netpoll.",
        "pre": {
            "np": "!=null",
            "skb": "!=null",
            "dev": "!=null",
            "npinfo": "!=null",
            "lockdep_assert_irqs_disabled": "true",
            "netif_running(dev)": "true",
            "netif_device_present(dev)": "true"
        }
    }
},
{
    "kretprobe:*(unsigned char *)ip6h = 0x60;ip6h->flow_lbl[0] = 0;ip6h->flow_lbl[1] = 0;ip6h->flow_lbl[2] = 0;ip6h->payload_len = htons(sizeof(struct udphdr) + len);ip6h->nexthdr = IPPROTO_UDP;ip6h->hop_limit = 32;ip6h->saddr = np->local_ip.in6;ip6h->daddr = np->remote_ip.in6;eth = skb_push(skb, ETH_HLEN);skb_reset_mac_header(skb);skb->protocol = eth->h_proto = htons(ETH_P_IPV6);} else": {
        "description": "Description of the function",
        "pre": {
            "ip6h": "= 0x60",
            "ip6h->flow_lbl[0]": "= 0",
            "ip6h->flow_lbl[1]": "= 0",
            "ip6h->flow_lbl[2]": "= 0",
            "ip6h->payload_len": "= htons(sizeof(struct udphdr) + len)",
            "ip6h->nexthdr": "= IPPROTO_UDP",
            "ip6h->hop_limit": "= 32",
            "ip6h->saddr": "= np->local_ip.in6",
            "ip6h->daddr": "= np->remote_ip.in6",
            "eth": "= skb_push(skb, ETH_HLEN)",
            "skb_reset_mac_header(skb)": "",
            "skb->protocol": "= eth->h_proto = htons(ETH_P_IPV6)"
        }
    }
},
{
    "kprobe:netpoll_send_udp": {
        "description": "Send UDP packet over netpoll.",
        "pre": {
            "np": "!=null",
            "msg": "!=null",
            "len": ">=0",
            "total_len": ">=0",
            "ip_len": ">=0",
            "udp_len": ">=0",
            "skb": "!=null",
            "udph": "!=null",
            "iph": "!=null",
            "eth": "!=null",
            "ip_ident": "!=null",
            "ip6h": "!=null",
            "np->ipv6": "in [0, 1]",
            "udph->source": ">=0",
            "udph->dest": ">=0",
            "udph->len": ">=0",
            "udph->check": ">=0",
            "ip6h->version": "==6",
            "ip6h->priority": "==0"
        }
    }
},
{
    "kretprobe:netpoll_parse_options": {
        "description": "Parse netpoll options.",
        "pre": {
            "np": "!=null",
            "opt": "!=null",
            "cur": "!=null",
            "delim": "!=null",
            "ipv6": "int",
            "ipversion_set": "bool"
        },
        "post": {
            "delim": "0",
            "*delim": "0",
            "np->dev_name": "cur",
            "cur": "delim",
            "*cur": "'@'",
            "ipversion_set": "true",
            "ipv6": "netpoll_parse_ip_addr(cur, &np->local_ip)",
            "np->ipv6": "(bool)ipv6"
        }
    }
},
{
    "kprobe:netpoll_parse_options": {
        "description": "Parse netpoll options.",
        "pre": {
            "np": "!=null",
            "opt": "!=null",
            "cur": "!=null",
            "delim": "!=null",
            "ipv6": "!=null",
            "ipversion_set": "!=null"
        }
    }
},
{
    "kretprobe:netpoll_setup": {
        "description": "Setup netpoll for a network device.",
        "pre": {
            "np": "!=null",
            "ndev": "!=null",
            "ndev->name": "!=null",
            "ndev->priv_flags & IFF_DISABLE_NETPOLL": "==0",
            "ndev->npinfo": "==null",
            "sizeof(npinfo)": ">0",
            "ops->ndo_netpoll_setup": "!=null"
        },
        "post": {
            "return": "==0",
            "err": "==0",
            "npinfo": "!=null",
            "npinfo->netpoll": "==np"
        }
    }
},
{
    "kprobe:netpoll_setup": {
        "description": "Setup netpoll for a network device.",
        "pre": {
            "np": "!=null",
            "ndev": "!=null",
            "ndev->priv_flags": "!IFF_DISABLE_NETPOLL",
            "ndev->npinfo": {
                "if null": {
                    "npinfo": "kmalloc(sizeof(npinfo))",
                    "if allocation fails": {
                        "err": "-ENOMEM"
                    },
                    "npinfo->dev_lock": "sema_init(1)",
                    "npinfo->txq": "skb_queue_head_init()",
                    "npinfo->tx_work": "INIT_DELAYED_WORK(queue_process)",
                    "npinfo->refcnt": "refcount_set(1)",
                    "if np->dev->netdev_ops->ndo_netpoll_setup != null": {
                        "err": "ops->ndo_netpoll_setup(ndev, npinfo)",
                        "if err != 0": {
                            "free_npinfo": "kfree(npinfo)"
                        }
                    }
                },
                "else": {
                    "npinfo": "ndev->npinfo",
                    "refcount_inc(npinfo)"
                }
            },
            "npinfo->netpoll": "np"
        }
    }
},
{
    "kretprobe:netpoll_cleanup": {
        "description": "Cleanup the netpoll structure.",
        "pre": {
            "np": "!=null",
            "np->dev": "!=null",
            "np->dev->npinfo": "!=null",
            "npinfo": "!=null",
            "!npinfo": "false",
            "netpoll_srcu": "!=null",
            "refcount_dec_and_test(&npinfo->refcnt)": "true",
            "np->dev->netdev_ops": "!=null",
            "np->dev->netdev_ops->ndo_netpoll_cleanup": "!=null"
        },
        "post": {
            "RCU_INIT_POINTER(np->dev->npinfo, NULL)": "true",
            "call_rcu(&npinfo->rcu, rcu_cleanup_netpoll_info)": "true"
        }
    }
},
{
    "kprobe:synchronize_rcu": {
        "description": "Synchronize RCU.",
        "pre": {}
    },
    "kprobe:__netpoll_cleanup": {
        "description": "Cleanup netpoll.",
        "pre": {
            "np": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Free memory.",
        "pre": {
            "np": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL_GPL": {
        "description": "Export symbol with GPL license.",
        "pre": {
            "__netpoll_free": "!=null"
        }
    },
    "kprobe:void netpoll_cleanup(struct netpoll *np)": {
        "description": "Cleanup netpoll.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_bh": {
        "description": "Allocation attempts can occur concurrently via the setsockopt path and the bind/hash path. Nothing to do when we lose the race.",
        "pre": {
            "max_socks": "!=null",
            "size": "sizeof(struct sock_reuseport) + sizeof(struct sock) * max_socks",
            "reuse": "kzalloc(size, GFP_ATOMIC)",
            "reuse->max_socks": "max_socks",
            "reuse->prog": "NULL",
            "sk": "!=null",
            "bind_inany": "bool",
            "id": "int",
            "ret": "0",
            "bh lock": "used",
            "hlist lock": "in soft irq of receive path or setsockopt from process context"
        }
    }
},
{
    "kprobe:spin_lock_bh": {
        "description": "Acquire a spinlock with bottom-half (BH) disabled.",
        "pre": {
            "lock": "&reuseport_lock"
        }
    }
},
{
    "kretprobe:smp_wmb();reuse->num_socks++;reuseport_get_incoming_cpu(sk, reuse);": {
        "description": "Add a socket to the reuseport",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null",
            "reuse->num_socks": "reuse->num_socks + 1",
            "reuse->socks[reuse->num_socks]": "sk",
            "paired_with": "smp_rmb() in reuseport_(select|migrate)_sock()"
        }
    }
},
{
    "kprobe:__reuseport_detach_sock": {
        "description": "Detach a socket from the reuseport array.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null",
            "reuse->socks[reuse->num_socks]": "sk",
            "smp_rmb()": "called in reuseport_(select|migrate)_sock()"
        }
    }
},
{
    "kretprobe:WRITE_ONCE": {
        "description": "Write a value to the specified memory location.",
        "pre": {
            "ptr": "!=null",
            "val": "!=null"
        }
    },
    "kretprobe:reuseport_get_incoming_cpu": {
        "description": "Get the incoming CPU for a given socket and reuseport structure.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null"
        }
    }
},
{
    "kprobe:WRITE_ONCE(reuse->num_closed_socks, reuse->num_closed_socks + 1);reuseport_get_incoming_cpu(sk, reuse);": {
        "description": "Detaches a socket from the reuseport array and updates the number of closed sockets.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null",
            "reuse->num_closed_socks": "!=null",
            "reuse->num_socks": "!=null",
            "reuse->max_socks": "!=null"
        }
    }
},
{
    "kretprobe:bpf_sk_reuseport_detach": {
        "description": "Detach a socket from the reuseport array.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kretprobe:__reuseport_detach_sock": {
        "description": "Detach a socket from the reuseport array.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null"
        }
    },
    "kretprobe:__reuseport_add_closed_sock": {
        "description": "Add a closed socket to the reuseport array.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null"
        }
    },
    "kretprobe:spin_unlock_bh": {
        "description": "Unlock the spinlock in the bottom half context.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Return from the function.",
        "pre": {}
    }
},
{
    "kprobe:bpf_sk_reuseport_detach": {
        "description": "Detach a socket from the reuseport array.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:__reuseport_detach_sock": {
        "description": "Detach a socket from the reuseport array.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null"
        }
    },
    "kprobe:__reuseport_add_closed_sock": {
        "description": "Add a closed socket to the reuseport array.",
        "pre": {
            "sk": "!=null",
            "reuse": "!=null"
        }
    },
    "kprobe:spin_unlock_bh": {
        "description": "Unlock the spinlock with bottom-half processing.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:__reuseport_put_incoming_cpu": {
        "description": "Description of the function",
        "pre": {
            "variable1": "condition1",
            "variable2": "condition2",
            ...
        }
    }
},
{
    "kprobe:WRITE_ONCE": {
        "description": "Write a value to the reuse->incoming_cpu variable.",
        "pre": {
            "reuse": "!=null",
            "reuse->incoming_cpu": "!=null"
        }
    }
},
{
    "kretprobe:reuseport_migrate_sock": {
        "description": "Select a socket from an SO_REUSEPORT group.",
        "pre": {
            "sk": "!=null",
            "migrating_sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:reuseport_migrate_sock": {
        "description": "Select a socket from an SO_REUSEPORT group.",
        "pre": {
            "sk": "!=null",
            "migrating_sk": "!=null",
            "skb": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:reuseport_attach_prog": {
        "description": "Attach a BPF program to a socket for reuseport functionality.",
        "pre": {
            "sk": "!=null",
            "prog": "!=null",
            "sk_unhashed(sk)": "true",
            "sk->sk_reuseport": "!=null",
            "reuseport_alloc(sk, false)": "0",
            "rcu_access_pointer(sk->sk_reuseport_cb)": "false"
        },
        "post": {
            "return": "-EINVAL",
            "spin_lock_bh(&reuseport_lock)": "true",
            "reuse": "!=null",
            "rcu_dereference_protected(sk->sk_reuseport_cb, lockdep_is_held(&reuseport_lock))": "reuse",
            "old_prog": "!=null",
            "rcu_dereference_protected(reuse->prog, lockdep_is_held(&reuseport_lock))": "old_prog",
            "rcu_assign_pointer(reuse->prog, prog)": "true",
            "spin_unlock_bh(&reuseport_lock)": "true",
            "sk_reuseport_prog_free(old_prog)": "true",
            "return": "0"
        }
    }
},
{
    "kprobe:reuseport_attach_prog": {
        "description": "Attaches a BPF program to a socket for reuseport functionality.",
        "pre": {
            "sk": "!=null",
            "prog": "!=null",
            "sk_unhashed(sk)": "false",
            "sk->sk_reuseport": "true",
            "rcu_access_pointer(sk->sk_reuseport_cb)": "true"
        }
    }
},
{
    "if (!reuse)": {
        "description": "Check if reuse is not set",
        "pre": {
            "reuse": "==null"
        }
    }
},
S,
{
    "kretprobe:tls_get_record": {
        "description": "Get the TLS record information for a given sequence number.",
        "pre": {
            "context": "!=null",
            "seq": "!=null",
            "p_record_sn": "!=null",
            "record_sn": "context->hint_record_sn",
            "info": "!=null",
            "last": "!=null",
            "before(seq, info->end_seq - info->len)": "true"
        }
    }
},
S,
{
    "kretprobe:dns_query": {
        "description": "[<query_type>:]<domain_name>",
        "pre": {
            "net": "!=null",
            "type": "!=null",
            "name": "!=null",
            "namelen": ">=0",
            "options": "!=null",
            "_result": "!=null",
            "_expiry": "!=null",
            "invalidate": "bool"
        }
    }
},
{
    "kprobe:dns_query": {
        "description": "Query the DNS",
        "pre": {
            "net": "!=null",
            "type": "!=null",
            "name": "!=null",
            "namelen": ">=0",
            "options": "!=null",
            "_result": "!=null",
            "_expiry": "!=null",
            "invalidate": "bool"
        }
    }
},
{
    "kretprobe:pn_find_sock_by_res": {
        "description": "Find a socket by resource",
        "pre": {
            "net": "!=null",
            "res": "!=null"
        }
    },
    "kretprobe:struct sock *sk = pn_find_sock_by_res(net, res);if (sk)": {
        "description": "Check if socket is found",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kprobe:pn_find_sock_by_res": {
        "description": "Find a socket by resource",
        "pre": {
            "net": "!=null",
            "res": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:p9_error_init": {
        "description": "Preload mappings into hash list for p9_error_init function.",
        "pre": {
            "void": "null"
        }
    }
},
{
    "kprobe:p9_error_init": {
        "description": "preload mappings into hash list",
        "pre": {}
    }
},
{
    "kretprobe:p9_errstr2errno": {
        "description": "Convert error string to error number",
        "pre": {
            "errstr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:p9_errstr2errno": {
        "description": "Convert error string to error number",
        "pre": {
            "errstr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:p9_show_client_options": {
        "description": "Show client options for p9 protocol.",
        "pre": {
            "m": "!=null",
            "clnt": "!=null",
            "clnt->msize": "==DEFAULT_MSIZE",
            "clnt->trans_mod->name": "!=null",
            "clnt->proto_version": "in [p9_proto_legacy, p9_proto_2000u, p9_proto_2000L]"
        }
    }
},
{
    "kprobe:p9_show_client_options": {
        "description": "Show client options for p9 protocol.",
        "pre": {
            "m": "!=null",
            "clnt": "!=null",
            "clnt->msize": "==DEFAULT_MSIZE",
            "clnt->trans_mod->name": "!=null",
            "clnt->proto_version": "in [p9_proto_legacy, p9_proto_2000u, p9_proto_2000L]"
        }
    }
},
{
    "kretprobe:p9_fcall_fini": {
        "description": "This function is used to finalize a p9_fcall structure.",
        "pre": {
            "fc->sdata": "==null or fc->sdata != null",
            "fc->cache": "==null or fc->cache != null",
            "fc->sdata": "==null or kmem_cache_free(fc->cache, fc->sdata) is called",
            "fc->sdata": "!=null or kfree(fc->sdata) is called"
        }
    }
},
{
    "kprobe:p9_fcall_fini": {
        "description": "Function to finalize p9_fcall structure",
        "pre": {
            "fc->sdata": "==null or (fc->sdata != null and fc->cache != null)",
            "fc->cache": "==null or (fc->sdata != null and fc->cache != null)"
        }
    }
},
{
    "kretprobe:refcount_set": {
        "description": "Set the reference count of the given request to 0.",
        "pre": {
            "req": "!=null",
            "req->refcount": "==0",
            "req->wq": "initialized",
            "req->req_list": "initialized",
            "c": "!=null",
            "c->lock": "locked",
            "type": "in [P9_TVERSION, other]",
            "tag": ">=0",
            "c->reqs": "!=null",
            "req->tc.tag": "==tag"
        }
    },
    "kretprobe:init_waitqueue_head": {
        "description": "Initialize the wait queue head of the given request.",
        "pre": {
            "req": "!=null",
            "req->wq": "uninitialized"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head of the given request.",
        "pre": {
            "req": "!=null",
            "req->req_list": "uninitialized"
        }
    },
    "kretprobe:idr_preload": {
        "description": "Preload the IDR subsystem with GFP_NOFS flag.",
        "pre": {
            "flags": "==GFP_NOFS"
        }
    },
    "kretprobe:spin_lock_irq": {
        "description": "Acquire the spin lock with IRQ disabled.",
        "pre": {
            "c": "!=null",
            "c->lock": "unlocked"
        }
    },
    "kretprobe:idr_alloc": {
        "description": "Allocate an ID from the IDR subsystem.",
        "pre": {
            "c": "!=null",
            "c->reqs": "!=null",
            "req": "!=null",
            "tag": ">=0",
            "type": "in [P9_TVERSION, other]"
        }
    },
    "kretprobe:spin_unlock_irq": {
        "description": "Release the spin lock with IRQ enabled.",
        "pre": {
            "c": "!=null",
            "c->lock": "locked"
        }
    },
    "kretprobe:idr_preload_end": {
        "description": "End the preload phase of the IDR subsystem.",
        "pre": {}
    },
    "kretprobe:goto_free": {
        "description": "Jump to the 'free' label.",
        "pre": {}
    }
},
{
    "kprobe:refcount_set": {
        "description": "Set the reference count of the given request to 0.",
        "pre": {
            "req": "!=null",
            "req->refcount": "==0"
        }
    },
    "kprobe:init_waitqueue_head": {
        "description": "Initialize the wait queue head of the given request.",
        "pre": {
            "req": "!=null",
            "req->wq": "is empty"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head of the given request.",
        "pre": {
            "req": "!=null",
            "req->req_list": "is empty"
        }
    },
    "kprobe:idr_preload": {
        "description": "Preload the IDR subsystem with GFP_NOFS flag.",
        "pre": {
            "flags": "==GFP_NOFS"
        }
    },
    "kprobe:spin_lock_irq": {
        "description": "Acquire the spin lock with IRQ disabled.",
        "pre": {
            "c": "!=null",
            "c->lock": "is not locked"
        }
    },
    "kprobe:idr_alloc": {
        "description": "Allocate an ID from the IDR subsystem for the given request.",
        "pre": {
            "c": "!=null",
            "c->reqs": "!=null",
            "req": "!=null",
            "type": "==P9_TVERSION",
            "tag": ">=0"
        }
    },
    "kprobe:idr_alloc_else": {
        "description": "Allocate an ID from the IDR subsystem for the given request.",
        "pre": {
            "c": "!=null",
            "c->reqs": "!=null",
            "req": "!=null",
            "type": "!=P9_TVERSION",
            "tag": ">=0"
        }
    },
    "kprobe:req->tc.tag_assignment": {
        "description": "Assign the tag value to the request's tc.tag field.",
        "pre": {
            "req": "!=null",
            "tag": ">=0",
            "req->tc.tag": "==tag"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release the spin lock with IRQ enabled.",
        "pre": {
            "c": "!=null",
            "c->lock": "is locked"
        }
    },
    "kprobe:idr_preload_end": {
        "description": "End the preload phase of the IDR subsystem.",
        "pre": {}
    },
    "kprobe:tag_check": {
        "description": "Check if the tag value is less than 0.",
        "pre": {
            "tag": "<0"
        }
    },
    "kprobe:free_check": {
        "description": "Check if the tag value is less than 0 to determine if the request should be freed.",
        "pre": {
            "tag": "<0"
        }
    }
},
{
    "kretprobe:refcount_set": {
        "description": "Set the reference count of the request to 2 and return the request.",
        "pre": {
            "req": "!=null",
            "req->refcount": "==2"
        },
        "post": {
            "req": "!=null"
        }
    },
    "kretprobe:p9_fcall_fini": {
        "description": "Free the tc and rc fields of the request.",
        "pre": {
            "req": "!=null"
        },
        "post": {
            "req": "!=null"
        }
    },
    "kretprobe:kmem_cache_free": {
        "description": "Free the request using the p9_req_cache.",
        "pre": {
            "req": "!=null",
            "p9_req_cache": "!=null"
        },
        "post": {
            "return": "ERR_PTR(-ENOMEM)"
        }
    },
    "kretprobe:p9_tag_lookup": {
        "description": "Look up a request by tag.",
        "pre": {
            "c": "!=null",
            "tag": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:refcount_set": {
        "description": "Set the reference count of the request to 2.",
        "pre": {
            "req": "!=null",
            "req->refcount": "==2"
        }
    },
    "kprobe:return": {
        "description": "Return the request.",
        "pre": {
            "req": "!=null"
        }
    },
    "kprobe:free:p9_fcall_fini": {
        "description": "Free the tc and rc fields of the request.",
        "pre": {
            "req": "!=null",
            "req->tc": "!=null",
            "req->rc": "!=null"
        }
    },
    "kprobe:free_req:kmem_cache_free": {
        "description": "Free the request using kmem_cache_free.",
        "pre": {
            "req": "!=null",
            "req->refcount": "==1",
            "req->tc": "==null",
            "req->rc": "==null"
        }
    },
    "kprobe:return ERR_PTR(-ENOMEM)": {
        "description": "Return ERR_PTR(-ENOMEM).",
        "pre": {}
    },
    "kprobe:p9_tag_lookup": {
        "description": "Look up a request by tag.",
        "pre": {
            "c": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:intp9_parse_header": {
        "description": "Parse header arguments out of a packet",
        "pre": {
            "pdu": "!=null",
            "size": "!=null",
            "type": "!=null",
            "tag": "!=null",
            "rewind": "!=null"
        }
    }
},
{
    "kprobe:intp9_parse_header": {
        "description": "Parse header arguments out of a packet.",
        "pre": {
            "pdu": "!=null",
            "size": "!=null",
            "type": "!=null",
            "tag": "!=null",
            "rewind": "!=null"
        }
    }
},
{
    "kretprobe:clnt->fcall_cache = kmem_cache_create_usercopy": {
        "description": "Create a usercopy of kmem_cache for fcall_cache",
        "pre": {
            "clnt": "!=null",
            "clnt->msize": "!=null",
            "P9_HDRSZ + 4": "!=null",
            "clnt->msize - (P9_HDRSZ + 4)": "!=null"
        }
    },
    "kretprobe:clnt->trans_mod->close": {
        "description": "Close the trans_mod of clnt",
        "pre": {
            "clnt": "!=null",
            "clnt->trans_mod": "!=null"
        }
    },
    "kretprobe:v9fs_put_trans": {
        "description": "Put the trans_mod of clnt",
        "pre": {
            "clnt": "!=null",
            "clnt->trans_mod": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Free the memory allocated for clnt",
        "pre": {
            "clnt": "!=null"
        }
    }
},
{
    "kprobe:clnt->fcall_cache = kmem_cache_create_usercopy": {
        "description": "Create a usercopy of kmem_cache for fcall_cache.",
        "pre": {
            "dev_name": "!=null",
            "options": "!=null"
        }
    },
    "kprobe:close_trans:clnt->trans_mod->close": {
        "description": "Close the transport module for clnt.",
        "pre": {
            "clnt": "!=null"
        }
    },
    "kprobe:put_trans:v9fs_put_trans": {
        "description": "Put the transport module for v9fs.",
        "pre": {
            "trans_mod": "!=null"
        }
    },
    "kprobe:free_client:kfree": {
        "description": "Free the memory allocated for clnt.",
        "pre": {
            "clnt": "!=null"
        }
    },
    "kprobe:return ERR_PTR(err);EXPORT_SYMBOL(p9_client_create)": {
        "description": "Return an error pointer with the given error code.",
        "pre": {
            "err": "!=null"
        }
    }
},
{
    "kretprobe:p9_client_clunk": {
        "description": "Clunk a p9_fid",
        "pre": {
            "fid": "!=null",
            "err": "-ERESTARTSYS"
        }
    }
},
{
    "kprobe:p9_client_clunk": {
        "description": "Clunk the given fid in the p9_client structure.",
        "pre": {
            "fid": "!=null",
            "err": "-ERESTARTSYS"
        }
    }
},
{
    "kretprobe:p9_client_readdir": {
        "description": "Read directory entries from the server.",
        "pre": {
            "clnt->trans_mod->zc_request": "==true",
            "rsize": ">1024"
        }
    }
},
{
    "kprobe:p9_client_readdir": {
        "description": "Read directory entries from the server.",
        "pre": {
            "clnt->trans_mod->zc_request": "==true",
            "rsize": ">1024"
        }
    }
},
{
    "kretprobe:p9_release_pages": {
        "description": "Release pages after the transaction.",
        "pre": {
            "pages": "!=null",
            "nr_pages": ">=0"
        }
    }
},
{
    "kprobe:p9_release_pages": {
        "description": "Release pages after the transaction.",
        "pre": {
            "pages": "!=null",
            "nr_pages": ">=0"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(p9_debug_level)": {
        "description": "feature-rific global debug level",
        "pre": {
            "p9_debug_level": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(p9_debug_level)": {
        "description": "feature-rific global debug level",
        "pre": {
            "p9_debug_level": "!=null"
        }
    }
},
{
    "kretprobe:v9fs_register_trans": {
        "description": "Register a new transport with 9p",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:v9fs_register_trans": {
        "description": "Register a new transport with 9p.",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:v9fs_unregister_trans": {
        "description": "Unregister a 9p transport",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:v9fs_unregister_trans": {
        "description": "Unregister a 9p transport",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:v9fs_get_trans_by_name": {
        "description": "Get transport with the matching name",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:v9fs_get_trans_by_name": {
        "description": "Get transport with the matching name",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:v9fs_get_default_trans": {
        "description": "Get the default transport",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:v9fs_get_default_trans": {
        "description": "Get the default transport",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:ceph_monc_do_statfs": {
        "description": "Performs a statfs operation on the Ceph monitor client.",
        "pre": {
            "monc": "!=null",
            "data_pool": "!=CEPH_NOPOOL",
            "buf": "!=null",
            "req": {
                "request": {
                    "front": {
                        "iov_base": "!=null"
                    }
                }
            }
        }
    }
},
{
    "ceph_monc_do_statfs": {
        "description": "Performs a statfs operation on the Ceph monitor client.",
        "pre": {
            "monc": {
                "type": "struct ceph_mon_client",
                "constraints": "!=null"
            },
            "data_pool": {
                "type": "u64",
                "constraints": "any"
            },
            "buf": {
                "type": "struct ceph_statfs",
                "constraints": "!=null"
            }
        }
    }
},
{
    "kretprobe:ceph_encode_string": {
        "description": "Encode a string and update the buffer.",
        "pre": {
            "p": "!=null",
            "end": "!=null",
            "what": "!=null",
            "strlen(what)": ">0"
        },
        "post": {
            "p": "==end"
        }
    }
},
S,
{
    "kretprobe:do_mon_command": {
        "description": "Execute a monitor command.",
        "pre": {
            "monc": "!=null",
            "client_addr": "!=null"
        }
    }
},
{
    "kprobe:do_mon_command": {
        "description": "Execute a monitor command with the given parameters.",
        "pre": {
            "monc": "!=null",
            "client_addr": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ceph_msgr_flush": {
        "description": "Flush the msgr queue before destroying the monc object.",
        "pre": {
            "monc": "!=null",
            "monc->auth": "!=null",
            "RB_EMPTY_ROOT(&monc->generic_request_tree)": "false",
            "monc->m_auth": "!=null",
            "monc->m_auth_reply": "!=null",
            "monc->m_subscribe": "!=null",
            "monc->m_subscribe_ack": "!=null",
            "monc->monmap": "!=null"
        }
    },
    "kretprobe:ceph_auth_destroy": {
        "description": "Destroy the authentication object of the monc.",
        "pre": {
            "monc": "!=null",
            "monc->auth": "!=null"
        }
    },
    "kretprobe:WARN_ON": {
        "description": "Check if the RB tree of generic requests is empty.",
        "pre": {
            "!RB_EMPTY_ROOT(&monc->generic_request_tree)": "true"
        }
    },
    "kretprobe:ceph_msg_put": {
        "description": "Put the given message object.",
        "pre": {
            "monc->m_auth": "!=null",
            "monc->m_auth_reply": "!=null",
            "monc->m_subscribe": "!=null",
            "monc->m_subscribe_ack": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Free the memory allocated for monc->monmap.",
        "pre": {
            "monc->monmap": "!=null"
        }
    }
},
{
    "kprobe:ceph_monc_stop": {
        "description": "Stop the ceph_mon_client",
        "pre": {
            "monc": "!=null"
        }
    }
},
{
    "kretprobe:your_function_name": {
        "description": "Description of your function",
        "pre": {
            "in4": "!=null",
            "in6": "!=null",
            "i": ">=0",
            "s": "!=null",
            "ss.ss_family": "in [AF_INET, AF_INET6]"
        }
    }
},
{
    "kprobe:struct_sockaddr_in": {
        "description": "Converts the sockaddr_storage structure to sockaddr_in structure.",
        "pre": {
            "ss": "!=null",
            "ss.ss_family": "==AF_INET"
        }
    },
    "kprobe:struct_sockaddr_in6": {
        "description": "Converts the sockaddr_storage structure to sockaddr_in6 structure.",
        "pre": {
            "ss": "!=null",
            "ss.ss_family": "==AF_INET6"
        }
    },
    "kprobe:atomic_inc_return": {
        "description": "Atomically increments the value of addr_str_seq and returns the result.",
        "pre": {
            "addr_str_seq": "!=null"
        }
    },
    "kprobe:addr_str": {
        "description": "Accesses the addr_str array using the index i.",
        "pre": {
            "addr_str": "!=null",
            "i": ">=0",
            "i": "<ADDR_STR_COUNT_MASK"
        }
    },
    "kprobe:switch_ss_family": {
        "description": "Performs a switch statement based on the value of ss.ss_family.",
        "pre": {
            "ss.ss_family": "in [AF_INET, AF_INET6]"
        }
    }
},
{
    "kretprobe:ceph_con_flag_clear": {
        "description": "Forcibly clear the SOCK_CLOSED flag.",
        "pre": {
            "con": "!=null",
            "con->sock": "!=null"
        }
    },
    "kretprobe:con_sock_state_closed": {
        "description": "Set the connection socket state to closed.",
        "pre": {
            "con": "!=null"
        }
    },
    "kretprobe:return_rc": {
        "description": "Return the value of rc.",
        "pre": {}
    }
},
{
    "kprobe:ceph_con_flag_clear": {
        "description": "Forcibly clear the SOCK_CLOSED flag. It gets set independent of the connection mutex, and we could have received a socket close event before we had the chance to shut the socket down.",
        "pre": {
            "con": "!=null",
            "con->sock": "!=null"
        }
    }
},
{
    "kretprobe:mutex_unlock": {
        "description": "Unlock the mutex associated with the given 'con' object and queue the 'con' object.",
        "pre": {
            "con": "!=null"
        }
    }
},
{
    "kprobe:mutex_unlock": {
        "description": "Unlock the mutex pointed to by con->mutex.",
        "pre": {
            "con": "!=null"
        }
    },
    "kprobe:queue_con": {
        "description": "Add con to the queue.",
        "pre": {
            "con": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:msg->hdr.src = con->msgr->inst.name;BUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));msg->needs_out_seq = true;mutex_lock(&con->mutex);if (con->state == CEPH_CON_S_CLOSED)": {
        "description": "Set the source of the message header to the name of the connection instance. Check if the length of the front iov is equal to the front length in the message header. Set the needs_out_seq flag to true. Acquire a lock on the connection mutex. Check if the state of the connection is CEPH_CON_S_CLOSED.",
        "pre": {
            "msg->hdr.src": "con->msgr->inst.name",
            "msg->front.iov_len": "== le32_to_cpu(msg->hdr.front_len)",
            "msg->needs_out_seq": "== true",
            "mutex_lock(&con->mutex)": "true",
            "con->state": "== CEPH_CON_S_CLOSED"
        }
    }
},
{
    "kprobe:msg->hdr.src = con->msgr->inst.name;BUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));msg->needs_out_seq = true;mutex_lock(&con->mutex);if (con->state == CEPH_CON_S_CLOSED)": {
        "description": "Set the source of the message header to the name of the connection instance. Check if the length of the front iov is equal to the front length in the message header. Set the needs_out_seq flag to true. Acquire a lock on the connection mutex. Check if the connection state is CEPH_CON_S_CLOSED.",
        "pre": {
            "msg->hdr.src": "con->msgr->inst.name",
            "msg->front.iov_len": "== le32_to_cpu(msg->hdr.front_len)",
            "msg->needs_out_seq": "true",
            "mutex_lock(&con->mutex)": "true",
            "con->state": "== CEPH_CON_S_CLOSED"
        }
    }
},
S,
{
    "if (front_len)": {
        "description": "Check if the front_len argument is non-zero.",
        "pre": {
            "front_len": "!=0"
        }
    }
},
{
    "kretprobe:ceph_msg_free": {
        "description": "Free a generically kmalloc'd message.",
        "pre": {}
    }
},
{
    "kprobe:ceph_msg_free": {
        "description": "Free a generically kmalloc'd message.",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:ceph_msg_remove": {
        "description": "Reset a connection. Discard all incoming and outgoing messages and clear _seq state.",
        "pre": {
            "msg": "!=null"
        }
    }
},
{
    "kprobe:ceph_msg_remove": {
        "description": "Reset a connection. Discard all incoming and outgoing messages and clear _seq state.",
        "pre": {
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:ceph_decode_entity_addr_legacy": {
        "description": "Decode the entity address in the Ceph protocol.",
        "pre": {
            "p": "!=null",
            "end": "!=null",
            "addr": "!=null",
            "struct_v": "u8",
            "struct_len": "u32",
            "addr_len": "u32",
            "struct_end": "void",
            "ret": "int",
            "bad": "label"
        },
        "post": {
            "ret": "0",
            "p": "struct_end",
            "bad": "return ret;"
        }
    }
},
{
    "kprobe:ceph_decode_entity_addr_legacy": {
        "description": "Decode entity address in the ceph_decode_entity_addr_legacy function.",
        "pre": {
            "**p": "= struct_end",
            "addr->type": "!= null",
            "addr->nonce": "!= null",
            "addr_len": null,
            "addr_len <= sizeof(addr->in_addr)": true
        }
    }
},
{
    "kretprobe:if (addr_cnt == 1 && !memchr_inv(&tmp_addr, 0, sizeof(tmp_addr)))return 0;  /* weird but effectively the same as !addr_cnt */": {
        "description": "Check if addr_cnt is equal to 1 and memchr_inv(&tmp_addr, 0, sizeof(tmp_addr)) is false.",
        "pre": {
            "addr_cnt": "== 1",
            "!memchr_inv(&tmp_addr, 0, sizeof(tmp_addr))": "false"
        }
    }
},
{
    "kprobe:if (addr_cnt == 1 && !memchr_inv(&tmp_addr, 0, sizeof(tmp_addr)))return 0;  /* weird but effectively the same as !addr_cnt */": {
        "description": "Check if addr_cnt is equal to 1 and tmp_addr does not contain any non-zero bytes.",
        "pre": {
            "addr_cnt": "== 1",
            "!memchr_inv(&tmp_addr, 0, sizeof(tmp_addr))": "true"
        }
    }
},
S,
S,
{
    "kretprobe:ceph_cls_lock": {
        "description": "Grab rados lock for object",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "type": "in [CEPH_CLS_LOCK_EXCLUSIVE, CEPH_CLS_LOCK_SHARED]",
            "cookie": "!=null",
            "tag": "!=null",
            "desc": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ceph_cls_lock": {
        "description": "Grab rados lock for object",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "type": "in [CEPH_CLS_LOCK_EXCLUSIVE, CEPH_CLS_LOCK_SHARED]",
            "cookie": "!=null",
            "tag": "!=null",
            "desc": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ceph_cls_unlock": {
        "description": "Release rados lock for object",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:ceph_cls_unlock": {
        "description": "Release rados lock for object",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:ceph_cls_break_lock": {
        "description": "Release rados lock for object for specified client",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "cookie": "!=null",
            "locker": "!=null"
        }
    }
},
{
    "kprobe:ceph_cls_break_lock": {
        "description": "Release rados lock for object for specified client",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "cookie": "!=null",
            "locker": "!=null"
        }
    }
},
{
    "kretprobe:ceph_start_encoding": {
        "description": "Encodes lock information and sets a cookie.",
        "pre": {
            "p": "!=null",
            "end": "!=null",
            "lock_name": "!=null",
            "name_len": ">0",
            "type": "is an integer",
            "old_cookie": "!=null",
            "tag": "!=null",
            "new_cookie": "!=null",
            "cookie_op_buf_size": ">0",
            "ret": "is an integer"
        }
    }
},
{
    "kprobe:ceph_start_encoding": {
        "description": "Encodes lock information and sets a cookie.",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "type": "!=null",
            "old_cookie": "!=null",
            "tag": "!=null",
            "new_cookie": "!=null",
            "cookie_op_buf_size": "> CEPH_ENCODING_START_BLK_LEN",
            "name_len": "= strlen(lock_name)",
            "old_cookie_len": "= strlen(old_cookie)",
            "tag_len": "= strlen(tag)",
            "new_cookie_len": "= strlen(new_cookie)",
            "p": "!=null",
            "end": "!=null",
            "cookie_op_page": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:ceph_start_encoding": {
        "description": "The kretprobe function for ceph_start_encoding.",
        "pre": {
            "p": "!=null",
            "get_info_op_buf_size": "> PAGE_SIZE",
            "name_len": ">= 0",
            "get_info_op_page": "!=null",
            "reply_page": "!=null",
            "reply_len": "<= PAGE_SIZE",
            "ret": ">= 0"
        }
    }
},
{
    "kprobe:ceph_cls_lock_info": {
        "description": "Function to get lock information in Ceph OSD client.",
        "pre": {
            "osdc": "!=null",
            "oid": "!=null",
            "oloc": "!=null",
            "lock_name": "!=null",
            "type": "!=null",
            "tag": "!=null",
            "lockers": "!=null",
            "num_lockers": "!=null",
            "get_info_op_buf_size": ">= name_len + sizeof(__le32) + CEPH_ENCODING_START_BLK_LEN",
            "name_len": ">= 0",
            "get_info_op_page": "!=null",
            "reply_page": "!=null",
            "reply_len": ">= PAGE_SIZE",
            "p": "!=null",
            "end": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:ceph_start_encoding": {
        "description": "Encodes various parameters and performs an assert_locked operation.",
        "pre": {
            "req": "!=null",
            "which": "int",
            "lock_name": "!=null",
            "type": "u8",
            "cookie": "!=null",
            "tag": "!=null",
            "assert_op_buf_size": "int",
            "name_len": "int",
            "cookie_len": "int",
            "tag_len": "int",
            "pages": "struct page",
            "p": "void",
            "end": "void",
            "ret": "int"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ceph_start_encoding": {
        "description": "Encodes data for ceph start encoding.",
        "pre": {
            "p": "!=null",
            "assert_op_buf_size": "!=null",
            "CEPH_ENCODING_START_BLK_LEN": "!=null",
            "lock_name": "!=null",
            "name_len": "!=null",
            "cookie": "!=null",
            "cookie_len": "!=null",
            "tag": "!=null",
            "tag_len": "!=null",
            "req": "!=null",
            "which": "!=null",
            "pages": "!=null",
            "assert_op_buf_size - CEPH_ENCODING_START_BLK_LEN": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ceph_pagelist_reserve": {
        "description": "Allocate enough pages for a pagelist to append the given amount of data without allocating.",
        "pre": {
            "pl": "!=null",
            "space": ">=0"
        }
    }
},
{
    "kprobe:ceph_pagelist_reserve": {
        "description": "Allocate enough pages for a pagelist to append the given amount of data without allocating.",
        "pre": {
            "pl": "!=null",
            "space": ">=0"
        }
    }
},
S,
{
    "kprobe:list_move_tail": {
        "description": "Move the page from pagelist to reserve.",
        "pre": {
            "page->lru": "!=null",
            "pl->free_list": "!=null",
            "pl->num_pages_free": ">0",
            "c->room": "!=null",
            "pl->head": "not empty"
        }
    }
},
{
    "kretprobe:__u32 len;      /* how many key bytes still need mixing`": {
        "description": "Calculate the hash value for a string using the rjenkins algorithm.",
        "pre": {
            "str": "!=null",
            "length": ">0",
            "a": "is __u32",
            "b": "is __u32",
            "c": "is __u32"
        }
    }
},
{
    "kprobe:__u32 len": {
        "description": "The __u32 len helper function",
        "pre": {
            "str": "!=null",
            "length": ">0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ceph_compare_options": {
        "description": "Compare options in the ceph client",
        "pre": {
            "!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net))": true,
            "ret": "!=0",
            "ret": "!=0",
            "ret": "!=0",
            "ret": "!=0",
            "opt1->key && !opt2->key": true,
            "!opt1->key && opt2->key": true,
            "opt1->key && opt2->key": true
        }
    }
},
{
    "kprobe:ceph_compare_options": {
        "description": "Compare options of ceph client",
        "pre": {
            "!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net))": true,
            "ret = memcmp(opt1, opt2, ofs)": true,
            "ret = strcmp_null(opt1->name, opt2->name)": true,
            "opt1->key && !opt2->key": -1,
            "!opt1->key && opt2->key": 1,
            "opt1->key && opt2->key": true
        }
    }
},
{
    "kretprobe:ceph_parse_ips": {
        "description": "Parse IP addresses from a buffer and store them in the ceph_options structure.",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "opt->mon_addr": "!=null",
            "CEPH_MAX_MON": ">=0",
            "&opt->num_mon": "!=null",
            "delim": ">=0"
        }
    }
},
{
    "kprobe:ceph_parse_ips": {
        "description": "Parse IP addresses from a buffer and store them in the ceph_options structure.",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "opt->mon_addr": "!=null",
            "CEPH_MAX_MON": ">=0",
            "&opt->num_mon": "!=null",
            "delim": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:ceph_print_client_options": {
        "description": "Print client options for Ceph",
        "pre": {
            "m->count": "!= pos",
            "m->count--": "true",
            "return": "0"
        }
    }
},
{
    "kprobe:ceph_print_client_options": {
        "description": "Print client options",
        "pre": {
            "m": "!=null",
            "client": "!=null",
            "show_all": "!=null"
        }
    }
},
{
    "kretprobe:ceph_create_client": {
        "description": "Create a Ceph client",
        "pre": {
            "client": "!=null",
            "opt": "!=null",
            "private": "!=null",
            "myaddr": "!=null",
            "err": ">=0",
            "client->private": "==private",
            "client->options": "==opt",
            "client->mount_mutex": "initialized",
            "client->auth_wq": "initialized",
            "client->auth_err": "==0",
            "client->extra_mon_dispatch": "==NULL",
            "client->supported_features": "==CEPH_FEATURES_SUPPORTED_DEFAULT",
            "client->required_features": "==CEPH_FEATURES_REQUIRED_DEFAULT",
            "ceph_test_opt(client, NOMSGSIGN)": "true",
            "client->required_features": "|= CEPH_FEATURE_MSG_AUTH"
        }
    }
},
{
    "kprobe:ceph_create_client": {
        "description": "Create a Ceph client",
        "pre": {
            "client": "!=null",
            "opt": "!=null",
            "private": "!=null",
            "myaddr": "!=null if ceph_test_opt(client, MYIP) is true"
        }
    },
    "kprobe:ceph_messenger_init": {
        "description": "Initialize the Ceph messenger",
        "pre": {
            "client": "!=null",
            "msgr": "!=null",
            "myaddr": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ceph_monc_open_session": {
        "description": "Open session and wait for mon and osd maps",
        "pre": {
            "client": "!=null",
            "client->monc": "!=null",
            "err": "int",
            "err < 0": "true",
            "have_mon_and_osd_map(client)": "false"
        }
    }
},
{
    "kprobe:ceph_monc_open_session": {
        "description": "Open session and wait for mon and osd maps.",
        "pre": {
            "client": "!=null",
            "client->monc": "!=null",
            "err": "int",
            "err < 0": "true",
            "have_mon_and_osd_map(client)": "false"
        }
    }
},
{
    "kretprobe:ceph_osdc_alloc_messages": {
        "description": "Allocate messages for OSD requests in Ceph.",
        "pre": {
            "req": "!=null",
            "gfp": "!=null",
            "num_request_data_items": "!=null",
            "num_reply_data_items": "!=null",
            "osdc": "!=null",
            "msg": "!=null",
            "msg_size": "CEPH_ENCODING_START_BLK_LEN + CEPH_PGID_ENCODING_LEN + 1",
            "req->r_request": "null",
            "req->r_reply": "null",
            "req->r_base_oid": "!=empty",
            "req->r_base_oloc": "!=empty"
        }
    }
},
{
    "kprobe:ceph_osdc_alloc_messages": {
        "description": "Create request message",
        "pre": {
            "req": "!=null",
            "gfp": "!=null",
            "num_request_data_items": "!=null",
            "num_reply_data_items": "!=null"
        }
    }
},
{
    "kretprobe:osd_req_op_init": {
        "description": "Initialize an OSD request operation.",
        "pre": {
            "req": "!=null",
            "req->r_kref": "!=null",
            "req->r_completion": "!=null",
            "req->r_node": "RB_EMPTY_NODE(&req->r_node)",
            "req->r_mc_node": "RB_EMPTY_NODE(&req->r_mc_node)",
            "req->r_private_item": "list_empty(&req->r_private_item)",
            "req->r_t": "target_initialized(&req->r_t)"
        }
    }
},
{
    "kprobe:osd_req_op_init": {
        "description": "Initialize an OSD request operation.",
        "pre": {
            "req": "!=null",
            "req->r_kref": "!=null",
            "req->r_completion": "!=null",
            "req->r_node": "!=null",
            "req->r_mc_node": "!=null",
            "req->r_private_item": "!=null",
            "req->r_t": "!=null",
            "sizeof(*req)": ">=0",
            "num_ops": ">=0",
            "use_mempool": "in [true, false]",
            "gfp_flags": ">=0"
        }
    }
},
{
    "kretprobe:osd_req_op_extent_update": {
        "description": "Update the extent length of the osd_req_op structure in the osd_req object.",
        "pre": {
            "osd_req": "!=null",
            "which": ">=0",
            "length": ">=0",
            "which": "< osd_req->r_num_ops",
            "op": "!=null",
            "op->extent.length": ">=0",
            "length": "!=op->extent.length"
        }
    }
},
{
    "kprobe:osd_req_op_extent_update": {
        "description": "Update the extent length of a specific OSD request operation.",
        "pre": {
            "osd_req": "!=null",
            "which": "< osd_req->r_num_ops",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:op->indata_len = prev_op->indata_len;op->outdata_len = prev_op->outdata_len;op->extent = prev_op->extent;/* adjust offset": {
        "description": "Duplicate the last extent of the previous OSD request operation",
        "pre": {
            "op": "!=null",
            "prev_op": "!=null",
            "op->indata_len": "== prev_op->indata_len",
            "op->outdata_len": "== prev_op->outdata_len",
            "op->extent": "== prev_op->extent"
        }
    }
},
{
    "kprobe:op->indata_len = prev_op->indata_len; op->outdata_len = prev_op->outdata_len; op->extent = prev_op->extent;/* adjust offset `": {
        "description": "Set the values of op->indata_len, op->outdata_len, op->extent, and offset.",
        "pre": {
            "op->indata_len": "!=null",
            "op->outdata_len": "!=null",
            "op->extent": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:op->flags |= CEPH_OSD_OP_FLAG_FAILOK;}EXPORT_SYMBOL(osd_req_op_alloc_hint_init": {
        "description": "Initialize the allocation hint for the OSD request operation.",
        "pre": {
            "osd_req": "!=null",
            "which": "unsigned int",
            "expected_object_size": "u64",
            "expected_write_size": "u64",
            "flags": "u32"
        }
    }
},
{
    "kprobe:op->flags |= CEPH_OSD_OP_FLAG_FAILOK;}EXPORT_SYMBOL(osd_req_op_alloc_hint_init": {
        "description": "Initialize the allocation hint for the OSD request operation.",
        "pre": {
            "osd_req": "!=null",
            "which": "unsigned int",
            "expected_object_size": "u64",
            "expected_write_size": "u64",
            "flags": "u32"
        }
    }
},
{
    "kretprobe:calc_layout": {
        "description": "Calculate the layout for a file operation.",
        "pre": {
            "layout": "!=null",
            "off": "!=null",
            "plen": "!=null",
            "objnum": "!=null",
            "objoff": "!=null",
            "objlen": "!=null",
            "r": "==0",
            "opcode": "in [CEPH_OSD_OP_CREATE, CEPH_OSD_OP_DELETE]"
        }
    }
},
{
    "kprobe:calc_layout": {
        "description": "Calculate the layout for a file.",
        "pre": {
            "osdc": "!=null",
            "layout": "!=null",
            "vino": "!=null",
            "off": ">=0",
            "plen": ">=0",
            "which": ">=0",
            "num_ops": ">=0",
            "opcode": "in [CEPH_OSD_OP_READ, CEPH_OSD_OP_WRITE, CEPH_OSD_OP_ZERO, CEPH_OSD_OP_TRUNCATE, CEPH_OSD_OP_CREATE, CEPH_OSD_OP_DELETE]",
            "flags": "!=null",
            "snapc": "!=null",
            "truncate_seq": ">=0",
            "truncate_size": ">=0",
            "use_mempool": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:sctp_do_peeloff": {
        "description": "Peel off an association from a socket.",
        "pre": {
            "!net_eq(current->nsproxy->net_ns, sock_net(sk))": true,
            "!asoc": true
        }
    }
},
{
    "kprobe:sctp_do_peeloff": {
        "description": "Peel off an association from a socket.",
        "pre": {
            "!net_eq(current->nsproxy->net_ns, sock_net(sk))": true,
            "!asoc": true
        }
    }
},
{
    "kretprobe:atm_pcr_goal": {
        "description": "Returns the positive PCR if it should be rounded up, the negative PCR if it should be rounded down, and zero if the maximum available bandwidth should be used.",
        "pre": {
            "tp": "!=null"
        },
        "post": {
            "PCR": {
                "conditions": [
                    {
                        "PCR": "x",
                        "min": "-",
                        "max": "-"
                    },
                    {
                        "PCR": "x+",
                        "min": "-",
                        "max": "x"
                    },
                    {
                        "PCR": "x-",
                        "min": "x",
                        "max": "-"
                    },
                    {
                        "PCR": "zz-",
                        "min": "zz",
                        "max": "-"
                    },
                    {
                        "PCR": "zz-x",
                        "min": "zz",
                        "max": "zz"
                    },
                    {
                        "PCR": "y-",
                        "min": "y",
                        "max": "-"
                    },
                    {
                        "PCR": "y",
                        "min": "y",
                        "max": "y"
                    },
                    {
                        "PCR": "y-x",
                        "min": "y",
                        "max": "x"
                    },
                    {
                        "PCR": "y-x",
                        "min": "y",
                        "max": "-"
                    },
                    {
                        "PCR": "y",
                        "min": "y",
                        "max": "-"
                    }
                ]
            }
        }
    }
},
{
    "kprobe:atm_pcr_goal": {
        "description": "Returns the positive PCR if it should be rounded up, the negative PCR if it should be rounded down, and zero if the maximum available bandwidth should be used.",
        "pre": {
            "tp": "!=null",
            "tp->pcr": "in [z-, x+, y-]"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the atm_dev_mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:list_del": {
        "description": "Deletes the dev from the dev_list.",
        "pre": {
            "list": "!=null",
            "dev": "!=null"
        }
    },
    "kretprobe:mutex_unlock": {
        "description": "Unlocks the atm_dev_mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:atm_dev_release_vccs": {
        "description": "Releases all vccs associated with the dev.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kretprobe:atm_unregister_sysfs": {
        "description": "Deregisters the dev from sysfs.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kretprobe:atm_proc_dev_deregister": {
        "description": "Deregisters the dev from proc.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kretprobe:atm_dev_put": {
        "description": "Decrements the reference count of dev.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL": {
        "description": "Exports the atm_dev_deregister symbol.",
        "pre": {
            "symbol": "atm_dev_deregister"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:list_del": {
        "description": "Remove an entry from a linked list.",
        "pre": {
            "list": "!=null",
            "entry": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:atm_dev_release_vccs": {
        "description": "Release all VCCs associated with an ATM device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:atm_unregister_sysfs": {
        "description": "Unregister an ATM device from sysfs.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:atm_proc_dev_deregister": {
        "description": "Deregister an ATM device from procfs.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:atm_dev_put": {
        "description": "Decrement the reference count of an ATM device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL": {
        "description": "Export a symbol for use by other modules.",
        "pre": {
            "symbol": "atm_dev_deregister"
        }
    }
},
S,
{
    "kprobe:WARN_ON": {
        "description": "Check if the signal is within the valid range and if it has changed.",
        "pre": {
            "signal": ">= ATM_PHY_SIG_LOST",
            "signal": "<= ATM_PHY_SIG_FOUND",
            "dev->signal": "!= signal"
        }
    }
},
{
    "kretprobe:__ipv6_addr_type": {
        "description": "Check the type of an IPv6 address.",
        "pre": {
            "addr": "!=null",
            "st": "!=null",
            "st & htonl(0xE0000000)": "!= htonl(0x00000000)",
            "st & htonl(0xE0000000)": "!= htonl(0xE0000000)",
            "st & htonl(0xFF000000)": "== htonl(0xFF000000)"
        },
        "post": {
            "return": "IPV6_ADDR_UNICAST | IPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL)"
        }
    }
},
{
    "kprobe:__ipv6_addr_type": {
        "description": "Check the type of an IPv6 address.",
        "pre": {
            "addr": "!=null",
            "st": "!=null",
            "st & htonl(0xE0000000)": "!= htonl(0x00000000)",
            "st & htonl(0xE0000000)": "!= htonl(0xE0000000)",
            "st & htonl(0xFF000000)": "== htonl(0xFF000000)"
        }
    }
},
{
    "kretprobe:in6_dev_finish_destroy": {
        "description": "Nobody refers to this device, we may destroy it.",
        "pre": {
            "head": "!=null",
            "idev": "!=null",
            "idev->rcu": "valid pointer",
            "idev->rcu == &head": "true",
            "idev->snmp6": "valid pointer",
            "idev->snmp6->refcnt": "== 0"
        }
    }
},
{
    "kprobe:in6_dev_finish_destroy": {
        "description": "Nobody refers to this device, we may destroy it.",
        "pre": {
            "idev": "!=null"
        }
    }
},
S,
{
    "kprobe:saddr_first_seg_flags_keyid_seglist": {
        "description": "Function saddr(16) + first_seg(1) + flags(1) + keyid(4) + seglist(16n)",
        "pre": {
            "hinfo": "!=null",
            "hdr": "!=null",
            "saddr": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:seg6_hmac_validate_skb": {
        "description": "Checks if seg6_require_hmac is greater than 0 and tlv is false.",
        "pre": {
            "idev->cnf.seg6_require_hmac": "> 0",
            "tlv": "== false"
        }
    }
},
{
    "seg6_hmac_validate_skb": {
        "description": "Validate the HMAC field in the given skb.",
        "pre": {
            "idev->cnf.seg6_require_hmac": "> 0",
            "tlv": "false"
        }
    }
},
{
    "kretprobe:seg6_hmac_info_lookup": {
        "description": "Lookup the HMAC info associated with the given key in the specified network namespace.",
        "pre": {
            "net": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:seg6_hmac_info_lookup": {
        "description": "Lookup seg6_hmac_info based on the given net and key.",
        "pre": {
            "net": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:ipv6_mc_check_mld_query": {
        "description": "Check MLD query for link-local source addresses.",
        "pre": {
            "skb": "!=null",
            "transport_len": ">= sizeof(struct ipv6hdr)",
            "mld": "!=null",
            "len": ">= sizeof(struct mld_msg)",
            "ipv6_addr_type(&ipv6_hdr(skb)->saddr)": "& IPV6_ADDR_LINKLOCAL == 0"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)": {
        "description": "Check if the IPv6 source address is not link-local.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:xfrm6_input_addr": {
        "description": "Lookup state with wild-card addresses",
        "pre": {
            "skb": "!=null",
            "daddr": "!=null",
            "saddr": "!=null",
            "proto": "!=null"
        }
    }
},
{
    "kprobe:xfrm6_input_addr": {
        "description": "lookup state with wild-card addresses",
        "pre": {
            "skb": "!=null",
            "daddr": "!=null",
            "saddr": "!=null",
            "proto": "!=null"
        }
    }
},
{
    "kretprobe:ipv6_setsockopt": {
        "description": "Set IPv6 socket options.",
        "pre": {
            "sk->sk_family": "!= AF_INET6",
            "optname": "in [optname1, optname2, ...]",
            "optval": "!= null",
            "optlen": ">= sizeof(int)",
            "np": "!= null",
            "net": "!= null",
            "val": "!= null",
            "valbool": "!= null",
            "retv": "== -ENOPROTOOPT",
            "needs_rtnl": "is boolean"
        }
    }
},
{
    "kprobe:if (unlikely(sk->sk_family != AF_INET6))goto unlock;switch (optname)": {
        "description": "Check if the socket family is not AF_INET6 and handle different cases based on optname.",
        "pre": {
            "sk->sk_family": "!= AF_INET6",
            "optname": "in [case1, case2, case3, ...]"
        }
    }
},
{
    "kretprobe:ipv6_get_msfilter": {
        "description": "Get the IPv6 multicast source filter options for a socket.",
        "pre": {
            "sk": "!=null",
            "opt": "!=null",
            "optname": "in [IPV6_HOPOPTS, IPV6_RTHDRDSTOPTS, IPV6_RTHDR, IPV6_DSTOPTS]",
            "optval": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:ipv6_get_msfilter": {
        "description": "ipv6_getsockopt_sticky(struct sock sk, struct ipv6_txoptions opt, int optname, sockptr_t optval, int len)",
        "pre": {
            "sk": "!=null",
            "opt": "!=null",
            "optname": "in [IPV6_HOPOPTS, IPV6_RTHDRDSTOPTS, IPV6_RTHDR, IPV6_DSTOPTS]",
            "optval": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:__inet6_lookup_established": {
        "description": "Lookup an established IPv6 connection in the inet6 hash table.",
        "pre": {
            "net": "!=null",
            "hashinfo": "!=null",
            "saddr": "!=null",
            "sport": "!=null",
            "daddr": "!=null",
            "hnum": "!=null",
            "dif": "!=null",
            "sdif": "!=null",
            "sk": "!=null",
            "node": "!=null",
            "ports": "!=null"
        }
    }
},
{
    "kprobe:__inet6_lookup_established": {
        "description": "Lookup an established IPv6 connection in the inet6 hash table.",
        "pre": {
            "net": "!=null",
            "hashinfo": "!=null",
            "saddr": "!=null",
            "sport": "!=null",
            "daddr": "!=null",
            "hnum": "!=null",
            "dif": "!=null",
            "sdif": "!=null",
            "sk": "!=null",
            "node": "!=null",
            "ports": "!=null"
        }
    }
},
{
    "kretprobe:ipv6_proxy_select_ident": {
        "description": "This function exists only for tap drivers that must support broken clients requesting UFO without specifying an IPv6 fragment ID. This is similar to ipv6_select_ident() but we use an independent hash seed to limit information leakage. The network header must be set before calling this.",
        "pre": {
            "net": "!=null",
            "dst": "!=null",
            "src": "!=null"
        },
        "post": {
            "__be32": ">0"
        }
    }
},
{
    "kprobe:ipv6_proxy_select_ident": {
        "description": "This function exists only for tap drivers that must support broken clients requesting UFO without specifying an IPv6 fragment ID.",
        "pre": {
            "net": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:skb_checksum_init_zero_check": {
        "description": "Check the checksum of the skb and initialize it to zero if necessary.",
        "pre": {
            "skb": "!=null",
            "proto": "!=null",
            "uh->check": "!=null",
            "ip6_compute_pseudo": "!=null"
        }
    },
    "kretprobe:return_value": {
        "description": "Check the return value of skb_checksum_init_zero_check.",
        "pre": {
            "err": "==0"
        }
    },
    "kretprobe:skb_ip_summed_check": {
        "description": "Check the value of skb->ip_summed and skb->csum_valid.",
        "pre": {
            "skb->ip_summed": "==CHECKSUM_COMPLETE",
            "skb->csum_valid": "==false"
        }
    }
},
{
    "kprobe:udp6_csum_init": {
        "description": "Initialize UDPv6 checksum.",
        "pre": {
            "skb": "!=null",
            "uh": "!=null",
            "proto": "int",
            "UDP_SKB_CB(skb)->partial_cov": "==0",
            "UDP_SKB_CB(skb)->cscov": "skb->len",
            "proto == IPPROTO_UDPLITE": {
                "pre": {
                    "err": "int",
                    "udplite_checksum_init(skb, uh)": "==0",
                    "UDP_SKB_CB(skb)->partial_cov": "!=0",
                    "skb->csum": "ip6_compute_pseudo(skb, proto)"
                }
            }
        }
    }
},
{
    "kretprobe:if (sk->sk_state != TCP_CLOSE || inet->inet_num)": {
        "description": "Check if the socket state is not TCP_CLOSE or inet_num is non-zero.",
        "pre": {
            "sk->sk_state": "!= TCP_CLOSE",
            "inet->inet_num": "!= 0"
        }
    }
},
{
    "kprobe:inet6_bind": {
        "description": "Bind an IPv6 socket to a specific address and port.",
        "pre": {
            "sk->sk_state": "!= TCP_CLOSE",
            "inet->inet_num": "!= null"
        }
    }
},
{
    "kretprobe:ipv6_sock_mc_close": {
        "description": "Free multicast lists for IPv6 socket.",
        "pre": {
            "sock": "!=null",
            "sock->sk": "!=null"
        }
    }
},
{
    "kprobe:ipv6_sock_mc_close": {
        "description": "Free multicast lists for IPv6 socket.",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:inet6_ioctl": {
        "description": "The inet6_ioctl function",
        "pre": {
            "sock": "!=null",
            "cmd": "unsigned int",
            "arg": "unsigned long",
            "argp": "void __user",
            "sk": "struct sock",
            "net": "struct net",
            "prot": "const struct proto",
            "rtmsg": "struct in6_rtmsg",
            "copy_from_user": "function",
            "ipv6_route_ioctl": "function",
            "addrconf_add_ifaddr": "function",
            "addrconf_del_ifaddr": "function",
            "addrconf_set_dstaddr": "function",
            "IPV6_ADDRFORM": "constant"
        },
        "post": {
            "return_value": "int",
            "conditions": [
                "return_value == -ENOIOCTLCMD"
            ]
        }
    }
},
{
    "kprobe:READ_ONCE": {
        "description": "Read the value of `sk_prot` from `sk`.",
        "pre": {
            "sk": "!=null"
        }
    },
    "kprobe:sk_ioctl": {
        "description": "Invoke the `sk_ioctl` function with the given arguments.",
        "pre": {
            "sk": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:answer = NULL;ret = -EPERM;last_perm = &inetsw6[p->type];list_for_each(lh, &inetsw6[p->type])": {
        "description": "Register IPv6 protocol switch.",
        "pre": {
            "p": "!=null",
            "p->protocol": "int",
            "p->type": "int",
            "inetsw6_lock": "spin_lock_bh",
            "ret": "-EPERM",
            "last_perm": "&inetsw6[p->type]",
            "lh": "struct list_head"
        }
    }
},
{
    "kprobe:answer = NULL;ret = -EPERM;last_perm = &inetsw6[p->type];list_for_each(lh, &inetsw6[p->type])": {
        "description": "Register IPv6 protocol switch.",
        "pre": {
            "p": "!=null",
            "p->protocol": "int",
            "p->type": "int",
            "inetsw6_lock": "spin_lock_bh",
            "ret": "-EPERM",
            "last_perm": "&inetsw6[p->type]",
            "lh": "struct list_head",
            "&inetsw6[p->type]": "struct list_head"
        }
    }
},
{
    "kretprobe:ndisc_mc_map": {
        "description": "Map multicast address to buffer for NDISC protocol.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "dev": "!=null",
            "dir": "in [0, 1]",
            "dev->type": "in [ARPHRD_ETHER, ARPHRD_IEEE802]"
        }
    }
},
{
    "kprobe:ndisc_mc_map": {
        "description": "Map multicast address to buffer for NDISC protocol.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "dev": "!=null",
            "dir": "!=null",
            "dev->type": "in [ARPHRD_ETHER, ARPHRD_IEEE802]"
        }
    }
},
{
    "kretprobe:skb_dst_drop": {
        "description": "Drop the destination cache associated with the given skb.",
        "pre": {
            "skb": "!=null"
        }
    },
    "kretprobe:skb_dst_set": {
        "description": "Set the destination cache of the given skb to the specified destination.",
        "pre": {
            "skb": "!=null",
            "dst": "!=null"
        }
    },
    "kretprobe:xfrm_decode_session": {
        "description": "Decode the session for the given skb and flowi6.",
        "pre": {
            "skb": "!=null",
            "flowi6_to_flowi(&fl6)": "!=null",
            "AF_INET6": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:skb_dst_drop(skb);skb_dst_set(skb, dst);#ifdef CONFIG_XFRMif (!(IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED) &&    xfrm_decode_session(skb, flowi6_to_flowi(&fl6), AF_INET6) == 0)": {
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:dst2 = dst;dst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), sk, 0);if (!IS_ERR(dst))": {
        "description": "This function assigns the value of 'dst' to 'dst2' and then performs a lookup using 'xfrm_lookup' with the given parameters. If the lookup is successful (i.e., 'dst' is not an error), further actions can be taken.",
        "pre": {
            "dst2": "!=null",
            "dst": "!=null",
            "net": "!=null",
            "flowi6_to_flowi(fl6)": "!=null",
            "sk": "!=null"
        }
    }
},
S,
{
    "kretprobe:ip6_err_gen_icmpv6_unreach": {
        "description": "RFC 4884 (partial) support for ICMP extensions",
        "pre": {
            "skb": "!=null",
            "nhs": "int",
            "type": "int",
            "data_len": "< 128 || (data_len & 7) || skb->len < data_len",
            "temp_saddr": "struct in6_addr",
            "rt": "struct rt6_info",
            "skb2": "struct sk_buff",
            "info": "u32"
        }
    }
},
{
    "kprobe:ip6_err_gen_icmpv6_unreach": {
        "description": "Generate ICMPv6 unreachable error message.",
        "pre": {
            "skb": "!=null",
            "nhs": ">=0",
            "type": ">=0",
            "data_len": ">=0"
        }
    }
},
{
    "kretprobe:fib6_info_hw_flags_set": {
        "description": "Set hardware flags for IPv6 fib info.",
        "pre": {
            "net->ipv6.sysctl.fib_notify_on_flag_change": "== 2",
            "READ_ONCE(f6i->offload_failed)": "== offload_failed"
        },
        "post": {
            "WRITE_ONCE(f6i->offload_failed)": "offload_failed"
        }
    }
},
{
    "kprobe:fib6_info_hw_flags_set": {
        "description": "Set hardware flags for IPv6 fib6_info structure.",
        "pre": {
            "net->ipv6.sysctl.fib_notify_on_flag_change": "== 2",
            "READ_ONCE(f6i->offload_failed)": "== offload_failed"
        },
        "post": {
            "WRITE_ONCE(f6i->offload_failed)": "= offload_failed"
        }
    }
},
{
    "kretprobe:ip6_tnl_parse_tlv_enc_lim": {
        "description": "Handle encapsulation limit option",
        "pre": {
            "skb": "!=null",
            "raw": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ip6_tnl_parse_tlv_enc_lim": {
        "description": "Handle encapsulation limit option",
        "pre": {
            "skb": "!=null",
            "raw": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:ip6_tnl_change_mtu": {
        "description": "Change mtu manually for tunnel device",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "new_mtu": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ip6_tnl_change_mtu": {
        "description": "Change mtu manually for tunnel device",
        "pre": {
            "dev": "!=null",
            "new_mtu": ">=0"
        }
    }
},
{
    "kretprobe:if (sin6)": {
        "description": "Description of the condition",
        "pre": {
            "sin6": "!=null"
        }
    }
},
{
    "kprobe:udpv6_sendmsg": {
        "description": "Send an IPv6 UDP message.",
        "pre": {
            "sk": "!=null",
            "msg": "!=null",
            "len": "!=null",
            "msg->msg_name": "!=null",
            "msg->msg_namelen": "!=null",
            "up": "!=null",
            "inet": "!=null",
            "np": "!=null",
            "sin6": "!=null",
            "daddr": "!=null",
            "final_p": "!=null",
            "final": "!=null",
            "opt": "!=null",
            "opt_to_free": "!=null",
            "flowlabel": "!=null",
            "cork": "!=null",
            "fl6": "!=null",
            "dst": "!=null",
            "ipc6": "!=null",
            "addr_len": "!=null",
            "connected": "!=null",
            "ulen": "!=null",
            "corkreq": "!=null",
            "err": "!=null",
            "is_udplite": "!=null",
            "getfrag": "!=null",
            "ipc6.gso_size": "!=null",
            "ipc6.sockc.tsflags": "!=null",
            "ipc6.sockc.mark": "!=null"
        }
    }
},
{
    "kretprobe:ipv6_ext_hdr": {
        "description": "Find out if nexthdr is an extension header or a protocol",
        "pre": {
            "nexthdr": "in [NEXTHDR_HOP, NEXTHDR_ROUTING, NEXTHDR_FRAGMENT, NEXTHDR_AUTH, NEXTHDR_NONE, NEXTHDR_DEST]"
        }
    }
},
{
    "kprobe:ipv6_ext_hdr": {
        "description": "Find out if nexthdr is an extension header or a protocol.",
        "pre": {
            "nexthdr": "in [NEXTHDR_HOP, NEXTHDR_ROUTING, NEXTHDR_FRAGMENT, NEXTHDR_AUTH, NEXTHDR_NONE, NEXTHDR_DEST]"
        }
    }
},
{
    "kretprobe:ipv6_find_hdr": {
        "description": "Find the IPv6 header in the given skb at the specified offset.",
        "pre": {
            "skb": "!=null",
            "offset": "!=null",
            "target": "!=null",
            "fragoff": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:skb_header_pointer": {
        "description": "Get a pointer to the specified header field in the given skb.",
        "pre": {
            "skb": "!=null",
            "start": "!=null",
            "field": "offsetof(struct frag_hdr, frag_off)",
            "size": "sizeof(_frag_off)",
            "pointer": "!=null"
        }
    },
    "kretprobe:ntohs": {
        "description": "Convert a 16-bit integer from network byte order to host byte order.",
        "pre": {
            "value": "*fp"
        },
        "post": {
            "result": "(_frag_off & ~0x7)"
        }
    },
    "kretprobe:!=null": {
        "description": "Check if the value is not null.",
        "pre": {
            "value": "fp"
        }
    },
    "kretprobe:==": {
        "description": "Check if the value is equal to the specified constant.",
        "pre": {
            "value": "(_frag_off & ~0x7)",
            "constant": "0"
        }
    }
},
{
    "kprobe:flags |= IP6_FH_F_FRAG;fp = skb_header_pointer(skb,start+offsetof(struct frag_hdr, frag_off),sizeof(_frag_off),&_frag_off);if (!fp)return -EBADMSG;_frag_off = ntohs(*fp) & ~0x7;if (_frag_off)": {
        "description": "Set the IP6_FH_F_FRAG flag and perform some operations on the skb structure.",
        "pre": {
            "flags": "!=null",
            "skb": "!=null",
            "start": "!=null",
            "offsetof(struct frag_hdr, frag_off)": "!=null",
            "sizeof(_frag_off)": "!=null",
            "fp": "!=null",
            "!fp": "false",
            "_frag_off": "!=null"
        }
    }
},
{
    "kretprobe:ip6_xmit": {
        "description": "Send an IPv6 packet.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "fl6": "!=null",
            "mark": "!=null",
            "opt": "!=null",
            "tclass": "!=null",
            "priority": "!=null",
            "np": "!=null",
            "first_hop": "!=null",
            "dst": "!=null",
            "dev": "!=null",
            "idev": "!=null",
            "hop_jumbo": "!=null",
            "hoplen": "!=null",
            "head_room": "!=null",
            "hdr": "!=null",
            "proto": "!=null",
            "seg_len": "!=null",
            "hlimit": "!=null",
            "mtu": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ip6_xmit": {
        "description": "Transmit an IPv6 packet.",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "fl6": "!=null",
            "mark": "!=null",
            "opt": "!=null",
            "tclass": "!=null",
            "priority": "!=null",
            "np": "!=null",
            "first_hop": "!=null",
            "dst": "!=null",
            "dev": "!=null",
            "idev": "!=null",
            "hop_jumbo": "!=null",
            "hoplen": "!=null",
            "head_room": "!=null",
            "hdr": "!=null",
            "proto": "!=null",
            "seg_len": "!=null",
            "hlimit": "!=null",
            "mtu": "!=null"
        },
        "post": {
            "skb": "!=null",
            "hdr": "!=null"
        }
    }
},
{
    "kretprobe:ip6_fraglist_init": {
        "description": "Initialize the IPv6 fragment list iterator and perform necessary operations on the skb.",
        "pre": {
            "skb": "!=null",
            "hlen": ">=0",
            "prevhdr": "is NEXTHDR_FRAGMENT",
            "nexthdr": "!=null",
            "frag_id": "!=null",
            "iter": "!=null",
            "iter->tmp_hdr": "!=null",
            "iter->frag": "!=null",
            "iter->offset": ">=0",
            "iter->hlen": ">=0",
            "iter->frag_id": "!=null",
            "iter->nexthdr": "!=null",
            "__skb_pull(skb, hlen)": "return value == 0",
            "__skb_push(skb, sizeof(struct frag_hdr))": "!=null",
            "__skb_push(skb, hlen)": "!=null",
            "skb_reset_network_header(skb)": "void",
            "memcpy(skb_network_header(skb), iter->tmp_hdr, hlen)": "void",
            "fh->nexthdr": "nexthdr",
            "fh->reserved": "0",
            "fh->frag_off": "htons(IP6_MF)",
            "fh->identification": "frag_id",
            "first_len": "skb_pagelen(skb)",
            "skb->data_len": "first_len - skb_headlen(skb)",
            "skb->len": "first_len",
            "ipv6_hdr(skb)->payload_len": "htons(first_len - sizeof(struct ipv6hdr))"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:*prevhdr = NEXTHDR_FRAGMENT;iter->tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);if (!iter->tmp_hdr)return -ENOMEM;iter->frag = skb_shinfo(skb)->frag_list;skb_frag_list_init(skb);iter->offset = 0;iter->hlen = hlen;iter->frag_id = frag_id;iter->nexthdr = nexthdr;__skb_pull(skb, hlen);fh = __skb_push(skb, sizeof(struct frag_hdr));__skb_push(skb, hlen);skb_reset_network_header(skb);memcpy(skb_network_header(skb), iter->tmp_hdr, hlen);fh->nexthdr = nexthdr;fh->reserved = 0;fh->frag_off = htons(IP6_MF);fh->identification = frag_id;first_len = skb_pagelen(skb);skb->data_len = first_len - skb_headlen(skb);skb->len = first_len;ipv6_hdr(skb)->payload_len = htons(first_len - sizeof(struct ipv6hdr));return 0;}EXPORT_SYMBOL(ip6_fraglist_init": {
        "description": "Build header",
        "pre": {
            "*prevhdr": "NEXTHDR_FRAGMENT",
            "iter->tmp_hdr": "!=null",
            "!iter->tmp_hdr": "-ENOMEM",
            "iter->frag": "!=null",
            "skb_shinfo(skb)->frag_list": "!=null",
            "skb_frag_list_init(skb)": "null",
            "iter->offset": "0",
            "iter->hlen": "hlen",
            "iter->frag_id": "frag_id",
            "iter->nexthdr": "nexthdr",
            "__skb_pull(skb, hlen)": "null",
            "fh": "!=null",
            "__skb_push(skb, sizeof(struct frag_hdr))": "null",
            "__skb_push(skb, hlen)": "null",
            "skb_reset_network_header(skb)": "null",
            "memcpy(skb_network_header(skb), iter->tmp_hdr, hlen)": "null",
            "fh->nexthdr": "nexthdr",
            "fh->reserved": "0",
            "fh->frag_off": "htons(IP6_MF)",
            "fh->identification": "frag_id",
            "first_len": "skb_pagelen(skb)",
            "skb->data_len": "first_len - skb_headlen(skb)",
            "skb->len": "first_len",
            "ipv6_hdr(skb)->payload_len": "htons(first_len - sizeof(struct ipv6hdr))",
            "return": "0"
        }
    }
},
{
    "kretprobe:inet6_add_protocol": {
        "description": "Add a new IPv6 protocol handler.",
        "pre": {
            "prot": "!=null",
            "protocol": ">=0"
        }
    }
},
S,
{
    "kretprobe:ipv6_dev_get_saddr": {
        "description": "Get the IPv6 source address for a device.",
        "pre": {
            "score->ifa->flags": "& IFA_F_TENTATIVE != 0",
            "score->ifa->flags": "& IFA_F_OPTIMISTIC == 0",
            "score->addr_type": "!= IPV6_ADDR_ANY",
            "score->addr_type": "& IPV6_ADDR_MULTICAST == 0"
        }
    }
},
{
    "kprobe:ipv6_dev_get_saddr": {
        "description": "Get the IPv6 source address for a device.",
        "pre": {
            "net": "!=null",
            "dst": "!=null",
            "idev": "!=null",
            "scores": "!=null",
            "hiscore_idx": "!=null",
            "score": "!=null",
            "hiscore": "!=null",
            "score->ifa": "!=null",
            "idev->addr_list": "!=null",
            "score->ifa->flags": "& IFA_F_TENTATIVE != 0",
            "score->ifa->flags": "& IFA_F_OPTIMISTIC == 0",
            "score->addr_type": "__ipv6_addr_type(&score->ifa->addr) != IPV6_ADDR_ANY",
            "score->addr_type": "& IPV6_ADDR_MULTICAST == 0"
        }
    }
},
{
    "kretprobe:__ipv6_chk_addr_and_flags": {
        "description": "Check if an IPv6 address exists in the L3 domain that dev is part of or on the specific device.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "dev": "!=null",
            "skip_dev_check": "in [true, false]",
            "strict": "int",
            "banned_flags": "u32"
        }
    }
},
{
    "kprobe:__ipv6_chk_addr_and_flags": {
        "description": "Check if the IPv6 address exists in the L3 domain or on the specific device.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "dev": "!=null",
            "skip_dev_check": "is_boolean",
            "strict": "is_integer",
            "banned_flags": "is_unsigned_integer"
        }
    }
},
{
    "kretprobe:ipv6_dev_find": {
        "description": "Find the first device with a given source address.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ipv6_dev_find": {
        "description": "Find the first device with a given source address.",
        "pre": {
            "net": "!=null",
            "addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__ipv6_dev_mc_inc": {
        "description": "Increase the group membership on the device.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:__ipv6_dev_mc_inc": {
        "description": "Increase the group membership on the device.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "mode": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]"
        }
    }
},
{
    "kretprobe:ipv6_dev_mc_inc": {
        "description": "Increment the multicast group membership count for the given IPv6 address on the specified network device.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null",
            "mode": ">=0"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ip6t_unregister_table_exit": {
        "description": "Unregister an IPv6 table in the netfilter framework.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:ip6t_unregister_table_exit": {
        "description": "Unregister an IPv6 table.",
        "pre": {
            "net": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "verdict": "NF_DROP",
    "indev": "!=null",
    "outdev": "!=null",
    "table_base": "!=null",
    "e": "!=null",
    "jumpstack": "!=null",
    "stackidx": "!=null",
    "cpu": "!=null",
    "private": "!=null",
    "acpar": "!=null",
    "addend": "!=null"
},
{
    "kretprobe:tls_client_hello_anon": {
        "description": "Request an anonymous TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC]",
            "return": "in [0, -ESRCH, -ENOMEM]"
        }
    }
},
{
    "kprobe:tls_client_hello_anon": {
        "description": "Request an anonymous TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        },
        "return": {
            "0": "Handshake request enqueue; ->done will be called when complete",
            "-ESRCH": "No user agent is available",
            "-ENOMEM": "Memory allocation failed"
        }
    }
},
{
    "kretprobe:tls_client_hello_x509": {
        "description": "Request an x.509-based TLS handshake on a socket",
        "pre": {
            "args": "!=null",
            "flags": "!=null"
        },
        "post": {
            "%0": "!=null",
            "%-ESRCH": "!=null",
            "%-ENOMEM": "!=null"
        }
    }
},
{
    "kprobe:tls_client_hello_x509": {
        "description": "Request an x.509-based TLS handshake on a socket",
        "pre": {
            "args": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        },
        "return": {
            "0": "Handshake request enqueue; ->done will be called when complete",
            "-ESRCH": "No user agent is available",
            "-ENOMEM": "Memory allocation failed"
        }
    }
},
{
    "kretprobe:tls_client_hello_psk": {
        "description": "Request a PSK-based TLS handshake on a socket",
        "pre": {
            "args": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "return": "in [0, -EINVAL, -ESRCH, -ENOMEM]"
        }
    }
},
{
    "kprobe:tls_client_hello_psk": {
        "description": "Request a PSK-based TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "return": "in [0, -EINVAL, -ESRCH, -ENOMEM]"
        }
    }
},
{
    "kretprobe:tls_server_hello_x509": {
        "description": "Request a server TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC]"
        },
        "post": {
            "return": "in [0, -ESRCH, -ENOMEM]"
        }
    }
},
{
    "kprobe:tls_server_hello_x509": {
        "description": "Request a server TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        },
        "return": {
            "0": "Handshake request enqueue; ->done will be called when complete",
            "-ESRCH": "No user agent is available",
            "-ENOMEM": "Memory allocation failed"
        }
    }
},
{
    "kretprobe:tls_server_hello_psk": {
        "description": "Request a server TLS handshake on a socket",
        "pre": {
            "args": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]", 
            "return": "in [0, -ESRCH, -ENOMEM]"
        }
    }
},
{
    "kprobe:tls_server_hello_psk": {
        "description": "Request a server TLS handshake on a socket.",
        "pre": {
            "args": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        },
        "return": {
            "0": "Handshake request enqueue; ->done will be called when complete",
            "-ESRCH": "No user agent is available",
            "-ENOMEM": "Memory allocation failed"
        }
    }
},
{
    "kretprobe:tls_handshake_cancel": {
        "description": "Cancel a pending handshake",
        "pre": {
            "sk": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:tls_handshake_cancel": {
        "description": "Cancel a pending handshake",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:handshake_genl_put": {
        "description": "Create a generic netlink message header",
        "pre": {
            "msg": "!=null",
            "info": "!=null"
        }
    }
},
S,
{
    "kretprobe:handshake_req_alloc": {
        "description": "Allocate a handshake request",
        "pre": {
            "proto": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:handshake_req_alloc": {
        "description": "Allocate a handshake request",
        "pre": {
            "proto": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:handshake_req_private": {
        "description": "Get per-handshake private data",
        "pre": {
            "req": "!=null"
        }
    }
},
{
    "kprobe:handshake_req_private": {
        "description": "Get per-handshake private data",
        "pre": {
            "req": "!=null"
        }
    }
},
{
    "kretprobe:handshake_req_submit": {
        "description": "Submit a handshake request",
        "pre": {
            "sock": "!=null",
            "req": "!=null",
            "flags": "!=null"
        },
        "post": {
            "%0": "exists",
            "%-EINVAL": "exists",
            "%-EBUSY": "exists",
            "%-ESRCH": "exists",
            "%-EAGAIN": "exists",
            "%-ENOMEM": "exists",
            "%-EMSGSIZE": "exists",
            "%-EOPNOTSUPP": "exists"
        }
    }
},
{
    "kprobe:handshake_req_submit": {
        "description": "Submit a handshake request",
        "pre": {
            "sock": "!=null",
            "req": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:handshake_req_cancel": {
        "description": "Cancel an in-progress handshake",
        "pre": {
            "sk": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:handshake_req_cancel": {
        "description": "Cancel an in-progress handshake",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kretprobe:xfrm_policy_destroy": {
        "description": "Destroy xfrm_policy: descendant resources must be released to this moment.",
        "pre": {
            "policy": "!=null",
            "policy->security": "!=null"
        }
    }
},
{
    "kprobe:xfrm_policy_destroy": {
        "description": "Destroy xfrm_policy: descendant resources must be released to this moment.",
        "pre": {
            "policy": "!=null"
        }
    }
},
{
    "kretprobe:xfrm_if_get_cb": {
        "description": "Get the xfrm_if_cb structure associated with the current network namespace.",
        "pre": {
            "chain": "!=null",
            "policy": "!=null",
            "excl": "in [true, false]"
        }
    }
},
S,
{
    "kretprobe:xfrm_policy_walk_done": {
        "description": "Finish walking through xfrm policies.",
        "pre": {
            "walk": {
                "walk": {
                    "all": "!=null"
                }
            },
            "net": "!=null"
        }
    }
},
{
    "kprobe:xfrm_policy_walk_done": {
        "description": "Finish walking through xfrm policies.",
        "pre": {
            "walk": {
                "walk": {
                    "all": "!=null"
                }
            },
            "net": "!=null"
        }
    }
},
{
    "kretprobe:xfrm_policy_alloc": {
        "description": "Allocate xfrm_policy. Used by pfkeyv2 SPD calls.",
        "pre": {
            "net": "!=null",
            "gfp": "!=null"
        }
    }
},
S,
S,
S,
"skb_mark": "!=null",
{
    "kprobe:xfrm_lookup": {
        "description": "Look up an xfrm destination for a given packet.",
        "pre": {
            "net": "!=null",
            "xfrm_dst_path(dst)": "!=null",
            "&fl": "!=null",
            "sk": "!=null",
            "XFRM_LOOKUP_QUEUE": "!=null"
        }
    },
    "kprobe:IS_ERR": {
        "description": "Check if the given expression returns an error.",
        "pre": {
            "dst": "!=null"
        }
    },
    "kprobe:purge_queue": {
        "description": "Purge the queue.",
        "pre": {}
    },
    "kprobe:dst_release": {
        "description": "Release the given destination.",
        "pre": {
            "dst": "!=null"
        }
    },
    "kprobe:pq->timeout >= XFRM_QUEUE_TMO_MAX": {
        "description": "Check if pq->timeout is greater than or equal to XFRM_QUEUE_TMO_MAX.",
        "pre": {}
    },
    "kprobe:pq->timeout = pq->timeout << 1": {
        "description": "Shift the value of pq->timeout left by 1.",
        "pre": {}
    },
    "kprobe:!mod_timer(&pq->hold_timer, jiffies + pq->timeout)": {
        "description": "Check if the timer was not modified successfully.",
        "pre": {}
    },
    "kprobe:xfrm_pol_hold": {
        "description": "Hold the xfrm policy.",
        "pre": {
            "pol": "!=null"
        }
    },
    "kprobe:out": {
        "description": "Jump to the out label.",
        "pre": {}
    },
    "kprobe:__skb_queue_head_init": {
        "description": "Initialize the head of a socket buffer queue.",
        "pre": {
            "&list": "!=null"
        }
    },
    "kprobe:spin_lock": {
        "description": "Acquire a spin lock.",
        "pre": {
            "&pq->hold_queue.lock": "!=null"
        }
    },
    "kprobe:spin_unlock": {
        "description": "Release a spin lock.",
        "pre": {
            "&pq->hold_queue.lock": "!=null"
        }
    },
    "kprobe:!skb_queue_empty(&list)": {
        "description": "Check if the socket buffer queue is not empty.",
        "pre": {}
    },
    "kprobe:__skb_dequeue": {
        "description": "Dequeue a socket buffer from the queue.",
        "pre": {
            "&list": "!=null"
        }
    }
},
{
    "kretprobe:xfrm_lookup_route": {
        "description": "Ensure a call to dst_output() to avoid sending out blackholed packets.",
        "pre": {
            "net": "!=null",
            "dst_orig": "!=null",
            "fl": "!=null",
            "sk": "!=null",
            "flags": "int",
            "return_value": "!=null"
        },
        "post": {
            "dst_output_called": "==true"
        }
    }
},
{
    "kprobe:xfrm_lookup_route": {
        "description": "Lookup the route for an XFRM packet.",
        "pre": {
            "net": "!=null",
            "dst_orig": "!=null",
            "fl": "!=null",
            "sk": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        }
    }
},
{
    "kretprobe:skb_sec_path": {
        "description": "Retrieve the security path associated with the socket buffer.",
        "pre": {
            "skb": "!=null",
            "sp": "!=null"
        }
    }
},
{
    "kprobe:skb_sec_path": {
        "description": "Get the security path associated with the skb.",
        "pre": {
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:if (unlikely(seq < bottom)) seq_hi++; else": {
        "description": "Check if the condition 'seq < bottom' is unlikely. If true, increment seq_hi; otherwise, execute the code in the 'else' block.",
        "pre": {
            "seq": "< bottom",
            "seq_hi": "seq_hi + 1"
        }
    }
},
{
    "kprobe:if (unlikely(seq < bottom)) seq_hi++; else": {
        "description": "Condition for the given function",
        "pre": {
            "seq": "< bottom",
            "seq_hi": "seq_hi + 1"
        }
    }
},
{
    "kretprobe:return_sp": {
        "description": "Allocated new secpath",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:return_sp": {
        "description": "Allocated new secpath",
        "pre": {
            "skb": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:__xfrm_state_bump_genids": {
        "description": "This function is used to bump the generation IDs of an xfrm_state structure.",
        "pre": {
            "xnew": "!=null"
        }
    }
},
{
    "kprobe:__xfrm_state_bump_genids": {
        "description": "Bump the generation IDs of the xfrm_state structure.",
        "pre": {
            "xnew": "!=null",
            "xnew->km.state": "!=null",
            "xnew->km.state->km": "!=null",
            "xnew->km.state->km->props.family": "==AF_INET or ==AF_INET6",
            "xnew->km.state->km->id.spi": ">=0",
            "xnew->km.state->km->id.proto": ">=0",
            "xnew->km.state->km->props.reqid": ">=0",
            "xnew->km.state->km->props.family == AF_INET6 implies xnew->km.state->km->id.daddr": "!=null",
            "xnew->km.state->km->props.family == AF_INET6 implies xnew->km.state->km->props.saddr": "!=null",
            "xnew->km.state->km->props.family == AF_INET implies xnew->km.state->km->id.daddr": "!=null",
            "xnew->km.state->km->props.family == AF_INET implies xnew->km.state->km->props.saddr": "!=null",
            "xnew->km.state->km->props.family == AF_INET implies xnew->km.state->km->id.spi": "==0",
            "xnew->km.state->km->props.family == AF_INET implies xnew->km.state->km->id.proto": "==0",
            "xnew->km.state->km->props.family == AF_INET implies xnew->km.state->km->props.reqid": "==0"
        }
    }
},
{
    "kretprobe:xfrm_state_lookup_all": {
        "description": "Lookup all xfrm states matching the given parameters.",
        "pre": {
            "net": "!=null",
            "mark": "!=null",
            "daddr": "!=null",
            "spi": "!=null",
            "proto": "!=null",
            "family": "!=null",
            "xdo": {
                "type": "XFRM_DEV_OFFLOAD_PACKET"
            }
        }
    }
},
{
    "kprobe:break;/* Packet offload: both policy and SA should * have the same device. `": {
        "description": "Packet offload: both policy and SA should have the same device.",
        "pre": {
            "net": "!=null",
            "mark": "!=null",
            "daddr": "!=null",
            "spi": "!=null",
            "proto": "!=null",
            "family": "!=null",
            "xdo": "!=null",
            "h": "xfrm_spi_hash(net, daddr, spi, proto, family)",
            "x": "xfrm_state",
            "xdo_type": "XFRM_DEV_OFFLOAD_PACKET",
            "xso_type": "XFRM_DEV_OFFLOAD_PACKET",
            "byspi": "hlist_for_each_entry_rcu(x, net->xfrm.state_byspi + h, byspi)"
        },
        "post": {
            "HW states are in the head of the list, there is no need to iterate further."
        }
    }
},
S,
S,
{
    "kretprobe:xfrm_state_lookup_byaddr": {
        "description": "Lookup an xfrm state by address.",
        "pre": {
            "net": "!=null",
            "mark": "!=null",
            "daddr": "!=null",
            "saddr": "!=null",
            "proto": "!=null",
            "family": "!=null"
        },
        "post": {
            "x": "!=null",
            "x->props.family": "==family",
            "x->id.proto": "==proto",
            "!xfrm_addr_equal(&x->id.daddr, daddr, family)": "false",
            "!xfrm_addr_equal(&x->props.saddr, saddr, family)": "false",
            "(mark & x->mark.m) != x->mark.v": "false",
            "!xfrm_state_hold_rcu(x)": "false"
        }
    }
},
{
    "kprobe:xfrm_state_lookup_byaddr": {
        "description": "Lookup an xfrm state by address.",
        "pre": {
            "net": "!=null",
            "mark": "!=null",
            "daddr": "!=null",
            "saddr": "!=null",
            "proto": "!=null",
            "family": "!=null",
            "h": "!=null",
            "x": "!=null",
            "x->props.family": "==family",
            "x->id.proto": "==proto",
            "!xfrm_addr_equal(&x->id.daddr, daddr, family)": "false",
            "!xfrm_addr_equal(&x->props.saddr, saddr, family)": "false",
            "(mark & x->mark.m) != x->mark.v": "false",
            "!xfrm_state_hold_rcu(x)": "false"
        }
    },
    "kprobe:__xfrm_state_locate": {
        "description": "Locate an xfrm state.",
        "pre": {
            "x": "!=null",
            "use_spi": "!=null",
            "family": "!=null",
            "net": "!=null",
            "mark": "!=null",
            "&x->id.daddr": "!=null",
            "&x->props.saddr": "!=null",
            "x->id.proto": "!=null",
            "x->id.spi": "!=null",
            "__xfrm_state_lookup(net, mark, &x->id.daddr, x->id.spi, x->id.proto, family)": "!=null"
        }
    },
    "kprobe:xfrm_hash_grow_check": {
        "description": "Check if xfrm hash needs to grow.",
        "pre": {
            "net": "!=null",
            "have_hash_collision": "!=null",
            "(net->xfrm.state_hmask + 1) < xfrm_state_hashmax": "true",
            "net->xfrm.state_num > net->xfrm.state_hmask": "true"
        }
    },
    "kprobe:xfrm_state_look_at": {
        "description": "Look at an xfrm state.",
        "pre": {
            "pol": "!=null",
            "x": "!=null",
            "fl": "!=null",
            "family": "!=null",
            "best": "!=null",
            "acq_in_progress": "!=null",
            "error": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:return 0;#endif /* CONFIG_CGROUP_DEVICE ": {
        "description": "The kretprobe function for the bpftrace.",
        "pre": {
            "return_value": "== 0"
        }
    }
},
S,
{
    "kretprobe:security_free_mnt_opts": {
        "description": "Free memory associated with mount options",
        "pre": {
            "mnt_opts": "!=null"
        }
    }
},
{
    "kprobe:security_free_mnt_opts": {
        "description": "Free memory associated with mount options",
        "pre": {
            "mnt_opts": "!=null"
        }
    }
},
{
    "kretprobe:security_sb_eat_lsm_opts": {
        "description": "Consume LSM mount options",
        "pre": {
            "options": "!=null",
            "mnt_opts": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:security_sb_eat_lsm_opts": {
        "description": "Consume LSM mount options",
        "pre": {
            "options": "!=null",
            "mnt_opts": "!=null"
        }
    }
},
{
    "kretprobe:security_sb_mnt_opts_compat": {
        "description": "Check if new mount options are allowed",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:security_sb_mnt_opts_compat": {
        "description": "Check if new mount options are allowed",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null"
        }
    }
},
{
    "kretprobe:security_sb_remount": {
        "description": "Verify no incompatible mount changes during remount",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null"
        }
    }
},
{
    "kprobe:security_sb_remount": {
        "description": "Verify no incompatible mount changes during remount",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null"
        }
    }
},
{
    "kretprobe:security_sb_set_mnt_opts": {
        "description": "Set the mount options for a filesystem",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null",
            "kern_flags": ">=0",
            "set_kern_flags": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:security_sb_set_mnt_opts": {
        "description": "Set the mount options for a filesystem",
        "pre": {
            "sb": "!=null",
            "mnt_opts": "!=null",
            "kern_flags": ">=0",
            "set_kern_flags": "!=null"
        }
    }
},
{
    "kretprobe:security_sb_clone_mnt_opts": {
        "description": "Duplicate superblock mount options",
        "pre": {
            "oldsb": "!=null",
            "newsb": "!=null",
            "kern_flags": "!=null",
            "set_kern_flags": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:security_sb_clone_mnt_opts": {
        "description": "Duplicate superblock mount options",
        "pre": {
            "oldsb": "!=null",
            "newsb": "!=null",
            "kern_flags": "!=null",
            "set_kern_flags": "!=null"
        }
    }
},
{
    "kretprobe:security_dentry_init_security": {
        "description": "Perform dentry initialization",
        "pre": {
            "dentry": "!=null",
            "mode": "int",
            "name": "!=null",
            "xattr_name": "!=null",
            "ctx": "!=null",
            "ctxlen": "u32"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:security_dentry_init_security": {
        "description": "Perform dentry initialization",
        "pre": {
            "dentry": "!=null",
            "mode": "int",
            "name": "!=null",
            "xattr_name": "!=null",
            "ctx": "!=null",
            "ctxlen": "u32"
        }
    }
},
{
    "kretprobe:security_dentry_create_files_as": {
        "description": "Perform dentry initialization",
        "pre": {
            "dentry": "!=null",
            "mode": "int",
            "name": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:security_dentry_create_files_as": {
        "description": "Perform dentry initialization",
        "pre": {
            "dentry": "!=null",
            "mode": "int",
            "name": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:security_inode_init_security": {
        "description": "Initialize an inode's LSM context",
        "pre": {
            "inode": "!=null",
            "dir": "!=null",
            "qstr": "!=null",
            "initxattrs": "!=null",
            "fs_data": "!=null"
        },
        "post": {
            "return": "in [0, -EOPNOTSUPP, -ENOMEM]"
        }
    }
},
{
    "kprobe:security_inode_init_security": {
        "description": "Initialize an inode's LSM context",
        "pre": {
            "inode": "!=null",
            "dir": "!=null",
            "qstr": "!=null",
            "initxattrs": "!=null",
            "fs_data": "!=null"
        }
    }
},
{
    "kretprobe:security_path_mknod": {
        "description": "Check if creating a special file is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:security_path_mknod": {
        "description": "Check if creating a special file is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:security_path_mkdir": {
        "description": "Check if creating a new directory is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:security_path_mkdir": {
        "description": "Check if creating a new directory is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:security_path_unlink": {
        "description": "Check if removing a hard link is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:security_path_unlink": {
        "description": "Check if removing a hard link is allowed",
        "pre": {
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:security_path_rename": {
        "description": "Check if renaming a file is allowed",
        "pre": {
            "old_dir": "!=null",
            "old_dentry": "!=null",
            "new_dir": "!=null",
            "new_dentry": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:security_path_rename": {
        "description": "Check if renaming a file is allowed",
        "pre": {
            "old_dir": "!=null",
            "old_dentry": "!=null",
            "new_dir": "!=null",
            "new_dentry": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:security_inode_listsecurity": {
        "description": "List the xattr security label names",
        "pre": {
            "inode": "!=null",
            "buffer": "!=null",
            "buffer_size": ">=0"
        }
    }
},
{
    "kprobe:security_inode_listsecurity": {
        "description": "List the xattr security label names",
        "pre": {
            "inode": "!=null",
            "buffer": "!=null",
            "buffer_size": ">=0"
        }
    }
},
{
    "kretprobe:security_inode_copy_up": {
        "description": "Create new creds for an overlayfs copy-up op",
        "pre": {
            "src": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:security_inode_copy_up": {
        "description": "Create new creds for an overlayfs copy-up op",
        "pre": {
            "src": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:security_inode_copy_up_xattr": {
        "description": "Filter xattrs in an overlayfs copy-up op",
        "pre": {
            "name": "!=null"
        },
        "post": {
            "return": "in [0, 1, -EOPNOTSUPP, negative error code]"
        }
    }
},
{
    "kprobe:security_inode_copy_up_xattr": {
        "description": "Filter xattrs in an overlayfs copy-up op",
        "pre": {
            "name": "!=null"
        },
        "post": {
            "return": "in [0, 1, -EOPNOTSUPP, negative error code]"
        }
    }
},
{
    "kretprobe:security_cred_getsecid": {
        "description": "Get the secid from a set of credentials",
        "pre": {
            "c": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kprobe:security_cred_getsecid": {
        "description": "Get the secid from a set of credentials",
        "pre": {
            "c": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_current_getsecid_subj": {
        "description": "Get the current task's subjective secid",
        "pre": {
            "secid": "!=null"
        }
    }
},
{
    "kprobe:security_current_getsecid_subj": {
        "description": "Get the current task's subjective secid",
        "pre": {
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_task_getsecid_obj": {
        "description": "Get a task's objective secid",
        "pre": {
            "p": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kprobe:security_task_getsecid_obj": {
        "description": "Get a task's objective secid",
        "pre": {
            "p": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_d_instantiate": {
        "description": "Populate an inode's LSM state based on a dentry",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:security_d_instantiate": {
        "description": "Populate an inode's LSM state based on a dentry",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:security_ismaclabel": {
        "description": "Check if the extended attribute specified by @name represents a MAC label.",
        "pre": {
            "name": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:security_ismaclabel": {
        "description": "Check if the extended attribute specified by @name represents a MAC label.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:security_secid_to_secctx": {
        "description": "Convert a secid to a secctx",
        "pre": {
            "secid": "!=null",
            "secdata": "!=null",
            "seclen": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:security_secid_to_secctx": {
        "description": "Convert a secid to a secctx",
        "pre": {
            "secid": "!=null",
            "secdata": "!=null",
            "seclen": "!=null"
        }
    }
},
{
    "kretprobe:security_secctx_to_secid": {
        "description": "Convert a secctx to a secid",
        "pre": {
            "secdata": "!=null",
            "seclen": ">=0",
            "secid": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:security_secctx_to_secid": {
        "description": "Convert a secctx to a secid",
        "pre": {
            "secdata": "!=null",
            "seclen": ">=0",
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_release_secctx": {
        "description": "Free a secctx buffer",
        "pre": {
            "secdata": "!=null",
            "seclen": ">=0"
        }
    }
},
{
    "kprobe:security_release_secctx": {
        "description": "Free a secctx buffer",
        "pre": {
            "secdata": "!=null",
            "seclen": ">=0"
        }
    }
},
{
    "kretprobe:security_inode_invalidate_secctx": {
        "description": "Invalidate an inode's security label",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:security_inode_invalidate_secctx": {
        "description": "Invalidate an inode's security label",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:security_inode_notifysecctx": {
        "description": "Notify the LSM of an inode's security label",
        "pre": {
            "inode": "!=null",
            "ctx": "!=null",
            "ctxlen": ">=0"
        }
    }
},
{
    "kprobe:security_inode_notifysecctx": {
        "description": "Notify the LSM of an inode's security label",
        "pre": {
            "inode": "!=null",
            "ctx": "!=null",
            "ctxlen": ">=0"
        }
    }
},
{
    "kretprobe:security_inode_setsecctx": {
        "description": "Change the security label of an inode",
        "pre": {
            "dentry": "!=null",
            "ctx": "!=null",
            "ctxlen": ">=0"
        }
    }
},
{
    "kprobe:security_inode_setsecctx": {
        "description": "Change the security label of an inode",
        "pre": {
            "dentry": "!=null",
            "ctx": "!=null",
            "ctxlen": ">=0"
        }
    }
},
{
    "kretprobe:security_inode_getsecctx": {
        "description": "Get the security label of an inode",
        "pre": {
            "inode": "!=null",
            "ctx": "!=null",
            "ctxlen": "!=null"
        }
    }
},
{
    "kprobe:security_inode_getsecctx": {
        "description": "Get the security label of an inode",
        "pre": {
            "inode": "!=null",
            "ctx": "!=null",
            "ctxlen": "!=null"
        }
    }
},
{
    "kretprobe:security_unix_stream_connect": {
        "description": "Check if a AF_UNIX stream is allowed",
        "pre": {
            "sock": "!=null",
            "other": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kprobe:security_unix_stream_connect": {
        "description": "Check if a AF_UNIX stream is allowed",
        "pre": {
            "sock": "!=null",
            "other": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kretprobe:security_unix_may_send": {
        "description": "Check if AF_UNIX socket can send datagrams",
        "pre": {
            "sock": "!=null",
            "other": "!=null"
        }
    }
},
{
    "kprobe:security_unix_may_send": {
        "description": "Check if AF_UNIX socket can send datagrams",
        "pre": {
            "sock": "!=null",
            "other": "!=null"
        }
    }
},
{
    "kretprobe:security_socket_socketpair": {
        "description": "Check if creating a socketpair is allowed",
        "pre": {
            "socka": "!=null",
            "sockb": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:security_socket_socketpair": {
        "description": "Check if creating a socketpair is allowed",
        "pre": {
            "socka": "!=null",
            "sockb": "!=null"
        }
    }
},
{
    "kretprobe:security_sock_rcv_skb": {
        "description": "Check if an incoming network packet is allowed",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:security_sock_rcv_skb": {
        "description": "Check if an incoming network packet is allowed",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:security_socket_getpeersec_dgram": {
        "description": "Get the remote peer label",
        "pre": {
            "sock": "!=null",
            "skb": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kprobe:security_socket_getpeersec_dgram": {
        "description": "Get the remote peer label",
        "pre": {
            "sock": "!=null",
            "skb": "!=null",
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_sk_clone": {
        "description": "Clone a sock's LSM state",
        "pre": {
            "sk": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kprobe:security_sk_clone": {
        "description": "Clone a sock's LSM state",
        "pre": {
            "sk": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kretprobe:security_req_classify_flow": {
        "description": "Set a flow's secid based on request_sock",
        "pre": {
            "req": "!=null",
            "flic": "!=null"
        }
    }
},
{
    "kprobe:security_req_classify_flow": {
        "description": "Set a flow's secid based on request_sock",
        "pre": {
            "req": "!=null",
            "flic": "!=null"
        }
    }
},
{
    "kretprobe:security_sock_graft": {
        "description": "Reconcile LSM state when grafting a sock on a socket",
        "pre": {
            "sk": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:security_sock_graft": {
        "description": "Reconcile LSM state when grafting a sock on a socket",
        "pre": {
            "sk": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:security_inet_conn_request": {
        "description": "Set request_sock state using incoming connect",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kprobe:security_inet_conn_request": {
        "description": "Set request_sock state using incoming connect",
        "pre": {
            "sk": "!=null",
            "skb": "!=null",
            "req": "!=null"
        }
    }
},
{
    "kretprobe:security_inet_conn_established": {
        "description": "Update sock's LSM state with connection",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:security_inet_conn_established": {
        "description": "Update sock's LSM state with connection",
        "pre": {
            "sk": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:security_secmark_relabel_packet": {
        "description": "Check if setting a secmark is allowed",
        "pre": {
            "secid": "!=null"
        }
    }
},
{
    "kprobe:security_secmark_relabel_packet": {
        "description": "Check if setting a secmark is allowed",
        "pre": {
            "secid": "!=null"
        }
    }
},
{
    "kretprobe:security_secmark_refcount_inc": {
        "description": "Increment the secmark labeling rule count",
        "pre": {
            "void": "security_secmark_refcount_inc",
            "parameters": "none"
        }
    }
},
{
    "kprobe:security_secmark_refcount_inc": {
        "description": "Increment the secmark labeling rule count. Tells the LSM to increment the number of secmark labeling rules loaded.",
        "pre": {
            "arg1": "!=null"
        }
    }
},
{
    "kretprobe:security_secmark_refcount_dec": {
        "description": "Decrement the secmark labeling rule count",
        "pre": {
            "void": "security_secmark_refcount_dec",
            "return_value": "!=null"
        }
    }
},
S,
{
    "kretprobe:security_tun_dev_alloc_security": {
        "description": "Allocate a LSM blob for a TUN device",
        "pre": {
            "security": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:security_tun_dev_alloc_security": {
        "description": "Allocate a LSM blob for a TUN device",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kretprobe:security_tun_dev_free_security": {
        "description": "Free a TUN device LSM blob",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kprobe:security_tun_dev_free_security": {
        "description": "Free a TUN device LSM blob",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kretprobe:security_tun_dev_create": {
        "description": "Check if creating a TUN device is allowed",
        "pre": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:security_tun_dev_create": {
        "description": "Check if creating a TUN device is allowed",
        "pre": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:security_tun_dev_attach_queue": {
        "description": "Check if attaching a TUN queue is allowed",
        "pre": {
            "security": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:security_tun_dev_attach_queue": {
        "description": "Check if attaching a TUN queue is allowed",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kretprobe:security_tun_dev_open": {
        "description": "Update TUN device LSM state on open",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kprobe:security_tun_dev_open": {
        "description": "Update TUN device LSM state on open",
        "pre": {
            "security": "!=null"
        }
    }
},
{
    "kretprobe:security_sctp_assoc_request": {
        "description": "Update the LSM on a SCTP association request",
        "pre": {
            "asoc": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:security_sctp_assoc_request": {
        "description": "Update the LSM on a SCTP association request",
        "pre": {
            "asoc": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:security_sctp_bind_connect": {
        "description": "Validate a list of addrs for a SCTP option",
        "pre": {
            "sk": "!=null",
            "optname": "!=null",
            "address": "!=null",
            "addrlen": ">=0"
        }
    }
},
{
    "kprobe:security_sctp_bind_connect": {
        "description": "Validate a list of addrs for a SCTP option",
        "pre": {
            "sk": "!=null",
            "optname": "!=null",
            "address": "!=null",
            "addrlen": ">=0"
        }
    }
},
{
    "kretprobe:security_sctp_sk_clone": {
        "description": "Clone a SCTP sock's LSM state",
        "pre": {
            "asoc": "!=null",
            "sk": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kprobe:security_sctp_sk_clone": {
        "description": "Clone a SCTP sock's LSM state",
        "pre": {
            "asoc": "!=null",
            "sk": "!=null",
            "newsk": "!=null"
        }
    }
},
{
    "kretprobe:security_sctp_assoc_established": {
        "description": "Update LSM state when association is established",
        "pre": {
            "asoc": "!=null",
            "skb": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:security_sctp_assoc_established": {
        "description": "Update LSM state when association is established",
        "pre": {
            "asoc": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:security_ib_pkey_access": {
        "description": "Check if access to an IB pkey is allowed",
        "pre": {
            "sec": "!=null",
            "subnet_prefix": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kprobe:security_ib_pkey_access": {
        "description": "Check if access to an IB pkey is allowed",
        "pre": {
            "sec": "!=null",
            "subnet_prefix": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kretprobe:security_ib_endport_manage_subnet": {
        "description": "Check if SMPs traffic is allowed",
        "pre": {
            "sec": "!=null",
            "dev_name": "!=null",
            "port_num": "!=null"
        }
    }
},
{
    "kprobe:security_ib_endport_manage_subnet": {
        "description": "Check if SMPs traffic is allowed",
        "pre": {
            "sec": "!=null",
            "dev_name": "!=null",
            "port_num": "!=null"
        }
    }
},
{
    "kretprobe:security_ib_alloc_security": {
        "description": "Allocate an Infiniband LSM blob",
        "pre": {
            "sec": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:security_ib_alloc_security": {
        "description": "Allocate a security structure for Infiniband objects.",
        "pre": {
            "sec": "!=null"
        }
    }
},
{
    "kretprobe:security_ib_free_security": {
        "description": "Free an Infiniband LSM blob",
        "pre": {
            "sec": "!=null"
        }
    }
},
{
    "kprobe:security_ib_free_security": {
        "description": "Free an Infiniband LSM blob",
        "pre": {
            "sec": "!=null"
        }
    }
},
{
    "kretprobe:security_xfrm_policy_alloc": {
        "description": "Allocate a xfrm policy LSM blob",
        "pre": {
            "ctxp": "!=null",
            "sec_ctx": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:security_xfrm_policy_alloc": {
        "description": "Allocate a xfrm policy LSM blob",
        "pre": {
            "ctxp": "!=null",
            "sec_ctx": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:security_xfrm_policy_free": {
        "description": "Free a xfrm security context",
        "pre": {
            "ctx": "!=null"
        }
    }
},
{
    "kprobe:security_xfrm_policy_free": {
        "description": "Free a xfrm security context",
        "pre": {
            "ctx": "!=null"
        }
    }
},
{
    "kretprobe:security_xfrm_state_alloc": {
        "description": "Allocate a xfrm state LSM blob",
        "pre": {
            "x": "!=null",
            "sec_ctx": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:security_xfrm_state_alloc": {
        "description": "Allocate a xfrm state LSM blob",
        "pre": {
            "x": "!=null",
            "sec_ctx": "!=null"
        }
    }
},
{
    "kretprobe:security_xfrm_state_delete": {
        "description": "Check if deleting a xfrm state is allowed",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:security_xfrm_state_delete": {
        "description": "Check if deleting a xfrm state is allowed",
        "pre": {
            "x": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:lookup_user_key": {
        "description": "Look up a key ID given by userspace with a given permissions mask to get the key it refers to.",
        "pre": {
            "key": "!=null",
            "match_data": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is_pointer",
            "return": "has_incremented_usage_count",
            "return": "in [-EINVAL, -ENOKEY, -EKEYREVOKED, -EKEYEXPIRED, -EACCES, -ENOMEM]"
        }
    }
},
{
    "kprobe:lookup_user_key": {
        "description": "Look up a key ID given by userspace with a given permissions mask to get the key it refers to.",
        "pre": {
            "key": "!=null",
            "match_data": "!=null",
            "lflags": "any",
            "return": "in [-EINVAL, -ENOKEY, -EKEYREVOKED, -EKEYEXPIRED, -EACCES, -ENOMEM]"
        }
    }
},
{
    "kretprobe:key_task_permission": {
        "description": "Check if a key can be used with the specified permissions.",
        "pre": {
            "key_ref": "!=null",
            "cred": "!=null",
            "need_perm": "in [KEY_NEED_READ, KEY_NEED_WRITE, KEY_NEED_LINK, KEY_NEED_SEARCH]"
        },
        "post": {
            "return_value": "in [0, -EACCES]"
        }
    }
},
{
    "kprobe:key_task_permission": {
        "description": "Check if a key can be used",
        "pre": {
            "key_ref": "!=null",
            "cred": "!=null",
            "need_perm": "!=null"
        }
    }
},
{
    "kretprobe:key_validate": {
        "description": "Validate a key.",
        "pre": {
            "key": "!=null"
        },
        "post": {
            "return_value": "in [0, -ENOKEY, -EKEYREVOKED, -EKEYEXPIRED]"
        }
    }
},
{
    "kprobe:key_validate": {
        "description": "Validate a key.",
        "pre": {
            "key": "!=null"
        },
        "post": {
            "return": "in [0, -ENOKEY, -EKEYREVOKED, -EKEYEXPIRED]"
        }
    }
},
S,
S,
{
    "kretprobe:keyring_search_iterator": {
        "description": "Condition for keyring_search_iterator function",
        "pre": {
            "key->type": "!= ctx->index_key.type"
        }
    }
},
{
    "kprobe:keyring_search_iterator": {
        "description": "Ignore keys not of this type",
        "pre": {
            "key->type": "!= ctx->index_key.type"
        }
    }
},
S,
{
    "kprobe:static DECLARE_RWSEM(keyring_serialise_restrict_sem)": {
        "description": "Check for restriction cycles that would prevent keyring garbage collection. keyring_serialise_restrict_sem must be held.",
        "pre": {
            "key_restrict_link_func_t": "!=null"
        }
    }
},
{
    "kretprobe:key_link_lock": {
        "description": "Lock keyrings for move (link/unlink combination).",
        "pre": {
            "keyring": "!=null",
            "index_key": "!=null",
            "keyring->type": "== &key_type_keyring"
        }
    }
},
S,
{
    "kretprobe:__key_unlink_begin": {
        "description": "Begin the process of unlinking a key from a keyring.",
        "pre": {
            "keyring": "!=null",
            "key": "!=null",
            "_edit": "!=null",
            "keyring->type": "==&key_type_keyring",
            "keyring->sem": "__acquires(&keyring->sem)",
            "return": "-ENOTDIR if keyring->type != &key_type_keyring",
            "down_write(&keyring->sem)": "called",
            "return": "0"
        }
    }
},
{
    "kprobe:__key_unlink_begin": {
        "description": "Begin the process of unlinking a key from a keyring.",
        "pre": {
            "keyring": {
                "type": "&key_type_keyring"
            }
        }
    }
},
{
    "kretprobe:key_move_lock": {
        "description": "Move a key from one keyring to another.",
        "pre": {
            "l_keyring": "!=null",
            "u_keyring": "!=null",
            "index_key": "!=null",
            "l_keyring->type": "== &key_type_keyring",
            "u_keyring->type": "== &key_type_keyring"
        }
    }
},
{
    "kprobe:key_move_lock": {
        "description": "Move a key from one keyring to another.",
        "pre": {
            "l_keyring": "!=null",
            "u_keyring": "!=null",
            "index_key": "!=null",
            "l_keyring->type": "== &key_type_keyring",
            "u_keyring->type": "== &key_type_keyring"
        }
    }
},
{
    "kretprobe:keyring_clear": {
        "description": "Clear a keyring",
        "pre": {
            "keyring": "!=null"
        },
        "post": {
            "return": "in [0, -ENOTDIR]"
        }
    }
},
{
    "kprobe:keyring_clear": {
        "description": "Clear a keyring",
        "pre": {
            "keyring": "!=null"
        }
    }
},
{
    "kretprobe:key_payload_reserve": {
        "description": "Adjust data quota reservation for the key's payload",
        "pre": {
            "key": "!=null",
            "datalen": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:key_payload_reserve": {
        "description": "Adjust data quota reservation for the key's payload",
        "pre": {
            "key": "!=null",
            "datalen": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:key_reject_and_link": {
        "description": "Negatively instantiate a key and link it into the keyring.",
        "pre": {
            "key": "!=null",
            "timeout": ">=0",
            "error": "!=null",
            "keyring": "in [null, !=null]",
            "authkey": "!=null"
        }
    }
},
{
    "kprobe:key_reject_and_link": {
        "description": "Negatively instantiate a key and link it into the keyring.",
        "pre": {
            "key": "!=null",
            "timeout": ">=0",
            "error": ">=0",
            "keyring": "in [null, !=null]",
            "authkey": "!=null"
        }
    }
},
{
    "kretprobe:key_put": {
        "description": "Discard a reference to a key.",
        "pre": {
            "key": "!=null"
        }
    }
},
{
    "kprobe:key_put": {
        "description": "Discard a reference to a key.",
        "pre": {
            "key": "!=null"
        }
    }
},
{
    "kretprobe:__key_create_or_update": {
        "description": "Create or update a key",
        "pre": {
            "keyring_ref": "!=null",
            "type": "!=null",
            "description": "!=null",
            "payload": "!=null",
            "plen": ">0",
            "perm": ">=0",
            "flags": ">=0",
            "allow_update": "is_boolean"
        }
    }
},
S,
{
    "kretprobe:key_permission": {
        "description": "Check if the key has write permission.",
        "pre": {
            "key_ref": "!=null",
            "KEY_NEED_WRITE": "true"
        }
    },
    "kretprobe:error": {
        "description": "Handle error case.",
        "pre": {
            "ret": "< 0"
        }
    },
    "kretprobe:-EEXIST": {
        "description": "Set ret to -EEXIST.",
        "pre": {}
    },
    "kretprobe:key->type->update": {
        "description": "Check if key->type->update is not null.",
        "pre": {
            "key->type->update": "!=null"
        }
    },
    "kretprobe:error2": {
        "description": "Handle error case.",
        "pre": {
            "!key->type->update": "true"
        }
    },
    "kretprobe:down_write": {
        "description": "Acquire write lock on key->sem.",
        "pre": {
            "&key->sem": "!=null"
        }
    },
    "kretprobe:key->type->update2": {
        "description": "Call key->type->update with key and prep as arguments.",
        "pre": {
            "key": "!=null",
            "prep": "!=null"
        }
    },
    "kretprobe:ret == 0": {
        "description": "Check if ret is equal to 0.",
        "pre": {
            "ret": "== 0"
        }
    }
},
{
    "kprobe:key_permission": {
        "description": "Check if the key has write permission.",
        "pre": {
            "key_ref": "!=null",
            "prep": "!=null"
        }
    },
    "kprobe:key->type->update": {
        "description": "Check if the key's type has an update function.",
        "pre": {
            "key": "!=null",
            "prep": "!=null"
        }
    },
    "kprobe:down_write": {
        "description": "Acquire a write lock on the key's semaphore.",
        "pre": {
            "sem": "!=null"
        }
    }
},
{
    "kretprobe:key_revoke": {
        "description": "Revoke a key.",
        "pre": {
            "key": "!=null"
        }
    }
},
{
    "kprobe:key_revoke": {
        "description": "Revoke a key.",
        "pre": {
            "key": "!=null"
        }
    }
},
{
    "kretprobe:key_instantiate_and_link": {
        "description": "Instantiate a key and link it into the keyring.",
        "pre": {
            "awaken": "==true",
            "key->flags": "!=null",
            "KEY_FLAG_USER_CONSTRUCT": "is set in key->flags",
            "ret": "!=null",
            "authkey": "!=null",
            "prep->expiry": "!=TIME64_MAX",
            "key->expiry": "prep->expiry",
            "key_gc_delay": "is added to prep->expiry",
            "key_construction_mutex": "is unlocked"
        },
        "post": {
            "ret": "==0",
            "authkey": "is revoked",
            "key": "is instantiated",
            "keyring": "is linked with the instantiated key"
        }
    }
},
{
    "kprobe:key_instantiate_and_link": {
        "description": "Instantiate a key and link it into the keyring.",
        "pre": {
            "awaken": "true",
            "key->flags": "!=null",
            "KEY_FLAG_USER_CONSTRUCT": "set",
            "ret": "!=null",
            "authkey": "!=null",
            "prep->expiry": "!=TIME64_MAX",
            "key_gc_delay": "!=null",
            "key_construction_mutex": "unlocked"
        }
    }
},
{
    "kretprobe:generic_key_instantiate": {
        "description": "Simple instantiation of a key from preparsed data",
        "pre": {
            "key": "!=null",
            "prep": "!=null"
        }
    }
},
{
    "kprobe:generic_key_instantiate": {
        "description": "Simple instantiation of a key from preparsed data",
        "pre": {
            "key": "!=null",
            "prep": "any"
        }
    }
},
{
    "kretprobe:register_key_type": {
        "description": "Register a type of key.",
        "pre": {
            "ktype": "!=null"
        },
        "post": {
            "return_value": "=0"
        }
    }
},
{
    "kprobe:register_key_type": {
        "description": "Register a type of key.",
        "pre": {
            "ktype": "!=null"
        }
    }
},
{
    "kretprobe:unregister_key_type": {
        "description": "Unregister a type of key.",
        "pre": {
            "ktype": "!=null"
        }
    }
},
{
    "kprobe:unregister_key_type": {
        "description": "Unregister a type of key.",
        "pre": {
            "ktype": "!=null"
        }
    }
},
{
    "kretprobe:complete_request_key": {
        "description": "Complete the construction of a key.",
        "pre": {
            "authkey": "!=null",
            "error": "in [0, 1]"
        }
    }
},
{
    "kprobe:complete_request_key": {
        "description": "Complete the construction of a key.",
        "pre": {
            "authkey": "!=null",
            "error": "is int"
        }
    }
},
{
    "kretprobe:request_key_and_link": {
        "description": "Request a key and link it to a keyring.",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null",
            "callout_len": ">=0",
            "aux": "!=null",
            "dest_keyring": "!=null",
            "flags": "unsigned long",
            "wait_for_key_construction()": "should be used to wait for that to complete"
        }
    }
},
{
    "kprobe:request_key_and_link": {
        "description": "Request a key of type *type* with a description *description* and link it to the destination keyring *dest_keyring*.",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null",
            "callout_len": ">=0",
            "aux": "!=null",
            "dest_keyring": "!=null",
            "flags": "unsigned long",
            "wait_for_key_construction": "should be used"
        }
    }
},
{
    "kretprobe:request_key_tag": {
        "description": "Request a key and wait for construction",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null and is a NUL-terminated string"
        }
    }
},
{
    "kprobe:request_key_tag": {
        "description": "Request a key and wait for construction",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null and is a NUL-terminated string"
        }
    }
},
{
    "kretprobe:request_key_with_auxdata": {
        "description": "Request a key with auxiliary data for the upcaller",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null",
            "callout_len": ">=0",
            "aux": "!=null"
        }
    }
},
{
    "kprobe:request_key_with_auxdata": {
        "description": "Request a key with auxiliary data for the upcaller",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null",
            "callout_info": "!=null",
            "callout_len": ">=0",
            "aux": "!=null"
        }
    }
},
{
    "kretprobe:request_key_rcu": {
        "description": "Request key from RCU-read-locked context",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "in [-ENOKEY, other_error_codes]"
        }
    }
},
{
    "kprobe:request_key_rcu": {
        "description": "Request key from RCU-read-locked context",
        "pre": {
            "type": "!=null",
            "description": "!=null",
            "domain_tag": "!=null"
        }
    }
},
S,
{
    "kprobe:ecryptfs_get_versions": {
        "description": "Get the versions of ecryptfs",
        "pre": {
            "major": "!=null",
            "minor": "!=null",
            "file_version": "!=null"
        }
    }
},
{
    "kretprobe:ecryptfs_fill_auth_tok": {
        "description": "Fill the ecryptfs_auth_tok structure with required ecryptfs data.",
        "pre": {
            "auth_tok": "!=null",
            "key_desc": "!=null"
        }
    }
},
{
    "kprobe:ecryptfs_fill_auth_tok": {
        "description": "Fill the ecryptfs_auth_tok structure with required ecryptfs data.",
        "pre": {
            "auth_tok": "!=null",
            "key_desc": "!=null"
        }
    }
},
{
    "kretprobe:bpf_testmod_loop_test": {
        "description": "This is always true. Use the check to make sure the compiler doesn't remove bpf_testmod_loop_test.",
        "pre": {
            "file": "!=null",
            "kobj": "!=null",
            "bin_attr": "!=null",
            "buf": "!=null",
            "off": ">=0",
            "len": ">=0",
            "struct_arg1": "!=null",
            "struct_arg2": "!=null",
            "struct_arg3": "!=null",
            "i": ">=1",
            "struct_arg3->b[0]": "==1"
        }
    }
},
{
    "kprobe:bpf_testmod_loop_test": {
        "description": "Condition for bpf_testmod_loop_test",
        "pre": {
            "arg1": "> 100"
        },
        "helpers": [
            {
                "name": "trace_bpf_testmod_test_read",
                "args": ["current", "&ctx"]
            }
        ]
    }
},
{
    "kretprobe:bpf_testmod_test_write": {
        "description": "Always fail",
        "pre": {
            "file": "!=null",
            "kobj": "!=null",
            "bin_attr": "!=null",
            "buf": "!=null",
            "off": "is_valid_loff_t",
            "len": "is_valid_size_t"
        },
        "post": {
            "return_value": "-EIO"
        }
    }
},
{
    "kprobe:bpf_testmod_test_write": {
        "description": "Always fail",
        "pre": {
            "file": "!=null",
            "kobj": "!=null",
            "bin_attr": "!=null",
            "buf": "!=null",
            "off": ">=0",
            "len": ">0"
        }
    }
},
S,
S,
{
    "kretprobe:register_sound_special_device": {
        "description": "Register a special sound node",
        "pre": {
            "fops": "!=null",
            "unit": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:register_sound_special_device": {
        "description": "Register a special sound node",
        "pre": {
            "fops": "!=null",
            "unit": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:register_sound_mixer": {
        "description": "Register a mixer device",
        "pre": {
            "fops": "!=null",
            "dev": "int"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:register_sound_mixer": {
        "description": "Register a mixer device",
        "pre": {
            "fops": "!=null",
            "dev": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:register_sound_dsp": {
        "description": "Register a DSP device",
        "pre": {
            "fops": "!=null",
            "dev": "int"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:register_sound_dsp": {
        "description": "Register a DSP device",
        "pre": {
            "fops": "!=null",
            "dev": "int"
        }
    }
},
{
    "kretprobe:unregister_sound_special": {
        "description": "Unregister a special sound device.",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kprobe:unregister_sound_special": {
        "description": "Unregister a special sound device.",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:unregister_sound_mixer": {
        "description": "Release a sound device that was allocated with register_sound_mixer().",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kprobe:unregister_sound_mixer": {
        "description": "Unregister a mixer",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:unregister_sound_dsp": {
        "description": "Unregister a DSP device",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kprobe:unregister_sound_dsp": {
        "description": "Unregister a DSP device.",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:pxa2xx_pcm_open": {
        "description": "pxa2xx_pcm_open function",
        "pre": {
            "substream": "!=null",
            "rtd": "!=null",
            "runtime": "!=null",
            "dma_params": "!=null",
            "ret": "int",
            "runtime->hw": "pxa2xx_pcm_hardware",
            "dma_params": "snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream)",
            "dma_params": "!=null"
        }
    }
},
{
    "kprobe:pxa2xx_pcm_open": {
        "description": "Open the PCM substream using the pxa2xx platform driver.",
        "pre": {
            "substream": "!=null",
            "rtd": "!=null",
            "runtime": "!=null",
            "dma_params": "!=null",
            "ret": "int",
            "runtime.hw": "pxa2xx_pcm_hardware",
            "dma_params": "snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream)",
            "dma_params": "!=null",
            "dma_params.chan_name": "!=null",
            "ret": "int",
            "ret": ">=0",
            "ret": "snd_dmaengine_pcm_open(substream, dma_request_slave_channel(asoc_rtd_to_cpu(rtd, 0)->dev, dma_params->chan_name))"
        }
    }
},
{
    "kretprobe:snd_fw_transaction": {
        "description": "Send a request and wait for its completion.",
        "pre": {
            "unit": "!=null",
            "tcode": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "length": "!=null",
            "flags": "in [FW_FIXED_GENERATION, FW_QUIET]"
        }
    }
},
{
    "kprobe:snd_fw_transaction": {
        "description": "Send a request and wait for its completion.",
        "pre": {
            "unit": "!=null",
            "tcode": "!=null",
            "offset": "!=null",
            "buffer": "!=null",
            "length": "!=null",
            "flags": "in [FW_FIXED_GENERATION, FW_QUIET]"
        }
    }
},
{
    "kretprobe:fw_iso_resources_init": {
        "description": "Initializes a &struct fw_iso_resources",
        "pre": {
            "r": "!=null",
            "unit": "!=null",
            "r->channels_mask": "change after calling this function"
        }
    }
},
{
    "kprobe:fw_iso_resources_init": {
        "description": "Initializes a &struct fw_iso_resources",
        "pre": {
            "r": "!=null",
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:fw_iso_resources_destroy": {
        "description": "Destroy a resource manager",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kprobe:fw_iso_resources_destroy": {
        "description": "Destroy a resource manager.",
        "pre": {
            "r": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:iso_packets_buffer_init": {
        "description": "Allocates the memory for packets",
        "pre": {
            "b": "!=null",
            "unit": "!=null",
            "count": "!=null",
            "packet_size": "!=null",
            "direction": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:iso_packets_buffer_init": {
        "description": "Allocates the memory for packets.",
        "pre": {
            "b": "!=null",
            "unit": "!=null",
            "count": ">=0",
            "packet_size": ">=0",
            "direction": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:iso_packets_buffer_destroy": {
        "description": "Frees packet buffer resources",
        "pre": {
            "b": "!=null",
            "unit": "!=null"
        }
    }
},
{
    "kprobe:iso_packets_buffer_destroy": {
        "description": "Frees packet buffer resources.",
        "pre": {
            "b": "!=null",
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:amdtp_stream_init": {
        "description": "Initialize an AMDTP stream structure.",
        "pre": {
            "s": "!=null",
            "unit": "!=null",
            "dir": "in [AMDTP_IN_STREAM, AMDTP_OUT_STREAM]",
            "flags": "in [CIP_FLAG_1, CIP_FLAG_2, CIP_FLAG_3]",
            "fmt": ">=0",
            "process_ctx_payloads": "!=null",
            "protocol_size": ">=0"
        }
    }
},
{
    "kprobe:amdtp_stream_init": {
        "description": "Initialize an AMDTP stream structure.",
        "pre": {
            "s": "!=null",
            "unit": "!=null",
            "dir": "in [AMDTP_STREAM_OUTPUT, AMDTP_STREAM_INPUT]",
            "flags": "!=null",
            "fmt": "!=null",
            "process_ctx_payloads": "!=null",
            "protocol_size": "!=null"
        }
    }
},
{
    "kretprobe:amdtp_stream_destroy": {
        "description": "Free stream resources",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:amdtp_stream_destroy": {
        "description": "Free stream resources",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:amdtp_stream_add_pcm_hw_constraints": {
        "description": "Add hardware constraints for PCM substream.",
        "pre": {
            "s": "!=null",
            "runtime": "!=null"
        }
    }
},
{
    "kprobe:amdtp_stream_add_pcm_hw_constraints": {
        "description": "add hw constraints for PCM substream",
        "pre": {
            "s": "!=null",
            "runtime": "!=null"
        }
    }
},
{
    "kretprobe:amdtp_stream_set_parameters": {
        "description": "Set stream parameters",
        "pre": {
            "s": "!=null",
            "rate": "!=null",
            "data_block_quadlets": "!=null",
            "pcm_frame_multiplier": "!=null"
        }
    }
},
{
    "kprobe:amdtp_stream_set_parameters": {
        "description": "Set stream parameters",
        "pre": {
            "s": "!=null",
            "rate": "!=null",
            "data_block_quadlets": "!=null",
            "pcm_frame_multiplier": "!=null"
        }
    }
},
{
    "kretprobe:amdtp_stream_get_max_payload": {
        "description": "Get the stream's packet size",
        "pre": {
            "s": "!=null",
            "s->configured": "==true"
        }
    }
},
{
    "kprobe:amdtp_stream_get_max_payload": {
        "description": "Get the stream's packet size",
        "pre": {
            "s": "!=null",
            "s->configured": "==true"
        }
    }
},
{
    "kretprobe:amdtp_stream_pcm_prepare": {
        "description": "prepare PCM device for running",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:amdtp_stream_pcm_prepare": {
        "description": "Prepare PCM device for running",
        "pre": {
            "s": "!=null"
        }
    }
},
S,
{
    "kprobe:fw_iso_context_start": {
        "description": "Starts the fw_iso_context with given parameters.",
        "pre": {
            "s": "!=null",
            "tag": "in [FW_ISO_CONTEXT_MATCH_TAG1, FW_ISO_CONTEXT_MATCH_TAG1 | FW_ISO_CONTEXT_MATCH_TAG0]",
            "s->flags": "& CIP_EMPTY_WITH_TAG0 == 0 || & CIP_NO_HEADER == 0",
            "s->ready_processing": "== false",
            "err": ">= 0"
        }
    },
    "kprobe:fw_iso_context_start.err_pkt_descs": {
        "description": "Error handling for fw_iso_context_start.",
        "pre": {
            "s->packet_descs": "== null"
        }
    },
    "kprobe:fw_iso_context_start.err_context": {
        "description": "Error handling for fw_iso_context_start.",
        "pre": {
            "s->direction": "== AMDTP_OUT_STREAM"
        }
    },
    "kprobe:amdtp_stream_update": {
        "description": "Updates the amdtp_stream.",
        "pre": {}
    },
    "kprobe:amdtp_stream_update.err_context": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "s->direction": "== AMDTP_IN_STREAM"
        }
    },
    "kprobe:amdtp_stream_update.err_context.s->ctx_data.tx.cache.descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "s->ctx_data.tx.cache.descs": "== null"
        }
    },
    "kprobe:amdtp_stream_update.err_context.s->ctx_data.rx.seq.descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "s->ctx_data.rx.seq.descs": "== null"
        }
    },
    "kprobe:amdtp_stream_update.err_context.s->packet_descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "s->packet_descs": "== null"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {}
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs": "== null"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs": "!= null"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs": "!= null"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    },
    "kprobe:amdtp_stream_update.err_pkt_descs.descs.list_add_tail.descs.packet_index": {
        "description": "Error handling for amdtp_stream_update.",
        "pre": {
            "descs->packet_index": "< s->queue_size"
        }
    }
},
{
    "kretprobe:amdtp_stream_start": {
        "description": "Start transferring packets",
        "pre": {
            "s": "!=null",
            "channel": "int",
            "speed": "int",
            "queue_size": "unsigned int",
            "idle_irq_interval": "unsigned int"
        }
    }
},
{
    "kprobe:amdtp_stream_start": {
        "description": "Start transferring packets.",
        "pre": {
            "s": "!=null",
            "channel": "int",
            "speed": "int",
            "queue_size": "unsigned int",
            "idle_irq_interval": "unsigned int"
        }
    }
},
{
    "kretprobe:buf[1] = 0xff;/* UNIT `": {
        "description": "Set the value of buf[1] to 0xff.",
        "pre": {
            "unit": "!=null",
            "rate": "unsigned int",
            "dir": "enum avc_general_plug_dir",
            "pid": "unsigned short",
            "sfc": "unsigned int",
            "buf": "!=null",
            "flag": "bool",
            "err": "int"
        }
    }
},
{
    "kprobe:avc_general_set_sig_fmt": {
        "description": "Sets the signal format for the given unit.",
        "pre": {
            "unit": "!=null",
            "rate": "unsigned int",
            "dir": "enum avc_general_plug_dir",
            "pid": "unsigned short"
        }
    }
},
S,
S,
{
    "kretprobe:avc_general_get_plug_info": {
        "description": "Get plug information for the specified subunit.",
        "pre": {
            "unit": "!=null",
            "subunit_type": "==0x1E || ==5",
            "subunit_id": "==5",
            "subfunction": "!=null",
            "info": "!=null",
            "buf": "!=null",
            "err": "==0"
        },
        "post": {
            "return": "-EINVAL if (subunit_type == 0x1E) || (subunit_id == 5), -ENOMEM if buf == NULL, 0 otherwise"
        }
    }
},
{
    "kprobe:avc_general_get_plug_info": {
        "description": "Get plug information for AVC general.",
        "pre": {
            "unit": "!=null",
            "subunit_type": "==0x1E",
            "subunit_id": "==5",
            "subfunction": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:err": {
        "description": "Check the return value and buffer content for the function err = -ENOSYS;else if (buf[0] == 0x0a) /* REJECTED */",
        "pre": {
            "unit": "!=null",
            "buf": "!=null",
            "err": "< 0",
            "err": "< 8",
            "buf[0]": "== 0x08"
        }
    }
},
{
    "kprobe:err=-ENOSYS": {
        "description": "Check if the error code is set to -ENOSYS and if the first byte of the buffer is 0x0a.",
        "pre": {
            "err": "-ENOSYS",
            "buf[0]": "0x0a"
        }
    }
},
{
    "kretprobe:fcp_bus_reset": {
        "description": "Inform the target handler about a bus reset",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kprobe:fcp_bus_reset": {
        "description": "Inform the target handler about a bus reset.",
        "pre": {
            "unit": "!=null"
        }
    }
},
{
    "kretprobe:cmp_connection_init": {
        "description": "Initializes a connection manager.",
        "pre": {
            "c": "!=null",
            "unit": "!=null",
            "direction": "in ['input', 'output']",
            "pcr_index": ">=0"
        }
    }
},
{
    "kprobe:cmp_connection_init": {
        "description": "Initializes a connection manager.",
        "pre": {
            "c": "!=null",
            "unit": "!=null",
            "direction": "in ['input', 'output']",
            "pcr_index": ">=0"
        }
    }
},
{
    "kretprobe:cmp_connection_check_used": {
        "description": "Check if the connection is already established.",
        "pre": {
            "c": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:cmp_connection_check_used": {
        "description": "Check if the connection is already established.",
        "pre": {
            "c": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:cmp_connection_destroy": {
        "description": "Free connection manager resources",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kprobe:cmp_connection_destroy": {
        "description": "Free connection manager resources",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kretprobe:cmp_connection_establish": {
        "description": "Establish a connection to the target.",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kprobe:cmp_connection_establish": {
        "description": "Establish a connection to the target",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kretprobe:cmp_connection_update": {
        "description": "Update the connection after a bus reset",
        "pre": {
            "c": "!=null"
        },
        "post": {
            "return_value": "in [0, -MAX_ERR_CODE]"
        }
    }
},
{
    "kprobe:cmp_connection_update": {
        "description": "Update the connection after a bus reset",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kretprobe:cmp_connection_break": {
        "description": "Break the connection to the target",
        "pre": {
            "c": "!=null"
        }
    }
},
{
    "kprobe:cmp_connection_break": {
        "description": "Break the connection to the target",
        "pre": {
            "c": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:DAPQ_tail": {
        "description": "Read the value of DAPQ_tail and check if it is equal to the value of DAPQ_head or if start is true.",
        "pre": {
            "chip": "!=null",
            "start": "!=null",
            "DAPQ_tail": "!=null",
            "DAPQ_head": "!=null",
            "JQS_wTail": "!=null",
            "JQS_wHead": "!=null"
        }
    }
},
{
    "kprobe:DAPQ_tail_function": {
        "description": "Read the value of DAPQ_tail and check if it is not equal to the value of DAPQ_head or if start is true.",
        "pre": {
            "chip": "!=null",
            "start": "!=null",
            "DAPQ_tail": "!=null",
            "DAPQ_head": "!=null",
            "DAPQ_tail != DAPQ_head || start": "true"
        }
    }
},
{
    "kretprobe:msleep": {
        "description": "Sleep for 1 millisecond.",
        "pre": {}
    },
    "kretprobe:snd_printdd": {
        "description": "Print debug message with jiffies value.",
        "pre": {}
    },
    "kretprobe:comment": {
        "description": "Check condition up to 250 ms.",
        "pre": {}
    }
},
{
    "kprobe:msleep": {
        "description": "Sleep for a specified number of milliseconds.",
        "pre": {
            "chip": "!=null"
        }
    },
    "kprobe:snd_printdd": {
        "description": "Print debug message with formatted output.",
        "pre": {
            "format": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:snd_wss_overrange": {
        "description": "Detect overrange only above 0dB; may be user selectable?",
        "pre": {
            "chip": "!=null",
            "flags": "!=null",
            "res": "!=null",
            "chip->reg_lock": "!=null",
            "flags": "unsigned long",
            "res": "unsigned char",
            "chip->reg_lock": "spin_lock_irqsave",
            "chip->reg_lock": "spin_unlock_irqrestore",
            "res & (0x08 | 0x02)": "true"
        }
    }
},
{
    "kprobe:snd_wss_overrange": {
        "description": "Detect overrange only above 0dB; may be user selectable?",
        "pre": {
            "chip": "!=null",
            "chip->capture_substream": "!=null",
            "chip->capture_substream->runtime": "!=null",
            "chip->capture_substream->runtime->overrange": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:snd_wss_pcm": {
        "description": "Helper for snd_wss_pcm function",
        "pre": {
            "pcm->private_data": "== chip",
            "pcm->info_flags": "== 0",
            "pcm->info_flags": "&= SNDRV_PCM_INFO_HALF_DUPLEX",
            "pcm->info_flags": "&= SNDRV_PCM_INFO_JOINT_DUPLEX",
            "pcm->name": "== snd_wss_chip_id(chip)",
            "pcm": "!= null",
            "SNDRV_DMA_TYPE_DEV": "!= null",
            "chip->card->dev": "!= null",
            "64*1024": "!= null",
            "chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024": "!= null",
            "chip->pcm": "== pcm"
        }
    }
},
S,
S,
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable local interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:snd_wss_mixer": {
        "description": "Use only the first 11 entries on AD1848",
        "pre": {
            "chip": "!=null",
            "chip->hardware": "& WSS_HW_AD1848_MASK",
            "count": "= 11"
        }
    }
},
{
    "kprobe:snd_wss_mixer": {
        "description": "Use only the first 11 entries on AD1848",
        "pre": {
            "chip": "!=null",
            "chip->hardware": "& WSS_HW_AD1848_MASK",
            "count": "= 11"
        }
    }
},
{
    "kretprobe:elsegus->mix_cntrl_reg &= ~0x08;/* disable latches */": {
        "description": "Disable latches in elsegus",
        "pre": {
            "snd_gf1_delay": "!=null",
            "latches": "==true",
            "gus->mix_cntrl_reg": "&= ~0x08"
        }
    }
},
S,
S,
S,
{
    "kretprobe:snd_gus_init_dma_irq": {
        "description": "Initialize DMA IRQ for the snd_gus_card structure.",
        "pre": {
            "gus": "!=null",
            "latches": "!=null",
            "snd_gf1_peek(gus, 0L)": "!=0xaa",
            "snd_gf1_peek(gus, 1L)": "!=0x55",
            "snd_gf1_peek(gus, local)": "==d",
            "snd_gf1_peek(gus, local + 1)": "==d + 1",
            "snd_gf1_peek(gus, 0L)": "==0xaa",
            "gus->gf1.memory": "==idx << 18",
            "gus->gf1.memory": "==256 * 1024",
            "gus->gf1.mem_alloc.banks_8[l].address": "==0",
            "gus->gf1.mem_alloc.banks_8[l].size": "==0",
            "gus->gf1.mem_alloc.banks_16[l].address": "==l << 18",
            "gus->gf1.mem_alloc.banks_16[l].size": "==local > 0 ? 256 * 1024 : 0"
        }
    }
},
S,
{
    "kretprobe:gus->gf1.reg_page": {
        "description": "Assign the value of GUSP(gus, GF1PAGE) to gus->gf1.reg_page.",
        "pre": {
            "gus": "!=null",
            "GF1PAGE": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_regsel": {
        "description": "Assign the value of GUSP(gus, GF1REGSEL) to gus->gf1.reg_regsel.",
        "pre": {
            "gus": "!=null",
            "GF1REGSEL": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_data8": {
        "description": "Assign the value of GUSP(gus, GF1DATAHIGH) to gus->gf1.reg_data8.",
        "pre": {
            "gus": "!=null",
            "GF1DATAHIGH": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_data16": {
        "description": "Assign the value of GUSP(gus, GF1DATALOW) to gus->gf1.reg_data16.",
        "pre": {
            "gus": "!=null",
            "GF1DATALOW": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_irqstat": {
        "description": "Assign the value of GUSP(gus, IRQSTAT) to gus->gf1.reg_irqstat.",
        "pre": {
            "gus": "!=null",
            "IRQSTAT": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_dram": {
        "description": "Assign the value of GUSP(gus, DRAM) to gus->gf1.reg_dram.",
        "pre": {
            "gus": "!=null",
            "DRAM": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_timerctrl": {
        "description": "Assign the value of GUSP(gus, TIMERCNTRL) to gus->gf1.reg_timerctrl.",
        "pre": {
            "gus": "!=null",
            "TIMERCNTRL": "!=null"
        }
    },
    "kretprobe:gus->gf1.reg_timerdata": {
        "description": "Assign the value of GUSP(gus, TIMERDATA) to gus->gf1.reg_timerdata.",
        "pre": {
            "gus": "!=null",
            "TIMERDATA": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:snd_gus_detect_memory": {
        "description": "Memory detection routine for plain GF1 soundcards",
        "pre": {
            "gus": "!=null"
        }
    }
},
{
    "kprobe:snd_gus_detect_memory": {
        "description": "Memory detection routine for plain GF1 soundcards",
        "pre": {
            "gus": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Reset the sound blaster DSP chip and return the result.",
        "pre": {
            "chip": "!=null"
        }
    }
},
S,
{
    "kretprobe:snd_sbdsp_create": {
        "description": "Create a SoundBlaster DSP instance.",
        "pre": {
            "card": "!=null",
            "port": "!=null",
            "irq": "!=null",
            "irq_handler": "!=null",
            "dma8": "!=null",
            "dma16": "!=null",
            "hardware": "!=null",
            "r_chip": "!=null"
        },
        "post": {
            "dma16": "-1",
            "snd_devm_request_dma(card->dev, dma16, \"SoundBlaster - 16bit\")": "!=null"
        }
    }
},
{
    "kprobe:snd_sbdsp_create": {
        "description": "Create a SoundBlaster DSP instance.",
        "pre": {
            "card": "!=null",
            "port": "!=null",
            "irq": "!=null",
            "irq_handler": "!=null",
            "dma8": "!=null",
            "dma16": "!=null",
            "hardware": "!=null",
            "r_chip": "!=null"
        }
    },
    "kprobe:snd_devm_request_dma": {
        "description": "Request a DMA channel for SoundBlaster.",
        "pre": {
            "card->dev": "!=null",
            "dma16": "-1",
            "dma16_desc": "==\"SoundBlaster - 16bit\""
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:snd_sb16_playback_pointer": {
        "description": "Get the current playback pointer for the SB16 sound card.",
        "pre": {
            "chip": "!=null",
            "status": "!=null",
            "ok": "!=null",
            "irq": "!=null",
            "dev_id": "!=null",
            "SB_IRQTYPE_MPUIN": "!=null",
            "SB_IRQTYPE_8BIT": "!=null",
            "SB_IRQTYPE_16BIT": "!=null",
            "SB_MODE_PLAYBACK_8": "!=null",
            "SB_MODE_CAPTURE_8": "!=null",
            "SB_MODE_PLAYBACK_16": "!=null",
            "SB_MODE_CAPTURE_16": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:snd_sb16_playback_pointer": {
        "description": "Function to get the playback pointer for the snd_sb16 driver.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:snd_emu8000_poke": {
        "description": "Set register",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:snd_emu8000_poke": {
        "description": "Set register",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:emu->last_reg = reg;}res = inw(port);/* Read data": {
        "description": "Set the value of emu->last_reg to reg and read data from the specified port.",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:emu->last_reg = reg;}res = inw(port);/* Read data": {
        "description": "Set register and read data",
        "pre": {
            "emu": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:snd_emu8000_poke_dw": {
        "description": "Set register",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:snd_emu8000_poke_dw": {
        "description": "Set register value in the snd_emu8000 structure.",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:snd_emu8000_peek_dw": {
        "description": "Peek a double word from the EMU8000 sound card.",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:emu->last_reg = reg;}low = inw(port);/* Read low word of data`": {
        "description": "Set the value of emu->last_reg to reg and read the low word of data from the specified port.",
        "pre": {
            "emu": "!=null",
            "port": "!=null",
            "reg": "!=emu->last_reg"
        }
    }
},
S,
{
    "kprobe:EMU8000_CCCA_WRITE": {
        "description": "Write a value to the EMU8000 CCCA register.",
        "pre": {
            "emu": "!=null",
            "ch": "!=null",
            "right_bit": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:voidsnd_emu8000_update_chorus_mode": {
        "description": "Update the chorus mode in snd_emu8000 structure.",
        "pre": {
            "emu": "!=null"
        }
    }
},
{
    "kprobe:voidsnd_emu8000_update_chorus_mode": {
        "description": "Update the chorus mode for the snd_emu8000 structure.",
        "pre": {
            "emu": "!=null"
        }
    }
},
{
    "kretprobe:voidsnd_emu8000_update_reverb_mode": {
        "description": "Updates the reverb mode for the snd_emu8000 structure.",
        "pre": {
            "emu": "!=null"
        }
    }
},
{
    "kprobe:voidsnd_emu8000_update_reverb_mode": {
        "description": "Update the reverb mode for the snd_emu8000 structure.",
        "pre": {
            "emu": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "10"
        }
    },
    "kretprobe:outb": {
        "description": "Write a byte to a specified port.",
        "pre": {
            "value": "0",
            "port": "ES1688P(chip, RESET)"
        }
    },
    "kretprobe:udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "30"
        }
    },
    "kretprobe:for": {
        "description": "Loop with a condition until it becomes false.",
        "pre": {
            "condition": "i < 1000 && !(inb(ES1688P(chip, DATA_AVAIL)) & 0x80)"
        }
    },
    "kretprobe:if": {
        "description": "Conditional statement.",
        "pre": {
            "condition": "inb(ES1688P(chip, READ)) != 0xaa"
        }
    }
},
{
    "kprobe:udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "us": "10"
        }
    },
    "kprobe:outb": {
        "description": "Write a value to a specified port.",
        "pre": {
            "value": "0",
            "port": "ES1688P(chip, RESET)"
        }
    },
    "kprobe:udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "us": "30"
        }
    },
    "kprobe:for": {
        "description": "Loop until a condition is met.",
        "pre": {
            "condition": "!(inb(ES1688P(chip, DATA_AVAIL)) & 0x80)",
            "iteration": "1000"
        }
    },
    "kprobe:if": {
        "description": "Conditional statement.",
        "pre": {
            "condition": "inb(ES1688P(chip, READ)) != 0xaa"
        }
    }
},
{
    "snd_es1688_create": {
        "description": "Create a new snd_es1688 device.",
        "pre": {
            "card": "!=null",
            "chip": "!=null",
            "port": ">=0",
            "mpu_port": ">=0",
            "irq": ">=0",
            "mpu_irq": ">=0",
            "dma8": ">=0",
            "hardware": ">=0"
        },
        "post": {
            "err": "==0",
            "chip->irq": "== -1",
            "chip->dma8": "== -1",
            "chip->hardware": "== ES1688_HW_UNDEF",
            "chip->res_port": "!=null"
        }
    }
},
{
    "kprobe:snd_device_new": {
        "description": "Create a new sound device.",
        "pre": {
            "card": "!=null",
            "chip": "!=null",
            "port": ">=0",
            "mpu_port": ">=0",
            "irq": ">=0",
            "mpu_irq": ">=0",
            "dma8": ">=0",
            "hardware": ">=0"
        },
        "post": {
            "err": "==0"
        },
        "exit": {
            "err": "!=0",
            "actions": [
                "snd_es1688_free(chip)",
                "return err"
            ]
        }
    },
    "kprobe:snd_es1688_playback_ops": {
        "description": "Playback operations for ES1688 chip.",
        "pre": {},
        "post": {}
    }
},
{
    "snd_es1688_info_mux": {
        "pre": {
            "kcontrol": "!=null",
            "uinfo": "!=null"
        },
        "description": "This function is responsible for..."
    }
},
{
    "kprobe:snd_es1688_info_mux": {
        "description": "Information about the mixer control for the ES1688 sound card.",
        "pre": {
            "card": "!=null",
            "device": ">=0",
            "err": "<0",
            "pcm->info_flags": "==SNDRV_PCM_INFO_HALF_DUPLEX",
            "buffer_size": ">=64 && <=1024",
            "period_size": ">=64 && <=1024"
        }
    }
},
{
    "kretprobe:intel_nhlt_ssp_endpoint_mask": {
        "description": "Calculate the SSP mask for the given NHLT ACPI table and device type.",
        "pre": {
            "nhlt": "!=null",
            "device_type": "in [NHLT_DEVICE_BT, NHLT_DEVICE_I2S]",
            "epnt": "!=null",
            "ssp_mask": "int",
            "i": "int"
        },
        "post": {
            "ssp_mask": "int"
        }
    }
},
{
    "kprobe:intel_nhlt_ssp_endpoint_mask": {
        "description": "Calculate the SSP mask for the given NHLT ACPI table and device type.",
        "pre": {
            "nhlt": "!=null",
            "device_type": "in [NHLT_DEVICE_BT, NHLT_DEVICE_I2S]",
            "epnt": "!=null",
            "ssp_mask": "int",
            "i": "int",
            "epnt->linktype": "==NHLT_LINK_SSP",
            "epnt->device_type": "==device_type"
        }
    }
},
{
    "kretprobe:intel_nhlt_ssp_mclk_mask": {
        "description": "Calculate the MCLK mask for the given NHLT SSP number.",
        "pre": {
            "nhlt": "!=null",
            "ssp_num": "!=null",
            "epnt.linktype": "==NHLT_LINK_SSP",
            "epnt.device_type": "==NHLT_DEVICE_I2S",
            "epnt.virtual_bus_id": "==ssp_num"
        }
    }
},
{
    "kprobe:intel_nhlt_ssp_mclk_mask": {
        "description": "Checks if the linktype is NHLT_LINK_SSP, device_type is NHLT_DEVICE_I2S, and virtual_bus_id is equal to ssp_num.",
        "pre": {
            "epnt->linktype": "== NHLT_LINK_SSP",
            "epnt->device_type": "== NHLT_DEVICE_I2S",
            "epnt->virtual_bus_id": "== ssp_num"
        }
    }
},
{
    "kretprobe:uart_interrupt_tx": {
        "description": "generic MPU401-UART interrupt handler",
        "pre": {
            "mpu": "!=null",
            "mpu->info_flags": "& MPU401_INFO_INPUT != 0",
            "mpu->input_lock": "!=null",
            "mpu->mode": "& MPU401_MODE_BIT_INPUT != 0",
            "mpu->info_flags": "& MPU401_INFO_TX_IRQ == 0"
        }
    }
},
{
    "kprobe:uart_interrupt_tx": {
        "description": "Generic MPU401-UART interrupt handler",
        "pre": {
            "mpu": "!=null",
            "mpu->info_flags": "& MPU401_INFO_INPUT",
            "mpu->input_lock": "!=null",
            "mpu->mode": "& MPU401_MODE_BIT_INPUT",
            "mpu->info_flags": "& MPU401_INFO_TX_IRQ"
        }
    }
},
{
    "kretprobe:snd_mpu401_uart_interrupt_tx": {
        "description": "generic MPU401-UART transmit irq handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        },
        "post": {
            "return": "in [IRQ_HANDLED, IRQ_NONE]"
        }
    }
},
{
    "kprobe:snd_mpu401_uart_interrupt_tx": {
        "description": "generic MPU401-UART transmit irq handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:snd_mpu401_uart_new": {
        "description": "Create an MPU401-UART instance",
        "pre": {
            "card": "!=null",
            "device": "is integer",
            "hardware": "is integer",
            "port": "is integer",
            "info_flags": "is integer",
            "irq": "is integer",
            "rrawmidi": "!=null"
        }
    }
},
{
    "kprobe:snd_mpu401_uart_new": {
        "description": "Create an MPU401-UART instance",
        "pre": {
            "card": "!=null",
            "device": "is integer",
            "hardware": "is integer",
            "port": "is integer",
            "info_flags": "is integer",
            "irq": "is integer",
            "rrawmidi": "!=null"
        }
    }
},
{
    "kretprobe:snd_vx_setup_firmware": {
        "description": "Create the devices if not built yet.",
        "pre": {
            "chip": "!=null",
            "chip->type": "in [VX_TYPE_BOARD, VX_TYPE_V2, VX_TYPE_MIC, VX_TYPE_VXPOCKET, VX_TYPE_VXP440]",
            "fw_files[chip->type][0]": "!=null",
            "fw_files[chip->type][1]": "!=null",
            "fw_files[chip->type][2]": "!=null",
            "fw_files[chip->type][3]": "!=null"
        }
    }
},
{
    "snd_vx_setup_firmware": {
        "description": "Create the devices if not built yet.",
        "pre": {
            "chip": "!=null",
            "chip->type": "in [VX_TYPE_BOARD, VX_TYPE_V2, VX_TYPE_MIC, VX_TYPE_VXPOCKET, VX_TYPE_VXP440]"
        }
    }
},
{
    "kretprobe:snd_vx_load_boot_image": {
        "description": "Boot up the Xilinx interface",
        "pre": {
            "chip": "!=null",
            "boot": "!=null"
        }
    }
},
{
    "kprobe:snd_vx_load_boot_image": {
        "description": "Boot up the Xilinx interface.",
        "pre": {
            "chip": "!=null",
            "boot": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_vx_irq_handler": {
        "description": "Interrupt handler for snd_vx_irq_handler",
        "pre": {
            "irq": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:snd_vx_irq_handler": {
        "description": "Interrupt handler for snd_vx_irq_handler",
        "pre": {
            "irq": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:snd_vx_dsp_boot": {
        "description": "Load the DSP boot",
        "pre": {
            "chip": "!=null",
            "boot": "!=null"
        }
    }
},
{
    "kprobe:snd_vx_dsp_boot": {
        "description": "Load the DSP boot",
        "pre": {
            "chip": "!=null",
            "boot": "!=null"
        }
    }
},
{
    "kretprobe:snd_vx_dsp_load": {
        "description": "Load the DSP image",
        "pre": {
            "chip": "!=null",
            "dsp": "!=null"
        }
    }
},
{
    "kprobe:snd_vx_dsp_load": {
        "description": "Load the DSP image",
        "pre": {
            "chip": "!=null",
            "dsp": "!=null"
        }
    }
},
{
    "kretprobe:snd_vx_create": {
        "description": "Constructor for struct vx_core",
        "pre": {
            "card": "!=null",
            "hw": "!=null",
            "ops": "!=null",
            "extra_size": "int"
        }
    }
},
{
    "kprobe:snd_vx_create": {
        "description": "Constructor for struct vx_core",
        "pre": {
            "card": "!=null",
            "hw": "!=null",
            "ops": "!=null",
            "extra_size": "int"
        }
    }
},
{
    "kretprobe:snd_opl4_enable_opl4": {
        "description": "Enable OPL4.",
        "pre": {
            "opl4": "!=null"
        }
    },
    "kretprobe:snd_opl4_create_mixer": {
        "description": "Create mixer for OPL4.",
        "pre": {
            "opl4": "!=null"
        }
    },
    "kretprobe:snd_opl4_create_proc": {
        "description": "Create proc for OPL4.",
        "pre": {
            "opl4": "!=null"
        }
    },
    "kretprobe:snd_opl4_create_seq_dev": {
        "description": "Create sequencer device for OPL4.",
        "pre": {
            "opl4": "!=null",
            "seq_device": "!=null",
            "opl4->hardware": "< OPL3_HW_OPL4_ML"
        }
    },
    "kretprobe:snd_opl4_create": {
        "description": "Create OPL4.",
        "pre": {
            "card": "!=null",
            "fm_port": "!=null",
            "pcm_port": "!=null",
            "seq_device": "!=null",
            "ropl3": "==null",
            "ropl4": "==null"
        }
    }
},
S,
{
    "kretprobe:opl3->command": {
        "description": "Command function of opl3",
        "pre": {
            "opl3": "!=null",
            "OPL3_LEFT | OPL3_REG_PERCUSSION": "!=null",
            "0x00": "!=null"
        }
    }
},
{
    "kprobe:opl3->command": {
        "description": "Execute the command on the OPL3 device.",
        "pre": {
            "opl3": "!=null",
            "opl3->command": "!=null",
            "opl3->command.arguments": {
                "arg1": "OPL3_LEFT | OPL3_REG_PERCUSSION",
                "arg2": "0x00"
            },
            "opl3->hardware": "!=null",
            "opl3->hardware & OPL3_HW_MASK": "!=0"
        }
    }
},
{
    "kretprobe:snd_opl3_create": {
        "description": "Create a new snd_opl3 instance.",
        "pre": {
            "card": "!=null",
            "l_port": ">=0",
            "r_port": ">=0",
            "hardware": "in [OPL3_HW_OPL3_SV, OPL3_HW_OPL3_CS, OPL3_HW_OPL3_FM801]",
            "integrated": "in [0, 1]",
            "ropl3": "==null"
        },
        "post": {
            "opl3": "!=null",
            "err": "<0"
        }
    }
},
S,
{
    "kretprobe:snd_hwdep_new": {
        "description": "Create hardware dependent device (direct FM).",
        "pre": {
            "card": "!=null",
            "device": "!=null",
            "hw": "!=null"
        },
        "post": {
            "err": "< 0"
        }
    }
},
{
    "kprobe:snd_hwdep_new": {
        "description": "Create hardware dependent device (direct FM).",
        "pre": {
            "card": "!=null",
            "device": "!=null",
            "hw": "!=null"
        }
    }
},
S,
S,
O,
S,
{
    "kretprobe:snd_opl3_find_patch": {
        "description": "Find a patch with the given program and bank numbers, returns its pointer if no matching patch is found and create_patch is set, it creates a new patch object.",
        "pre": {
            "opl3": "!=null",
            "prog": "!=null",
            "bank": "!=null",
            "create_patch": "==1"
        }
    }
},
{
    "kprobe:snd_opl3_find_patch": {
        "description": "Find a patch with the given program and bank numbers, returns its pointer if no matching patch is found and create_patch is set, it creates a new patch object.",
        "pre": {
            "opl3": "!=null",
            "prog": "!=null",
            "bank": "!=null",
            "create_patch": "!=null"
        }
    }
},
{
    "kretprobe:snd_opl3_release": {
        "description": "Release the snd_opl3 device.",
        "pre": {
            "hw": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:snd_opl3_release": {
        "description": "Release the snd_opl3 device.",
        "pre": {
            "hw": "!=null",
            "file": "!=null"
        }
    }
},
S,
{
    "kprobe:list_move_tail": {
        "description": "Move the list entry at the tail of the mapped order link to the head of the mapped order link in the emu structure.",
        "pre": {
            "emu": "!=null",
            "blk": "!=null",
            "emu.memblk_lock": "!=null",
            "blk.mapped_order_link": "!=null",
            "emu.mapped_order_link_head": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Unlock the emu structure's memblk_lock and restore the IRQ state.",
        "pre": {
            "emu": "!=null",
            "emu.memblk_lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:map_memblk": {
        "description": "Map the memblk in the emu structure.",
        "pre": {
            "emu": "!=null",
            "blk": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:snd_ice1712_akm4xxx_build_controls": {
        "description": "Build AK4xxx controls.",
        "pre": {
            "ice": "!=null",
            "ice->akm": "!=null",
            "ice->akm_codecs": ">0",
            "akidx": ">=0",
            "akidx": "< ice->akm_codecs",
            "ak": "!=null",
            "ak->private_value[0]": "!=null"
        }
    }
},
{
    "kprobe:snd_ice1712_akm4xxx_build_controls": {
        "description": "build AK4xxx controls",
        "pre": {
            "ice": "!=null",
            "ice->akm": "!=null",
            "ice->akm_codecs": ">=0",
            "akidx": ">=0",
            "akidx": "< ice->akm_codecs",
            "ak": "!=null",
            "ak->private_value[0]": "!=null"
        }
    }
},
{
    "kretprobe:snd_trident_start_voice": {
        "description": "Start a voice, any channel 0 thru 63. This routine automatically handles the fact that there are more than 32 channels available.",
        "pre": {
            "trident": "!=null",
            "voice": ">=0",
            "voice": "<=63"
        }
    }
},
{
    "kprobe:snd_trident_start_voice": {
        "description": "Start a voice, any channel 0 thru 63. This routine automatically handles the fact that there are more than 32 channels available.",
        "pre": {
            "trident": "!=null",
            "voice": ">=0",
            "voice": "<=63"
        }
    }
},
{
    "kretprobe:snd_trident_stop_voice": {
        "description": "Stop a voice, any channel 0 thru 63. This routine automatically handles the fact that there are more than 32 channels available.",
        "pre": {
            "trident": "!=null",
            "voice": ">=0",
            "voice": "<=63"
        }
    }
},
{
    "kprobe:snd_trident_stop_voice": {
        "description": "Stop a voice, any channel 0 thru 63. This routine automatically handles the fact that there are more than 32 channels available.",
        "pre": {
            "trident": "!=null",
            "voice": ">=0",
            "voice": "<=63"
        }
    }
},
{
    "kretprobe:snd_trident_write_voice_regs": {
        "description": "This routine will complete and write the 5 hardware channel registers to hardware.",
        "pre": {
            "trident": "!=null",
            "voice": "!=null"
        }
    }
},
{
    "kprobe:snd_trident_write_voice_regs": {
        "description": "This routine will complete and write the 5 hardware channel registers to hardware.",
        "pre": {
            "trident": "!=null",
            "voice": "!=null"
        }
    }
},
{
    "kretprobe:snd_trident_hw_params": {
        "description": "Set the hardware parameters for the playback device.",
        "pre": {
            "substream": "!=null",
            "hw_params": "!=null"
        }
    }
},
S,
{
    "kretprobe:snd_ac97_set_rate": {
        "description": "Change the rate of the given input/output.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "rate": "!=null",
            "reg": "in [AC97_PCM_MIC_ADC_RATE, AC97_PCM_FRONT_DAC_RATE, AC97_PCM_LR_ADC_RATE, AC97_PCM_SURR_DAC_RATE, AC97_PCM_LFE_DAC_RATE, AC97_SPDIF]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
S,
{
    "kretprobe:snd_ac97_pcm_assign": {
        "description": "Assign AC97 slots to given PCM streams",
        "pre": {
            "bus": "!=null",
            "pcms_count": ">=0",
            "pcms": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_pcm_assign": {
        "description": "Assign AC97 slots to given PCM streams",
        "pre": {
            "bus": "!=null",
            "pcms_count": ">=0",
            "pcms": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_pcm_open": {
        "description": "Opens the given AC97 pcm",
        "pre": {
            "pcm": "!=null",
            "rate": "!=null",
            "cfg": "!=null",
            "slots": "!=null",
            "rate": "==48000",
            "slots": "subset of allocated slots (snd_ac97_pcm_assign)"
        }
    }
},
{
    "kprobe:snd_ac97_pcm_open": {
        "description": "Opens the given AC97 pcm",
        "pre": {
            "pcm": "!=null",
            "rate": "!=null",
            "cfg": "!=null",
            "slots": "!=null",
            "rate": "==48000",
            "slots": "subset of allocated slots (snd_ac97_pcm_assign)"
        }
    }
},
{
    "kretprobe:snd_ac97_pcm_close": {
        "description": "Closes the given AC97 pcm",
        "pre": {
            "pcm": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:snd_ac97_pcm_close": {
        "description": "Closes the given AC97 pcm",
        "pre": {
            "pcm": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_pcm_double_rate_rules": {
        "description": "Set double rate constraints",
        "pre": {
            "runtime": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_ac97_pcm_double_rate_rules": {
        "description": "Set double rate constraints",
        "pre": {
            "runtime": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_write": {
        "description": "Write a value on the given register.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_write": {
        "description": "Write a value on the given register.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_read": {
        "description": "Read a value from the given register.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_read": {
        "description": "Read a value from the given register.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_write_cache": {
        "description": "Write a value on the given register and update the cache.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_write_cache": {
        "description": "Write a value on the given register and update the cache.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_update": {
        "description": "Update the value on the given register",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_update": {
        "description": "Update the value on the given register",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_update_bits": {
        "description": "Update the bits on the given register",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "mask": "!=null",
            "value": "!=null"
        },
        "post": {
            "return": "in [1, 0, negative code]"
        }
    }
},
{
    "kprobe:snd_ac97_update_bits": {
        "description": "Update the bits on the given register",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "mask": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_get_short_name": {
        "description": "Retrieve the short identifying name of the codec.",
        "pre": {
            "ac97": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_get_short_name": {
        "description": "Retrieve the short identifying name of the codec.",
        "pre": {
            "ac97": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_free": {
        "description": "Free the memory allocated for the snd_ac97 structure.",
        "pre": {
            "ac97": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_free": {
        "description": "Free the snd_ac97 structure.",
        "pre": {
            "ac97": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_ac97_update_power": {
        "description": "Update the AC97 powerdown register bits of the given part.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "powerup": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_update_power": {
        "description": "Update the AC97 powerdown register bits of the given part.",
        "pre": {
            "ac97": "!=null",
            "reg": "!=null",
            "powerup": "!=0"
        }
    }
},
{
    "kretprobe:snd_ac97_suspend": {
        "description": "General suspend function for AC97 codec",
        "pre": {
            "ac97": "!=null"
        }
    }
},
{
    "kprobe:snd_ac97_suspend": {
        "description": "General suspend function for AC97 codec",
        "pre": {
            "ac97": "!=null"
        }
    }
},
{
    "kretprobe:snd_ac97_powerdown": {
        "description": "Power down the snd_ac97 device.",
        "pre": {
            "ac97": "!=null"
        }
    }
},
S,
{
    "kretprobe:snd_ac97_tune_hardware": {
        "description": "Tune up the hardware",
        "pre": {
            "ac97": "!=null",
            "quirk": "!=null",
            "override": "!=null",
            "quirk_list_terminated": "true"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_ac97_tune_hardware": {
        "description": "Tune up the hardware",
        "pre": {
            "ac97": "!=null",
            "quirk": "!=null",
            "override": "!=null"
        }
    }
},
{
    "kretprobe:hpi_send_recv": {
        "description": "This function is called from hpifunc.c functions, called by ALSA (or other kernel process). In this case, there is no file descriptor available for the message cache code.",
        "pre": {
            "phm": "!=null",
            "phr": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:hpi_send_recv": {
        "description": "Function to send and receive HPI messages",
        "pre": {
            "phm": {
                "adapter_index": ">= HPI_MAX_ADAPTERS",
                "object": "!= HPI_OBJ_SUBSYSTEM"
            },
            "phr": {
                "error": "HPI_ERROR_INVALID_OBJ_INDEX"
            }
        }
    }
},
{
    "kretprobe:oxygen_ac97_wait": {
        "description": "Wait for the completion of an AC97 operation.",
        "pre": {
            "chip": "!=null",
            "OXYGEN_AC97_INT_WRITE_DONE": "!=null",
            "return_value": ">= 0"
        }
    },
    "kretprobe:++succeeded": {
        "description": "Increment the 'succeeded' variable.",
        "pre": {
            "succeeded": "!=null",
            "succeeded": ">= 2"
        }
    }
},
{
    "kprobe:oxygen_write_ac97": {
        "description": "Write data to the AC97 codec.",
        "pre": {
            "chip": "!=null",
            "codec": "!=null",
            "index": "!=null",
            "data": "!=null",
            "succeeded": ">=2"
        }
    }
},
{
    "kretprobe:oxygen_read_ac97": {
        "description": "Reads a value from the AC97 codec.",
        "pre": {
            "chip": "!=null",
            "codec": "!=null",
            "index": "!=null",
            "count": ">= 0",
            "last_read": "!= value",
            "reg": "!=null",
            "value": "== last_read"
        }
    }
},
{
    "kprobe:oxygen_read_ac97": {
        "description": "Reads a value from the AC97 codec.",
        "pre": {
            "chip": "!=null",
            "codec": "!=null",
            "index": "!=null",
            "count": ">= 0",
            "last_read": "!=null",
            "reg": "!=null",
            "value": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:oxygen_write_i2c": {
        "description": "Write data to an I2C device on an oxygen chip.",
        "pre": {
            "chip": "!=null",
            "device": "!=null",
            "map": "!=null",
            "data": "!=null",
            "msleep(1)": "takes less than or equal to 1 ms",
            "oxygen_write8(chip, OXYGEN_2WIRE_MAP, map)": "returns success",
            "oxygen_write8(chip, OXYGEN_2WIRE_DATA, data)": "returns success",
            "oxygen_write8(chip, OXYGEN_2WIRE_CONTROL, device | OXYGEN_2WIRE_DIR_WRITE)": "returns success"
        }
    }
},
{
    "kprobe:oxygen_write_i2c": {
        "description": "Write data to an I2C device on the oxygen chip.",
        "pre": {
            "chip": "!=null",
            "device": "!=null",
            "map": "!=null",
            "data": "!=null"
        },
        "post": {
            "chip": "==chip",
            "device": "==device",
            "map": "==map",
            "data": "==data"
        },
        "side_effects": "none"
    }
},
S,
{
    "kprobe:_write_uart": {
        "description": "Reset UART and wait for ACK",
        "pre": {
            "chip": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:down_write": {
        "description": "Acquire a write lock on the specified rwsem.",
        "pre": {
            "&umidi->disc_rwsem": "!=null"
        }
    },
    "kretprobe:spin_lock_irq": {
        "description": "Acquire a spinlock with IRQs disabled.",
        "pre": {
            "&umidi->disc_lock": "!=null"
        }
    },
    "kretprobe:spin_unlock_irq": {
        "description": "Release a spinlock with IRQs disabled.",
        "pre": {
            "&umidi->disc_lock": "!=null"
        }
    },
    "kretprobe:up_write": {
        "description": "Release a write lock on the specified rwsem.",
        "pre": {
            "&umidi->disc_rwsem": "!=null"
        }
    },
    "kretprobe:del_timer_sync": {
        "description": "Delete a timer synchronously.",
        "pre": {
            "&umidi->error_timer": "!=null"
        }
    },
    "kretprobe:for_loop": {
        "description": "Iterate over MIDI endpoints.",
        "pre": {
            "i": ">=0",
            "i": "<MIDI_MAX_ENDPOINTS"
        }
    }
},
{
    "kprobe:down_write": {
        "description": "Acquire a write lock on the specified rwsem.",
        "pre": {
            "rwsem": "!=null"
        }
    },
    "kprobe:spin_lock_irq": {
        "description": "Acquire a spinlock with IRQs disabled.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release a spinlock with IRQs enabled.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:up_write": {
        "description": "Release a write lock on the specified rwsem.",
        "pre": {
            "rwsem": "!=null"
        }
    },
    "kprobe:del_timer_sync": {
        "description": "Delete a timer synchronously.",
        "pre": {
            "timer": "!=null"
        }
    },
    "kprobe:for": {
        "description": "Loop over a range of values.",
        "pre": {
            "i": ">=0",
            "i": "<MIDI_MAX_ENDPOINTS"
        }
    }
},
{
    "kretprobe:snd_rawmidi_proceed": {
        "description": "Proceed with the raw MIDI substream.",
        "pre": {
            "substream": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:queue_work": {
        "description": "Queue work on the system high priority workqueue.",
        "pre": {
            "system_highpri_wq": "!=null",
            "port": {
                "ep": {
                    "work": "!=null"
                }
            }
        }
    },
    "kretprobe:snd_usbmidi_output_drain": {
        "description": "Drain the output of the USB MIDI substream.",
        "pre": {
            "substream": "!=null"
        }
    }
},
S,
{
    "kretprobe:memset": {
        "description": "Set the memory at 'endpoints' to zero with the size of 'endpoints'.",
        "pre": {
            "endpoints": "!=null",
            "quirk": "!=null",
            "quirk->type": "in [QUIRK_MIDI_STANDARD_INTERFACE]",
            "sizeof(endpoints)": ">0"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set the memory of 'endpoints' to zero.",
        "pre": {
            "endpoints": "!=null",
            "sizeof(endpoints)": "sizeof(endpoints) == MIDI_MAX_ENDPOINTS * sizeof(struct snd_usb_midi_endpoint_info)",
            "quirk": "!=null"
        }
    },
    "kprobe:switch": {
        "description": "Switch statement based on the value of 'quirk->type' or 'QUIRK_MIDI_STANDARD_INTERFACE'.",
        "pre": {
            "quirk": "!=null",
            "quirk->type": "in [QUIRK_MIDI_STANDARD_INTERFACE, ...]",
            "QUIRK_MIDI_STANDARD_INTERFACE": "defined"
        }
    }
},
S,
S,
S,
{
    "kprobe:snd_util_memhdr_free": {
        "description": "Release all blocks in the given snd_util_memhdr structure.",
        "pre": {
            "hdr": "!=null"
        }
    }
},
{
    "kretprobe:units = size;if (units & 1)units++;if (units > hdr->size)return NULL;/* look for empty block`": {
        "description": "Allocate memory block based on size and header information.",
        "pre": {
            "hdr": "!=null",
            "size": ">0",
            "units": ">=size",
            "units & 1": "==0",
            "hdr->size": ">=units"
        }
    }
},
{
    "kprobe:__snd_util_mem_alloc": {
        "description": "word alignment",
        "pre": {
            "hdr": "!=null",
            "size": ">0"
        }
    }
},
S,
{
    "kprobe:snd_util_mem_free": {
        "description": "Free a memory block (with mutex).",
        "pre": {
            "hdr": "!=null",
            "blk": "!=null"
        }
    }
},
{
    "kretprobe:__snd_util_memblk_new": {
        "description": "Create a new memory block with the given size and link it next to prev.",
        "pre": {
            "hdr": "!=null",
            "units": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kprobe:__snd_util_memblk_new": {
        "description": "Create a new memory block with the given size and link it next to prev.",
        "pre": {
            "hdr": "!=null",
            "units": ">=0",
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:snd_emux_register": {
        "description": "Register the sound emulator.",
        "pre": {
            "private_data": "emu",
            "sample_new": "!=null",
            "sample_free": "!=null",
            "sample_reset": "!=null",
            "sflist": "==null"
        }
    }
},
{
    "kprobe:snd_emux_register": {
        "description": "Register a sound emulator",
        "pre": {
            "emu.hw": "!=null",
            "emu.max_voices": ">0",
            "card": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:snd_sf_linear_to_log": {
        "description": "Converts a linear value to a logarithmic value using the given parameters.",
        "pre": {
            "amount": ">1",
            "offset": "!=null",
            "ratio": "!=null"
        }
    }
},
{
    "kprobe:snd_sf_linear_to_log": {
        "description": "Converts a linear value to a logarithmic value using the given parameters.",
        "pre": {
            "amount": ">1",
            "offset": "!=null",
            "ratio": "!=null"
        }
    }
},
{
    "kretprobe:snd_emux_terminate_all": {
        "description": "Terminate all emulated voices in snd_emux",
        "pre": {
            "emu": "!=null",
            "emu->voice_lock": "unlocked"
        },
        "post": {
            "emu->use_time": "==0",
            "emu->voice_lock": "unlocked"
        }
    }
},
{
    "snd_emux_terminate_all": {
        "description": "initialize allocation time",
        "pre": {
            "emu": "!=null"
        }
    }
},
{
    "kretprobe:snd_soc_alloc_ac97_component": {
        "description": "Allocate a new AC'97 device for the given COMPONENT.",
        "pre": {
            "component": "!=null"
        },
        "post": {
            "return_value": "!=PTR_ERR"
        }
    }
},
{
    "kprobe:snd_soc_alloc_ac97_component": {
        "description": "Allocate a new AC'97 device",
        "pre": {
            "component": "!=null"
        }
    }
},
{
    "kretprobe:mt8192_afe_gpio_init": {
        "description": "Initialize GPIOs for MT8192 AFE",
        "pre": {
            "aud_pinctrl": "!=null",
            "ret": "is_error(aud_pinctrl) => return ret",
            "aud_gpios[i].gpioctrl": "!=error",
            "aud_gpios[i].gpioctrl": "is_error => print_debug_message(ret)",
            "aud_gpios[i].gpio_prepare": "true"
        }
    }
},
{
    "kprobe:mt8192_afe_gpio_init": {
        "description": "Initialize GPIO pins based on the given device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fsl_asoc_get_dma_channel": {
        "description": "Determines the dma and channel id for a given SSI node and discovers the platform_name for the ASoC DAI link.",
        "pre": {
            "ssi_np": "!=null",
            "name": "!=null",
            "dai": "!=null",
            "dma_channel_id": "!=null",
            "dma_id": "!=null"
        }
    }
},
{
    "kprobe:fsl_asoc_get_dma_channel": {
        "description": "Determine the dma channel for a SSI node",
        "pre": {
            "ssi_np": "!=null",
            "name": "!=null",
            "dai": "!=null",
            "dma_channel_id": "!=null",
            "dma_id": "!=null"
        }
    }
},
{
    "kretprobe:fsl_asoc_get_pll_clocks": {
        "description": "Get two PLL clock sources",
        "pre": {
            "dev": "!=null",
            "pll8k_clk": "!=null",
            "pll11k_clk": "!=null"
        }
    }
},
{
    "kprobe:fsl_asoc_get_pll_clocks": {
        "description": "Get two PLL clock source",
        "pre": {
            "dev": "!=null",
            "pll8k_clk": "!=null",
            "pll11k_clk": "!=null"
        }
    }
},
{
    "kretprobe:fsl_asoc_reparent_pll_clocks": {
        "description": "Set clock parent if necessary",
        "pre": {
            "dev": "!=null",
            "clk": "!=null",
            "pll8k_clk": "!=null",
            "pll11k_clk": "!=null",
            "ratio": "!=null"
        }
    }
},
{
    "kprobe:fsl_asoc_reparent_pll_clocks": {
        "description": "Set clock parent if necessary.",
        "pre": {
            "dev": "!=null",
            "clk": "!=null",
            "pll8k_clk": "!=null",
            "pll11k_clk": "!=null",
            "ratio": "!=null"
        }
    }
},
{
    "kretprobe:snd_amd_acp_find_config": {
        "description": "Do not enable FLAGS on older platforms with Rev id zero",
        "pre": {
            "pci->revision": "==0"
        }
    }
},
{
    "kprobe:snd_amd_acp_find_config": {
        "description": "Do not enable FLAGS on older platforms with Rev id zero",
        "pre": {
            "pci->revision": "==0"
        }
    }
},
{
    "kretprobe:snd_sof_load_firmware_raw": {
        "description": "Don't request firmware again if firmware is already requested",
        "pre": {
            "sdev->basefw.fw": "==null",
            "plat_data->fw_filename_prefix": "!=null",
            "plat_data->fw_filename": "!=null",
            "fw_filename": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:snd_sof_load_firmware_raw": {
        "description": "Don't request firmware again if firmware is already requested",
        "pre": {
            "sdev->basefw.fw": "==null",
            "plat_data->fw_filename_prefix": "!=null",
            "plat_data->fw_filename": "!=null",
            "fw_filename": "!=null",
            "ret": ">=0"
        }
    }
},
S,
{
    "snd_sof_load_firmware_memcpy": {
        "description": "Load firmware using memcpy",
        "pre": {
            "sdev": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kretprobe:snd_sof_run_firmware": {
        "description": "Run firmware for the snd_sof_dev structure.",
        "pre": {
            "sdev": "!=null",
            "ret": "!=null",
            "boot_wait": "initialized",
            "dsp_dump_enabled": "true"
        }
    }
},
{
    "kprobe:snd_sof_run_firmware": {
        "description": "Run firmware for the snd_sof_dev structure.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__iowrite32_copy": {
        "description": "Write a 32-bit value from *src* to *dest* using *m* as the size.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "m": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:__iowrite32_copy": {
        "description": "Write 32-bit values from *src* to *dest* with *m* 32-bit values and *n* remaining bytes.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "m": ">=0",
            "n": ">=0"
        }
    }
},
S,
S,
S,
{
    "kprobe:sof_ipc4_set_pipeline_state": {
        "description": "Set the pipeline state for multiple pipelines using a single IPC.",
        "pre": {
            "sdev": "!=null",
            "trigger_list->pipeline_ids[0]": "!=null",
            "state": "!=null",
            "msg.primary": "!=null",
            "msg.primary & SOF_IPC4_MSG_TYPE_MASK": "== SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_SET_PIPELINE_STATE)",
            "msg.primary & SOF_IPC4_MSG_DIR_MASK": "== SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST)",
            "msg.primary & SOF_IPC4_MSG_TARGET_MASK": "== SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG)"
        }
    }
},
{
    "kretprobe:snd_sof_dsp_update_bits_forced": {
        "description": "Updates the bits of a register with the given values.",
        "pre": {
            "sdev": "!=null",
            "bar": "!=null",
            "offset": "!=null",
            "mask": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:snd_sof_dsp_update_bits_forced": {
        "description": "Updates the bits of a register with the given mask and value.",
        "pre": {
            "sdev": "!=null",
            "bar": ">=0",
            "offset": ">=0",
            "mask": ">=0",
            "value": ">=0"
        }
    }
},
{
    "kretprobe:snd_sof_dsp_panic": {
        "description": "Handle a received DSP panic message",
        "pre": {
            "sdev": "!=null",
            "offset": "!=null",
            "non_recoverable": "in [true, false]"
        }
    }
},
{
    "kprobe:snd_sof_dsp_panic": {
        "description": "Handle a received DSP panic message",
        "pre": {
            "sdev": "!=null",
            "offset": "!=null",
            "non_recoverable": "is boolean"
        }
    }
},
{
    "kretprobe:sof_debug_check_flag": {
        "description": "Check if a given flag(s) is set in sof_core_debug.",
        "pre": {
            "mask": "!=null",
            "mask_bits_set_in_sof_core_debug": "all_bits_set_in(mask) are also set in sof_core_debug"
        }
    }
},
{
    "kprobe:sof_debug_check_flag": {
        "description": "Check if a given flag(s) is set in sof_core_debug.",
        "pre": {
            "mask": "!=null",
            "mask_bits_set_in_sof_core_debug": "all bits set in mask are also set in sof_core_debug"
        }
    }
},
{
    "kretprobe:sof_print_oops_and_stack": {
        "description": "Handle the printing of DSP oops and stack trace",
        "pre": {
            "sdev": "!=null",
            "level": "!=null",
            "panic_code": "!=null",
            "tracep_code": "!=null",
            "oops": "!=null",
            "panic_info": "!=null",
            "stack": "!=null",
            "stack_words": "!=null"
        }
    }
},
{
    "kprobe:sof_print_oops_and_stack": {
        "description": "Handle the printing of DSP oops and stack trace",
        "pre": {
            "sdev": "!=null",
            "level": "!=null",
            "panic_code": "!=null",
            "tracep_code": "!=null",
            "oops": "!=null",
            "panic_info": "!=null",
            "stack": "!=null",
            "stack_words": ">=0"
        }
    }
},
{
    "kretprobe:snd_sof_device_probe": {
        "description": "Initialize sof device",
        "pre": {
            "dev": "!=null",
            "sdev": "!=null"
        }
    }
},
S,
S,
{
    "kprobe:sof_unregister_clients": {
        "description": "Unregister machine driver. This will unbind the snd_card which will remove the component driver and unload the topology before freeing the snd_card.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:snd_sof_create_page_table": {
        "description": "Generate page table for given parameters.",
        "pre": {
            "dev": "!=null",
            "dmab": "!=null",
            "page_table": "!=null",
            "size": "!=null",
            "i": ">=0",
            "pages": ">=0",
            "idx": ">=0",
            "pfn": ">=0",
            "pg_table": "!=null"
        },
        "post": {
            "idx": "==(5 * i) >> 1",
            "pfn": "==snd_sgbuf_get_addr(dmab, i * PAGE_SIZE) >> PAGE_SHIFT",
            "pg_table": "==page_table + idx"
        }
    }
},
{
    "kprobe:snd_sof_create_page_table": {
        "description": "Generate page table for given parameters.",
        "pre": {
            "dev": "!=null",
            "dmab": "!=null",
            "page_table": "!=null",
            "size": "!=null",
            "i": ">=0",
            "pages": ">=0",
            "idx": ">=0",
            "pfn": ">=0",
            "pg_table": "!=null"
        }
    }
},
{
    "kretprobe:snd_sof_handle_fw_exception": {
        "description": "Handle firmware exception in snd_sof_dev",
        "pre": {
            "sdev->ipc_dump_printed": "==false",
            "sdev->dev": "!=null"
        }
    }
},
{
    "kprobe:snd_sof_handle_fw_exception": {
        "description": "Handle firmware exception in snd_sof_dev.",
        "pre": {
            "sdev->ipc_dump_printed": "==false"
        }
    }
},
S,
S,
{
    "kretprobe:snd_sof_device_remove": {
        "description": "Remove the SOF device and DSP hardware.",
        "pre": {
            "pdev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:sof_of_remove": {
        "description": "Remove the SOF device and disable power management runtime.",
        "pre": {
            "pdev": "!=null",
            "pdev->dev": "!=null",
            "pm_runtime_disable(&pdev->dev)": "called",
            "call sof helper for DSP hardware remove": "called"
        }
    }
},
{
    "kretprobe:if (!sdev->msg)": {
        "description": "Check if the `msg` field of `sdev` is null.",
        "pre": {
            "sdev": {
                "msg": "==null"
            }
        }
    }
},
{
    "kprobe:if (!sdev->msg)": {
        "description": "Check if the `msg` field of `sdev` is null.",
        "pre": {
            "sdev": {
                "msg": "==null"
            }
        }
    }
},
{
    "kretprobe:snd_sof_ipc_reply": {
        "description": "Wake up and return the error if we have waiters on this message.",
        "pre": {
            "sdev": "!=null",
            "msg_id": "!=null",
            "msg": "!=null",
            "msg->ipc_complete": "==true"
        }
    }
},
{
    "kprobe:snd_sof_ipc_reply": {
        "description": "Wake up and return the error if we have waiters on this message.",
        "pre": {
            "sdev": "!=null",
            "msg_id": "!=null",
            "msg": "!=null",
            "msg->ipc_complete": "==true"
        }
    }
},
{
    "kretprobe:snd_sof_ipc_init": {
        "description": "Initialize the snd_sof_ipc structure and the snd_sof_ipc_msg structure.",
        "pre": {
            "sdev": "!=null",
            "ipc": "!=null",
            "msg": "!=null",
            "ops": "!=null"
        }
    }
},
S,
{
    "kretprobe:snd_sof_ipc_free": {
        "description": "Free the snd_sof_ipc structure associated with the given snd_sof_dev.",
        "pre": {
            "sdev": "!=null",
            "ipc": "!=null",
            "ipc.disable_ipc_tx": "true",
            "ipc.ops.exit": "!=null"
        }
    }
},
S,
S,
{
    "kprobe:if (--swidget->use_count)return 0;pipe_widget = swidget->spipe->pipe_widget;/* reset route setup status for all routes that contain this widget `": {
        "description": "Free the sof_widget_unlocked structure if the use_count is 0.",
        "pre": {
            "swidget": {
                "use_count": "==0"
            }
        }
    }
},
S,
{
    "kprobe:if (!swidget->private)return 0;trace_sof_widget_setup(swidget);/* widget already set up `": {
        "description": "Condition for the given function",
        "pre": {
            "swidget": "!=null",
            "swidget->private": "==true"
        }
    }
},
{
    "kretprobe:snd_sof_dsp_only_d0i3_compatible_stream_active": {
        "description": "Check if the stream is D0i3 compatible and active.",
        "pre": {
            "sdev": "!=null",
            "spcm": "!=null",
            "dir": "in [0, 1, 2, 3]",
            "substream": "!=null",
            "substream->runtime": "!=null"
        }
    }
},
{
    "kprobe:snd_sof_dsp_only_d0i3_compatible_stream_active": {
        "description": "Check if the stream is D0i3 compatible and active.",
        "pre": {
            "sdev": "!=null",
            "spcm": "!=null",
            "d0i3_compatible_active": "bool",
            "dir": "in [0, 1, 2, 3]",
            "substream": "!=null",
            "substream->runtime": "!=null"
        }
    }
},
S,
{
    "kprobe:snd_sof_machine_select": {
        "description": "Select the sound Open Firmware machine for the given device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:platform_device_register_data": {
        "description": "Register a platform device with additional data.",
        "pre": {
            "sdev->dev": "!=null",
            "drv_name": "!=null",
            "mach": "!=null",
            "size": ">=0"
        },
        "post": {
            "plat_data->pdev_mach": "!=null"
        }
    },
    "kretprobe:IS_ERR": {
        "description": "Check if the return value is an error.",
        "pre": {
            "plat_data->pdev_mach": "!=null"
        },
        "post": {
            "return value": "is an error"
        }
    },
    "kretprobe:PTR_ERR": {
        "description": "Get the error code from the return value.",
        "pre": {
            "plat_data->pdev_mach": "!=null"
        },
        "post": {
            "return value": "error code"
        }
    },
    "kretprobe:dev_dbg": {
        "description": "Print debug message.",
        "pre": {
            "sdev->dev": "!=null",
            "plat_data->pdev_mach": "!=null"
        },
        "post": {
            "debug message": "printed"
        }
    }
},
{
    "kprobe:plat_data->pdev_mach = platform_device_register_data": {
        "description": "Register a machine driver and pass machine info as pdata.",
        "pre": {
            "sdev": "!=null",
            "pdata": "!=null",
            "plat_data": "!=null",
            "plat_data->machine": "!=null",
            "plat_data->machine->drv_name": "!=null",
            "plat_data->machine->drv_name": "is a string",
            "plat_data->machine": "!=null",
            "sizeof(plat_data->machine)": ">0"
        }
    }
},
{
    "kretprobe:snd_sof_pcm_period_elapsed": {
        "description": "This function is called when a PCM period has elapsed.",
        "pre": {
            "substream": "!=null"
        }
    }
},
S,
{
    "kretprobe:if (!dai)": {
        "description": "Check if `dai` is null.",
        "pre": {
            "dai": "==null"
        }
    }
},
{
    "kprobe:if (!dai)": {
        "description": "Check if the variable 'dai' is null.",
        "pre": {
            "dai": "==null"
        }
    }
},
S,
{
    "kprobe:sof_ipc_msg_data": {
        "description": "Handle IPC message data in the SOF driver.",
        "pre": {
            "sps": "!=null",
            "sdev->stream_box.size": "!=null",
            "p": "!=null",
            "sz": "!=null"
        }
    }
},
{
    "kretprobe:if (posn_offset > sdev->stream_box.size || posn_offset % sizeof(struct sof_ipc_stream_posn) != 0)": {
        "description": "Check if offset is overflow or it is not aligned.",
        "pre": {
            "posn_offset": "> sdev->stream_box.size || posn_offset % sizeof(struct sof_ipc_stream_posn) != 0",
            "sdev": "!= null",
            "sps": "!= null"
        }
    }
},
{
    "kprobe:if (posn_offset > sdev->stream_box.size || posn_offset % sizeof(struct sof_ipc_stream_posn) != 0) return -EINVAL; posn_offset += sdev->stream_box.offset; if (sps->substream)": {
        "description": "Check if offset is overflow or it is not aligned.",
        "pre": {
            "posn_offset": "> sdev->stream_box.size || posn_offset % sizeof(struct sof_ipc_stream_posn) != 0",
            "sdev": "!= null",
            "sps": "!= null"
        }
    }
},
{
    "kretprobe:sof_stream_pcm_open": {
        "description": "Binding pcm substream to hda stream",
        "pre": {
            "sdev": "!=null",
            "substream": "!=null",
            "stream": "!=null"
        }
    }
},
S,
{
    "kretprobe:mtk_adsp_dump": {
        "description": "This function is called when a panic message is received from the firmware.",
        "pre": {
            "sdev": "!=null",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:mtk_adsp_dump": {
        "description": "This function is called when a panic message is received from the firmware.",
        "pre": {
            "sdev": "!=null",
            "flags": "any"
        }
    }
},
{
    "kretprobe:imx8_dump": {
        "description": "This function is called when a panic message is received from the firmware.",
        "pre": {
            "sdev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:imx8_dump": {
        "description": "This function is called when a panic message is received from the firmware.",
        "pre": {
            "sdev": "!=null",
            "flags": "any"
        }
    }
},
{
    "kretprobe:hda_to_sdw": {
        "description": "Handle the special case when verb is 0x7ff.",
        "pre": {
            "nid": "!=null",
            "verb": "==0x7ff",
            "payload": "!=null",
            "sdw_addr_h": "!=null",
            "sdw_data_h": "!=null",
            "sdw_addr_l": "!=null",
            "sdw_data_l": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:clk_get_rate": {
        "description": "Get the rate of the clock",
        "pre": {
            "adau1372": "!=null",
            "adau1372->mclk": "!=null",
            "adau1372->mclk": "==12.288MHz"
        }
    }
},
{
    "kprobe:clk_get_rate": {
        "description": "Get the rate of the clock specified by *mclk*.",
        "pre": {
            "mclk": "!=null"
        }
    },
    "kprobe:switch": {
        "description": "Switch based on the value of *rate*.",
        "pre": {
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:aic3x_probe": {
        "description": "Probe function for aic3x",
        "pre": {
            "dev": "!=null",
            "regmap": "!=null",
            "driver_data": "!=null",
            "aic3x": "!=null",
            "aic3x->regmap": "!=null",
            "np": "!=null",
            "ret": "int",
            "i": "int",
            "value": "u32",
            "aic3x->setup": "!=null when of_property_read_u32_array(np, \"ai3x-gpio-func\", ai3x_setup->gpio_func, 2) >= 0",
            "aic3x->micbias_vg": "in [AIC3X_MICBIAS_2_0V, AIC3X_MICBIAS_2_5V, AIC3X_MICBIAS_AVDDV, AIC3X_MICBIAS_OFF] when !of_property_read_u32(np, \"ai3x-micbias-vg\", &value)",
            "dev_err(dev, \"Unsuitable MicBias voltage \"\"found in DT\\n\")": "void",
            "aic3x->gpio_reset": "!=null",
            "ret != -EBUSY": "bool"
        }
    }
},
{
    "kprobe:aic3x_probe": {
        "description": "Probe function for aic3x",
        "pre": {
            "dev": "!=null",
            "regmap": "!=null",
            "driver_data": "!=null",
            "aic3x": "!=null",
            "aic3x->regmap": "!=null",
            "np": "optional",
            "ret": "optional",
            "i": "optional",
            "value": "optional",
            "ai3x_setup": "optional",
            "ai3x_setup->gpio_func": "optional",
            "aic3x->setup": "optional",
            "aic3x->micbias_vg": "optional",
            "dev->of_node": "optional",
            "aic3x->gpio_reset": "optional",
            "ret != -EBUSY": "optional"
        }
    }
},
S,
S,
{
    "kretprobe:wsa_macro_set_spkr_mode": {
        "description": "Configures speaker compander and smartboost settings based on speaker mode.",
        "pre": {
            "component": "!=null",
            "mode": "is an integer",
            "mode >= 0",
            "mode <= 3"
        },
        "post": {
            "return_value": "is an integer",
            "return_value == 0 or return_value == -EINVAL"
        }
    }
},
{
    "kprobe:wsa_macro_set_spkr_mode": {
        "description": "Configures speaker compander and smartboost settings based on speaker mode.",
        "pre": {
            "component": "!=null",
            "mode": "!=null",
            "mode": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
S,
{
    "kprobe:regmap_update_bits": {
        "description": "Update bits in a register map.",
        "pre": {
            "regmap": "!=null",
            "reg": "PCM3060_REG64",
            "mask": "PCM3060_REG_MRST",
            "val": "0"
        }
    }
},
S,
S,
{
    "kretprobe:dmasound_init": {
        "description": "Set up sound queue, devaudio, and devdsp.",
        "pre": {
            "res": "!=null",
            "irq_installed": "==0"
        }
    }
},
{
    "kprobe:/* Set default settings. */": {
        "description": "Set default settings for sound queue, devaudio, and devdsp.",
        "pre": {
            "res": "int",
            "irq_installed": "==0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:module_param": {
        "description": "Set the value of a module parameter.",
        "pre": {
            "param_name": "in ['writeBufSize', 'dmasound_catchRadius', 'numWriteBufs']",
            "param_type": "=='int'",
            "param_value": "!=null"
        }
    },
    "kretprobe:MODULE_LICENSE": {
        "description": "Set the license of the module.",
        "pre": {
            "license": "=='GPL'"
        }
    },
    "kretprobe:static int sq_unit": {
        "description": "Set the value of the static variable sq_unit.",
        "pre": {
            "sq_unit": "==-1"
        }
    },
    "kretprobe:static int mixer_unit": {
        "description": "Set the value of the static variable mixer_unit.",
        "pre": {
            "mixer_unit": "==-1"
        }
    },
    "kretprobe:static int state_unit": {
        "description": "Set the value of the static variable state_unit.",
        "pre": {
            "state_unit": "==-1"
        }
    },
    "kretprobe:static int irq_installed": {
        "description": "Set the value of the static variable irq_installed."
    }
},
S,
S,
S,
{
    "kretprobe:dmasound_alaw2dma8": {
        "description": "Array of values for dmasound_alaw2dma8",
        "pre": {
            "dmasound_alaw2dma8": "!=null",
            "dmasound_alaw2dma8[]": "in [-22,-21,-24,-23,-18,-17,-20,-19,-30,-29,-32,-31,-26,-25,-28,-27,-11,-11,-12,-12,-9,-9,-10,-10,-15,-15,-16,-16,-13,-13,-14,-14,-86,-82,-94,-90,-70,-66,-78,-74,-118,-114,-126,-122,-102,-98,-110,-106,-43,-41,-47,-45,-35,-33,-39,-37,-59,-57,-63,-61,-51,-49,-55,-53,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-6,-6,-6,-6,-5,-5,-5,-5,-8,-8,-8,-8,-7,-7,-7,-7,-3,-3,-3,-3,-3,-3,-3,-3,-4,-4,-4,-4,-4,-4,-4,-4,21,20,23,22,17,16,19,18,29,28,31,30,25,24,27,26,10,10,11,11,8,8,9,9,14,14,15,15,12,12,13,13,86,82,94,90,70,66,78,74,118,114,126,122,102,98,110,106,43,41,47,45,35,33,39,37,59,57,63,61,51,49,55,53,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,4,4,4,4,7,7,7,7,6,6,6,6,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3]"
        }
    }
},
S,
S,
S,
{
    "kretprobe:snd_tea6330t_update_mixer": {
        "description": "Update the mixer settings for TEA6330T.",
        "pre": {
            "card": "!=null",
            "bus": "!=null",
            "equalizer": "is an integer",
            "fader": "is an integer"
        }
    }
},
{
    "kprobe:snd_tea6330t_update_mixer": {
        "description": "Update the mixer settings for TEA6330T.",
        "pre": {
            "equalizer": "!=null",
            "fader": "!=null",
            "tea->regs[TEA6330T_SADDR_FADER]": "==0x3f",
            "tea->regs[TEA6330T_SADDR_AUDIO_SWITCH]": "equalizer ? ==0 : ==TEA6330T_EQN"
        }
    }
},
{
    "kretprobe:snd_ak4114_reinit": {
        "description": "Reinitialize the ak4114 chip",
        "pre": {
            "chip": "!=null",
            "atomic_inc_return(&chip->wq_processing)": "== 1",
            "cancel_delayed_work_sync(&chip->work)": "void",
            "mutex_lock(&chip->reinit_mutex)": "void",
            "ak4114_init_regs(chip)": "void",
            "mutex_unlock(&chip->reinit_mutex)": "void"
        }
    }
},
{
    "kprobe:snd_ak4114_reinit": {
        "description": "Reinitialize the snd_ak4114 chip",
        "pre": {
            "chip": "!=null",
            "chip->wq_processing": "==0",
            "chip->work": "!=null",
            "chip->reinit_mutex": "not held"
        }
    }
},
{
    "kretprobe:snd_ak4114_build": {
        "description": "Builds the snd_ak4114 structure and initializes its controls.",
        "pre": {
            "ak4114": "!=null",
            "ply_substream": "!=null",
            "cap_substream": "!=null"
        }
    }
},
{
    "kprobe:snd_ak4114_build": {
        "description": "Builds the snd_ak4114 structure and initializes its controls.",
        "pre": {
            "ak4114": "!=null",
            "ply_substream": "!=null",
            "cap_substream": "!=null"
        }
    }
},
{
    "kretprobe:external_rate": {
        "description": "Check the rate and errors for the ak4114 device.",
        "pre": {
            "ak4114": "!=null",
            "flags": "!=null",
            "runtime": "!=null",
            "runtime->rate": "!=res"
        }
    }
},
{
    "kprobe:external_rate": {
        "description": "Calculate the rate for the external device.",
        "pre": {
            "rcs1": "!=null",
            "flags": "!=null",
            "ak4114": "!=null",
            "ak4114->capture_substream": "!=null",
            "ak4114->capture_substream->runtime": "!=null",
            "runtime": "!=null",
            "runtime->rate": "!=null",
            "res": "!=null",
            "flags & AK4114_CHECK_NO_RATE": "!=0",
            "!(flags & AK4114_CHECK_NO_RATE)": "!=0",
            "runtime->rate != res": "!=0"
        }
    }
},
{
    "kretprobe:snd_ak4114_suspend": {
        "description": "Suspend function for snd_ak4114",
        "pre": {
            "chip": "!=null",
            "chip->wq_processing": "==chip->wq_processing+1",
            "no_new_work_scheduled": "true"
        }
    }
},
{
    "kprobe:snd_ak4114_suspend": {
        "description": "Suspend the ak4114 chip",
        "pre": {
            "chip": "!=null",
            "chip->wq_processing": "==0"
        }
    }
},
{
    "kretprobe:snd_pt2258_reset": {
        "description": "Reset the PT2258 chip.",
        "pre": {
            "pt": "!=null",
            "bytes": "!=null",
            "bytes[0]": "= PT2258_CMD_RESET",
            "i": ">= 0",
            "i": "< 2",
            "snd_i2c_lock(pt->i2c_bus)": "called",
            "snd_i2c_sendbytes(pt->i2c_dev, bytes, 1)": "== 1",
            "snd_i2c_unlock(pt->i2c_bus)": "called"
        }
    }
},
S,
{
    "kretprobe:snd_akm4xxx_set": {
        "description": "Set the value of a register in the AKM4xxx chip.",
        "pre": {
            "ak": "!=null",
            "chip": "is an integer",
            "reg": "is an unsigned char",
            "val": "is an unsigned char"
        },
        "post": {
            "ak->ops.lock": {
                "pre": {
                    "ak": "!=null",
                    "chip": "is an integer"
                }
            },
            "ak->ops.write": {
                "pre": {
                    "ak": "!=null",
                    "chip": "is an integer",
                    "reg": "is an unsigned char",
                    "val": "is an unsigned char"
                }
            }
        }
    }
},
{
    "kprobe:snd_akm4xxx_set": {
        "description": "Write a value to a register in the AKM4xxx chip.",
        "pre": {
            "ak": "!=null",
            "chip": "int",
            "reg": "unsigned char",
            "val": "unsigned char"
        }
    }
},
{
    "kretprobe:snd_akm4xxx_reset": {
        "description": "Reset the AKM4xxx device.",
        "pre": {
            "ak": "!=null",
            "state": "int"
        },
        "post": {
            "ak->type": "in [SND_AK4524, SND_AK4528, SND_AK4620, SND_AK4529]",
            "ak4524_reset(ak, state)": "called when ak->type is SND_AK4524, SND_AK4528, or SND_AK4620",
            "FIXME: needed for ak4529?": "called when ak->type is SND_AK4529"
        }
    }
},
{
    "kprobe:snd_akm4xxx_reset": {
        "description": "Reset the AKM4xxx device.",
        "pre": {
            "ak": "!=null",
            "state": "int"
        }
    }
},
S,
S,
{
    "kretprobe:snd_ak4113_suspend": {
        "description": "Cancel delayed work and prevent scheduling new work in snd_ak4113_suspend",
        "pre": {
            "chip": "!=null",
            "chip->wq_processing": "==chip->wq_processing+1",
            "no_new_work_scheduled": "true"
        }
    }
},
{
    "kprobe:snd_ak4113_suspend": {
        "description": "Suspend the ak4113 chip",
        "pre": {
            "chip": "!=null",
            "chip->wq_processing": "==0"
        }
    }
},
{
    "kretprobe:reg_write": {
        "description": "Write a value to a register in the AK4117 chip.",
        "pre": {
            "chip": "!=null",
            "reg": ">=0",
            "mask": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:reg_write": {
        "description": "Write a value to a register in the AK4117 chip.",
        "pre": {
            "chip": "!=null",
            "AK4117_REG_PWRDN": "==0"
        }
    }
},
{
    "kretprobe:snd_ak4117_check_rate_and_errors": {
        "description": "Rate change",
        "pre": {
            "c1": "& 0x0f",
            "c1": "& AK4117_PEM",
            "c0": "& AK4117_CINT",
            "c0": "& AK4117_QINT",
            "c0": "& AK4117_AUDION",
            "c1": "& AK4117_NPCM",
            "c1": "& AK4117_DTSCD",
            "ak4117->change_callback": "!= null",
            "(c0 | c1)": "!= 0"
        },
        "actions": [
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[4]->id)",
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[6]->id)",
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[8]->id)",
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[9]->id)",
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[10]->id)",
            "snd_ctl_notify(ak4117->card, SNDRV_CTL_EVENT_MASK_VALUE, &ak4117->kctls[11]->id)",
            "ak4117->change_callback(ak4117, c0, c1)"
        ]
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:_snd_ctl_add_follower": {
        "description": "Add a follower to a control",
        "pre": {
            "follower->info": "follower_info",
            "follower->get": "follower_get",
            "follower->put": "follower_put",
            "follower->vd[0].access": "& SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK",
            "follower->tlv.c": "follower_tlv_cmd",
            "follower->private_data": "srec",
            "follower->private_free": "follower_free",
            "list_add_tail(&srec->list, &master_link->followers)": "true"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:_snd_ctl_add_follower": {
        "description": "Add a follower to a control master.",
        "pre": {
            "master": "!=null",
            "follower": "!=null",
            "flags": "unsigned int",
            "master_link": "!=null",
            "srec": "!=null",
            "srec->kctl": "follower",
            "srec->follower": "follower",
            "srec->follower.vd": "follower->vd",
            "srec->master": "master_link",
            "srec->flags": "flags"
        }
    }
},
{
    "kretprobe:snd_ctl_make_virtual_master": {
        "description": "Create a virtual master control",
        "pre": {
            "name": "!=null",
            "tlv": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_make_virtual_master": {
        "description": "Create a virtual master control",
        "pre": {
            "name": "!=null",
            "tlv": "!=null"
        }
    }
},
{
    "kretprobe:copy_to_user_fromio": {
        "description": "Copy data from mmio-space to user-space.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:copy_to_user_fromio": {
        "description": "Copy data from mmio-space to user-space.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:copy_from_user_toio": {
        "description": "Copy data from user-space to mmio-space.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:copy_from_user_toio": {
        "description": "Copy data from user-space to mmio-space.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_set_ops": {
        "description": "Set the PCM operators",
        "pre": {
            "pcm": "!=null",
            "direction": "in [SNDRV_PCM_STREAM_PLAYBACK, SNDRV_PCM_STREAM_CAPTURE]",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_set_ops": {
        "description": "Set the PCM operators",
        "pre": {
            "pcm": "!=null",
            "direction": "in [SNDRV_PCM_STREAM_PLAYBACK, SNDRV_PCM_STREAM_CAPTURE]",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_set_sync": {
        "description": "Set the PCM sync identifier for the card.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_set_sync": {
        "description": "Set the PCM sync identifier for the card.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:snd_interval_refine": {
        "description": "Refine the interval value of configurator",
        "pre": {
            "i": "!=null",
            "v": "!=null"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kprobe:snd_interval_refine": {
        "description": "Refine the interval value of configurator",
        "pre": {
            "i": "!=null",
            "v": "!=null"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kretprobe:snd_interval_ratnum": {
        "description": "Refine the interval value",
        "pre": {
            "i": "!=null",
            "rats_count": ">=0",
            "rats": "!=null",
            "nump": "!=null",
            "denp": "!=null"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kprobe:snd_interval_ratnum": {
        "description": "Refine the interval value",
        "pre": {
            "i": "!=null",
            "rats_count": ">=0",
            "rats": "!=null",
            "nump": "!=null",
            "denp": "!=null"
        }
    }
},
{
    "kretprobe:snd_interval_list": {
        "description": "Refines the interval value from the list.",
        "pre": {
            "i": "!=null",
            "count": ">=0",
            "list": "!=null",
            "mask": ">=0"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kprobe:snd_interval_list": {
        "description": "Refine the interval value from the list.",
        "pre": {
            "i": "!=null",
            "count": ">=0",
            "list": "!=null",
            "mask": ">=0"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kretprobe:snd_interval_ranges": {
        "description": "Refine the interval value from the list of ranges.",
        "pre": {
            "i": "!=null",
            "count": ">=0",
            "ranges": "!=null",
            "mask": ">=0"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kprobe:snd_interval_ranges": {
        "description": "Refine the interval value from the list of ranges.",
        "pre": {
            "i": "!=null",
            "count": ">=0",
            "ranges": "!=null",
            "mask": ">=0"
        },
        "post": {
            "return": "in [positive, zero, negative]"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_rule_add": {
        "description": "Add the hw-constraint rule",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "func": "!=null",
            "private": "!=null",
            "dep": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_hw_rule_add": {
        "description": "Add the hw-constraint rule",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "func": "!=null",
            "private": "!=null",
            "dep": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_mask64": {
        "description": "Apply the given bitmap mask constraint",
        "pre": {
            "runtime": "!=null",
            "var": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_mask64": {
        "description": "Apply the given bitmap mask constraint",
        "pre": {
            "runtime": "!=null",
            "var": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_integer": {
        "description": "Apply an integer constraint to an interval",
        "pre": {
            "runtime": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_integer": {
        "description": "Apply an integer constraint to an interval.",
        "pre": {
            "runtime": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_minmax": {
        "description": "Apply a minmax range constraint to an interval parameter.",
        "pre": {
            "runtime": "!=null",
            "var": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_minmax": {
        "description": "Apply a minmax range constraint to an interval parameter.",
        "pre": {
            "runtime": "!=null",
            "var": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_list": {
        "description": "Apply a list of constraints to a parameter.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "l": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_list": {
        "description": "Apply a list of constraints to a parameter.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "l": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_ranges": {
        "description": "Apply list of range constraints to a parameter",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_ranges": {
        "description": "Apply list of range constraints to a parameter",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_ratnums": {
        "description": "Apply ratnums constraint to a parameter",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_ratnums": {
        "description": "Apply ratnums constraint to a parameter.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_ratdens": {
        "description": "Apply ratdens constraint to a parameter",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_ratdens": {
        "description": "Apply ratdens constraint to a parameter",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "r": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_msbits": {
        "description": "Add a hw constraint msbits rule",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "width": "!=null",
            "msbits": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_msbits": {
        "description": "Add a hw constraint msbits rule",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "width": "!=null",
            "msbits": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_step": {
        "description": "Add a hardware constraint step rule.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "step": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_step": {
        "description": "Add a hardware constraint step rule.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null",
            "step": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_constraint_pow2": {
        "description": "Add a hardware constraint power-of-2 rule.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_constraint_pow2": {
        "description": "Add a hardware constraint power-of-2 rule.",
        "pre": {
            "runtime": "!=null",
            "cond": "!=null",
            "var": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_rule_noresample": {
        "description": "Add a rule to allow disabling hardware resampling.",
        "pre": {
            "runtime": "!=null",
            "base_rate": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_hw_rule_noresample_func": {
        "description": "Add a rule to allow disabling hardware resampling.",
        "pre": {
            "params": "!=null",
            "rule": "!=null"
        },
        "post": {
            "return": "is_int"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_param_value": {
        "description": "Return the value of the specified parameter in the hw_params instance.",
        "pre": {
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        },
        "post": {
            "return": "in [-EINVAL, value of var if fixed in configuration space]"
        }
    }
},
{
    "kprobe:snd_pcm_hw_param_value": {
        "description": "Return the value of the specified parameter in the hardware configuration space.",
        "pre": {
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_param_first": {
        "description": "Refine config space and return the minimum value.",
        "pre": {
            "pcm": "!=null",
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        },
        "post": {
            "return": ">= -EINVAL"
        }
    }
},
{
    "kprobe:snd_pcm_hw_param_first": {
        "description": "Refine config space and return the minimum value.",
        "pre": {
            "pcm": "!=null",
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_param_last": {
        "description": "Refine config space and return maximum value",
        "pre": {
            "pcm": "!=null",
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        },
        "post": {
            "return": ">= -EINVAL"
        }
    }
},
{
    "kprobe:snd_pcm_hw_param_last": {
        "description": "Refine config space and return maximum value.",
        "pre": {
            "pcm": "!=null",
            "params": "!=null",
            "var": "!=null",
            "dir": "in [-1, 0, 1, null]"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_ioctl": {
        "description": "A generic PCM ioctl callback",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_lib_ioctl": {
        "description": "A generic PCM ioctl callback.",
        "pre": {
            "substream": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_period_elapsed_under_stream_lock": {
        "description": "Update the status of runtime for the next period under acquired lock of PCM substream.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_period_elapsed_under_stream_lock": {
        "description": "Update the status of runtime for the next period under acquired lock of PCM substream.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:__snd_pcm_lib_xfer": {
        "description": "Transfer data from/to a PCM substream.",
        "pre": {
            "is_playback": "==false",
            "runtime->state": "==SNDRV_PCM_STATE_PREPARED",
            "size": ">=runtime->start_threshold"
        }
    }
},
{
    "kprobe:__snd_pcm_lib_xfer": {
        "description": "Transfer data from/to a PCM substream.",
        "pre": {
            "is_playback": "false",
            "runtime->state": "SNDRV_PCM_STATE_PREPARED",
            "size": ">= runtime->start_threshold"
        }
    }
},
{
    "kretprobe:snd_card_new": {
        "description": "Create and initialize a soundcard structure",
        "pre": {
            "parent": "!=null",
            "idx": ">=0 && <=(SNDRV_CARDS-1)",
            "xid": "!=null",
            "module": "!=null",
            "extra_size": ">=0",
            "card_ret": "!=null"
        }
    }
},
{
    "kprobe:snd_card_new": {
        "description": "Create and initialize a soundcard structure",
        "pre": {
            "parent": "!=null",
            "idx": ">=0 && <=(SNDRV_CARDS-1)",
            "xid": "!=null",
            "module": "!=null",
            "extra_size": ">=0",
            "card_ret": "!=null"
        }
    }
},
{
    "kretprobe:snd_card_disconnect": {
        "description": "Disconnects all APIs from the file-operations (user space).",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return": "in [0, <negative error code>]"
        }
    }
},
{
    "kprobe:snd_card_disconnect": {
        "description": "Disconnects all APIs from the file-operations (user space).",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:snd_card_free_when_closed": {
        "description": "Disconnect the card, free it later eventually",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kprobe:snd_card_free_when_closed": {
        "description": "Disconnect the card, free it later eventually",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:snd_devm_card_new": {
        "description": "Create a new sound card device.",
        "pre": {
            "parent": "!=null",
            "idx": "int",
            "xid": "!=null",
            "module": "!=null",
            "extra_size": "size_t",
            "card_ret": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:snd_devm_card_new": {
        "description": "Create a new sound card device.",
        "pre": {
            "parent": "!=null",
            "idx": "int",
            "xid": "!=null",
            "module": "!=null",
            "extra_size": "size_t",
            "card_ret": "!=null"
        }
    }
},
{
    "kretprobe:snd_card_set_id_no_lock": {
        "description": "Set the ID of the sound card",
        "pre": {
            "card": "!=null",
            "src": "!=null",
            "nid": "!=null",
            "id": "!=null",
            "id[0]": "==null",
            "strncmp(id, \"card\", 4)": "==0"
        }
    }
},
{
    "kprobe:your_function_name": {
        "description": "Description of your function",
        "pre": {
            "*id": "==null || strncmp(*id, \"card\", 4) == 0"
        }
    }
},
{
    "kretprobe:snd_component_add": {
        "description": "Add a component string to the supported list.",
        "pre": {
            "card": "!=null",
            "component": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_component_add": {
        "description": "Add a component string to the supported list.",
        "pre": {
            "card": "!=null",
            "component": "!=null"
        }
    }
},
{
    "kretprobe:snd_card_file_add": {
        "description": "Add the file to the file list of the card.",
        "pre": {
            "card": "!=null",
            "file": "!=null"
        },
        "post": {
            "return_value": "<=0"
        }
    }
},
{
    "kprobe:snd_card_file_add": {
        "description": "Add the file to the file list of the card.",
        "pre": {
            "card": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kretprobe:snd_card_file_remove": {
        "description": "Remove the file from the file list",
        "pre": {
            "card": "!=null",
            "file": "!=null"
        },
        "post": {
            "return": "<=0"
        }
    }
},
{
    "kprobe:snd_card_file_remove": {
        "description": "Remove the file from the file list",
        "pre": {
            "card": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kretprobe:snd_power_wait": {
        "description": "Wait until the card gets powered up to SNDRV_CTL_POWER_D0 state.",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return_value": "in [0, -MAX_ERRNO]"
        }
    }
},
{
    "kprobe:snd_power_wait": {
        "description": "Wait until the card gets powered up to SNDRV_CTL_POWER_D0 state.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:snd_hwdep_new": {
        "description": "Create a new hwdep instance",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "device": "int",
            "rhwdep": "!=null"
        },
        "post": {
            "return": "int",
            "return >= 0"
        }
    }
},
{
    "kprobe:snd_hwdep_new": {
        "description": "Create a new hwdep instance",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "device": "int",
            "rhwdep": "!=null"
        }
    }
},
{
    "kretprobe:snd_dma_program": {
        "description": "Program an ISA DMA transfer",
        "pre": {
            "dma": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "mode": "in [DMA_MODE_XXX]"
        }
    }
},
{
    "kprobe:snd_dma_program": {
        "description": "Program an ISA DMA transfer",
        "pre": {
            "dma": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "mode": "in [DMA_MODE_XXX]"
        }
    }
},
{
    "kretprobe:snd_dma_disable": {
        "description": "Stop the ISA DMA transfer",
        "pre": {
            "dma": "!=null"
        }
    }
},
{
    "kprobe:snd_dma_disable": {
        "description": "Stop the ISA DMA transfer.",
        "pre": {
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:snd_dma_pointer": {
        "description": "Return the current pointer to DMA transfer buffer in bytes.",
        "pre": {
            "dma": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:snd_dma_pointer": {
        "description": "Return the current pointer to DMA transfer buffer in bytes.",
        "pre": {
            "dma": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:snd_info_get_line": {
        "description": "Read one line from the procfs buffer",
        "pre": {
            "buffer": "!=null",
            "line": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:snd_info_get_line": {
        "description": "Read one line from the procfs buffer",
        "pre": {
            "buffer": "!=null",
            "line": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:snd_info_get_str": {
        "description": "Parse a string token",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:snd_info_get_str": {
        "description": "Parse a string token",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:snd_info_card_create": {
        "description": "Create a card proc file",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:snd_info_card_create": {
        "description": "Create a card proc file.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:snd_info_create_entry": {
        "description": "Create a new instance of snd_info_entry.",
        "pre": {
            "name": "!= null",
            "parent": "!= null",
            "module": "!= null"
        }
    }
},
{
    "kprobe:snd_info_create_entry": {
        "description": "Create a new instance of snd_info_entry with the given name, parent, and module.",
        "pre": {
            "name": "!=null",
            "parent": "!=null",
            "module": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:snd_pci_quirk_lookup_id": {
        "description": "Look up a PCI SSID quirk list",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:snd_pci_quirk_lookup_id": {
        "description": "Look up a PCI SSID quirk list",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:queue_autoload_drivers": {
        "description": "Initialize the autoload for the snd-seq module.",
        "pre": {
            "snd_seq_in_init": "== 0",
            "CONFIG_SND_SEQUENCER_MODULE": "== 1"
        }
    }
},
{
    "kprobe:queue_autoload_drivers": {
        "description": "Initialize the autoload for the snd-seq module.",
        "pre": {
            "snd_seq_in_init": "== 1",
            "CONFIG_SND_SEQUENCER_MODULE": "== 1"
        }
    }
},
{
    "kretprobe:snd_seq_device_new": {
        "description": "Create a new sequencer device entry",
        "pre": {
            "driver": "!=null",
            "id": "!=null",
            "snd_seq_device": "!=null"
        }
    }
},
{
    "snd_seq_device_new": {
        "description": "Create a new entry pointer for communicating with the sequencer device driver.",
        "pre": {
            "id": "!=null",
            "driver_loaded": "required",
            "hardware_resources": "passed"
        }
    }
},
{
    "kretprobe:if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE || tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER)": {
        "description": "Condition for the if statement in the given function",
        "pre": {
            "tid->dev_sclass": "<= SNDRV_TIMER_SCLASS_NONE || > SNDRV_TIMER_SCLASS_OSS_SEQUENCER"
        }
    }
},
{
    "kprobe:if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE || tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER)": {
        "description": "Condition for the given if statement",
        "pre": {
            "tid->dev_sclass": "<= SNDRV_TIMER_SCLASS_NONE || > SNDRV_TIMER_SCLASS_OSS_SEQUENCER"
        }
    }
},
{
    "kretprobe:snd_timer_open": {
        "description": "Open a timer instance. When opening a master, the slave id must be provided.",
        "pre": {
            "timeri": "!=null",
            "tid": "!=null",
            "slave_id": "!=null"
        }
    }
},
{
    "kprobe:snd_timer_open": {
        "description": "Open a timer instance.",
        "pre": {
            "timeri": "!=null",
            "tid": "!=null",
            "slave_id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:spin_lock_irq": {
        "description": "Acquire the spinlock associated with the timer's lock.",
        "pre": {
            "lock": "!=null",
            "timer": "!=null",
            "timer->flags": "& SNDRV_TIMER_IFLG_CALLBACK != 0"
        }
    },
    "kretprobe:wait": {
        "description": "Wait until the active callback is finished.",
        "pre": {
            "timer": "!=null"
        }
    }
},
{
    "kprobe:spin_lock_irq": {
        "description": "Acquire the spinlock associated with the given timer's lock.",
        "pre": {
            "lock": "!=null",
            "timer": "!=null",
            "timer->flags": "& SNDRV_TIMER_IFLG_CALLBACK"
        }
    },
    "kprobe:while": {
        "description": "Loop while the flags of the given timer have the SNDRV_TIMER_IFLG_CALLBACK bit set.",
        "pre": {
            "timeri->flags": "& SNDRV_TIMER_IFLG_CALLBACK"
        }
    }
},
S,
{
    "kprobe:snd_timer_continue": {
        "description": "Continues the timer only after it has been paused.",
        "pre": {
            "timeri.flags": "& SNDRV_TIMER_IFLG_PAUSED != 0"
        }
    }
},
{
    "kretprobe:resolution": {
        "description": "Get the hardware resolution of the timer.",
        "pre": {
            "timer": "!=null",
            "ticks_left": "unsigned long",
            "ti": "struct snd_timer_instance",
            "ts": "struct snd_timer_instance",
            "tmp": "struct snd_timer_instance",
            "resolution": "unsigned long",
            "ack_list_head": "struct list_head",
            "flags": "unsigned long",
            "use_work": "bool"
        }
    }
},
S,
{
    "kretprobe:if (card != NULL)": {
        "description": "Check if the 'card' variable is not equal to NULL.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kprobe:if (card != NULL)": {
        "description": "Check if the variable 'card' is not equal to NULL.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:list_for_each_entry": {
        "description": "Start/continue a master timer",
        "pre": {
            "ts": "!=null",
            "&ti->slave_active_head": "!=null",
            "active_list": "!=null",
            "ts->ccallback": "!=null",
            "event": "in [SNDRV_TIMER_EVENT_START, SNDRV_TIMER_EVENT_CONTINUE]",
            "&tstamp": "!=null",
            "resolution": ">=0"
        }
    }
},
{
    "kprobe:list_for_each_entry": {
        "description": "Start/continue a master timer",
        "pre": {
            "ts": "!=null",
            "event": ">= SNDRV_TIMER_EVENT_START && <= SNDRV_TIMER_EVENT_PAUSE",
            "tstamp": "!=null",
            "resolution": ">= 0"
        }
    }
},
{
    "kretprobe:snd_compr_free_pages": {
        "description": "Free pages used by the sound compression stream.",
        "pre": {
            "stream": "!=null",
            "stream->runtime": "!=null",
            "runtime": "!=null",
            "runtime->dma_area": "==null",
            "runtime->dma_buffer_p": "!=&stream->dma_buffer"
        }
    }
},
{
    "kprobe:snd_compr_free_pages": {
        "description": "Free pages used by the sound compression stream.",
        "pre": {
            "stream": "!=null",
            "stream->runtime": "!=null",
            "stream->runtime->dma_area": "==null",
            "stream->runtime->dma_buffer_p": "!=&stream->dma_buffer"
        }
    }
},
{
    "kretprobe:snd_dma_alloc_dir_pages": {
        "description": "Allocate the buffer area according to the given type and direction.",
        "pre": {
            "type": "!=null",
            "device": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]",
            "size": ">=0",
            "dmab": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ENOMEM, ...]"
        }
    }
},
{
    "kprobe:snd_dma_alloc_dir_pages": {
        "description": "Allocate the buffer area according to the given type and direction.",
        "pre": {
            "type": "!=null",
            "device": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE, DMA_BIDIRECTIONAL]",
            "size": ">=0",
            "dmab": "!=null"
        },
        "post": {
            "return": "in [0, negative value]"
        }
    }
},
{
    "kretprobe:snd_dma_alloc_pages_fallback": {
        "description": "Allocate the buffer area according to the given type with fallback.",
        "pre": {
            "type": "!=null",
            "device": "!=null",
            "size": "!=null",
            "dmab": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_dma_alloc_pages_fallback": {
        "description": "Allocate the buffer area according to the given type with fallback.",
        "pre": {
            "type": "!=null",
            "device": "!=null",
            "size": "!=null",
            "dmab": "!=null"
        }
    }
},
{
    "kretprobe:snd_dma_free_pages": {
        "description": "Release the allocated buffer",
        "pre": {
            "dmab": "!=null"
        }
    }
},
{
    "kprobe:snd_dma_free_pages": {
        "description": "Release the allocated buffer",
        "pre": {
            "dmab": "!=null"
        }
    }
},
{
    "kretprobe:snd_dma_buffer_mmap": {
        "description": "Perform mmap of the given DMA buffer",
        "pre": {
            "dmab": "!=null",
            "area": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_dma_buffer_mmap": {
        "description": "Perform mmap of the given DMA buffer",
        "pre": {
            "dmab": "!=null",
            "area": "!=null"
        }
    }
},
{
    "kretprobe:snd_sgbuf_get_addr": {
        "description": "Return the physical address at the corresponding offset",
        "pre": {
            "dmab": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:snd_sgbuf_get_addr": {
        "description": "Return the physical address at the corresponding offset.",
        "pre": {
            "dmab": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:snd_sgbuf_get_page": {
        "description": "Return the physical page at the corresponding offset",
        "pre": {
            "dmab": "!=null",
            "offset": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:snd_sgbuf_get_page": {
        "description": "Return the physical page at the corresponding offset.",
        "pre": {
            "dmab": "!=null",
            "offset": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:snd_sgbuf_get_chunk_size": {
        "description": "Compute the max chunk size with continuous pages on sg-buffer",
        "pre": {
            "dmab": "!=null",
            "ofs": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:snd_sgbuf_get_chunk_size": {
        "description": "Compute the max chunk size with continuous pages on sg-buffer.",
        "pre": {
            "dmab": "!=null",
            "ofs": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:snd_device_new": {
        "description": "Create an ALSA device component",
        "pre": {
            "card": "!=null",
            "type": "in [SNDRV_DEV_XXX]",
            "device_data": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:snd_device_new": {
        "description": "Create an ALSA device component",
        "pre": {
            "card": "!=null",
            "type": "in [SNDRV_DEV_XXX]",
            "device_data": "!=null",
            "ops": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_device_register": {
        "description": "Register the device",
        "pre": {
            "dev": "!=null",
            "dev->state": "==SNDRV_DEV_BUILD",
            "dev->ops->dev_register": "!=null",
            "err": "int",
            "err < 0": "true",
            "return": "0"
        }
    }
},
{
    "kprobe:snd_device_register": {
        "description": "Register the device",
        "pre": {
            "dev": {
                "state": "== SNDRV_DEV_BUILD",
                "ops": {
                    "dev_register": "!= null"
                }
            }
        }
    }
},
{
    "kretprobe:snd_register_oss_device": {
        "description": "Register an OSS device",
        "pre": {
            "type": "!=null",
            "card": "!=null",
            "dev": "!=null",
            "f_ops": "!=null",
            "private_data": "!=null",
            "minor": "< 0",
            "preg": "==null",
            "preg->type": "==type",
            "preg->card": "==(card ? card->number : -1)",
            "preg->device": "==dev",
            "preg->f_ops": "==f_ops",
            "preg->private_data": "==private_data",
            "preg->card_ptr": "==card",
            "sound_oss_mutex": "locked"
        },
        "post": {
            "snd_oss_minors[minor]": "==preg",
            "minor_unit": "SNDRV_MINOR_OSS_DEVICE(minor)"
        },
        "switch": {
            "minor_unit": {
                "case": [
                    {
                        "value": "SNDRV_MINOR_OSS_DEVICE(minor)",
                        "statements": []
                    }
                ]
            }
        }
    }
},
{
    "kprobe:snd_register_oss_device": {
        "description": "Register an OSS device with the given parameters.",
        "pre": {
            "type": "!=null",
            "card": "!=null",
            "dev": "!=null",
            "f_ops": "!=null",
            "private_data": "!=null",
            "minor": "< 0",
            "preg": "= kmalloc(sizeof(struct snd_minor), GFP_KERNEL)",
            "preg == NULL": "return -ENOMEM",
            "preg->type": "= type",
            "preg->card": "= card ? card->number : -1",
            "preg->device": "= dev",
            "preg->f_ops": "= f_ops",
            "preg->private_data": "= private_data",
            "preg->card_ptr": "= card",
            "mutex_lock(&sound_oss_mutex)": null,
            "snd_oss_minors[minor]": "= preg",
            "minor_unit": "= SNDRV_MINOR_OSS_DEVICE(minor)",
            "switch (minor_unit)": null
        }
    }
},
{
    "kretprobe:snd_unregister_oss_device": {
        "description": "Unregister an OSS sound device.",
        "pre": {
            "type": "!=null",
            "card": "!=null",
            "dev": "!=null",
            "minor": ">= 0",
            "cidx": "SNDRV_MINOR_OSS_CARD(minor)",
            "track2": ">= -1",
            "mptr": "!=null",
            "card->number": "< SNDRV_MINOR_OSS_DEVICES",
            "SNDRV_MINOR_OSS_DEVICE(minor)": "in [SNDRV_MINOR_OSS_PCM, SNDRV_MINOR_OSS_MIDI, SNDRV_MINOR_OSS_MIDI1]",
            "track2": ">= 0 implies snd_oss_minors[track2] == NULL",
            "snd_oss_minors[minor]": "NULL"
        }
    }
},
{
    "unregister_sound_special": {
        "description": "Unregister a sound special device.",
        "pre": {
            "type": "any",
            "card": {
                "not_null": true,
                "number": ">= SNDRV_MINOR_OSS_DEVICES"
            },
            "dev": "any"
        }
    }
},
{
    "kretprobe:snd_request_card": {
        "description": "Try to load the card module for the given card number.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kprobe:snd_request_card": {
        "description": "Try to load the card module for the given card number.",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:snd_lookup_minor_data": {
        "description": "Get user data of a registered device",
        "pre": {
            "minor": "!=null",
            "type": "in [SNDRV_DEVICE_TYPE_XXX]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:snd_lookup_minor_data": {
        "description": "Get user data of a registered device",
        "pre": {
            "minor": "!=null",
            "type": "in [SNDRV_DEVICE_TYPE_XXX]"
        }
    }
},
{
    "kretprobe:snd_register_device": {
        "description": "Register the ALSA device file for the card",
        "pre": {
            "type": "!=null",
            "card": "!=null",
            "dev": "!=null",
            "f_ops": "!=null",
            "private_data": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kprobe:snd_register_device": {
        "description": "Register the ALSA device file for the card",
        "pre": {
            "type": "!=null",
            "card": "!=null",
            "dev": "!=null",
            "f_ops": "!=null",
            "private_data": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kretprobe:snd_unregister_device": {
        "description": "Unregister the device on the given card",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_unregister_device": {
        "description": "Unregister the device on the given card",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_signed": {
        "description": "Check if the PCM format is signed linear",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return_value": "in [1, 0, <negative_error_code>]"
        }
    }
},
{
    "kprobe:snd_pcm_format_signed": {
        "description": "Check if the PCM format is signed linear.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_unsigned": {
        "description": "Check if the PCM format is unsigned linear",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return_value": "in [1, 0, <negative_error_code>]"
        }
    }
},
{
    "kprobe:snd_pcm_format_unsigned": {
        "description": "Check if the PCM format is unsigned linear.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_linear": {
        "description": "Check the PCM format is linear",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:snd_pcm_format_linear": {
        "description": "Check the PCM format is linear",
        "pre": {
            "format": "!=null",
            "format_type": "in [SND_PCM_FORMAT_LINEAR]",
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kretprobe:snd_pcm_format_little_endian": {
        "description": "Check if the PCM format is little-endian",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return": "in [1, 0, <negative error code>]"
        }
    }
},
{
    "kprobe:snd_pcm_format_little_endian": {
        "description": "Check if the PCM format is little-endian.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_big_endian": {
        "description": "Check if the PCM format is big-endian",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_format_big_endian": {
        "description": "Check if the PCM format is big-endian",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_width": {
        "description": "Return the bit-width of the format",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_format_width": {
        "description": "Return the bit-width of the format.",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_physical_width": {
        "description": "Return the physical bit-width of the format.",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_format_physical_width": {
        "description": "Return the physical bit-width of the format",
        "pre": {
            "format": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_format_size": {
        "description": "Return the byte size of samples on the given format",
        "pre": {
            "format": "!=null",
            "samples": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_format_size": {
        "description": "Return the byte size of samples on the given format.",
        "pre": {
            "format": "!=null",
            "samples": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_format_silence_64": {
        "description": "Return the silent data in 8 bytes array",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_format_silence_64": {
        "description": "Return the silent data in 8 bytes array.",
        "pre": {
            "format": "!=null"
        },
        "post": {
            "return": "in [valid format pattern, %NULL]"
        }
    }
},
{
    "kretprobe:snd_pcm_format_set_silence": {
        "description": "Set the silence data on the buffer for the given samples.",
        "pre": {
            "format": "!=null",
            "data": "!=null",
            "samples": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_format_set_silence": {
        "description": "Set the silence data on the buffer for the given samples.",
        "pre": {
            "format": "!=null",
            "data": "!=null",
            "samples": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_hw_limit_rates": {
        "description": "Determines the rate_min and rate_max fields from the rates bits of the given hw.",
        "pre": {
            "hw": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:snd_pcm_hw_limit_rates": {
        "description": "Determines the rate_min and rate_max fields from the rates bits of the given hw.",
        "pre": {
            "hw": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_rate_to_rate_bit": {
        "description": "Converts sample rate to SNDRV_PCM_RATE_xxx bit",
        "pre": {
            "rate": "!=null"
        },
        "post": {
            "return_value": "in [SNDRV_PCM_RATE_8000, SNDRV_PCM_RATE_11025, SNDRV_PCM_RATE_16000, SNDRV_PCM_RATE_22050, SNDRV_PCM_RATE_32000, SNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_48000, SNDRV_PCM_RATE_64000, SNDRV_PCM_RATE_88200, SNDRV_PCM_RATE_96000, SNDRV_PCM_RATE_176400, SNDRV_PCM_RATE_192000, SNDRV_PCM_RATE_384000, SNDRV_PCM_RATE_KNOT]"
        }
    }
},
{
    "kprobe:snd_pcm_rate_to_rate_bit": {
        "description": "Converts sample rate to SNDRV_PCM_RATE_xxx bit",
        "pre": {
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_rate_bit_to_rate": {
        "description": "Converts SNDRV_PCM_RATE_xxx bit to sample rate",
        "pre": {
            "rate_bit": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_rate_bit_to_rate": {
        "description": "Converts SNDRV_PCM_RATE_xxx bit to sample rate",
        "pre": {
            "rate_bit": "!=null",
            "rate_bit": "in [SNDRV_PCM_RATE_8000, SNDRV_PCM_RATE_16000, SNDRV_PCM_RATE_44100, SNDRV_PCM_RATE_48000, SNDRV_PCM_RATE_96000, SNDRV_PCM_RATE_192000]",
            "return": "in [8000, 16000, 44100, 48000, 96000, 192000, 0]"
        }
    }
},
{
    "kretprobe:snd_pcm_group_init": {
        "description": "Initialize the sound PCM group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_group_init": {
        "description": "Initialize the sound PCM group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_stop": {
        "description": "Try to stop all running streams in the substream group",
        "pre": {
            "substream": "!=null",
            "state": "in [SND_PCM_STATE_OPEN, SND_PCM_STATE_SETUP, SND_PCM_STATE_PREPARED, SND_PCM_STATE_RUNNING, SND_PCM_STATE_XRUN, SND_PCM_STATE_DRAINING, SND_PCM_STATE_PAUSED, SND_PCM_STATE_SUSPENDED]"
        }
    }
},
{
    "kprobe:snd_pcm_stop": {
        "description": "Try to stop all running streams in the substream group",
        "pre": {
            "substream": "!=null",
            "state": "in [SND_PCM_STATE_OPEN, SND_PCM_STATE_SETUP, SND_PCM_STATE_PREPARED, SND_PCM_STATE_RUNNING, SND_PCM_STATE_XRUN, SND_PCM_STATE_DRAINING, SND_PCM_STATE_PAUSED, SND_PCM_STATE_SUSPENDED]"
        }
    }
},
{
    "kretprobe:snd_pcm_suspend_all": {
        "description": "Trigger SUSPEND to all substreams in the given pcm",
        "pre": {
            "pcm": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_suspend_all": {
        "description": "Trigger SUSPEND to all substreams in the given pcm",
        "pre": {
            "pcm": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_open_substream": {
        "description": "Open a substream for a PCM device.",
        "pre": {
            "substream->managed_buffer_alloc": "==true",
            "substream->dma_buffer.dev.need_sync": "==true"
        },
        "post": {
            "*rsubstream": "==substream",
            "substream->runtime->hw.info": "|=SNDRV_PCM_INFO_EXPLICIT_SYNC"
        },
        "error": {
            "snd_pcm_release_substream(substream)": "called"
        },
        "return": {
            "0": "returned",
            "err": "returned"
        }
    }
},
{
    "kprobe:snd_pcm_open_substream": {
        "description": "Open a substream for PCM.",
        "pre": {
            "pcm": "!=null",
            "stream": "!=null",
            "file": "!=null",
            "rsubstream": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_kernel_ioctl": {
        "description": "Execute PCM ioctl in the kernel-space",
        "pre": {
            "substream": "!=null",
            "cmd": "!=null",
            "arg": "!=null",
            "cmd": "in [hw_params, sw_params, prepare, start, drain, drop, forward]"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:snd_pcm_kernel_ioctl": {
        "description": "Execute PCM ioctl in the kernel-space",
        "pre": {
            "substream": "!=null",
            "cmd": "!=null",
            "arg": "!=null",
            "cmd": "in [hw_params, sw_params, prepare, start, drain, drop, forward]"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_mmap_iomem": {
        "description": "Default PCM data mmap function for IO mem",
        "pre": {
            "substream": "!=null",
            "area": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_lib_mmap_iomem": {
        "description": "Default PCM data mmap function for IO mem",
        "pre": {
            "substream": "!=null",
            "area": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_default_mmap": {
        "description": "Default PCM data mmap function",
        "pre": {
            "substream": "!=null",
            "area": "!=null",
            "vmf": "!=null",
            "vmf->vma": "!=null",
            "vmf->vma->vm_private_data": "!=null",
            "substream == NULL": false,
            "runtime": "!=null",
            "offset": "vmf->pgoff << PAGE_SHIFT",
            "dma_bytes": "PAGE_ALIGN(runtime->dma_bytes)",
            "offset > dma_bytes - PAGE_SIZE": false,
            "substream->ops->page": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_lib_default_mmap": {
        "description": "Default PCM data mmap function",
        "pre": {
            "substream": "!=null",
            "area": "valid VMA"
        }
    }
},
{
    "kretprobe:snd_pcm_create_iec958_consumer_default": {
        "description": "Create default consumer format IEC958 channel status",
        "pre": {
            "cs": "!=null",
            "len": ">=4"
        }
    }
},
{
    "kprobe:snd_pcm_create_iec958_consumer_default": {
        "description": "Create default consumer format IEC958 channel status",
        "pre": {
            "cs": "!=null",
            "len": ">=4"
        }
    }
},
{
    "kretprobe:snd_pcm_create_iec958_consumer_hw_params": {
        "description": "Create the consumer format channel status data in @cs of maximum size @len corresponding to the parameters of the PCM runtime @runtime.",
        "pre": {
            "params": "!=null",
            "cs": "!=null",
            "len": ">=4"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_create_iec958_consumer_hw_params": {
        "description": "Create IEC958 channel status",
        "pre": {
            "params": "!=null",
            "cs": "!=null",
            "len": ">=4"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_preallocate_free_for_all": {
        "description": "Release all pre-allocated buffers on the pcm",
        "pre": {
            "pcm": "!=null"
        }
    }
},
S,
{
    "kretprobe:snd_pcm_lib_preallocate_pages": {
        "description": "Pre-allocate DMA buffer pages for the given DMA type.",
        "pre": {
            "substream": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_lib_preallocate_pages": {
        "description": "Pre-allocate DMA buffer pages for the given DMA type.",
        "pre": {
            "substream": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_preallocate_pages_for_all": {
        "description": "Pre-allocate continuous memory for all substreams of the given pcm for the specified DMA type.",
        "pre": {
            "pcm": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_lib_preallocate_pages_for_all": {
        "description": "Pre-allocation for continuous memory type (all substreams)",
        "pre": {
            "pcm": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_set_managed_buffer": {
        "description": "Set up buffer management for a substream",
        "pre": {
            "substream": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_set_managed_buffer": {
        "description": "Set up buffer management for a substream",
        "pre": {
            "substream": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_set_managed_buffer_all": {
        "description": "Set up buffer management for all substreams of the given pcm for the specified DMA type and size, and set the managed_buffer_alloc flag to each substream.",
        "pre": {
            "pcm": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_set_managed_buffer_all": {
        "description": "Set up buffer management for all substreams of the given pcm for the specified DMA type and size, and set the managed_buffer_alloc flag to each substream.",
        "pre": {
            "pcm": "!=null",
            "type": "in [SNDRV_DMA_TYPE_]",
            "data": "!=null",
            "size": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_malloc_pages": {
        "description": "Allocate the DMA buffer",
        "pre": {
            "substream": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_lib_malloc_pages": {
        "description": "Allocate the DMA buffer",
        "pre": {
            "substream": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:vfree(runtime->dma_area);}runtime->dma_area = __vmalloc(size, gfp_flags);if (!runtime->dma_area)return -ENOMEM;runtime->dma_bytes = size;return 1;}EXPORT_SYMBOL(_snd_pcm_lib_alloc_vmalloc_buffer": {
        "description": "Allocate a vmalloc buffer for the given PCM substream.",
        "pre": {
            "substream": "!=null",
            "size": "!=null",
            "gfp_flags": "!=null",
            "runtime": "!=null",
            "runtime->dma_area": "==null",
            "runtime->dma_bytes": ">= size"
        },
        "post": {
            "runtime->dma_area": "!=null",
            "runtime->dma_bytes": "== size",
            "return value": "== 1"
        }
    }
},
{
    "kprobe:vfree(runtime->dma_area);}runtime->dma_area = __vmalloc(size, gfp_flags);if (!runtime->dma_area)return -ENOMEM;runtime->dma_bytes = size;return 1;}EXPORT_SYMBOL(_snd_pcm_lib_alloc_vmalloc_buffer": {
        "description": "Allocate a vmalloc buffer for the PCM substream.",
        "pre": {
            "substream": "!=null",
            "size": "!=null",
            "gfp_flags": "!=null",
            "runtime->dma_area": "==null",
            "runtime->dma_bytes": "< size"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_free_vmalloc_buffer": {
        "description": "Free vmalloc buffer",
        "pre": {
            "substream": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_lib_free_vmalloc_buffer": {
        "description": "Free vmalloc buffer",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_lib_get_vmalloc_page": {
        "description": "Map vmalloc buffer offset to page struct",
        "pre": {
            "substream": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_lib_get_vmalloc_page": {
        "description": "Map vmalloc buffer offset to page struct",
        "pre": {
            "substream": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:snd_pcm_new_stream": {
        "description": "Create a new PCM stream",
        "pre": {
            "pcm": "!=null",
            "stream": "in [SNDRV_PCM_STREAM_PLAYBACK, SNDRV_PCM_STREAM_CAPTURE]",
            "substream_count": ">=0"
        }
    }
},
{
    "kprobe:snd_pcm_new_stream": {
        "description": "Create a new PCM stream",
        "pre": {
            "pcm": "!=null",
            "stream": "in [SNDRV_PCM_STREAM_PLAYBACK, SNDRV_PCM_STREAM_CAPTURE]",
            "substream_count": ">=0"
        }
    }
},
{
    "kretprobe:snd_pcm_new_internal": {
        "description": "Create a new internal PCM instance",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "device": "int",
            "playback_count": "int",
            "capture_count": "int",
            "rpcm": "!=null"
        }
    }
},
{
    "kprobe:snd_pcm_new_internal": {
        "description": "Create a new internal PCM instance",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "device": "int",
            "playback_count": "int",
            "capture_count": "int",
            "rpcm": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_ctl_notify": {
        "description": "Send notification to user-space for a control change",
        "pre": {
            "card": "!=null",
            "mask": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_notify": {
        "description": "Send notification to user-space for a control change",
        "pre": {
            "card": "!=null",
            "mask": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_notify_one": {
        "description": "Send notification to user-space for a control change",
        "pre": {
            "card": "!=null",
            "mask": "!=null",
            "kctl": "!=null",
            "ioff": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_notify_one": {
        "description": "Send notification to user-space for a control change",
        "pre": {
            "card": "!=null",
            "mask": "!=null",
            "kctl": "!=null",
            "ioff": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_new1": {
        "description": "Create a control instance from the template",
        "pre": {
            "ncontrol": "!=null",
            "private_data": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_new1": {
        "description": "Create a control instance from the template",
        "pre": {
            "ncontrol": "!=null",
            "private_data": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_free_one": {
        "description": "Release the control instance",
        "pre": {
            "kcontrol": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_free_one": {
        "description": "Release the control instance",
        "pre": {
            "kcontrol": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_ctl_replace": {
        "description": "Replace the control instance of the card.",
        "pre": {
            "card": "!=null",
            "kcontrol": "!=null",
            "add_on_replace": "in [true, false]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_ctl_replace": {
        "description": "Replace the control instance of the card.",
        "pre": {
            "card": "!=null",
            "kcontrol": "!=null",
            "add_on_replace": "in [true, false]"
        }
    }
},
{
    "kretprobe:if (card->last_numid >= UINT_MAX - count)card->last_numid = 0;list_for_each_entry(kctl, &card->controls, list)": {
        "description": "Make sure that the ids assigned to the control do not wrap around",
        "pre": {
            "card": "!=null",
            "count": "!=null",
            "card->last_numid": ">= 0",
            "card->last_numid": "<= UINT_MAX - count",
            "kctl": "!=null",
            "&card->controls": "!=null"
        }
    }
},
{
    "kprobe:if (card->last_numid >= UINT_MAX - count)card->last_numid = 0;list_for_each_entry(kctl, &card->controls, list)": {
        "description": "Make sure that the ids assigned to the control do not wrap around",
        "pre": {
            "card": "!=null",
            "count": "!=null",
            "card->last_numid": ">= 0",
            "card->last_numid": "<= UINT_MAX - count",
            "kctl": "!=null",
            "&card->controls": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_remove_id": {
        "description": "Remove the control of the given id and release it.",
        "pre": {
            "card": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_ctl_remove_id": {
        "description": "Remove the control of the given id and release it.",
        "pre": {
            "card": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_rename_id": {
        "description": "Replace the id of a control on the card.",
        "pre": {
            "card": "!=null",
            "src_id": "!=null",
            "dst_id": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_rename_id": {
        "description": "Replace the id of a control on the card.",
        "pre": {
            "card": "!=null",
            "src_id": "!=null",
            "dst_id": "!=null"
        }
    }
},
"pre": {
    "card": "!=null",
    "numid": "!=null"
},
{
    "kprobe:snd_ctl_find_numid": {
        "description": "Find the control instance with the given number-id from the card.",
        "pre": {
            "card": "!=null",
            "numid": "!=null",
            "kctl": "!=null",
            "kctl->id.numid": "<= numid",
            "kctl->id.numid + kctl->count": "> numid"
        },
        "post": {
            "return": "kctl"
        }
    }
},
{
    "kretprobe:snd_ctl_add": {
        "description": "Add the control instance to the card.",
        "pre": {
            "card": "!=null",
            "kcontrol": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_add": {
        "description": "Add the control instance to the card.",
        "pre": {
            "card": "!=null",
            "kcontrol": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_register_ioctl": {
        "description": "Register the device-specific control-ioctls",
        "pre": {
            "fcn": "!=null",
            "lists": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_register_ioctl": {
        "description": "Register the device-specific control-ioctls",
        "pre": {
            "fcn": "!=null",
            "lists": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_register_ioctl_compat": {
        "description": "Register the device-specific 32bit compat control-ioctls.",
        "pre": {
            "fcn": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:snd_ctl_register_ioctl_compat": {
        "description": "Register the device-specific 32bit compat control-ioctls.",
        "pre": {
            "fcn": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_unregister_ioctl": {
        "description": "De-register the device-specific control-ioctls.",
        "pre": {
            "fcn": "!=null",
            "lists": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:snd_ctl_unregister_ioctl": {
        "description": "De-register the device-specific control-ioctls.",
        "pre": {
            "fcn": "!=null",
            "lists": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_unregister_ioctl_compat": {
        "description": "De-register the device-specific compat 32bit control-ioctls.",
        "pre": {
            "fcn": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_ctl_unregister_ioctl_compat": {
        "description": "De-register the device-specific compat 32bit control-ioctls.",
        "pre": {
            "fcn": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_boolean_mono_info": {
        "description": "Helper function for a standard boolean info callback with a mono channel",
        "pre": {
            "kcontrol": "!=null",
            "uinfo": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_boolean_mono_info": {
        "description": "Helper function for a standard boolean info callback with a mono channel",
        "pre": {
            "kcontrol": "!=null",
            "uinfo": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_boolean_stereo_info": {
        "description": "Helper function for a standard boolean info callback with stereo two channels.",
        "pre": {
            "kcontrol": "!=null",
            "uinfo": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_boolean_stereo_info": {
        "description": "Helper function for a standard boolean info callback with stereo two channels.",
        "pre": {
            "kcontrol": "!=null",
            "uinfo": "!=null"
        }
    }
},
{
    "kretprobe:snd_ctl_enum_info": {
        "description": "Fills the info structure for an enumerated control.",
        "pre": {
            "info": "!=null",
            "channels": ">= 0",
            "items": ">= 0",
            "names": "!=null"
        }
    }
},
{
    "kprobe:snd_ctl_enum_info": {
        "description": "Fills the info structure for an enumerated control.",
        "pre": {
            "info": "!=null",
            "channels": ">= 0",
            "items": ">= 0",
            "names": "!=null"
        }
    }
},
{
    "kretprobe:snd_jack_add_new_kctl": {
        "description": "Create a new snd_jack_kctl and add it to jack",
        "pre": {
            "jack": "!=null",
            "name": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:snd_jack_add_new_kctl": {
        "description": "Create a new snd_jack_kctl and add it to jack",
        "pre": {
            "jack": "!=null",
            "name": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:snd_jack_new": {
        "description": "Create a new jack",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "type": "is a bitmask of enum snd_jack_type values",
            "jjack": "!=null",
            "initial_kctl": "is a boolean",
            "phantom_jack": "is a boolean"
        }
    }
},
{
    "kprobe:snd_jack_new": {
        "description": "Create a new jack",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "type": "is a bitmask of enum snd_jack_type values",
            "jjack": "!=null",
            "initial_kctl": "is a boolean",
            "phantom_jack": "is a boolean"
        }
    }
},
{
    "kretprobe:snd_jack_set_parent": {
        "description": "Set the parent device for a jack",
        "pre": {
            "jack": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:snd_jack_set_parent": {
        "description": "Set the parent device for a jack",
        "pre": {
            "jack": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:snd_jack_set_key": {
        "description": "Set a key mapping on a jack",
        "pre": {
            "jack": "!=null",
            "type": "in [SND_JACK_BTN_1, SND_JACK_BTN_2, SND_JACK_BTN_3, SND_JACK_BTN_4, SND_JACK_BTN_5, SND_JACK_BTN_6, SND_JACK_BTN_7, SND_JACK_BTN_8, SND_JACK_BTN_9, SND_JACK_BTN_10, SND_JACK_BTN_11, SND_JACK_BTN_12, SND_JACK_BTN_13, SND_JACK_BTN_14, SND_JACK_BTN_15, SND_JACK_BTN_16]",
            "keytype": "!=null"
        }
    }
},
{
    "kprobe:snd_jack_set_key": {
        "description": "Set a key mapping on a jack",
        "pre": {
            "jack": "!=null",
            "type": "in [SND_JACK_BTN_1, SND_JACK_BTN_2, SND_JACK_BTN_3, SND_JACK_BTN_4, SND_JACK_BTN_5, SND_JACK_BTN_6, SND_JACK_BTN_7, SND_JACK_BTN_8, SND_JACK_BTN_9, SND_JACK_BTN_10, SND_JACK_BTN_11, SND_JACK_BTN_12, SND_JACK_BTN_13, SND_JACK_BTN_14, SND_JACK_BTN_15, SND_JACK_BTN_16]",
            "keytype": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:snd_rawmidi_drain_output": {
        "description": "Drain the output of the raw MIDI substream.",
        "pre": {
            "substream->lock": "acquired using spin_lock_irq",
            "substream->runtime": "!=null",
            "substream->runtime->buffer": "!=null",
            "substream->opened": "true",
            "substream->runtime->drain": "1"
        },
        "post": {
            "err": "< 0 => return err",
            "wait_event_interruptible_timeout(runtime->sleep, runtime->avail >= runtime->buffer_size, 10 HZ)": "wait for runtime->avail >= runtime->buffer_size with timeout 10 HZ",
            "signal_pending(current)": "set err to -ERESTARTSYS",
            "runtime->avail < runtime->buffer_size && !timeout => err = -EIO",
            "runtime->drain": "0"
        }
    }
},
{
    "kprobe:snd_rawmidi_drain_output": {
        "description": "Drain the output of the raw MIDI substream.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:snd_rawmidi_receive": {
        "description": "Receive the input data from the device",
        "pre": {
            "substream": "!=null",
            "buffer": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:snd_rawmidi_receive": {
        "description": "Receive the input data from the device",
        "pre": {
            "substream": "!=null",
            "buffer": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:snd_rawmidi_kernel_read1": {
        "description": "Kernel function for reading raw MIDI data from a substream.",
        "pre": {
            "substream": "!=null",
            "userbuf": "!=null",
            "kernelbuf": "!=null",
            "count": ">=0",
            "runtime": "!=null",
            "runtime.buffer_size": ">0",
            "runtime.appl_ptr": ">=0",
            "runtime.appl_ptr + count1": "<= runtime.buffer_size",
            "runtime.avail": ">=0",
            "runtime.buffer": "!=null",
            "result": ">=0",
            "kernelbuf + result": "!=null"
        }
    }
},
{
    "kprobe:snd_rawmidi_kernel_read1": {
        "description": "Kernel function for reading raw MIDI data.",
        "pre": {
            "substream": "!=null",
            "userbuf": "!=null",
            "kernelbuf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:snd_rawmidi_transmit_empty": {
        "description": "Check whether the output buffer is empty",
        "pre": {
            "substream": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:snd_rawmidi_transmit_empty": {
        "description": "Check whether the output buffer is empty.",
        "pre": {
            "substream": "!=null"
        }
    }
},
{
    "kretprobe:__snd_rawmidi_transmit_peek": {
        "description": "Copy data from the internal buffer",
        "pre": {
            "substream": "!=null",
            "buffer": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:__snd_rawmidi_transmit_peek": {
        "description": "Copy data from the internal buffer",
        "pre": {
            "substream": "!=null",
            "buffer": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:snd_rawmidi_transmit_peek": {
        "description": "Transmit and peek at the data in the raw MIDI substream.",
        "pre": {
            "substream": "!=null",
            "buffer": "!=null",
            "count": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:snd_rawmidi_proceed": {
        "description": "Discard all pending bytes and proceed.",
        "pre": {
            "substream": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:snd_rawmidi_proceed": {
        "description": "Discard all pending bytes and proceed",
        "pre": {
            "substream": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:snd_rawmidi_kernel_release": {
        "description": "Release the resources associated with the snd_rawmidi_file structure.",
        "pre": {
            "rfile": "!=null"
        }
    }
},
S,
S,
{
    "kprobe:snd_rawmidi_new": {
        "description": "Create a new instance of raw MIDI device for the given sound card.",
        "pre": {
            "card": "!=null",
            "id": "!=null",
            "device": "int",
            "output_count": "int",
            "input_count": "int",
            "rrawmidi": "!=null"
        },
        "post": {
            "return": "int",
            "return_conditions": {
                "zero": "successful",
                "negative": "failure"
            }
        }
    }
},
S,
{
    "kprobe:snd_virmidi_new": {
        "description": "Create a new virtual MIDI device.",
        "pre": {
            "card": "!=null",
            "device": "is an integer",
            "rrmidi": "is an instance of struct snd_rawmidi"
        }
    }
},
{
    "kretprobe:snd_seq_event_port_attach": {
        "description": "Set up the port",
        "pre": {
            "portinfo.addr.client": "client",
            "portinfo.name": "portname ? portname : \"Unnamed port\"",
            "portinfo.capability": "cap",
            "portinfo.type": "type",
            "portinfo.kernel": "pcbp",
            "portinfo.midi_channels": "midi_channels",
            "portinfo.midi_voices": "midi_voices"
        }
    }
},
{
    "memset": {},
    "portinfo.addr.client": "client",
    "portinfo.name": "portname ? portname : 'Unnamed port'",
    "portinfo.capability": "cap",
    "portinfo.type": "type",
    "portinfo.kernel": "pcbp",
    "portinfo.midi_channels": "midi_channels",
    "portinfo.midi_voices": "midi_voices"
},
{
    "kretprobe:ev->type = status_event[ST_SPECIAL + c - 0xf0].event;ev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;ev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;return ev->type != SNDRV_SEQ_EVENT_NONE;}spin_lock_irqsave(&dev->lock, flags);if ((c & 0x80) && (c != MIDI_CMD_COMMON_SYSEX_END || dev->type != ST_SYSEX)": {
        "description": "The given function updates the value of ev->type based on the status_event array and performs some flag operations. It then checks if ev->type is not equal to SNDRV_SEQ_EVENT_NONE. Additionally, it acquires a spin lock if certain conditions are met.",
        "pre": {
            "ev": {
                "type": "!= null",
                "flags": "&= ~SNDRV_SEQ_EVENT_LENGTH_MASK; |= SNDRV_SEQ_EVENT_LENGTH_FIXED"
            },
            "status_event": "!= null",
            "c": "!= null",
            "dev": {
                "lock": "!= null",
                "type": "!= null"
            }
        }
    }
},
{
    "kprobe:ev->type = status_event[ST_SPECIAL + c - 0xf0].event;ev->flags &= ~SNDRV_SEQ_EVENT_LENGTH_MASK;ev->flags |= SNDRV_SEQ_EVENT_LENGTH_FIXED;return ev->type != SNDRV_SEQ_EVENT_NONE;}spin_lock_irqsave(&dev->lock, flags);if ((c & 0x80) && (c != MIDI_CMD_COMMON_SYSEX_END || dev->type != ST_SYSEX)": {
        "description": "snd_midi_event_encode_byte",
        "pre": {
            "dev": "!=null",
            "c": "!=null",
            "ev": "!=null",
            "ev->type": "in status_event[ST_SPECIAL + c - 0xf0].event",
            "ev->flags": "&= ~SNDRV_SEQ_EVENT_LENGTH_MASK",
            "ev->flags": "|= SNDRV_SEQ_EVENT_LENGTH_FIXED",
            "return": "ev->type != SNDRV_SEQ_EVENT_NONE",
            "spin_lock_irqsave(&dev->lock, flags)": "valid",
            "if ((c & 0x80) && (c != MIDI_CMD_COMMON_SYSEX_END || dev->type != ST_SYSEX))": "valid"
        }
    }
},
{
    "kretprobe:snd_midi_event_decode": {
        "description": "Decodes a MIDI event",
        "pre": {
            "dev": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "ev": "!=null",
            "ev->type": "!=SNDRV_SEQ_EVENT_NONE",
            "ev->type": "in [status_event[].event, extra_event[].event]",
            "ev->data.note.channel": ">=0",
            "ev->data.note.channel": "<=15"
        },
        "post": {
            "cmd": "0x80 | (type << 4) | (ev->data.note.channel & 0x0f)",
            "cmd": "==MIDI_CMD_COMMON_SYSEX"
        }
    }
},
{
    "kprobe:snd_midi_event_decode": {
        "description": "Decode MIDI event",
        "pre": {
            "dev": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "ev": {
                "type": "!=SNDRV_SEQ_EVENT_NONE",
                "data": {
                    "note": {
                        "channel": ">=0",
                        "channel & 0x0f": ">=0"
                    },
                    "control": {
                        "channel": ">=0",
                        "channel & 0x0f": ">=0"
                    }
                }
            }
        },
        "post": {
            "cmd": "0x80 | (type << 4) | (ev->data.note.channel & 0x0f)",
            "cmd == MIDI_CMD_COMMON_SYSEX": true
        }
    }
},
S,
{
    "kprobe:snd_midi_process_event": {
        "description": "Process a MIDI event.",
        "pre": {
            "ops": "!=null",
            "ev": {
                "type": "== SNDRV_SEQ_EVENT_NOTE"
            },
            "chanset": "!=null",
            "chanset->channels": "!=null",
            "chanset->max_channels": "> dest_channel"
        }
    }
},
{
    "kretprobe:snd_midi_channel_set_clear": {
        "description": "Set and clear various properties of the MIDI channel.",
        "pre": {
            "chset": {
                "midi_mode": "SNDRV_MIDI_MODE_GM",
                "gs_master_volume": 127
            },
            "chan": {
                "note": "memset to 0",
                "midi_aftertouch": 0,
                "midi_pressure": 0,
                "midi_program": 0,
                "midi_pitchbend": 0,
                "gm_rpn_pitch_bend_range": 256
            }
        }
    }
},
{
    "kprobe:snd_midi_channel_set_clear": {
        "description": "Clears the MIDI channel set and sets default values for each channel.",
        "pre": {
            "chset": "!=null",
            "chset->midi_mode": "==SNDRV_MIDI_MODE_GM",
            "chset->gs_master_volume": "==127",
            "chset->max_channels": ">=0",
            "chset->channels": "!=null",
            "chan": "!=null",
            "chan->note": "==0",
            "chan->midi_aftertouch": "==0",
            "chan->midi_pressure": "==0",
            "chan->midi_program": "==0",
            "chan->midi_pitchbend": "==0",
            "chan->gm_rpn_pitch_bend_range": "==256",
            "chan->gm_rpn_fine_tuning": "==0",
            "chan->gm_rpn_coarse_tuning": "==0",
            "chan->drum_channel": "in [0, 1]"
        }
    }
},
{
    "kretprobe:seq_create_client1": {
        "description": "Create a kernel client for the sound card's sequencer.",
        "pre": {
            "client_index": "!=null",
            "0": "!=null"
        },
        "post": {
            "client": "==null"
        }
    }
},
{
    "kprobe:snd_seq_create_kernel_client": {
        "description": "Create a kernel client for the ALSA sequencer.",
        "pre": {
            "client_index": ">= SNDRV_SEQ_CLIENTS_PER_CARD"
        }
    }
},
{
    "kretprobe:if (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)": {
        "description": "Check if the event type is SNDRV_SEQ_EVENT_KERNEL_ERROR",
        "pre": {
            "ev": {
                "type": "== SNDRV_SEQ_EVENT_KERNEL_ERROR"
            }
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if (ev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)return -EINVAL; /* quoted events can't be enqueued `": {
        "description": "Check if the event type is SNDRV_SEQ_EVENT_KERNEL_ERROR and return -EINVAL if true.",
        "pre": {
            "ev->type": "== SNDRV_SEQ_EVENT_KERNEL_ERROR"
        }
    }
},
{
    "kretprobe:snd_seq_kernel_client_dispatch": {
        "description": "Dispatches a kernel client event in the ALSA sequencer subsystem.",
        "pre": {
            "client": "!=null",
            "ev": "!=null",
            "atomic": "!=null",
            "hop": "!=null",
            "cptr": "!=null",
            "result": "!=null",
            "ev": "!=null",
            "ev->queue": "==SNDRV_SEQ_QUEUE_DIRECT",
            "ev->source.client": "==client",
            "check_event_type_and_length(ev)": "==0",
            "cptr = snd_seq_client_use_ptr(client)": "!=NULL",
            "!cptr->accept_output": "==0",
            "result = snd_seq_deliver_event(cptr, ev, atomic, hop)": "!=NULL",
            "snd_seq_client_unlock(cptr)": "!=NULL"
        }
    }
},
S,
{
    "kretprobe:snd_seq_kernel_client_ctl": {
        "description": "Operate a command for a client with data in kernel space.",
        "pre": {
            "clientid": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:snd_seq_kernel_client_ctl": {
        "description": "Operate a command for a client with data in kernel space.",
        "pre": {
            "clientid": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
]