[{
    "kretprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">= 0",
            "nbits": ">= 0"
        }
    }
},
{
    "kprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">0",
            "dst_size": "==nbits",
            "src_size": "==nbits",
            "shift": "<nbits"
        }
    }
},
{
    "kretprobe:__bitmap_shift_left": {
        "description": "Logical left shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:__bitmap_shift_left": {
        "description": "Logical left shift of the bits in a bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": ">=0",
            "cut": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": ">=0",
            "cut": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": ">=0",
            "align_offset": ">=0",
            "align_mask": "is one less than a power of 2"
        }
    }
},
{
    "kprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": ">=0",
            "align_offset": ">=0",
            "align_mask": "is one less than a power of 2"
        }
    }
},
{
    "kretprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string",
        "pre": {
            "list": "bool",
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": "int"
        },
        "post": {
            "return": "int",
            "buf": "!=null",
            "buf_length": "int"
        }
    }
},
{
    "kprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string",
        "pre": {
            "list": "bool",
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:bitmap_print_bitmask_to_buf": {
        "description": "Prints the bitmask to the buffer.",
        "pre": {
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": ">=0",
            "off": ">=0",
            "count": ">=0"
        }
    }
},

{
    "kretprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap.",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit",
        "pre": {
            "oldbit": "!=null",
            "old": "!=null",
            "new": "!=null",
            "bits": "!=null"
        }
    }
},
{
    "kprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit.",
        "pre": {
            "oldbit": "!=null",
            "old": "!=null",
            "new": "!=null",
            "bits": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_find_free_region": {
        "description": "Find a contiguous aligned mem region",
        "pre": {
            "bitmap": "!=null",
            "bits": "!=null",
            "order": "!=null",
            "order": "is a power of 2",
            "order": ">= 0",
            "bits": ">= order",
            "bitmap": "has at least (bits / 8) elements"
        }
    }
},
{
    "kprobe:bitmap_find_free_region": {
        "description": "Find a contiguous aligned mem region",
        "pre": {
            "bitmap": "!=null",
            "bits": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap.",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap.",
        "pre": {
            "bitmap": "!=null",
            "pos": "!=null",
            "order": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": "% BITS_PER_LONG == 0"
        }
    }
},
{
    "kprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": "% BITS_PER_LONG == 0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap.",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": "!=null"
        }
    }
},
{
    "kretprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:sg_split": {
        "description": "Split a scatterlist into several scatterlists",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_split": {
        "description": "Split a scatterlist into several scatterlists",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:unlikely(val.t - m->s[2].t > win))": {
        "description": "Check if the difference between val.t and m->s[2].t is greater than win.",
        "pre": {
            "val.t": "!=null",
            "m->s[2].t": "!=null",
            "win": "!=null"
        }
    }
},

{
    "kretprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL]"
        }
    }
},
{
    "kprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL]"
        }
    }
},
{
    "kretprobe:cpu_rmap_put": {
        "description": "Release reference on a cpu_rmap",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_put": {
        "description": "Release ref on a cpu_rmap",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kretprobe:cpu_rmap_add": {
        "description": "Add object to a rmap",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
        "post": {
            "return_value": ">= -ENOSPC"
        }
    }
},
{
    "kprobe:cpu_rmap_add": {
        "description": "Add object to a rmap",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
        "post": {
            "return": "int",
            "return_conditions": {
                "value": ">= -ENOSPC"
            }
        }
    }
},
{
    "kretprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "pre": {
            "rmap": "!=null",
            "index": "!=null",
            "affinity": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "pre": {
            "rmap": "!=null",
            "index": "!=null",
            "affinity": "!=null"
        }
    }
},
{
    "kretprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs.",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs.",
        "pre": {
            "rmap": "in [null, not null]",
            "context": "in [process context]",
            "irqs": "must be freed before calling this function"
        }
    }
},
{
    "kretprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map.",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map",
        "pre": {
            "rmap": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kprobe:___ratelimit": {
        "description": "Paired with WRITE_ONCE() in .proc_handler(). Changing two values separately could be inconsistent and some message could be lost. (See: net_ratelimit_state).",
        "pre": {
            "rs": "!=null",
            "func": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:string_get_size": {
        "description": "get the size in the specified units",
        "pre": {
            "size": "!=null",
            "blk_size": "!=null",
            "units": "in [1000, 1024]",
            "buf": "!=null",
            "len": ">=9"
        }
    }
},
{
    "kprobe:string_get_size": {
        "description": "get the size in the specified units",
        "pre": {
            "size": "!=null",
            "blk_size": "!=null",
            "units": "in [1000, 1024]",
            "buf": "!=null",
            "len": ">=9"
        }
    }
},
{
    "kretprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        }
    }
},
{
    "kprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        }
    }
},
{
    "kretprobe:string_unescape": {
        "description": "Unquote characters in the given string.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": ">=0",
            "flags": "& [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:string_unescape": {
        "description": "Unquote characters in the given string.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": ">=0",
            "flags": "in [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:string_escape_mem": {
        "description": "quote characters in the given memory buffer",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": ">=0",
            "only": "!=null"
        }
    }
},
{
    "kprobe:string_escape_mem": {
        "description": "Quote characters in the given memory buffer.",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": ">=0",
            "only": "!=null"
        }
    }
},
{
    "kretprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "count": ">0"
        }
    }
},
{
    "kprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "count": ">0"
        }
    }
},
{
    "kretprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str.",
        "pre": {
            "str": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str.",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strim": {
        "description": "Removes leading and trailing whitespace from the given string.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:strim": {
        "description": "Removes leading and trailing whitespace from the given string.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "string": "!=null"
        },
        "post": {
            "return": ">= -22"
        }
    }
},
{
    "kprobe:match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "string": "!=null"
        }
    }
},
{
    "kretprobe:__sysfs_match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">= -1",
            "str": "!=null"
        },
        "post": {
            "return": ">= -EINVAL",
            "return": "<= n",
            "return": "!= -1"
        }
    }
},
{
    "kprobe:__sysfs_match_string": {
        "description": "Matches given string in an array",
        "pre": {
            "array": "!=null",
            "n": ">=0",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strreplace": {
        "description": "Replace all occurrences of character in string.",
        "pre": {
            "str": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
        "post": {
            "return": "==str"
        }
    }
},
{
    "kprobe:strreplace": {
        "description": "Replace all occurrences of character in string.",
        "pre": {
            "str": "!=null",
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding",
        "pre": {
            "dest": "!=null",
            "dest_len": ">= count",
            "src": "!=null",
            "count": ">= 0",
            "pad": ">= 0"
        }
    }
},
{
    "kprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding",
        "pre": {
            "dest": "!=null",
            "dest_len": ">= count",
            "src": "!=null",
            "count": ">= 0",
            "pad": ">= 0"
        }
    }
},


{
    "kretprobe:kstrtoull": {
        "description": "convert a string to an unsigned long long",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoull": {
        "description": "Convert a string to an unsigned long long.",
        "pre": {
            "s": "!=null",
            "base": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:kstrtoll": {
        "description": "Converts a string to a long long.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoll": {
        "description": "Convert a string to a long long",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtouint": {
        "description": "Convert a string to an unsigned int.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:noinlineint kstrtouint": {
        "description": "Convert a string to an unsigned int.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtoint": {
        "description": "Converts a string to an integer.",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoint": {
        "description": "Convert a string to an int",
        "pre": {
            "s": "!=null",
            "base": ">=0 and <=16",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kretprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values.",
        "pre": {
            "s": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "==0",
            "res": "!=null"
        }
    }
},
{
    "kprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values.",
        "pre": {
            "s": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:kstrtobool_from_user": {
        "description": "Converts a string to a boolean value from user space.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [-EFAULT, 0, 1]",
            "buf": "!=null",
            "buf[count]": "= '\\0'"
        }
    }
},
{
    "kprobe:kstrtobool_from_user": {
        "description": "Converts a string from user space to a boolean value.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign \"-\". Radix 0 means autodetection: leading \"0x\" implies radix 16, leading \"0\" implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign \"-\". Radix 0 means autodetection: leading \"0x\" implies radix 16, leading \"0\" implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        }
    }
},



{
    "kprobe:_find_first_and_bit": {
        "description": "Find the first bit set in the bitwise AND of addr1[idx] and addr2[idx].",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "size": "!=null"
        }
    }
},

{
    "kprobe:find_first_zero_bit": {
        "description": "Find the first zero bit in the memory range starting at *addr* with size *size*.",
        "pre": {
            "addr": "!=null",
            "size": "!=null"
        }
    }
},










{
    "kretprobe:if (strnlen( maxlen) < maxlen)return false;/* Don't dirty result unless string is valid MAC. `": {
        "description": "Check if the string is a valid MAC address.",
        "pre": {
            "s": "!=null",
            "maxlen": ">=0",
            "mac": "!=null",
            "mac[0]": ">=0",
            "mac[1]": ">=0",
            "mac[2]": ">=0",
            "mac[3]": ">=0",
            "mac[4]": ">=0",
            "mac[5]": ">=0"
        }
    }
},
{
    "kprobe:if (strnlen( maxlen) < maxlen)return false;/* Don't dirty result unless string is valid MAC. `": {
        "description": "Check if the string `s` represents a valid MAC address.",
        "pre": {
            "s": "!=null",
            "maxlen": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_iov_iter_readable": {
        "description": "Fault in iov iterator for reading",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_iov_iter_readable": {
        "description": "Fault in iov iterator for reading",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_iov_iter_writeable": {
        "description": "Fault in iov iterator for writing",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_iov_iter_writeable": {
        "description": "Fault in iov iterator for writing",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_iovec_advance": {
        "description": "Advance the iov_iter by the specified size when it is of type iovec.",
        "pre": {
            "i": "!=null",
            "size": "!=null",
            "i->count": "!=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_iov(i)": "!=null",
            "i->__iov": "!=null"
        }
    },
    "kretprobe:iov_iter_is_bvec": {
        "description": "Check if the iov_iter is of type bvec.",
        "pre": {
            "i": "!=null"
        }
    }
},
{
    "kprobe:iov_iter_iovec_advance": {
        "description": "Advance the iov_iter by the specified size when using bvec.",
        "pre": {
            "i": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:iov_iter_is_bvec": {
        "description": "Check if the iov_iter is using bvec.",
        "pre": {
            "i": "!=null"
        }
    }
},


{
    "kretprobe:iov_iter_xarray": {
        "description": "Initialise an IO iterator to use the pages in an xarray",
        "pre": {
            "i": "!=null",
            "direction": "!=null",
            "xarray": "!=null",
            "start": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:iov_iter_xarray": {
        "description": "Initialise an IO iterator to use the pages in an xarray",
        "pre": {
            "i": "!=null",
            "direction": "!=null",
            "xarray": "!=null",
            "start": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data",
        "pre": {
            "i": "!=null",
            "direction": "in [READ]",
            "count": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data",
        "pre": {
            "i": "!=null",
            "direction": "in [READ]",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_alignment": {
        "description": "Calculate the alignment value for the given iov_iter.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_ubuf(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_iovec": {
        "description": "Calculate the alignment value for the given iov_iter using iovec.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_iovec(i) || iov_iter_is_kvec(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_bvec": {
        "description": "Calculate the alignment value for the given iov_iter using bvec.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iov_iter_is_bvec(i)": "==true"
        }
    },
    "kretprobe:iov_iter_alignment_xarray": {
        "description": "Calculate the alignment value for the given iov_iter using xarray.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iov_iter_is_xarray(i)": "==true"
        }
    }
},
{
    "kprobe:iov_iter_alignment": {
        "description": "Calculate the alignment value for the given iov_iter.",
        "pre": {
            "i": "!=null",
            "i->count": ">=0",
            "i->iov_offset": ">=0",
            "i->nr_segs": ">=0",
            "iter_is_ubuf(i)": "==true",
            "i->ubuf": "!=null"
        }
    }
},
{
    "kretprobe:iov_iter_npages": {
        "description": "Calculate the number of pages in the iov_iter.",
        "pre": {
            "i": "!=null",
            "maxpages": "!=null",
            "i->count": "!=0",
            "iter_is_ubuf(i)": "==true",
            "offset_in_page(i->ubuf + i->iov_offset)": ">=0",
            "DIV_ROUND_UP(offs + i->count, PAGE_SIZE)": ">=0",
            "min(npage maxpages)": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_npages": {
        "description": "Calculate the number of pages in the iov_iter.",
        "pre": {
            "i": "!=null",
            "maxpages": "!=null",
            "i->count": "!=0",
            "iter_is_ubuf(i)": "==true",
            "offset_in_page(i->ubuf + i->iov_offset)": ">=0",
            "npages": ">=min(0, maxpages)"
        }
    }
},
{
    "kretprobe:return_new_kmemdup": {
        "description": "Allocate memory for new->__iov using kmemdup and return NULL.",
        "pre": {
            "new->__iov": "!=null",
            "new->nr_segs": ">0",
            "sizeof(struct iovec)": ">0",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:dup_iter": {
        "description": "Duplicating an iov_iter structure.",
        "pre": {
            "new": "!=null",
            "new->__iov": "!=null",
            "new->nr_segs": ">0",
            "flags": "!=null"
        }
    }
},
{
    "for (seg = 0; seg < nr_segs; seg++)": {
        "description": "Loop over segments",
        "pre": {
            "type": "any",
            "uvec": "!=null",
            "iovp": "!=null",
            "i": "any",
            "compat": "any"
        },
        "post": {
            "return_value": "any"
        }
    }
},
{
    "for (seg = 0; seg < nr_segs; seg++)": {
        "pre": {
            "nr_segs": ">0",
            "seg": "int",
            "seg_init": "0",
            "seg_increment": "1",
            "loop_condition": "seg < nr_segs"
        }
    }
},
{
    "kretprobe:BUG_ON": {
        "description": "Check if count is greater than num_queued - dql->num_completed",
        "pre": {
            "count": "> num_queued - dql->num_completed"
        }
    },
    "kretprobe:dql_completed": {
        "description": "Update various variables in dql_completed function",
        "pre": {
            "inprogress": "num_queued - completed",
            "prev_inprogress": "dql->prev_num_queued - dql->num_completed",
            "limit": "dql->limit",
            "ovlimit": "POSDIFF(num_queued - dql->num_completed, limit)",
            "completed": "dql->num_completed + count",
            "all_prev_completed": "AFTER_EQ(completed, dql->prev_num_queued)",
            "ovlimit && !inprogress || dql->prev_ovlimit && all_prev_completed": "true"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if count is greater than num_queued - dql->num_completed",
        "pre": {
            "count": "> num_queued - dql->num_completed"
        }
    },
    "kprobe:dql_completed": {
        "description": "Perform various calculations and checks",
        "pre": {
            "completed": "= dql->num_completed + count",
            "limit": "= dql->limit",
            "ovlimit": "= POSDIFF(num_queued - dql->num_completed, limit)",
            "inprogress": "= num_queued - completed",
            "prev_inprogress": "= dql->prev_num_queued - dql->num_completed",
            "all_prev_completed": "= AFTER_EQ(completed, dql->prev_num_queued)",
            "ovlimit_and_no_inprogress": "= (ovlimit && !inprogress)",
            "prev_ovlimit_and_all_prev_completed": "= (dql->prev_ovlimit && all_prev_completed)"
        }
    }
},
{
    "kretprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "pre": {
            "dql->limit": "= 0",
            "dql->num_queued": "= 0",
            "dql->num_completed": "= 0",
            "dql->last_obj_cnt": "= 0",
            "dql->prev_num_queued": "= 0",
            "dql->prev_last_obj_cnt": "= 0",
            "dql->prev_ovlimit": "= 0",
            "dql->lowest_slack": "= UINT_MAX",
            "dql->slack_start_time": "= jiffies"
        }
    }
},
{
    "kprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "pre": {
            "dql->limit": "= 0",
            "dql->num_queued": "= 0",
            "dql->num_completed": "= 0",
            "dql->last_obj_cnt": "= 0",
            "dql->prev_num_queued": "= 0",
            "dql->prev_last_obj_cnt": "= 0",
            "dql->prev_ovlimit": "= 0",
            "dql->lowest_slack": "= UINT_MAX",
            "dql->slack_start_time": "= jiffies"
        }
    }
},
{
    "kretprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap",
        "pre": {
            "n": ">=0",
            "mask": "!=null",
            "start": ">=0",
            "wrap": "bool"
        },
        "post": {
            "return": ">= nr_cpu_ids"
        }
    }
},
{
    "kprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap",
        "pre": {
            "n": ">= 0",
            "mask": "!= null",
            "start": ">= 0",
            "wrap": "boolean"
        },
        "post": {
            "return": ">= nr_cpu_ids"
        }
    }
},
{
    "kretprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node",
        "pre": {
            "mask": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",  // Please provide the complete list of GFP_ flags
            "node": "in [NUMA_NO_NODE, ...]"  // Please provide the complete list of memory nodes
        },
        "post": {
            "return": "in [TRUE, FALSE]",
            "mask": "null if return == FALSE"
        }
    }
},
{
    "kprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node",
        "pre": {
            "mask": "!=null",
            "flags": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask.",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask.",
        "pre": {
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_local_spread": {
        "description": "Select the i'th CPU based on NUMA distances",
        "pre": {
            "i": ">= 0",
            "node": ">= 0"
        }
    }
},
{
    "kprobe:cpumask_local_spread": {
        "description": "Select the i'th cpu based on NUMA distances",
        "pre": {
            "i": ">= 0",
            "node": ">= 0"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kretprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p.",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        },
        "post": {
            "return_value": ">= nr_cpu_ids"
        }
    }
},
{
    "kprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p.",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_any_distribute": {
        "description": "Find the next bit set in the cpumask after the previous position and update the distribute_cpu_mask_prev with the new value.",
        "pre": {
            "srcp": "!=null",
            "next": ">=0",
            "prev": ">=0",
            "distribute_cpu_mask_prev": "!=null",
            "nr_cpumask_bits": ">=0",
            "nr_cpu_ids": ">=0"
        }
    }
},
{
    "kprobe:cpumask_any_distribute": {
        "description": "Selects the next CPU from the given CPU mask for distribution.",
        "pre": {
            "__this_cpu_read(distribute_cpu_mask_prev)": "!=null",
            "find_next_bit_wrap(cpumask_bits(srcp), nr_cpumask_bit prev + 1)": "!=null",
            "next < nr_cpu_ids": "true",
            "__this_cpu_write(distribute_cpu_mask_prev, next)": "true"
        }
    }
},
{
    "kretprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR",
        "pre": {
            "dev": "!=null",
            "bar": ">=0",
            "offset": ">=0",
            "maxlen": ">=0"
        }
    }
},
{
    "kprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR",
        "pre": {
            "dev": "!=null",
            "bar": "!=null",
            "offset": "!=null",
            "maxlen": ">=0"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmap I/O or memory space for a PCI device.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmap I/O memory previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_raw": {
        "description": "Retrieve the raw object associated with the objagg_obj.",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_raw": {
        "description": "Get the raw object pointer from the objagg_obj structure.",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:if (!objagg->hints)": {
        "description": "Check if `objagg->hints` is not null.",
        "pre": {
            "objagg": {
                "hints": "==null"
            }
        }
    }
},
{
    "kprobe:if (!objagg->hints)": {
        "description": "Check if the `objagg` structure does not have any hints.",
        "pre": {
            "objagg": {
                "hints": "==null"
            }
        }
    }
},
{
    "kretprobe:objagg_create": {
        "description": "Creates a new objagg instance",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "any",
            "priv": "any"
        }
    }
},
{
    "kprobe:objagg_create": {
        "description": "Creates a new objagg instance",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "null or !=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance.",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kretprobe:objagg_hints_get": {
        "description": "Obtains hints instance",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "in [OBJAGG_OPT_ALGO_TYPE_1, OBJAGG_OPT_ALGO_TYPE_2, OBJAGG_OPT_ALGO_TYPE_3]"
        }
    }
},
{
    "kprobe:objagg_hints_get": {
        "description": "Obtains hints instance",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "in [OBJAGG_OPT_ALGO_TYPE_1, OBJAGG_OPT_ALGO_TYPE_2, OBJAGG_OPT_ALGO_TYPE_3]"
        }
    }
},
{
    "kretprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance",
        "pre": {
            "objagg_hints": "!=null"
        }
    }
},
{
    "kprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance",
        "pre": {
            "objagg_hints": "!=null"
        }
    }
},




{
    "kretprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1",
        "pre": {
            "r": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1.",
        "pre": {
            "r": "!=null",
            "*r": "!=null",
            "*r != 1": true
        }
    }
},
{
    "kprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1",
        "pre": {
            "r": "!=null",
            "*r": "!=null",
            "*r != 1": true
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:refcount_dec_and_mutex_lock": {
        "description": "Return holding mutex if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_and_mutex_lock": {
        "description": "Return holding mutex if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_and_lock": {
        "description": "Return holding spinlock if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_and_lock": {
        "description": "Return holding spinlock if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0.",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:parman_create": {
        "description": "creates a new parman instance",
        "pre": {
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:parman_create": {
        "description": "creates a new parman instance",
        "pre": {
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:parman_destroy": {
        "description": "Destroys an existing parman instance.",
        "pre": {
            "parman": "!=null"
        }
    }
},

{
    "kretprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": ">=0"
        }
    }
},
{
    "kprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": ">=0"
        }
    }
},


{
    "kretprobe:parman_item_add": {
        "description": "Adds a parman item under defined priority",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:parman_item_add": {
        "description": "Adds a parman item under defined priority.",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:parman_item_remove": {
        "description": "Deletes a parman item",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:parman_item_remove": {
        "description": "Deletes a parman item",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:packing": {
        "description": "Convert numbers between a packed and an unpacked format.",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">=0",
            "endbit": "<=startbit",
            "pbuflen": ">=0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        }
    }
},
{
    "kprobe:packing": {
        "description": "Convert numbers (currently u64) between a packed and an unpacked format.",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">=0",
            "endbit": "<=startbit",
            "pbuflen": ">0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        }
    }
},
{
    "kretprobe:ucs2_strncmp": {
        "description": "Compares two UCS2 strings up to a specified length.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": "!=null"
        },
        "post": {
            "return": "in [-1, 0, 1]",
            "a": "==0 implies b==0"
        }
    }
},
{
    "kprobe:ucs2_strncmp": {
        "description": "Compare two UCS2 strings up to a specified length.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:crc32c": {
        "description": "Calculate the CRC32C checksum.",
        "pre": {
            "crc": "!=null",
            "address": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kprobe:crc32c": {
        "description": "Calculate the CRC32C checksum.",
        "pre": {
            "crc": "!=null",
            "address": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their clas as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-type enforce relative levels by bitpos.",
        "pre": {
            "instr": "!=null",
            "kp": {
                "arg": {
                    "bitslvl": "!=null",
                    "map": "!=null",
                    "map_type": "!=null"
                }
            }
        },
        "post": {
            "return_value": "in [0, <0]"
        }
    }
},
{
    "kprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their clas as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-type enforce relative levels by bitpos.",
        "pre": {
            "instr": "!=null",
            "kp": {
                "arg": {
                    "bitslvl": "!=null",
                    "map": "!=null",
                    "map_type": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:param_get_dyndbg_classes": {
        "description": "classes reader",
        "pre": {
            "buffer": "!=null",
            "kp": "!=null",
            "kp->arg->state": "!=null",
            "kp->arg->state->bits": "!=null",
            "kp->arg->state->map": "!=null"
        }
    }
},
{
    "kprobe:param_get_dyndbg_classes": {
        "description": "classes reader",
        "pre": {
            "buffer": "!=null",
            "kp": {
                "arg": {
                    "state": "!=null",
                    "bits": "!=null",
                    "map": "!=null"
                }
            }
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range into kernel virtual memory.",
        "pre": {
            "offset": "!=null",
            "size": "!=null"
        }
    }
},



{
    "kretprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": ">=0",
            "end": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": ">=0",
            "end": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kretprobe:idr_for_each": {
        "description": "Iterate through all stored pointers in the IDR.",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:idr_for_each": {
        "description": "Iterate through all stored pointers.",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:idr_get_next_ul": {
        "description": "Find next populated entry.",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null",
            "*nextid": ">=0"
        }
    }
},
{
    "kprobe:idr_get_next_ul": {
        "description": "Find next populated entry.",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null",
            "*nextid": ">=0"
        }
    }
},
{
    "kretprobe:idr_replace": {
        "description": "Replace pointer for given ID.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:idr_replace": {
        "description": "Replace pointer for given ID.",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": "!=null"
        }
    }
},


{
    "kretprobe:lockref_get": {
        "description": "Increments reference count unconditionally",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_get": {
        "description": "Increments reference count unconditionally",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement",
        "pre": {
            "lockref": "!=null",
            "count": ">1"
        }
    }
},
{
    "kretprobe:lockref_put_return": {
        "description": "Decrement reference count if possible",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_put_return": {
        "description": "Decrement reference count if possible",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement.",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "count": "<=1",
            "lock": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement.",
        "pre": {
            "lockref": "!=null",
            "count": ">1"
        }
    }
},
{
    "kretprobe:lockref_mark_dead": {
        "description": "mark lockref dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_mark_dead": {
        "description": "Mark lockref dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead",
        "pre": {
            "lockref": "!=null"
        }
    }
},


{
    "kretprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "pre": {
            "table": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "pre": {
            "table": "!=null",
            "polynomial": "!=null"
        }
    }
},


{
    "kretprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject.",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject.",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kretprobe:kobject_add_internal": {
        "description": "Add a kobject internally.",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "!=null"
        }
    }
},
{
    "kprobe:if (kobj->kset)": {
        "description": "Check if the kobj has a kset.",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "!=null"
        }
    }
},
{
    "kretprobe:kobject_del": {
        "description": "Remove a kobject",
        "pre": {
            "kobj->state_add_uevent_sent": "==true",
            "kobj->state_remove_uevent_sent": "==false"
        }
    }
},
{
    "kprobe:kobject_del": {
        "description": "Delete a kernel object and send a 'remove' event if the caller did not do it but sent 'add'.",
        "pre": {
            "kobj->state_add_uevent_sent": "!=0",
            "!kobj->state_remove_uevent_sent": "!=0"
        }
    }
},
{
    "kretprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj.",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj.",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},


{
    "kretprobe:kset_register": {
        "description": "Initialize and add a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_register": {
        "description": "Initialize and add a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:kset_unregister": {
        "description": "Remove a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_unregister": {
        "description": "Remove a kset.",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value",
        "pre": {
            "ch": "!=null",
            "ch": "is_hex_digit"
        },
        "post": {
            "return": "in [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
        }
    }
},
{
    "kprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value",
        "pre": {
            "ch": "in [0x30 ... 0x39, 0x41 ... 0x46, 0x61 ... 0x66]"
        }
    }
},
{
    "kretprobe:hex2bin": {
        "description": "Convert an ASCII hexadecimal string to its binary representation.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:hex2bin": {
        "description": "Convert an ASCII hexadecimal string to its binary representation.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:bin2hex": {
        "description": "Convert binary data to an ASCII hexadecimal string.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:bin2hex": {
        "description": "Convert binary data to an ASCII hexadecimal string.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kretprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [DUMP_PREFIX_OFFSET, DUMP_PREFIX_ADDRES DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "boolean"
        }
    }
},
{
    "kprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [DUMP_PREFIX_OFFSET, DUMP_PREFIX_ADDRES DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "boolean"
        }
    }
},

{
    "kprobe:siphash_1u64": {
        "description": "Compute 64-bit siphash PRF value of a u64",
        "pre": {
            "first": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},


{
    "kretprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32.",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "pre": {
            "first": "!=null",
            "second": "!=null",
            "third": "!=null",
            "forth": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_register": {
        "description": "Register a textsearch module",
        "pre": {
            "ops": "!=null",
            "ops.name": "!=null",
            "ops.find": "!=null",
            "ops.init": "!=null",
            "ops.get_pattern": "!=null",
            "ops.get_pattern_len": "!=null"
        }
    }
},
{
    "kprobe:textsearch_register": {
        "description": "Register a textsearch module",
        "pre": {
            "ops": "!=null",
            "ops.name": "!=null",
            "ops.find": "!=null",
            "ops.init": "!=null",
            "ops.get_pattern": "!=null",
            "ops.get_pattern_len": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module",
        "pre": {
            "ops": "!=null"
        },
        "post": {
            "return_value": "in [0, -ENOENT]"
        }
    }
},
{
    "kprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module",
        "pre": {
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_destroy": {
        "description": "Notifies the algorithm to destroy algorithm-specific allocations.",
        "pre": {
            "conf": "!=null"
        }
    }
},

{
    "kretprobe:glob_match": {
        "description": "Shell-style pattern matching, like !fnmatch(pat, str, 0)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kprobe:glob_match": {
        "description": "Shell-style pattern matching, like !fnmatch(pat, str, 0)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "len": "!=null",
            "tab": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C",
        "pre": {
            "crc": "!=null",
            "p": "!=null",
            "len": "!=null",
            "tab": "!=null",
            "polynomial": "!=null"
        }
    }
},
{
    "kretprobe:gf2_multiply": {
        "description": "This multiplies the polynomials x and y modulo the given modulus.",
        "pre": {
            "x": "!=null",
            "y": "!=null",
            "modulus": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Perform IO operation with conditions.",
        "pre": {
            "addr": "!=null",
            "outb(val,port)": "!=null",
            "writeb(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite16": {
        "description": "Write 16-bit value to IO memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=0"
        }
    },
    "kprobe:IO_COND": {
        "description": "Perform IO operation conditionally.",
        "pre": {
            "addr": "!=null",
            "outb(val,port)": "!=null",
            "writeb(val, addr)": "!=null"
        }
    },
    "kprobe:iowrite16": {
        "description": "Write 16-bit value to IO address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite16be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "==u16",
            "addr_type": "==void __iomem *",
            "val_uninitialized": "==false"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check memory for uninitialized values.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "sizeof(u16)"
        }
    },
    "kprobe:IO_COND": {
        "description": "Perform IO operation conditionally.",
        "pre": {
            "addr": "!=null",
            "outw(val,port)": "initialized",
            "writew(val, addr)": "initialized"
        }
    },
    "kprobe:iowrite16be": {
        "description": "Write 16-bit value to IO memory.",
        "pre": {
            "val": "initialized",
            "addr": "!=null",
            "typeof(val)": "u16",
            "typeof(addr)": "void __iomem *"
        }
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Condition for IO operation.",
        "pre": {
            "addr": "!=null",
            "pio_write16be(val,port)": "!=null",
            "mmio_write16be(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite32": {
        "description": "Write 32-bit value to a memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "initialized",
            "addr": "used"
        }
    },
    "kretprobe:iowrite32be": {
        "description": "No specific conditions mentioned in the provided documentation."
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u32",
            "addr_type": "void __iomem *",
            "sizeof_val": ">0"
        }
    }
},


{
    "kretprobe:iowrite64_hi_lo": {
        "description": "Ensure uninitialized memory is not copied to devices using the iowrite64_lo_hi helper function.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "initialized"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Conditionally execute pio_write64_hi_lo(val, port) or writeq(val, addr).",
        "pre": {
            "condition": "placeholder"
        }
    },
    "kretprobe:iowrite64be_lo_hi": {
        "description": "",
        "pre": {
            "condition": "true"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:iowrite64_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:IO_COND": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "addr": "!=null",
            "val": "!=null",
            "port": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *",
            "port_type": "unknown"
        }
    },
    "kprobe:writeq": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    },
    "kprobe:iowrite64be_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "addr": "!=null",
            "val_type": "u64",
            "addr_type": "void __iomem *"
        }
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=null",
            "sizeof(val)": "!=null"
        }
    },
    "kretprobe:IO_COND": {
        "description": "Perform IO conditional operation.",
        "pre": {
            "addr": "!=null",
            "pio_write64be_lo_hi(val, port)": "!=null",
            "mmio_write64be(val, addr)": "!=null"
        }
    },
    "kretprobe:iowrite64be_hi_lo": {
        "description": "Write 64-bit value to a memory address.",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null"
        }
    },
    "kprobe:pio_write64be_hi_lo": {
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null",
            "port": "!=null"
        }
    },
    "kprobe:mmio_write64be": {
        "pre": {
            "val": "!=uninitialized",
            "addr": "!=null"
        }
    },
    "EXPORT_SYMBOL:iowrite64_lo_hi": {},
    "EXPORT_SYMBOL:iowrite64_hi_lo": {},
    "EXPORT_SYMBOL:iowrite64be_lo_hi": {},
    "EXPORT_SYMBOL:iowrite64be_hi_lo": {}
},





{
    "kprobe:kmsan_unpoison_memory": {
        "description": "Unpoison the memory range specified by *dst* and *count*.",
        "pre": {
            "dst": "!=null",
            "count": "!=null",
            "count * 4": ">=0"
        }
    }
},




{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": "!=null",
            "addr": "is a valid memory address",
            "src": "is a valid memory address",
            "count": "is a positive integer"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "pre": {
            "src": "!=null",
            "count": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(ioport_map)": {
        "description": "Maps an I/O port to a memory address.",
        "pre": {
            "port": "!=null",
            "nr": "!=null",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(ioport_map)": {
        "description": "Map an I/O port to a memory-mapped I/O pointer.",
        "pre": {
            "port": "!=null",
            "nr": "!=null",
            "return_value": "!=null"
        }
    }
},


{
    "kretprobe:pci_iounmap": {
        "description": "Unmap an I/O memory region previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmap an I/O memory region previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},

{
    "kprobe:unsafe_get_user": {
        "description": "Copy a string from user space to kernel space, ensuring NUL termination.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0",
            "max": ">=0"
        }
    }
},
{
    "kretprobe:xxh32_reset": {
        "description": "Reset the xxh32 state with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        },
        "post": {
            "statePtr": "contains valid xxh32_state data"
        }
    }
},
{
    "kprobe:xxh32_reset": {
        "description": "Reset the state of xxh32_state using the provided seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},
{
    "kretprobe:xxh64_reset": {
        "description": "Reset the xxh64_state structure with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},
{
    "kprobe:xxh64_reset": {
        "description": "Reset the xxh64_state structure with the given seed.",
        "pre": {
            "statePtr": "!=null",
            "seed": "!=null"
        }
    }
},




{
    "kretprobe:memcpy": {
        "description": "Copy `len` bytes from `input` to `((uint8_t *)state->mem64) + state->memsize` and update `state->memsize`.",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": "!=null",
            "state->mem64": "!=null",
            "state->memsize": "!=null",
            "state->memsize + len < 32": "true"
        },
        "post": {
            "state->memsize": "state->memsize + len"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy `len` bytes from `input` to `state->mem64 + state->memsize`.",
        "pre": {
            "state": "!=null",
            "state->mem64": "!=null",
            "state->memsize": "!=null",
            "input": "!=null",
            "len": "!=null",
            "len": ">0"
        }
    }
},
{
    "kretprobe:memweight": {
        "description": "Count the total number of bits set in memory area",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:memweight": {
        "description": "Count the total number of bits set in memory area.",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "pre": {
            "node": "!=null",
            "tag": "unsigned int"
        }
    }
},
{
    "kprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "pre": {
            "node": "!=null",
            "tag": ">=0"
        }
    }
},
{
    "kretprobe:radix_tree_maybe_preload": {
        "description": "Preload radix tree if gfp_mask allows blocking.",
        "pre": {
            "gfp_mask": "!=null",
            "gfp_mask": "in [gfpflags_allow_blocking(gfp_mask)]",
            "return_value": "==0"
        }
    }
},
{
    "kprobe:radix_tree_maybe_preload": {
        "description": "Preload radix tree if `gfp_mask` allows blocking, otherwise skip preloading.",
        "pre": {
            "gfp_mask": "!=null",
            "gfpflags_allow_blocking(gfp_mask)": "true",
            "__radix_tree_preload(gfp_mask, RADIX_TREE_PRELOAD_SIZE)": "!=null",
            "return value": "0"
        }
    }
},
{
    "kretprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_lookup_slot": {
        "description": "Look up a slot in a radix tree based on the given index.",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:radix_tree_lookup_slot": {
        "description": "Look up a slot in the radix tree based on the given index.",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "nodep": "!=null",
            "slotp": "!=null"
        }
    }
},
{
    "kprobe:__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "nodep": "!=null",
            "slotp": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tag_set": {
        "description": "Set a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "in [0, RADIX_TREE_MAX_TAGS)"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tag_set": {
        "description": "Set a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "in [0, RADIX_TREE_MAX_TAGS)"
        }
    }
},
{
    "kretprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node.",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "tag": "!=null",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:radix_tree_next_chunk": {
        "description": "Find next chunk of slots for iteration",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "in [RADIX_TREE_ITER_]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_next_chunk": {
        "description": "Find the next chunk of slots for iteration.",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_replace_slot": {
        "description": "Replace a slot in a radix tree with a new item.",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        },
        "post": {
            "root": "unchanged",
            "slot": "unchanged",
            "item": "changed"
        }
    }
},
{
    "kprobe:radix_tree_replace_slot": {
        "description": "Replace the slot in the radix tree.",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        },
        "post": {
            "success": true
        }
    }
},
{
    "kretprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at this iterator position",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at this iterator position.",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_delete_item": {
        "description": "Delete an item from a radix tree",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_delete_item": {
        "description": "Delete an item from a radix tree",
        "pre": {
            "root": "!=null",
            "index": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "pre": {
            "root": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "pre": {
            "root": "!=null",
            "tag": "!=null"
        }
    }
},
{
    "kretprobe:idr_preload": {
        "description": "Preload for idr_alloc()",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:idr_preload": {
        "description": "Preload for idr_alloc().",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR",
        "pre": {
            "idr": "!=null"
        }
    }
},
{
    "kprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR",
        "pre": {
            "idr": "!=null"
        }
    }
},


{
    "kretprobe:argv_free": {
        "description": "Free an argv and the strings it points to.",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kprobe:argv_free": {
        "description": "Free an argv",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kretprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv",
        "pre": {
            "gfp": "!=null",
            "str": "!=null",
            "argcp": "!=null"
        }
    }
},
{
    "kprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv",
        "pre": {
            "gfp": "!=null",
            "str": "!=null",
            "argcp": "!=null"
        }
    }
},
{
    "kretprobe:xa_load": {
        "description": "Load an entry from an XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:xa_load": {
        "description": "Load an entry from an XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:__xa_store": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_store": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "old": "!=null",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // Add more possible values for gfp_t if needed
        }
    }
},
{
    "kprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "old": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENOMEM]"
        }
    }
},
{
    "kprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray.",
        "pre": {
            "xa": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray.",
        "pre": {
            "xa": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:xa_get_order": {
        "description": "Get the order of an entry.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "index": "<=63"
        }
    }
},
{
    "kprobe:xa_get_order": {
        "description": "Get the order of an entry.",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "index": "<=63"
        }
    }
},
{
    "kretprobe:__xa_alloc": {
        "description": "__xa_alloc() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_alloc": {
        "description": "__xa_alloc() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_alloc_cyclic": {
        "description": "Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "next": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__xa_alloc_cyclic": {
        "description": "__xa_alloc_cyclic() - Find somewhere to store this entry in the XArray.",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": {
                "min": "!=null",
                "max": "!=null"
            },
            "next": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry.",
        "pre": {
            "xa": "!=null",
            "index": "!=null",
            "mark": "!=null"
        }
    }
},
{
    "kretprobe:xa_find": {
        "description": "Search the XArray for an entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kprobe:xa_find": {
        "description": "Search the XArray for an entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kretprobe:xa_find_after": {
        "description": "Search the XArray for a present entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "!=null"
        }
    }
},
{
    "kprobe:xa_find_after": {
        "description": "Search the XArray for a present entry.",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": "!=null",
            "filter": "!=null"
        }
    }
},
{
    "kretprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array.",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=0",
            "n": ">=0",
            "filter": ">=0"
        }
    }
},
{
    "kprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array.",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=start",
            "n": ">=0",
            "filter": "in [XA_PRESENT, xa_mark_t]"
        }
    }
},
{
    "kretprobe:xa_destroy": {
        "description": "Free all internal data structures.",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kprobe:xa_destroy": {
        "description": "Free all internal data structures.",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kretprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes.",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes.",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again",
        "pre": {
            "iop": "!=null",
            "interrupts_disabled": "true"
        }
    }
},
{
    "kprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again",
        "pre": {
            "iop": "!=null",
            "interrupts_disabled": "true"
        }
    }
},
{
    "kretprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop.",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "pre": {
            "iop": "!=null",
            "weight": "!=null",
            "poll_fn": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "pre": {
            "iop": "!=null",
            "weight": ">=0",
            "poll_fn": "!=null"
        }
    }
},


{
    "kretprobe:memparse": {
        "description": "Parse a string with mem suffixes into a number",
        "pre": {
            "ptr": "!=null",
            "retptr": "!=null"
        }
    }
},
{
    "kprobe:memparse": {
        "description": "Parse a string with mem suffixes into a number",
        "pre": {
            "ptr": "!=null",
            "retptr": "!=null"
        }
    }
},
{
    "kretprobe:if (**val == '\"')": {
        "description": "Check if the value pointed to by val is equal to '\"'.",
        "pre": {
            "val": "== '\"'"
        }
    }
},
{
    "kprobe:if (**val == '\"')": {
        "description": "Check if the value pointed to by val is equal to '\"'.",
        "pre": {
            "val": "== '\"'"
        }
    }
},
{
    "kretprobe:generate_random_uuid": {
        "description": "Generate a random UUID",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kprobe:generate_random_uuid": {
        "description": "Generate a random UUID",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:generate_random_guid": {
        "description": "Set GUID version to 4 - truly random generation",
        "pre": {
            "guid": "!=null"
        }
    }
},
{
    "kprobe:generate_random_guid": {
        "description": "Set GUID version to 4 - truly random generation",
        "pre": {
            "guid": "!=null"
        }
    }
},
{
    "kretprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid",
        "pre": {
            "uuid": "!=null",
            "uuid_format": "matches regex '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'"
        },
        "post": {
            "return_value": "==true"
        }
    }
},
{
    "kprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid",
        "pre": {
            "uuid": "!=null",
            "uuid_format": "matches regex: ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list.",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list.",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:sg_nents_for_len": {
        "description": "Return total count of entries in scatterlist needed to satisfy the supplied length.",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:sg_nents_for_len": {
        "description": "Return total count of entries in scatterlist needed to satisfy the supplied length.",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list",
        "pre": {
            "sgl": "!=null",
            "nents": "!=null"
        }
    }
},
{
    "kretprobe:sg_init_table": {
        "description": "Initialize SG table",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kprobe:sg_init_table": {
        "description": "Initialize SG table",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kretprobe:sg_init_one": {
        "description": "Initialize a single entry sg list",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_init_one": {
        "description": "Initialize a single entry sg list",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},

{
    "kprobe:__sg_free_table": {
        "description": "Free the scatterlist table and associated resources.",
        "pre": {
            "table": "!=null",
            "max_ents": "!=null",
            "nents_first_chunk": "!=null",
            "free_fn": "!=null",
            "num_ents": "!=null",
            "max_ents": "== previously used value with __sg_alloc_table()"
        }
    }
},
{
    "kretprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kretprobe:sg_kmalloc": {
        "description": "Allocate memory for scatterlist entries.",
        "pre": {
            "nents": ">= 0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},

{
    "kretprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "left_pages": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "left_pages": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment.",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">=0",
            "offset": ">=0",
            "size": ">=0",
            "max_segment": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": ">=1",
            "order": ">=0",
            "chainable": "in [true, false]",
            "gfp": "not null",
            "nent_p": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": ">=1",
            "order": ">=0",
            "chainable": "bool",
            "gfp": "valid memory allocation flags",
            "nent_p": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kretprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": "!=null",
            "gfp": "!=null",
            "nent_p": "!=null"
        }
    }
},
{
    "kprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages.",
        "pre": {
            "length": "!=null",
            "gfp": "!=null",
            "nent_p": "!=null"
        }
    }
},
{
    "kretprobe:sg_miter_start": {
        "description": "Start mapping iteration over a sg list",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:sg_miter_start": {
        "description": "Start mapping iteration over a sg list",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:sg_miter_skip": {
        "description": "This function stops the sg_mapping_iter at the specified offset.",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:sg_miter_skip": {
        "description": "Stops the sg_mapping_iter and checks if it contains a valid mapping.",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping.",
        "pre": {
            "miter": "!=null",
            "miter->page": "!=null",
            "miter->addr": "!=null",
            "miter->length": "!=null"
        }
    }
},
{
    "kprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping.",
        "pre": {
            "miter": "!=null",
            "miter->page": "!=null",
            "miter->addr": "!=null",
            "miter->length": "!=null"
        }
    }
},
{
    "kretprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kretprobe:stmp_clear_poll_bit": {
        "description": "Clear and poll the SFTRST bit in the reset address.",
        "pre": {
            "reset_addr": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:stmp_clear_poll_bit": {
        "description": "Clear and poll the SFTRST bit in the reset address.",
        "pre": {
            "reset_addr": "!=null"
        }
    }
},
{
    "kretprobe:stack_depot_set_extra_bits": {
        "description": "Set extra bits on a stack depot handle.",
        "pre": {
            "handle": "!=null",
            "extra_bits": "unsigned int"
        }
    }
},
{
    "kprobe:stack_depot_set_extra_bits": {
        "description": "Set extra bits for stack depot handle",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:mtee_store_range": {
        "description": "Store an entry at a given range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:mtee_store_range": {
        "description": "Store an entry at a given range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtee_insert_range": {
        "description": "Insert an entry at a given range if there is no value.",
        "pre": {
            "mt": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null",
            "mt": "is struct maple_tree",
            "first": "is unsigned long",
            "last": "is unsigned long",
            "entry": "is void*",
            "gfp": "is gfp_t"
        },
        "post": {
            "return": "in [0, -EEXIST -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:mtee_insert_range": {
        "description": "Insert an entry at a given range if there is no value.",
        "pre": {
            "mt": "!=null",
            "first": "!=null",
            "last": "!=null",
            "entry": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_alloc_range": {
        "description": "Allocate a range in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mtree_alloc_range": {
        "description": "Allocate a range in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_alloc_rrange": {
        "description": "Allocate a range of memory in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mtree_alloc_rrange": {
        "description": "Allocate a range of memory in the maple_tree.",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "!=null",
            "min": "!=null",
            "max": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:mtree_erase": {
        "description": "Find an index and erase the entire range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:mtree_erase": {
        "description": "Find an index and erase the entire range.",
        "pre": {
            "mt": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:mtree_destroy": {
        "description": "Destroy a maple tree",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kprobe:mtree_destroy": {
        "description": "Destroy a maple tree",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kretprobe:mt_find": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:mt_find": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found.",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:errseq_set": {
        "description": "Set an errseq_t for later reporting.",
        "pre": {
            "eseq": "!=null",
            "err": ">= -1",
            "err": "<= -MAX_ERRNO"
        },
        "post": {
            "return": ">= -MAX_ERRNO",
            "return": "<= -1"
        }
    }
},
{
    "kprobe:errseq_set": {
        "description": "Set a errseq_t for later reporting",
        "pre": {
            "eseq": "!=null",
            "err": ">= -1",
            "err": "<= -MAX_ERRNO"
        }
    }
},
{
    "kretprobe:errseq_sample": {
        "description": "Grab current errseq_t value.",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kprobe:errseq_sample": {
        "description": "Grab current errseq_t value.",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kretprobe:errseq_check": {
        "description": "Has an error occurred since a particular sample point?",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [0, !=since]"
        }
    }
},
{
    "kprobe:errseq_check": {
        "description": "Has an error occurred since a particular sample point?",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value.",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value.",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        }
    }
},
{
    "kretprobe:lc_create": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on succes or NULL on (allocation) failure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">=0",
            "e_off": ">=0"
        }
    }
},
{
    "kprobe:lc_create": {
        "description": "Creates a new lru_cache structure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">=0",
            "e_off": ">=0"
        }
    }
},
{
    "kretprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots.",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots.",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create()",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create().",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_del": {
        "description": "Removes an element from the cache",
        "pre": {
            "lc": "!=null",
            "e": "!=null",
            "e.refcnt": "==0",
            "e.lru": "!=null",
            "e.free": "!=null",
            "e.enr": "==LC_FREE"
        }
    }
},
{
    "kprobe:lc_del": {
        "description": "Removes an element from the cache.",
        "pre": {
            "lc": "!=null",
            "e": "!=null",
            "e->refcnt": "==0",
            "e->enr": "==LC_FREE"
        }
    }
},
{
    "kretprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return": {
                "constraints": "in [null, not in active set, pointer to element with requested element number]",
                "description": "The return value can be null if the cache is marked as LC_STARVING, or if the requested label is not in the active set. Otherwise, it should be a pointer to the element with the requested element number."
            }
        }
    }
},
{
    "kprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return": "in [null, !=null]"
        }
    }
},
{
    "kretprobe:lc_find": {
        "description": "Find element by label, if present in the hash table.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null",
            "include_changing": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:lc_find": {
        "description": "Find element by label, if present in the hash table.",
        "pre": {
            "lc": "!=null",
            "enr": "!=null",
            "include_changing": "!=null"
        }
    }
},
{
    "kretprobe:seq_printf": {
        "description": "Print formatted output to a sequence file.",
        "pre": {
            "seq": "!=null",
            "lc": "!=null",
            "lc->name": "!=null",
            "lc->used": "!=null",
            "lc->nr_elements": "!=null",
            "lc->hits": "!=null",
            "lc->misses": "!=null",
            "lc->starving": "!=null",
            "lc->locked": "!=null",
            "lc->changed": "!=null"
        }
    }
},
{
    "kprobe:seq_printf": {
        "description": "Prints formatted output to a sequence file.",
        "pre": {
            "seq": "!=null",
            "lc": {
                "name": "!=null",
                "used": ">=0",
                "nr_elements": ">=0",
                "hits": ">=0",
                "misses": ">=0",
                "starving": ">=0",
                "locked": ">=0",
                "changed": ">=0"
            },
            "enr": ">=0"
        }
    }
},
{
    "kretprobe:lc_put": {
        "description": "Give up refcnt of @e",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        }
    }
},
{
    "kprobe:lc_put": {
        "description": "Give up refcnt of @e",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        }
    }
},


{
    "kretprobe:lc_element_by_index": {
        "description": "Return the element at the specified index in the LRU cache.",
        "pre": {
            "lc": "!=null",
            "i": ">=0"
        }
    }
},
{
    "kprobe:lc_element_by_index": {
        "description": "Return the element at the specified index in the lru cache.",
        "pre": {
            "lc": "!=null",
            "i": ">=0"
        }
    }
},
{
    "kretprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "pre": {
            "lc": "!=null"
        },
        "post": {
            "val": "==0"
        }
    }
},
{
    "kprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "pre": {
            "lc": "!=null"
        }
    },
    "kprobe:return 0 == val;}/** * lc_create - prepares to track objects in an active set * @name: descriptive name only used in lc_seq_printf_stats and lc_seq_dump_details * @cache: cache root pointer * @max_pending_changes: maximum changes to accumulate until a transaction is required * @e_count: number of elements allowed to be active simultaneously * @e_size: size of the tracked objects * @e_off: offset to the &struct lc_element member in a tracked object * * Returns a pointer to a newly initialized struct lru_cache on succes * or NULL on (allocation) failure.": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on succes or NULL on (allocation) failure.",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": "!=null",
            "e_count": "!=null",
            "e_size": "!=null",
            "e_off": "!=null"
        }
    }
},
{
    "kretprobe:lc_is_used": {
        "description": "Find element by label",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kprobe:lc_is_used": {
        "description": "Find element by label",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kretprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        },
        "post": {
            "return_value": "!=null",
            "to_be_changed_element": "!=null"
        }
    }
},
{
    "kprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements",
        "pre": {
            "lc": "!=null",
            "enr": "!=null"
        }
    }
},
{
    "kretprobe:__acquire(once_lock);return false;}return true;}EXPORT_SYMBOL(__do_once_start": {
        "description": "__do_once_start function with __acquire(once_lock) helper",
        "pre": {
            "done": "==false",
            "flags": ">=0",
            "once_lock": "!=null"
        }
    }
},
{
    "kprobe:__acquire(once_lock);return false;}return true;}EXPORT_SYMBOL(__do_once_start": {
        "description": "__do_once_start function with acquire once_lock",
        "pre": {
            "done": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:__do_once_done": {
        "description": "__do_once_done but return early in the DO_ONCE() macro.",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null",
            "once_lock": "!=null"
        },
        "post": {
            "return": "in [false, true]"
        }
    }
},
{
    "kprobe:__do_once_done": {
        "description": "Return early in the DO_ONCE() macro.",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null",
            "once_lock": "!=null"
        }
    }
},
{
    "kretprobe:__do_once_sleepable_start": {
        "description": "__do_once_sleepable_start function",
        "pre": {
            "__acquire(once_mutex)": "true",
            "return": "false"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:__acquire(once_mutex);return false;}return true;}EXPORT_SYMBOL(__do_once_sleepable_start": {
        "description": "This function acquires the once_mutex and returns false. If the 'done' parameter is true, it unlocks the once_mutex and restores an even lock count. If the 'done' parameter is false, it returns true.",
        "pre": {
            "once_mutex": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_create": {
        "description": "Create a new special memory pool",
        "pre": {
            "min_alloc_order": "!=null",
            "nid": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_create": {
        "description": "Create a new special memory pool",
        "pre": {
            "min_alloc_order": "!=null",
            "nid": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the specified pool.",
        "pre": {
            "pool": "!=null",
            "virt": "!=null",
            "phys": "!=null",
            "size": "!=null",
            "nid": "int",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the specified pool.",
        "pre": {
            "pool": "!=null",
            "virt": "!=null",
            "phys": "!=null",
            "size": "!=null",
            "nid": "int",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_virt_to_phys": {
        "description": "Return the physical address of memory",
        "pre": {
            "pool": "!=null",
            "addr": "!=null"
        },
        "post": {
            "return": ">=0 || ==-1"
        }
    }
},
{
    "kprobe:gen_pool_virt_to_phys": {
        "description": "Return the physical address of memory.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_destroy": {
        "description": "destroy a special memory pool",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_destroy": {
        "description": "Destroy the specified special memory pool. Verifies that there are no outstanding allocations.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate special memory from the pool",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "algo": "!=null",
            "data": "!=null",
            "owner": "optional"
        }
    }
},
{
    "kprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate special memory from the pool",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "algo": "!=null",
            "data": "!=null",
            "owner": "optional"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate special memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "align": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate special memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "align": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc": {
        "description": "Allocate special zeroed memory from the pool for DMA usage.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc": {
        "description": "Allocate special zeroed memory from the pool for DMA usage.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm.",
        "pre": {
            "pool": "!=null",
            "size": "!=null",
            "dma": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "align": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given alignment.",
        "pre": {
            "pool": "!=null",
            "size": ">=0",
            "dma": "!=null",
            "align": ">=0"
        }
    }
},
{
    "kretprobe:gen_pool_free_owner": {
        "description": "Free allocated special memory back to the pool.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_free_owner": {
        "description": "Free allocated special memory back to the pool.",
        "pre": {
            "pool": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_for_each_chunk": {
        "description": "Call func for every chunk of generic memory pool",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_for_each_chunk": {
        "description": "Call func for every chunk of generic memory pool.",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_has_addr": {
        "description": "Checks if an address falls within the range of a pool",
        "pre": {
            "pool": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_has_addr": {
        "description": "Checks if an address falls within the range of a pool.",
        "pre": {
            "pool": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm for the pool.",
        "pre": {
            "pool": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm for the pool.",
        "pre": {
            "pool": "!=null",
            "algo": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "!=null",
            "pool": "!=null",
            "start_addr": "not used in this function"
        }
    }
},
{
    "kprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "!=null",
            "pool": "!=null",
            "start_addr": "not used in this function"
        }
    }
},
{
    "kretprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kretprobe:gen_pool_best_fit": {
        "description": "Find the best fitting region of memory matching the size requirement (no alignment constraint).",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kprobe:gen_pool_best_fit": {
        "description": "Find the best fitting region of memory matching the size requirement (no alignment constraint).",
        "pre": {
            "map": "!=null",
            "size": "!=null",
            "start": "!=null",
            "nr": "!=null",
            "data": "unused",
            "pool": "!=null",
            "start_addr": "unused"
        }
    }
},
{
    "kretprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmalloc/free interface. The pool will be automatically destroyed by the device management code.",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmalloc/free interface. The pool will be automatically destroyed by the device management code.",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:match_token": {
        "description": "Find a token (and optional args) in a string",
        "pre": {
            "s": "!=null",
            "table": "!=null",
            "args": "!=null",
            "table.pattern": "!=null",
            "table.pattern[MAX_OPT_ARGS]": "!=null",
            "args[MAX_OPT_ARGS]": "!=null"
        }
    }
},
{
    "kprobe:match_token": {
        "description": "Find a token (and optional args) in a string",
        "pre": {
            "s": "!=null",
            "table": "!=null",
            "args": "!=null",
            "table.pattern": "==null",
            "table.pattern[MAX_OPT_ARGS]": "==null"
        }
    }
},
{
    "kretprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is_integer"
        }
    }
},
{
    "kprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "==0"
        }
    }
},
{
    "kprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_u64int": {
        "description": "scan a number in the given base from a substring_t",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "!=null"
        },
        "post": {
            "result": "=0 if successful, =-EINVAL or =-ERANGE on failure",
            "result": ">=INT_MIN",
            "result": "<=INT_MAX"
        }
    }
},
{
    "kprobe:match_u64int": {
        "description": "scan a number in the given base from a substring_t",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "in [2, 8, 10, 16]"
        }
    }
},
{
    "kretprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is an integer",
            "return": "in [0, -EINVAL, -ERANGE]"
        }
    }
},
{
    "kprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "result": "is an integer",
            "return": "in [0, -EINVAL, -ERANGE]"
        }
    }
},
{
    "kprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer.",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        }
    }
},
{
    "kretprobe:match_wildcard": {
        "description": "Parse the string @str to check if it matches the wildcard pattern @pattern.",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:match_wildcard": {
        "description": "Parse the string @str to check if it matches the wildcard pattern @pattern.",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:match_strdup": {
        "description": "Allocate a new string with the contents of a substring_t",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:match_strdup": {
        "description": "Allocate a new string with the contents of a substring_t",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kretprobe:debug_percpu_counter_activate": {
        "description": "Activate the debug object for the percpu_counter",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:debug_percpu_counter_activate": {
        "description": "Activates the debug object for the percpu_counter.",
        "pre": {
            "fbc": "!=null"
        }
    }
},


{
    "kretprobe:size = roundup_pow_of_two(size);fifo->in = 0;fifo->out = 0;fifo->esize = esize;if (size < 2)": {
        "description": "Allocate memory for a FIFO buffer and initialize its properties.",
        "pre": {
            "fifo": "!=null",
            "size": "!=null",
            "esize": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:size = roundup_pow_of_two(size);fifo->in = 0;fifo->out = 0;fifo->esize = esize;if (size < 2)": {
        "description": "Allocate memory for a FIFO buffer and initialize its properties.",
        "pre": {
            "size": "!=null",
            "fifo->in": "= 0",
            "fifo->out": "= 0",
            "fifo->esize": "= esize",
            "size < 2": "true"
        }
    }
},
{
    "kretprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copy the string pointed to by `src` to `dest`.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "tmp": "!=null"
        }
    }
},
{
    "kprobe:strcpy": {
        "description": "Copy the string from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:unalign_check": {
        "description": "Check if the source address is unaligned",
        "pre": {
            "src": "!=null",
            "(long)src & (sizeof(long) - 1)": "!= 0"
        }
    }
},
{
    "kprobe:if ((long)src & (sizeof(long) - 1))": {
        "description": "Check if the source address is aligned to the size of a long integer.",
        "pre": {
            "src": "!=null",
            "sizeof(long)": "!=null",
            "((long)src & (sizeof(long) - 1))": "!=0"
        }
    }
},
{
    "kretprobe:stpcpy": {
        "description": "Copy a string from src to dest, returning a pointer to the new end of dest, including src's %NUL-terminator. May overrun dest.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest_size": ">=": "strlen(src) + 1"
        }
    }
},
{
    "kprobe:stpcpy": {
        "description": "Copy a string from src to dest, returning a pointer to the new end of dest.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest_size": ">=": "strlen(src) + 1"
        }
    }
},
{
    "kretprobe:strlcat": {
        "description": "Concatenate two strings with a size limit.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "dsize": ">=0",
            "len": ">=0",
            "res": ">=0",
            "BUG_ON(dsize >= count)": "true",
            "dest += dsize": "true",
            "count -= dsize": "true",
            "len >= count": "true",
            "len = count-1": "true",
            "__builtin_memcpy(dest, src, len)": "true",
            "dest[len] = 0": "true"
        }
    }
},
{
    "kprobe:strlcat": {
        "description": "Concatenates the source string to the destination string with a size limit.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "!=null",
            "dsize": ">=0",
            "len": ">=0",
            "res": ">=0",
            "dsize": "<=count",
            "len": "<=count-1"
        }
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:strchr": {
        "description": "Find the first occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strchr": {
        "description": "Find the first occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "pre": {
            "s": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": ">=0"
        }
    }
},
{
    "kprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": ">=0"
        }
    }
},
{
    "kretprobe:strnlen": {
        "description": "Calculate the length of a string, up to a maximum count.",
        "pre": {
            "s": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": ">=0",
            "return": "<=count"
        }
    }
},
{
    "kprobe:strnlen": {
        "description": "Calculate the length of a string, up to a maximum count.",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "sc": "!=null",
            "sc != '\\0'": true
        }
    }
},
{
    "kretprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contains letters in @accept.",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contains letters in @accept.",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kretprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject.",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kretprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strsep": {
        "description": "Split a string into tokens",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strsep": {
        "description": "Split a string into tokens",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Fill a region of memory with the given value",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Fill a region of memory with the given value",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:memset16": {
        "description": "Fill a memory area with a uint16_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memset16": {
        "description": "Fill a memory area with a uint16_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memset32": {
        "description": "Fill a memory area with a uint32_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memset32": {
        "description": "Fill a memory area with a uint32_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memset64": {
        "description": "Fill a memory area with a uint64_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memset64": {
        "description": "Fill a memory area with a uint64_t",
        "pre": {
            "s": "!=null",
            "v": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memmove": {
        "description": "Copy one area of memory to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memmove": {
        "description": "Copy one area of memory to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">0"
        }
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "addr": "!=null",
            "c": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [addr, addr + size]"
        }
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "addr": "!=null",
            "c": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory.",
        "pre": {
            "start": "!=null",
            "c": "!=null",
            "bytes": "!=null"
        }
    }
},
{
    "kprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory.",
        "pre": {
            "start": "!=null",
            "c": "!=null",
            "bytes": "!=null"
        }
    }
},
{
    "kretprobe:check_signature": {
        "description": "Perform a signature comparison with the mmio address io_addr. Returns 1 on a match.",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:check_signature": {
        "description": "Perform a signature comparison with the mmio address io_addr. Returns 1 on a match.",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:bsearch": {
        "description": "Binary search an array of elements.",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp": "!=null"
        }
    }
},
{
    "kprobe:bsearch": {
        "description": "Binary search an array of elements.",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp": "!=null"
        }
    }
},
{
    "kretprobe:atomic_add_unless": {
        "description": "Subtract 1 from counter unless that drops it to 0 (i.e., it was 1)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:atomic_add_unless": {
        "description": "Subtract 1 from counter unless that drops it to 0 (i.e., it was 1)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:__sum16 ip_fast_csum": {
        "description": "Checksum computation optimized for IP headers on 4 octet boundaries.",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0"
        }
    }
},
{
    "kprobe:__sum16 ip_fast_csum": {
        "description": "Compute the checksum for IP headers on 4 octet boundaries.",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0"
        }
    }
},
{
    "kretprobe:result += sum;if (sum > result)result += 1;return (__force __wsum)result;}EXPORT_SYMBOL(csum_partial": {
        "description": "Calculate the checksum of a buffer and update the result.",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": "!=null"
        }
    }
},
{
    "kprobe:result += sum;if (sum > result)result += 1;return (__force __wsum)result;}EXPORT_SYMBOL(csum_partial": {
        "description": "Calculate the checksum of a buffer and update the result.",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": ">=0",
            "sum": ">=0",
            "result": ">=0"
        }
    }
},
{
    "kretprobe:from64to32": {
        "description": "Add up 32-bit and 32-bit for 32+c bit.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:x = (x & 0xffffffff) + (x >> 32);/* add up carry.. */": {
        "description": "Add up the carry of 32-bit and 32-bit for 32+c bit.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:sibling = parent->rb_right;if (node != sibling)": {
        "description": "This condition checks if the 'node' is not equal to 'sibling' in the given function.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "node": "!=null",
            "sibling": "!=null",
            "tmp1": "!=null",
            "tmp2": "!=null",
            "node_color": "in [BLACK, NULL]",
            "parent_color": "in [BLACK, NULL]",
            "sibling_color": "in [BLACK, NULL]",
            "tmp1_color": "in [BLACK, NULL]",
            "tmp2_color": "in [BLACK, NULL]",
            "root_color": "in [BLACK, NULL]",
            "node_is_root": "in [true, false]",
            "node_is_leaf": "in [true, false]",
            "sibling_is_root": "in [true, false]",
            "sibling_is_leaf": "in [true, false]",
            "tmp1_is_root": "in [true, false]",
            "tmp1_is_leaf": "in [true, false]",
            "tmp2_is_root": "in [true, false]",
            "tmp2_is_leaf": "in [true, false]",
            "root_is_root": "in [true, false]",
            "root_is_leaf": "in [true, false]",
            "node_black_count": "is 1 lower than other leaf paths",
            "sibling_black_count": "is 1 lower than other leaf paths",
            "tmp1_black_count": "is 1 lower than other leaf paths",
            "tmp2_black_count": "is 1 lower than other leaf paths",
            "root_black_count": "is 1 lower than other leaf paths"
        }
    }
},
{
    "kprobe:sibling = parent->rb_right;if (node != sibling)": {
        "description": "Check if the node is not equal to its right sibling in the red-black tree.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "node": "!=null",
            "sibling": "!=null",
            "tmp1": "!=null",
            "tmp2": "!=null",
            "node_color": "in [BLACK, RED]",
            "sibling_color": "in [BLACK, RED]",
            "root_color": "in [BLACK, RED]",
            "parent_color": "in [BLACK, RED]",
            "node_parent": "==parent",
            "sibling_parent": "==parent",
            "root_parent": "==NULL",
            "parent_root": "==root",
            "node_left": "==NULL",
            "node_right": "==NULL",
            "sibling_left": "==NULL",
            "sibling_right": "==NULL",
            "root_left": "==NULL",
            "root_right": "==NULL",
            "parent_left": "==NULL",
            "parent_right": "==NULL",
            "node_left_color": "==BLACK",
            "node_right_color": "==BLACK",
            "sibling_left_color": "==BLACK",
            "sibling_right_color": "==BLACK",
            "root_left_color": "==BLACK",
            "root_right_color": "==BLACK",
            "parent_left_color": "==BLACK",
            "parent_right_color": "==BLACK",
            "node_parent_color": "==BLACK",
            "sibling_parent_color": "==BLACK",
            "root_parent_color": "==BLACK",
            "parent_root_color": "==BLACK",
            "node_parent_left": "==NULL",
            "node_parent_right": "==NULL",
            "sibling_parent_left": "==NULL",
            "sibling_parent_right": "==NULL",
            "root_parent_left": "==NULL",
            "root_parent_right": "==NULL",
            "parent_root_left": "==NULL",
            "parent_root_right": "==NULL",
            "node_parent_left_color": "==BLACK",
            "node_parent_right_color": "==BLACK",
            "sibling_parent_left_color": "==BLACK",
            "sibling_parent_right_color": "==BLACK",
            "root_parent_left_color": "==BLACK",
            "root_parent_right_color": "==BLACK",
            "parent_root_left_color": "==BLACK",
            "parent_root_right_color": "==BLACK",
            "node_parent_color_left": "==BLACK",
            "node_parent_color_right": "==BLACK",
            "sibling_parent_color_left": "==BLACK",
            "sibling_parent_color_right": "==BLACK",
            "root_parent_color_left": "==BLACK",
            "root_parent_color_right": "==BLACK",
            "parent_root_color_left": "==BLACK",
            "parent_root_color_right": "==BLACK",
            "node_parent_left_color_left": "==BLACK",
            "node_parent_left_color_right": "==BLACK",
            "sibling_parent_left_color_left": "==BLACK",
            "sibling_parent_left_color_right": "==BLACK",
            "root_parent_left_color_left": "==BLACK",
            "root_parent_left_color_right": "==BLACK",
            "parent_root_left_color_left": "==BLACK",
            "parent_root_left_color_right": "==BLACK",
            "node_parent_right_color_left": "==BLACK",
            "node_parent_right_color_right": "==BLACK",
            "sibling_parent_right_color_left": "==BLACK",
            "sibling_parent_right_color_right": "==BLACK",
            "root_parent_right_color_left": "==BLACK",
            "root_parent_right_color_right": "==BLACK",
            "parent_root_right_color_left": "==BLACK",
            "parent_root_right_color_right": "==BLACK",
            "node_parent_color_left_color": "==BLACK",
            "node_parent_color_right_color": "==BLACK",
            "sibling_parent_color_left_color": "==BLACK",
            "sibling_parent_color_right_color": "==BLACK",
            "root_parent_color_left_color": "==BLACK",
            "root_parent_color_right_color": "==BLACK",
            "parent_root_color_left_color": "==BLACK",
            "parent_root_color_right_color": "==BLACK",
            "node_parent_left_color_left_color": "==BLACK",
            "node_parent_left_color_right_color": "==BLACK",
            "sibling_parent_left_color_left_color": "==BLACK",
            "sibling_parent_left_color_right_color": "==BLACK",
            "root_parent_left_color_left_color": "==BLACK",
            "root_parent_left_color_right_color": "==BLACK",
            "parent_root_left_color_left_color": "==BLACK",
            "parent_root_left_color_right_color": "==BLACK",
            "node_parent_right_color_left_color": "==BLACK",
            "node_parent_right_color_right_color": "==BLACK",
            "sibling_parent_right_color_left_color": "==BLACK",
            "sibling_parent_right_color_right_color": "==BLACK",
            "root_parent_right_color_left_color": "==BLACK",
            "root_parent_right_color_right_color": "==BLACK",
            "parent_root_right_color_left_color": "==BLACK",
            "parent_root_right_color_right_color": "==BLACK"
        }
    }
},


{
    "kretprobe:____rb_erase_color": {
        "description": "This function is used for erasing a node from a red-black tree and maintaining the color balance.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null"
        }
    }
},
{
    "kprobe:____rb_erase_color": {
        "description": "Function for erasing a node from a red-black tree.",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "augment_rotate": "inline",
            "dummy_rotate": "eliminated"
        }
    }
},





{
    "kprobe:rb_replace_node_rcu": {
        "description": "Copy the pointers' color from the victim to the replacement.",
        "pre": {
            "victim": "!=null",
            "new": "!=null",
            "root": "!=null"
        }
    }
},




{
    "kretprobe:if (bf->selector & ~valid_flags_mask)": {
        "description": "Disallow invalid bit values",
        "pre": {
            "bf": "!=null",
            "valid_flags_mask": "!=0"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if (bf->selector & ~valid_flags_mask)return -EINVAL;/*disallow invalid bit values `": {
        "description": "Disallow invalid bit values",
        "pre": {
            "bf->selector": "& ~valid_flags_mask",
            "return": "-EINVAL"
        }
    }
},
{
    "kretprobe:intnla_policy_len": {
        "description": "Determine the max. length of a policy",
        "pre": {
            "p": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},

{
    "kretprobe:__nla_parse": {
        "description": "Parse a stream of attributes into a tb buffer",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": ">=0",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:__nla_parse": {
        "description": "Parse a stream of attributes into a tb buffer",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": ">=0",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:nla_find": {
        "description": "Find a specific attribute in a stream of attributes",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        }
    }
},
{
    "kprobe:nla_find": {
        "description": "Find a specific attribute in a stream of attributes",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        }
    }
},
{
    "kretprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "!=null",
            "dstsize": "<= U16_MAX",
            "dstsize": ">= 0",
            "nla length": "<= dstsize",
            "srclen": ">= 0",
            "srclen": "<= dstsize - 1",
            "return value": "in [srclen, -E2BIG]"
        }
    }
},
{
    "kprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "!=null",
            "dstsize": "<=U16_MAX",
            "strlen(nla) + 1": "<=dstsize"
        },
        "post": {
            "return_value": ">=-E2BIG"
        }
    }
},
{
    "kretprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:nla_strcmp": {
        "description": "Compare a string attribute against another string.",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kprobe:nla_strcmp": {
        "description": "Compare a string attribute against another string.",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:__nla_reserve": {
        "description": "Reserve room for attribute on the skb.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int"
        }
    }
},
{
    "kprobe:__nla_reserve": {
        "description": "Reserve room for attribute on the skb.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int"
        }
    }
},
{
    "kretprobe:__nla_reserve_64bit": {
        "description": "Reserve room for attribute on the skb and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kprobe:__nla_reserve_64bit": {
        "description": "Reserve room for attribute on the skb and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kretprobe:__nla_reserve_nohdr": {
        "description": "Reserve room for attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0"
        }
    }
},
{
    "kprobe:__nla_reserve_nohdr": {
        "description": "Reserve room for attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0"
        }
    }
},
{
    "kretprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "!=null",
            "attrlen": "!=null",
            "data": "!=null",
            "padattr": "!=null"
        }
    }
},
{
    "kprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it.",
        "pre": {
            "skb": "!=null",
            "attrtype": "int",
            "attrlen": "int",
            "data": "!=null",
            "padattr": "int"
        }
    }
},
{
    "kretprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        },
        "post": {
            "return": "in [-EMSGSIZE]"
        }
    }
},
{
    "kprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtoull": {
        "description": "Convert a string to an unsigned long long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:noinlineunsigned long long simple_strtoull": {
        "description": "Convert a string to an unsigned long long.",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtol": {
        "description": "Convert a string to a signed long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:simple_strtol": {
        "description": "Convert a string to a signed long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long.",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "!=null"
        }
    }
},




{
    "kretprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:align": {
        "description": "Calculate alignment and perform operations on src and max.",
        "pre": {
            "src": "!=null",
            "count": "!=null",
            "max": "!=null",
            "align": ">= 0",
            "c": "!=null",
            "constants": "!=null",
            "constants.word_size": "== sizeof(unsigned long)",
            "res": ">= 0",
            "efault": "!=null"
        }
    }
},
{
    "kprobe:align": {
        "description": "Calculate the alignment of the source address.",
        "pre": {
            "src": "!=null",
            "sizeof(unsigned long)": "!=null",
            "align": "((sizeof(unsigned long) - 1) & (unsigned long)src)",
            "src": "src - align",
            "max": "max + align",
            "c": "unsafe_get_user(c, (unsigned long __user *)src, efault)",
            "c": "c | aligned_byte_mask(align)"
        }
    }
},
{
    "kretprobe:sort_r": {
        "description": "Sort an array of elements using heapsort.",
        "pre": {
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp_func": "!=null",
            "swap_func": "in [!=null, null]",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:sort_r": {
        "description": "Sort an array of elements using heapsort.",
        "pre": {
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp_func": "!=null",
            "swap_func": "in [!=null, null]",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:is_aligned": {
        "description": "Check if the pointer and size are suitable for word-wide copying.",
        "pre": {
            "base": "!=null",
            "size": "!=null",
            "align": "in [4, 8]",
            "size % align": "== 0",
            "base % align": "== 0"
        }
    }
},

{
    "kretprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace.",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},
{
    "kprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace.",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},


{
    "kretprobe:_copy_from_user": {
        "description": "Copy data from user space to kernel space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
            "should_fail_usercopy": "==0",
            "access_ok(from, n)": "==true"
        },
        "post": {
            "res": ">=0",
            "memset(to + (n - res), 0, res)": "executes if res is unlikely",
            "return res": "executes always"
        }
    }
},
{
    "kprobe:_copy_from_user": {
        "description": "Copy data from user space to kernel space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
            "should_fail_usercopy": "==0",
            "access_ok(from, n)": "==true"
        }
    }
},
{
    "kretprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes.",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EFAULT]"
        }
    }
},
{
    "kprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes.",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EFAULT]"
        }
    }
},
{
    "kretprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_UC, DEVM_IOREMAP_WC, DEVM_IOREMAP_NP]"
        }
    }
},
{
    "kretprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_iounmap": {
        "description": "Managed iounmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:devm_iounmap": {
        "description": "Managed iounmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:devm_ioremap_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region, and ioremaps it. All operations are managed and will be undone on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_NP]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_ioremap_resource": {
        "description": "Check, request region, and ioremap resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "type": "in [DEVM_IOREMAP, DEVM_IOREMAP_NP]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device. This is to be used when a device requests maps resources described by other device tree nodes (children or otherwise).",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device. This is to be used when a device requests maps resources described by other device tree nodes (children or otherwise).",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": ">=0 or ==null"
        }
    }
},
{
    "kretprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kretprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap().",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table for @dev. If iomap table doesn't exist and @pdev is managed, it will be allocated. All iomaps recorded in the iomap table are automatically unmapped on driver detach.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). Unmaps the address @addr for the PCI device @pdev.",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). Unmaps the address @addr for the PCI device @pdev.",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_regions_request_all": {
        "description": "Request all BARs and iomap specified ones",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:pcim_iomap_regions_request_all": {
        "description": "Request all BARs and iomap specified ones",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs",
        "pre": {
            "pdev": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:devm_arch_phys_wc_add": {
        "description": "Managed arch_phys_wc_add()",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_arch_phys_wc_add": {
        "description": "Managed arch_phys_wc_add()",
        "pre": {
            "dev": "!=null",
            "base": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback.",
        "pre": {
            "dev": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback.",
        "pre": {
            "dev": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter.",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter.",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kretprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [20, 12]"
        }
    }
},
{
    "kretprobe:key->key.r[0] = (get_unaligned_le32(&raw_key[0])) & 0x3ffffff;key->key.r[1] = (get_unaligned_le32(&raw_key[3]) >> 2) & 0x3ffff03;key->key.r[2] = (get_unaligned_le32(&raw_key[6]) >> 4) & 0x3ffc0ff;key->key.r[3] = (get_unaligned_le32(&raw_key[9]) >> 6) & 0x3f03fff;key->key.r[4] = (get_unaligned_le32(&raw_key[12]) >> 8) & 0x00fffff;/* s = 5*r `": {
        "description": "Set the values of key->key.r[0] to key->key.r[4] based on the given raw_key.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "!=null",
            "raw_key[3]": "!=null",
            "raw_key[6]": "!=null",
            "raw_key[9]": "!=null",
            "raw_key[12]": "!=null",
            "key->key.r[0]": ">= 0 && <= 0x3ffffff",
            "key->key.r[1]": ">= 0 && <= 0x3ffff03",
            "key->key.r[2]": ">= 0 && <= 0x3ffc0ff",
            "key->key.r[3]": ">= 0 && <= 0x3f03fff",
            "key->key.r[4]": ">= 0 && <= 0x00fffff"
        }
    }
},
{
    "kprobe:key->key.r[0] = (get_unaligned_le32(&raw_key[0])) & 0x3ffffff;key->key.r[1] = (get_unaligned_le32(&raw_key[3]) >> 2) & 0x3ffff03;key->key.r[2] = (get_unaligned_le32(&raw_key[6]) >> 4) & 0x3ffc0ff;key->key.r[3] = (get_unaligned_le32(&raw_key[9]) >> 6) & 0x3f03fff;key->key.r[4] = (get_unaligned_le32(&raw_key[12]) >> 8) & 0x00fffff;/* s = 5*r `": {
        "description": "Set the values of key->key.r[0] to key->key.r[4] based on the given raw_key.",
        "pre": {
            "key->key.r[0]": ">= 0 && <= 0x3ffffff",
            "key->key.r[1]": ">= 0 && <= 0x3ffff03",
            "key->key.r[2]": ">= 0 && <= 0x3ffc0ff",
            "key->key.r[3]": ">= 0 && <= 0x3f03fff",
            "key->key.r[4]": ">= 0 && <= 0x00fffff"
        }
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "Helper function for poly1305_core_blocks",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">0",
            "hibit": ">=0"
        }
    }
},
{
    "kprobe:h0 += (get_unaligned_le32(&input[0])) & 0x3ffffff;h1 += (get_unaligned_le32(&input[3]) >> 2) & 0x3ffffff;h2 += (get_unaligned_le32(&input[6]) >> 4) & 0x3ffffff;h3 += (get_unaligned_le32(&input[9]) >> 6) & 0x3ffffff;h4 += (get_unaligned_le32(&input[12]) >> 8) | hibit;/* h *= r": {
        "description": "Update the values of h0, h1, h2, h3, and h4 based on the input and hibit.",
        "pre": {
            "input": "!=null",
            "hibit": "!=null",
            "h0": "!=null",
            "h1": "!=null",
            "h2": "!=null",
            "h3": "!=null",
            "h4": "!=null"
        }
    }
},
{
    "h0": "!=null",
    "h1": "!=null",
    "h2": "!=null",
    "h3": "!=null",
    "h4": "!=null",
    "c": "!=null"
},
{
    "kprobe:h0_state_h1_state_h2_state_h3_state_h4_c": {
        "description": "Compute h + -p",
        "pre": {
            "state": "!=null",
            "h0": "is int",
            "h1": "is int",
            "h2": "is int",
            "h3": "is int",
            "h4": "is int",
            "c": "is int",
            "h1": ">> 26",
            "h1": "& 0x3ffffff",
            "h2": "+= c",
            "c": ">> 26",
            "h2": "& 0x3ffffff",
            "h3": "+= c",
            "c": ">> 26",
            "h3": "& 0x3ffffff",
            "h4": "+= c",
            "c": ">> 26",
            "h4": "& 0x3ffffff",
            "h0": "+= c * 5",
            "c": ">> 26",
            "h0": "& 0x3ffffff",
            "h1": "+= c"
        }
    }
},
{
    "kretprobe:while (size > 0)": {
        "description": "Loop while size is greater than 0.",
        "pre": {
            "size": ">0"
        }
    }
},
{
    "while (size > 0)": {
        "description": "Loop until size becomes zero",
        "pre": {
            "size": "> 0"
        },
        "post": {
            "size": "== 0"
        },
        "loop_body": {
            "neq": "|= get_unaligned((unsigned long)a) ^ get_unaligned((unsigned long)b)",
            "a": "+= sizeof(unsigned long)",
            "b": "+= sizeof(unsigned long)",
            "size": "-= sizeof(unsigned long)"
        }
    }
},
{
    "kretprobe:get_unaligned_le64": {
        "description": "Read an unaligned 64-bit little-endian value from memory.",
        "pre": {
            "raw_key": "!=null"
        }
    },
    "kretprobe:poly1305_core_setkey": {
        "description": "Set the key for the Poly1305 core function.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null"
        }
    }
},
{
    "kprobe:poly1305_core_setkey": {
        "description": "Set the key for the poly1305_core function.",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "!=null",
            "raw_key[8]": "!=null",
            "t0": "!=null",
            "t1": "!=null",
            "key->key.r64[0]": "t0 & 0xffc0fffffffULL",
            "key->key.r64[1]": "((t0 >> 44) | (t1 << 20)) & 0xfffffc0ffffULL",
            "key->key.r64[2]": "((t1 >> 24)) & 0x00ffffffc0fULL",
            "s": "20 * r"
        }
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "Perform poly1305 core blocks computation.",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">0",
            "hibit": ">=0"
        },
        "post": {
            "h0": ">=0",
            "h1": ">=0",
            "h2": ">=0"
        }
    }
},
{
    "kprobe:poly1305_core_blocks": {
        "description": "Perform poly1305 core blocks operation.",
        "pre": {
            "input": "!=null"
        }
    }
},
{
    "kretprobe:h0 = state->h64[0];h1 = state->h64[1];h2 = state->h64[2];c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;/* compute h + -p `": {
        "description": "Compute h + -p",
        "pre": {
            "h0": "!=null",
            "h0": "<= 0xfffffffffffULL",
            "h1": "!=null",
            "h1": "<= 0xfffffffffffULL",
            "h2": "!=null",
            "h2": "<= 0x3ffffffffffULL",
            "c": "!=null"
        }
    }
},
{
    "kprobe:h0 = state->h64[0];h1 = state->h64[1];h2 = state->h64[2];c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;c = h1 >> 44;h1 &= 0xfffffffffffULL;h2 += c;c = h2 >> 42;h2 &= 0x3ffffffffffULL;h0 += c * 5;c = h0 >> 44;h0 &= 0xfffffffffffULL;h1 += c;/* compute h + -p `": {
        "description": "Compute h + -p",
        "pre": {
            "state": "!=null",
            "state->h64[0]": "!=null",
            "state->h64[1]": "!=null",
            "state->h64[2]": "!=null",
            "h1": ">= 0",
            "h1": "<= 0xfffffffffffULL",
            "h2": ">= 0",
            "h2": "<= 0x3ffffffffffULL",
            "c": ">= 0",
            "c": "<= 0xfffffffffffULL",
            "h0": ">= 0",
            "h0": "<= 0xfffffffffffULL"
        }
    }
},


{
    "kretprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule.",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": ">= 0",
            "authsize": ">= 0"
        }
    }
},
{
    "kprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule.",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": ">=0",
            "authsize": ">=0"
        }
    }
},
{
    "kretprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kretprobe:aes_encrypt": {
        "description": "Encrypt data using the AES algorithm.",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    },
    "kretprobe:local_irq_restore": {
        "description": "Restore the interrupt state to the value saved by local_irq_save.",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kprobe:local_irq_save": {
        "description": "Save the current interrupt state and disable interrupts.",
        "pre": {
            "flags": "!=null"
        }
    },
    "kprobe:aes_encrypt": {
        "description": "Encrypt data using the AES algorithm.",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null"
        }
    },
    "kprobe:local_irq_restore": {
        "description": "Restore the interrupt state to the value saved by local_irq_save.",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null",
            "iv_size": "==12",
            "authtag": "!=null"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null",
            "iv_size": "12",
            "authtag": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},


{
    "kretprobe:chacha_crypt_generic": {
        "description": "Perform generic ChaCha encryption.",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": ">= CHACHA_BLOCK_SIZE",
            "nrounds": "!=null"
        }
    }
},
{
    "kprobe:chacha_crypt_generic": {
        "description": "aligned to potentially speed up crypto_xor()",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": ">=CHACHA_BLOCK_SIZE",
            "nrounds": "any"
        }
    }
},
{
    "kretprobe:blake2s_compress": {
        "description": "Compresses the input state using the Blake2s algorithm.",
        "pre": {
            "state": "!=null",
            "state->buf": "!=null",
            "state->buflen": "==1",
            "state->h": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kprobe:blake2s_compress": {
        "description": "Compresses the state using the Blake2s algorithm.",
        "pre": {
            "state": "!=null",
            "state->buf": "!=null",
            "state->buflen": "==1",
            "state->h": "!=null",
            "ARRAY_SIZE(state->h)": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kretprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": ">=16 && <=256"
        }
    }
},
{
    "kprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": "!=null"
        }
    }
},
{
    "kretprobe:aes_encrypt": {
        "description": "Encrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_encrypt": {
        "description": "Encrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:aes_decrypt": {
        "description": "Decrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_decrypt": {
        "description": "Decrypt a single AES block",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:sha1_transform": {
        "description": "Single block SHA1 transform (deprecated)",
        "pre": {
            "digest": "!=null",
            "data": "!=null",
            "array": "!=null"
        }
    }
},
{
    "kprobe:sha1_transform": {
        "description": "Single block SHA1 transform (deprecated)",
        "pre": {
            "digest": "!=null",
            "data": "!=null",
            "array": "!=null"
        }
    }
},
{
    "kretprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "pre": {
            "buf": "!=null"
        }
    }
},
{
    "kprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "pre": {
            "buf": "!=null"
        }
    }
},


{
    "kretprobe:dim_on_top": {
        "description": "Check if the dimension is on top.",
        "pre": {
            "dim": "!=null",
            "dim->tune_state": "in [DIM_PARKING_ON_TOP, DIM_PARKING_TIRED, DIM_GOING_RIGHT, DIM_GOING_LEFT]",
            "dim->steps_right": "> 1",
            "dim->steps_left": "== 1"
        }
    }
},
{
    "kprobe:return (dim->steps_right > 1) && (dim->steps_left == 1);}}EXPORT_SYMBOL(dim_on_top": {
        "description": "Helper function to determine if the dimension is on top.",
        "pre": {
            "dim->steps_right": "> 1",
            "dim->steps_left": "== 1"
        }
    }
},
{
    "kretprobe:dim_calc_stats": {
        "description": "Calculate statistics for DIM samples.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "curr_stats": "!=null"
        },
        "post": {
            "delta_us": "!=0",
            "npkts": ">=0",
            "nbytes": ">=0",
            "ncomps": ">=0",
            "curr_stats.ppms": ">=0",
            "curr_stats.bpms": ">=0",
            "curr_stats.epms": ">=0",
            "curr_stats.cpms": ">=0",
            "curr_stats.cpe_ratio": ">=0"
        }
    }
},
{
    "kprobe:dim_calc_stats": {
        "description": "Calculate statistics using the given start and end samples.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "curr_stats": "!=null"
        }
    }
},
{
    "kretprobe:rdma_dim_decision": {
        "description": "Helper function for rdma_dim_decision.",
        "pre": {
            "dim->tune_state": "== DIM_GOING_RIGHT || dim->tune_state == DIM_GOING_LEFT",
            "dim->profile_ix": ">= 0 && dim->profile_ix <= RDMA_DIM_PARAMS_NUM_PROFILES - 1",
            "dim->steps_right": ">= 0",
            "dim->steps_left": ">= 0"
        }
    },
    "kretprobe:rdma_dim_stats_compare": {
        "description": "Helper function for rdma_dim_stats_compare.",
        "pre": {
            "curr.cpms": "!= null",
            "prev.cpms": "!= null",
            "curr.cpe_ratio": "!= null",
            "prev.cpe_ratio": "!= null"
        }
    }
},
{
    "kprobe:rdma_dim_decision": {
        "description": "Helper function for making decisions based on dim statistics.",
        "pre": {
            "curr_stats": "!=null",
            "dim": "!=null"
        }
    },
    "kprobe:rdma_dim_step": {
        "description": "Helper function for stepping through dim profiles.",
        "pre": {
            "dim": "!=null",
            "dim->tune_state": "in [DIM_GOING_RIGHT, DIM_GOING_LEFT]",
            "dim->profile_ix": "in [0, RDMA_DIM_PARAMS_NUM_PROFILES - 1]"
        }
    },
    "kprobe:rdma_dim_stats_compare": {
        "description": "Helper function for comparing dim statistics.",
        "pre": {
            "curr": "!=null",
            "prev": "!=null"
        }
    }
},


{
    "kretprobe:LZ4_decompress_safe_continue": {
        "description": "Decompress multiple blocks in streaming mode.",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        }
    }
},
{
    "kprobe:LZ4_decompress_safe_continue": {
        "description": "Decompress multiple blocks in streaming mode.",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        }
    }
},
{
    "kretprobe:assert": {
        "description": "Assert that lz4sd->extDictSize is equal to 0",
        "pre": {
            "lz4sd->extDictSize": "== 0"
        }
    },
    "kretprobe:LZ4_decompress_safe": {
        "description": "Decompress data using LZ4_decompress_safe function",
        "pre": {
            "source": "!= null",
            "dest": "!= null",
            "compressedSize": "!= null",
            "maxOutputSize": "!= null"
        },
        "post": {
            "result": "> 0"
        }
    },
    "kretprobe:return": {
        "description": "Update lz4sd->prefixSize and lz4sd->prefixEnd",
        "pre": {
            "lz4sd->prefixEnd": "== dest"
        }
    }
},
{
    "kprobe:assert": {
        "description": "Assert that lz4sd->extDictSize is equal to 0.",
        "pre": {
            "lz4sd->extDictSize": "== 0"
        }
    },
    "kprobe:LZ4_decompress_safe": {
        "description": "Decompress the source data to the destination buffer using LZ4_decompress_safe.",
        "pre": {
            "source": "!= null",
            "dest": "!= null",
            "compressedSize": ">= 0",
            "maxOutputSize": ">= 0"
        }
    },
    "kprobe:return": {
        "description": "Return the result of LZ4_decompress_safe.",
        "pre": {
            "result": "<= 0"
        }
    },
    "kprobe:lz4sd->prefixSize": {
        "description": "Set lz4sd->prefixSize to the result of LZ4_decompress_safe.",
        "pre": {
            "lz4sd->prefixSize": "= result"
        }
    },
    "kprobe:lz4sd->prefixEnd": {
        "description": "Set lz4sd->prefixEnd to the destination buffer plus the result of LZ4_decompress_safe.",
        "pre": {
            "lz4sd->prefixEnd": "= (BYTE *)dest + result"
        }
    },
    "kprobe:else if (lz4sd->prefixEnd == (BYTE *)dest)": {
        "description": "Check if lz4sd->prefixEnd is equal to the destination buffer.",
        "pre": {
            "lz4sd->prefixEnd": "== (BYTE *)dest"
        }
    }
},



{
    "kprobe:- 8 /* because 8 + MINMATCH == MFLIMIT */": {
        "description": "Function description goes here.",
        "pre": {
            "ctx": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "srcSizePtr": ">=0",
            "targetDstSize": ">=0",
            "tableType": "valid table type"
        }
    }
},

{
    "kprobe:LZ4_resetStream": {
        "description": "Reset the LZ4 stream state.",
        "pre": {
            "LZ4_dict": "!=null",
            "dictSize": "< HASH_UNIT"
        }
    }
},
{
    "kretprobe:LZ4_saveDict": {
        "description": "Save the LZ4 dictionary.",
        "pre": {
            "LZ4_dict": "!=null",
            "safeBuffer": "!=null",
            "dictSize": "> 0",
            "dictSize": "<= 64 * KB",
            "dict->dictSize": ">= (U32)dictSize",
            "safeBuffer": "points to valid memory",
            "dict->dictionary": "points to valid memory",
            "dict->dictSize": "is updated to (U32)dictSize",
            "return value": "is equal to dictSize"
        }
    }
},



{
    "kretprobe:zstd_init_cstream": {
        "description": "Initialize a zstd compression stream.",
        "pre": {
            "parameters": "!=null",
            "pledged_src_size": "==0",
            "workspace": "!=null",
            "workspace_size": "!=0"
        }
    }
},
{
    "kprobe:zstd_init_cstream": {
        "description": "Initialize a zstd compression stream.",
        "pre": {
            "parameters": "!=null",
            "pledged_src_size": "==0",
            "workspace": "!=null",
            "workspace_size": "!=0"
        }
    }
},
{
    "kretprobe:find_font": {
        "description": "Find a specified font with string name @name. Returns %NULL if no font found, or a pointer to the specified font.",
        "pre": {
            "name": "!=null"
        }
    }
},

{
    "kretprobe:get_default_font": {
        "description": "Get the default font for a specified screen size.",
        "pre": {
            "xres": "!=null",
            "yres": "!=null",
            "font_w": "!=null",
            "font_h": "!=null"
        }
    }
},
{
    "kprobe:get_default_font": {
        "description": "Get the default font for a specified screen size.",
        "pre": {
            "xres": "!=null",
            "yres": "!=null",
            "font_w": "!=null",
            "font_h": "!=null"
        }
    }
},
{
    "kretprobe:rational_best_approximation": {
        "description": "Find the best rational approximation for a given fixed-point number.",
        "pre": {
            "given_numerator": "!=null",
            "given_denominator": "!=null",
            "max_numerator": "!=null",
            "max_denominator": "!=null",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},
{
    "kprobe:rational_best_approximation": {
        "description": "Calculate the rational best approximation for a given numerator and denominator.",
        "pre": {
            "given_numerator": "!=null",
            "given_denominator": "!=null",
            "max_numerator": "!=null",
            "max_denominator": "!=null",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},


{
    "kretprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for a given angle",
        "pre": {
            "theta": "!=null"
        },
        "post": {
            "coord": "!=null",
            "coord.x": ">=0",
            "coord.y": ">=0"
        }
    }
},
{
    "kprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for a given angle.",
        "pre": {
            "theta": "!=null",
            "coord": "!=null"
        }
    }
},

{
    "kprobe:__div64_32": {
        "description": "__div64_32() can be overridden by linking arch-specific assembly versions such as archppclibdiv64.S and archshlibdiv64.S or by defining a preprocessor macro in archincludeasmdiv64.h.",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null"
        }
    }
},
{
    "kretprobe:div64_u64_rem": {
        "description": "Unsigned 64bit divide with 64bit divisor and remainder",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null",
            "remainder": "!=null"
        }
    }
},
{
    "kprobe:div64_u64_rem": {
        "description": "Unsigned 64-bit divide with 64-bit divisor and remainder.",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null",
            "remainder": "!=null"
        }
    }
},


{
    "kretprobe:is_prime_number": {
        "description": "Checks if a number is prime.",
        "pre": {
            "x": "!=null"
        }
    },
    "kretprobe:slow_next_prime_number": {
        "description": "Finds the next prime number greater than the given number.",
        "pre": {
            "x": "!=null"
        }
    },
    "kretprobe:clear_multiples": {
        "description": "Clears the multiples of a prime number within a given range.",
        "pre": {
            "x": "!=null",
            "p": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    },
    "kretprobe:expand_to_next_prime": {
        "description": "Expands the number to the next prime number.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:is_prime_number": {
        "description": "Checks if a number is prime.",
        "pre": {
            "x": "!=null"
        }
    },
    "kprobe:slow_next_prime_number": {
        "description": "Finds the next prime number greater than the given number.",
        "pre": {
            "x": "!=null"
        }
    },
    "kprobe:clear_multiples": {
        "description": "Clears the multiples of a prime number within a given range.",
        "pre": {
            "x": "!=null",
            "p": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    },
    "kprobe:expand_to_next_prime": {
        "description": "Expands the number to the next prime number.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:int_sqrt": {
        "description": "Computes the integer square root of x.",
        "pre": {
            "x": ">= 0"
        }
    }
},
{
    "kprobe:int_sqrt": {
        "description": "Computes the integer square root of x.",
        "pre": {
            "x": ">= 0"
        }
    }
},
{
    "kretprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        }
    }
},
{
    "kprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        }
    }
},
{
    "kretprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        }
    }
},

{
    "kprobe:dfltcc_can_inflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "strm->state": "!=null",
            "GET_DFLTCC_STATE(state)": "!=null"
        }
    }
},


{
    "kretprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "zlib_dfltcc_support": "in [ZLIB_DFLTCC_DISABLED, ZLIB_DFLTCC_INFLATE_ONLY]"
        }
    }
},
{
    "kprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null"
        }
    }
},
{
    "kretprobe:dfltcc_reset_deflate_state": {
        "description": "Reset the deflate state and initialize tuning parameters.",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "= DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "= DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": ">= DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},
{
    "kprobe:dfltcc_reset_deflate_state": {
        "description": "Reset the deflate state and initialize tuning parameters.",
        "pre": {
            "strm": "!=null",
            "state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "= DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "= DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": ">= DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},




{
    "kretprobe:crypto_sha256_arm_update": {
        "description": "Make sure casting to sha256_block_fn() is safe.",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:crypto_sha256_arm_update": {
        "description": "Update the SHA256 state with the given data.",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},


{
    "kretprobe:pfn_valid": {
        "description": "Check if the physical frame number (PFN) is valid.",
        "pre": {
            "pfn": "!=null",
            "addr": "!=null",
            "pageblock_size": "!=null",
            "__phys_to_pfn(addr)": "==pfn",
            "memblock_overlaps_region(&memblock.memory, ALIGN_DOWN(addr, pageblock_size), pageblock_size)": "==1"
        }
    }
},
{
    "kprobe:memblock_overlaps_region": {
        "description": "Check if the memory block overlaps with a region.",
        "pre": {
            "memblock.memory": "!=null",
            "addr": "!=null",
            "pageblock_size": "!=null",
            "pageblock_nr_pages": "!=null"
        }
    }
},


{
    "kretprobe:empty_zero_page": {
        "description": "Special page used for zero-initialized data and COW.",
        "pre": {
            "empty_zero_page": "!=null",
            "usage": "in [ZERO_INITIALIZED_DATA, COW]"
        }
    }
},
{
    "kprobe:struct_page_empty_zero_page": {
        "description": "empty_zero_page is a special page that is used for zero-initialized data and COW.",
        "pre": {
            "empty_zero_page": "!=null"
        }
    }
},

{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Bounds checking against the kernel image only.",
        "pre": {
            "x": ">= (unsigned long)KERNEL_START",
            "x": "<= (unsigned long)KERNEL_END"
        }
    }
},





{
    "kprobe:unmap_area_sections": {
        "description": "Unmap and remap a region using iounmap and ioremap.",
        "pre": {
            "virt": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:jornada_ssp_reverse": {
        "description": "Reverses the input byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return_value": "in [0, 255]"
        }
    }
},
{
    "kprobe:jornada_ssp_reverse": {
        "description": "Reverses the input byte",
        "pre": {
            "byte": "!=null"
        }
    }
},
{
    "kretprobe:jornada_ssp_byte": {
        "description": "Waits for ready ssp bus and sends byte",
        "pre": {
            "byte": "!=null",
            "fifo_buffer": "==0",
            "mcu_running": "==true"
        },
        "post": {
            "return_value": "!=null",
            "return_value": "in [%mcu_output, %-ETIMEDOUT]"
        }
    }
},
{
    "kprobe:jornada_ssp_byte": {
        "description": "Waits for the ready ssp bus and sends a byte.",
        "pre": {
            "byte": "!=null",
            "fifo_buffer": "empty",
            "mcu_running": "true"
        },
        "post": {
            "output": "!=null",
            "output": "on success",
            "output": "-ETIMEDOUT on timeout"
        }
    }
},
{
    "kretprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return": {
                "constraints": [
                    "in [jornada_ssp_byte(byte), %-ETIMEDOUT]"
                ]
            }
        }
    }
},
{
    "kprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte",
        "pre": {
            "byte": "!=null"
        },
        "post": {
            "return": "in [jornada_ssp_byte(byte), %-ETIMEDOUT]"
        }
    }
},
{
    "kretprobe:jornada_ssp_start": {
        "description": "Enable MCU",
        "pre": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:jornada_ssp_start": {
        "description": "enable mcu",
        "pre": {}
    }
},
{
    "kretprobe:jornada_ssp_end": {
        "description": "disable mcu and turn off lock",
        "pre": {
            "mcu": "disabled",
            "lock": "off"
        }
    }
},
{
    "kprobe:jornada_ssp_end": {
        "description": "Disable mcu and turn off lock",
        "pre": {}
    }
},
{
    "kretprobe:ssp_write_word": {
        "description": "Write a word to the SSP port",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "in [0, -ETIMEDOUT]"
        }
    }
},
{
    "kprobe:ssp_write_word": {
        "description": "Write a word to the SSP port",
        "pre": {
            "data": "!=null",
            "SSP_transmit_FIFO": "has_free_entry"
        },
        "post": {
            "SSP_port": "sending_data"
        },
        "returns": {
            "timeout": "%-ETIMEDOUT",
            "success": "0"
        }
    }
},
{
    "kretprobe:ssp_read_word": {
        "description": "Read a word from the SSP port",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is 16-bit data"
        }
    }
},
{
    "kprobe:ssp_read_word": {
        "description": "Read a word from the SSP port.",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs. Wait for the SSP to idle and ensure that the receive FIFO is empty.",
        "pre": {
            "return_value": "in [-ETIMEDOUT, 0]"
        }
    }
},
{
    "kprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs of the SSP.",
        "pre": {
            "receive_fifo_empty": true,
            "ssp_idle": true
        }
    }
},
{
    "kretprobe:ssp_enable": {
        "description": "Enable the SSP port",
        "pre": {},
        "post": {
            "return_value": ">= 0"
        }
    }
},

{
    "kretprobe:ssp_disable": {
        "description": "Shut down the SSP port and optionally power it down.",
        "pre": {},
        "post": {
            "return_value": "0"
        }
    }
},

{
    "kretprobe:ssp_save_state": {
        "description": "Save the SSP configuration",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kprobe:ssp_save_state": {
        "description": "Save the configured SSP state for suspend.",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kretprobe:ssp_restore_state": {
        "description": "Restore a previously saved SSP configuration",
        "pre": {
            "ssp": "!=null",
            "(*ssp).field1": "!=null",
            "(*ssp).field2": "!=null",
            "(*ssp).field3": "!=null",
            ...
        }
    }
},



{
    "kretprobe:ssp_exit": {
        "description": "Undo the effects of ssp_init, release and free resources for the SSP port.",
        "pre": {
            "none": "none"
        }
    }
},









{
    "kretprobe:ep93xx_i2s_acquire": {
        "description": "This is potentially racy with the clock api for i2s_mclk, sclk and lrclk. Since the i2s driver is the only user of those clocks we rely on it to prevent parallel use of this function and the clock api for the i2s clocks.",
        "pre": {
            "__raw_readl(EP93XX_SYSCON_I2SCLKDIV)": "!=null",
            "val": "!=null",
            "EP93XX_I2SCLKDIV_MASK": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_ORIDE": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_SPOL": "!=null",
            "ep93xx_syscon_swlocked_write(val, EP93XX_SYSCON_I2SCLKDIV)": "!=null"
        }
    }
},
{
    "kprobe:ep93xx_i2s_acquire": {
        "description": "This function acquires the EP93xx I2S interface.",
        "pre": {
            "val": "!=null",
            "ep93xx_devcfg_set_clear": "!=null",
            "EP93XX_SYSCON_DEVCFG_I2SONAC97": "!=null",
            "EP93XX_SYSCON_DEVCFG_I2S_MASK": "!=null"
        }
    }
},

{
    "kprobe:ep93xx_devcfg_clear_bits": {
        "description": "Clears the specified bits in the EP93XX_SYSCON_DEVCFG register.",
        "pre": {
            "pdev": "!=null",
            "err": "int",
            "i": "int",
            "EP93XX_GPIO_LINE_EGPIO2": "int",
            "EP93XX_GPIO_LINE_EGPIO15": "int",
            "EP93XX_GPIO_LINE_E": "int[8]",
            "EP93XX_GPIO_LINE_G": "int[8]",
            "EP93XX_GPIO_LINE_H": "int[8]"
        }
    }
},


{
    "iowrite16": {
        "description": "Write the value 0x0000 to the address calculated as sdev->base + SCOOP_CDR.",
        "pre": {
            "arg1": "0x0000",
            "arg2": "sdev->base + SCOOP_CDR"
        }
    }
},
{
    "kprobe:iowrite16": {
        "description": "Write the value 0x0000 to the address sdev->base + SCOOP_CDR.",
        "pre": {
            "sdev": "!=null",
            "sdev->base": "!=null",
            "SCOOP_CDR": "!=null"
        }
    }
},


{
    "kretprobe:krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:asm volatile (\"mcr p15, 3, %0, c15, c0, 6 @ l2cpselr\" : : \"r\" (addr));isb();asm volatile (\"mcr p15, 3, %0, c15, c0, 7 @ l2cpdr\" : : \"r\" (val));isb();raw_spin_unlock_irqrestore(&krait_l2_lock, flags);}EXPORT_SYMBOL(krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:asm volatile (\"mcr p15, 3, %0, c15, c0, 6 @ l2cpselr\" : : \"r\" (addr));isb();asm volatile (\"mrc p15, 3, %0, c15, c0, 7 @ l2cpdr\" : \"=r\" (val));raw_spin_unlock_irqrestore(&krait_l2_lock, flags);return val;}EXPORT_SYMBOL(krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "pre": {
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency.",
        "pre": {
            "sachip": "!=null"
        }
    }
},
{
    "sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_select_audio_mode": {
        "description": "Select I2S or AC link mode.",
        "pre": {
            "sadev": "!=null",
            "mode": "in [SA1111_AUDIO_ACLINK, SA1111_AUDIO_I2S]"
        }
    }
},
{
    "kprobe:sa1111_select_audio_mode": {
        "description": "Select I2S or AC link mode",
        "pre": {
            "sadev": "!=null",
            "mode": "in [SA1111_AUDIO_ACLINK, SA1111_AUDIO_I2S]"
        }
    }
},
{
    "kretprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate.",
        "pre": {
            "sadev": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate.",
        "pre": {
            "sadev": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block.",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "if (info->dma && sachip->dev->dma_mask)": {
        "description": "Check if info->dma and sachip->dev->dma_mask are not null.",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        }
    }
},
{
    "kprobe:if (info->dma && sachip->dev->dma_mask)": {
        "description": "Check if the parent device has a DMA mask associated with it and if this child supports DMA.",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        }
    }
},
{
    "kretprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "pre": {
            "bus": "!=null"
        }
    }
},






{
    "kretprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "pre": {
            "x->e_machine": "!= EM_ARM"
        }
    }
},
{
    "kprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "pre": {
            "x->e_machine": "!= EM_ARM"
        }
    }
},
{
    "kretprobe:elf_set_personality": {
        "description": "Set the personality of the current process based on the ELF header flags.",
        "pre": {
            "x": "!=null",
            "eflags": "!=null",
            "personality": "!=null",
            "current": "!=null",
            "PER_LINUX": "defined",
            "PER_MASK": "defined"
        }
    }
},
{
    "kprobe:elf_set_personality": {
        "description": "Set the personality of the current process based on the ELF executable.",
        "pre": {
            "x": "!=null",
            "eflags": "!=null",
            "personality": "!=null",
            "personality & PER_MASK": "==0",
            "personality |= PER_LINUX": "true"
        }
    }
},
{
    "kretprobe:omap_readl": {
        "description": "Read the value of OCPI_PROT register and store it in val.",
        "pre": {
            "OCPI_PROT": "!=null"
        },
        "post": {
            "val": "!=null",
            "val": "&= ~0xff"
        }
    }
},
{
    "kprobe:omap_readl": {
        "description": "Read a 32-bit value from the OCPI_PROT register and perform a bitwise AND operation with ~0xff.",
        "pre": {
            "val": "!=null",
            "cpu_is_omap16xx()": "true"
        }
    }
},
{
    "kretprobe:static struct omap_id omap_ids[] __initdata": {
        "description": "Register values to detect the OMAP version",
        "pre": {
            "omap_revision": "!=null"
        }
    }
},

{
    "kretprobe:omap_readb": {
        "description": "Read a byte from the memory location specified by pa.",
        "pre": {
            "pa": "!=null"
        }
    }
},







{
    "kretprobe:break;}}if (free_ch == -1)": {
        "description": "Condition for the break statement in the given function",
        "pre": {
            "free_ch": "== -1"
        }
    }
},
{
    "kprobe:omap_request_dma": {
        "description": "Request DMA channel for OMAP devices.",
        "pre": {
            "dev_id": "!=null",
            "dev_name": "!=null",
            "callback": "!=null",
            "data": "!=null",
            "dma_ch_out": "!=null",
            "free_ch": "== -1"
        }
    }
},
{
    "kretprobe:omap_disable_channel_irq": {
        "description": "Disable all DMA interrupts for the channel.",
        "pre": {
            "lch": "!=null",
            "dma_chan[lch].dev_id": "!= -1"
        }
    }
},

{
    "kretprobe:omap_clear_dma": {
        "description": "Clears the DMA channel specified by *lch*.",
        "pre": {
            "lch": "!=null"
        }
    }
},
{
    "kprobe:omap_clear_dma": {
        "description": "Clears the DMA channel specified by *lch*.",
        "pre": {
            "lch": "!=null"
        }
    }
},
{
    "kretprobe:omap_disable_channel_irq": {
        "description": "Disable all interrupts on the channel",
        "pre": {
            "lch": "!=null",
            "l": "!=null",
            "p": "!=null",
            "DMA_ERRATA_i541": "defined",
            "OMAP_DMA_CCR_SEL_SRC_DST_SYNC": "defined",
            "IS_DMA_ERRATA(DMA_ERRATA_i541)": "true",
            "(l & OMAP_DMA_CCR_SEL_SRC_DST_SYNC)": "true"
        }
    }
},
{
    "kprobe:omap_disable_channel_irq": {
        "description": "Disable all interrupts on the channel",
        "pre": {
            "lch": "!=null",
            "l": "!=null",
            "p": "!=null",
            "DMA_ERRATA_i541": "defined",
            "OMAP_DMA_CCR_SEL_SRC_DST_SYNC": "defined",
            "IS_DMA_ERRATA(DMA_ERRATA_i541)": "true",
            "(l & OMAP_DMA_CCR_SEL_SRC_DST_SYNC)": "true"
        }
    }
},
{
    "kretprobe:omap_get_dma_src_pos": {
        "description": "Helper function to get the source position for DMA transfer.",
        "pre": {
            "lch": "!=null",
            "offset": "!=null",
            "dma_omap15xx()": "in [true, false]",
            "IS_DMA_ERRATA(DMA_ERRATA_3_3)": "in [true, false]"
        }
    }
},
{
    "kprobe:omap_get_dma_src_pos": {
        "description": "This function retrieves the DMA source position.",
        "pre": {
            "lch": "!=null",
            "p": "!=null",
            "CDAC": "!=null",
            "CSAC": "!=null",
            "CSSA": "!=null",
            "offset": "!=null",
            "dma_omap15xx()": "returns true or false",
            "IS_DMA_ERRATA(DMA_ERRATA_3_3)": "returns true or false"
        },
        "post": {
            "offset": "is updated and returned"
        }
    }
},
{
    "kretprobe:omap_get_dma_dst_pos": {
        "description": "Get the DMA destination position.",
        "pre": {
            "!dma_omap15xx()": true,
            "offset": 0
        }
    }
},
{
    "kprobe:if (!dma_omap15xx() && offset == 0)": {
        "description": "Check if dma_omap15xx() is false and offset is equal to 0.",
        "pre": {
            "dma_omap15xx()": "== false",
            "offset": "== 0"
        }
    }
},


{
    "kretprobe:sx1_setbacklight": {
        "description": "Set the LCD backlight intensity.",
        "pre": {
            "backlight": "!=null"
        }
    }
},

{
    "kretprobe:sx1_getbacklight": {
        "description": "Get the current LCD backlight intensity.",
        "pre": {
            "backlight": "!=null",
            "backlight_value": ">=0",
            "backlight_value": "<=SOFIA_MAX_LIGHT_VAL"
        }
    }
},
{
    "kprobe:sx1_getbacklight": {
        "description": "Get current LCD backlight intensity",
        "pre": {
            "backlight": ">=0",
            "backlight": "<=255"
        }
    }
},


{
    "kretprobe:sx1_setusbpower": {
        "description": "set USB power on/off",
        "pre": {
            "onoff": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sx1_setusbpower": {
        "description": "set USB power on/off",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},

{
    "kprobe:if (fmrx(FPEXC) & FPEXC_EN)pr_crit(\"BUG: unsupported FP instruction in kernel mode\\n\");elsepr_crit(\"BUG: FP instruction issued in kernel mode with FP unit disabled\\n\");pr_crit(\"FPEXC == 0x%08x\\n\", fmrx(FPEXC));return 1;}static struct undef_hook vfp_kmode_exception_hook[] = ": {
        "description": "Kernel function for handling VFP mode exceptions in kernel mode.",
        "pre": {
            "fmrx(FPEXC) & FPEXC_EN": "!= 0",
            "fmrx(FPEXC)": "!= 0",
            "vfp_kmode_exception_hook": "!= null"
        }
    }
},
{
    "kretprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "pre": {
            "fmxr": {
                "arg1": "FPEXC",
                "arg2": "fmrx(FPEXC) & ~FPEXC_EN"
            },
            "local_bh_enable": "null"
        }
    }
},
{
    "kprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "pre": {
            "none": "none"
        }
    }
},

{
    "kprobe:index = c_start(&excd);continue;}if (c_id(&excd) == 0x80)": {
        "description": "Function to generate conditions for",
        "pre": {
            "cd": "!=null",
            "ec": "!=null",
            "id": "!=null",
            "num": "!=null"
        }
    }
},


{
    "kretprobe:wb977_open;__gpio_modify_io": {
        "description": "Close up the EFER gate",
        "pre": {
            "mask": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:wb977_open;__gpio_modify_io": {
        "description": "Open up the EFER gate",
        "pre": {
            "mask": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:ndelay": {
        "description": "Perform a delay for the specified number of nanoseconds.",
        "pre": {
            "nsecs": "!=null",
            "ncycles": "!=null",
            "ncycles >> NDELAY_SHIFT": "!=null"
        }
    }
},

{
    "kretprobe:WARN(!is_linear_mapping && !is_kernel_mapping)": {
        "description": "virt_to_phys used for non-linear address",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "return": "__va_to_pa_nodebug(x)"
        }
    }
},
{
    "kprobe:WARN": {
        "description": "Check if virt_to_phys is used for a non-linear address",
        "pre": {
            "!is_linear_mapping(x) && !is_kernel_mapping(x)": "true"
        }
    },
    "kprobe:__va_to_pa_nodebug": {
        "description": "Return the physical address corresponding to the virtual address",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kretprobe:VIRTUAL_BUG_ON": {
        "description": "Boundary checking against the kernel image mapping. __pa_symbol should only be used on kernel symbol addresses.",
        "pre": {
            "x": "!= null",
            "kernel_start": "!= null",
            "kernel_end": "!= null"
        },
        "post": {
            "return_value": "__va_to_pa_nodebug(x)"
        }
    }
},
{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Boundary checking against the kernel image mapping.",
        "pre": {
            "x": ">= kernel_start",
            "x": "<= kernel_end"
        }
    },
    "kretprobe:__va_to_pa_nodebug": {
        "description": "Convert virtual address to physical address without debugging information.",
        "pre": {
            "x": "!= null"
        }
    }
},
{
    "kretprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "pre": {
            "ch": "!=null"
        }
    }
},
{
    "kprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "pre": {
            "ch": "!=null"
        }
    }
},
{
    "kretprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device.",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "pre": {}
    }
},
{
    "kprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "pre": {}
    }
},


{
    "kretprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts.",
        "pre": {
            "cpu_mask": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts.",
        "pre": {
            "cpu_mask": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, error_code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        },
        "post": {
            "return": "in [0, error_code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "vmid": "!=null"
        },
        "post": {
            "return": "in [0, Error]"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "vmid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "pre": {
            "cpu_mask": "!=null",
            "start": "!=null",
            "size": "!=null",
            "asid": "!=null"
        }
    }
},
{
    "kretprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not.",
        "pre": {
            "extid": "!=null"
        }
    }
},
{
    "kprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not.",
        "pre": {
            "extid": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "skip ACPI PCI scan and IRQ initialization",
        "pre": {
            "return_value": "any"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "skip ACPI PCI scan and IRQ initialization",
        "pre": {}
    }
},
{
    "kretprobe:__udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "!=null"
        },
        "helper": {
            "function": "__const_udelay",
            "arguments": {
                "usecs": "!=null"
            }
        },
        "additional_info": {
            "constant_value": "0x10C7UL",
            "extra_info": "2  32  1000000 (rounded up)"
        }
    }
},
{
    "kprobe:__udelay": {
        "description": "Delay execution for a specified number of microseconds.",
        "pre": {
            "usecs": "!=null"
        }
    }
},



{
    "kprobe:flush_dcache_page": {
        "description": "Write back any data associated with the kernel mapping of the given page.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:addi": {
        "description": "Copy byte by byte for small copies and if src^dst != 0",
        "pre": {
            "r6": "!=null",
            "r2": "!=null",
            "r6": "!=r2",
            "r2": "!=0"
        }
    }
},
{
    "kprobe:raw_copy_to_user": {
        "description": "Copy byte by byte for small copies and if src^dst != 0",
        "pre": {
            "r2": "-1",
            "r6": "!= -1",
            "r4": "!= null",
            "r5": "!= null",
            "r2": ">= r6",
            "r2 ^ r4": "!= 0"
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range to a virtual address.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "size": ">0",
            "last_addr": ">=phys_addr",
            "return": "null if size==0 or last_addr<phys_addr"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Remap a memory area",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=0",
            "last_addr": ">=phys_addr",
            "last_addr": "<=MAX_ADDRESS_LIMIT",
            "remapped_area": "not overlapping with existing memory areas"
        }
    }
},
{
    "kretprobe:iounmap": {
        "description": "Unmaps the given I/O memory address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "Unmaps the given I/O memory address.",
        "pre": {
            "addr": "!=null"
        }
    }
},

{
    "kprobe:get_cycles": {
        "description": "Only read timer if it has been initialized",
        "pre": {
            "nios2_cs.timer.base": "!=null"
        }
    }
},


{
    "kretprobe:aes_ecb_encrypt": {
        "description": "AES ECB encryption",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    }
},
{
    "kprobe:aes_ecb_encrypt": {
        "description": "AES ECB encryption",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    }
},


{
    "kretprobe:vm_get_page_prot": {
        "description": "Returns the page protection value based on the given vm_flags.",
        "pre": {
            "vm_flags": "!=null",
            "vm_flags & VM_MTE": "== VM_MTE",
            "vma->vm_flags & VM_MTE_ALLOWED": "== VM_MTE_ALLOWED"
        }
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "Get the page protection value based on vm_flags.",
        "pre": {
            "vm_flags": "!=null",
            "prot": "!=null",
            "vm_flags & VM_MTE": "!=0",
            "prot |= PTE_ATTRINDX(MT_NORMAL_TAGGED)": "true",
            "return": "__pgprot(prot)"
        }
    }
},
{
    "kretprobe:memstart_addr": {
        "description": "Variable that holds the start address before initialization.",
        "pre": {
            "memstart_addr": "-1"
        }
    }
},
{
    "kprobe:memstart_addr": {
        "description": "Helper function to retrieve the start address of memory before initialization.",
        "pre": {
            "memstart_addr": "== -1"
        }
    }
},
{
    "kretprobe:pfn_is_map_memory": {
        "description": "Avoid false positives for bogus PFN see comment in pfn_valid().",
        "pre": {
            "pfn": "!=null"
        }
    }
},
{
    "kprobe:pfn_is_map_memory": {
        "description": "Check if the physical frame number (PFN) is associated with map memory.",
        "pre": {
            "addr": "!=null",
            "pfn": "!=null",
            "PHYS_PFN(addr)": "!=pfn",
            "memblock_is_map_memory(addr)": "==1"
        }
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "Flush the dcache for a page",
        "pre": {
            "PageHuge(page)": true,
            "compound_head(page)": "page != null",
            "test_bit(PG_dcache_clean, &page->flags)": true,
            "clear_bit(PG_dcache_clean, &page->flags)": true
        }
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "Flush the data cache for a given page.",
        "pre": {
            "page": "!=null",
            "PageHuge(page)": "true",
            "compound_head(page)": "!=null",
            "test_bit(PG_dcache_clean, &page->flags)": "true",
            "clear_bit(PG_dcache_clean, &page->flags)": "true"
        }
    }
},


{
    "kretprobe:WARN_ON_ONCE(!try_page_mte_tagging)": {
        "description": "Check if try_page_mte_tagging(to) returns false and trigger a warning if it does.",
        "pre": {
            "to": "!=null"
        }
    },
    "kretprobe:mte_copy_page_tags": {
        "description": "Copy the memory tags from page 'from' to page 'to'.",
        "pre": {
            "kto": "!=null",
            "kfrom": "!=null"
        }
    },
    "kretprobe:set_page_mte_tagged": {
        "description": "Set the MTE tag for page 'to'.",
        "pre": {
            "to": "!=null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(copy_highpage)": {
        "description": "Export the 'copy_highpage' function symbol.",
        "pre": {}
    }
},
{
    "kprobe:WARN_ON_ONCE(!try_page_mte_tagging)": {
        "description": "Check if try_page_mte_tagging(to) returns false and raise a warning if it does.",
        "pre": {
            "to": "!=null"
        }
    },
    "kprobe:mte_copy_page_tags": {
        "description": "Copy the memory tags from page 'from' to page 'to'.",
        "pre": {
            "kto": "!=null",
            "kfrom": "!=null"
        }
    },
    "kprobe:set_page_mte_tagged": {
        "description": "Set the MTE tag for page 'to'.",
        "pre": {
            "to": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(copy_highpage)": {
        "description": "Export the 'copy_highpage' function symbol.",
        "pre": {}
    }
},

{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Bounds checking against the kernel image only.",
        "pre": {
            "x": ">= (unsigned long) KERNEL_START",
            "x": "<= (unsigned long) KERNEL_END"
        }
    }
},
{
    "kretprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header for architecture-specific operations.",
        "pre": {
            "addr": "!=null",
            "max_size": ">= sizeof(struct arch_hibernate_hdr)",
            "hdr": {
                "invariants": "valid",
                "ttbr1_el1": "__pa_symbol(swapper_pg_dir)",
                "reenter_kernel": "_cpu_resume"
            }
        }
    }
},
{
    "kprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header for architecture-specific operations.",
        "pre": {
            "addr": "!=null",
            "max_size": ">=sizeof(struct arch_hibernate_hdr)",
            "hdr->invariants": "valid",
            "hdr->ttbr1_el1": "__pa_symbol(swapper_pg_dir)",
            "hdr->reenter_kernel": "_cpu_resume"
        }
    }
},


{
    "kretprobe:arch_local_irq_disable": {
        "description": "Disables local interrupts on the current CPU.",
        "pre": {
            "preempt_disable_notrace": "called",
            "__asm__ __volatile__": "contains '.setpush', '.setnoat', 'mfc0$1,$12', 'ori$1,0x1f', 'xori$1,0x1f', '.setnoreorder', 'mtc0$1,$12', '__irq_disable_hazard', '.setpop'",
            "no outputs": "true"
        }
    }
},

{
    "kretprobe:arch_local_irq_save": {
        "description": "Save the value of the flags register.",
        "pre": {
            "preempt_disable_notrace": true,
            "inline_asm_save_flags": true,
            "inline_asm_set_flags": true
        },
        "post": {
            "flags": "!=null"
        }
    }
},

{
    "kretprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value.",
        "pre": {
            "nr": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:EXPORT_SYMBOL(shm_align_mask)": {
        "description": "Helper function to calculate the alignment mask for shared memory.",
        "pre": {
            "shm_align_mask": "= PAGE_SIZE - 1",
            "PAGE_SIZE": "> 0",
            "shm_align_mask": "<= PAGE_SIZE - 1"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(shm_align_mask)": {
        "description": "Calculate the alignment mask for shared memory.",
        "pre": {
            "PAGE_SIZE": "!=null",
            "result": ">=0",
            "result": "<=PAGE_SIZE - 1"
        }
    }
},


{
    "kretprobe:has_transparent_hugepage": {
        "description": "Check if transparent huge pages are enabled.",
        "pre": {
            "mask": "== -1"
        },
        "post": {
            "mask": "== PM_HUGE_MASK"
        }
    }
},
{
    "kprobe:has_transparent_hugepage": {
        "description": "Check if transparent huge pages are enabled.",
        "pre": {
            "flags": "!=null",
            "mask": "!=null",
            "PM_HUGE_MASK": "!=null",
            "PM_DEFAULT_MASK": "!=null"
        }
    }
},




{
    "kretprobe:__flush_dcache_page": {
        "description": "__flush_dcache_page function",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "addr": "!=null",
            "!mapping_mapped(mapping)": "true",
            "PageHighMem(page)": "true"
        }
    }
},
{
    "kprobe:__flush_dcache_page": {
        "description": "__flush_dcache_page function",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "addr": "!=null"
        }
    }
},


{
    "kretprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space with control over cache coherency attributes (CCA).",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot_val": "!=null"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot_val": "!=null"
        }
    }
},
{
    "kretprobe:for (e1 = bcm47xx_board_list_melco_id; e1->value1; e1++)": {
        "description": "Iterate over the bcm47xx_board_list_melco_id array.",
        "pre": {
            "e1": "!=null",
            "e1->value1": "!=null"
        }
    }
},
{
    "kprobe:bcm47xx_board_list_melco_id": {
        "description": "Iterate over the bcm47xx_board_list_melco_id and perform operations on each element.",
        "pre": {
            "e1": "!=null",
            "e1->value1": "!=null"
        }
    }
},


{
    "kretprobe:octeon_is_simulation": {
        "description": "Return non-zero if running in the Octeon simulator, 0 otherwise.",
        "pre": {},
        "ret": "in [0, !=0]"
    }
},
{
    "kprobe:octeon_is_simulation": {
        "description": "Return non-zero if we are currently running in the Octeon simulator.",
        "pre": {
            "return_value": "!=0"
        }
    }
},
{
    "kretprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon",
        "pre": {},
        "post": {
            "return": ">0"
        }
    }
},
{
    "kprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon",
        "pre": {
            "return": "!=null"
        }
    }
},


{
    "kretprobe:octeon_ndelay_factor": {
        "description": "Calculate the octeon_ndelay_factor",
        "pre": {
            "octeon_udelay_factor": "!=null",
            "octeon_get_clock_rate()": "!=null",
            "HZ": "!=0",
            "current_cpu_type()": "==CPU_CAVIUM_OCTEON2"
        }
    }
},
{
    "kprobe:octeon_ndelay_factor": {
        "description": "Calculate the ndelay factor based on the udelay factor and clock rate.",
        "pre": {
            "octeon_udelay_factor": "!=null",
            "octeon_get_clock_rate()": "!=null",
            "HZ": "!=null",
            "current_cpu_type()": "== CPU_CAVIUM_OCTEON2"
        }
    }
},
{
    "kretprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass.",
        "pre": {
            "count": ">= 0"
        }
    }
},
{
    "kprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass.",
        "pre": {
            "count": ">=0"
        }
    }
},


{
    "kretprobe:if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))": {
        "description": "Condition for the given if statement",
        "pre": {
            "device": "PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        }
    }
},
{
    "kprobe:if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))": {
        "description": "_wrmsr() to access the registers PCI_MSR_ADDR, PCI_MSR_DATA_LO, PCI_MSR_DATA_HI, which is bigger than PCI_MSR_CTRL, so it will not go this branch, but the others. So, no calling dead loop here.",
        "pre": {
            "device": "== PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        }
    }
},


{
    "kretprobe:outb": {
        "description": "Write the value 0x0B to the PIC_MASTER_ISR register.",
        "pre": {
            "PIC_MASTER_ISR": "!=null",
            "PIC_MASTER_CMD": "!=null",
            "PIC_MASTER_IMR": "!=null",
            "PIC_CASCADE_IR": "!=null"
        }
    }
},
{
    "kprobe:outb": {
        "description": "Write the value 0x0B to the PIC_MASTER_ISR register.",
        "pre": {
            "PIC_MASTER_ISR": "!=null"
        }
    }
},
{
    "kretprobe:loongson_uart_base": {
        "description": "Ioremapped base address for Loongson UART",
        "pre": {
            "_loongson_uart_base": "!=null"
        }
    }
},
{
    "kprobe:loongson_uart_base": {
        "description": "Ioremapped base address for Loongson UART",
        "pre": {
            "base_address": "!=null"
        }
    }
},
{
    "kretprobe:mips_io_port_base": {
        "description": "mips_io_port_base is the begin of the address space to which x86 style IO ports are mapped.",
        "pre": {
            "mips_io_port_base": "!=null"
        }
    }
},
{
    "kprobe:mips_io_port_base": {
        "description": "mips_io_port_base is the begin of the address space to which x86 style IO ports are mapped.",
        "pre": {
            "mips_io_port_base": "!=null"
        }
    }
},




{
    "kretprobe:unwind_stack_by_address": {
        "description": "Unwind the stack by address.",
        "pre": {
            "stack_page": "!=null",
            "sp": "!=null",
            "pc": "!=null",
            "ra": "!=null",
            "low": "!=null",
            "high": "!=null",
            "irq_stack_high": "!=null",
            "info": "!=null",
            "size": "!=null",
            "ofs": "!=null",
            "regs": "!=null",
            "leaf": "!=null",
            "preemptible()": "false",
            "on_irq_stack(raw_smp_processor_id(), *sp)": "true"
        }
    }
},
{
    "kprobe:unwind_stack_by_address": {
        "description": "Unwind the stack by address.",
        "pre": {
            "stack_page": "!=null",
            "sp": "!=null",
            "pc": "!=null",
            "ra": "!=null",
            "low": "!=null",
            "preemptible()": "false",
            "on_irq_stack(raw_smp_processor_id(), *sp)": "true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical CPU numbers to logical CPU numbers.",
        "pre": {
            "map": "!=null",
            "key": ">=0 && <NR_CPUS",
            "value": ">=0",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical CPU numbers to logical CPU numbers.",
        "pre": {
            "map": "!=null",
            "key": ">=0",
            "key": "<NR_CPUS",
            "value": ">=0",
            "value": "<NR_CPUS"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical CPUs to physical CPUs",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical CPUs to physical CPUs.",
        "pre": {
            "map": "!=null",
            "key": ">=0",
            "key": "<NR_CPUS",
            "value": ">=0",
            "value": "<NR_CPUS"
        }
    }
},
{
    "kretprobe:flush_tlb_one_ipi": {
        "description": "Flushes the TLB for a specific page.",
        "pre": {
            "cpu": "!= smp_processor_id()",
            "cpu_context(cpu, vma->vm_mm)": "true",
            "set_cpu_context(cpu, vma->vm_mm, 1)": "true",
            "local_flush_tlb_page(vma, page)": "true",
            "preempt_enable()": "true"
        }
    }
},
{
    "kprobe:flush_tlb_one_ipi": {
        "description": "Flush the TLB for a specific page using an IPI (Inter-Processor Interrupt).",
        "pre": {
            "cpu": "!= smp_processor_id()",
            "cpu_context(cpu, vma->vm_mm)": "true",
            "set_cpu_context(cpu, vma->vm_mm, 1)": "true",
            "local_flush_tlb_page(vma, page)": "true",
            "preempt_enable()": "true"
        }
    }
},


{
    "kretprobe:request_au1000_dma": {
        "description": "Request AU1000 DMA channel",
        "pre": {
            "dev_id": ">= 0",
            "dev_str": "!= null",
            "irqhandler": "null or valid function",
            "irqflags": "valid flags",
            "irq_dev_id": "valid value"
        },
        "post": {
            "chan->io": "(void __iomem *)(KSEG1ADDR(AU1000_DMA_PHYS_ADDR) + i * DMA_CHANNEL_LEN)",
            "chan->dev_id": "dev_id",
            "chan->dev_str": "dev_str",
            "chan->fifo_addr": "dev->fifo_addr",
            "chan->mode": "dev->dma_mode"
        }
    }
},
{
    "kprobe:chan->io": {
        "description": "Assign the value of (void __iomem *)(KSEG1ADDR(AU1000_DMA_PHYS_ADDR) +i * DMA_CHANNEL_LEN) to chan->io.",
        "pre": {
            "i": ">= 0",
            "dev_id": ">= 0",
            "dev_str": "!= null",
            "dev->fifo_addr": "!= null",
            "dev->dma_mode": "!= null"
        }
    },
    "kprobe:chan->dev_id": {
        "description": "Assign the value of dev_id to chan->dev_id.",
        "pre": {
            "dev_id": ">= 0"
        }
    },
    "kprobe:chan->dev_str": {
        "description": "Assign the value of dev_str to chan->dev_str.",
        "pre": {
            "dev_str": "!= null"
        }
    },
    "kprobe:chan->fifo_addr": {
        "description": "Assign the value of dev->fifo_addr to chan->fifo_addr.",
        "pre": {
            "dev->fifo_addr": "!= null"
        }
    },
    "kprobe:chan->mode": {
        "description": "Assign the value of dev->dma_mode to chan->mode.",
        "pre": {
            "dev->dma_mode": "!= null"
        }
    }
},

{
    "kprobe:if (!dbdma_initialized)return 0;stp = find_dbdev_id(srcid);if (stp == NULL)return 0;dtp = find_dbdev_id(destid);if (dtp == NULL)return 0;used = 0;/* Check to see if we can get both channels. `": {
        "description": "Function if (!dbdma_initialized)return 0;stp = find_dbdev_id(srcid);if (stp == NULL)return 0;dtp = find_dbdev_id(destid);if (dtp == NULL)return 0;used = 0;/* Check to see if we can get both channels. `",
        "pre": {
            "dbdma_initialized": "==false",
            "srcid": "!=null",
            "find_dbdev_id(srcid)": "!=null",
            "destid": "!=null",
            "find_dbdev_id(destid)": "!=null",
            "used": "==0"
        }
    }
},


{
    "kretprobe:ctp = *((chan_tab_t **)chanid);stp = ctp->chan_src;dtp = ctp->chan_dest;/* * The descriptors must be 32-byte aligned.  There is a * possibility the allocation will give us such an addres * and if we try that first we are likely to not waste larger * slabs of memory. ": {
        "description": "Allocate a ring buffer for the specified channel ID.",
        "pre": {
            "chanid": "!=null",
            "entries": ">= 0"
        },
        "post": {
            "ctp": "!=null",
            "stp": "!=null",
            "dtp": "!=null",
            "ctp->chan_src": "32-byte aligned",
            "ctp->chan_dest": "32-byte aligned"
        }
    }
},
{
    "kprobe:au1xxx_dbdma_ring_alloc": {
        "description": "Allocate a ring buffer for the specified channel ID.",
        "pre": {
            "chanid": "!=null",
            "entries": "!=null",
            "ctp": "!=null",
            "stp": "!=null",
            "dtp": "!=null",
            "ctp->chan_src": "!=null",
            "ctp->chan_dest": "!=null",
            "ctp->chan_src % 32": "==0",
            "ctp->chan_dest % 32": "==0"
        }
    }
},








{
    "kretprobe:bcm63xx_set_cs_base": {
        "description": "bcm63xx_set_cs_base(unsigned int c u32 base, unsigned int size) - sanity check on size",
        "pre": {
            "cs": "!=null",
            "base": "!=null",
            "size": "!=null",
            "size != roundup_pow_of_two(size)": true,
            "size < 8 * 1024 || size > 256 * 1024 * 1024": true,
            "val = (base & MPI_CSBASE_BASE_MASK)": true
        }
    }
},
{
    "kprobe:bcm63xx_set_cs_base": {
        "description": "bcm63xx_set_cs_base(unsigned int c u32 base, unsigned int size) - sanity check on size",
        "pre": {
            "cs": "!=null",
            "base": "!=null",
            "size": "!=null",
            "size != roundup_pow_of_two(size)": true,
            "size < 8 * 1024 || size > 256 * 1024 * 1024": true,
            "val = (base & MPI_CSBASE_BASE_MASK)": true
        }
    }
},
{
    "kretprobe:bcm63xx_set_cs_param": {
        "description": "Set the parameters for the given cs.",
        "pre": {
            "cs": "in [MPI_CS_PCMCIA_COMMON, MPI_CS_PCMCIA_ATTR, MPI_CS_PCMCIA_IO]",
            "params": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:bcm63xx_set_cs_param": {
        "description": "Set the parameters for the cs in bcm63xx.",
        "pre": {
            "cs": "in [MPI_CS_PCMCIA_COMMON, MPI_CS_PCMCIA_ATTR, MPI_CS_PCMCIA_IO]",
            "params": "!=null"
        }
    }
},
{
    "kretprobe:enet_misc_set": {
        "description": "Ethernet MAC \"misc\" clock: dma clocks and main clock on 6348",
        "pre": {
            "clk": "!=null",
            "enable": "!=null"
        }
    }
},



{
    "kretprobe:r4030_read_reg32": {
        "description": "Reads the value from the register at address JAZZ_R4030_CHNL_ENABLE + (channel << 5).",
        "pre": {
            "status": "!=null",
            "status": "& 0x400 != 0",
            "status": "& 0x200 != 0"
        }
    }
},
{
    "kprobe:r4030_read_reg32": {
        "description": "Read a 32-bit value from the register at the specified address.",
        "pre": {
            "channel": "is_integer"
        },
        "post": {
            "status": "is_integer",
            "status & 0x400": "!= 0",
            "status & 0x200": "!= 0"
        }
    }
},
{
    "kretprobe:vdma_disable": {
        "description": "Disable a DMA channel",
        "pre": {
            "channel": "!=null",
            "vdma_debug": "==true"
        },
        "post": {
            "r4030_read_reg32(JAZZ_R4030_CHNL_ENABLE + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_MODE + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_ADDR + (channel << 5))": "==0",
            "r4030_read_reg32(JAZZ_R4030_CHNL_COUNT + (channel << 5))": "==0"
        }
    }
},
{
    "kprobe:vdma_disable": {
        "description": "Disable a DMA channel and ensure completion of the current DMA acknowledge cycle.",
        "pre": {
            "channel": "!=null"
        }
    }
},






{
    "kretprobe:smp_wmb();}EXPORT_SYMBOL(copy_user_highpage": {
        "description": "Make sure this page is cleared on other CPU's too before using it",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "!=null",
            "vma": "!=null",
            "vfrom": "!=null",
            "vto": "!=null",
            "boot_cpu_data.dcache.n_aliases": "==true",
            "page_mapcount(from)": "!=0",
            "test_bit(PG_dcache_clean, &from->flags)": "==true",
            "pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK)": "==true",
            "(vma->vm_flags & VM_EXEC)": "==true"
        }
    }
},
{
    "kprobe:smp_wmb();}EXPORT_SYMBOL(copy_user_highpage": {
        "description": "Make sure this page is cleared on other CPU's too before using it",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "!=null",
            "vma": "!=null",
            "vfrom": "!=null",
            "vto": "!=null",
            "boot_cpu_data.dcache.n_aliases": "==true",
            "page_mapcount(from)": "!=0",
            "test_bit(PG_dcache_clean, &from->flags)": "==true",
            "pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK)": "==true",
            "(vma->vm_flags & VM_EXEC)": "==true"
        }
    }
},


{
    "kretprobe:__ioremap_caller": {
        "description": "Remap an I/O memory range into the kernel's virtual memory space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=0",
            "pgprot": "!=null",
            "caller": "!=null"
        },
        "post": {
            "last_addr": "= phys_addr + size - 1",
            "!size || last_addr < phys_addr": "return null"
        }
    }
},
{
    "kprobe:__ioremap_caller": {
        "description": "Remap an I/O memory range into the kernel's virtual memory space.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "pgprot": "!=null",
            "caller": "!=null",
            "area": "!=null",
            "offset": "!=null",
            "last_addr": "!=null",
            "addr": "!=null",
            "orig_addr": "!=null",
            "mapped": "!=null"
        },
        "post": {
            "mapped": "!=null"
        },
        "additional_conditions": [
            "size != 0",
            "last_addr >= phys_addr"
        ]
    }
},



{
    "kprobe:list_for_each_entry": {
        "description": "Iterate over a list of dma_info objects",
        "pre": {
            "info": "!=null",
            "&registered_dmac_list": "!=null",
            "list": "!=null",
            "chan": "unsigned int"
        }
    }
},
{
    "kretprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:register_dmac": {
        "description": "Check if DMAC_CHANNELS_CONFIGURED flag is not set",
        "pre": {
            "info->flags": "& ~DMAC_CHANNELS_CONFIGURED == 0"
        }
    }
},
{
    "kprobe:register_dmac": {
        "description": "Register DMAC handler.",
        "pre": {
            "info->flags": "& DMAC_CHANNELS_CONFIGURED == 0"
        }
    }
},

{
    "kprobe:pcibios_scanbus": {
        "description": "Scan the PCI bus and initialize the PCI controller.",
        "pre": {
            "hose_head": "!=null",
            "hose_tail": "!=null",
            "pci_initialized": "!=null"
        }
    }
},

{
    "kprobe:sh_machine_vector": {
        "description": "Initialization of sh_machine_vector structure",
        "pre": {
            "sh_mv": "=null"
        }
    }
},




{
    "kretprobe:memcpy_fromio": {
        "description": "Copy data from an I/O memory location to a regular memory location.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">= 0x20",
            "to & 0x1f": "== 0",
            "from & 0x3": "== 0"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Copy data from an I/O memory location to a regular memory location.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">= 0x20",
            "to & 0x1f": "== 0",
            "from & 0x3": "== 0"
        }
    }
},
{
    "kretprobe:sq_flush_range": {
        "description": "Flush (prefetch) a specific SQ range",
        "pre": {
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:sq_flush_range": {
        "description": "Flush (prefetch) a specific SQ range",
        "pre": {
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:sq_remap": {
        "description": "Map a physical address through the Store Queues.",
        "pre": {
            "map": "!=null",
            "prot": "!=null",
            "map->size": ">0",
            "map->sq_addr": "!=null",
            "map->addr": "!=null",
            "map->addr >> 26": ">=0",
            "((map->addr >> 26) << 2) & 0x1c": ">=0",
            "SQ_QACR0": "!=null",
            "SQ_QACR1": "!=null"
        }
    }
},
{
    "kprobe:sq_remap": {
        "description": "Map a physical address through the Store Queues",
        "pre": {
            "map": "!=null",
            "prot": "!=null",
            "map->size": ">0",
            "map->sq_addr": "!=null",
            "map->addr": "!=null"
        }
    }
},
{
    "kretprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kretprobe:kasan_map_memory": {
        "description": "The kasan_map_memory function maps all of the required address space and the host machine will allocate physical memory as necessary.",
        "pre": {
            "address": "== (void *)KASAN_SHADOW_START",
            "size": "== KASAN_SHADOW_SIZE"
        },
        "post": {
            "kasan_um_is_ready": "== true"
        }
    }
},
{
    "kprobe:kasan_map_memory": {
        "description": "The kasan_map_memory function maps all of the required address space and the host machine will allocate physical memory as necessary.",
        "pre": {
            "address": "== (void *)KASAN_SHADOW_START",
            "size": "== KASAN_SHADOW_SIZE"
        }
    }
},
{
    "kretprobe:free_irq_by_fd": {
        "description": "Free the interrupt request line associated with the given file descriptor.",
        "pre": {
            "fd": "!=null"
        }
    }
},

{
    "kretprobe:setup_physmem": {
        "description": "Setup physical memory for UML",
        "pre": {
            "start": "!=null",
            "reserve_end": "!=null",
            "len": "!=null",
            "highmem": "!=null"
        }
    }
},
{
    "kprobe:setup_physmem": {
        "description": "Setup physical memory for UML",
        "pre": {
            "start": "!=null",
            "reserve_end": "!=null",
            "len": "!=null",
            "highmem": "!=null"
        }
    }
},
{
    "kretprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "pre": {
            "op": "!=null",
            "oparg": "!=null",
            "oval": "!=null",
            "uaddr": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN, -ENOSYS]"
        }
    }
},
{
    "kprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "pre": {
            "op": "!=null",
            "oparg": "!=null",
            "oval": "!=null",
            "uaddr": "!=null"
        }
    }
},
{
    "kretprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval.",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "!=null",
            "newval": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN]"
        }
    }
},
{
    "kprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval.",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "!=null",
            "newval": "!=null"
        }
    }
},
{
    "kretprobe:__raw_readsw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__raw_readsw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__raw_writesw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__raw_writesw": {
        "description": "Read words a short at a time.",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:csum_tcpudp_nofold": {
        "description": "Calculate the checksum for TCP/UDP packets without folding.",
        "pre": {
            "saddr": "!=null",
            "daddr": "!=null",
            "len": "!=null",
            "proto": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:csum_tcpudp_nofold": {
        "description": "Calculate the checksum for TCP/UDP packets without folding down to 32-bits.",
        "pre": {
            "saddr": "!=null",
            "daddr": "!=null",
            "len": "!=null",
            "proto": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:while (count--)": {
        "description": "Iterate `count` number of times and perform operations on the source if it is not 32-bit aligned.",
        "pre": {
            "count": ">= 0",
            "src": "!= null",
            "port": "!= null"
        },
        "post": {
            "src": {
                "if": "(unsigned long)src & 0x3 != 0",
                "then": "src += 4"
            },
            "port": {
                "if": "(unsigned long)src & 0x3 != 0",
                "then": "iowrite32(((struct S)src)->x, port)"
            }
        }
    }
},
{
    "while (count--)": {
        "pre": {
            "count": ">= 0",
            "src": "!= null",
            "src": "32-bit aligned"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmap I/O memory previously mapped with pci_iomap.",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Nothing to do",
        "pre": {
            "dev": "any",
            "addr": "any"
        }
    }
},
{
    "kretprobe:__prom_getchild": {
        "description": "Helper function that does not alter return values.",
        "pre": {},
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__prom_getchild": {
        "description": "prom_getchild that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:__prom_getsibling": {
        "description": "Function that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:__prom_getsibling": {
        "description": "Helper function that does not alter return values.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:prom_nodeops->no_getprop": {
        "description": "Get a property value from a device tree node.",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": ">0"
        }
    },
    "kretprobe:restore_current": {
        "description": "Restore the current task.",
        "pre": {}
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Return the value of 'ret' variable.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Lock the spinlock and save the IRQ state.",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": "!=null"
        }
    }
},
{
    "kretprobe:prom_searchsiblings": {
        "description": "Search for siblings of a given node in the device tree.",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null",
            "thisnode": "!=null",
            "error": "int",
            "promlib_buf": "char[128]"
        },
        "post": {
            "return": "int",
            "error": "== -1",
            "nodename": "== promlib_buf"
        }
    }
},
{
    "kprobe:prom_searchsiblings": {
        "description": "Search for siblings of a given node in the device tree.",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null",
            "error": "== -1",
            "promlib_buf": "!=null"
        }
    }
},
{
    "kretprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        }
    }
},
{
    "kretprobe:prom_getchild": {
        "description": "Get the child node of the given node.",
        "pre": {
            "node": "!=null"
        }
    },
    "kretprobe:prom_searchsiblings": {
        "description": "Search for the sibling node of the given node with the specified name.",
        "pre": {
            "node": "!=null",
            "nbuf": "!=null"
        }
    },
    "kretprobe:return_0": {
        "description": "Return 0 if the node is null.",
        "pre": {
            "node": "==null"
        }
    },
    "kretprobe:return_1": {
        "description": "Return 1 if the character at the current position is '@'.",
        "pre": {
            "s": "==\"@\""
        }
    }
},
{
    "kprobe:prom_getchild": {
        "description": "Get the child node of the given node.",
        "pre": {
            "node": "!=null"
        }
    },
    "kprobe:prom_searchsiblings": {
        "description": "Search for siblings of the given node using the provided name.",
        "pre": {
            "node": "!=null",
            "nbuf": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return statement.",
        "pre": {
            "node": "==null"
        }
    },
    "kprobe:prom_finddevice": {
        "description": "Find a device with the given name.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'.",
        "pre": {
            "node": "!=null",
            "buffer": "!=null",
            "buffer_length": ">=32"
        }
    }
},
{
    "kprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'.",
        "pre": {
            "node": "!=null",
            "buffer": "!=null",
            "buffer_length": ">=32"
        }
    }
},








{
    "kretprobe:mmu_info": {
        "description": "Print MMU information",
        "pre": {
            "m": "!=null",
            "tlb_type": "in [cheetah, cheetah_plu spitfire, hypervisor]",
            "pgsz_strings": "!=null",
            "cpu_pgsz_mask": "!=null",
            "CONFIG_DEBUG_DCFLUSH": "defined",
            "dcpage_flushes": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:#endif /* CONFIG_DEBUG_DCFLUSH `": {
        "description": "Flush the instruction cache.",
        "pre": {
            "tlb_type": "in [cheetah, cheetah_plu spitfire, hypervisor]",
            "cpu_pgsz_mask": "!=null",
            "dcpage_flushes": "!=null"
        }
    }
},




{
    "kretprobe:reduce_memory": {
        "description": "Reduce memory and exclude reserved regions",
        "pre": {
            "limit_ram": "!=null",
            "exclude_regions": ["vmlinux", "initrd"],
            "lower_limit": "initrd_size"
        }
    }
},





{
    "kretprobe:vio_vdev_node": {
        "description": "Find VDEV node in MD",
        "pre": {
            "hp": "!=null",
            "vdev": "!=null"
        }
    }
},





{
    "kretprobe:ent->err_handle = 0;wmb();put_cpu();if (local_copy.err_type == SUN4V_ERR_TYPE_SHUTDOWN_RQST)": {
        "description": "Check if the err_type field of local_copy is equal to SUN4V_ERR_TYPE_SHUTDOWN_RQST",
        "pre": {},
        "post": {
            "local_copy.err_type": "== SUN4V_ERR_TYPE_SHUTDOWN_RQST"
        }
    }
},
{
    "kprobe:ent->err_handle = 0;wmb();put_cpu();if (local_copy.err_type == SUN4V_ERR_TYPE_SHUTDOWN_RQST)": {
        "description": "Set err_handle to 0, perform a write memory barrier, release the CPU, and check if err_type is SUN4V_ERR_TYPE_SHUTDOWN_RQST.",
        "pre": {
            "local_copy.err_type": "== SUN4V_ERR_TYPE_SHUTDOWN_RQST"
        }
    }
},
{
    "kretprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "pre": {
            "vio": "!=null",
            "tp": "!=null",
            "tp->type": "== VIO_TYPE_CTRL",
            "tp->stype": "== VIO_SUBTYPE_INFO",
            "tp->stype_env": "== VIO_VER_INFO"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "pre": {
            "vio": "!=null",
            "tp": "!=null",
            "tp->type": "== VIO_TYPE_CTRL",
            "tp->stype": "== VIO_SUBTYPE_INFO",
            "tp->stype_env": "== VIO_VER_INFO"
        },
        "post": {
            "return": "== 0"
        }
    }
},






{
    "kretprobe:floppy_irq": {
        "description": "Set the value of floppy_irq to irq and calculate cpu_irq.",
        "pre": {
            "irq": "!=null",
            "NR_IRQS": "!=null",
            "floppy_irq": "irq",
            "cpu_irq": "(irq & (NR_IRQS - 1))"
        }
    }
},
{
    "kprobe:floppy_irq": {
        "description": "Assign the value of 'irq' to 'floppy_irq' and calculate 'cpu_irq' based on 'irq' and 'NR_IRQS'.",
        "pre": {
            "irq": "!=null",
            "NR_IRQS": "!=null",
            "floppy_irq": "!=null",
            "cpu_irq": "!=null"
        }
    }
},
{
    "kretprobe:atomic_t_nmi_active": {
        "description": "Initialize the atomic_t variable nmi_active with the value 0.",
        "pre": {
            "nmi_active": "==0"
        }
    }
},
{
    "kprobe:atomic_t_nmi_active": {
        "description": "Helper for the atomic_t nmi_active variable.",
        "pre": {
            "nmi_active": ">0 or <0 or 0"
        }
    }
},
{
    "kretprobe:__ldc_channel_exists": {
        "description": "Check if a channel with a given ID already exists in the ldc_channel_list.",
        "pre": {
            "ldc_channel_list": "!=null",
            "id": "unsigned long",
            "mutex": "exists",
            "spinlock": "exists"
        }
    }
},
{
    "kprobe:__ldc_channel_exists": {
        "description": "Check if a channel with the given ID exists in ldc_channel_list.",
        "pre": {
            "ldc_channel_list": "initialized",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:ldc_bind": {
        "description": "Bind an LDC channel",
        "pre": {
            "lp": {
                "state": "== LDC_STATE_INIT"
            }
        },
        "post": {
            "lp": {
                "hs_state": "== LDC_HS_COMPLETE"
            },
            "flags": "&= ~LDC_FLAG_REGISTERED_QUEUES",
            "cfg": {
                "rx_irq": "enable_irq",
                "tx_irq": "enable_irq",
                "mode": "!= LDC_MODE_RAW"
            }
        }
    }
},
{
    "kprobe:ldc_bind": {
        "description": "Binds an LDC channel",
        "pre": {
            "lp": {
                "state": "== LDC_STATE_INIT"
            }
        }
    }
},






{
    "kretprobe:if (lp->hs_state == LDC_HS_COMPLETE)": {
        "description": "Check if the value of lp->hs_state is equal to LDC_HS_COMPLETE.",
        "pre": {
            "lp": "!=null",
            "lp->hs_state": "== LDC_HS_COMPLETE"
        }
    }
},

{
    "kretprobe:ldc_copy": {
        "description": "Copy data using the ldc_copy helper function.",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": "!=null",
            "offset": "!=null",
            "cookies": "!=null",
            "ncookies": "!=null",
            "ra": "aligned to 8 bytes",
            "lp->hs_state": "== LDC_HS_COMPLETE",
            "lp->flags": "not set LDC_FLAG_RESET"
        },
        "post": {
            "return": "orig_len - len"
        }
    }
},
{
    "kprobe:return orig_len - len;}EXPORT_SYMBOL(ldc_copy": {
        "description": "Calculate the difference between orig_len and len and return the result.",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": "!=null",
            "offset": "!=null",
            "cookies": "!=null",
            "ncookies": "!=null"
        }
    }
},
{
    "kretprobe:set_auxio": {
        "description": "Set the AUXIO register with the given bits on and off.",
        "pre": {
            "bits_on": "!=null",
            "bits_off": "!=null",
            "auxio_register": "!=null",
            "sparc_cpu_model": "==sun4m"
        }
    }
},
{
    "kprobe:set_auxio": {
        "description": "Set the AUXIO register with the given bits.",
        "pre": {
            "bits_on": "!=null",
            "bits_off": "!=null"
        }
    }
},
{
    "kretprobe:get_area": {
        "description": "Get the unmapped area for a file.",
        "pre": {
            "filp": "!=null",
            "orig_addr": "==null",
            "len": "!=null",
            "pgoff": "!=null",
            "flags": "!=null",
            "align_goal": "in [PAGE_SIZE, 4UL * 1024 * 1024, 512UL * 1024, 64UL * 1024]"
        }
    }
},
{
    "kprobe:get_area": {
        "description": "Helper function to get the unmapped area for a file.",
        "pre": {
            "filp": "!=null",
            "orig_addr": "==null",
            "len": "!=null",
            "pgoff": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:_map_to_cpu": {
        "description": "This function maps an index to a CPU.",
        "pre": {
            "index": "!=null",
            "num_online_cpus()": "<= num_possible_cpus()",
            "cpu_online(cpu_rover)": "true",
            "cpu_rover": "< end",
            "cpu_rover": ">= 0",
            "cpu_rover": "< num_possible_cpus()",
            "cpu_rover": "!= null",
            "end": "<= num_online_cpus()",
            "i": ">= 0",
            "i": "< num_possible_cpus()"
        }
    }
},
{
    "kprobe:return cpumask_first(cpu_online_mask);}static int _map_to_cpu(unsigned int index)": {
        "description": "This function maps an index to a CPU.",
        "pre": {
            "index": "!=null",
            "index": ">= 0",
            "index": "< num_possible_cpus()",
            "num_online_cpus()": "<= num_possible_cpus()"
        }
    }
},
{
    "kretprobe:pci_set_master": {
        "description": "Set the master bit for the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->class": "PCI_CLASS_STORAGE_IDE << 8",
            "dev->current_state": "PCI_UNKNOWN"
        }
    }
},
{
    "kprobe:pci_set_master": {
        "description": "Set the master bit for the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->class": "PCI_CLASS_STORAGE_IDE << 8",
            "dev->current_state": "PCI_UNKNOWN"
        }
    }
},


{
    "kretprobe:mdesc_get_node_ops": {
        "description": "Find the get_info op for the given node name",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        }
    }
},
{
    "kprobe:mdesc_get_node_ops": {
        "description": "Find the get_info op for the given node name",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        }
    }
},
{
    "kretprobe:idp = mdesc_get_property": {
        "description": "Get the value of the 'id' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "idp": "!=null"
        }
    },
    "kretprobe:name = mdesc_get_property": {
        "description": "Get the value of the 'name' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "name": "!=null"
        }
    },
    "kretprobe:parent_cfg_hdlp = parent_cfg_handle": {
        "description": "Get the value of the 'parent_cfg_hdl' property from the 'md' structure.",
        "pre": {
            "md": "!=null",
            "node": "!=null"
        },
        "post": {
            "parent_cfg_hdlp": "!=null"
        }
    },
    "kretprobe:!idp || !name || !parent_cfg_hdlp": {
        "description": "Check if any of the variables 'idp', 'name', or 'parent_cfg_hdlp' is null.",
        "pre": {
            "idp": "!=null",
            "name": "!=null",
            "parent_cfg_hdlp": "!=null"
        },
        "post": {
            "return": "-1"
        }
    },
    "kretprobe:node_info->vdev_port.id = *idp": {
        "description": "Assign the value of 'idp' to 'node_info->vdev_port.id'.",
        "pre": {
            "idp": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:node_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL)": {
        "description": "Assign the value of 'name' to 'node_info->vdev_port.name' using 'kstrdup_const' function.",
        "pre": {
            "name": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:!node_info->vdev_port.name": {
        "description": "Check if 'node_info->vdev_port.name' is null.",
        "pre": {
            "node_info": "!=null"
        },
        "post": {
            "return": "-1"
        }
    },
    "kretprobe:node_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp": {
        "description": "Assign the value of 'parent_cfg_hdlp' to 'node_info->vdev_port.parent_cfg_hdl'.",
        "pre": {
            "parent_cfg_hdlp": "!=null",
            "node_info": "!=null"
        }
    },
    "kretprobe:return 0": {
        "description": "Return 0 to indicate successful execution of the function."
    },
    "kretprobe:rel_vdev_port_node_info": {
        "description": "Release the memory allocated for 'node_info'.",
        "pre": {
            "node_info": "!=null"
        }
    }
},
{
    "kprobe:idp = mdesc_get_property(md, node, \"id\", NULL);name = mdesc_get_property(md, node, \"name\", NULL);parent_cfg_hdlp = parent_cfg_handle(md, node);if (!idp || !name || !parent_cfg_hdlp)return -1;node_info->vdev_port.id = *idp;node_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);if (!node_info->vdev_port.name)return -1;node_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;return 0;}static void rel_vdev_port_node_info(union md_node_info *node_info)":{
        "description": "This function retrieves information about a virtual device port node.",
        "pre": {
            "md": "!=null",
            "node": "!=null",
            "idp": "!=null",
            "name": "!=null",
            "parent_cfg_hdlp": "!=null",
            "node_info->vdev_port.id": "!=null",
            "node_info->vdev_port.name": "!=null",
            "node_info->vdev_port.parent_cfg_hdl": "!=null"
        }
    }
},


{
    "kretprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},
{
    "kprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum.",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},


{
    "movl_%%ecx_%%edx": {
        "description": "String comparison using cmpsb instruction",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first occurrence of the substring ct in the string cs.",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},


{
    "kretprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is being copied to devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">0"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check if uninitialized memory is being copied to devices.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">0"
        }
    }
},
{
    "kretprobe:memset_io": {
        "description": "The memset_io function sets the value of each byte in the memory range pointed to by 'a' to the value of 'b'.",
        "pre": {
            "a": "!=null",
            "b": "any",
            "c": ">=0"
        }
    }
},
{
    "kprobe:memset_io": {
        "description": "Set the value of the memory region starting at address *a* to *b* for *c* bytes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:clear_user": {
        "description": "Zero a block of memory in user space.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:clear_user": {
        "description": "Zero a block of memory in user space.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:unsigned_long__clear_user": {
        "description": "Zero a block of memory in user space, with less checking.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:unsigned_long__clear_user": {
        "description": "Zero a block of memory in user space, with less checking.",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:csum_partial": {
        "description": "Calculate the checksum of a partial buffer.",
        "pre": {
            "buff": "!=null",
            "len": "==40",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:csum_partial": {
        "description": "Calculate the checksum of a partial buffer.",
        "pre": {
            "buff": "!=null",
            "len": "==40",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:alloc_p2m_pmd": {
        "description": "Allocate a new PMD level if it is missing.",
        "pre": {
            "addr": "!=null",
            "pte_pg": "!=null"
        },
        "post": {
            "ptep": "!=null"
        }
    },
    "kretprobe:p2m_top_mfn": {
        "description": "Check if p2m_top_mfn is not null.",
        "pre": {},
        "post": {
            "p2m_top_mfn": "!=null"
        }
    },
    "kretprobe:pfn": {
        "description": "Check if pfn is less than MAX_P2M_PFN.",
        "pre": {},
        "post": {
            "pfn": "< MAX_P2M_PFN"
        }
    }
},
{
    "kprobe:alloc_p2m_pmd": {
        "description": "Allocate a new pmd entry for the given address.",
        "pre": {
            "addr": "!=null",
            "pte_pg": "!=null"
        }
    },
    "kprobe:lookup_address": {
        "description": "Look up the address and retrieve the corresponding pte entry.",
        "pre": {
            "addr": "!=null",
            "level": "==PG_LEVEL_4K"
        }
    },
    "kprobe:p2m_missing_pte": {
        "description": "Check if the pte_pg is equal to p2m_missing_pte.",
        "pre": {
            "pte_pg": "==p2m_missing_pte"
        }
    },
    "kprobe:p2m_identity_pte": {
        "description": "Check if the pte_pg is equal to p2m_identity_pte.",
        "pre": {
            "pte_pg": "==p2m_identity_pte"
        }
    },
    "kprobe:p2m_top_mfn": {
        "description": "Check if p2m_top_mfn is not null.",
        "pre": {
            "p2m_top_mfn": "!=null"
        }
    },
    "kprobe:pfn": {
        "description": "Check if pfn is less than MAX_P2M_PFN.",
        "pre": {
            "pfn": "<MAX_P2M_PFN"
        }
    }
},
{
    "kretprobe:BUILD_BUG_ON": {
        "description": "Build-time check to ensure SZ_4K / BLAKE2S_BLOCK_SIZE >= 8",
        "pre": {},
        "post": {}
    },
    "kretprobe:static_branch_likely": {
        "description": "Check if static branch blake2s_use_ssse3 is likely",
        "pre": {},
        "post": {}
    },
    "kretprobe:may_use_simd": {
        "description": "Check if SIMD instructions can be used",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:BUILD_BUG_ON": {
        "description": "Check if the size of SZ_4K divided by BLAKE2S_BLOCK_SIZE is less than 8.",
        "pre": {
            "SZ_4K / BLAKE2S_BLOCK_SIZE": "< 8"
        }
    },
    "kprobe:static_branch_likely": {
        "description": "Check if the static branch 'blake2s_use_ssse3' is likely to be true.",
        "pre": {
            "&blake2s_use_ssse3": "== true"
        }
    },
    "kprobe:may_use_simd": {
        "description": "Check if SIMD (Single Instruction, Multiple Data) instructions can be used.",
        "pre": {
            "may_use_simd()": "== true"
        }
    }
},
{
    "kretprobe:cpuid_eax": {
        "description": "Get the value of the EAX register using the cpuid instruction.",
        "pre": {
            "eax": "==0x80000000"
        }
    },
    "kretprobe:IBS_CPUID_FEATURES": {
        "description": "Check if the IBS CPUID feature is supported.",
        "pre": {
            "max_level": ">= IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:IBS_CAPS_DEFAULT": {
        "description": "Return the default value for IBS capabilities.",
        "pre": {
            "max_level": "< IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:cpuid_eax": {
        "description": "Get the value of the EAX register using the cpuid instruction.",
        "pre": {
            "eax": "==IBS_CPUID_FEATURES"
        }
    },
    "kretprobe:IBS_CAPS_AVAIL": {
        "description": "Check if IBS capabilities are available.",
        "pre": {
            "caps": "& IBS_CAPS_AVAIL"
        }
    }
},
{
    "kprobe:cpuid_eax": {
        "description": "Get the value of the CPUID register with input argument 0x80000000.",
        "pre": {
            "max_level": "< IBS_CPUID_FEATURES"
        }
    },
    "kprobe:IBS_CPUID_FEATURES": {
        "description": "Check if IBS CPUID feature is available.",
        "pre": {
            "caps": "& IBS_CAPS_AVAIL"
        }
    }
},
{
    "kretprobe:setup_node_to_cpumask_map": {
        "description": "Initialize the node to cpumask map.",
        "pre": {
            "CONFIG_DEBUG_PER_CPU_MAPS": "enabled"
        }
    }
},
{
    "kprobe:setup_node_to_cpumask_map": {
        "description": "Initialize the node to cpumask map.",
        "pre": {
            "CONFIG_DEBUG_PER_CPU_MAPS": "enabled"
        }
    }
},


{
    "kretprobe:return ret;}EXPORT_SYMBOL(register_kmmio_probe": {
        "description": "Registers a kmmio probe.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "ret": "!=null",
            "size": ">=0",
            "addr": ">=0",
            "size_lim": ">=0",
            "l": ">=0",
            "pte": "!=null"
        }
    }
},
{
    "kprobe:return ret;}EXPORT_SYMBOL(register_kmmio_probe": {
        "description": "Registers a kmmio probe.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "ret": "!=null",
            "size": ">=0",
            "addr": "!=null",
            "size_lim": ">=0",
            "l": "!=null",
            "pte": "!=null"
        }
    }
},
{
    "kretprobe:call_rcu(&drelease->rcu, remove_kmmio_fault_pages);}EXPORT_SYMBOL(unregister_kmmio_probe": {
        "description": "This function unregisters a kmmio probe and performs some cleanup operations.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "size": ">=0",
            "addr": "!=null",
            "size_lim": ">=0",
            "release_list": "==null",
            "drelease": "!=null",
            "l": ">=0",
            "pte": "!=null",
            "kmmio_count": ">0"
        }
    }
},
{
    "kprobe:call_rcu(&drelease->rcu, remove_kmmio_fault_pages);}EXPORT_SYMBOL(unregister_kmmio_probe": {
        "description": "Unregister a kmmio probe and remove associated fault pages.",
        "pre": {
            "p": "!=null",
            "p->addr": "!=null",
            "p->len": "!=null",
            "p->addr & PAGE_MASK": "==p->addr & PAGE_MASK",
            "size_lim": "p->len + (p->addr & ~PAGE_MASK)",
            "release_list": "==NULL",
            "drelease": "!=NULL",
            "drelease->release_list": "==release_list"
        }
    }
},
{
    "kretprobe:vm_get_page_prot": {
        "description": "Generate Z3 conditions for vm_get_page_prot function",
        "pre": {
            "vm_flags": "!=null",
            "val": "!=null",
            "val & _PAGE_PRESENT": "==0",
            "__supported_pte_mask": "!=null"
        }
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "Get the page protection flags based on the vm_flags.",
        "pre": {
            "vm_flags": "!=null"
        }
    }
},


{
    "kretprobe:__phys_addr_symbol": {
        "description": "__phys_addr_symbol(unsigned long x) - Calculate the physical address corresponding to a given virtual address.",
        "pre": {
            "x": "!=null"
        },
        "post": {
            "y": ">= __START_KERNEL_map",
            "y": "<= KERNEL_IMAGE_SIZE",
            "return_value": ">= y + phys_base"
        }
    }
},



"post": {
    "return_value": "!=null"
},
{
    "kprobe:ioremap_uc": {
        "description": "map bus memory into CPU space as strongly uncachable",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "pcm": "==_PAGE_CACHE_MODE_UC_MINUS",
            "__builtin_return_address(0)": "!=null",
            "false": "==false"
        }
    }
},
{
    "kretprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:fix_addr": {
        "description": "Fix the top bit of the address if needed, otherwise it is a no-op.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:fix_addr": {
        "description": "Fix the top bit of the address if needed, otherwise it is a no-op.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:set_memory_wb": {
        "description": "Set memory cache mode to Write-Back (WB)",
        "pre": {
            "addr": "!=null",
            "numpages": "!=null"
        }
    }
},
{
    "kprobe:set_memory_wb": {
        "description": "Set the memory write-back cache mode for the specified address range.",
        "pre": {
            "addr": "!=null",
            "numpages": "!=null"
        }
    }
},
{
    "kretprobe:cpa_clear_pages_array": {
        "description": "Clear the pages array with write-back cache mode.",
        "pre": {
            "pages": "!=null",
            "numpages": ">=0",
            "__pgprot(_PAGE_CACHE_MASK)": "!=null"
        },
        "post": {
            "retval": "==0",
            "i": ">=0",
            "i": "<numpages"
        }
    }
},
{
    "kprobe:cpa_clear_pages_array": {
        "description": "Clears the pages array",
        "pre": {
            "pages": "!=null",
            "numpages": "any integer"
        }
    }
},
{
    "kretprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it.",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it.",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state()",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state().",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:scx200_probe": {
        "description": "Probe function for scx200",
        "pre": {
            "pdev": "!=null",
            "ent": "!=null"
        }
    }
},
{
    "kprobe:scx200_probe": {
        "description": "Probe function for scx200",
        "pre": {
            "bank": ">= 0 and < 2",
            "scx200_gpio_shadow[bank]": "= inl(scx200_gpio_base + 0x10 * bank)",
            "pdev": "!= null",
            "ent": "!= null"
        }
    }
},


{
    "kretprobe:iosf_mbi_available": {
        "description": "Mbi isn't hot-pluggable. No remove routine is provided.",
        "pre": {}
    }
},
{
    "kprobe:return_mbi_pdev": {
        "description": "Check if Mbi is available.",
        "pre": {}
    }
},

{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "&iosf_mbi_pmic_access_mutex"
        }
    },
    "kprobe:while": {
        "description": "Loop while a condition is true.",
        "pre": {
            "condition": "iosf_mbi_pmic_i2c_access_count != 0"
        }
    }
},


{
    "kretprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering the notifier block.",
        "pre": {
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:iosf_mbi_punit_acquire": {
        "description": "Acquire the P-Unit lock.",
        "pre": {},
        "post": {
            "ret": ">= 0"
        }
    },
    "kretprobe:iosf_mbi_unregister_pmic_bus_access_notifier_unlocked": {
        "description": "Unregister the PMIC bus access notifier.",
        "pre": {
            "nb": "!= null"
        },
        "post": {
            "ret": ">= 0"
        }
    },
    "kretprobe:iosf_mbi_punit_release": {
        "description": "Release the P-Unit lock.",
        "pre": {},
        "post": {}
    },
    "kretprobe:iosf_mbi_assert_punit_acquired": {
        "description": "Assert that the P-Unit is acquired.",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:iosf_mbi_punit_acquire": {
        "description": "Acquire the punit.",
        "pre": {}
    },
    "kprobe:iosf_mbi_unregister_pmic_bus_access_notifier_unlocked": {
        "description": "Unregister the PMIC bus access notifier.",
        "pre": {
            "nb": "!=null"
        }
    },
    "kprobe:iosf_mbi_punit_release": {
        "description": "Release the punit.",
        "pre": {}
    },
    "kprobe:return": {
        "description": "Return the value.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(iosf_mbi_unregister_pmic_bus_access_notifier)": {
        "description": "Export the symbol iosf_mbi_unregister_pmic_bus_access_notifier.",
        "pre": {}
    },
    "kprobe:void iosf_mbi_assert_punit_acquired(void)": {
        "description": "Assert that the punit is acquired.",
        "pre": {}
    }
},


{
    "kretprobe:pcibios_align_resource": {
        "description": "Align the PCI resource according to the specified size and alignment.",
        "pre": {
            "data": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "dev": "!=null",
            "start": "!=null",
            "flags": "in [IORESOURCE_IO, IORESOURCE_MEM]"
        },
        "post": {
            "start": ">= BIOS_END"
        }
    }
},




{
    "kprobe:/* * outb_pic - this has to work on a wide range of PC hardware. ": {
        "description": "This function is responsible for handling the outb_pic operation on a wide range of PC hardware.",
        "pre": {
            "legacy_pic": "==null",
            "i8259A_lock": "!=null",
            "auto_eoi": "in [0, 1]",
            "PIC_MASTER_IMR": "==0xff"
        }
    }
},


{
    "kretprobe:profile_pc": {
        "description": "Profile the program counter",
        "pre": {
            "regs": "!=null",
            "pc": "!=null",
            "user_mode(regs)": "==false",
            "in_lock_functions(pc)": "==true",
            "sp[0] >> 22": "==true",
            "sp[1] >> 22": "==true"
        }
    }
},
{
    "kprobe:profile_pc": {
        "description": "Profile the program counter.",
        "pre": {
            "regs": "!=null",
            "pc": "!=null",
            "user_mode(regs)": "false",
            "in_lock_functions(pc)": "true",
            "sp[0] >> 22": "true",
            "sp[1] >> 22": "true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(cpu_khz)": {
        "description": "Returns the TSC clocks in microseconds.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(cpu_khz)": {
        "description": "Measure TSC clocks in microseconds (not used here).",
        "pre": {
            "usec": "not used"
        }
    }
},
{
    "kretprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC.",
        "pre": {
            "art_ns": "!=null",
            "tsc_khz": "!=null",
            "X86_FEATURE_TSC_KNOWN_FREQ": "==true"
        },
        "post": {
            "cycles": "!=null",
            "cs": "!=null"
        }
    }
},
{
    "kprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC.",
        "pre": {
            "art_ns": "!=null",
            "tsc_khz": "!=null",
            "X86_FEATURE_TSC_KNOWN_FREQ": "==true"
        },
        "post": {
            "cycles": "!=null",
            "cs": "!=null"
        }
    }
},
{
    "kretprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id.",
        "pre": {
            "phys_pkg": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= -1"
        }
    }
},
{
    "kprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id.",
        "pre": {
            "phys_pkg": "!=null",
            "phys_pkg": "unsigned int",
            "return_value": "int"
        },
        "post": {
            "return_value": "in [-1, 0, 1, 2, ...]"
        }
    }
},
{
    "kretprobe:spin_lock(&rtc_lock);CMOS_WRITE(0x00, 0x8f);spin_unlock(&rtc_lock);/* * Switch to the trampoline page table.`": {
        "description": "Reboot the machine and switch to the trampoline page table.",
        "pre": {
            "rtc_lock": "locked"
        },
        "post": {
            "rtc_lock": "unlocked",
            "CMOS_WRITE": {
                "register": "0x00",
                "value": "0x8f"
            }
        }
    }
},
{
    "kprobe:spin_lock": {
        "description": "Acquire the spin lock associated with rtc_lock.",
        "pre": {
            "rtc_lock": "!=null"
        }
    },
    "kprobe:CMOS_WRITE": {
        "description": "Write the value 0x8f to CMOS register number 0x00.",
        "pre": {
            "register": "0x00",
            "value": "0x8f"
        }
    },
    "kprobe:spin_unlock": {
        "description": "Release the spin lock associated with rtc_lock.",
        "pre": {
            "rtc_lock": "!=null"
        }
    }
},
{
    "kretprobe:native_io_delay": {
        "description": "The native_io_delay function should be a constant.",
        "pre": {
            "native_io_delay": "==constant"
        }
    }
},
{
    "kprobe:native_io_delay": {
        "description": "The native_io_delay function should be a constant.",
        "pre": {
            "native_io_delay": "==constant"
        }
    }
},
{
    "kretprobe:pin_2_irq": {
        "description": "Converts pin number to IRQ number.",
        "pre": {
            "i": "!=null",
            "ioapic_idx": "!=null",
            "mp_irqs[i].dstirq": "!=null",
            "0": "!=null"
        },
        "post": {
            "irq": ">0",
            "!IO_APIC_IRQ(irq)": "true",
            "pin": "== (mp_irqs[i].srcbusirq & 3)"
        }
    }
},
{
    "kprobe:pin_2_irq": {
        "description": "Converts a pin number to an IRQ number.",
        "pre": {
            "i": "!=null",
            "ioapic_idx": "!=null",
            "mp_irqs[i].dstirq": "!=null",
            "pin": "!=null",
            "irq": ">0",
            "!IO_APIC_IRQ(irq)": "true",
            "pin": "== (mp_irqs[i].srcbusirq & 3)"
        }
    }
},


{
    "kretprobe:native_write_cr0": {
        "description": "Write the value to the CR0 register and warn if the WP bit is missing.",
        "pre": {
            "val": "!=null",
            "bits_missing": "!=null",
            "static_branch_likely(&cr_pinning)": "true",
            "unlikely((val & X86_CR0_WP) != X86_CR0_WP)": "true"
        }
    }
},
{
    "kprobe:native_write_cr0": {
        "description": "Write the value to the CR0 register and set the missing bits if necessary.",
        "pre": {
            "bits_missing": "!=null"
        }
    }
},
{
    "kretprobe:reserve_perfctr_nmi": {
        "description": "Reserve performance counter for non-maskable interrupt (NMI).",
        "pre": {
            "counter": "> NMI_MAX_COUNTER_BITS",
            "!test_and_set_bit(counter, perfctr_nmi_owner)": "true"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:reserve_perfctr_nmi": {
        "description": "Reserve a performance counter for non-maskable interrupt (NMI) handling.",
        "pre": {
            "msr": "!=null",
            "counter": "!=null",
            "counter > NMI_MAX_COUNTER_BITS": "return 1",
            "!test_and_set_bit(counter, perfctr_nmi_owner)": "return 1",
            "return 0": ""
        }
    }
},


{
    "kretprobe:reserve_evntsel_nmi": {
        "description": "Reserve event select for non-maskable interrupt (NMI).",
        "pre": {
            "counter": "> NMI_MAX_COUNTER_BITS",
            "!test_and_set_bit(counter, evntsel_nmi_owner)": "== 0"
        }
    }
},
{
    "kprobe:reserve_evntsel_nmi": {
        "description": "Reserve an event select MSR for NMI.",
        "pre": {
            "msr": "!=null",
            "counter": "!=null",
            "counter > NMI_MAX_COUNTER_BITS": "true",
            "!test_and_set_bit(counter, evntsel_nmi_owner)": "true"
        },
        "post": {
            "return": "0"
        }
    }
},


{
    "kretprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids",
        "pre": {
            "match": "!=null"
        },
        "post": {
            "return": "in [null, !=null]"
        }
    }
},
{
    "kprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids.",
        "pre": {
            "match": "!=null"
        }
    }
},


{
    "kretprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:irq_fpu_usable": {
        "description": "Check if the in-kernel FPU usage is already active.",
        "pre": {
            "in_nmi()": "==false"
        },
        "post": {
            "return": "==true"
        }
    }
},
{
    "kprobe:if (this_cpu_read(in_kernel_fpu))return false;/* * When not in NMI or hard interrupt context, FPU can be used in: * * - Task context except from within fpregs_lock()'ed critical *   regions. * * - Soft interrupt processing context which cannot happen *   while in a fpregs_lock()'ed critical region. */": {
        "description": "Check if the in_kernel_fpu is readable on the current CPU and return false if it is.",
        "pre": {
            "in_nmi()": "false"
        }
    }
},


{
    "kretprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": "!=null"
        }
    }
},
{
    "kretprobe:memmove": {
        "description": "Move a block of memory from one location to another.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">0",
            "v_dst + c": "<= v_src",
            "v_src + c": "<= v_dst"
        }
    }
},
{
    "memmove": {
        "description": "Move a block of memory from one location to another.",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">0"
        },
        "post": {
            "success": "true"
        }
    }
},

{
    "memset": {
        "description": "Set a block of memory to a specified value.",
        "pre": {
            "v_src": "!=null",
            "c": "any",
            "n": "valid_size"
        },
        "post": {
            "memory_block": {
                "start_address": "v_src",
                "size": "n",
                "value": "c"
            }
        }
    }
},

{
    "kprobe:if (mapping && !mapping_mapped(mapping))": {
        "description": "Check if the mapping exists and the page is not mapped to user-space.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:local_flush_cache_page": {
        "description": "Flushes the cache page for a given virtual address and physical address.",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kprobe:local_flush_cache_page": {
        "description": "Flushes the cache for a specific page.",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},

{
    "kprobe:EXPORT_SYMBOL(ccount_freq)": {
        "description": "Count the frequency of events at a specific frequency.",
        "pre": {
            "freq": ">=0"
        }
    }
},

{
    "kprobe:xtensa_backtrace_user": {
        "description": "Look through the register window for the previous PCs in the call trace.",
        "pre": {
            "regs": "!=null",
            "depth": ">= 0",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:spill_registers": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:spill_registers": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:return_address": {
        "description": "Returns the return address from the caller of this function.",
        "pre": {
            "level": "== 0"
        }
    }
},
{
    "kprobe:return_address": {
        "description": "Get the return address from the caller of the function.",
        "pre": {
            "level": ">= 0"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy a byte at a time until the destination is aligned.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">= MIN_THRESHOLD",
            "distance": "== 0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy a byte at a time until the destination is aligned.",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0",
            "count": "<=MIN_THRESHOLD",
            "distance": "==0"
        }
    }
},






{
    "kretprobe:result += (__force u32)sum;/* 32+c bits -> 32 bits `": {
        "description": "Add the value of sum to the result variable.",
        "pre": {
            "result": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kprobe:result += (__force u32)sum;/* 32+c bits -> 32 bits `": {
        "description": "Add the value of sum to the result variable.",
        "pre": {
            "result": "!=null",
            "sum": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:flush_tlb_range": {
        "description": "Flush the Translation Lookaside Buffer (TLB) for a given range of virtual memory addresses.",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "end": "!=null",
            "mm": "!=null",
            "size": "end - start",
            "nbits": "ia64_fls(size + 0xfff)",
            "mm == current->active_mm": true,
            "nbits < purge.max_bits": true,
            "nbits > purge.max_bits": false,
            "start &= ~((1UL << nbits) - 1)": true,
            "cpumask_weight(mm_cpumask(mm)) == 1": true
        }
    }
},
{
    "kprobe:flush_tlb_range": {
        "description": "Flush the TLB entries for a given range of virtual memory addresses.",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "end": "!=null"
        }
    }
},
{
    "kretprobe:kern_mem_attribute": {
        "description": "Get the memory attribute for the given physical address and size.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        },
        "post": {
            "attr": "!=null"
        }
    },
    "kretprobe:phys_to_virt": {
        "description": "Convert the given physical address to a virtual address.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:attr & EFI_MEMORY_WB": {
        "description": "Check if the attribute has EFI_MEMORY_WB flag set.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:attr & EFI_MEMORY_UC": {
        "description": "Check if the attribute has EFI_MEMORY_UC flag set.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__IA64_UNCACHED_OFFSET | phys_addr": {
        "description": "Calculate the virtual address by adding the uncached offset to the physical address.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:phys_to_virt(phys_addr)": {
        "description": "Convert the given physical address to a virtual address using phys_to_virt helper.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:__ioremap_uc(phys_addr)": {
        "description": "Remap the given physical address with uncached attribute using __ioremap_uc helper.",
        "pre": {
            "phys_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kern_mem_attribute": {
        "description": "Get the memory attribute for the given physical address and size.",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null"
        }
    },
    "kprobe:phys_to_virt": {
        "description": "Convert the given physical address to a virtual address.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:__ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:ioremap_uc": {
        "description": "Remap the given physical address with uncached attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:__ioremap": {
        "description": "Remap the given physical address with default attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    },
    "kprobe:ioremap": {
        "description": "Remap the given physical address with default attribute.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},


{
    "kretprobe:node_cpuid[cpu].phys_id": {
        "description": "Set the physical ID of the CPU.",
        "pre": {
            "cpu": "!=null",
            "physid": "!=null",
            "handle": "!=null"
        }
    },
    "kretprobe:node_cpuid[cpu].nid": {
        "description": "Set the NUMA node ID of the CPU.",
        "pre": {
            "cpu": "!=null",
            "handle": "!=null"
        }
    },
    "kretprobe:additional_cpus": {
        "description": "Set the value of additional CPUs.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:node_cpuid[cpu].phys_id = physid;node_cpuid[cpu].nid = acpi_get_node(handle);#endifreturn 0;}int additional_cpus __initdata = -1;static __init int setup_additional_cpus(char *s)": {
        "description": "Set the physical ID and NUMA node ID for the specified CPU.",
        "pre": {
            "cpu": "!=null",
            "physid": "!=null",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:acpi_unmap_cpu": {
        "description": "Unmap the CPU and perform NUMA specific cleanup.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:acpi_unmap_cpu": {
        "description": "Unmap the CPU and perform NUMA specific cleanup.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:acpi_register_ioapic": {
        "description": "Registers an IOAPIC device with ACPI.",
        "pre": {
            "handle": "!=null",
            "phys_addr": "!=null",
            "gsi_base": "!=null"
        }
    }
},
{
    "kprobe:acpi_register_ioapic": {
        "description": "Registers an IOAPIC device with ACPI.",
        "pre": {
            "handle": "!=null",
            "phys_addr": "!=null",
            "gsi_base": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(ia64_iobase)": {
        "description": "virtual address for IO accesses",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(ia64_iobase)": {
        "description": "virtual address for IO accesses",
        "pre": {
            "arg0": "!=null"
        }
    }
},
{
    "kretprobe:ia64_itc_udelay": {
        "description": "Delays execution for the specified number of microseconds using the ITC values.",
        "pre": {
            "usecs": ">= 0"
        }
    }
},
{
    "kprobe:ia64_itc_udelay": {
        "description": "Delays the execution for the specified number of microseconds.",
        "pre": {
            "usecs": ">= 0"
        }
    }
},
{
    "kretprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable.",
        "pre": {
            "can_cpei_retarget() || !is_cpu_cpei_target(num)": true,
            "sysfs_cpus[num].cpu.hotpluggable": 1,
            "map_cpu_to_node(num, node_cpuid[num].nid)": true,
            "return register_cpu(&sysfs_cpus[num].cpu, num)": true
        }
    }
},
{
    "kprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable",
        "pre": {
            "can_cpei_retarget() || !is_cpu_cpei_target(num)": true,
            "sysfs_cpus[num].cpu.hotpluggable": 1,
            "map_cpu_to_node(num, node_cpuid[num].nid)": true,
            "register_cpu(&sysfs_cpus[num].cpu, num)": true
        }
    }
},


{
    "kretprobe:static DEFINE_SPINLOCK(mlogbuf_rlock)": {
        "description": "Defines a spinlock named mlogbuf_rlock for normal contexts.",
        "pre": {
            "mlogbuf_rlock": "!=null"
        }
    }
},



{
    "kretprobe:nat = 0; return 0;": {
        "description": "Set `nat` to 0 and return 0.",
        "pre": {
            "nat": "== 0"
        }
    }
},



{
    "kretprobe:if (!unw_valid(info, info->rp_loc))": {
        "description": "Check if the return IP pointer is valid",
        "pre": {
            "info": "!=null",
            "info->rp_loc": "!=null"
        }
    }
},
{
    "kprobe:if (!unw_valid(info, info->rp_loc))": {
        "description": "Check if the return IP pointer is valid in the unw_frame_info structure.",
        "pre": {
            "info": "!=null",
            "info->rp_loc": "!=null"
        }
    }
},
{
    "kretprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node.",
        "pre": {
            "starting_nid": "!=null",
            "n_pages": "!=null"
        }
    }
},
{
    "kprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node.",
        "pre": {
            "starting_nid": "!=null",
            "n_pages": "!=null"
        }
    }
},
{
    "kretprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">=0"
        }
    }
},
{
    "kprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">=0"
        }
    }
},
O,

{
    "kretprobe:udelay": {
        "description": "Use only for very small delays (< 1 msec).",
        "pre": {
            "smp_processor_id": "!=null"
        }
    }
},
{
    "kprobe:udelay": {
        "description": "Use only for very small delays (< 1 msec).",
        "pre": {
            "smp_processor_id": "!=null"
        }
    }
},
{
    "kretprobe:FIXUP_MEMADDR_VGA": {
        "description": "Adjust the address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:FIXUP_MEMADDR_VGA": {
        "description": "Adjust the address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:return ~0;}voidmarvel_iowrite8": {
        "description": "This function writes the value `~0` to the I/O address specified by `xaddr`.",
        "pre": {
            "b": "!=null",
            "xaddr": "!=null"
        }
    }
},
{
    "kprobe:return ~0;}voidmarvel_iowrite8": {
        "description": "This function writes the value `~0` to the I/O address specified by `xaddr`.",
        "pre": {
            "b": "!=null",
            "xaddr": "!=null"
        }
    }
},
O,

{
    "kretprobe:irongate_iounmap": {
        "description": "Free the memory associated with the given address if it is not equal to zero.",
        "pre": {
            "addr": "!=0"
        }
    }
},
{
    "kprobe:irongate_iounmap": {
        "description": "Free the virtual memory associated with the given physical address.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:dump_elf_thread": {
        "description": "dump_elf_thread(elf_greg_t dest, struct pt_regs pt, struct thread_info ti). Switch stack follows right below pt_regs.",
        "pre": {
            "dest": "!=null",
            "pt": "!=null",
            "ti": "!=null"
        },
        "post": {
            "dest[0]": "== pt->r0",
            "dest[1]": "== pt->r1",
            "dest[2]": "== pt->r2",
            "dest[3]": "== pt->r3",
            "dest[4]": "== pt->r4",
            "dest[5]": "== pt->r5",
            "dest[6]": "== pt->r6",
            "dest[7]": "== pt->r7",
            "dest[8]": "== pt->r8",
            "dest[9]": "== ((struct switch_stack *) pt) - 1)->r9",
            "dest[10]": "== ((struct switch_stack *) pt) - 1)->r10",
            "dest[11]": "== ((struct switch_stack *) pt) - 1)->r11",
            "dest[12]": "== ((struct switch_stack *) pt) - 1)->r12",
            "dest[13]": "== ((struct switch_stack *) pt) - 1)->r13",
            "dest[14]": "== ((struct switch_stack *) pt) - 1)->r14",
            "dest[15]": "== ((struct switch_stack *) pt) - 1)->r15",
            "dest[16]": "== pt->r16",
            "dest[17]": "== pt->r17",
            "dest[18]": "== pt->r18",
            "dest[19]": "== pt->r19",
            "dest[20]": "== pt->r20",
            "dest[21]": "== pt->r21",
            "dest[22]": "== pt->r22",
            "dest[23]": "== pt->r23",
            "dest[24]": "== pt->r24",
            "dest[25]": "== pt->r25",
            "dest[26]": "== pt->r26",
            "dest[27]": "== pt->r27",
            "dest[28]": "== pt->r28",
            "dest[29]": "== pt->gp",
            "dest[30]": "== (ti == current_thread_info() ? rdusp() : ti->pcb.usp)",
            "dest[31]": "== pt->pc"
        }
    }
},
{
    "kprobe:dump_elf_thread": {
        "description": "Dump the ELF thread",
        "pre": {
            "dest": "!=null",
            "pt": "!=null",
            "ti": "!=null",
            "sw": "!=null",
            "sw == ((struct switch_stack *) pt) - 1": true,
            "dest[0] == pt->r0": true,
            "dest[1] == pt->r1": true,
            "dest[2] == pt->r2": true,
            "dest[3] == pt->r3": true,
            "dest[4] == pt->r4": true,
            "dest[5] == pt->r5": true,
            "dest[6] == pt->r6": true,
            "dest[7] == pt->r7": true,
            "dest[8] == pt->r8": true,
            "dest[9] == sw->r9": true,
            "dest[10] == sw->r10": true,
            "dest[11] == sw->r11": true,
            "dest[12] == sw->r12": true,
            "dest[13] == sw->r13": true,
            "dest[14] == sw->r14": true,
            "dest[15] == sw->r15": true,
            "dest[16] == pt->r16": true,
            "dest[17] == pt->r17": true,
            "dest[18] == pt->r18": true,
            "dest[19] == pt->r19": true,
            "dest[20] == pt->r20": true,
            "dest[21] == pt->r21": true,
            "dest[22] == pt->r22": true,
            "dest[23] == pt->r23": true,
            "dest[24] == pt->r24": true,
            "dest[25] == pt->r25": true,
            "dest[26] == pt->r26": true,
            "dest[27] == pt->r27": true,
            "dest[28] == pt->r28": true,
            "dest[29] == pt->gp": true,
            "dest[30] == (ti == current_thread_info() ? rdusp() : ti->pcb.usp)": true,
            "dest[31] == pt->pc": true
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "pre": {
            "smp_num_cpus": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "pre": {
            "smp_num_cpus": "==1"
        }
    }
},
{
    "kretprobe:on_each_cpu(ipi_imb, NULL, 1);}EXPORT_SYMBOL(smp_imb": {
        "description": "Must wait for other processors to flush their icache before continuing.",
        "pre": {
            "ipi_imb": "!=null"
        }
    }
},
{
    "kprobe:on_each_cpu(ipi_imb, NULL, 1);}EXPORT_SYMBOL(smp_imb": {
        "description": "Must wait for other processors to flush their icache before continuing.",
        "pre": {
            "ipi_imb": "null",
            "NULL": "null",
            "1": "null"
        }
    }
},
{
    "kretprobe:flush_tlb_mm": {
        "description": "Flush the TLB entries for a given memory mapping.",
        "pre": {
            "vma": "!=null",
            "start": "valid_memory_address",
            "end": "valid_memory_address",
            "vma_mapping": "valid_memory_mapping",
            "memory_range": "valid_memory_range"
        }
    }
},
{
    "kprobe:flush_tlb_mm": {
        "description": "Flush the TLB range for the given vm_area_struct.",
        "pre": {
            "vma": "!=null",
            "start": "unsigned long",
            "end": "unsigned long"
        },
        "post": "Flushes the TLB range specified by start and end for the given vma."
    }
},
{
    "kretprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "count": ">= 8",
            "to": "& 7 == 0",
            "from": "& 7 == 0"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "count": ">= 8",
            "to": "& 7 == 0",
            "from": "& 7 == 0"
        }
    }
},
{
    "kretprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},




{
    "kretprobe:readb_relaxed": {
        "description": "Read a byte from the given I/O memory address in a relaxed manner.",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:readb_relaxed": {
        "description": "Read a byte from the given I/O memory address using relaxed ordering.",
        "pre": {
            "addr": "!=null"
        }
    }
},




{
    "kretprobe:min_high_pfn = PFN_DOWN(high_mem_start);max_high_pfn = PFN_DOWN(high_mem_start + high_mem_sz);/* * max_high_pfn should be ok here for both HIGHMEM and HIGHMEM+PAE. * For HIGHMEM without PAE max_high_pfn should be less than * min_low_pfn to guarantee that these two regions don't overlap. * For PAE case highmem is greater than lowmem, so it is natural * to use max_high_pfn. * * In both case holes should be handled by pfn_valid(). ": {
        "description": "Generate conditions for min_high_pfn and max_high_pfn",
        "pre": {
            "high_mem_start": "!=null",
            "high_mem_sz": "!=null",
            "min_low_pfn": "!=null",
            "max_high_pfn": "!=null",
            "pfn_valid()": "handles the hole in the memory map."
        },
        "post": {
            "max_high_pfn": "< min_low_pfn"
        }
    }
},
{
    "kprobe:min_high_pfn = PFN_DOWN(high_mem_start);max_high_pfn = PFN_DOWN(high_mem_start + high_mem_sz);/* * max_high_pfn should be ok here for both HIGHMEM and HIGHMEM+PAE. * For HIGHMEM without PAE max_high_pfn should be less than * min_low_pfn to guarantee that these two regions don't overlap. * For PAE case highmem is greater than lowmem, so it is natural * to use max_high_pfn. * * In both case holes should be handled by pfn_valid(). ": {
        "description": "Generate conditions for min_high_pfn and max_high_pfn",
        "pre": {
            "min_high_pfn": "!=null",
            "max_high_pfn": "!=null",
            "max_high_pfn < min_low_pfn": "when high_mem_sz > 0",
            "pfn_valid()": "should handle holes in the memory map"
        }
    }
},


{
    "kretprobe:read_decode_cache_bcr_arcv2": {
        "description": "Read the Cache Build Configuration Register Decode them, and save into the cpuinfo structure for later use.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:read_decode_cache_bcr_arcv2": {
        "description": "Read the Cache Build Configuration Register decode them, and save into the cpuinfo structure for later use.",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:flush_icache_range": {
        "description": "Shortcut for bigger flush ranges. Here we don't care if this was kernel virtual or phy addr",
        "pre": {
            "kstart": "!=null",
            "kend": "!=null",
            "tot_sz": "!=null",
            "kstart < TASK_SIZE": true
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Shortcut for bigger flush ranges. Here we don't care if this was kernel virtual or phy addr",
        "pre": {
            "kstart": "!=null",
            "kend": "!=null",
            "tot_sz": "kend - kstart",
            "tot_sz > PAGE_SIZE": true
        }
    }
},
{
    "kretprobe:ioremap": {
        "description": "Map a physical address range into kernel virtual memory.",
        "pre": {
            "paddr": "!=null",
            "size": "!=0",
            "end": "!=null",
            "end < paddr": "true"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Map the physical address range specified by *paddr* and *size* into virtual memory.",
        "pre": {
            "paddr": "!=null",
            "size": "!=0",
            "end": "= paddr + size - 1",
            "end < paddr": "return NULL",
            "return": "!=NULL"
        }
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "Remap a physical address range into the kernel's virtual address space with specified protection flags.",
        "pre": {
            "paddr": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Remap physical addresses to virtual addresses with specific access flags.",
        "pre": {
            "paddr": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:arch_local_irq_enable": {
        "description": "Enable interrupts.",
        "pre": {
            "called_from": "in [hard-ISR, soft-ISR]",
            "interrupt_priorities": "not inverted when called_from == hard-ISR",
            "interrupts_enabled": "all when called_from == soft-ISR",
            "L1_interrupts_enabled": "not re-enabled when flow == L1 ISR ==> interrupted by L2 ISR ==> L2 soft ISR"
        }
    }
},
{
    "kprobe:arch_local_irq_enable": {
        "description": "Enable interrupts.",
        "pre": {
            "called_from": {
                "in": ["hard-ISR", "soft-ISR"]
            },
            "interrupt_priorities": {
                "if": "called_from == 'hard-ISR'",
                "then": {
                    "inverted": false
                }
            },
            "interrupts_enabled": {
                "if": "called_from == 'soft-ISR'",
                "then": true
            },
            "re_enable_L1": {
                "if": "called_from == 'soft-ISR' && flow == 'L1 ISR ==> interrupted by L2 ISR ==> L2 soft ISR'",
                "then": false
            }
        }
    }
},


{
    "kretprobe:ioread8_rep": {
        "description": "Read 8-bit values from memory and repeat the operation count times.",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:ioread8_rep": {
        "description": "Read `count` bytes from `addr` and store them in `dst`.",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},


{
    "kretprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at SRC.",
        "pre": {
            "port": "!=null",
            "dst": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at SRC. SRC must be at least short aligned. This is used by the IDE driver to read disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the inw() breaks things.",
        "pre": {
            "port": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},




{
    "kretprobe:outsw": {
        "description": "Write data from source to the specified port in the opposite direction.",
        "pre": {
            "port": "!=null",
            "src": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:outsw": {
        "description": "Write data from source buffer to the specified port.",
        "pre": {
            "port": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},


{
    "kretprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path.",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path.",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},


{
    "kretprobe:pdc_iodc_read": {
        "description": "Read data from the modules IODC.",
        "pre": {
            "actcnt": "!=null",
            "hpa": "!=null",
            "index": "!=null",
            "iodc_data": "!=null",
            "iodc_data_size": "!=null"
        }
    }
},
{
    "kprobe:pdc_iodc_read": {
        "description": "Read data from the modules IODC.",
        "pre": {
            "actcnt": "!=null",
            "hpa": "!=null",
            "index": "!=null",
            "iodc_data": "!=null",
            "iodc_data_size": "!=null"
        }
    }
},
{
    "kretprobe:pdc_lan_station_id": {
        "description": "Get the LAN address.",
        "pre": {
            "lan_addr": "!=null",
            "hpa": "!=null"
        }
    }
},
{
    "kprobe:pdc_lan_station_id": {
        "description": "Get the LAN address.",
        "pre": {
            "lan_addr": "!=null",
            "hpa": "!=null"
        }
    }
},
{
    "kretprobe:pdc_stable_read": {
        "description": "Read data from Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kprobe:pdc_stable_read": {
        "description": "Read data from Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kretprobe:pdc_stable_write": {
        "description": "Write data to Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kprobe:pdc_stable_write": {
        "description": "Write data to Stable Storage.",
        "pre": {
            "staddr": "!=null",
            "memaddr": "!=null",
            "count": "!=null",
            "count": "% 4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kretprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "pre": {
            "void": "pdc_stable_verify_contents()",
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "pre": {
            "void": "null"
        }
    }
},
{
    "kretprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator. This PDC call will erase all contents of Stable Storage. Use with care!",
        "pre": {
            "void": "pdc_stable_initialize()",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kretprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kretprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock.",
        "pre": {
            "sec": "!=null",
            "usec": "!=null"
        }
    }
},
{
    "kprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock.",
        "pre": {
            "sec": ">=0",
            "usec": ">=0"
        }
    }
},

{
    "kprobe:if (btlb_info.max_size==0)": {
        "description": "Check if btlb_info.max_size is equal to 0.",
        "pre": {
            "btlb_info.max_size": "==0"
        }
    }
},

{
    "kprobe:asm_syncdma": {
        "description": "Ensure DMA is complete",
        "pre": {
            "!IS_ENABLED(CONFIG_SMP)": true,
            "!arch_irqs_disabled()": true,
            "size": ">= parisc_cache_flush_threshold"
        }
    }
},


{
    "kretprobe:fb_is_primary_device": {
        "description": "Check if the given framebuffer is the primary device.",
        "pre": {
            "info": "!=null",
            "sti": "==null"
        }
    }
},
{
    "kprobe:if (!sti)return true;/* return true if it's the default built-in framebuffer driver `": {
        "description": "Check if it's the default built-in framebuffer driver",
        "pre": {
            "sti": "!=null"
        }
    }
},
{
    "kretprobe:__delay": {
        "description": "Loop 'loops' times. Callers must not assume a specific amount of time passes before this function returns.",
        "pre": {
            "loops": "!=null",
            "loops": ">=0",
            "loops": "is_integer"
        }
    }
},




{
    "kprobe:__atomic_add_const": {
        "description": "Put the reader into the wait queue",
        "pre": {
            "rw": "arch_rwlock_t",
            "in_interrupt()": false,
            "rw->cnts & 0x10000": 0
        }
    }
},
{
    "kretprobe:__atomic_add": {
        "description": "Put the writer into the wait queue",
        "pre": {
            "rw": "!=null",
            "__atomic_add(0x20000, &rw->cnts)": "!=null"
        }
    }
},
{
    "kprobe:__atomic_add": {
        "description": "Add 0x20000 to the value of rw->cnts.",
        "pre": {
            "rw": "!=null",
            "rw->cnts": "!=null",
            "__atomic_add(0x20000, &rw->cnts)": "true"
        }
    }
},
{
    "kretprobe:return result + size;/* Nope. ": {
        "description": "This function returns the sum of 'result' and 'size'.",
        "pre": {
            "result": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:return result + size;/* Nope. `": {
        "description": "Calculate the sum of result and size.",
        "pre": {
            "result": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:strlen": {
        "description": "Find the length of a string",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:strlen": {
        "description": "Find the length of a string",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:strnlen": {
        "description": "Find the length of a length-limited string",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "<=min(strlen(s), n)"
        }
    }
},
{
    "kprobe:strnlen": {
        "description": "Find the length of a length-limited string",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copy a %NUL terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "dest"
        }
    }
},
{
    "kprobe:strcpy": {
        "description": "Copy a %NUL terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strcat": {
        "description": "Append one %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "is the same as dest"
        }
    }
},
{
    "kprobe:strcat": {
        "description": "Append one %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "dest"
        }
    }
},
{
    "kretprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "is a pointer to dest"
        }
    }
},
{
    "kprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return_value": "==0 if s1 and s2 are equal, <0 if s1 is less than s2, >0 if s1 is greater than s2"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return": "is an integer"
        }
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a NUL terminated string.",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        },
        "post": {
            "return": "in [ s + n]"
        }
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:_copy_from_user_key": {
        "description": "Copy data from user space to kernel space with key",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "size": "!=null",
            "key": "!=null",
            "rem": "((from + 4095) & -4096)",
            "val": "nr%[val]"
        }
    }
},
{
    "kprobe:nr%[rem],%[val]": {
        "description": "Function: nr%[rem],%[val]\nrem = (from + 4095) & -4096",
        "pre": {
            "from": "!=null",
            "rem": "((from + 4095) & -4096)"
        }
    }
},
{
    "kretprobe:nr%[rem],%[val]": {
        "description": "Description of the function nr%[rem],%[val]",
        "pre": {
            "to": "!=null",
            "size": "!=null",
            "rem": "!=null",
            "val": "!=null"
        },
        "post": {
            "rem": "(to + 4095) & -4096"
        }
    }
},
{
    "kprobe:nr%[rem],%[val]": {
        "description": "Helper function to calculate rem = (to + 4095) & -4096",
        "pre": {
            "to": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:chacha_crypt_arch": {
        "description": "chacha_crypt_arch helper function",
        "pre": {
            "bytes": "<= CHACHA_BLOCK_SIZE",
            "nrounds": "!= 20",
            "MACHINE_HAS_VX": "== false"
        }
    }
},
{
    "kprobe:chacha_crypt_arch": {
        "description": "Perform chacha20 encryption/decryption using the s390 implementation.",
        "pre": {
            "bytes": "<= CHACHA_BLOCK_SIZE || nrounds != 20 || !MACHINE_HAS_VX"
        }
    }
},
{
    "kretprobe:set_pte": {
        "description": "Reset the protection bits of a page table entry.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null",
            "ptep": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:set_pte": {
        "description": "Reset the protection bits of a page table entry.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null",
            "ptep": "!=null",
            "new": "!=null"
        }
    }
},




{
    "kretprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit.",
        "pre": {
            "mm": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "orc": "in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
            "oldpte": "!=null",
            "oldpgste": "!=null"
        },
        "post": {
            "return": "in [1, 0, < 0]",
            "return_description": "1 if the page is to be added to the CBRL, otherwise 0, or < 0 in case of error.",
            "return_constraints": {
                "1": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
                "0": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
                "< 0": "orc in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]"
            }
        }
    }
},
{
    "kprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "orc": "in [ESSA_SET_1, ESSA_SET_2, ESSA_SET_3, ESSA_SET_4]",
            "oldpte": "null or !=null",
            "oldpgste": "null or !=null"
        },
        "return": "in [1, 0, < 0]"
    }
},
{
    "kretprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "bits": "!=null",
            "value": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "bits": "!=null",
            "value": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "pgstep": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address.",
        "pre": {
            "mm": "!=null",
            "hva": "!=null",
            "pgstep": "!=null"
        },
        "return": "< 0"
    }
},
{
    "kretprobe:__segment_load": {
        "description": "Load a segment",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is an integer",
            "addr": "!=null",
            "end": "!=null"
        },
        "post": {
            "return": "< 0 || >= 0"
        }
    }
},
{
    "kprobe:__segment_load": {
        "description": "Load a segment",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is int",
            "addr": "!=null",
            "end": "!=null",
            "return": "< 0 || >= 0"
        }
    }
},
{
    "kretprobe:segment_save": {
        "description": "Save segment content permanently",
        "pre": {
            "name": "!=null",
            "MACHINE_IS_VM": "true",
            "seg": "!=null",
            "ref_count": "==0",
            "seg->res": "!=null",
            "seg->start_addr": "!=null",
            "seg->end - seg->start_addr + 1": ">0"
        }
    }
},
{
    "kprobe:segment_save": {
        "description": "Save segment content permanently.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:segment_warning": {
        "description": "Print appropriate error message for segment_load()segment_type() return code.",
        "pre": {
            "rc": "!=null",
            "seg_name": "!=null"
        }
    }
},
{
    "kprobe:segment_warning": {
        "description": "Print appropriate error message for segment_load()segment_type() return code.",
        "pre": {
            "rc": "is_int",
            "seg_name": "is_valid_char_pointer"
        }
    }
},
{
    "kretprobe:function_name": {
        "description": "Description of the function",
        "pre": {
            "qin->qopcode": "DCSS_FINDSEGA",
            "qin->qoutptr": "!=null",
            "qin->qoutlen": "sizeof(struct qout64)",
            "qin->qname": "seg->dcss_name",
            "diag_cc": "< 0"
        }
    }
},
{
    "kprobe:qin->qopcode": {
        "description": "Set qopcode to DCSS_FINDSEGA",
        "pre": {
            "qopcode": "DCSS_FINDSEGA"
        }
    },
    "kprobe:qin->qoutptr": {
        "description": "Set qoutptr to the address of qout",
        "pre": {
            "qoutptr": "address of qout"
        }
    },
    "kprobe:qin->qoutlen": {
        "description": "Set qoutlen to the size of struct qout64",
        "pre": {
            "qoutlen": "sizeof(struct qout64)"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy seg->dcss_name to qin->qname with a length of 8",
        "pre": {
            "qname": "copy of seg->dcss_name with length 8"
        }
    },
    "kprobe:dcss_diag": {
        "description": "Call dcss_diag with segext_scode, qin, dummy, and vmrc",
        "pre": {
            "segext_scode": "no specific constraints",
            "qin": "no specific constraints",
            "dummy": "no specific constraints",
            "vmrc": "no specific constraints"
        }
    },
    "kprobe:if (diag_cc < 0)": {
        "description": "Check if diag_cc is less than 0"
    }
},
{
    "kretprobe:segment_unload": {
        "description": "Decrease the use count of a DCSS segment and remove it from the address space if nobody is using it any longer.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:voidsegment_unload": {
        "description": "Decrease the use count of a DCSS segment and remove it from the address space if nobody is using it any longer.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pci_iomap_range_mio": {
        "description": "Detect overrun",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null",
            "offset": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:WARN_ON(!++zpci_iomap_start[idx].count);zpci_iomap_start[idx].fh = zdev->fh;zpci_iomap_start[idx].bar = bar;spin_unlock(&zpci_iomap_lock);return (void __iomem *) ZPCI_ADDR(idx) + offset;}static void __iomem *pci_iomap_range_mio(struct pci_dev *pdev, int bar, unsigned long offset, unsigned long max)": {
        "description": "pci_iomap_range_mio function with WARN_ON check and return value calculation",
        "pre": {
            "pdev": "!=null",
            "bar": "int",
            "offset": "unsigned long",
            "max": "unsigned long",
            "zpci_iomap_start[idx].count": "int",
            "zdev->fh": "!=null",
            "zpci_iomap_start[idx].bar": "int",
            "zpci_iomap_lock": "spinlock_t"
        }
    }
},




{
    "kretprobe:stsi": {
        "description": "Store system information. Returns the current configuration level if function code 0 was specified. Otherwise returns 0 on success or a negative value on error.",
        "pre": {
            "sysinfo": "!=null",
            "fc": "!=null",
            "sel1": "!=null",
            "sel2": "!=null",
            "lvl": "!=null"
        }
    }
},
{
    "kprobe:stsi": {
        "description": "Store system information",
        "pre": {
            "sysinfo": "!=null",
            "fc": "!=null",
            "sel1": "!=null",
            "sel2": "!=null",
            "lvl": "!=null"
        }
    }
},
{
    "kretprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "pre": {
            "num": "!=null"
        }
    }
},
{
    "kprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "pre": {
            "num": "!=null"
        }
    }
},


{
    "kretprobe:debug_register_mode": {
        "description": "Creates and initializes a debug area.",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">=0",
            "nr_areas": ">=0",
            "buf_size": ">=0",
            "mode": ">=0",
            "uid": "==0",
            "gid": "==0"
        }
    }
},
{
    "kprobe:debug_register_mode": {
        "description": "Creates and initializes a debug area.",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">=0",
            "nr_areas": ">=0",
            "buf_size": ">=0",
            "mode": ">=0",
            "uid": "==0",
            "gid": "==0"
        }
    }
},


{
    "kretprobe:debug_unregister": {
        "description": "Give back debug area.",
        "pre": {
            "id": "!=null",
            "loop": {
                "index": "i",
                "range": {
                    "start": 0,
                    "end": "DEBUG_MAX_VIEWS - 1"
                },
                "body": {
                    "if": {
                        "condition": "id->views[i] != null",
                        "body": {
                            "debugfs_remove": "id->debugfs_entries[i]"
                        }
                    }
                }
            },
            "debugfs_remove": "id->debugfs_root_entry",
            "assignments": [
                {
                    "condition": "id == debug_area_first",
                    "assignment": "debug_area_first = id->next"
                },
                {
                    "condition": "id == debug_area_last",
                    "assignment": "debug_area_last = id->prev"
                },
                {
                    "condition": "id->prev",
                    "assignment": "id->prev->next = id->next"
                },
                {
                    "condition": "id->next",
                    "assignment": "id->next->prev = id->prev"
                }
            ]
        },
        "post": {
            "return": "none"
        }
    }
},
{
    "kprobe:debug_unregister": {
        "description": "Give back debug area.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "pre": {
            "id": "!=null",
            "new_level": "int"
        },
        "post": {
            "return": "none"
        }
    }
},
{
    "kprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "pre": {
            "id": "!=null",
            "new_level": "!=null"
        }
    }
},
{
    "kretprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed.",
        "pre": {},
        "post": {
            "return": "null"
        }
    }
},
{
    "kprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed.",
        "pre": {
            "none": "true"
        }
    }
},
{
    "kretprobe:debug_event_common": {
        "description": "Write debug entry with given size",
        "pre": {
            "id": "!=null",
            "level": "any",
            "buf": "!=null",
            "len": ">0"
        }
    }
},

{
    "kretprobe:debug_exception_common": {
        "description": "write debug entry with given size and switch to next debug area",
        "pre": {
            "id": "!=null",
            "level": "any integer value",
            "buf": "!=null",
            "len": "any integer value"
        },
        "return_value": "!=null"
    }
},
{
    "kprobe:debug_exception_common": {
        "description": "write debug entry with given size and switch to next debug area",
        "pre": {
            "id": "!=null",
            "level": "is an integer",
            "buf": "!=null",
            "len": "is an integer"
        }
    }
},
{
    "kretprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs directory entry.",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs directory entry.",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        }
    }
},
{
    "kretprobe:debug_feature_version": {
        "description": "Used by dump analysis tools to determine the version of debug feature.",
        "pre": {
            "__used debug_feature_version": "!=null"
        }
    }
},
{
    "kprobe:debug_feature_version": {
        "description": "Static global variable representing the debug feature version.",
        "pre": {
            "debug_feature_version": "= __DEBUG_FEATURE_VERSION"
        }
    }
},
{
    "kretprobe:get_phys_clock": {
        "description": "Helper function to get the physical clock.",
        "pre": {
            "clock": "!=null",
            "sw_ptr": "!=null",
            "sw0": "!=null",
            "sw1": "!=null"
        },
        "post": {
            "return": "in [0, -EOPNOTSUPP, -EACCE -EAGAIN]",
            "!test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": true,
            "!test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": true,
            "sw0": "sw1",
            "(sw0 & 0x80000000U)": true
        }
    }
},
{
    "kprobe:return_0_if_not_supported": {
        "description": "Return 0 if the clock synchronization has STP and STP is set, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "true",
            "test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": "true"
        }
    },
    "kprobe:return_0_if_synced": {
        "description": "Return 0 if the clock synchronization has STP and STP is not set, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "true",
            "test_bit(CLOCK_SYNC_STP, &clock_sync_flags)": "false"
        }
    },
    "kprobe:return_error": {
        "description": "Return -EAGAIN if the clock synchronization does not have STP, otherwise return -EACCES.",
        "pre": {
            "clock_sync_flags": "!=null",
            "test_bit(CLOCK_SYNC_HAS_STP, &clock_sync_flags)": "false"
        }
    }
},
{
    "kretprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null"
        }
    }
},
{
    "kprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null"
        }
    }
},
{
    "kretprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Save floating point control": {
        "description": "Limit the save to the FPUvector registers already in use by the previous context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Save floating point control `": {
        "description": "Limit the save to the FPUvector registers already in use by the previous context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Restore floating-point controls": {
        "description": "Limit the restore to the FPUvector registers of the previous context that have been overwritten by the current context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:flags &= state->mask;if (flags & KERNEL_FPC)/* Restore floating-point controls": {
        "description": "Limit the restore to the FPUvector registers of the previous context that have been overwritten by the current context",
        "pre": {
            "state": "!=null",
            "flags": "!=null"
        }
    }
},






{
    "kretprobe:diag14": {
        "description": "Diagnose 14: Input spool file manipulation",
        "pre": {
            "rx": "!=null",
            "ry1": "!=null",
            "subcode": "!=null"
        }
    }
},
{
    "kprobe:diag14": {
        "description": "Diagnose 14: Input spool file manipulation",
        "pre": {
            "rx": "!=null",
            "ry1": "!=null",
            "subcode": "!=null"
        }
    }
},

{
    "kprobe:struct_uv_info___bootdata_preserved": {
        "description": "Function to preserve uv_info structure",
        "pre": {
            "uv_info": "!=null",
            "module": "in [KVM, PV guest]"
        },
        "post": {
            "sysfs_interface": "readable"
        }
    }
},


{
    "kretprobe:csum_partial_copy_from_user": {
        "description": "Computes a partial checksum for TCP/UDP fragments.",
        "pre": {
            "skb": "!=null",
            "off": ">=0",
            "len": ">=0",
            "sum": ">=0"
        }
    }
},
{
    "kprobe:csum_partial_copy_from_user": {
        "description": "Computes a partial checksum for TCP/UDP fragments.",
        "pre": {
            "skb": "!=null",
            "off": ">=0",
            "len": ">=0",
            "sum": "!=null"
        }
    }
},


{
    "kretprobe:cache_clear": {
        "description": "Clear cache entries for the area defined by a physical address.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address"
        }
    }
},
{
    "kprobe:cache_clear": {
        "description": "Clear any cache entries for the area defined by the physical address.",
        "pre": {
            "paddr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:cache_push": {
        "description": "Write back dirty cache data in the given area and invalidate the range in the instruction cache.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address",
            "range": "within_valid_memory_range",
            "cache_data": "dirty",
            "instruction_cache_range": "invalidated"
        }
    }
},
{
    "kprobe:cache_push": {
        "description": "Write back dirty cache data and invalidate instruction cache for a given physical address range.",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
            "paddr": "valid_physical_address",
            "len": "<=max_allowed_length"
        }
    }
},
{
    "kretprobe:mm_cachebits": {
        "description": "Bits to add to page descriptors for 'normal' caching mode.",
        "pre": {
            "mm_cachebits": "!=null",
            "mm_cachebits": "in [0, _PAGE_CACHE040]"
        }
    }
},
{
    "kprobe:mm_cachebits": {
        "description": "Bits to add to page descriptors for 'normal' caching mode.",
        "pre": {
            "mm_cachebits": "!=null"
        }
    }
},
{
    "kretprobe:if (!size || physaddr > (unsigned long)(-size))return NULL;#ifdef CONFIG_AMIGAif (MACH_IS_AMIGA)": {
        "description": "The condition for the given function",
        "pre": {
            "size": "!=null",
            "physaddr": "> (unsigned long)(-size)",
            "CONFIG_AMIGA": "defined",
            "MACH_IS_AMIGA": "defined"
        }
    }
},
{
    "kprobe:if (!size || physaddr > (unsigned long)(-size))return NULL;#ifdef CONFIG_AMIGAif (MACH_IS_AMIGA)": {
        "description": "Helper function for mapping physical addresses to virtual addresses.",
        "pre": {
            "size": "!=null",
            "physaddr": "!=null",
            "size or physaddr": "!=null",
            "physaddr > (unsigned long)(-size)": "true",
            "CONFIG_AMIGA": "defined",
            "MACH_IS_AMIGA": "defined"
        }
    }
},
{
    "kretprobe:__free_io_area": {
        "description": "Map some physical address range into the kernel address space.",
        "pre": {
            "tmp->addr": "!=null",
            "tmp->size - IO_SIZE": ">=0"
        }
    }
},
{
    "kprobe:__free_io_area": {
        "description": "Map some physical address range into the kernel address space.",
        "pre": {
            "tmp->addr": "!=null",
            "tmp->size - IO_SIZE": ">0"
        }
    }
},
{
    "kretprobe:offset = phys & (PAGE_SIZE-1);phys &= ~(PAGE_SIZE-1);size += offset;size = PAGE_ALIGN(size);if((area = get_vm_area(size, VM_IOREMAP)) == NULL)return NULL;#ifdef SUN3_KMAP_DEBUGpr_info(\"ioremap: got virt %p size %lx(%lx)\\n\", area->addr, size,area->size);#endifpages = size / PAGE_SIZE;virt = (unsigned long)area->addr;ret = virt + offset;while(pages)": {
        "description": "The kretprobe function",
        "pre": {
            "phys": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:offset = phys & (PAGE_SIZE-1);phys &= ~(PAGE_SIZE-1);size += offset;size = PAGE_ALIGN(size);if((area = get_vm_area(size, VM_IOREMAP)) == NULL)return NULL;#ifdef SUN3_KMAP_DEBUGpr_info(\"ioremap: got virt %p size %lx(%lx)\\n\", area->addr, size,area->size);#endifpages = size / PAGE_SIZE;virt = (unsigned long)area->addr;ret = virt + offset;while(pages)": {
        "description": "The given function performs ioremap operation on a physical address range.",
        "pre": {
            "phys": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success.",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:hwreg_write": {
        "description": "Write a value to a hardware register.",
        "pre": {
            "regp": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:hwreg_write": {
        "description": "Write a value to a hardware register.",
        "pre": {
            "regp": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(amiga_audio_min_period)": {
        "description": "Helper function for amiga_audio_min_period",
        "pre": {
            "amiga_audio_min_period": "==124"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(amiga_audio_min_period)": {
        "description": "Helper function for amiga_audio_min_period",
        "pre": {
            "amiga_audio_min_period": "==124"
        }
    }
},
{
    "kretprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'",
        "pre": {
            "handler": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'.",
        "pre": {
            "handler": "!=null",
            "data": "!=null"
        }
    }
},




{
    "kretprobe:stdma_is_locked_by": {
        "description": "Allow lock holder to check whether it needs to release.",
        "pre": {
            "handler": "!=null"
        }
    }
},

{
    "kretprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked.",
        "pre": {
            "ints_disabled": "==true"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked.",
        "pre": {
            "ints_disabled": "==true"
        }
    }
},






{
    "kretprobe:size = PAGE_ALIGN(size);res = kzalloc(sizeof(struct resource), GFP_KERNEL);if (!res)return NULL;res->name = owner;error = allocate_resource(&stram_pool, re size, 0, UINT_MAX,  PAGE_SIZE, NULL, NULL);if (error < 0)": {
        "description": "Allocate memory for a resource and assign a name to it.",
        "pre": {
            "size": "!=null",
            "res": "!=null",
            "owner": "!=null",
            "error": "< 0"
        }
    }
},
{
    "kprobe:size = PAGE_ALIGN(size);res = kzalloc(sizeof(struct resource), GFP_KERNEL);if (!res)return NULL;res->name = owner;error = allocate_resource(&stram_pool, re size, 0, UINT_MAX,  PAGE_SIZE, NULL, NULL);if (error < 0)": {
        "description": "Allocate a resource for Atari stram",
        "pre": {
            "size": "!=null",
            "owner": "!=null"
        }
    }
},




{
    "kretprobe:__mcfgpio_direction_output": {
        "description": "Set the direction of GPIO to output.",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START",
            "gpio_type": "== unsigned",
            "value": "!= null"
        }
    }
},
{
    "kprobe:__mcfgpio_direction_output": {
        "description": "Set the direction of GPIO pin to output.",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START"
        }
    }
},
{
    "kretprobe:clk_disable0": {
        "description": "Disable the clock specified by `clk`.",
        "pre": {
            "clk": "!=null"
        }
    }
},
{
    "kprobe:clk_disable0": {
        "description": "Disable the clock specified by `clk`.",
        "pre": {
            "clk": "!=null"
        }
    }
},
{
    "kretprobe:macintosh_config": {
        "description": "Macintosh Table: hardcoded model configuration data.",
        "pre": {
            "macintosh_config->ident": "== MAC_MODEL_IICI",
            "mach_l2_flush": "== via_l2_flush",
            "register_platform_power_off(mac_poweroff)": ""
        }
    }
},



{
    "kretprobe:crash_shutdown_register": {
        "description": "Register a crash shutdown handler.",
        "pre": {
            "handler": "!=null",
            "crash_handlers_lock": "locked",
            "crash_shutdown_handles[i]": "==null",
            "i": "< CRASH_HANDLER_MAX"
        },
        "post": {
            "crash_shutdown_handles[i]": "==handler",
            "rc": "==0"
        }
    }
},



{
    "kretprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "pre": {
            "start": "!=null",
            "stop": "!=null"
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "pre": {
            "start": "!=null",
            "stop": "!=null",
            "start < stop": true
        }
    }
},


{
    "kretprobe:__node_distance": {
        "description": "Calculate the distance between two nodes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "i": ">=0",
            "distance": "!=null",
            "affinity_form": "in [FORM2_AFFINITY, FORM0_AFFINITY]",
            "numa_distance_table": "!=null when affinity_form == FORM2_AFFINITY",
            "distance_ref_points_depth": ">=0",
            "distance_lookup_table": "!=null",
            "LOCAL_DISTANCE": "!=null",
            "REMOTE_DISTANCE": "!=null"
        },
        "post": {
            "distance": "distance * 2"
        }
    }
},
{
    "kprobe:__node_distance": {
        "description": "Calculate the distance between two nodes.",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "i": ">=0",
            "distance": "!=null",
            "affinity_form": "in [FORM2_AFFINITY, FORM0_AFFINITY]",
            "numa_distance_table": "!=null",
            "distance_ref_points_depth": ">=0",
            "distance_lookup_table": "!=null"
        }
    }
},
{
    "kretprobe:of_node_to_nid": {
        "description": "Walk the device tree upward looking for an associativity id",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:of_node_to_nid": {
        "description": "Walk the device tree upward looking for an associativity id",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:iounmap": {
        "description": "Unmap an I/O memory region.",
        "pre": {
            "addr": "!= null",
            "v_block_mapped((unsigned long)addr)": "false",
            "addr > high_memory": "false",
            "(unsigned long)addr < ioremap_bot": "false"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "Unmap an I/O memory address.",
        "pre": {
            "addr": "not mapped by BATs"
        }
    }
},
{
    "kretprobe:if (pte_write(pte)) pte = pte_mkdirty(pte);": {
        "description": "Check if the given page table entry is writable and update it to be dirty if it is.",
        "pre": {
            "pte": "!=null",
            "pte_write(pte)": true,
            "pte_mkdirty(pte)": "!=null"
        }
    }
},
{
    "kprobe:if (pte_write(pte))pte = pte_mkdirty(pte);/* we don't want to let _PAGE_USER and _PAGE_EXEC leak out `": {
        "description": "Check if pte is writable and update it to be dirty if true.",
        "pre": {
            "pte": "!=null",
            "pte_write(pte)": "true",
            "pte_mkdirty(pte)": "!=null"
        }
    }
},


{
    "kretprobe:if (radix_enabled() && ((vm_flags & VM_ACCESS_FLAGS) == VM_EXEC))": {
        "description": "Check if radix is enabled and if the VM flags indicate executable access.",
        "pre": {
            "radix_enabled()": true,
            "vm_flags & VM_ACCESS_FLAGS": "VM_EXEC"
        }
    }
},
{
    "kprobe:radix_enabled": {
        "description": "Check if radix is enabled.",
        "pre": {}
    },
    "kprobe:vm_flags": {
        "description": "Get the value of vm_flags.",
        "pre": {}
    },
    "kprobe:VM_ACCESS_FLAGS": {
        "description": "Get the value of VM_ACCESS_FLAGS.",
        "pre": {}
    },
    "kprobe:VM_EXEC": {
        "description": "Get the value of VM_EXEC.",
        "pre": {}
    },
    "kprobe:if_condition": {
        "description": "Check if radix is enabled and vm_flags & VM_ACCESS_FLAGS == VM_EXEC.",
        "pre": {
            "radix_enabled()": "true",
            "vm_flags & VM_ACCESS_FLAGS": "VM_EXEC"
        }
    }
},
{
    "kretprobe:radix__local_flush_tlb_page_psize": {
        "description": "Flush the TLB page for a specific page size in the local radix tree.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        }
    }
},
{
    "kprobe:radix__local_flush_tlb_page_psize": {
        "description": "Flush the TLB page for a specific page size in the local radix tree.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        }
    }
},
{
    "kretprobe:smp_mb": {
        "description": "Memory barrier that ensures that all memory operations before the barrier are completed before any memory operations after the barrier.",
        "pre": {
            "mm": "!=null",
            "type": "in [FLUSH_TYPE_LOCAL, FLUSH_TYPE_GLOBAL]"
        }
    },
    "kretprobe:flush_type_needed": {
        "description": "Determines the type of flush needed for the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "flush_type": "in [FLUSH_TYPE_LOCAL, FLUSH_TYPE_GLOBAL]"
        }
    }
},

{
    "kretprobe:flush_type_needed": {
        "description": "Determines the flush type needed for a given memory management structure.",
        "pre": {
            "mm": "!=null",
            "vmaddr": "!=null",
            "psize": "!=null"
        },
        "post": {
            "type": "==FLUSH_TYPE_LOCAL"
        }
    }
},

{
    "kretprobe:flush_type_needed": {
        "description": "Check the flush type needed for the given mm struct.",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "end": "!=null",
            "pid": "!=MMU_NO_CONTEXT",
            "nr_pages": "> (end - start) >> page_shift",
            "flush_pid": "true",
            "flush_pwc": "false",
            "type": "in [FLUSH_TYPE_NONE, FLUSH_TYPE_GLOBAL]"
        }
    }
},
{
    "flush_type_needed": {
        "description": "Determines the type of flush needed for the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "false": "boolean"
        }
    },
    "FLUSH_TYPE_NONE": {
        "description": "Constant representing no flush type.",
        "pre": {}
    },
    "FLUSH_TYPE_GLOBAL": {
        "description": "Constant representing global flush type.",
        "pre": {}
    },
    "flush_pid": {
        "description": "Flag indicating whether to flush the PID.",
        "pre": {
            "nr_pages": "> tlb_single_page_flush_ceiling",
            "nr_pages": "> tlb_local_single_page_flush_ceiling"
        }
    },
    "tlb_single_page_flush_ceiling": {
        "description": "Constant representing the ceiling value for single page flush.",
        "pre": {}
    },
    "tlb_local_single_page_flush_ceiling": {
        "description": "Constant representing the ceiling value for local single page flush.",
        "pre": {}
    },
    "pid": {
        "description": "Process ID associated with the mm_struct.",
        "pre": {
            "mm": "!=null",
            "mm->context.id": "!=MMU_NO_CONTEXT"
        }
    },
    "MMU_NO_CONTEXT": {
        "description": "Constant representing no context for the mm_struct.",
        "pre": {}
    },
    "end": {
        "description": "End address of the range to flush.",
        "pre": {
            "end": "!=TLB_FLUSH_ALL"
        }
    },
    "preempt_disable": {
        "description": "Disables preemption.",
        "pre": {}
    },
    "smp_mb": {
        "description": "Performs a memory barrier.",
        "pre": {}
    }
},
{
    "kretprobe:isync();}EXPORT_SYMBOL(switch_mmu_context": {
        "description": "Switches the MMU context and performs an isync operation.",
        "pre": {
            "prev": "!=null",
            "next": "!=null",
            "tsk": "!=null",
            "next->context.id": ">= 0",
            "next->context.sr0": "!=null",
            "IS_ENABLED(CONFIG_BDI_SWITCH)": "true",
            "mmu_has_feature(MMU_FTR_HPTE_TABLE)": "true"
        }
    }
},
{
    "kprobe:isync();}EXPORT_SYMBOL(switch_mmu_context": {
        "description": "Switches the MMU context and performs an isync operation.",
        "pre": {
            "prev": "!=null",
            "next": "!=null",
            "tsk": "!=null",
            "next->context.id": "< 0",
            "next->context.sr0": "!=null",
            "IS_ENABLED(CONFIG_BDI_SWITCH)": "true",
            "mmu_has_feature(MMU_FTR_HPTE_TABLE)": "false"
        }
    }
},
{
    "kretprobe:for_each_vma": {
        "description": "Flush the TLB for each virtual memory area (vma) in the given mm_struct.",
        "pre": {
            "mm": "!=null",
            "mp": "!=null",
            "vmi": "!=null",
            "mmap_lock": "held",
            "vmtruncate": "not called on SMP",
            "dup_mmap": "called"
        }
    }
},
{
    "kprobe:for_each_vma(vmi, mp)hash__flush_range(mp->vm_mm, mp->vm_start, mp->vm_end);}EXPORT_SYMBOL(hash__flush_tlb_mm": {
        "description": "Flush the TLB entries for a given memory range in the specified mm_struct.",
        "pre": {
            "mm": "!=null",
            "mp": "!=null",
            "vmi": "!=null",
            "vm_start": "!=null",
            "vm_end": "!=null"
        }
    }
},
{
    "kretprobe:cpm_setbrg": {
        "description": "Set the value of the BRG counter for SMCs.",
        "pre": {
            "bp": "!=null",
            "brg": "!=null"
        }
    }
},
{
    "kprobe:cpm_setbrg": {
        "description": "Set the baud rate generator (BRG) for SMCs.",
        "pre": {
            "brg": "!=null",
            "rate": "!=null"
        }
    }
},
{
    "kretprobe:ps3_irq_plug_destroy": {
        "description": "Destroy the plugged IRQ associated with the given virtual IRQ.",
        "pre": {
            "virq": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ps3_irq_plug_destroy": {
        "description": "Destroy the IRQ plug associated with the given virtual IRQ.",
        "pre": {
            "virq": "!=null"
        }
    }
},


{
    "kretprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a Linux physical address to LPAR address.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a Linux physical address to LPAR address.",
        "pre": {
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes",
        "pre": {
            "new_entitlement": "!=null",
            "new_entitlement": ">=0",
            "new_entitlement": "<=MAX_SIZE_T"
        },
        "post": {
            "return_value": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes",
        "pre": {
            "new_entitlement": "!=null"
        }
    }
},
{
    "kretprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device",
        "pre": {
            "viodev": "!=null",
            "desired": ">=0"
        }
    }
},
{
    "kprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device",
        "pre": {
            "viodev": "!=null",
            "desired": "!=null"
        }
    }
},
{
    "kretprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation",
        "pre": {
            "vdev": "!=null",
            "op": "!=null",
            "op->hcall_ret": "is int",
            "op->hcall_ret": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCE -EPERM]"
        }
    }
},
{
    "kprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation",
        "pre": {
            "vdev": "!=null",
            "op": "!=null",
            "op->hcall_ret": "!=null",
            "op->hcall_ret": "int",
            "op->hcall_ret": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCE -EPERM]",
            "op->timeout": "int",
            "op->timeout": ">=0"
        }
    }
},
{
    "kretprobe:__vio_register_driver": {
        "description": "__vio_register_driver function",
        "pre": {
            "viodrv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null",
            "viodrv->driver.name": "viodrv->name",
            "viodrv->driver.pm": "viodrv->pm",
            "viodrv->driver.bus": "&vio_bus_type",
            "viodrv->driver.owner": "owner",
            "viodrv->driver.mod_name": "mod_name"
        }
    }
},
{
    "kprobe:__vio_register_driver": {
        "description": "__vio_register_driver(struct vio_driver viodrv, struct module owner, const char mod_name)",
        "pre": {
            "viodrv": {
                "driver": {
                    "name": "!=null",
                    "pm": "!=null",
                    "bus": "&vio_bus_type",
                    "owner": "owner",
                    "mod_name": "mod_name"
                }
            }
        }
    }
},
{
    "kretprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kretprobe:vio_register_device_node": {
        "description": "Register a new vio device.",
        "pre": {
            "of_node": "!=null",
            "of_node.device_type": "!=null",
            "of_node.compatible": "!=null"
        }
    }
},
{
    "kprobe:vio_register_device_node": {
        "description": "Register a new vio device.",
        "pre": {
            "of_node": "!=null",
            "of_node.device_type": "!=null",
            "of_node.compatible": "!=null"
        }
    }
},
{
    "kretprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev",
        "pre": {
            "vnode": "!=null"
        }
    }
},
{
    "kprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev",
        "pre": {
            "vnode": "!=null"
        }
    }
},


{
    "kretprobe:ibmebus_matches": {
        "description": "These devices will automatically be added to the bus during init",
        "pre": {
            "ibmebus_bus_type": "!=null"
        }
    }
},

{
    "kretprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter.",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=16"
        }
    }
},
{
    "kprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter",
        "pre": {
            "vtermno": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:h_get_mpp": {
        "description": "Returns info in 7 parameters",
        "pre": {},
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:h_get_mpp": {
        "description": "Helper function h_get_mpp returns info in 7 parameters.",
        "pre": {
            "mpp_data": "!=null"
        }
    }
},

{
    "kprobe:data->drc_type = (char *)p;p = of_prop_next_string(*prop, p);if (!p)return -EINVAL;": {
        "description": "Set the value of data->drc_type and update p using of_prop_next_string. Return -EINVAL if p is null.",
        "pre": {
            "data": "!=null",
            "prop": "!=null",
            "p": "!=null",
            "of_prop_next_string(*prop, p)": "!=null",
            "return": "-EINVAL if p is null"
        }
    }
},

{
    "kprobe:hvcs_free_partner_info": {
        "description": "Free the partner info list returned by hvcs_get_partner_info()",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty.",
        "pre": {
            "unit_address": "!=null",
            "p_partition_ID": "!=null",
            "p_unit_address": "!=null"
        }
    }
},
{
    "kprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty.",
        "pre": {
            "unit_address": "!=null",
            "p_partition_ID": "!=null",
            "p_unit_address": "!=null"
        }
    }
},
{
    "kretprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty",
        "pre": {
            "unit_address": "!=null"
        }
    }
},
{
    "kprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty.",
        "pre": {
            "unit_address": "!=null"
        }
    }
},


{
    "kretprobe:opal_pci_set_xive_pe": {
        "description": "Assign XIVE to PE",
        "pre": {
            "phb->opal_id": "!=null",
            "pe->pe_number": "!=null",
            "xive_num": "!=null"
        }
    }
},
{
    "kprobe:opal_pci_set_xive_pe": {
        "description": "Assign XIVE to PE",
        "pre": {
            "phb->opal_id": "!=null",
            "pe->pe_number": "!=null",
            "xive_num": "!=null"
        }
    }
},


{
    "kretprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number",
        "pre": {
            "irq": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number",
        "pre": {
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer",
        "pre": {
            "gpt": "!=null",
            "period": ">=0",
            "continuous": "in [0, 1]"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer",
        "pre": {
            "gpt": "!=null",
            "period": ">=0",
            "continuous": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt",
        "pre": {
            "gpt": "!=null"
        },
        "post": {
            "return_value": "is_error_when_attempting_to_stop_wdt"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt",
        "pre": {
            "gpt": "!=null",
            "gpt->wdt": "==null"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "!=null"
        }
    }
},


{
    "kretprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register",
        "pre": {
            "intf": "!=null",
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register",
        "pre": {
            "reg": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_chan": {
        "description": "Allocate a DMA channel",
        "pre": {
            "type": "in [PASEMI_DMA_RX, PASEMI_DMA_TX]",
            "total_size": ">=0",
            "offset": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_chan": {
        "description": "Allocate a DMA channel",
        "pre": {
            "type": "in [RX, TX]",
            "total_size": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_chan": {
        "description": "Free a previously allocated channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_chan": {
        "description": "Free a previously allocated channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate descriptor ring for a channel",
        "pre": {
            "chan": "!=null",
            "ring_size": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate descriptor ring for a channel",
        "pre": {
            "chan": "!=null",
            "ring_size": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel",
        "pre": {
            "chan": "!=null",
            "cmdsta": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel",
        "pre": {
            "chan": "!=null",
            "cmdsta": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel",
        "pre": {
            "chan": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to use for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to use for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_buf": {
        "description": "Free a buffer used for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_buf": {
        "description": "Free a buffer used for DMA",
        "pre": {
            "chan": "!=null",
            "size": ">=0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization",
        "pre": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization",
        "pre": {
            "return_value": ">= -1",
            "return_value": "<= 63"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event)",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event)",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0",
        "pre": {
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine to use for cryptochecksum offload",
        "pre": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine to use for cryptochecksum offload.",
        "pre": {
            "return_value": ">= -8",
            "return_value": "<= 8"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine",
        "pre": {
            "fun": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine",
        "pre": {
            "fun": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library",
        "pre": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library",
        "pre": {
            "return_value": "==0"
        }
    }
},


{
    "kretprobe:mpc512x_cs_config": {
        "description": "Setup chip select configuration",
        "pre": {
            "cs": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mpc512x_cs_config": {
        "description": "Setup chip select configuration",
        "pre": {
            "cs": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "Check whether a transfer is in progress",
        "pre": {
            "lpbfifo.regs": "!=null",
            "lpbfifo.req": "true"
        }
    }
},
{
    "kprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "",
        "pre": {
            "lpbfifo.req": "!=null",
            "lpbfifo.wait_lpbfifo_irq": "true",
            "lpbfifo.wait_lpbfifo_callback": "true",
            "lpbfifo.req": "req",
            "ret": "!=0"
        }
    }
},
{
    "kretprobe:mpic_start_timer": {
        "description": "Start hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_start_timer": {
        "description": "Start hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_stop_timer": {
        "description": "Stop hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_stop_timer": {
        "description": "Stop hardware timer",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:mpic_free_timer": {
        "description": "Free hardware timer",
        "pre": {
            "handle": "!=null",
            "context": "not in interrupt context"
        }
    }
},
{
    "kprobe:mpic_free_timer": {
        "description": "Free hardware timer",
        "pre": {
            "handle": "!=null",
            "context": "not in interrupt context"
        }
    }
},
{
    "kretprobe:mpic_request_timer": {
        "description": "Get a hardware timer.",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:mpic_request_timer": {
        "description": "Get a hardware timer.",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:gtm_put_timer16": {
        "description": "Release 16 bits GTM timer",
        "pre": {
            "tmr": "!=null"
        },
        "context": "any"
    }
},
{
    "kprobe:gtm_put_timer16": {
        "description": "Release 16 bits GTM timer",
        "pre": {
            "tmr": "!=null"
        },
        "context": "any"
    }
},
{
    "kretprobe:gtm_set_timer16": {
        "description": "(Re)set 16 bit timer with arbitrary precision.",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},
{
    "kprobe:gtm_set_timer16": {
        "description": "(re)set 16 bit timer with arbitrary precision",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},

{
    "kprobe:gtm_set_exact_timer16": {
        "description": "quite obviou frequency which is enough for µSec precision",
        "pre": {
            "tmr": "!=null",
            "usec": "!=null",
            "reload": "!=null"
        }
    }
},


{
    "kretprobe:gtm_ack_timer16": {
        "description": "Acknowledge timer event (free-run timers only)",
        "pre": {
            "tmr": "!=null",
            "events": "!=null"
        },
        "context": "any"
    }
},
{
    "kprobe:gtm_ack_timer16": {
        "description": "Acknowledge timer event (free-run timers only).",
        "pre": {
            "tmr": "!=null",
            "events": "!=null"
        }
    }
},


{
    "kretprobe:fsl_lbc_addr": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kprobe:fsl_lbc_addr": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null",
            "addr_base": "is a valid physical address",
            "addr_base": "is a base address of the memory bank",
            "addr_base": "is in the correct format for the BR register",
            "addr_base": "is a 32-bit physical address if the SOC has eLBC",
            "addr_base": "is a 34-bit local bus physical address if the SOC does not have eLBC"
        }
    }
},
{
    "kretprobe:fsl_lbc_find": {
        "description": "Find Localbus bank",
        "pre": {
            "addr_base": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:fsl_lbc_find": {
        "description": "Find Localbus bank",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        }
    }
},
{
    "kprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_run_pattern": {
        "description": "Actually run an UPM pattern",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "!=null"
        }
    }
},
{
    "kprobe:fsl_upm_run_pattern": {
        "description": "Actually run an UPM pattern",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "\"cpm\""
        }
    },
    "kretprobe:of_find_compatible_node": {
        "description": "Find a device tree node compatible with a given device.",
        "pre": {
            "compatible": "\"fsl,qe\""
        }
    },
    "kretprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "\"qe\""
        }
    }
},
{
    "kprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "!=null"
        }
    },
    "kprobe:of_find_compatible_node": {
        "description": "Find a device tree node by its compatible string.",
        "pre": {
            "type": "!=null",
            "compatible": "!=null"
        }
    },
    "kprobe:of_find_node_by_type": {
        "description": "Find a device tree node by its type.",
        "pre": {
            "type": "!=null"
        }
    },
    "kprobe:of_property_read_u32": {
        "description": "Read a 32-bit unsigned integer property from a device tree node.",
        "pre": {
            "node": "!=null",
            "property": "\"clock-frequency\"",
            "value": "!=null"
        }
    },
    "kprobe:of_node_put": {
        "description": "Decrement the reference count of a device tree node.",
        "pre": {
            "node": "!=null"
        }
    }
},

{
    "kprobe:pci_io_base": {
        "description": "The base address from which IO bars are offsets.",
        "pre": {
            "pci_io_base": "!=null",
            "pci_io_base": ">=0",
            "pci_io_base": "<=65535"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "Returns the base address of the ISA bus or NULL if no ISA bus is present.",
        "pre": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "Check if ISA bus is available",
        "pre": {
            "isa_bus": "==null"
        }
    }
},


{
    "kretprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE",
        "pre": {
            "pdev": "!=null"
        }
    }
},

{
    "kprobe:struct_machdep_calls_ppc_md": {
        "description": "Main machine-dep calls structure",
        "pre": {
            "ppc_md": "!=null",
            "machine_id": "!=null",
            "boot_cpuid": "-1",
            "boot_cpu_hwid": "-1 (if CONFIG_PPC64 is defined)"
        }
    }
},
{
    "kretprobe:if (!np)np = of_find_node_by_name(NULL, \"8042\");if (np)": {
        "description": "Check if the variable np is null. If it is null, assign the result of of_find_node_by_name(NULL, \"8042\") to np.",
        "pre": {
            "np": "==null"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if np is NULL and find node by name",
        "pre": {
            "np": "==null",
            "of_find_node_by_name(NULL, \"8042\")": "!=null"
        }
    }
},
{
    "kretprobe:if ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))goto out_unlock;/* If everything fails then fallback to dynamic PHB numbering. `": {
        "description": "This function checks if the phb_id is greater than or equal to 0 and if the bit at phb_id in phb_bitmap is not set. If both conditions are true, it goes to the out_unlock label.",
        "pre": {
            "phb_id": ">= 0",
            "!test_and_set_bit(phb_id, phb_bitmap)": "true"
        }
    }
},
{
    "kprobe:if ((phb_id >= 0) && !test_and_set_bit(phb_id, phb_bitmap))goto out_unlock;/* If everything fails then fallback to dynamic PHB numbering. `": {
        "description": "Condition for the given function",
        "pre": {
            "phb_id": ">= 0",
            "!test_and_set_bit(phb_id, phb_bitmap)": "true"
        }
    }
},




{
    "kretprobe:btext_update_display": {
        "description": "Update the display with the given parameters.",
        "pre": {
            "phys": "!=null",
            "width": "!=null",
            "height": "!=null",
            "depth": "!=null",
            "pitch": "!=null",
            "dispDeviceBase": "!=null",
            "(phys ^ (unsigned long)dispDeviceBase) & 0xf0000000": "==0",
            "dispDeviceRect[0]": "==0",
            "dispDeviceRect[1]": "==0",
            "dispDeviceRect[2]": "==width",
            "dispDeviceRect[3]": "==height",
            "dispDeviceDepth": "==depth",
            "dispDeviceRowBytes": "==pitch",
            "boot_text_mapped": "==true"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the condition is met for the given function.",
        "pre": {
            "phys": "!=null",
            "dispDeviceBase": "!=null",
            "dispDeviceBase ^ (unsigned long)phys": "& 0xf0000000 == 0",
            "dispDeviceBase": "= (__u8 *) phys",
            "dispDeviceRect[0]": "= 0",
            "dispDeviceRect[1]": "= 0",
            "dispDeviceRect[2]": "= width",
            "dispDeviceRect[3]": "= height",
            "dispDeviceDepth": "= depth",
            "dispDeviceRowBytes": "= pitch",
            "boot_text_mapped": "= true"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(tb_ticks_per_usec)": {
        "description": "Helper function to get the number of ticks per microsecond.",
        "pre": {
            "tb_ticks_per_usec": "==100"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(tb_ticks_per_usec)": {
        "description": "Helper function to get the number of ticks per microsecond.",
        "pre": {
            "tb_ticks_per_usec": "==100"
        }
    }
},


{
    "kretprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows with interrupts disabled.",
        "pre": {
            "interrupts_disabled": "true",
            "decrementer_overflow": "true"
        }
    }
},
{
    "kprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows with interrupts disabled.",
        "pre": {
            "interrupts_disabled": "true",
            "decrementer_overflow": "true"
        }
    }
},





{
    "kprobe:enable_kernel_vsx": {
        "description": "Enable kernel VSX.",
        "pre": {
            "cpumsr": "!=null",
            "current->thread.regs->msr": "MSR_VSX && MSR_VEC && MSR_FP"
        }
    }
},


{
    "kretprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:cpu_to_chip_id": {
        "description": "Return the cpus chip-id",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:cpu_to_chip_id": {
        "description": "Return the cpus chip-id",
        "pre": {
            "cpu": "!=null"
        }
    }
},

{
    "pci_device_from_OF_node": {
        "description": "Check if it might have a chance to be a PCI device",
        "pre": {
            "!pci_find_hose_for_OF_device(node)": true,
            "reg": "!=null",
            "size": ">= 5 * sizeof(u32)",
            "!reg || size < 5 * sizeof(u32)": "-ENODEV",
            "*bus": "(be32_to_cpup(&reg[0]) >> 16) & 0xff",
            "*devfn": "(be32_to_cpup(&reg[0]) >> 8) & 0xff",
            "#ifndef CONFIG_PPC_PCI_OF_BUS_MAP": 0,
            "#else": {
                "dev": "NULL",
                "pci_device_from_OF_node": "node, bu devfn"
            }
        }
    }
},

{
    "kprobe:__replay_soft_interrupts();irq_exit();}#if defined(CONFIG_PPC_BOOK3S_64) && defined(CONFIG_PPC_KUAP)static inline __no_kcsan void replay_soft_interrupts_irqrestore(void)": {
        "description": "Replay soft interrupts and restore IRQ state.",
        "pre": {
            "arg1": "!=null",
            "arg2": "!=null",
            "arg3": "!=null",
            "arg4": "!=null"
        }
    }
},
{
    "kretprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bu create a pci_dev",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bu create a pci_dev",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:in_xmon": {
        "description": "The value of in_xmon variable.",
        "pre": {
            "in_xmon": "==0"
        }
    },
    "kretprobe:xmon_on": {
        "description": "The value of xmon_on variable.",
        "pre": {
            "xmon_on": "IS_ENABLED(CONFIG_XMON_DEFAULT)"
        }
    },
    "kretprobe:xmon_is_ro": {
        "description": "The value of xmon_is_ro variable.",
        "pre": {
            "xmon_is_ro": "IS_ENABLED(CONFIG_XMON_DEFAULT_RO_MODE)"
        }
    },
    "kretprobe:adrs": {
        "description": "The value of adrs variable."
    },
    "kretprobe:size": {
        "description": "The value of size variable.",
        "pre": {
            "size": "==1"
        }
    },
    "kretprobe:ndump": {
        "description": "The value of ndump variable.",
        "pre": {
            "ndump": "==64"
        }
    },
    "kretprobe:nidump": {
        "description": "The value of nidump variable.",
        "pre": {
            "nidump": "==16"
        }
    },
    "kretprobe:ncsum": {
        "description": "The value of ncsum variable.",
        "pre": {
            "ncsum": "==4096"
        }
    },
    "kretprobe:termch": {
        "description": "The value of termch variable."
    },
    "kretprobe:tmpstr": {
        "description": "The value of tmpstr variable."
    },
    "kretprobe:tracing_enabled": {
        "description": "The value of tracing_enabled variable."
    },
    "kretprobe:bus_error_jmp": {
        "description": "The value of bus_error_jmp variable."
    },
    "kretprobe:catch_memory_errors": {
        "description": "The value of catch_memory_errors variable."
    },
    "kretprobe:catch_spr_faults": {
        "description": "The value of catch_spr_faults variable."
    },
    "kretprobe:xmon_fault_jmp": {
        "description": "The value of xmon_fault_jmp variable."
    }
},

{
    "kretprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Get page shift, work out hash and AVPN etc.",
        "pre": {
            "kvm": "!=null",
            "eaddr": "!=null",
            "slb_v": "& SLB_VSID_L != 0",
            "valid": "!=null",
            "mask": "SLB_VSID_B | HPTE_V_AVPN | HPTE_V_SECONDARY",
            "val": "0",
            "pshift": "12"
        }
    }
},
{
    "kprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Get page shift, work out hash and AVPN etc.",
        "pre": {
            "slb_v": "& SLB_VSID_L != 0",
            "mask": "SLB_VSID_B | HPTE_V_AVPN | HPTE_V_SECONDARY",
            "val": "0",
            "pshift": "12"
        }
    }
},





{
    "kprobe:if_unlikely_unsigned_long_addr_gt_FIXADDR_START": {
        "description": "Check if the address is greater than FIXADDR_START.",
        "pre": {
            "addr": ">FIXADDR_START"
        }
    }
},
{
    "kretprobe:default_power_off": {
        "description": "Power off the system when pm_power_off is not set by a power management driver.",
        "pre": {
            "pm_power_off": "==null"
        }
    }
},
{
    "kprobe:default_power_off": {
        "description": "Simulate power off on a simulator",
        "pre": {
            "pm_power_off": "not set",
            "instruction": "l.nop 1"
        }
    }
},





{
    "kprobe:sysctl_vfs_cache_pressure": {
        "description": "The sysctl_vfs_cache_pressure function",
        "pre": {
            "sysctl_vfs_cache_pressure": "==100"
        }
    },
    "kprobe:rename_lock": {
        "description": "The rename_lock function",
        "pre": {
            "rename_lock": "!=null"
        }
    },
    "kprobe:dentry_cache": {
        "description": "The dentry_cache function",
        "pre": {
            "dentry_cache": "!=null"
        }
    },
    "kprobe:empty_name": {
        "description": "The empty_name function",
        "pre": {
            "empty_name": "==\"\""
        }
    },
    "kprobe:slash_name": {
        "description": "The slash_name function",
        "pre": {
            "slash_name": "==\"/\""
        }
    },
    "kprobe:dotdot_name": {
        "description": "The dotdot_name function",
        "pre": {
            "dotdot_name": "==\"..\""
        }
    }
},
{
    "kretprobe:fast_dput": {
        "description": "Call dput() and return whether the operation was successful.",
        "pre": {
            "dentry": "!=null",
            "rcu_read_lock_held": "true"
        }
    }
},
{
    "kprobe:fast_dput": {
        "description": "Perform dput() and return whether it was successful.",
        "pre": {
            "dentry": "!=null",
            "rcu_read_lock_held": true
        }
    }
},


{
    "kretprobe:d_find_any_alias": {
        "description": "Find any alias for a given inode",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:d_find_any_alias": {
        "description": "find any alias for a given inode",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:d_find_alias": {
        "description": "Grab a hashed alias of an inode",
        "pre": {
            "inode": "!=null",
            "inode->i_mode": "!=null",
            "inode->i_mode": "S_ISDIR",
            "inode->i_dentry": "!=null",
            "alias": "!=null",
            "alias->d_lock": "!=null",
            "alias->d_u.d_alias": "!=null",
            "alias->d_lock": "spin_lock",
            "!d_unhashed(alias)": true,
            "__dget_dlock(alias)": true
        },
        "post": {
            "return": "alias"
        }
    }
},
{
    "kprobe:d_find_alias": {
        "description": "grab a hashed alias of inode",
        "pre": {
            "inode": "!=null",
            "alias": "!=null",
            "S_ISDIR(inode->i_mode)": "true",
            "__d_find_any_alias(inode)": "!=null"
        }
    }
},
{
    "kretprobe:shrink_dcache_sb": {
        "description": "Shrink dcache for a superblock",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_sb": {
        "description": "Shrink dcache for a superblock",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:d_set_mounted": {
        "description": "Set the 'mounted' flag for the given dentry.",
        "pre": {
            "dentry": "!=null",
            "rename_lock": "held",
            "d_lock": "held"
        }
    }
},
{
    "kprobe:d_set_mounted": {
        "description": "Set the 'mounted' flag for the given dentry.",
        "pre": {
            "dentry": "!=null",
            "rename_lock": "held",
            "d_lock": "held"
        }
    }
},
{
    "kretprobe:__d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:__d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_alloc": {
        "description": "Allocate a dcache entry",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:d_instantiate": {
        "description": "Fill in inode information for a dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "dentry->d_flags": "& DCACHE_LRU_LIST",
            "nr_dentry_negative": "this_cpu_dec",
            "dentry->d_u.d_alias": "hlist_add_head(&dentry->d_u.d_alia &inode->i_dentry)",
            "dentry->d_seq": "raw_write_seqcount_begin(&dentry->d_seq)",
            "__d_set_inode_and_type": "__d_set_inode_and_type(dentry, inode, add_flags)",
            "fsnotify_update_flags": "fsnotify_update_flags(dentry)",
            "dentry->d_lock": "spin_unlock(&dentry->d_lock)"
        }
    }
},
{
    "kprobe:d_instantiate": {
        "description": "Fill in inode information for a dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "add_flags": "unsigned",
            "d_flags_for_inode": "function",
            "d_in_lookup": "function",
            "spin_lock": "function",
            "Decrement negative dentry count if it was in the LRU list.": "comment"
        }
    }
},
{
    "d_instantiate_anon": {
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "false",
            "add_flags": "d_flags_for_inode(inode) | DCACHE_DISCONNECTED",
            "dentry->d_lock": "locked",
            "__d_set_inode_and_type": {
                "dentry": "!=null",
                "inode": "!=null",
                "add_flags": "!=null"
            },
            "hlist_add_head": {
                "dentry->d_u.d_alias": "!=null",
                "inode->i_dentry": "!=null"
            }
        }
    }
},
{
    "kprobe:d_instantiate_anon": {
        "description": "Attach a disconnected dentry.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "bool"
        }
    }
},
{
    "kretprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode.",
        "pre": {
            "inode": "!=null",
            "disconnected": "bool"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode.",
        "pre": {
            "inode": "!=null",
            "disconnected": "boolean"
        }
    }
},

{
    "kprobe:__d_drop": {
        "description": "Drop a dentry from its hash table.",
        "pre": {
            "dentry": {
                "IS_ROOT": true
            },
            "b": "&dentry->d_sb->s_roots"
        }
    }
},
{
    "kretprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name.",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name",
        "pre": {
            "dentry": "!=null",
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name.",
        "pre": {
            "dentry": "<dentry_constraints>",
            "parent": "<parent_constraints>",
            "name": "<name_constraints>"
        }
    }
},
{
    "kretprobe:d_drop": {
        "description": "Invalidate a dentry for some reason.",
        "pre": {
            "dentry": "!=null",
            "dentry->d_lock": "acquired"
        }
    }
},
{
    "kprobe:d_drop": {
        "description": "Invalidate a dentry for some reason.",
        "pre": {
            "dentry": "!=null",
            "dentry->d_lock": "acquired",
            "dentry->d_hash.pprev": "!=NULL"
        }
    }
},
{
    "kretprobe:d_rehash": {
        "description": "Add an entry back to the hash.",
        "pre": {
            "entry": "!=null",
            "entry->d_name.hash": "!=null",
            "b": "!=null",
            "hlist_bl_lock(b)": "called",
            "hlist_bl_add_head_rcu(&entry->d_hash, b)": "called",
            "hlist_bl_unlock(b)": "called"
        }
    }
},
{
    "kprobe:d_rehash": {
        "description": "Add an entry back to the hash.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias.",
        "pre": {
            "entry": "!=null",
            "inode": "!=null",
            "entry->d_name.name": "!=null",
            "entry->d_parent": "!=null",
            "inode->i_ino": "!=null",
            "inode->i_sb": "!=null",
            "inode->i_sb->s_root": "!=null",
            "inode->i_sb->s_root->d_inode": "!=null",
            "inode->i_sb->s_root->d_inode->i_ino": "!=null"
        }
    }
},
{
    "kprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias.",
        "pre": {
            "entry": "!=null",
            "inode": "!=null",
            "entry->d_name.name": "!=null",
            "entry->d_parent": "!=null",
            "inode->i_ino": "!=null",
            "inode->i_sb": "!=null",
            "inode->i_sb->s_type": "==DT_UNKNOWN || ==DT_DIR || ==DT_REG",
            "inode->i_sb->s_op": "!=null",
            "inode->i_sb->s_op->lookup": "!=null",
            "inode->i_sb->s_op->lookup->dentry": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_name.name": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_name.name": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_ino": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_sb": "!=null",
            "inode->i_sb->s_op->lookup->dentry->d_parent->d_inode->i_sb->s_type": "==DT_UNKNOWN || ==DT_DIR || ==DT_REG"
        }
    }
},


{
    "kretprobe:is_subdir": {
        "description": "Check if new_dentry is a subdirectory of old_dentry.",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        }
    }
},
{
    "kprobe:is_subdir": {
        "description": "Check if new_dentry is a subdirectory of old_dentry.",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        }
    }
},


{
    "kretprobe:simple_setattr": {
        "description": "setattr for simple filesystem",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:simple_setattr": {
        "description": "setattr for simple filesystem",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        }
    }
},
{
    "kretprobe:simple_fill_super": {
        "description": "Function to fill the super block with the given parameters.",
        "pre": {
            "s": "!=null",
            "magic": "!=null",
            "files": "!=null",
            "s->s_blocksize": "==PAGE_SIZE",
            "s->s_blocksize_bits": "==PAGE_SHIFT",
            "s->s_magic": "==magic",
            "s->s_op": "==&simple_super_operations",
            "s->s_time_gran": "==1",
            "inode": "!=null",
            "root": "!=null",
            "dentry": "!=null",
            "i": ">=0",
            "files[i].name": "!=null",
            "files[i].name[0]": "!=null",
            "inode->i_ino": "==1",
            "inode->i_mode": "==S_IFDIR | 0755",
            "inode->i_atime": "==current_time(inode)",
            "inode->i_mtime": "==current_time(inode)",
            "inode->i_ctime": "==current_time(inode)",
            "inode->i_op": "==&simple_dir_inode_operations",
            "inode->i_fop": "==&simple_dir_operations",
            "set_nlink(inode, 2)": "true",
            "root": "==d_make_root(inode)",
            "!root": "==null"
        }
    }
},
{
    "kprobe:simple_fill_super": {
        "description": "Function to fill the super block with the given parameters.",
        "pre": {
            "s": {
                "s_blocksize": 4096,
                "s_blocksize_bits": 12,
                "s_magic": 1234567890,
                "s_op": "!=null",
                "s_time_gran": 1
            },
            "magic": 1234567890,
            "files": {
                "name": [
                    "!=null",
                    "!=1"
                ]
            },
            "inode": {
                "i_ino": 1,
                "i_mode": "S_IFDIR | 0755",
                "i_atime": "current_time(inode)",
                "i_mtime": "current_time(inode)",
                "i_ctime": "current_time(inode)",
                "i_op": "&simple_dir_inode_operations",
                "i_fop": "&simple_dir_operations"
            },
            "root": "!=null"
        }
    }
},
{
    "kretprobe:simple_read_from_buffer": {
        "description": "Copy data from the buffer to user space",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kprobe:simple_read_from_buffer": {
        "description": "Copy data from the buffer to user space",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kretprobe:simple_write_to_buffer": {
        "description": "Copy data from user space to the buffer",
        "pre": {
            "to": "!=null",
            "available": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:simple_write_to_buffer": {
        "description": "Copy data from user space to the buffer",
        "pre": {
            "to": "!=null",
            "available": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memory_read_from_buffer": {
        "description": "Copy data from the buffer",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kprobe:memory_read_from_buffer": {
        "description": "Copy data from the buffer",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        }
    }
},
{
    "kretprobe:simple_transaction_set": {
        "description": "Set the size of the simple transaction argument response structure.",
        "pre": {
            "file": "!=null",
            "n": ">=0",
            "ar": "!=null",
            "ar->size": "==0",
            "ar->data": "not ready for reading"
        }
    }
},
{
    "kprobe:smp_mb();ar->size = n;}EXPORT_SYMBOL(simple_transaction_set": {
        "description": "Set the value of `ar->size` to `n` in the `simple_transaction_set` function.",
        "pre": {
            "file": "!=null",
            "n": ">=0",
            "ar": "!=null",
            "ar->data": "ready for reading",
            "ar->size": "0"
        }
    }
},
{
    "kretprobe:if (file->private_data)": {
        "description": "Check if the private_data field of the file structure is not null.",
        "pre": {
            "file": {
                "private_data": "!=null"
            }
        }
    }
},
{
    "kprobe:if (file->private_data)": {
        "description": "Check if the private_data field of the file structure is not null.",
        "pre": {
            "file": {
                "private_data": "!=null"
            }
        }
    }
},
{
    "kretprobe:__generic_file_fsync": {
        "description": "Generic fsync implementation for simple filesystems",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:__generic_file_fsync": {
        "description": "Generic fsync implementation for simple filesystems.",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:generic_check_addressable": {
        "description": "Check addressability of file system",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        }
    }
},
{
    "kprobe:generic_check_addressable": {
        "description": "Check addressability of file system",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        }
    }
},
{
    "kretprobe:pseudo_fs_get_tree": {
        "description": "Get the tree for the pseudo filesystem.",
        "pre": {
            "root->i_ino": "== 1",
            "root->i_mode": "& (S_IFDIR | S_IRUSR | S_IWUSR)",
            "root->i_atime": "== root->i_mtime",
            "root->i_atime": "== root->i_ctime",
            "s->s_root": "!= null",
            "ctx->dops": "!= null"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:pseudo_fs_get_tree": {
        "description": "Get the tree for the pseudo filesystem.",
        "pre": {
            "root->i_ino": "== 1",
            "root->i_mode": "& (S_IFDIR | S_IRUSR | S_IWUSR)",
            "root->i_atime": "== root->i_mtime",
            "root->i_atime": "== root->i_ctime",
            "s->s_root": "!= null",
            "ctx->dops": "!= null"
        }
    }
},
{
    "kretprobe:alloc_anon_inode": {
        "description": "Allocate an anonymous inode",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "inode->i_state": "I_DIRTY",
            "inode->i_mode": "S_IRUSR | S_IWUSR",
            "inode->i_uid": "current_fsuid()",
            "inode->i_gid": "current_fsgid()",
            "inode->i_flags": "inode->i_flags | S_PRIVATE",
            "inode->i_atime": "current_time(inode)",
            "inode->i_mtime": "current_time(inode)",
            "inode->i_ctime": "current_time(inode)",
            "return": "inode"
        }
    }
},
{
    "kprobe:alloc_anon_inode": {
        "description": "Allocate an anonymous inode in the given super block.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:intsimple_nosetlease": {
        "description": "Generic helper for prohibiting leases",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:intsimple_nosetlease": {
        "description": "Generic helper for prohibiting leases",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:simple_get_link": {
        "description": "Generic helper to get the target of 'fast' symlinks",
        "pre": {
            "dentry": "==null",
            "inode": "!=null",
            "done": "==null"
        }
    }
},
{
    "kprobe:simple_get_link": {
        "description": "Generic helper to get the target of 'fast' symlinks",
        "pre": {
            "dentry": "==null",
            "inode": "!=null",
            "done": "==null"
        }
    }
},
{
    "kretprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:inode_maybe_inc_iversion": {
        "description": "Increments i_version of the given inode if necessary.",
        "pre": {
            "inode": "!=null",
            "force": "in [true, false]"
        }
    }
},
{
    "kprobe:inode_maybe_inc_iversion": {
        "description": "Increments i_version of the given inode.",
        "pre": {
            "inode": "!=null",
            "force": "in [true, false]"
        }
    }
},
{
    "kretprobe:smp_mb();cur = inode_peek_iversion_raw(inode);do": {
        "description": "Query the inode's i_version field",
        "pre": {
            "smp_mb": "called",
            "cur": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:smp_mb();cur = inode_peek_iversion_raw(inode);do": {
        "description": "Perform a memory barrier, then assign the current value of the inode's i_version field to the variable 'cur' using the helper function 'inode_peek_iversion_raw'.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "any"
        }
    }
},
{
    "kprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "any"
        }
    }
},


{
    "kretprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "unsigned int",
            "_path": "!=null"
        }
    }
},
{
    "kprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "!=null",
            "_path": "!=null"
        }
    }
},
{
    "kretprobe:return handler->set": {
        "description": "Set extended attribute value for a file.",
        "pre": {
            "handler": "!=null",
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null",
            "size": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:return handler->set": {
        "description": "Set the value of the entry using the provided handler.",
        "pre": {
            "handler": "!=null",
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null",
            "size": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:generic_listxattr": {
        "description": "Run through a dentry's xattr list() operations",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buffer_size": "!=null"
        }
    }
},
{
    "kprobe:ssize_tgeneric_listxattr": {
        "description": "Run through a dentry's xattr list() operations.",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buffer_size": "!=null"
        }
    }
},
{
    "kretprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},


{
    "kretprobe:vfs_setpos": {
        "description": "Update the file offset for lseek",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "maxsize": "!=null"
        }
    }
},
{
    "kprobe:vfs_setpos": {
        "description": "Update the file offset for lseek",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "maxsize": "!=null"
        }
    }
},
{
    "kretprobe:loff_tgeneric_file_llseek_size": {
        "description": "Generic llseek implementation for regular files",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        }
    }
},
{
    "kprobe:loff_tgeneric_file_llseek_size": {
        "description": "Generic llseek implementation for regular files.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        }
    }
},
{
    "kretprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null"
        }
    }
},
{
    "kprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "!=null"
        }
    }
},
{
    "kretprobe:if (offset >= inode->i_size)": {
        "description": "Check if the offset is greater than or equal to the size of the inode.",
        "pre": {
            "offset": ">= inode->i_size"
        }
    }
},
{
    "kprobe:default_llseek": {
        "description": "Check if offset is greater than or equal to inode->i_size",
        "pre": {
            "file": "is_instance_of(struct file)",
            "offset": "is_instance_of(loff_t)",
            "whence": "is_instance_of(int)",
            "inode": "is_instance_of(struct inode)",
            "inode->i_size": ">= offset"
        }
    }
},
{
    "kretprobe:return -EOVERFLOW;} else if (unlikely((loff_t) (pos + count) < 0)": {
        "description": "This condition checks if the return value is -EOVERFLOW and if the sum of pos and count is less than 0.",
        "pre": {
            "pos": "!=null",
            "count": "!=null",
            "return_value": "-EOVERFLOW",
            "pos + count": "< 0"
        }
    }
},
{
    "kprobe:return -EOVERFLOW;} else if (unlikely((loff_t) (pos + count) < 0)": {
        "description": "Check for overflow in the addition of pos and count.",
        "pre": {
            "read_write": "in [0, 1]",
            "file": "!=null",
            "ppos": ">=0",
            "count": ">=0",
            "pos": ">=0",
            "unsigned_offsets(file)": "==true",
            "count >= -pos": "==true",
            "pos + count": "<0"
        }
    }
},
{
    "kretprobe:kernel_read": {
        "description": "Read data from a file.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "pos": ">=0",
            "file->f_op->read_iter": "!=null",
            "file->f_op->read": "!=null"
        }
    }
},
{
    "kprobe:kernel_read": {
        "description": "Read data from a file in the kernel.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "count": "!=null",
            "pos": "!=null",
            "file->f_op->read_iter": "!=null",
            "file->f_op->read": "!=null"
        }
    }
},
{
    "kretprobe:kernel_write_iter": {
        "description": "Kernel write iterator function",
        "pre": {
            "file": "!=null",
            "from": "!=null",
            "pos": "!=null",
            "file->f_op->write_iter": "!=null",
            "file->f_op->write": "!=null",
            "!file->f_op->write_iter || file->f_op->write": "true",
            "init_sync_kiocb(&kiocb, file)": "no condition specified",
            "kiocb.ki_pos": "pos ? *pos : 0",
            "ret": "no condition specified",
            "ret > 0": "true"
        }
    }
},
{
    "kprobe:kernel_write_iter": {
        "description": "Kernel function for writing data to a file.",
        "pre": {
            "file": "!=null",
            "from": "!=null",
            "pos": "!=null",
            "file->f_op->write_iter": "!=null",
            "file->f_op->write": "!=null"
        }
    }
},
{
    "kretprobe:generic_copy_file_range": {
        "description": "Copy data between two files",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:generic_copy_file_range": {
        "description": "Copy data between two files",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": "unsigned int",
            "return": "ssize_t"
        }
    }
},
{
    "kretprobe:if (!splice && file_out->f_op->copy_file_range)": {
        "description": "Check conditions for the given function",
        "pre": {
            "splice": false,
            "file_out->f_op": {
                "copy_file_range": true
            }
        }
    }
},
{
    "kprobe:if (!splice && file_out->f_op->copy_file_range)": {
        "description": "Condition for the if statement: if (!splice && file_out->f_op->copy_file_range)",
        "pre": {
            "splice": false,
            "file_out->f_op->copy_file_range": "!=null"
        }
    }
},
{
    "kretprobe:generic_write_checks_count": {
        "description": "Performs generic write checks for a given count.",
        "pre": {
            "iocb": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:generic_write_checks_count": {
        "description": "Performs generic write checks for the given iocb and count.",
        "pre": {
            "iocb": "!=null",
            "count": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kretprobe:sync_mapping_buffers": {
        "description": "Write out and wait upon a mapping's associated buffers",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:sync_mapping_buffers": {
        "description": "Write out and wait upon a mapping's associated buffers.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:generic_buffers_fsync_noflush": {
        "description": "Generic buffer fsync implementation for simple filesystems with no inode lock.",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [true, false]"
        }
    }
},
{
    "kprobe:generic_buffers_fsync_noflush": {
        "description": "generic buffer fsync implementation for simple filesystems with no inode lock",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [true, false]"
        }
    }
},
{
    "kretprobe:mark_buffer_dirty_inode": {
        "description": "Mark the buffer dirty for the inode.",
        "pre": {
            "address_space": "!=null",
            "address_space.private_lock": "held",
            "inode": "!=null",
            "inode.on_list": "not in [true, false]"
        }
    }
},
{
    "kprobe:/* * The buffer's backing address_space's private_lock must be held */": {
        "description": "The buffer's backing address_space's private_lock must be held.",
        "pre": {
            "address_space": "!=null",
            "private_lock": "held"
        }
    }
},
{
    "kretprobe:folio_memcg_lock": {
        "description": "Locks the memcg migration of a page and synchronizes PageDirty with per-memcg dirty page counters.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        },
        "post": {
            "newly_dirty": "==true",
            "mapping->host": "!=null",
            "mapping->host->i_state": "& I_DIRTY_PAGES"
        }
    }
},
{
    "kprobe:folio_memcg_lock": {
        "description": "Locks the memcg of a folio and marks it as dirty if necessary.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:__bread_gfp": {
        "description": "Reads a specified block and returns the buffer head that contains it.",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__bread_gfp": {
        "description": "Reads a specified block and returns the buffer head that contains it.",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:set_bh_page": {
        "description": "Set the page associated with the buffer head and calculate the data pointer.",
        "pre": {
            "bh": "!=null",
            "page": "!=null",
            "offset": "!=null",
            "offset": "< PAGE_SIZE",
            "PageHighMem(page)": "== false"
        },
        "post": {
            "bh->b_data": "((char *)(0 + offset)) || (page_address(page) + offset)"
        }
    }
},
{
    "kprobe:bh->b_data": {
        "description": "Set the value of bh->b_data based on the offset and page.",
        "pre": {
            "bh": {
                "b_page": "!=null",
                "b_data": "!=null"
            },
            "page": "!=null",
            "offset": "!=null"
        }
    }
},


{
    "kretprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio.",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio.",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__block_write_full_folio": {
        "description": "Write a full folio to disk.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "get_block": "!=null",
            "wbc": "!=null",
            "handler": "!=null",
            "block": "sector_t",
            "last_block": "sector_t",
            "bh": "struct buffer_head",
            "head": "struct buffer_head",
            "blocksize": "unsigned int",
            "bbits": "unsigned int",
            "nr_underway": "int",
            "write_flags": "blk_opf_t"
        }
    }
},
{
    "kprobe:__block_write_full_folio": {
        "description": "Write a full folio to disk.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "get_block": "!=null",
            "wbc": "!=null",
            "handler": "!=null",
            "block": "sector_t",
            "last_block": "sector_t",
            "bh": "struct buffer_head",
            "head": "struct buffer_head",
            "blocksize": "unsigned int",
            "bbits": "unsigned int",
            "nr_underway": "int",
            "write_flags": "blk_opf_t"
        }
    }
},


{
    "kretprobe:folio_test_uptodate": {
        "description": "Check if the folio is up-to-date.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_zero_new_buffers": {
        "description": "Zero out new buffers in the folio.",
        "pre": {
            "folio": "!=null",
            "start+copied": ">=0",
            "start+len": ">=0"
        }
    },
    "kretprobe:flush_dcache_folio": {
        "description": "Flush the data cache for the folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_uptodate": {
        "description": "Check if the folio is up-to-date.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_zero_new_buffers": {
        "description": "Zero out new buffers in the folio.",
        "pre": {
            "folio": "!=null",
            "start+copied": ">=0",
            "start+len": ">=0"
        }
    },
    "kprobe:flush_dcache_folio": {
        "description": "Flush the data cache for the folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:if (pos + copied > inode->i_size)": {
        "description": "Check if the sum of 'pos' and 'copied' is greater than 'inode->i_size'.",
        "pre": {
            "pos": "!=null",
            "copied": "!=null",
            "inode": "!=null",
            "inode->i_size": "!=null",
            "pos + copied": "> inode->i_size"
        }
    }
},
{
    "kprobe:if (pos + copied > inode->i_size)": {
        "description": "Check if the sum of pos and copied is greater than the size of the inode.",
        "pre": {
            "pos": "!=null",
            "copied": "!=null",
            "inode": "!=null",
            "inode->i_size": "> pos + copied"
        }
    }
},
{
    "kretprobe:block_is_partially_uptodate": {
        "description": "Checks whether buffers within a folio are uptodate or not.",
        "pre": {
            "folio": "!=null",
            "from": ">=0",
            "count": ">0"
        }
    }
},
{
    "kprobe:block_is_partially_uptodate": {
        "description": "Checks whether buffers within a folio are uptodate or not. Returns true if all buffers which correspond to the specified part of the folio are uptodate.",
        "pre": {
            "folio": "!=null",
            "from": ">= 0",
            "count": ">= 0"
        }
    }
},


{
    "kretprobe:block_commit_write": {
        "description": "Handles the basic task of block allocation and bringing partial write blocks uptodate.",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "from": ">=0",
            "to": ">=0",
            "partial": "false",
            "blocksize": ">=0",
            "bh": "!=null",
            "head": "!=null",
            "block_start": ">=0",
            "block_end": ">=0",
            "buffer_uptodate(bh)": "true if block_end <= from or block_start >= to, false otherwise",
            "set_buffer_uptodate(bh)": "called if block_end > from and block_start < to",
            "mark_buffer_dirty(bh)": "called if block_end > from and block_start < to",
            "buffer_new(bh)": "false if buffer is not new, true otherwise",
            "clear_buffer_new(bh)": "called if buffer is new",
            "bh->b_this_page": "!=null",
            "buffer_uptodate(bh->b_this_page)": "true if block_end <= from or block_start >= to, false otherwise"
        }
    }
},
{
    "kprobe:block_commit_write": {
        "description": "The block_commit_write function handles the basic task of block allocation and bringing partial write blocks up to date.",
        "pre": {
            "inode": "any",
            "folio": "any",
            "from": "any",
            "to": "any"
        }
    }
},

{
    "kprobe:block_page_mkwrite": {
        "description": "block_page_mkwrite() is not allowed to change the file size as it gets called from a page fault handler when a page is first dirtied. Hence we must be careful to check for EOF conditions here. We set the page up correctly for a written page which means we get ENOSPC checking when writing into holes and correct delalloc and unwritten extent mapping on filesystems that support these features. We are not allowed to take the i_mutex here so we have to play games to protect against truncate races as the page could now be beyond EOF. Because truncate writes the inode size before removing page once we have the page lock we can determine safely if the page is beyond EOF. If it is not beyond EOF, then the page is guaranteed safe against truncation until we unlock the page. Direct callers of this function should protect against filesystem freezing using sb_start_pagefault() - sb_end_pagefault() functions.",
        "pre": {
            "vma": "!=null",
            "vmf": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check if length is zero. If true, return 0. Otherwise, perform the following operations.",
        "pre": {
            "length": "==0",
            "blocksize": "!=null",
            "index": "!=null",
            "mapping": "!=null",
            "inode": "!=null",
            "folio": "!=null",
            "bh": "!=null"
        }
    }
},
{
    "kprobe:if (!length)return 0;length = blocksize - length;iblock = (sector_t)index << (PAGE_SHIFT - inode->i_blkbits);folio = filemap_grab_folio(mapping, index);if (IS_ERR(folio))return PTR_ERR(folio);bh = folio_buffers(folio);if (!bh)": {
        "description": "Condition for the given function",
        "pre": {
            "length": "==0",
            "blocksize": "!=null",
            "index": "!=null",
            "inode->i_blkbits": "!=null",
            "mapping": "!=null",
            "folio": "!=null",
            "bh": "!=null"
        }
    }
},
{
    "kretprobe:end_buffer_async_write": {
        "description": "Performs asynchronous write of buffer head and updates uptodate flag.",
        "pre": {
            "bh": "!=null",
            "uptodate": "==1"
        }
    }
},
{
    "kprobe:end_buffer_async_write": {
        "description": "Pages which are unlocked during IO and have PageWriteback cleared upon IO completion.",
        "pre": {
            "bh": "!=null",
            "uptodate": "is an integer"
        }
    }
},
{
    "kretprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers. If all the buffers are unlocked and clean, then the folio_test_dirty information is stale. If any of the buffers are locked, it is assumed they are locked for IO.",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        }
    }
},
{
    "kprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers.",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        }
    }
},


{
    "kretprobe:buffer_mapped": {
        "description": "Check if the buffer head is mapped.",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kprobe:buffer_mapped": {
        "description": "Check if the buffer head is mapped.",
        "pre": {
            "bh": "!=null"
        }
    }
},



{
    "kprobe:folio_init_buffers": {
        "description": "Initialise the state of a blockdev folio's buffers.",
        "pre": {
            "folio": "!=null",
            "bdev": "!=null",
            "block": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kretprobe:__bh_read": {
        "description": "Submit read for a locked buffer",
        "pre": {
            "bh": "!=null",
            "op_flags": "in [REQ_OP_...]",
            "wait": "bool"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kprobe:__bh_read": {
        "description": "Submit read for a locked buffer",
        "pre": {
            "bh": "!=null",
            "op_flags": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:__bh_read_batch": {
        "description": "Submit read for a batch of unlocked buffers",
        "pre": {
            "nr": "!=null",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE]",
            "force_lock": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kprobe:__bh_read_batch": {
        "description": "Submit read for a batch of unlocked buffers",
        "pre": {
            "nr": "!=null",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROE REQ_OP_ZONE_APPEND, REQ_OP_ZONE_RESET_ALL, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_RESET_WRITE_PTR, REQ_OP_ZONE_RESET_ZONE_PTR, REQ_OP_ZONE_APPEND_WRITE_PTR, REQ_OP_ZONE_APPEND_ZONE_PTR, REQ_OP_ZONE_RESET_ALL_WRITE_PTR, REQ_OP_ZONE_RESET_ALL_ZONE_PTR, REQ_OP_ZONE_FINISH_WRITE_PTR, REQ_OP_ZONE_FINISH_ZONE_PTR, REQ_OP_WRITE_SAME_WRITE_PTR, REQ_OP_WRITE_SAME_ZONE_PTR, REQ_OP_WRITE_ZEROES_WRITE_PTR, REQ_OP_WRITE_ZEROES_ZONE_PTR, REQ_OP_ZONE_APPEND_WRITE_PTR, REQ_OP_ZONE_APPEND_ZONE_PTR, REQ_OP_ZONE_RESET_ALL_WRITE_PTR, REQ_OP_ZONE_RESET_ALL_ZONE_PTR, REQ_OP_ZONE_FINISH_WRITE_PTR, REQ_OP_ZONE_FINISH_ZONE_PTR, REQ_OP_WRITE_SAME_WRITE_PTR, REQ_OP_WRITE_SAME_ZONE_PTR, REQ_OP_WRITE_ZEROES_WRITE_PTR, REQ_OP_WRITE_ZEROES_ZONE_PTR]",
            "force_lock": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EIO]"
        }
    }
},
{
    "kretprobe:pipe_lock_nested": {
        "description": "Locks the mutex associated with the pipe if pipe->files is not null.",
        "pre": {
            "pipe": "!=null",
            "subclass": "any",
            "pipe->files": "!=null",
            "pipe->mutex": "locked"
        }
    }
},
{
    "kprobe:pipe_lock_nested": {
        "description": "Nests non-pipe inode locks (for writing to a file)",
        "pre": {
            "pipe": "!=null",
            "subclass": "int"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_try_steal": {
        "description": "Attempt to take ownership of a pipe buffer",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_try_steal": {
        "description": "Attempt to take ownership of a pipe buffer.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_get": {
        "description": "get a reference to a &struct pipe_buffer",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_get": {
        "description": "Get a reference to a struct pipe_buffer.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},


{
    "kretprobe:vfs_fsync_range": {
        "description": "Helper to sync a range of data & metadata to disk",
        "pre": {
            "file": "!=null",
            "start": "!=null",
            "end": "!=null",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:vfs_fsync_range": {
        "description": "Helper to sync a range of data & metadata to disk",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:smp_mb": {
        "description": "__mark_inode_dirty(). This allows __mark_inode_dirty() to test i_state without grabbing i_lock - either they see the I_DIRTY bits cleared or we see the dirtied inode. I_DIRTY_PAGES is always cleared together above even if @mapping still has dirty pages. The flag is reinstated after smp_mb() if necessary. This guarantees that either __mark_inode_dirty() sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.",
        "pre": {
            "mapping": "!=null",
            "inode": "!=null",
            "inode->i_state": "& I_DIRTY_PAGES == 0 || mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)"
        }
    }
},
{
    "kprobe:smp_mb": {
        "description": "Memory barrier function.",
        "pre": {
            "mapping_tagged": {
                "mapping": "!=null",
                "tag": "PAGECACHE_TAG_DIRTY"
            },
            "inode_i_state_set": {
                "inode": "!=null",
                "state": "|= I_DIRTY_PAGES"
            },
            "inode_i_state_check": {
                "inode": "!=null",
                "state": "& I_PINNING_FSCACHE_WB"
            }
        }
    }
},
{
    "kretprobe:writeback_inodes_sb_nr": {
        "description": "Writeback dirty inodes from the given super_block.",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_FS_FREE_SPACE, WB_REASON_FS_INODE, WB_REASON_FS_SINGLE]"
        }
    }
},
{
    "kprobe:writeback_inodes_sb_nr": {
        "description": "Write back dirty inodes from a given super_block.",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_FS_FREE_SPACE, WB_REASON_SYNC, WB_REASON_PERIODIC]"
        }
    }
},
{
    "kretprobe:try_to_writeback_inodes_sb": {
        "description": "Try to start writeback if none underway",
        "pre": {
            "sb": "!=null",
            "reason": "!=null"
        }
    }
},
{
    "kprobe:try_to_writeback_inodes_sb": {
        "description": "Try to start writeback if none underway.",
        "pre": {
            "sb": "!=null",
            "reason": "!=null"
        }
    }
},


{
    "kretprobe:write_inode_now": {
        "description": "Write an inode to disk",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kprobe:write_inode_now": {
        "description": "Write an inode to disk",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion.",
        "pre": {
            "inode": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion.",
        "pre": {
            "inode": "!=null",
            "wait": "!=null"
        }
    }
},


{
    "kretprobe:get_file_rcu": {
        "description": "Check if the file pointer obtained from get_file_rcu is valid.",
        "pre": {
            "file": "==null"
        }
    },
    "kretprobe:continue": {
        "description": "Continue execution if the file table entry has changed.",
        "pre": {}
    }
},
{
    "kprobe:if (unlikely(!get_file_rcu(file)))continue;/* *  (b) the file table entry has changed under us. *       Note that we don't need to re-check the 'fdt->fd' *       pointer having changed, because it always goes *       hand-in-hand with 'fdt'. * * If so, we need to put our ref and try again. */": {
        "description": "Check if the file table entry has changed and handle the race condition.",
        "pre": {
            "file": "!=null",
            "fd": "< fdt->max_fds",
            "fdt->fd + array_index_nospec(fd, fdt->max_fds)": "!=null",
            "file->f_mode & mask": "==0"
        }
    }
},


{
    "kretprobe:vfs_parse_fs_param_source": {
        "description": "Handle setting \"source\" via parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null"
        },
        "post": {
            "return": "in [0, -ENOPARAM, -EINVAL]"
        }
    }
},
{
    "kprobe:vfs_parse_fs_param_source": {
        "description": "Handle setting \"source\" via parameter",
        "pre": {
            "fc": "!=null",
            "param": "!=null"
        }
    }
},
{
    "kretprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">=0"
        }
    }
},
{
    "kprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">=0"
        }
    }
},
{
    "kretprobe:generic_parse_monolithic": {
        "description": "Parse key[=val][,key[=val]] mount data.",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:generic_parse_monolithic": {
        "description": "Parse key[=val][,key[=val]] mount data.",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicates the file system context.",
        "pre": {
            "src_fc": "!=null",
            "src_fc->ops->dup": "!=null",
            "ret": ">= -EOPNOTSUPP",
            "fc": "!=null",
            "fc->uapi_mutex": "initialized",
            "fc->fs_private": "== NULL",
            "fc->s_fs_info": "== NULL",
            "fc->source": "== NULL",
            "fc->security": "== NULL",
            "fc->fs_type": "!=null",
            "fc->net_ns": "!=null",
            "fc->user_ns": "!=null",
            "fc->cred": "!=null",
            "fc->log.log": "!=null",
            "fc->log.log->usage": "incremented"
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicate the file system context.",
        "pre": {
            "src_fc": "!=null",
            "src_fc->ops->dup": "!=null",
            "ret": "int",
            "fc": "!=null",
            "!fc->ops->dup": "false",
            "fc = kmemdup(src_fc, sizeof(struct fs_context), GFP_KERNEL)": "fc != null",
            "mutex_init(&fc->uapi_mutex)": "true",
            "fc->fs_private": "null",
            "fc->s_fs_info": "null",
            "fc->source": "null",
            "fc->security": "null",
            "get_filesystem(fc->fs_type)": "true",
            "get_net(fc->net_ns)": "true",
            "get_user_ns(fc->user_ns)": "true",
            "get_cred(fc->cred)": "true",
            "fc->log.log": "null",
            "ret < 0": "false"
        }
    }
},
{
    "kretprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "in ['DEBUG', 'INFO', 'WARNING', 'ERROR']",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "in ['DEBUG', 'INFO', 'WARNING', 'ERROR']",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "pre": {
            "src_fc": "!=null"
        }
    }
},
{
    "kretprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kretprobe:generic_fill_statx_attr": {
        "description": "Fill in the statx attributes from the inode flags",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fill_statx_attr": {
        "description": "Fill in the statx attributes from the inode flags",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kretprobe:vfs_getattr_nosec": {
        "description": "getattr without security checks",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "is an integer",
            "query_flags": "is an integer"
        }
    }
},
{
    "kprobe:vfs_getattr_nosec": {
        "description": "getattr without security checks",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "is an integer",
            "query_flags": "is an integer"
        }
    }
},

{
    "kprobe:inode_set_bytes": {
        "description": "Set the number of bytes and blocks for an inode.",
        "pre": {
            "inode": "!=null",
            "bytes": ">=0",
            "inode->i_lock": "locked"
        }
    }
},


{
    "kretprobe:inode_init_always": {
        "description": "Perform inode structure initialization",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_init_always": {
        "description": "Perform inode structure initialization",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:drop_nlink": {
        "description": "Directly drop an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:drop_nlink": {
        "description": "Directly drop an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:clear_nlink": {
        "description": "Directly zero an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:clear_nlink": {
        "description": "Directly zero an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:set_nlink": {
        "description": "Directly set an inode's link count",
        "pre": {
            "inode": "!=null",
            "nlink": "!=null",
            "nlink": ">0"
        }
    }
},
{
    "kprobe:set_nlink": {
        "description": "Directly set an inode's link count",
        "pre": {
            "inode": "!=null",
            "nlink": "!=null",
            "nlink": ">0"
        }
    }
},
{
    "kretprobe:inc_nlink": {
        "description": "Directly increment an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inc_nlink": {
        "description": "Directly increment an inode's link count",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:__insert_inode_hash": {
        "description": "Hash an inode and add it to the inode hash for this superblock.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null"
        }
    }
},
{
    "kprobe:__insert_inode_hash": {
        "description": "Hash an inode and add it to the inode hash for this superblock.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null"
        }
    }
},
{
    "kretprobe:__remove_inode_hash": {
        "description": "Remove an inode from the hash",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:__remove_inode_hash": {
        "description": "Remove an inode from the hash",
        "pre": {
            "inode": "!=null"
        }
    }
},


{
    "kretprobe:get_next_ino": {
        "description": "Function to get the next inode number",
        "pre": {
            "p": "!=null",
            "res": "!=null",
            "res & (LAST_INO_BATCH-1)": "!=0",
            "next": "!=null",
            "next - LAST_INO_BATCH": "!=0",
            "res + 1": "!=0"
        }
    }
},
{
    "kprobe:get_next_ino": {
        "description": "Function to get the next inode number",
        "pre": {
            "p": "!=null",
            "res": "isUnsignedInt",
            "res & (LAST_INO_BATCH-1)": "!=0",
            "shared_last_ino": "isAtomicInt",
            "next": "isInt",
            "next - LAST_INO_BATCH": "isInt",
            "get_next_ino": "!=0"
        }
    }
},
{
    "kretprobe:new_inode_pseudo": {
        "description": "Obtain an inode for the given superblock.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:new_inode_pseudo": {
        "description": "Obtain an inode for the given superblock.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:lockdep_annotate_inode_mutex_key": {
        "description": "Annotate the mutex key of an inode if it is a directory.",
        "pre": {
            "inode": "!=null",
            "S_ISDIR(inode->i_mode)": "true",
            "type": "!=null"
        }
    }
},
{
    "kprobe:lockdep_match_class": {
        "description": "Check if the lock class of inode's i_rwsem matches the lock class of type's i_mutex_key.",
        "pre": {
            "inode": "!=null",
            "type": "!=null",
            "inode->i_rwsem": "!=null",
            "type->i_mutex_key": "!=null"
        }
    }
},
{
    "kretprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters for the new inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters for the new inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null",
            "inode1_is_directory": "==false",
            "inode2_is_directory": "==false"
        }
    }
},
{
    "kprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects.",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null",
            "inode1_is_directory": "==false",
            "inode2_is_directory": "==false"
        }
    }
},
{
    "kretprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kretprobe:inode_insert5": {
        "description": "Insert a pre-allocated inode into cache and return it locked, hashed, and with the I_NEW flag set.",
        "pre": {
            "inode": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "set": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:inode_insert5": {
        "description": "Insert a pre-allocated inode into the cache and return it locked, hashed, and with the I_NEW flag set.",
        "pre": {
            "inode": "!=null",
            "hashval": ">=0",
            "test": "!=null",
            "set": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_fast": {
        "description": "Find an inode quickly in a given super block using the inode number.",
        "pre": {
            "sb": "!=null",
            "head": "!=null",
            "ino": "!=null"
        }
    }
},


{
    "kprobe:iunique_lock": {
        "description": "Lock the inode hash lock.",
        "pre": {
            "inode_hash_lock": "!=null"
        }
    }
},
{
    "kretprobe:igrab": {
        "description": "Handle the case where s_op->clear_inode is not been called yet, and somebody is calling igrab while the inode is getting freed.",
        "pre": {
            "inode": "==null"
        }
    }
},
{
    "kprobe:igrab": {
        "description": "Handle the case where s_op->clear_inode is not been called yet, and somebody is calling igrab while the inode is getting freed.",
        "pre": {
            "inode": "==null"
        }
    }
},
{
    "kretprobe:ilookup5_nowait": {
        "description": "Search for an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ilookup5_nowait": {
        "description": "Search for an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_nowait": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "match": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:find_inode_nowait": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "match": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_rcu": {
        "description": "Find an inode in the inode cache.",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:find_inode_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "hashval": "!=null",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},
{
    "kprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache",
        "pre": {
            "sb": "!=null",
            "ino": "!=null"
        }
    }
},


{
    "kretprobe:bmap": {
        "description": "Find a block number in a file",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "block": "in [0, !=0] when return == 0"
        }
    }
},
{
    "kprobe:bmap": {
        "description": "Find a block number in a file",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "block": "in [0, !=0] when return == 0"
        }
    }
},
{
    "kretprobe:touch_atime": {
        "description": "Update the access time of a file.",
        "pre": {
            "path": "!=null",
            "mnt": "=path->mnt",
            "inode": "=d_inode(path->dentry)",
            "now": "=current_time(inode)",
            "atime_needs_update(path, inode)": "=true",
            "sb_start_write_trylock(inode->i_sb)": "=true",
            "__mnt_want_write(mnt)": "=0"
        },
        "post": {
            "sb_end_write(inode->i_sb)": "called"
        }
    }
},
{
    "kprobe:now = current_time(inode);inode_update_time(inode, &now, S_ATIME);__mnt_drop_write(mnt);skip_update:sb_end_write(inode->i_sb);}EXPORT_SYMBOL(touch_atime": {
        "description": "Updates the access time of a file.",
        "pre": {
            "path": "!=null",
            "path->mnt": "!=null",
            "path->dentry": "!=null",
            "d_inode(path->dentry)": "!=null",
            "atime_needs_update(path, d_inode(path->dentry))": "true",
            "sb_start_write_trylock(d_inode(path->dentry)->i_sb)": "true",
            "__mnt_want_write(path->mnt)": "== 0"
        }
    }
},
{
    "kretprobe:file_remove_privs": {
        "description": "Remove special file privileges (suid, capabilities) from a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "file": "!=null"
},


{
    "kretprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null",
            "flags": "in [IOCB_NOWAIT]",
            "file_inode_lock": "held"
        },
        "post": {
            "return_value": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file.",
        "pre": {
            "file": "!=null",
            "flags": "!=null",
            "flags": "in [IOCB_NOWAIT]",
            "file_inode_lock": "held"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kretprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device.",
        "pre": {
            "inode": "!=null",
            "mode": "!=null",
            "rdev": "!=null",
            "inode->i_mode": "==mode",
            "S_ISCHR(mode)": "implies (inode->i_fop == &def_chr_fops && inode->i_rdev == rdev)",
            "S_ISBLK(mode)": "implies (IS_ENABLED(CONFIG_BLOCK) && inode->i_fop == &def_blk_fops && inode->i_rdev == rdev)",
            "S_ISFIFO(mode)": "implies (inode->i_fop == &pipefifo_fops)",
            "S_ISSOCK(mode)": "implies (inode->i_fop == &no_open_fops)"
        }
    }
},
{
    "kprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device.",
        "pre": {
            "inode": {
                "i_mode": "mode",
                "i_fop": {
                    "def_chr_fops": "S_ISCHR(mode)",
                    "def_blk_fops": "S_ISBLK(mode) && IS_ENABLED(CONFIG_BLOCK)",
                    "pipefifo_fops": "S_ISFIFO(mode)",
                    "no_open_fops": "S_ISSOCK(mode)"
                },
                "i_rdev": "rdev"
            }
        }
    }
},
{
    "kretprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "bool",
            "constraints": [
                "current has CAP_FOWNER in a namespace with the inode owner uid mapped",
                "current owns the file"
            ]
        }
    }
},
{
    "kprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_dio_wait": {
        "description": "wait for outstanding DIO requests to finish",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_dio_wait": {
        "description": "Wait for outstanding DIO requests to finish.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_set_flags": {
        "description": "Atomically set some inode flags.",
        "pre": {
            "inode": "!=null",
            "flags": "!=null",
            "mask": "!=null",
            "i_mutex": "held",
            "i_flags": "unchanged during execution"
        }
    }
},
{
    "kprobe:inode_set_flags": {
        "description": "Atomically set some inode flags.",
        "pre": {
            "inode": "!=null",
            "flags": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:timestamp_truncate": {
        "description": "Truncate timespec to a granularity",
        "pre": {
            "t": "!=null",
            "inode": "!=null",
            "gran": "!=0",
            "gran": "<=1000000000"
        }
    }
},
{
    "kprobe:timestamp_truncate": {
        "description": "Truncate timespec to a granularity",
        "pre": {
            "t": "!=null",
            "inode": "!=null",
            "gran": "!=0",
            "gran": "<=1000000000"
        }
    }
},
{
    "kretprobe:touch_atime": {
        "description": "Return mask of changes for notify_change() that need to be done as a response to write or truncate. Return 0 if nothing has to be changed. Negative value on error (change should be denied).",
        "pre": {
            "path": "!=null",
            "inode": "!=null",
            "now": "!=null",
            "relatime_need_update(mnt, inode, now)": "return false",
            "timespec64_equal(&inode->i_atime, &now)": "return false",
            "return true"
        }
    }
},
{
    "kprobe:touch_atime": {
        "description": "Return mask of changes for notify_change() that need to be done as a response to write or truncate. Return 0 if nothing has to be changed. Negative value on error (change should be denied).",
        "pre": {
            "path": "!=null",
            "inode": "!=null",
            "now": "!=null",
            "mnt": "!=null",
            "atime_needs_update(path, inode)": "true",
            "sb_start_write_trylock(inode->i_sb)": "true",
            "__mnt_want_write(mnt)": "== 0"
        }
    }
},
{
    "kretprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "!=null",
            "mode & S_ISGID": "==1",
            "mode & S_IXGRP": "==1",
            "dir & S_ISGID": "==1",
            "caller in group of parent directory or CAP_FSETID in user namespace and privileged over parent directory": "true"
        },
        "post": {
            "new mode": "mode & ~S_ISGID"
        }
    }
},
{
    "kprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "!=null",
            "mode & S_ISGID": "!=0",
            "mode & S_IXGRP": "!=0",
            "dir & S_ISGID": "!=0",
            "caller in group of parent directory or CAP_FSETID in user namespace and privileged over parent directory": "true"
        },
        "post": {
            "new mode to use for the file": "!=null"
        }
    }
},
{
    "kretprobe:__dump_emit": {
        "description": "Core dumping helper function.",
        "pre": {
            "cprm": "!=null",
            "addr": "!=null",
            "nr": "!=null"
        }
    }
},
{
    "kprobe:__dump_emit": {
        "description": "Core dumping helper function.",
        "pre": {
            "cprm": "!=null",
            "addr": "!=null",
            "nr": "!=null"
        }
    }
},


{
    "kretprobe:vfs_ioctl": {
        "description": "Call filesystem specific ioctl methods",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:vfs_ioctl": {
        "description": "Call filesystem specific ioctl methods",
        "pre": {
            "filp": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function",
        "pre": {
            "fieinfo": "!=null",
            "logical": "!=null",
            "phys": "!=null",
            "len": "!=null",
            "flags": "in [FIEMAP_EXTENT flags]"
        }
    }
},
{
    "kprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function",
        "pre": {
            "fieinfo": "!=null",
            "logical": "!=null",
            "phys": "!=null",
            "len": "!=null",
            "flags": "in [FIEMAP_EXTENT]"
        }
    }
},
{
    "kretprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": "!=null",
            "len": "!=null",
            "supported_flags": "!=null"
        }
    }
},
{
    "kprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": "!=null",
            "len": "!=null",
            "supported_flags": "!=null"
        }
    }
},
{
    "kretprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags",
        "pre": {
            "fa": "!=null",
            "xflags": "!=null"
        }
    }
},
{
    "kprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags",
        "pre": {
            "fa": "!=null",
            "xflags": "!=null"
        }
    }
},
{
    "kretprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags",
        "pre": {
            "fa": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags",
        "pre": {
            "fa": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kretprobe:copy_fsxattr_to_user": {
        "description": "Copy fsxattr to userspace.",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT]"
        }
    }
},
{
    "kprobe:copy_fsxattr_to_user": {
        "description": "copy fsxattr to userspace.",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        }
    }
},
{
    "kretprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        }
    }
},
{
    "kretprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation",
        "pre": {
            "file": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        },
        "post": {
            "return_value": "is_valid_long"
        }
    }
},
{
    "kprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation",
        "pre": {
            "file": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:generic_remap_file_range_prep": {
        "description": "Prepare for generic remap file range operation.",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "remap_flags": "!=null",
            "dax_read_ops": "!=null",
            "inode_in": "!=null",
            "inode_out": "!=null",
            "same_inode": "in [true, false]",
            "ret": "!=null"
        },
        "post": {
            "ret": "in [-EPERM, -ETXTBSY]"
        }
    }
},
{
    "kprobe:generic_remap_file_range_prep": {
        "description": "Prepare for generic remap file range operation.",
        "pre": {
            "file_in": "!=null",
            "pos_in": "!=null",
            "file_out": "!=null",
            "pos_out": "!=null",
            "len": "!=null",
            "remap_flags": "!=null",
            "dax_read_ops": "!=null",
            "inode_in": "!=null",
            "inode_out": "!=null",
            "same_inode": "in [true, false]",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:remap_verify_area": {
        "description": "Verify the area for remapping.",
        "pre": {
            "src_file": "!=null",
            "src_pos": "!=null",
            "len": "!=null",
            "false": "true"
        }
    },
    "kretprobe:remap_verify_area": {
        "description": "Verify the area for remapping.",
        "pre": {
            "dst_file": "!=null",
            "dst_pos": "!=null",
            "len": "!=null",
            "true": "true"
        }
    },
    "kretprobe:allow_file_dedupe": {
        "description": "Check if file deduplication is allowed.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:file_inode": {
        "description": "Get the inode of a file.",
        "pre": {
            "src_file": "!=null",
            "dst_file": "!=null"
        }
    },
    "kretprobe:S_ISDIR": {
        "description": "Check if the file is a directory.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:dst_file->f_op->remap_file_range": {
        "description": "Check if remap_file_range is supported by the file.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kretprobe:len": {
        "description": "Check if len is equal to 0.",
        "pre": {
            "len": "0"
        }
    }
},
{
    "kprobe:remap_verify_area": {
        "description": "Verify the area to be remapped.",
        "pre": {
            "src_file": "!=null",
            "src_pos": "!=null",
            "len": "!=null",
            "false": "true"
        }
    },
    "kprobe:remap_verify_area": {
        "description": "Verify the area to be remapped.",
        "pre": {
            "dst_file": "!=null",
            "dst_pos": "!=null",
            "len": "!=null",
            "true": "true"
        }
    },
    "kprobe:allow_file_dedupe": {
        "description": "Check if file deduplication is allowed.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:file_inode": {
        "description": "Get the inode of a file.",
        "pre": {
            "src_file": "!=null",
            "dst_file": "!=null"
        }
    },
    "kprobe:S_ISDIR": {
        "description": "Check if the file is a directory.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:dst_file->f_op->remap_file_range": {
        "description": "Check if the file has the remap_file_range operation.",
        "pre": {
            "dst_file": "!=null"
        }
    },
    "kprobe:len": {
        "description": "Check if the length is zero.",
        "pre": {
            "len": "0"
        }
    }
},
{
    "kretprobe:vfs_dedupe_file_range_compare": {
        "description": "Compare file ranges for deduplication.",
        "pre": {
            "!folio_test_uptodate(src_folio)": true,
            "!folio_test_uptodate(dst_folio)": true,
            "src_folio->mapping": "!= src->f_mapping",
            "dst_folio->mapping": "!= dest->f_mapping"
        }
    }
},
{
    "kprobe:vfs_dedupe_file_range_compare": {
        "description": "Compare file ranges for deduplication.",
        "pre": {
            "!folio_test_uptodate(src_folio)": true,
            "!folio_test_uptodate(dst_folio)": true,
            "src_folio->mapping": "!= src->f_mapping",
            "dst_folio->mapping": "!= dest->f_mapping"
        }
    }
},


{
    "kretprobe:WARN_ON_ONCE": {
        "description": "Check if the fl_ops field of the new lock is not null.",
        "pre": {
            "new->fl_ops": "!=null"
        }
    },
    "kretprobe:locks_copy_conflock": {
        "description": "Copy the contents of the fl lock to the new lock.",
        "pre": {
            "new": "freshly-initialized lock",
            "fl": "lock"
        }
    },
    "kretprobe:new->fl_file": {
        "description": "Assign the fl_file field of the fl lock to the new lock.",
        "pre": {
            "new->fl_file": "= fl->fl_file"
        }
    },
    "kretprobe:new->fl_ops": {
        "description": "Assign the fl_ops field of the fl lock to the new lock.",
        "pre": {
            "new->fl_ops": "= fl->fl_ops"
        }
    },
    "kretprobe:if (fl->fl_ops)": {
        "description": "Check if the fl_ops field of the fl lock is not null.",
        "pre": {
            "fl->fl_ops": "!=null"
        }
    }
},
{
    "kprobe:locks_copy_lock": {
        "description": "Copy the contents of the file lock 'fl' to the newly initialized file lock 'new'.",
        "pre": {
            "new": {
                "fl_ops": "==null"
            },
            "fl": {
                "fl_ops": "!=null"
            }
        }
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Stop waiting for a file lock",
        "pre": {
            "waiter": "!=null",
            "waiter->fl_blocker": "==null"
        }
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Store NULL in the fl_blocker field of the waiter structure.",
        "pre": {
            "waiter": "!=null"
        }
    }
},
{
    "kretprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file.",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        }
    }
},
{
    "kprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        }
    }
},
{
    "kretprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "pre": {
            "filp": "!=null",
            "type": "is a valid long value",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "pre": {
            "filp": "!=null",
            "type": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:__break_lease": {
        "description": "__break_lease - revoke all outstanding leases on file",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        }
    }
},
{
    "kprobe:__break_lease": {
        "description": "__break_lease-revoke all outstanding leases on file",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        }
    }
},
{
    "kretprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease.",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease.",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:generic_setlease": {
        "description": "Sets a lease on an open file.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null",
            "flp->fl_lmops->lm_break": "!=null"
        }
    }
},
{
    "kprobe:generic_setlease": {
        "description": "Sets a lease on an open file.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "flp": "!=null",
            "priv": "!=null",
            "flp->fl_lmops->lm_break": "!=null"
        }
    }
},
{
    "kretprobe:locks_lock_inode_wait": {
        "description": "Apply a lock to an inode",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:locks_lock_inode_wait": {
        "description": "Apply a lock to an inode",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:locks_remove_posix": {
        "description": "Remove POSIX locks from a file.",
        "pre": {
            "filp": "!=null",
            "owner": "!=null",
            "inode": "!=null",
            "lock": "!=null",
            "ctx": "!=null",
            "error": "!=null"
        }
    }
},
{
    "kprobe:locks_remove_posix": {
        "description": "Remove POSIX locks from a file.",
        "pre": {
            "filp": "!=null",
            "owner": "!=null",
            "inode": "!=null",
            "ctx": "!=null",
            "list_empty(&ctx->flc_posix)": "true",
            "locks_init_lock(&lock)": "true",
            "lock.fl_type": "F_UNLCK",
            "lock.fl_flags": "FL_POSIX | FL_CLOSE",
            "lock.fl_start": "0",
            "lock.fl_end": "OFFSET_MAX",
            "lock.fl_owner": "owner",
            "lock.fl_pid": "current->tgid",
            "lock.fl_file": "filp",
            "lock.fl_ops": "NULL",
            "lock.fl_lmops": "NULL",
            "vfs_lock_file(filp, F_SETLK, &lock, NULL)": "error",
            "lock.fl_ops && lock.fl_ops->fl_release_private": "true",
            "lock.fl_ops->fl_release_private(&lock)": "true",
            "trace_locks_remove_posix(inode, &lock, error)": "true"
        }
    }
},
{
    "kretprobe:finish_open": {
        "description": "Finish opening a file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null"
        }
    }
},
{
    "kprobe:finish_open": {
        "description": "Finish opening a file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kretprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:dentry_open": {
        "description": "Open a dentry",
        "pre": {
            "f": {
                "f_path": {
                    "mnt": "!=null"
                },
                "f_inode": "!=null",
                "f_mapping": "!=null",
                "f_flags": "in [O_PATH, O_RDWR, O_WRONLY, O_RDONLY]"
            },
            "inode": {
                "i_mode": "!=null"
            }
        }
    }
},
{
    "inode": {
        "i_mode": {
            "constraints": [
                "S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)"
            ]
        }
    }
},
{
    "kretprobe:dentry_create": {
        "description": "Create and open a file",
        "pre": {
            "path": "!=null",
            "flags": "!=null",
            "mode": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:dentry_create": {
        "description": "Create and open a file",
        "pre": {
            "path": "!=null",
            "flags": "!=null",
            "mode": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kretprobe:filp_open": {
        "description": "Open file and return file pointer",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:filp_open": {
        "description": "Open file and return file pointer",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors.",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors.",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:get_cached_acl": {
        "description": "Get the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null",
            "ret": "!=null",
            "acl": "==ret",
            "IS_ERR(ret)": "==false",
            "is_uncached_acl(acl)": "==false",
            "IS_POSIXACL(inode)": "==true",
            "sentinel": "==uncached_acl_sentinel(current)",
            "p": "==acl_by_type(inode, type)"
        },
        "post": {
            "return": "==acl"
        }
    }
},
{
    "kprobe:get_cached_acl": {
        "description": "Get the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:IS_POSIXACL": {
        "description": "Check if the inode has POSIX ACL enabled.",
        "pre": {
            "inode": "!=null"
        }
    },
    "kprobe:uncached_acl_sentinel": {
        "description": "Get the uncached ACL sentinel for the current task.",
        "pre": {
            "current": "!=null"
        }
    },
    "kprobe:acl_by_type": {
        "description": "Get the ACL by type for the given inode.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:get_inode_acl": {
        "description": "Get the inode ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:posix_acl_dup": {
        "description": "Duplicate the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:posix_acl_release": {
        "description": "Release the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:xchg": {
        "description": "Exchange the value of the given variable with a new value.",
        "pre": {
            "p": "!=null",
            "acl": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:posix_acl_release": {
        "description": "Release the given POSIX ACL.",
        "pre": {
            "acl": "!=null"
        }
    },
    "kprobe:__forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "p": "!=null"
        }
    },
    "kprobe:forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:__forget_cached_acl": {
        "description": "Forget the cached ACL for the given inode and type.",
        "pre": {
            "p": "!=null"
        }
    },
    "kprobe:forget_all_cached_acls": {
        "description": "Forget all the cached ACLs for the given inode.",
        "pre": {
            "inode": "!=null"
        }
    },
    "kprobe:__get_acl": {
        "description": "Get the ACL for the given inode, dentry, and type.",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "type": "!=null"
        }
    },
    "kprobe:is_uncached_acl": {
        "description": "Check if the ACL is uncached.",
        "pre": {
            "sentinel": "!=null"
        }
    }
},
{
    "kretprobe:posix_acl_equiv_mode": {
        "description": "Check if the given ACL is equivalent to the mode bits.",
        "pre": {
            "acl": "==null",
            "pa": "!=null",
            "pe": "!=null"
        }
    }
},



{
    "kretprobe:posix_acl_update_mode": {
        "description": "Update the file mode when setting an ACL: compute the new file permission bits based on the ACL.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        }
    }
},
{
    "kprobe:posix_acl_update_mode": {
        "description": "Update mode in set_acl",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        }
    }
},
{
    "kretprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file.",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file.",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:splice_direct_to_actor": {
        "description": "Splices data directly between two non-pipes.",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_direct_to_actor": {
        "description": "Splices data directly between two non-pipes.",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:do_splice_direct": {
        "description": "Splices data directly between two files.",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:do_splice_direct": {
        "description": "splices data directly between two files",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:copy_string_kernel": {
        "description": "Copy a string from user space to kernel space.",
        "pre": {
            "arg": "!=null",
            "bprm": "!=null",
            "bprm->p": "!=null",
            "len": "==0",
            "valid_arg_len(bprm, len)": "==true"
        }
    }
},
{
    "kprobe:copy_string_kernel": {
        "description": "Copy a string from user space to kernel space.",
        "pre": {
            "pos": "any",
            "len": "== 0",
            "arg": "any",
            "bprm": "!= null"
        }
    }
},

{
    "kprobe:bprm_mm_init": {
        "description": "Initialize the memory map for the binary being executed.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kretprobe:open_exec": {
        "description": "Open and execute a file.",
        "pre": {
            "fd": "!=null",
            "name": "!=null",
            "flags": "!=null",
            "flags": "in [AT_SYMLINK_NOFOLLOW, AT_EMPTY_PATH]"
        }
    }
},
{
    "kprobe:open_exec": {
        "description": "Open and execute a file.",
        "pre": {
            "err": "== -EACCES",
            "file": {
                "inode": {
                    "i_mode": "& S_IFREG != 0"
                },
                "f_path": {
                    "path_noexec": "== false"
                }
            }
        }
    }
},
{
    "kretprobe:bprm_creds_from_file": {
        "description": "Compute the credentials for the given binary file.",
        "pre": {
            "bprm": "!=null"
        },
        "post": {
            "retval": "!=null",
            "retval": "!=0"
        }
    }
},
{
    "kprobe:bprm_creds_from_file": {
        "description": "Ensure all future errors are fatal.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "acct_arg_size": {
        "description": "Calculate the size of the accounting arguments for the given bprm.",
        "pre": {
            "bprm": "!=null"
        },
        "post": {
            "retval": ">=0"
        }
    }
},
{
    "kprobe:acct_arg_size": {
        "description": "Calculate the size of the accounting arguments for the given bprm.",
        "pre": {
            "bprm": "!=null"
        }
    },
    "kprobe:exec_mmap": {
        "description": "Execute mmap on the given mm.",
        "pre": {
            "mm": "!=null"
        }
    },
    "kprobe:exec_task_namespaces": {
        "description": "Execute task namespaces.",
        "pre": {}
    },
    "kprobe:spin_lock_irq": {
        "description": "Acquire the spinlock for the siglock of the current process.",
        "pre": {
            "me": "!=null",
            "me->sighand": "!=null",
            "me->sighand->siglock": "!=null"
        }
    },
    "kprobe:posix_cpu_timers_exit": {
        "description": "Exit the POSIX CPU timers for the given process.",
        "pre": {
            "me": "!=null"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release the spinlock for the siglock of the current process.",
        "pre": {
            "me": "!=null",
            "me->sighand": "!=null",
            "me->sighand->siglock": "!=null"
        }
    },
    "kprobe:exit_itimers": {
        "description": "Exit the interval timers for the given process.",
        "pre": {
            "me": "!=null"
        }
    },
    "kprobe:flush_itimer_signals": {
        "description": "Flush the itimer signals for the current process.",
        "pre": {}
    }
},


{
    "kretprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "pre": {
            "current": {
                "group_leader": "!=null"
            },
            "current->signal": {
                "rlim[RLIMIT_STACK]": "!=null"
            },
            "bprm": {
                "rlim_stack": "!=null"
            }
        }
    }
},
{
    "kprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kretprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "pre": {
            "interp": "!=null",
            "bprm": {
                "interp": "!=bprm->filename"
            }
        },
        "post": {
            "interp": "=kstrdup(interp, GFP_KERNEL)",
            "!interp": "return -ENOMEM",
            "return": "0"
        }
    }
},
{
    "kprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "pre": {
            "bprm->interp": "!= bprm->filename",
            "kfree(bprm->interp)": "called",
            "bprm->interp": "= kstrdup(interp, GFP_KERNEL)",
            "!bprm->interp": "return -ENOMEM",
            "return": "0"
        }
    }
},
{
    "kretprobe:register_chrdev_region": {
        "description": "Register a range of device numbers",
        "pre": {
            "from": "!=null",
            "count": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:register_chrdev_region": {
        "description": "Register a range of device numbers",
        "pre": {
            "from": "!=null",
            "count": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:alloc_chrdev_region": {
        "description": "Register a range of char device numbers",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kprobe:alloc_chrdev_region": {
        "description": "Register a range of char device numbers",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:cdev_init": {
        "description": "Initialize a cdev structure",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kprobe:cdev_init": {
        "description": "Initialize a cdev structure",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kretprobe:unregister_chrdev_region": {
        "description": "Unregister a range of device numbers.",
        "pre": {
            "from": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:unregister_chrdev_region": {
        "description": "Unregister a range of device numbers.",
        "pre": {
            "from": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:chrdev_open": {
        "description": "Called every time a character special file is opened",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:chrdev_open": {
        "description": "Called every time a character special file is opened",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:cdev_set_parent": {
        "description": "Set the parent kobject for a char device",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:cdev_set_parent": {
        "description": "Set the parent kobject for a char device.",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kretprobe:cdev_device_add": {
        "description": "Add a char device and its corresponding struct device.",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kprobe:cdev_device_add": {
        "description": "Add a char device and its corresponding struct device.",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kretprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add",
        "pre": {
            "dev": "!=null",
            "cdev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add",
        "pre": {
            "dev": "!=null",
            "cdev": "!=null",
            "dev->devt": "!=null"
        }
    }
},
{
    "kretprobe:make_bad_inode": {
        "description": "Mark an inode as bad due to an I/O error",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:make_bad_inode": {
        "description": "Mark an inode as bad due to an I/O error.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:is_bad_inode": {
        "description": "Check if the inode has been marked as bad.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:is_bad_inode": {
        "description": "Check if the inode has been marked as bad.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it.",
        "pre": {
            "inode": "!=null"
        }
    }
},

{
    "kprobe:map_buffer_to_folio": {
        "description": "Map a buffer into a page to avoid adding new buffers.",
        "pre": {
            "folio": "!=null",
            "bh": "!=null",
            "page_block": "!=null"
        }
    }
},
{
    "kretprobe:intmpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space and writepage() all of them.",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kprobe:intmpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space & writepage() all of them.",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:setattr_should_drop_sgid": {
        "description": "Check if the setgid bit needs to be removed from the inode.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [ATTR_KILL_SGID, 0]"
        }
    }
},
{
    "kprobe:setattr_should_drop_sgid": {
        "description": "Check if the setgid bit needs to be removed from the inode.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "retval": "in [ATTR_KILL_SGID, 0]"
        }
    }
},
{
    "kretprobe:setattr_should_drop_suidgid": {
        "description": "Determine whether the set{g,u}id bit needs to be dropped.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [0, ATTR_KILL_SUID, ATTR_KILL_SGID, ATTR_KILL_SUID | ATTR_KILL_SGID]"
        }
    }
},
{
    "kprobe:setattr_should_drop_suidgid": {
        "description": "Determine whether the set{g,u}id bit needs to be dropped.",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [ATTR_KILL_SUID, ATTR_KILL_SGID, 0]"
        }
    }
},

{
    "kprobe:if (ia_valid & ATTR_FORCE)goto kill_priv;/* Make sure a caller can chown. */": {
        "description": "Check if a caller can chown.",
        "pre": {
            "ia_valid": "!=0",
            "ATTR_FORCE": "!=0"
        },
        "goto": "kill_priv"
    }
},
{
    "kretprobe:ia_valid & ATTR_TOUCH": {
        "description": "Check if the `ia_valid` bitmask includes the `ATTR_TOUCH` flag.",
        "pre": {
            "ia_valid": "&= ATTR_TOUCH"
        }
    }
},
{
    "kprobe:if (ia_valid & ATTR_TOUCH)": {
        "description": "Check if the `ia_valid` bitmask includes the `ATTR_TOUCH` flag.",
        "pre": {
            "ia_valid": "& ATTR_TOUCH != 0"
        }
    }
},
{
    "kretprobe:notify_change": {
        "description": "Modify attributes of a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},
{
    "kprobe:notify_change": {
        "description": "Modify attributes of a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},


{
    "kretprobe:generic_permission": {
        "description": "Check for access rights on a Posix-like filesystem",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [MAY_READ, MAY_WRITE, MAY_EXEC, MAY_NOT_BLOCK]"
        }
    }
},
{
    "kprobe:generic_permission": {
        "description": "Check for access rights on a Posix-like filesystem",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:do_inode_permission": {
        "description": "UNIX permission checking",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC]"
        }
    }
},
{
    "kprobe:do_inode_permission": {
        "description": "UNIX permission checking",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC]"
        }
    }
},
{
    "kretprobe:path_get": {
        "description": "Get a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_get": {
        "description": "Get a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:path_put": {
        "description": "Put a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_put": {
        "description": "Put a reference to a path",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount",
        "pre": {
            "path": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:lookup_one_qstr_excl": {
        "description": "Lookup a dentry with the given name in the base directory, excluding certain flags.",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "flags": "unsigned int",
            "base->d_inode": "!=null",
            "IS_DEADDIR(base->d_inode)": "==false",
            "lookup_dcache(name, base, flags)": "==null"
        },
        "post": {
            "return": "dentry",
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:lookup_one_qstr_excl": {
        "description": "Lookup a dentry with the given name and base directory, excluding certain flags.",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "flags": "!=null",
            "base->d_inode": "!=null",
            "IS_DEADDIR(base->d_inode)": "==false",
            "dentry": "==null"
        }
    }
},
{
    "kretprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        }
    }
},
{
    "kprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair.",
        "pre": {
            "filename": "!=null",
            "flags": "!=null",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        }
    }
},
{
    "kretprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair.",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair.",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:try_lookup_one_len": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:try_lookup_one_len": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:inode_lock_nested": {
        "description": "Lock the inode of the given dentry with the specified mutex.",
        "pre": {
            "p2->d_inode": "!=null",
            "I_MUTEX_PARENT": "!=null"
        }
    }
},
{
    "kprobe:inode_lock_nested": {
        "description": "Lock the inode of p2's dentry with I_MUTEX_PARENT.",
        "pre": {
            "p2->d_inode": "!=null",
            "I_MUTEX_PARENT": "!=null",
            "c1->d_parent": "==p2"
        }
    }
},
{
    "kretprobe:vfs_create": {
        "description": "Create a new file.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "want_excl": "!=null"
        }
    }
},
{
    "kprobe:vfs_create": {
        "description": "Create a new file.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null",
            "want_excl": "!=null"
        }
    }
},
{
    "kretprobe:kernel_tmpfile_open": {
        "description": "Open a tmpfile for kernel internal use",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "!=null",
            "open_flag": "!=null",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:kernel_tmpfile_open": {
        "description": "Open a tmpfile for kernel internal use",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "!=null",
            "open_flag": "!=null",
            "cred": "!=null"
        }
    }
},


{
    "kretprobe:vfs_mkdir": {
        "description": "Create a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:vfs_mkdir": {
        "description": "Create a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:vfs_rmdir": {
        "description": "Remove a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:vfs_rmdir": {
        "description": "Remove a directory.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:vfs_unlink": {
        "description": "Unlink a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "delegated_inode": "!=null",
            "dir->i_mutex": "held",
            "delegated_inode": "returns -EWOULDBLOCK if delegation is discovered",
            "delegated_inode": "returns reference to inode if delegation is discovered",
            "delegated_inode": "caller should break delegation and retry",
            "dir->i_mutex": "should be dropped before breaking delegation",
            "delegated_inode": "can be NULL for non-NFS exported filesystems",
            "idmap": "required if inode found through idmapped mount",
            "idmap": "used to map the inode according to idmap before checking permissions",
            "idmap": "pass nop_mnt_idmap for non-idmapped mounts or raw inode permission checking"
        }
    }
},
{
    "kprobe:vfs_unlink": {
        "description": "Unlink a filesystem object",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "delegated_inode": "!=null or ==null"
        }
    }
},
{
    "kretprobe:vfs_symlink": {
        "description": "Create a symlink.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null"
        }
    }
},
{
    "kprobe:vfs_symlink": {
        "description": "Create a symlink.",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null"
        }
    }
},
{
    "kretprobe:vfs_link": {
        "description": "Create a new link",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "!=null or ==null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:vfs_link": {
        "description": "create a new link",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "in [null, !=null]"
        }
    }
},


{
    "kretprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:vfs_get_link": {
        "description": "Get symlink body",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kprobe:vfs_get_link": {
        "description": "Get symlink body",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_create": {
        "description": "Create entry in cache",
        "pre": {
            "cache": "!=null",
            "mask": "!=null",
            "key": "!=null",
            "value": "!=null",
            "reusable": "in [true, false]"
        },
        "post": {
            "return": "in [-EBUSY, 0]"
        }
    }
},
{
    "kprobe:mb_cache_entry_create": {
        "description": "Create entry in cache",
        "pre": {
            "cache": "!=null",
            "mask": "!=null",
            "key": "!=null",
            "value": "!=null",
            "reusable": "in [true, false]"
        }
    }
},
{
    "kretprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_first": {
        "description": "Find the first reusable entry with the given key",
        "pre": {
            "cache": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_find_first": {
        "description": "Find the first reusable entry with the given key",
        "pre": {
            "cache": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_next": {
        "description": "Find next reusable entry with the same key",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_find_next": {
        "description": "Find next reusable entry with the same key",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key).",
        "pre": {
            "cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key).",
        "pre": {
            "cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:struct_mb_cache": {
        "description": "Used for deduplication of extended attribute blocks and xattr values stored in inodes.",
        "pre": {
            "entry": "!=null",
            "key": "!=null",
            "value": "!=null",
            "operation": "in [CREATE, REMOVE, SEARCH, DELETE]",
            "hash_table": "fixed-size"
        }
    }
},
{
    "kprobe:struct_mb_cache_create": {
        "description": "Create a new entry in the mb_cache.",
        "pre": {
            "mb_cache": "!=null"
        }
    },
    "kprobe:struct_mb_cache_remove": {
        "description": "Remove an entry from the mb_cache.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:struct_mb_cache_search": {
        "description": "Search for an entry in the mb_cache by key.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null"
        }
    },
    "kprobe:struct_mb_cache_delete_entry": {
        "description": "Delete an entry from the mb_cache with a given key-value pair.",
        "pre": {
            "mb_cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "pre": {
            "bucket_bits": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "pre": {
            "bucket_bits": ">=0"
        }
    }
},
{
    "kretprobe:mb_cache_destroy": {
        "description": "Destroy cache",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_destroy": {
        "description": "Destroy cache",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:seq_open": {
        "description": "Initialize sequential file",
        "pre": {
            "file": "!=null",
            "op": "!=null",
            "op->start": "!=null",
            "op->stop": "!=null",
            "op->next": "!=null",
            "op->show": "!=null",
            "op->start()": "returns !ERR_PTR",
            "op->next()": "returns !ERR_PTR",
            "op->show()": "returns >=0 or SEQ_SKIP",
            "@file->private_data": "unchanged"
        }
    }
},
{
    "kprobe:seq_open": {
        "description": "Initialize sequential file",
        "pre": {
            "file": "!=null",
            "op": "!=null",
            "op->start": "!=null",
            "op->stop": "!=null",
            "op->next": "!=null",
            "op->show": "!=null",
            "op->start()": "returns != ERR_PTR(error)",
            "op->next()": "returns != ERR_PTR(error)",
            "op->show()": "returns >= 0",
            "op->show()": "returns != SEQ_SKIP"
        }
    }
},
{
    "kretprobe:seq_read": {
        "description": "read() method for sequential files.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_read": {
        "description": "read() method for sequential files.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_read_iter": {
        "description": "Read data from a sequence file into a buffer.",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb.ki_pos": ">=0",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:seq_read_iter": {
        "description": "Read data from a sequential file into a buffer.",
        "pre": {
            "iocb": "!=null",
            "iocb.ki_pos": "any value",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:seq_lseek": {
        "description": "llseek() method for sequential files.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "whence": "in [0, 1]"
        }
    }
},
{
    "kprobe:seq_lseek": {
        "description": "llseek() method for sequential files.",
        "pre": {
            "file": "!=null",
            "whence": "in [0, 1]"
        }
    }
},
{
    "kretprobe:seq_release": {
        "description": "Free the structures associated with sequential file.",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:seq_release": {
        "description": "Free the structures associated with sequential file.",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kretprobe:seq_escape_mem": {
        "description": "Print data into buffer, escaping some characters",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_escape_mem": {
        "description": "Print data into buffer, escaping some characters",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:mangle_path": {
        "description": "Mangle and copy path to buffer",
        "pre": {
            "s": "!=null",
            "p": "!=null",
            "esc": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mangle_path": {
        "description": "Mangle and copy path to buffer",
        "pre": {
            "s": "!=null",
            "p": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_path": {
        "description": "seq_file interface to print a pathname",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_path": {
        "description": "seq_file interface to print a pathname",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_file_path": {
        "description": "Prints the absolute path of a file using the seq_file interface.",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_file_path": {
        "description": "Prints the absolute path of a file using the seq_file interface.",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf().",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "!=null",
            "width": ">=0"
        }
    }
},
{
    "kprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf().",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "!=null",
            "width": ">=0"
        }
    }
},
{
    "kretprobe:goto overflow;if (delimiter && delimiter[0])": {
        "description": "Conditional statement to check if delimiter is not null and delimiter[0] is not null.",
        "pre": {
            "delimiter": "!=null",
            "delimiter[0]": "!=null"
        }
    }
},

{
    "kretprobe:seq_write": {
        "description": "Write arbitrary data to buffer",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:seq_write": {
        "description": "Write arbitrary data to buffer.",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:seq_pad": {
        "description": "Write padding spaces to buffer",
        "pre": {
            "m": "!=null",
            "c": ">=0"
        }
    }
},
{
    "kprobe:seq_pad": {
        "description": "Write padding spaces to buffer",
        "pre": {
            "m": "!=null",
            "c": "is_char"
        }
    }
},
{
    "kretprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist.",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist.",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array.",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array.",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:f_setown": {
        "description": "Set the owner of a file to a specified process ID.",
        "pre": {
            "filp": "!=null",
            "pid": "!=null",
            "type": "in [PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID, PIDTYPE_TGID]",
            "force": "in [0, 1]",
            "arg": "!=null",
            "ret": "!=null",
            "who": "!=null",
            "type": "in [PIDTYPE_TGID, PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID]",
            "ret": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:if": {
        "description": "Condition for the 'if' statement in the function.",
        "pre": {
            "who": "== INT_MIN"
        }
    },
    "kprobe:return": {
        "description": "Condition for the 'return' statement in the function.",
        "pre": {
            "return": "== -EINVAL"
        }
    },
    "kprobe:type": {
        "description": "Condition for the 'type' assignment in the function.",
        "pre": {
            "type": "== PIDTYPE_PGID"
        }
    },
    "kprobe:who": {
        "description": "Condition for the 'who' assignment in the function.",
        "pre": {
            "who": "== -who"
        }
    },
    "kprobe:rcu_read_lock": {
        "description": "Condition for the 'rcu_read_lock' function call in the function.",
        "pre": {
            "rcu_read_lock": "()"
        }
    },
    "kprobe:if_2": {
        "description": "Condition for the second 'if' statement in the function.",
        "pre": {
            "who": "!= 0"
        }
    }
},
{
    "kretprobe:fasync_helper": {
        "description": "Used by almost all character device drivers to set up the fasync queue, and for regular files by the file lease code.",
        "pre": {
            "fd": "!=null",
            "filp": "!=null",
            "on": "!=null",
            "fapp": "!=null"
        },
        "post": {
            "return_value": "<=0"
        }
    }
},
{
    "kprobe:fasync_helper": {
        "description": "Used by character device drivers and file lease code to set up the fasync queue.",
        "pre": {
            "fd": "!=null",
            "filp": "!=null",
            "on": "!=null",
            "fapp": "!=null"
        }
    }
},
{
    "kretprobe:kill_fasync": {
        "description": "Kill the fasync_struct by sending a signal.",
        "pre": {
            "fa": "!=null",
            "sig": "!=SIGURG",
            "fown->signum": "!=0"
        }
    }
},
{
    "kill_fasync": {
        "pre": {
            "sig": "!= SIGURG",
            "fown->signum": "!= 0"
        },
        "post": {
            "send_sigio(fown, fa->fa_fd, band)": "called",
            "read_unlock_irqrestore(&fa->fa_lock, flags)": "called",
            "fa = rcu_dereference(fa->fa_next)": "called"
        }
    }
},
{
    "kretprobe:deactivate_locked_super": {
        "description": "Drops an active reference to superblock, converting it into a temporary one if there is no other active references left.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_locked_super": {
        "description": "Drop an active reference to superblock.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:deactivate_super": {
        "description": "Drop an active reference to superblock",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_super": {
        "description": "Drop an active reference to superblock",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:retire_super": {
        "description": "Retire the superblock and mark it for re-use.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:retire_super": {
        "description": "Retire the superblock and mark it for re-use.",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:sget_fc": {
        "description": "Find or create a superblock",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kprobe:sget_fc": {
        "description": "Find or create a superblock",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},


{
    "kretprobe:iterate_supers_type": {
        "description": "Call function for superblocks of given type",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:iterate_supers_type": {
        "description": "Call function for superblocks of given type",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one.",
        "pre": {
            "p": "!=null"
        },
        "post": {
            "return": "in [0, -EMFILE, -ENOMEM]"
        }
    }
},
{
    "kprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one.",
        "pre": {
            "p": "!=null"
        },
        "context": "Any context. Frequently called while holding sb_lock.",
        "return": {
            "success": "0",
            "failure": {
                "-EMFILE": "if there are no anonymous bdevs left",
                "-ENOMEM": "if memory allocation failed"
            }
        }
    }
},
{
    "kretprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "kprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "mount_bdev": {
        "pre": {
            "mutex_lock": "bd_fsfreeze_mutex",
            "bd_fsfreeze_count": "> 0"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Lock the specified mutex.",
        "pre": {
            "mutex": "!=null",
            "mutex->count": "> 0",
            "bdev": "!=null",
            "bdev->bd_fsfreeze_count": "> 0"
        }
    }
},
{
    "kretprobe:compare_single": {
        "description": "mount_single(), then a chunk of this can be removed. [Bollocks -- AV] Better yet, reconfiguration shouldn't happen, but rather the second mount should be rejected if the parameters are not compatible.",
        "pre": {
            "s->s_root": "!=null",
            "flags": "!=null",
            "MS_RMT_MASK": "!=null",
            "fc": "!=null",
            "data": "!=null",
            "ret": "!=null",
            "s": "!=null",
            "p": "!=null"
        },
        "post": {}
    }
},

{
    "kretprobe:vfs_get_tree": {
        "description": "Get the mountable root",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_get_tree": {
        "description": "Get the mountable root",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state.",
        "pre": {
            "sb": "!=null",
            "sb->s_writers.frozen": "in [SB_UNFROZEN, SB_FREEZE_WRITE, SB_FREEZE_PAGEFAULT, SB_FREEZE_F SB_FREEZE_COMPLETE]"
        }
    }
},
{
    "kprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state.",
        "pre": {
            "sb": "!=null",
            "sb->s_writers.frozen": "in [SB_UNFROZEN, SB_FREEZE_WRITE, SB_FREEZE_PAGEFAULT, SB_FREEZE_F SB_FREEZE_COMPLETE]"
        }
    }
},
{
    "kretprobe:super_cache_scan": {
        "description": "Function for scanning the super cache.",
        "pre": {
            "shrink": "!=null",
            "sc": "!=null"
        }
    }
},
{
    "kprobe:super_cache_scan": {
        "description": "Scan the superblock cache and perform shrinking operations.",
        "pre": {
            "shrink": "!=null",
            "sc": "!=null",
            "sb": "!=null",
            "super_blocks": "is a list",
            "sb_lock": "is a spinlock",
            "sb_writers_name": "is an array",
            "shrinker_rwsem": "is a semaphore"
        }
    }
},
{
    "kretprobe:__mnt_want_write_file": {
        "description": "Check if the __mnt_want_write_file function returns a non-zero value, indicating a successful write operation.",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kprobe:__mnt_want_write_file": {
        "description": "Helper function to indicate if the file should be writable.",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kretprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:return -1;}/* call under rcu_read_lock": {
        "description": "Call under rcu_read_lock",
        "pre": {
            "bastard": "!=null",
            "mnt": "!=null",
            "mount_lock": "unknown",
            "seq": "unknown",
            "bastard->mnt_flags & MNT_SYNC_UMOUNT": "unknown",
            "bastard->mnt_flags & MNT_DOOMED": "unknown"
        }
    }
},
{
    "kprobe:return -1;}/* call under rcu_read_lock ": {
        "description": "Helper function for mntput_no_expire().",
        "pre": {
            "read_seqretry(&mount_lock, seq)": "false",
            "bastard->mnt_flags & MNT_SYNC_UMOUNT": "false",
            "bastard->mnt_flags & MNT_DOOMED": "false"
        }
    }
},


{
    "kretprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace.",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace.",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        }
    }
},
{
    "kprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        }
    }
},
{
    "kretprobe:s = path.mnt->mnt_sb;atomic_inc(&s->s_active);mntput(path.mnt);/* lock the sucker `": {
        "description": "Lock the super block and increment the active count.",
        "pre": {
            "path.mnt": "!=null",
            "path.mnt->mnt_sb": "!=null",
            "s": "!=null",
            "s->s_active": "!=null"
        }
    }
},
{
    "kprobe:s = path.mnt->mnt_sb;atomic_inc(&s->s_active);mntput(path.mnt);/* lock the sucker `": {
        "description": "Increment the reference count of the superblock associated with the given mount point.",
        "pre": {
            "path.mnt": "!=null",
            "name": "!=null"
        }
    }
},


{
    "kretprobe:fscache_end_volume_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "volume": "!=null",
            "cookie": "!=null",
            "why": "in [fscache_access_unlive]"
        }
    }
},
{
    "kprobe:fscache_end_volume_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "volume": "!=null",
            "cookie": "!=null",
            "why": "in [fscache_access_unlive]"
        }
    }
},
{
    "kretprobe:fscache_withdraw_volume": {
        "description": "Withdraw a volume from being cached",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_volume": {
        "description": "Withdraw a volume from being cached",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kretprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_ACCESS_TRACE_READ, FSCACHE_ACCESS_TRACE_WRITE, FSCACHE_ACCESS_TRACE_TRUNCATE, FSCACHE_ACCESS_TRACE_OTHER]"
        }
    }
},
{
    "kprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access.",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_ACCESS_TRACE_READ, FSCACHE_ACCESS_TRACE_WRITE, FSCACHE_ACCESS_TRACE_TRUNCATE, FSCACHE_ACCESS_TRACE_OTHER]"
        }
    }
},
{
    "kretprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:__fscache_use_cookie": {
        "description": "__fscache_use_cookie function",
        "pre": {
            "cookie": "!=null",
            "will_modify": "bool"
        }
    }
},
{
    "kprobe:__fscache_use_cookie": {
        "description": "__fscache_use_cookie function",
        "pre": {
            "cookie": "!=null",
            "will_modify": "bool"
        }
    }
},
{
    "kretprobe:atomic_fetch_add_unless": {
        "description": "Atomically fetches the value at the address of cookie->n_active, adds -1 to it, and stores the result back. If the original value is not 1, the condition is satisfied.",
        "pre": {
            "cookie->n_active": "!=null",
            "cookie->n_active": "is_integer",
            "cookie->n_active": "!=1"
        }
    }
},
{
    "kprobe:atomic_fetch_add_unless": {
        "description": "Atomically fetches the value at the memory location specified by &cookie->n_active, adds -1 to it, and stores the result back to the same memory location, unless the original value was 1.",
        "pre": {
            "&cookie->n_active": "!=null",
            "-1": "!=null",
            "1": "!=null",
            "c": "!=null",
            "c": "!=1"
        }
    }
},
{
    "kretprobe:fscache_begin_lookup": {
        "description": "Begin the process of looking up a cookie. We offload the actual process to a worker thread.",
        "pre": {
            "cookie": "!=null",
            "cookie->volume": "!=null",
            "trace": "!=null"
        }
    }
},

{
    "kretprobe:fscache_init_access_gate": {
        "description": "Initializes the access gate on a cookie by setting a flag to prevent the state machine from being queued when the access counter transitions to 0.",
        "pre": {
            "cookie": "!=null",
            "where": "!=null"
        }
    }
},

{
    "kretprobe:__fscache_invalidate": {
        "description": "Invalidate a fscache cookie",
        "pre": {
            "cookie": "!=null",
            "aux_data": "!=null",
            "new_size": ">=0",
            "flags": "unsigned int",
            "FSCACHE_COOKIE_RELINQUISHED": "!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)",
            "FSCACHE_INVAL_DIO_WRITE": "!(flags & FSCACHE_INVAL_DIO_WRITE) || !test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags)",
            "FSCACHE_COOKIE_NO_DATA_TO_READ": "set_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags)",
            "cookie->inval_counter": "++",
            "cookie->state": "in [FSCACHE_COOKIE_STATE_INVALIDATING, FSCACHE_COOKIE_STATE_LOOKING_UP, FSCACHE_COOKIE_STATE_CREATING, FSCACHE_COOKIE_STATE_ACTIVE]",
            "is_caching": "fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie)",
            "__fscache_set_cookie_state": "if (is_caching) __fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING)",
            "wake_up_cookie_state": "wake_up_cookie_state(cookie)",
            "fscache_queue_cookie": "if (is_caching) fscache_queue_cookie(cookie, fscache_cookie_get_inval_work)"
        }
    }
},

{
    "kretprobe:fscache_wait_for_operation": {
        "description": "Wait for an object to become accessible",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_UNAVAILABLE, FSCACHE_WANT_AVAILABLE]"
        }
    }
},
{
    "kprobe:fscache_wait_for_operation": {
        "description": "Wait for an object to become accessible",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_UNAVAILABLE, FSCACHE_WANT_AVAILABLE, FSCACHE_WANT_COMPLETE]"
        }
    }
},
{
    "kretprobe:fscache_dirty_folio": {
        "description": "Mark folio dirty and pin a cache object for writeback",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:fscache_dirty_folio": {
        "description": "Mark folio dirty and pin a cache object for writeback",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kretprobe:iov_iter_xarray": {
        "description": "Perform an operation on the iov_iter using the xarray.",
        "pre": {
            "iter": "!=null",
            "source": "ITER_SOURCE",
            "mapping->i_pages": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    },
    "kretprobe:fscache_write": {
        "description": "Write data to the fscache.",
        "pre": {
            "cres": "!=null",
            "start": "!=null",
            "&iter": "!=null",
            "fscache_wreq_done": "!=null",
            "wreq": "!=null"
        }
    },
    "kretprobe:abandon_end": {
        "description": "Handle the abandon end case.",
        "pre": {
            "wreq": "!=null",
            "ret": "!=null",
            "false": "!=null"
        }
    },
    "kretprobe:abandon_free": {
        "description": "Free resources in the abandon case.",
        "pre": {
            "wreq": "!=null"
        }
    },
    "kretprobe:abandon": {
        "description": "Handle the abandon case.",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "len": "!=null",
            "cond": "!=null"
        }
    },
    "kretprobe:if (term_func)term_func(term_func_priv, ret, false);}EXPORT_SYMBOL(__fscache_write_to_cache": {
        "description": "Call the term_func if it exists.",
        "pre": {
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "ret": "!=null",
            "false": "!=null"
        }
    }
},
{
    "kprobe:__fscache_write_to_cache": {
        "description": "Write data to the cache",
        "pre": {
            "cookie": "!=null",
            "mapping": "!=null",
            "start": ">=0",
            "len": ">=0",
            "i_size": ">=0",
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "cond": "boolean"
        }
    }
},


{
    "kretprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_add_cache": {
        "description": "Declare a cache as being open for business",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "!=null"
        }
    }
},
{
    "kprobe:fscache_add_cache": {
        "description": "Declare a cache as being open for business",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "!=null"
        }
    }
},
{
    "kretprobe:fscache_io_error": {
        "description": "Note a cache IO error",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_io_error": {
        "description": "Note a cache IO error",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_withdraw_cache": {
        "description": "Withdraw a cache from the active service",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_cache": {
        "description": "Withdraw a cache from the active service",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a bio",
        "pre": {
            "bio": "!=null",
            "bio->bi_size": ">0",
            "bio->bi_end_io": "!=null",
            "bio->bi_status": "not in [EIO, EAGAIN, EINTR]",
            "bio->bi_rw": "==READ",
            "bio->bi_io_vec": "!=null",
            "bio->bi_io_vec->bv_len": ">0",
            "bio->bi_io_vec->bv_page": "!=null",
            "bio->bi_io_vec->bv_page->mapping": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb->s_cop": "!=null",
            "bio->bi_io_vec->bv_page->mapping->host->i_sb->s_cop->s_cop_decrypt_bio": "!=null"
        },
        "post": {
            "return": "==true",
            "bio->bi_status": "==0"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a bio",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:bio_alloc": {
        "description": "Allocate a bio structure for I/O operations.",
        "pre": {
            "inode": "!=null",
            "inode->i_sb->s_bdev": "!=null",
            "BIO_MAX_VECS": "!=null",
            "REQ_OP_WRITE": "!=null",
            "GFP_NOFS": "!=null",
            "len": "!=null"
        }
    },
    "kretprobe:fscrypt_zeroout_range_inline_crypt": {
        "description": "Zero out a range of blocks for inline encryption.",
        "pre": {
            "inode": "!=null",
            "lblk": "!=null",
            "pblk": "!=null",
            "len": "!=null",
            "blockbits": "!=null",
            "blocks_per_page": "!=null",
            "bio": "!=null",
            "ret": "!=null",
            "err": "!=null",
            "num_pages": "!=null"
        }
    }
},

{
    "kretprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_free_inode": {
        "description": "Free an inode's fscrypt data requiring RCU delay",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_free_inode": {
        "description": "Free an inode's fscrypt data requiring RCU delay",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_ioctl_set_policy": {
        "description": "Set the policy for fscrypt using ioctl.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "policy.version": "!=null",
            "size": ">0",
            "inode": "!=null",
            "nop_mnt_idmap": "!=null",
            "ret": "!=null",
            "existing_policy": "!=null"
        },
        "post": {
            "ret": "in [-EFAULT, -EACCE -ENODATA]"
        }
    }
},
{
    "kprobe:fscrypt_ioctl_set_policy": {
        "description": "Set the policy for fscrypt ioctl.",
        "pre": {
            "filp": "!=null",
            "arg": "!=null",
            "policy.version": "!=null",
            "size": ">0",
            "inode": "!=null",
            "ret": "!=null",
            "existing_policy": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_has_permitted_context": {
        "description": "Check if a file's encryption policy is permitted within its directory.",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_has_permitted_context": {
        "description": "Check if a file's encryption policy is permitted within its directory.",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        }
    }
},
{
    "kretprobe:fname_decrypt": {
        "description": "Decrypts the filename",
        "pre": {
            "inode": "!=null",
            "iname": "!=null",
            "oname": "!=null"
        },
        "post": {
            "return_value": "in [0, -errno]"
        }
    }
},

{
    "kretprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer for presented filenames",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer for presented filenames",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form",
        "pre": {
            "inode": "!=null",
            "hash": "optional",
            "minor_hash": "optional",
            "iname": "!=null",
            "oname": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form.",
        "pre": {
            "inode": "!=null",
            "hash": ">=0",
            "minor_hash": ">=0",
            "iname": "!=null",
            "oname": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        }
    }
},


{
    "kretprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0",
            "gfp_flags": "valid memory allocation flags"
        }
    }
},
{
    "kprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0",
            "gfp_flags": "valid memory allocation flags"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio",
        "pre": {
            "folio": "!=null",
            "len": "!=null",
            "offs": "!=null",
            "len": "multiple of filesystem's block size",
            "offs": "multiple of filesystem's block size"
        },
        "post": {
            "return value": "0 on success; -errno on failure"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio",
        "pre": {
            "folio": "!=null",
            "len": "!=null",
            "offs": "!=null",
            "len": "% filesystem_block_size == 0",
            "offs": "% filesystem_block_size == 0"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a filesystem block in-place",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">= 0",
            "lblk_num": ">= 0"
        }
    }
},


{
    "kretprobe:o2quo_disk_timeout": {
        "description": "Post condition for o2quo_disk_timeout()",
        "post": {
            "return_value": "(failed << 1) < quorum"
        }
    }
},
{
    "kprobe:o2hb_arm_timeout": {
        "description": "Arm the timeout for the o2hb region.",
        "pre": {
            "failed": "<< 1 < quorum",
            "quorum": "!= null"
        }
    }
},




{
    "kretprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        }
    }
},
{
    "kretprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        }
    }
},
{
    "kprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group.",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        }
    }
},
{
    "kretprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group.",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:config_item_set_name": {
        "description": "Set the name of an item",
        "pre": {
            "item": "!=null",
            "fmt": "!=null",
            "name": "!=null",
            "strlen(name)": "< CONFIGFS_ITEM_NAME_LEN",
            "item->ci_name": "points to dynamically allocated string if strlen(name) >= CONFIGFS_ITEM_NAME_LEN",
            "item->ci_namebuf": "points to static array if strlen(name) < CONFIGFS_ITEM_NAME_LEN"
        }
    }
},
{
    "kprobe:config_item_set_name": {
        "description": "Set the name of an item.",
        "pre": {
            "item": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:config_item_put": {
        "description": "Decrement the refcount, and if 0, call config_item_cleanup().",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kprobe:config_item_put": {
        "description": "Decrement refcount for item and call config_item_cleanup if 0.",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kretprobe:config_group_find_item": {
        "description": "Search for an item in a group.",
        "pre": {
            "group": "!=null",
            "name": "!=null",
            "group->cg_list": "!=null",
            "group->cg_subsys->su_mtx": "locked"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:config_group_find_item": {
        "description": "Search for an item in a group.",
        "pre": {
            "group": "!=null",
            "name": "!=null",
            "group->cg_list": "!=null",
            "group->cg_subsys->su_mtx": "locked"
        }
    }
},
{
    "kretprobe:netfs_readahead": {
        "description": "Helper to manage a read request",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kprobe:netfs_readahead": {
        "description": "Helper to manage a read request",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kretprobe:netfs_read_folio": {
        "description": "Helper to manage a read_folio request",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:netfs_read_folio": {
        "description": "Helper to manage a read_folio request",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:netfs_write_begin": {
        "description": "Helper to prepare for writing",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},
{
    "kprobe:netfs_write_begin": {
        "description": "Helper to prepare for writing",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},


{
    "kretprobe:jbd2_journal_start": {
        "description": "Return a pointer to a newly allocated handle, or an ERR_PTR() value on failure.",
        "pre": {
            "journal": "!=null",
            "nblocks": ">=0"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_start": {
        "description": "Start a journal transaction in the jbd2 filesystem journaling layer.",
        "pre": {
            "journal": "!=null",
            "nblocks": ">=0"
        }
    }
},
{
    "kretprobe:jbd2_journal_free_reserved": {
        "description": "Free the reserved handle in the jbd2 journal.",
        "pre": {
            "handle": {
                "type": "handle_t"
            },
            "journal": {
                "type": "journal_t",
                "value": "handle->h_journal"
            },
            "journal->j_state_lock": "locked with read_lock()",
            "journal->j_running_transaction": "exists and pinned by acquiring j_state_lock",
            "journal->j_state_lock": "unlocked with read_unlock()",
            "handle": "freed with jbd2_free_handle()"
        }
    }
},
{
    "kprobe:jbd2_journal_free_reserved": {
        "description": "Free the reserved journal handle.",
        "pre": {
            "handle": "!=null",
            "handle->h_journal": "!=null",
            "handle->h_journal->j_state_lock": "locked",
            "handle->h_journal->j_running_transaction": "exists"
        }
    }
},
{
    "kretprobe:jbd2__journal_restart": {
        "description": "Commit the handle's transaction and reattach to a new transaction with requested number of credits.",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:jbd2__journal_restart": {
        "description": "Commit the handle's transaction and reattach it to a new transaction with the requested number of credits.",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:jbd2_trans_will_send_data_barrier": {
        "description": "Check if the transaction will send a data barrier.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "ret": "==0",
            "commit_trans": "!=null",
            "journal->j_flags": "& JBD2_BARRIER",
            "journal->j_state_lock": "read_locked"
        }
    }
},
{
    "kprobe:jbd2_trans_will_send_data_barrier": {
        "description": "Check if the transaction will send a data barrier in the journal.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "journal->j_flags": "& JBD2_BARRIER != 0",
            "commit_trans": "!=null",
            "commit_trans->t_tid": "== tid"
        }
    }
},
{
    "kretprobe:jbd2_fc_begin_commit": {
        "description": "Begin a fast commit in the journal.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null",
            "is_journal_aborted(journal)": "==false",
            "j_commit_sequence": "<= tid",
            "j_stats.ts_tid": "==0"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},

{
    "kretprobe:jbd2_transaction_committed": {
        "description": "Check if a transaction with the given tid has already committed.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kprobe:jbd2_transaction_committed": {
        "description": "Check if the transaction with the given tid has already been committed.",
        "pre": {
            "journal": "!=null",
            "tid": "!=null"
        }
    }
},




{
    "kretprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal.",
        "pre": {
            "journal": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal.",
        "pre": {
            "journal": "!=null"
        }
    }
},
{
    "kretprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock",
        "pre": {
            "journal": "!=null",
            "compat": "!=null",
            "ro": "!=null",
            "incompat": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock",
        "pre": {
            "journal": "!=null",
            "compat": "!=null",
            "ro": "!=null",
            "incompat": "!=null"
        }
    }
},

{
    "kprobe:/* * Give a buffer_head a journal_head. * * May sleep. */": {
        "description": "Attach a journal_head to a buffer_head and manage references.",
        "pre": {
            "bh": "!=null",
            "jh": "!=null",
            "b_jcount": ">=0",
            "b_transaction": "!=null"
        },
        "post": {
            "bh": "!=null",
            "jh": "!=null",
            "b_jcount": ">=0",
            "b_transaction": "!=null"
        }
    }
},
{
    "kretprobe:proc_symlink": {
        "description": "Create a symbolic link in the proc file system.",
        "pre": {
            "parent": "!=null",
            "name": "!=null",
            "mode": "!=null",
            "nlink": "!=null"
        }
    }
},
{
    "kprobe:proc_symlink": {
        "description": "Create a symbolic link in the proc filesystem.",
        "pre": {
            "parent": "!=null",
            "name": "!=null",
            "mode": "!=null",
            "nlink": "!=null"
        }
    }
},
{
    "kretprobe:__xlate_proc_name": {
        "description": "This function parses a name such as 'ttydriverserial', and returns the struct proc_dir_entry for 'procttydriver', and returns 'serial' in residual.",
        "pre": {
            "name": "!=null",
            "ret": "!=null",
            "residual": "!=null"
        }
    }
},
{
    "kprobe:__xlate_proc_name": {
        "description": "Translate a name to a proc_dir_entry and residual name.",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:register_sysctl": {
        "description": "Register a sysctl table.",
        "pre": {
            "path": "!=null",
            "table": "!=null",
            "table_is_filled": "true",
            "table_termination": "true"
        }
    }
},
{
    "kprobe:register_sysctl": {
        "description": "Register a sysctl table.",
        "pre": {
            "path": "!=null",
            "table": "!=null"
        }
    }
},
{
    "kretprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kretprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem",
        "pre": {
            "name": "!=null",
            "parent": "!=null",
            "parent_type": "==dentry",
            "f": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem",
        "pre": {
            "name": "!=null",
            "parent": "is_directory(parent) || parent == null",
            "f": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:continue;}if (inlen <= 0)break;v = get_utf16(*pwc endian);if ((v & SURROGATE_MASK) != SURROGATE_PAIR ||!(v & SURROGATE_LOW))": {
        "description": "Helper function to convert UTF-16 characters to UTF-8 characters.",
        "pre": {
            "pwcs": "!=null",
            "inlen": "<= 0",
            "endian": "in [utf16_endian]",
            "s": "!=null",
            "maxout": "!=null"
        }
    }
},
{
    "kprobe:continue;}if (inlen <= 0)break;v = get_utf16(*pwc endian);if ((v & SURROGATE_MASK) != SURROGATE_PAIR ||!(v & SURROGATE_LOW))": {
        "description": "Helper function to convert UTF-16 characters to UTF-8 characters.",
        "pre": {
            "pwcs": "!=null",
            "inlen": "<= 0",
            "endian": "in [utf16_endian]",
            "s": "!=null",
            "maxout": "!=null"
        }
    }
},


{
    "kretprobe:qid_eq": {
        "description": "Test to see if two kqid values are the same.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kprobe:qid_eq": {
        "description": "Test to see if two kqid values are the same.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kretprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another.",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        }
    }
},
{
    "kretprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kretprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair.",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        }
    }
},
{
    "kretprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid.",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid.",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kretprobe:if (!dquot->dq_off)": {
        "description": "Check if the value of dq_off is zero.",
        "pre": {
            "dquot": {
                "dq_off": "==0"
            }
        }
    }
},
{
    "kprobe:if (!dquot->dq_off)": {
        "description": "Condition for the if statement: if (!dquot->dq_off)",
        "pre": {
            "dquot": {
                "dq_off": "==0"
            }
        }
    }
},
{
    "kretprobe:qtree_delete_dquot": {
        "description": "Delete a dquot from the qtree.",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "tmp": "not in [QT_TREEOFF]",
            "dquot->dq_off": "==0"
        }
    }
},
{
    "kprobe:return 0;return remove_tree(info, dquot, &tmp, 0);}EXPORT_SYMBOL(qtree_delete_dquot": {
        "description": "Delete a dquot from the qtree.",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "dquot->dq_off": "==0"
        }
    }
},
{
    "kretprobe:if (!sb_dqopt(dquot->dq_sb)->files[type])": {
        "description": "Check if the files array at index 'type' is null",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_sb": "!=null",
            "sb_dqopt(dquot->dq_sb)": "!=null",
            "sb_dqopt(dquot->dq_sb)->files[type]": "==null"
        }
    }
},
{
    "if (!sb_dqopt(dquot->dq_sb)->files[type])": {
        "description": "Check if a specific file type is present in the files array of the sb_dqopt structure.",
        "pre": {
            "dquot": "!= null",
            "dquot->dq_sb": "!= null",
            "sb_dqopt(dquot->dq_sb)->files[type]": "== null"
        }
    }
},
{
    "kretprobe:DEFINE_SPINLOCK": {
        "description": "Defines a spinlock for protecting the specified resource.",
        "pre": {
            "spinlock_name": "dq_data_lock",
            "ordering": "dq_data_lock > dq_list_lock > i_lock > dquot->dq_dqb_lock",
            "flags": "S_NOQUOTA is not set"
        }
    },
    "kretprobe:EXPORT_SYMBOL": {
        "description": "Exports the specified symbol.",
        "pre": {
            "symbol_name": "dq_data_lock"
        }
    }
},

{
    "kretprobe:static LIST_HEAD(inuse_list);static LIST_HEAD(free_dquots);static unsigned int dq_hash_bit dq_hash_mask;static struct hlist_head *dquot_hash;struct dqstats dqstats;EXPORT_SYMBOL(dqstats)": {
        "description": "dqstats.free_dquots gives the number of dquots on the list. When dquot is invalidated it's completely released from memory. Dirty dquots are added to the dqi_dirty_list of quota_info when mark dirtied, and this list is searched when writing dirty dquots back to quota file. Note that some filesystems do dirty dquot tracking on their own (e.g. in a journal) and thus don't use dqi_dirty_list. Dquots with a specific identity (device, type and id) are placed on one of the dquot_hash[] hash chains. The provides an efficient search mechanism to locate a specific dquot.",
        "pre": {
            "dqstats.free_dquots": "!=null",
            "dquot": "invalidated => released from memory",
            "dquots": "dirty => added to dqi_dirty_list of quota_info",
            "dquots": "dirty => searched when writing dirty dquots back to quota file",
            "filesystems": "do dirty dquot tracking on their own (e.g. in a journal) => don't use dqi_dirty_list",
            "dquots": "specific identity (device, type, id) => placed on dquot_hash[] hash chains"
        }
    }
},
{
    "kprobe:static LIST_HEAD(inuse_list);static LIST_HEAD(free_dquots);static unsigned int dq_hash_bit dq_hash_mask;static struct hlist_head *dquot_hash;struct dqstats dqstats;EXPORT_SYMBOL(dqstats)": {
        "description": "dqstats.free_dquots gives the number of dquots on the list. When dquot is invalidated it's completely released from memory. Dirty dquots are added to the dqi_dirty_list of quota_info when mark dirtied, and this list is searched when writing dirty dquots back to quota file. Note that some filesystems do dirty dquot tracking on their own (e.g. in a journal) and thus don't use dqi_dirty_list. Dquots with a specific identity (device, type and id) are placed on one of the dquot_hash[] hash chains. The provides an efficient search mechanism to locate a specific dquot.",
        "pre": {
            "inuse_list": "!=null",
            "free_dquots": "!=null",
            "dq_hash_bits": "!=null",
            "dq_hash_mask": "!=null",
            "dquot_hash": "!=null",
            "dqstats": "!=null"
        }
    }
},
{
    "kretprobe:dquot_mark_dquot_dirty": {
        "description": "Mark the dquot as dirty.",
        "pre": {
            "dquot": "!=null",
            "ret": "==1",
            "DQ_ACTIVE_B": "is set in dquot->dq_flags",
            "DQUOT_NOLIST_DIRTY": "is not set in sb_dqopt(dquot->dq_sb)->flags"
        },
        "post": {
            "DQ_MOD_B": "is set in dquot->dq_flags"
        }
    }
},
{
    "kprobe:if (test_bit(DQ_MOD_B, &dquot->dq_flags))return 1;spin_lock(&dq_list_lock);if (!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags))": {
        "description": "Check if the DQ_MOD_B bit is set in the dq_flags of the dquot structure. If it is set, return 1. Otherwise, acquire the dq_list_lock spin lock and set the DQ_MOD_B bit in the dq_flags.",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_flags": "!=null",
            "test_bit(DQ_MOD_B, &dquot->dq_flags)": "==1",
            "!test_and_set_bit(DQ_MOD_B, &dquot->dq_flags)": "==1"
        }
    }
},
{
    "kretprobe:smp_mb__before_atomic": {
        "description": "Ensure that flags update is visible after dquot has been filled.",
        "pre": {
            "dquot": "!=null",
            "dq_flags": "!=null",
            "DQ_READ_B": "in [0, 1]"
        }
    },
    "kretprobe:set_bit": {
        "description": "Instantiate dquot if needed.",
        "pre": {
            "DQ_READ_B": "in [0, 1]",
            "dquot": "!=null",
            "&dquot->dq_flags": "!=null"
        }
    }
},
{
    "kprobe:smp_mb__before_atomic": {
        "description": "Ensure memory ordering before setting the bit DQ_READ_B in the dq_flags of the dquot structure.",
        "pre": {
            "dquot": "!=null",
            "dquot->dq_flags": "!=null",
            "DQ_READ_B": "!=null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the specified bit in the given memory location.",
        "pre": {
            "bit": "!=null",
            "memory_location": "!=null"
        }
    }
},
{
    "kretprobe:dquot_commit": {
        "description": "Commit the dquot structure",
        "pre": {
            "dquot": "!=null",
            "ret": "int",
            "memalloc": "unsigned int",
            "dqopt": "struct quota_info",
            "dqopt->dq_sb": "!=null",
            "dquot->dq_lock": "mutex",
            "memalloc_nofs_save": "function",
            "clear_dquot_dirty": "function"
        },
        "post": {
            "ret": "int",
            "memalloc": "unsigned int",
            "dqopt": "struct quota_info",
            "dqopt->dq_sb": "!=null",
            "dquot->dq_lock": "mutex",
            "memalloc_nofs_save": "function",
            "clear_dquot_dirty": "function"
        }
    }
},



{
    "kretprobe:dquot_scan_active": {
        "description": "Scan active dquot and increase use count",
        "pre": {
            "sb": "!=null",
            "fn": "!=null",
            "priv": "!=null",
            "dquot": "!=null",
            "old_dquot": "!=null",
            "ret": "0",
            "sb->s_umount": "locked",
            "dq_list_lock": "locked",
            "dquot->dq_flags": "has DQ_ACTIVE_B bit set",
            "dquot->dq_sb": "same as sb"
        },
        "post": {
            "old_dquot": "updated to dquot"
        }
    }
},
{
    "kprobe:atomic_inc(&dquot->dq_count);spin_unlock(&dq_list_lock);dqput(old_dquot);old_dquot = dquot;/* * ->release_dquot() can be racing with us. Our reference * protects us from new calls to it so just wait for any * outstanding call and recheck the DQ_ACTIVE_B after that. `": {
        "description": "Increase the use count of dquot and release dq_list_lock.",
        "pre": {
            "dquot": "!=null",
            "dq_count": "!=null",
            "dq_list_lock": "!=null",
            "old_dquot": "!=null",
            "dq_flags": "has bit DQ_ACTIVE_B set",
            "dq_sb": "== sb"
        }
    }
},

{
    "kprobe:list_replace_init": {
        "description": "Replace the list `dqopt->info[cnt].dqi_dirty_list` with the list `dirty`.",
        "pre": {
            "dqopt->info[cnt].dqi_dirty_list": "!=null",
            "dirty": "!=null"
        }
    },
    "kprobe:list_empty": {
        "description": "Check if the list `dirty` is empty.",
        "pre": {
            "dirty": "!=null",
            "!list_empty(&dirty)": "true"
        }
    }
},
{
    "kretprobe:if (sb->s_op->sync_fs)": {
        "description": "Check if the `sync_fs` function pointer is not null.",
        "pre": {
            "sb": "!=null",
            "sb->s_op": "!=null",
            "sb->s_op->sync_fs": "!=null"
        }
    }
},
{
    "kprobe:if (sb->s_op->sync_fs)": {
        "description": "Check if the `sync_fs` function is called for the given `sb`.",
        "pre": {
            "sb": "!=null",
            "sb->s_op": "!=null",
            "sb->s_op->sync_fs": "!=null"
        }
    }
},


{
    "kretprobe:insert_dquot_hash": {
        "description": "Insert a dquot into the hash table.",
        "pre": {
            "dquot": "!=null"
        }
    }
},
{
    "kprobe:insert_dquot_hash": {
        "description": "Insert a dquot into the hash table.",
        "pre": {
            "dquot": "!=null"
        }
    }
},
{
    "kretprobe:dquot_drop": {
        "description": "Drop the dquot structures associated with the given inode.",
        "pre": {
            "inode": "!=null",
            "dquots": "!=null",
            "cnt": ">=0",
            "cnt": "<MAXQUOTAS"
        }
    }
},
{
    "kprobe:dquot_drop": {
        "description": "Drop the dquot associated with the inode.",
        "pre": {
            "inode": "!=null",
            "dquots": "!=null",
            "cnt": ">=0",
            "cnt": "<MAXQUOTAS",
            "put": "!=null",
            "dq_data_lock": "locked",
            "IS_NOQUOTA(inode)": "false"
        }
    }
},
{
    "kretprobe:for (cnt--; cnt >= 0; cnt--)": {
        "description": "Decrement cnt and loop while cnt is greater than or equal to 0.",
        "pre": {
            "cnt": ">= 0"
        }
    }
},
{
    "kprobe:__dquot_alloc_space": {
        "description": "Allocate space for dquot",
        "pre": {
            "inode": "!=null",
            "number": "!=null",
            "flags": "in [DQUOT_SPACE_RESERVE, <other values>]"
        }
    }
},

{
    "kprobe:dquot_alloc_inode": {
        "description": "Allocate a dquot for an inode.",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Loop over the quotas for each cnt from 0 to MAXQUOTAS.",
        "pre": {
            "cnt": ">= 0",
            "cnt": "< MAXQUOTAS"
        }
    }
},
{
    "for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Iterate over cnt from 0 to MAXQUOTAS",
        "pre": {
            "inode": "!= null",
            "transfer_to": "!= null"
        }
    }
},

{
    "kprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);/* Cannot turn off usage accounting without turning off limit or * suspend quotas and simultaneously turn quotas off. */": {
        "description": "Disable quotas for a specific type in the given super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "flags": "unsigned int",
            "dqopt": "struct quota_info",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kretprobe:dquot_load_quota_sb": {
        "description": "Check if flags & DQUOT_SUSPENDED is true",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "flags": "& DQUOT_SUSPENDED != 0"
        }
    }
},
{
    "kprobe:BUG_ON(flags & DQUOT_SUSPENDED)": {
        "description": "Check if the DQUOT_SUSPENDED flag is set in the flags variable.",
        "pre": {
            "flags": "& DQUOT_SUSPENDED == DQUOT_SUSPENDED"
        }
    }
},
{
    "kretprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Resume dquot operations for a specific type on a super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "dqopt": "!=null",
            "ret": "int",
            "cnt": "int",
            "flags": "unsigned int",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kprobe:if (WARN_ON_ONCE(down_read_trylock(&sb->s_umount)))up_read(&sb->s_umount);for (cnt = 0; cnt < MAXQUOTAS; cnt++)": {
        "description": "Resume dquot operations for a specific type on a super block.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "dqopt": "!=null",
            "ret": "int",
            "cnt": "int",
            "flags": "unsigned int",
            "s_umount": "exclusive mode"
        }
    }
},
{
    "kretprobe:dquot_quota_on": {
        "description": "Enable quota on a filesystem.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "path": "!=null",
            "path->dentry": "!=null",
            "path->dentry->d_sb": "!=sb",
            "error": "int"
        },
        "post": {
            "error": "int"
        }
    }
},
{
    "kprobe:dquot_quota_on": {
        "description": "Enable quota on a filesystem.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "format_id": "int",
            "path": "!=null"
        }
    }
},


{
    "kretprobe:dquot_set_dqinfo": {
        "description": "Set quota information for a given super block and type.",
        "pre": {
            "ii->i_fieldmask & QC_WARNS_MASK": "!= true",
            "ii->i_fieldmask & QC_RT_SPC_TIMER": "!= true",
            "sb_has_quota_active(sb, type)": "== true",
            "ii->i_fieldmask & QC_FLAGS": "== true",
            "ii->i_flags & QCI_ROOT_SQUASH && mi->dqi_format->qf_fmt_id != QFMT_VFS_OLD": "!= true",
            "ii->i_fieldmask & QC_SPC_TIMER": "== true",
            "ii->i_fieldmask & QC_INO_TIMER": "== true",
            "ii->i_fieldmask & QC_FLAGS": "== true",
            "ii->i_flags & QCI_ROOT_SQUASH": "== true",
            "mi->dqi_flags": "|= DQF_ROOT_SQUASH",
            "mi->dqi_flags": "&= ~DQF_ROOT_SQUASH"
        },
        "post": {
            "unlock(dq_data_lock)": "true",
            "mark_info_dirty(sb, type)": "true"
        }
    }
},
{
    "kprobe:return_sb_dq_op_write_info": {
        "description": "Write quota information to disk for a given super block and type.",
        "pre": {
            "sb": "!=null",
            "type": "int",
            "ii": {
                "i_fieldmask": "int",
                "i_flags": "int",
                "i_spc_timelimit": "int",
                "i_ino_timelimit": "int"
            },
            "sb_has_quota_active(sb, type)": "true",
            "mi": {
                "dqi_format": {
                    "qf_fmt_id": "int"
                }
            }
        }
    }
},
{
    "kretprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kretprobe:crypto_kdf108_setkey": {
        "description": "Check according to SP800-108 section 7.2",
        "pre": {
            "ikm": "!=null",
            "ikmlen": "!=null"
        }
    }
},
{
    "kprobe:crypto_kdf108_setkey": {
        "description": "Check according to SP800-108 section 7.2",
        "pre": {
            "ikm": "!=null",
            "ikmlen": "!=null"
        }
    }
},
{
    "kretprobe:ecc_is_key_valid": {
        "description": "Check if the private key is valid for the given ECC curve.",
        "pre": {
            "curve": "!=null",
            "private_key": "!=null",
            "ndigits": "!=null",
            "private_key": "in [2, curve->n-3]",
            "curve->g.ndigits": "== ndigits"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:ecc_is_key_valid": {
        "description": "Check if the private key is valid for the given ECC curve.",
        "pre": {
            "curve": {
                "g": {
                    "ndigits": "==ndigits"
                }
            },
            "private_key": "!=null",
            "ndigits": "!=null",
            "private_key_range": "[2, n-3]"
        }
    }
},
{
    "kretprobe:if (nbits < 160 || ndigits > ARRAY_SIZE(priv))return -EINVAL;/* * FIPS 186-4 recommends that the private key should be obtained from a * RBG with a security strength equal to or greater than the security * strength associated with N. * * The maximum security strength identified by NIST SP800-57pt1r4 for * ECC is 256 (N >= 512). * * This condition is met by the default RNG because it selects a favored * DRBG with a security strength of 256. */": {
        "description": "Check if the private key generation conditions are met.",
        "pre": {
            "nbits": "< 160 || ndigits > ARRAY_SIZE(priv)"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the private key meets the security strength requirements.",
        "pre": {
            "nbits": "< 160 || ndigits > ARRAY_SIZE(priv)",
            "return": "-EINVAL"
        }
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_full": {
        "description": "Check if the public key is valid for the given curve.",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kprobe:ecc_is_pubkey_valid_full": {
        "description": "Check if the given public key is valid for the specified curve.",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kretprobe:if (ecc_point_is_zero(pk))return -EINVAL;/* Check 2: Verify key is in the range [1, p-1]. */": {
        "description": "Check if the given ECC point is zero. If it i return -EINVAL.",
        "pre": {
            "pk": "!=null",
            "pk->ndigits": "==curve->g.ndigits"
        }
    }
},
{
    "kprobe:ecc_point_is_zero": {
        "description": "Check if the given ECC point is zero.",
        "pre": {
            "pk": "!=null"
        }
    },
    "kprobe:ecc_is_pubkey_valid_partial": {
        "description": "Check if the given ECC public key is valid (partial check).",
        "pre": {
            "curve": "!=null",
            "pk": "!=null",
            "pk->ndigits": "==curve->g.ndigits"
        }
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_partial": {
        "description": "Partial verification: ephemeral keys only",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        },
        "post": {
            "ret": "== -EAGAIN",
            "pk->x": "== public_key[ndigits]",
            "pk->y": "== &public_key[ndigits]"
        }
    }
},
{
    "ecc_is_pubkey_valid_partial": {
        "description": "Partial verification: ephemeral keys only",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kretprobe:dma_pool_create": {
        "description": "Create a DMA allocation pool with the requested characteristics.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": ">0",
            "boundary": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:dma_pool_create": {
        "description": "Create a DMA allocation pool with the requested characteristics.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "boundary": ">=0"
        }
    }
},


{
    "kretprobe:dma_pool_free": {
        "description": "Put block back into dma pool",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:dma_pool_free": {
        "description": "Put block back into dma pool",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "allocation": ">=0"
        }
    }
},
{
    "kprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach.",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": "!=null",
            "align": "!=null",
            "allocation": ">=0"
        }
    }
},
{
    "kretprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy().",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy().",
        "pre": {
            "pool": "!=null"
        }
    }
},


{
    "kretprobe:movable_zone": {
        "description": "The 'movable_zone' function returns the 'real' zone pages taken from ZONE_MOVABLE.",
        "pre": {
            "movable_zone": "!=null"
        }
    }
},
{
    "kprobe:movable_zone": {
        "description": "The 'movable_zone' function represents the 'real' zone from which pages in ZONE_MOVABLE are taken.",
        "pre": {
            "movable_zone": "!=null"
        }
    }
},
{
    "kretprobe:__alloc_pages_may_oom": {
        "description": "Allocate pages and handle out-of-memory (OOM) situations.",
        "pre": {
            "page": "==null",
            "gfp_mask": "!=null",
            "order": "!=null",
            "alloc_flags": "!=null",
            "ac": "!=null"
        }
    }
},
{
    "kprobe:__alloc_pages_cpuset_fallback": {
        "description": "Allocate pages with cpuset fallback",
        "pre": {
            "gfp_mask": "!=null",
            "order": "!=null",
            "alloc_flags": "!=null",
            "ac": "!=null"
        },
        "post": {
            "page": "!=null"
        }
    }
},


{
    "kretprobe:free_pages": {
        "description": "Free the allocated pages.",
        "pre": {
            "pages": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:free_pages": {
        "description": "Free the allocated pages.",
        "pre": {
            "pages": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:size = nc->size": {
        "description": "Assign the value of nc->size to size.",
        "pre": {
            "nc": "!=null",
            "nc->size": "!=null"
        }
    }
},
{
    "kprobe:size = nc->size;#endif/* Even if we own the page, we do not use atomic_set(). * This would break get_page_unless_zero() users. */": {
        "description": "Helper function for allocating page fragments with alignment.",
        "pre": {
            "nc": "!=null"
        }
    }
},
{
    "kretprobe:alloc_pages_exact": {
        "description": "Allocate pages of exact size",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:alloc_pages_exact": {
        "description": "Allocate exact pages with specified size and flags.",
        "pre": {
            "size": ">0",
            "gfp_mask": ">=0"
        },
        "post": {
            "return": "!=NULL"
        }
    }
},


{
    "kretprobe:high_memory": {
        "description": "Defines the upper bound on direct map memory, then end of ZONE_NORMAL.",
        "pre": {
            "max_low_pfn": "== highstart_pfn",
            "ZONE_NORMAL": "!= null",
            "ZONE_HIGHMEM": "!= null",
            "gap_between_zones": "== 0"
        }
    }
},
{
    "kprobe:void *high_memory;EXPORT_SYMBOL(high_memory)": {
        "description": "Defines the upper bound on direct map memory, then end of ZONE_NORMAL.",
        "pre": {
            "max_low_pfn": "== highstart_pfn",
            "ZONE_NORMAL": "!= null",
            "ZONE_HIGHMEM": "!= null",
            "gap_between_zones": "== 0"
        }
    }
},
{
    "kretprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pages": "!=null",
            "num": "!=null"
        }
    }
},
{
    "kprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pages": "!=null",
            "num": "!=null"
        }
    }
},
{
    "kretprobe:__vm_map_pages": {
        "description": "Maps a range of kernel pages into a user vma.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:__vm_map_pages": {
        "description": "Maps a range of kernel pages into a user vma.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starting with zero offset.",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starts with zero offset",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pfn": "!=null",
            "pgprot": "!=null"
        }
    }
},
{
    "kprobe:vm_fault_t vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:vm_normal_page": {
        "description": "This function returns the struct page corresponding to the given virtual address in the specified vm_area_struct.",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pte": "!=null",
            "vma->vm_flags": "not in [VM_PFNMAP, VM_MIXEDMAP]",
            "vma->vm_pgoff + ((addr - vma->vm_start) >> PAGE_SHIFT)": "== pfn_of_page"
        }
    }
},
{
    "kprobe:vm_normal_page": {
        "description": "This function returns a struct page pointer for the given virtual memory area (vma), address (addr), and page table entry (pte).",
        "pre": {
            "vma": "!=null",
            "addr": "!=null",
            "pte": "!=null"
        }
    }
},
{
    "kretprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace",
        "pre": {
            "vma": "!=null",
            "start": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "VIRTUAL_BUG_ON": {
        "description": "Check if vmalloc_addr is a valid virtual address for vmalloc or module space",
        "pre": {
            "vmalloc_addr": "is_vmalloc_or_module_addr(vmalloc_addr)"
        }
    }
},
{
    "kprobe:VIRTUAL_BUG_ON": {
        "description": "Check if the given address is a valid vmalloc or module address.",
        "pre": {
            "is_vmalloc_or_module_addr(vmalloc_addr)": "!= false",
            "pgd_none(*pgd)": "!= true",
            "WARN_ON_ONCE(pgd_leaf(*pgd))": "!= true"
        }
    }
},
{
    "kretprobe:addr_to_vb_xa": {
        "description": "Helper function for vm_unmap_ram",
        "pre": {
            "addr": "!=null",
            "addr_zone": "in [CPU0, CPU1, CPU2]",
            "vmap_blocks_access": {
                "CPU0": "CPU0INDEX0 -> vmap_blocks -> xa_lock",
                "CPU1": "CPU1INDEX1 -> vmap_blocks -> xa_lock",
                "CPU2": "CPU2INDEX2 -> vmap_blocks -> xa_lock"
            },
            "xa_lock_contention": "exists"
        }
    }
},
{
    "kprobe:addr_to_vb_xa": {
        "description": "Converts an address to a virtual block xarray.",
        "pre": {
            "addr": "!=null",
            "addr": "belongs to CPU0 zone when CPU == 0",
            "addr": "belongs to CPU1 zone when CPU == 1",
            "addr": "belongs to CPU2 zone when CPU == 2",
            "addr": "not in [6, 11, 20] when CPU != 0, 1, 2"
        }
    }
},




{
    "kretprobe:__get_vm_area_caller": {
        "description": "This condition represents the post condition for the __get_vm_area_caller function.",
        "pre": {
            "flags": "not in [VM_ALLOC]",
            "area.addr": "!=null",
            "requested_size": "!=null",
            "KASAN_VMALLOC_PROT_NORMAL": "!=null"
        }
    }
},
{
    "kprobe:__get_vm_area_caller": {
        "description": "Allocate a virtual memory area.",
        "pre": {
            "flags": "!(flags & VM_ALLOC)"
        }
    }
},
{
    "kretprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace.",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill.",
        "pre": {
            "size": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill.",
        "pre": {
            "size": ">0",
            "node": ">=0"
        }
    }
},
{
    "kretprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable)",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable)",
        "pre": {
            "size": "!=null"
        }
    }
},


{
    "kretprobe:remap_vmalloc_range_partial": {
        "description": "Map vmalloc pages to userspace",
        "pre": {
            "vma": "!=null",
            "uaddr": "!=null",
            "kaddr": "!=null",
            "pgoff": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:remap_vmalloc_range_partial": {
        "description": "Map vmalloc pages to userspace",
        "pre": {
            "vma": "!=null",
            "uaddr": "!=null",
            "kaddr": "!=null",
            "pgoff": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, -Exxx]"
        }
    }
},




{
    "kretprobe:vm_brk_flags": {
        "description": "The vm_brk_flags function is used to handle memory allocation and deallocation with specific flags.",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "mm": "!=null",
            "vma": "null",
            "len": "PAGE_ALIGN(request)",
            "ret": "not in [EINVAL, ENOMEM, EINTR]",
            "populate": "((mm->def_flags & VM_LOCKED) != 0)"
        },
        "post": {
            "ret": "ret",
            "mm": "mm",
            "vma": "vma",
            "uf": "uf",
            "populate": "populate"
        }
    }
},
{
    "kprobe:vm_brk_flags": {
        "description": "Function to handle brk flags in the virtual memory area.",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "ret": "in [0, -EINVAL, -ENOMEM, -EINTR]"
        }
    }
},
{
    "kretprobe:vm_brk_flags": {
        "description": "Function to handle vm_brk_flags",
        "pre": {
            "flags": "& (~VM_EXEC) != 0",
            "ret": "check_brk_limits(addr, len) == 0",
            "ret": "do_vmi_munmap(&vmi, mm, addr, len, &uf, 0) == 0",
            "vma": "vma_prev(&vmi) != NULL",
            "ret": "do_brk_flags(&vmi, vma, addr, len, flags) == 0",
            "populate": "(mm->def_flags & VM_LOCKED) != 0",
            "ret": "mm_populate(addr, len) == 0"
        },
        "post": {
            "ret": "ret"
        }
    }
},
{
    "kprobe:vm_brk_flags": {
        "description": "Function to handle vm_brk_flags",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "& (~VM_EXEC) != 0",
            "mm": "!=null",
            "vma": "null",
            "len": "PAGE_ALIGN(request)",
            "ret": "int",
            "populate": "((mm->def_flags & VM_LOCKED) != 0)"
        }
    }
},
{
    "kretprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete.",
        "pre": {
            "none": "none"
        }
    }
},
{
    "kprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete.",
        "pre": {
            "none": "none"
        }
    }
},


{
    "kretprobe:VM_BUG_ON": {
        "description": "Check if migrate is not null.",
        "pre": {
            "migrate": "!=null"
        }
    },
    "kretprobe:addr = migrate->start + i*PAGE_SIZE": {
        "description": "Calculate the address based on migrate->start and i.",
        "pre": {
            "migrate": "!=null",
            "i": ">=0"
        }
    },
    "kretprobe:if (!notified)": {
        "description": "Check if notified is false.",
        "pre": {
            "notified": "==false"
        }
    }
},
{
    "VM_BUG_ON(!migrate); addr = migrate->start + i*PAGE_SIZE; if (!notified)": {
        "description": "Perform a VM bug check and calculate the address based on migrate->start and i*PAGE_SIZE if notified is false.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null",
            "migrate": "!=null"
        }
    }
},
{
    "kretprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kretprobe:migrate_device_pages": {
        "description": "Migrate struct page meta-data from source struct page to destination.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kprobe:migrate_device_pages": {
        "description": "Migrate struct page meta-data from source struct page to destination.",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": "!=null"
        }
    }
},
{
    "kretprobe:balance_dirty_pages_ratelimited": {
        "description": "Checks if writeback or throttling needs to be forced.",
        "pre": {
            "ratelimit_pages": "==32"
        }
    }
},

{
    "kretprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag.",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag.",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kretprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},



{
    "kprobe:folio_account_redirty": {
        "description": "De-account the dirty counters when redirtying a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},

{
    "kprobe:WARN_ON_ONCE": {
        "description": "Check if 'warn' is true and 'folio' is not up-to-date.",
        "pre": {
            "warn": "==true",
            "folio_test_uptodate(folio)": "==false"
        }
    },
    "kprobe:folio_account_dirtied": {
        "description": "Account for dirtying the 'folio' in the 'mapping'.",
        "pre": {
            "folio": "!=null",
            "mapping": "!=null"
        }
    },
    "kprobe:__xa_set_mark": {
        "description": "Set the 'folio' as dirty in the 'mapping' at the specified index.",
        "pre": {
            "mapping->i_pages": "!=null",
            "folio_index(folio)": ">=0",
            "PAGECACHE_TAG_DIRTY": "!=null"
        }
    },
    "kprobe:xa_unlock_irqrestore": {
        "description": "Unlock the 'mapping->i_pages' with the given 'flags'.",
        "pre": {
            "mapping->i_pages": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:filemap_dirty_folio": {
        "description": "Mark the 'folio' as dirty for filesystems that do not use buffer_heads.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:if (error == AOP_WRITEPAGE_ACTIVATE)": {
        "description": "Check if the error value is equal to AOP_WRITEPAGE_ACTIVATE.",
        "pre": {
            "error": "== AOP_WRITEPAGE_ACTIVATE"
        }
    }
},
{
    "folio": "!=null",
    "wbc": "!=null",
    "mapping": "!=null",
    "data": "!=null",
    "error": "==AOP_WRITEPAGE_ACTIVATE"
},
{
    "kretprobe:__folio_start_writeback": {
        "description": "Starts the writeback process for a folio",
        "pre": {
            "folio": {
                "host": "!=null"
            },
            "on_wblist": false
        },
        "post": {
            "folio_test_dirty(folio)": false,
            "xas_clear_mark(&xa PAGECACHE_TAG_DIRTY)": true,
            "xas_clear_mark(&xa PAGECACHE_TAG_TOWRITE)": true,
            "keep_write": false
        }
    }
},
{
    "kprobe:__folio_start_writeback": {
        "description": "Starts the writeback process for a folio",
        "pre": {
            "folio": {
                "host": "!=null"
            },
            "on_wblist": false
        }
    }
},
{
    "kretprobe:unpin_user_page": {
        "description": "Unpin a user page",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:unpin_user_page": {
        "description": "Unpin a user page",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range",
        "pre": {
            "page": "!=null",
            "npages": ">= 0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range",
        "pre": {
            "page": "!=null",
            "npages": ">= 0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_subpage_writeable": {
        "description": "Fault in an address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_subpage_writeable": {
        "description": "Fault in an address range for writing",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_safe_writeable": {
        "description": "Fault in an address range for writing.",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_safe_writeable": {
        "description": "Fault in an address range for writing.",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading",
        "pre": {
            "uaddr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading.",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": ">=0",
            "gup_flags": ">=0",
            "pages": "!=null",
            "locked": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": ">=0",
            "gup_flags": ">=0",
            "pages": "!=null",
            "locked": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:try_grab_folio": {
        "description": "Increment the refcount and pincount of the folio based on the provided parameters.",
        "pre": {
            "page": "!=null",
            "refs": ">=0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        },
        "post": {
            "return": {
                "type": "struct folio",
                "constraints": {
                    "if return == null": "failure",
                    "if flags == FOLL_GET": "refcount == old(refcount) + refs",
                    "if flags == FOLL_PIN and folio is large": "refcount == old(refcount) + refs and pincount == old(pincount) + refs",
                    "if flags == FOLL_PIN and folio is single-page": "refcount == old(refcount) + refs * GUP_PIN_COUNTING_BIAS"
                }
            }
        }
    }
},
{
    "kprobe:try_grab_folio": {
        "description": "The folio containing @page (with refcount appropriately incremented) for succes or NULL upon failure. If neither FOLL_GET nor FOLL_PIN was set, that's considered failure, and furthermore, a likely bug in the caller, so a warning is also emitted.",
        "pre": {
            "page": "!=null",
            "refs": ">=0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        }
    }
},
{
    "kretprobe:get_user_pages_unlocked": {
        "description": "Replaces the form: mmap_read_lock(mm); get_user_pages(mm, ..., page NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages). Functionally equivalent to get_user_pages_fast if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_FORCE, ...]"
        }
    }
},
{
    "kprobe:get_user_pages_unlocked": {
        "description": "Replaces the form: mmap_read_lock(mm); get_user_pages(mm, ..., page NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages). Functionally equivalent to get_user_pages_fast if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_FORCE, ...]"
        }
    }
},
{
    "kretprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": "!=null",
            "gup_flags": "!=null",
            "pages": "!=null",
            "locked": "!=null"
        }
    }
},
{
    "kprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process",
        "pre": {
            "mm": "!=null",
            "start": "!=null",
            "nr_pages": "!=null",
            "gup_flags": "!=null",
            "pages": "!=null",
            "locked": "!=null"
        }
    }
},
{
    "kretprobe:pin_user_pages_unlocked": {
        "description": "The FOLL_PIN variant of get_user_pages_unlocked(). Sets FOLL_PIN and rejects FOLL_GET.",
        "pre": {
            "start": "!=null",
            "nr_pages": ">=0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN]"
        }
    }
},
{
    "kprobe:pin_user_pages_unlocked": {
        "description": "The FOLL_PIN variant of get_user_pages_unlocked(). Sets FOLL_PIN and rejects FOLL_GET.",
        "pre": {
            "start": "!=null",
            "nr_pages": "!=null",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN]"
        }
    }
},
{
    "kretprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and CPUs of the node are removed.",
        "pre": {
            "nid": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and cpus of the node are removed.",
        "pre": {
            "nid": "!=null"
        }
    }
},
{
    "kretprobe:mempool_exit": {
        "description": "Free all reserved elements in pool and pool itself. This function only sleeps if the free_fn() function sleeps.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_exit": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself.",
        "pre": {
            "pool": "!=null",
            "free_fn()": "does not sleep"
        }
    }
},
{
    "kretprobe:while (pool->curr_nr < pool->min_nr)": {
        "description": "Loop until the current number of buffers is less than the minimum number of buffers.",
        "pre": {
            "pool->curr_nr": "< pool->min_nr"
        }
    }
},
{
    "kprobe:while (pool->curr_nr < pool->min_nr)": {
        "description": "Loop while the current number of elements in the pool is less than the minimum number.",
        "pre": {
            "pool->curr_nr": "< pool->min_nr"
        }
    }
},
{
    "kretprobe:mempool_resize": {
        "description": "Resize an existing memory pool",
        "pre": {
            "pool": "!=null",
            "new_min_nr": "int"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:mempool_resize": {
        "description": "Resize an existing memory pool",
        "pre": {
            "pool": "!=null",
            "new_min_nr": "int"
        }
    }
},
{
    "kretprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "pre": {
            "pool": "!=null",
            "pool->pool_data": "!=null",
            "element": "!=null",
            "PAGE_SHIFT": "!=null",
            "order": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "pre": {
            "pool->pool_data": "!=null",
            "element": "!=null"
        }
    }
},




{
    "kretprobe:__put_devmap_managed_page_refs": {
        "description": "__put_devmap_managed_page_refs(struct page page, int refs) - If the page's pgmap type is not MEMORY_DEVICE_FS_DAX, return false.",
        "pre": {
            "page->pgmap->type": "== MEMORY_DEVICE_FS_DAX",
            "refs": ">= 0"
        },
        "post": {
            "return": "== 1",
            "wake_up_var(&page->_refcount)": "called"
        }
    }
},
{
    "kprobe:__put_devmap_managed_page_refs": {
        "description": "__put_devmap_managed_page_refs(struct page page, int refs)",
        "pre": {
            "page->pgmap->type": "== MEMORY_DEVICE_FS_DAX",
            "refs": ">= 0"
        }
    }
},


{
    "kretprobe:readahead_expand": {
        "description": "Expand a readahead request",
        "pre": {
            "ractl": "!=null",
            "new_start": "!=null",
            "new_len": "!=null"
        }
    }
},
{
    "kprobe:readahead_expand": {
        "description": "Expand a readahead request",
        "pre": {
            "ractl": "!=null",
            "new_start": "!=null",
            "new_len": "!=null"
        }
    }
},

{
    "kprobe:hmm_range_need_fault": {
        "description": "Check if a fault is needed for the given range in the hmm_vma_walk function.",
        "pre": {
            "hmm_vma_walk": "!=null",
            "range->hmm_pfns + ((start - range->start) >> PAGE_SHIFT)": "!=null",
            "(end - start) >> PAGE_SHIFT": "!=null"
        }
    },
    "kprobe:hmm_pfns_fill": {
        "description": "Fill the hmm_pfns array with HMM_PFN_ERROR for the given range.",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "range": "!=null"
        }
    }
},
{
    "kretprobe:folio_migrate_mapping": {
        "description": "Migrate the mapping of a folio to a new folio.",
        "pre": {
            "mapping": "!=null",
            "newfolio": "!=null",
            "folio": "!=null",
            "extra_count": "int",
            "xas": "XA_STATE",
            "oldzone": "struct zone",
            "newzone": "struct zone",
            "dirty": "int",
            "expected_count": "int",
            "nr": "long"
        },
        "post": {
            "return": "-EAGAIN",
            "conditions": [
                "folio_ref_count(folio) != expected_count"
            ]
        }
    }
},
{
    "kprobe:folio_ref_count": {
        "description": "Check if the reference count of the folio is equal to the expected count.",
        "pre": {
            "folio": "!=null",
            "expected_count": "!=null",
            "folio_ref_count(folio)": "!= expected_count"
        },
        "return": "-EAGAIN"
    }
},
{
    "kretprobe:folio_test_mappedtodisk": {
        "description": "Check if the folio is mapped to disk.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_set_mappedtodisk": {
        "description": "Set the mappedtodisk flag for the new folio.",
        "pre": {
            "newfolio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_mappedtodisk": {
        "description": "Check if the folio is mapped to disk.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_set_mappedtodisk": {
        "description": "Set the mappedtodisk flag for the new folio.",
        "pre": {
            "newfolio": "!=null"
        }
    }
},
{
    "kretprobe:folio_migrate_mapping": {
        "description": "Simple folio migration.",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC_NO_COPY, ...]", // Add other possible values for the enum
            "extra_count": ">=0"
        }
    }
},
{
    "kprobe:folio_migrate_mapping": {
        "description": "Migrate a single LRU folio",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC_NO_COPY, ...]", // Add other valid modes here
            "extra_count": ">=0"
        }
    }
},
{
    "kretprobe:expected_count = folio_expected_refs": {
        "description": "Check if the expected reference count of the folio is equal to the reference count of the source folio.",
        "pre": {
            "mapping": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]",
            "check_refs": "bool"
        },
        "post": {
            "expected_count": "== folio_expected_refs(mapping, src)",
            "return": "-EAGAIN if folio_ref_count(src) != expected_count",
            "return": "-EAGAIN if !buffer_migrate_lock_buffers(head, mode)",
            "return": "success otherwise"
        }
    }
},
{
    "kprobe:expected_count": {
        "description": "Check if the reference count of src folio matches the expected count.",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]",
            "check_refs": "bool"
        }
    },
    "kprobe:buffer_migrate_lock_buffers": {
        "description": "Lock the buffers of the head folio for migration.",
        "pre": {
            "head": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC]"
        }
    },
    "kprobe:check_refs": {
        "description": "Check if the reference count is enabled.",
        "pre": {}
    }
},
{
    "kretprobe:cgwb_release_wq": {
        "description": "Allocate a workqueue named 'cgwb_release' with 0 flags and 1 maximum concurrency. If the allocation fail return -ENOMEM. Otherwise, return 0.",
        "pre": {
            "cgwb_release_wq": "==null"
        },
        "post": {
            "cgwb_release_wq": "!=null"
        }
    }
},
{
    "kprobe:cgwb_release_wq": {
        "description": "Allocate a workqueue named 'cgwb_release' with 0 flags and 1 maximum concurrency. If the allocation fail return -ENOMEM. Otherwise, return 0.",
        "pre": {
            "cgwb_release_wq": "==null"
        }
    }
},
{
    "kretprobe:cleanup_offline_cgwbs_workfn": {
        "description": "Try to release dying cgwbs by switching attached inodes to the nearest living ancestor's writeback. Processed wbs are placed at the end of the list to guarantee forward progress.",
        "pre": {
            "bdi": "!=null"
        }
    }
},
{
    "kprobe:cleanup_offline_cgwbs_workfn": {
        "description": "Try to release dying cgwbs by switching attached inodes to the nearest living ancestor's writeback. Processed wbs are placed at the end of the list to guarantee forward progress.",
        "pre": {
            "bdi": "!=null",
            "iter": "!=null",
            "slot": "!=null",
            "wb": "!=null",
            "WB_registered": "0",
            "cgwb_lock": "unlocked",
            "list_empty(&bdi->wb_list)": "true"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and save the IRQ state.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:radix_tree_lookup": {
        "description": "Look up an entry in a radix tree.",
        "pre": {
            "tree": "!=null",
            "key": "!=null"
        },
        "post": {
            "wb": "!=null",
            "wb.blkcg_css": "!=null",
            "wb.blkcg_css": "!=blkcg_css"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:radix_tree_lookup": {
        "description": "Look up an entry in a radix tree.",
        "pre": {
            "tree": "!=null",
            "key": "!=null"
        }
    },
    "kprobe:wb->blkcg_css": {
        "description": "Check if wb->blkcg_css is equal to blkcg_css.",
        "pre": {
            "wb": "!=null",
            "wb->blkcg_css": "==blkcg_css"
        }
    }
},
{
    "kretprobe:generic_error_remove_page": {
        "description": "Remove a page from the address space mapping if it is not a regular file.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null",
            "PageTail(page)": "false",
            "!S_ISREG(mapping->host->i_mode)": "true"
        },
        "post": {
            "return": "-EIO",
            "truncate_inode_folio(mapping, page_folio(page))": "return value"
        }
    }
},
{
    "kprobe:generic_error_remove_page": {
        "description": "Remove a page from the address space mapping if it is not a regular file.",
        "pre": {
            "mapping": "!=null",
            "page": "!=null",
            "PageTail(page)": "false",
            "!S_ISREG(mapping->host->i_mode)": "true"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_range": {
        "description": "Truncate range of pages specified by start & end byte offsets",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:truncate_inode_pages_range": {
        "description": "Truncate range of pages specified by start & end byte offsets",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies",
        "pre": {
            "mapping": "!=null"
        }
    }
},


{
    "kretprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null",
            "inode->i_size": "written"
        }
    }
},
{
    "kprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated.",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null",
            "inode->i_size": "newsize"
        }
    }
},
{
    "kretprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null"
        }
    }
},
{
    "kprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null"
        }
    }
},
{
    "kretprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size",
        "pre": {
            "inode": "!=null",
            "from": "!=null",
            "to": "!=null"
        }
    }
},
{
    "kprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size",
        "pre": {
            "inode": "!=null",
            "from": "!=null",
            "to": "!=null"
        }
    }
},
{
    "kretprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched.",
        "pre": {
            "inode": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched",
        "pre": {
            "inode": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kretprobe:__kmap_to_page": {
        "description": "kmap_local_page() mappings",
        "pre": {
            "vaddr": "!=null",
            "base": "unsigned long",
            "kctrl": "struct kmap_ctrl",
            "addr": "unsigned long",
            "i": "int"
        },
        "post": {
            "return": "pte_page(ptep_get(&pkmap_page_table[PKMAP_NR(addr)]))"
        }
    }
},

{
    "kretprobe:#ifdef ARCH_NEEDS_KMAP_HIGH_GET#define lock_kmap()             spin_lock_irq(&kmap_lock)#define unlock_kmap()           spin_unlock_irq(&kmap_lock)#define lock_kmap_any(flags)    spin_lock_irqsave(&kmap_lock, flags)#define unlock_kmap_any(flags)  spin_unlock_irqrestore(&kmap_lock, flags)#else#define lock_kmap()             spin_lock(&kmap_lock)#define unlock_kmap()           spin_unlock(&kmap_lock)#define lock_kmap_any(flags)    \\do": {
        "description": "The function abstracts the disabling of IRQ out of the locking in the case of kmap_high_get().",
        "pre": {
            "kmap_lock": "!=null",
            "flags": "in [null, BPF_NOEXIST, BPF_EXIST, BPF_ANY]"
        }
    }
},

{
    "kretprobe:kmap_high_get": {
        "description": "Get the high virtual address mapping for a given page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:kmap_high_get": {
        "description": "Condition for the kmap_high_get function",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:__kmap_local_page_prot": {
        "description": "To broaden the usage of the actual kmap_local() machinery always map pages when debugging is enabled and the architecture has no problems with alias mappings.",
        "pre": {
            "!IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": true,
            "!PageHighMem(page)": true
        }
    }
},
{
    "kprobe:__kmap_local_page_prot": {
        "description": "To broaden the usage of the actual kmap_local() machinery always map pages when debugging is enabled and the architecture has no problems with alias mappings.",
        "pre": {
            "!IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": true,
            "!PageHighMem(page)": true
        }
    }
},

{
    "kprobe:WARN_ON_ONCE": {
        "description": "Handle mappings which were obtained by kmap_high_get() first as the virtual address of such mappings is below PAGE_OFFSET. Warn for all other addresses which are in the user space part of the virtual address space.",
        "pre": {
            "vaddr": "!=null",
            "addr": ">= __fix_to_virt(FIX_KMAP_END)",
            "addr": "<= __fix_to_virt(FIX_KMAP_BEGIN)",
            "IS_ENABLED(CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP)": "true"
        }
    }
},




{
    "kretprobe:static_branch_likely": {
        "description": "Check if the static branch is likely to be taken.",
        "pre": {
            "!static_branch_likely(&vm_numa_stat_key)": true
        },
        "post": {
            "return": {
                "page": "!=null",
                "page_to_nid(page)": "nid"
            }
        }
    }
},
{
    "kprobe:static_branch_likely_page_to_nid": {
        "description": "Allocate pages with the given GFP flag order, and NUMA node ID. Skip NUMA_INTERLEAVE_HIT counter update if NUMA statistics is disabled.",
        "pre": {
            "gfp": "!=null",
            "order": "!=null",
            "nid": "!=null",
            "Fourth Parameter": "==null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:get_hwpoison_page": {
        "description": "The function to get a hardware poisoned page.",
        "pre": {
            "p": "!=null",
            "flags": "!=null",
            "p->flags": "& PG_hwpoison",
            "return": "in [0, 1, -EIO, -EBUSY, -EHWPOISON]"
        }
    }
},
{
    "kprobe:get_hwpoison_page": {
        "description": "Retrieve a hardware-poisoned page.",
        "pre": {
            "p": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:is_migrate_cma_page": {
        "description": "Check if the given page is a CMA (Contiguous Memory Allocator) page that can be migrated.",
        "pre": {
            "page": "!=null"
        }
    },
    "kretprobe:page_folio": {
        "description": "Get the folio structure associated with the given page.",
        "pre": {
            "page": "!=null"
        }
    },
    "kretprobe:PageCompound": {
        "description": "Check if the given page is a compound page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:is_migrate_cma_page": {
        "description": "Check if the given page is a CMA (Contiguous Memory Allocator) page that can be migrated.",
        "pre": {
            "page": "!=null"
        }
    },
    "kprobe:page_folio": {
        "description": "Get the folio structure associated with the given page.",
        "pre": {
            "page": "!=null"
        }
    },
    "kprobe:PageCompound": {
        "description": "Check if the given page is a compound page.",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:generic_fadvise": {
        "description": "Generic file advisory information.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "len": "!=null",
            "advice": "!=null",
            "inode": "!=null",
            "mapping": "!=null",
            "bdi": "!=null",
            "endbyte": "!=null"
        },
        "post": {
            "return": "in [-ESPIPE, -EINVAL]"
        }
    }
},
{
    "kprobe:generic_fadvise": {
        "description": "Generic file advisory information.",
        "pre": {
            "file": "!=null",
            "offset": "!=null",
            "len": "!=null",
            "advice": "!=null",
            "inode": "!=null",
            "mapping": "!=null",
            "bdi": "!=null",
            "endbyte": "!=null"
        }
    }
},


{
    "kretprobe:do_slab_free": {
        "description": "Free objects from a slab cache.",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": ">=0"
        }
    }
},
{
    "kprobe:do_slab_free": {
        "description": "Performs fastpath freeing without additional function calls.",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": ">=0"
        }
    }
},
{
    "kretprobe:slub_get_cpu_ptr": {
        "description": "Allocate a per-CPU object cache for the specified slab.",
        "pre": {
            "s": "!=null",
            "flags": "!=null",
            "size": "!=null",
            "p": "!=null",
            "objcg": "!=null"
        }
    },
    "kretprobe:local_lock_irqsave": {
        "description": "Acquire a local lock and disable IRQs.",
        "pre": {
            "lock": "!=null",
            "irqflags": "!=null"
        }
    },
    "kretprobe:for_loop": {
        "description": "Iterate over the range [0, size) using variable i.",
        "pre": {
            "i": ">=0",
            "i": "<size"
        }
    }
},
{
    "kprobe:c = slub_get_cpu_ptr(s->cpu_slab);local_lock_irqsave(&s->cpu_slab->lock, irqflags);for (i = 0; i < size; i++)": {
        "description": "Drain objects in the per cpu slab, while disabling local IRQ which protects against PREEMPT and interrupts handlers invoking normal fastpath.",
        "pre": {
            "s": "!=null",
            "s->cpu_slab": "!=null",
            "s->cpu_slab->lock": "!=null",
            "irqflags": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:__folio_put": {
        "description": "This function releases the page cache for the given folio and performs additional operations depending on the size of the folio.",
        "pre": {
            "folio": "!=null",
            "!folio_test_hugetlb(folio)": "true",
            "__page_cache_release(folio)": "true",
            "destroy_large_folio(folio)": "true"
        }
    }
},
{
    "kprobe:__folio_put": {
        "description": "Put the folio into the cache.",
        "pre": {
            "folio": "!=null",
            "!folio_test_hugetlb(folio)": true,
            "__page_cache_release(folio)": true,
            "destroy_large_folio(folio)": true
        }
    }
},
{
    "kretprobe:put_pages_list": {
        "description": "Release a list of pages threaded on page->lru.",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kprobe:put_pages_list": {
        "description": "Release a list of pages threaded on page->lru.",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:folio_test_active": {
        "description": "Check if the folio is active.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_test_active": {
        "description": "Check if the folio is active.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:__folio_batch_release": {
        "description": "__folio_batch_release() will drain those queues here. folio_batch_move_lru() calls folios_put() directly to avoid mutual recursion.",
        "pre": {
            "fbatch": "!=null",
            "queues_drained": true,
            "folios_put_called": true
        }
    }
},

{
    "kretprobe:preempt_disable_nested": {
        "description": "Disable preemption and calculate x and t values.",
        "pre": {
            "delta": "!=null",
            "*p": "!=null",
            "pcp->stat_threshold": "!=null",
            "x": "!=null",
            "t": "!=null",
            "abs(x)": "> t"
        }
    }
},
{
    "kprobe:preempt_disable_nested": {
        "description": "Disable preemption for nested sections.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]",
            "delta": "!=null",
            "pcp": "!=null",
            "p": "!=null",
            "x": "!=null",
            "t": "!=null"
        }
    }
},
{
    "kretprobe:VM_WARN_ON_ONCE(delta & (PAGE_SIZE - 1));delta >>= PAGE_SHIFT;}/* See __mod_node_page_state": {
        "description": "Modifies the node page state based on the given parameters.",
        "pre": {
            "pgdat": "!=null",
            "item": "in [NODE_STAT_ITEM_1, NODE_STAT_ITEM_2, ...]",
            "delta": "!=null"
        }
    }
},
{
    "kprobe:VM_WARN_ON_ONCE": {
        "description": "Check if delta has a non-zero value and is not a multiple of PAGE_SIZE.",
        "pre": {
            "delta": "!=0",
            "delta & (PAGE_SIZE - 1)": "==0"
        }
    },
    "kprobe:delta >>= PAGE_SHIFT": {
        "description": "Right shift delta by PAGE_SHIFT bits.",
        "pre": {
            "delta": "!=null"
        }
    }
},


{
    "kretprobe:mod_zone_state": {
        "description": "Modifies the zone counter state through atomic per CPU operations.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]",
            "delta": "is int",
            "overstep_mode": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:mod_zone_state": {
        "description": "Modifies the zone counter state through atomic per cpu operations.",
        "pre": {
            "zone": "!=null",
            "item": "in [ZONE_STAT_ITEM_1, ZONE_STAT_ITEM_2, ...]", 
            "delta": "is int",
            "overstep_mode": "in [-1, 0, 1]"
        }
    }
},


{
    "kretprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "useroffset": "!=null",
            "usersize": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "useroffset": "!=null",
            "usersize": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kretprobe:kmem_cache_sanity_check": {
        "description": "Integrity check for the kmem_cache_sanity_check function.",
        "pre": {
            "name": "!=null",
            "size": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},

{
    "kretprobe:kmem_cache_release": {
        "description": "Delete and release the kmem_cache object.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_release": {
        "description": "Release a kmem_cache object.",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:kmem_cache_shrink": {
        "description": "Shrink a cache. Releases as many slabs as possible for a cache.",
        "pre": {
            "cachep": "!=null"
        },
        "post": {
            "return": "in [0, !=0]"
        }
    }
},
{
    "kprobe:kmem_cache_shrink": {
        "description": "Shrink a cache.",
        "pre": {
            "cachep": "!=null"
        }
    }
},


{
    "kretprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "pre": {
            "size": "== 0"
        },
        "post": {
            "return": "== 0"
        }
    }
},
{
    "kprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "pre": {
            "size": "== 0"
        }
    }
},
{
    "kretprobe:if (IS_ENABLED(CONFIG_MEMCG_KMEM) && (type == KMALLOC_NORMAL))flags |= SLAB_NO_MERGE;if (minalign > ARCH_KMALLOC_MINALIGN)": {
        "description": "This function checks if the CONFIG_MEMCG_KMEM is enabled and the type is KMALLOC_NORMAL. If both conditions are true, it sets the flags to include SLAB_NO_MERGE if minalign is greater than ARCH_KMALLOC_MINALIGN.",
        "pre": {
            "IS_ENABLED(CONFIG_MEMCG_KMEM)": true,
            "type": "KMALLOC_NORMAL",
            "flags": "|= SLAB_NO_MERGE",
            "minalign": "> ARCH_KMALLOC_MINALIGN"
        }
    }
},
{
    "kprobe:if (IS_ENABLED(CONFIG_MEMCG_KMEM) && (type == KMALLOC_NORMAL))flags |= SLAB_NO_MERGE;if (minalign > ARCH_KMALLOC_MINALIGN)": {
        "description": "Description of the function",
        "pre": {
            "IS_ENABLED(CONFIG_MEMCG_KMEM)": true,
            "type": "KMALLOC_NORMAL",
            "flags": "SLAB_NO_MERGE",
            "minalign": "> ARCH_KMALLOC_MINALIGN"
        }
    }
},
{
    "kretprobe:kmem_cache_create": {
        "description": "Create a cache.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_create": {
        "description": "Create a cache.",
        "pre": {
            "name": "!=null",
            "size": "!=null",
            "align": "!=null",
            "flags": "!=null",
            "ctor": "!=null"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Free previously allocated memory.",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kprobe:kfree": {
        "description": "Free previously allocated memory.",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:krealloc": {
        "description": "Check for double-free before calling ksize.",
        "pre": {
            "p": "!=null",
            "likely(p)": "true"
        }
    }
},

{
    "kretprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:__ksize": {
        "description": "Report full size of underlying allocation",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kprobe:__ksize": {
        "description": "Report full size of underlying allocation",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_update_trace": {
        "description": "Update object allocation stack trace",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_update_trace": {
        "description": "Update object allocation stack trace",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive.",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive.",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:struct_kmemleak_object": {
        "description": "Structure holding the metadata for each allocated memory block.",
        "pre": {
            "object": "!=null",
            "object->lock": "held",
            "object_list": "protected",
            "gray_list": "protected",
            "rb_node": "protected",
            "use_count": "reference-counted",
            "RCU": "used for freeing"
        }
    }
},
{
    "kprobe:struct_kmemleak_object": {
        "description": "Structure holding the metadata for each allocated memory block.",
        "pre": {
            "node": "!=null",
            "start": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_no_scan": {
        "description": "Do not scan an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_no_scan": {
        "description": "Do not scan an allocated object",
        "pre": {
            "ptr": "!=null"
        }
    }
},


{
    "kretprobe:kmemleak_free_part_phys": {
        "description": "Free a range of memory starting from the given physical address.",
        "pre": {
            "phys": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_free_part_phys": {
        "description": "Free a part of a memory object based on the physical address and size.",
        "pre": {
            "phys": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but takes a physical address argument.",
        "pre": {
            "phys": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but takes a physical address argument",
        "pre": {
            "phys": "!=null",
            "phys": "is_valid_physical_address"
        }
    }
},
{
    "kretprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation.",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available",
        "pre": {
            "type": "!=null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:mem_cgroup_from_task": {
        "description": "Returns the memory cgroup associated with the given task.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kprobe:mem_cgroup_from_task": {
        "description": "Retrieve the memory cgroup associated with a task.",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg.",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg.",
        "pre": {
            "mm": "!=null"
        }
    }
},


{
    "kretprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kretprobe:slab_post_alloc_hook": {
        "description": "Post-allocation hook for slab memory allocation.",
        "pre": {
            "s": "!=null",
            "objcg": "==null",
            "flags": "!=null",
            "size": "!=null",
            "p": "!=null"
        }
    }
},

{
    "kretprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node",
        "pre": {
            "cachep": "!=null",
            "flags": "!=null",
            "nodeid": "!=null"
        }
    }
},
{
    "kretprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode and produces a novel ino for the newly allocated inode.",
        "pre": {
            "sb": "!=null",
            "inop": "in [null, !=null]"
        }
    }
},
{
    "kprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode and produces a novel ino for the newly allocated inode.",
        "pre": {
            "sb": "!=null",
            "inop": "!=null or ==null"
        }
    }
},
{
    "kretprobe:kfree_const": {
        "description": "Conditionally free memory",
        "pre": {
            "x": "!=null",
            "x": "not in .rodata section"
        }
    }
},
{
    "kprobe:kfree_const": {
        "description": "Conditionally free memory.",
        "pre": {
            "x": "not in .rodata"
        }
    }
},
{
    "kretprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string.",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string.",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA]"
        }
    }
},
{
    "kretprobe:kstrdup_const": {
        "description": "conditionally duplicate an existing const string",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kstrdup_const": {
        "description": "conditionally duplicate an existing const string",
        "pre": {
            "s": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:kstrndup": {
        "description": "Allocate and copy a string up to a maximum length.",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kstrndup": {
        "description": "Allocate and copy at most 'max' bytes from 's' into a new string.",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:kvmemdup": {
        "description": "Duplicate a memory region.",
        "pre": {
            "src": "!=null",
            "len": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kprobe:kvmemdup": {
        "description": "Duplicate memory region with a specified size and allocate new memory for it.",
        "pre": {
            "src": "!=null",
            "len": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:memdup_user": {
        "description": "Duplicate memory region from user space",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:memdup_user": {
        "description": "Duplicate memory region from user space.",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space.",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:strndup_user": {
        "description": "Duplicate an existing string from user space",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:strndup_user": {
        "description": "Duplicate an existing string from user space.",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vma_set_file": {
        "description": "Changing an anonymous vma with this is illegal",
        "pre": {
            "vma": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:vma_set_file": {
        "description": "Changing an anonymous vma with this is illegal",
        "pre": {
            "vma": "!=null",
            "file": "!=null"
        },
        "post": {
            "vma->vm_file": "==file",
            "file->refcount": "==refcount-1"
        }
    }
},
{
    "kretprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL, GFP_KERNEL | __GFP_RETRY_MAYFAIL]",
            "node": "!=null"
        },
        "post": {
            "return": "in [!=null, NULL]"
        }
    }
},
{
    "kprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation.",
        "pre": {
            "size": "!=null",
            "flags": "in [GFP_KERNEL, GFP_KERNEL | __GFP_RETRY_MAYFAIL]",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information.",
        "pre": {
            "addr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information.",
        "pre": {
            "addr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array.",
        "pre": {
            "n": ">= 0",
            "size": ">= 0",
            "flags": "valid flags"
        }
    }
},
{
    "kprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array.",
        "pre": {
            "n": ">= 0",
            "size": ">= 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kretprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array.",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array.",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kretprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:page_offline_freeze": {
        "description": "Used by drivers that care about races when setting a page PageOffline().",
        "pre": {
            "page_offline_rwsem": "!=null"
        }
    }
},

{
    "kretprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "ret": "in [-ENOSPC, -EIO]"
        }
    }
},
{
    "kprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        }
    }
},
{
    "kretprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "sync_mode": "in [WB_SYNC_ALL]"
        }
    }
},
{
    "kprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback on mapping dirty pages in range",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "sync_mode": "in [WB_SYNC_ALL]"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:filemap_flush": {
        "description": "Mostly a non-blocking flush",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:filemap_flush": {
        "description": "Mostly a non-blocking flush",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:filemap_range_has_page": {
        "description": "Check if a page exists in range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_range_has_page": {
        "description": "Check if a page exists in range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_range": {
        "description": "Wait for writeback to complete for the given address space in the specified range.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">=start_byte"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Wait for writeback to complete in the given range of the address space.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Wait for writeback to complete.",
        "pre": {
            "mapping": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:file_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "file": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kprobe:file_fdatawait_range": {
        "description": "Wait for writeback to complete",
        "pre": {
            "file": "!=null",
            "start_byte": "!=null",
            "end_byte": "!=null"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors in the given address space.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors in the given address space.",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "mapping": "!=null",
            "lstart": "!=null",
            "lend": "!=null"
        }
    }
},
{
    "kretprobe:file_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive.",
        "pre": {
            "file": "!=null",
            "lstart": "!=null",
            "lend": "!=null",
            "lend": ">= lstart"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kprobe:file_write_and_wait_range": {
        "description": "Write out & wait on a file range",
        "pre": {
            "file": "!=null",
            "lstart": "!=null",
            "lend": "!=null",
            "lend": ">= lstart"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kretprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kretprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock for two mappings.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock for two mappings.",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},


{
    "kretprobe:folio_unlock": {
        "description": "Unlock a locked folio. Unlocks the folio and wakes up any thread sleeping on the page lock.",
        "pre": {
            "folio": "!=null"
        },
        "context": {
            "interrupt": true,
            "process": true,
            "nmi": false
        }
    }
},
{
    "kprobe:folio_unlock": {
        "description": "Unlock a locked folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 to be cleared on a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kretprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null",
            "index - return >= max_scan": "true"
        }
    }
},
{
    "kprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "max_scan": "!=null"
        }
    }
},
{
    "kretprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "fgp_flags": "in [0, FGP_ACCESSED, FGP_LOCK, FGP_CREAT, FGP_FOR_MMAP, FGP_WRITE, FGP_NOF FGP_NOWAIT, FGP_STABLE]",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "fgp_flags": "in [0, FGP_ACCESSED, FGP_LOCK, FGP_CREAT, FGP_FOR_MMAP, FGP_WRITE, FGP_NOF FGP_NOWAIT, FGP_STABLE]",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "fbatch": "!=null"
        }
    }
},
{
    "kprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": "!=null",
            "fbatch": "!=null"
        }
    }
},
{
    "kretprobe:generic_file_read_iter": {
        "description": "generic filesystem read routine",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        }
    }
},
{
    "kprobe:generic_file_read_iter": {
        "description": "generic filesystem read routine",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:page_cache_delete": {
        "description": "Delete a page from the page cache.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "shadow": "!=null",
            "mapping->host": "!=null",
            "mapping->host->i_mapping": "!=null",
            "mapping->host->i_mapping->nrpages": ">0",
            "folio->mapping": "==mapping",
            "folio->index": ">=0",
            "folio->index < mapping->host->i_mapping->nrpages",
            "folio->mapping->host": "==mapping->host",
            "folio->mapping->host->i_mapping": "==mapping->host->i_mapping",
            "folio->mapping->host->i_mapping->nrpages": "==mapping->host->i_mapping->nrpages",
            "shadow": "points to a valid shadow page"
        }
    }
},
{
    "kprobe:page_cache_delete": {
        "description": "Delete a page from the page cache.",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "shadow": "!=null"
        }
    }
},
{
    "kretprobe:filemap_map_pages": {
        "description": "Handle the fault in the filemap",
        "pre": {
            "!pte_none(ptep_get(vmf->pte))": true,
            "goto unlock": true
        }
    }
},
{
    "kprobe:filemap_map_pages": {
        "description": "Handle the fault",
        "pre": {
            "vmf": {
                "pte": {
                    "none": false
                }
            }
        }
    }
},
{
    "kretprobe:folio_mark_dirty": {
        "description": "Marks the folio as dirty.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:folio_wait_stable": {
        "description": "Waits for the folio to become stable.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:out:sb_end_pagefault": {
        "description": "Ends the page fault for the given mapping's host's superblock.",
        "pre": {
            "mapping": "!=null",
            "mapping->host": "!=null",
            "mapping->host->i_sb": "!=null"
        }
    },
    "kretprobe:return": {
        "description": "Returns the value of 'ret'.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kretprobe:generic_file_vm_ops": {
        "description": "Defines the virtual memory operations for generic file operations.",
        "pre": {}
    }
},
{
    "kprobe:folio_mark_dirty": {
        "description": "Marks the folio as dirty.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:folio_wait_stable": {
        "description": "Waits for the folio to become stable.",
        "pre": {
            "folio": "!=null"
        }
    },
    "kprobe:sb_end_pagefault": {
        "description": "Ends the page fault for the superblock of the mapping's host.",
        "pre": {
            "mapping->host->i_sb": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Returns the value of ret.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:generic_file_readonly_mmap": {
        "description": "This is for filesystems which do not implement ->writepage.",
        "pre": {
            "file": "!=null",
            "vma": "!=null",
            "file->f_mapping->a_ops->read_folio": "!=null"
        }
    }
},
{
    "kprobe:generic_file_readonly_mmap": {
        "description": "Maps a file into memory for read-only access.",
        "pre": {
            "file": "!=null",
            "vma": "!=null",
            "file->f_mapping": "!=null",
            "mapping->a_ops->read_folio": "==false"
        }
    }
},
{
    "kretprobe:filemap_page_mkwrite": {
        "description": "Handles page faults during write operations on file-backed memory mappings.",
        "pre": {},
        "post": {
            "return": "==VM_FAULT_SIGBUS"
        }
    }
},
{
    "kprobe:filemap_page_mkwrite": {
        "description": "Handles page faults for writeable mappings of file-backed memory.",
        "pre": {
            "vmf": "!=null"
        },
        "post": {
            "return": "in [VM_FAULT_SIGBU VM_FAULT_NOPAGE, VM_FAULT_LOCKED, VM_FAULT_RETRY, VM_FAULT_FALLBACK, VM_FAULT_MAJOR, VM_FAULT_WRITE, VM_FAULT_HWPOISON, VM_FAULT_SIGSEGV, VM_FAULT_OOM, VM_FAULT_SIGBUS]"
        }
    }
},
{
    "kretprobe:return ERR_PTR(err);}goto filler;}if (folio_test_uptodate(folio))goto out;if (!folio_trylock(folio))": {
        "description": "This function returns an error pointer if there is an error (ERR_PTR(err)). It then goes to the 'filler' label. If the 'folio' is up-to-date, it goes to the 'out' label. If 'folio' cannot be locked, it continues execution.",
        "pre": {
            "err": "!=null",
            "folio": "!=null",
            "folio_test_uptodate(folio)": "true",
            "folio_trylock(folio)": "false"
        }
    }
},
{
    "return ERR_PTR(err);}goto filler;}if (folio_test_uptodate(folio))goto out;if (!folio_trylock(folio))": {
        "pre": {
            "mapping": "!=null",
            "index": "any",
            "filler": "!=null",
            "file": "any",
            "gfp": "any"
        }
    }
},
{
    "kretprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags.",
        "pre": {
            "mapping": "!=null",
            "index": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:kiocb_invalidate_pages": {
        "description": "Invalidate pages and return the number of written bytes.",
        "pre": {
            "iocb": "!=null"
        }
    }
},

{
    "kretprobe:__generic_file_write_iter": {
        "description": "Write data to a file",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:__generic_file_write_iter": {
        "description": "Write data to a file",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio.",
        "pre": {
            "folio": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio.",
        "pre": {
            "folio": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:last_addr = phys_addr + size - 1;if (!size || last_addr < phys_addr)return NULL;/* Page-align mappings": {
        "description": "Disallow wrap-around or zero size",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "last_addr": "!=null",
            "size": "!=0",
            "last_addr < phys_addr": "true"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Disallow wrap-around or zero size",
        "pre": {
            "phys_addr": "!=null",
            "size": "!=null",
            "prot": "!=null"
        }
    }
},
{
    "kretprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null",
            "vma->vm_flags": "in [VM_IO | VM_PFNMAP]",
            "return": ">=0"
        }
    }
},
{
    "kprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address",
        "pre": {
            "vma": "!=null",
            "address": "!=null",
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc": {
        "description": "Allocate memory using vmalloc.",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "gfp_mask": "& ~__GFP_HIGHMEM == gfp_mask"
        }
    }
},
{
    "kprobe:__vmalloc": {
        "description": "Allocate virtual memory with specified size and flags.",
        "pre": {
            "size": "!=null",
            "gfp_mask": "!=null",
            "gfp_mask": "not in [__GFP_HIGHMEM]"
        }
    }
},


{
    "kretprobe:vmalloc_node_range": {
        "description": "Allocate virtually contiguous memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:__vmalloc_node": {
        "description": "Allocate virtually contiguous memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "gfp_mask": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:__vmalloc_user_flags": {
        "description": "Allocate virtually contiguous memory with user flags.",
        "pre": {
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:vmalloc_user": {
        "description": "Allocate virtually contiguous memory for user.",
        "pre": {
            "size": "!=null"
        }
    },
    "kretprobe:vmalloc_to_page": {
        "description": "Convert virtual address to page.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kretprobe:vmalloc_to_pfn": {
        "description": "Convert virtual address to page frame number.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kretprobe:vread_iter": {
        "description": "Read data from memory using an iterator.",
        "pre": {
            "iter": "!=null",
            "addr": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_node_range": {
        "description": "Allocate virtually contiguous memory with specified range and node.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kprobe:__vmalloc_node": {
        "description": "Allocate virtually contiguous memory with specified node.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "gfp_mask": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    },
    "kprobe:__vmalloc_user_flags": {
        "description": "Allocate virtually contiguous memory with specified flags for user space.",
        "pre": {
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:vmalloc_user": {
        "description": "Allocate virtually contiguous memory for user space.",
        "pre": {
            "size": "!=null"
        }
    },
    "kprobe:vmalloc_to_page": {
        "description": "Convert virtual address to corresponding page structure.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kprobe:vmalloc_to_pfn": {
        "description": "Convert virtual address to corresponding page frame number.",
        "pre": {
            "addr": "!=null"
        }
    },
    "kprobe:vread_iter": {
        "description": "Read data from memory to an iterator.",
        "pre": {
            "iter": "!=null",
            "addr": "!=null",
            "count": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc_node_range": {
        "description": "Allocate a range of virtually contiguous kernel memory.",
        "pre": {
            "size": "!=null",
            "align": "!=null",
            "start": "!=null",
            "end": "!=null",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": "!=null",
            "node": "!=null",
            "caller": "!=null"
        }
    }
},



{
    "kretprobe:usercopy_abort": {
        "description": "__check_object_size() function. Normal stack buffer usage should never trip the check and kernel text addressing will always trip the check. For cache object it is checking that only the whitelisted range of bytes for a given cache is being accessed (via the cache's usersize and useroffset fields). To adjust a cache whitelist, use the usercopy-aware kmem_cache_create_usercopy() function to create the cache (and carefully audit the whitelist range).",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "in [true, false]",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:usercopy_abort": {
        "description": "__noreturn usercopy_abort function",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "in [true, false]",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:kasan_reset_tag": {
        "description": "Reset the KASAN tag for the given address.",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": ">=0",
            "init": "in [true, false]",
            "shadow_start": "!=null",
            "shadow_end": "!=null",
            "kasan_arch_is_ready()": "true"
        }
    }
},
{
    "kprobe:kasan_reset_tag": {
        "description": "Reset the KASAN tag for the given address.",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": ">=0",
            "init": "in [true, false]",
            "shadow_start": "!=null",
            "shadow_end": "!=null",
            "kasan_arch_is_ready()": "true"
        }
    }
},

{
    "kprobe:__kasan_kmalloc": {
        "description": "Allocate memory using kmalloc with KASAN (Kernel Address Sanitizer) enabled.",
        "pre": {
            "cache": "!=null",
            "object": "!=null",
            "size": "!=null",
            "flags": "!=null",
            "redzone_start": "!=null",
            "redzone_end": "!=null",
            "gfpflags_allow_blocking(flags)": "true",
            "object == NULL": "false",
            "is_kfence_address(kasan_reset_tag(object))": "false"
        }
    }
},
{
    "kretprobe:kmsan_copy_page_meta": {
        "description": "Copy page metadata from source page to destination page.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "!kmsan_enabled": "true",
            "!kmsan_in_runtime()": "true",
            "!page_has_metadata(dst)": "false",
            "!page_has_metadata(src)": "false"
        }
    }
},
{
    "kprobe:kmsan_copy_page_meta": {
        "description": "Copy page metadata from source page to destination page.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "!kmsan_enabled": "false",
            "!kmsan_in_runtime()": "false",
            "!page_has_metadata(dst)": "false",
            "!page_has_metadata(src)": "false"
        }
    }
},
{
    "kretprobe:false);}EXPORT_SYMBOL(__msan_metadata_ptr_for_load_n": {
        "description": "Retrieve the metadata pointer for a load operation.",
        "pre": {
            "addr": "!=null",
            "size": ">0"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},



{
    "kretprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "pre": {
            "addr": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:__msan_memmove": {
        "description": "The __msan_memmove function copies n bytes from memory area src to memory area dst.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();kmsan_internal_memmove_metadata(dst, (void *)src, n);kmsan_leave_runtime();set_retval_metadata(shadow, origin);return result;}EXPORT_SYMBOL(__msan_memmove": {
        "description": "__msan_memmove function",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": "!=null"
        }
    }
},
{
    "kretprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();/* Using memmove instead of memcpy doesn't affect correctness. `": {
        "description": "The kretprobe function returns the value of 'result' after performing some checks.",
        "pre": {
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true",
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:return result;if (!kmsan_enabled || kmsan_in_runtime())return result;kmsan_enter_runtime();/* Using memmove instead of memcpy doesn't affect correctness. `": {
        "description": "This function returns the result after performing some operations related to memory copying.",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},


{
    "kretprobe:__msan_chain_origin": {
        "description": "Chain the origin of the depot stack handle.",
        "pre": {
            "origin": "!=null"
        }
    }
},
{
    "kprobe:kmsan_enter_runtime": {
        "description": "Enter the KMSAN runtime.",
        "pre": {}
    },
    "kprobe:kmsan_internal_chain_origin": {
        "description": "Internal function to chain the origin.",
        "pre": {
            "origin": "!=null"
        }
    },
    "kprobe:kmsan_leave_runtime": {
        "description": "Leave the KMSAN runtime.",
        "pre": {}
    },
    "kprobe:user_access_restore": {
        "description": "Restore user access flags.",
        "pre": {
            "ua_flags": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return the value of ret.",
        "pre": {
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:if (IS_ENABLED(CONFIG_UNWINDER_FRAME_POINTER))entries[3] = (u64)__builtin_return_address(1);elseentries[3] = 0;/* stack_depot_save() may allocate memory. `": {
        "description": "With frame pointers enabled, it is possible to quickly fetch the second frame of the caller stack without calling the unwinder. Without them, simply do not bother.",
        "pre": {
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true",
            "ua_flags": "!=null",
            "entries[0]": "==KMSAN_ALLOCA_MAGIC_ORIGIN",
            "entries[1]": "!=null",
            "entries[2]": "!=null"
        }
    }
},
{
    "kprobe:if (IS_ENABLED(CONFIG_UNWINDER_FRAME_POINTER))entries[3] = (u64)__builtin_return_address(1);elseentries[3] = 0;/* stack_depot_save() may allocate memory. `": {
        "description": "The given function condition",
        "pre": {
            "entries[0]": "== KMSAN_ALLOCA_MAGIC_ORIGIN",
            "entries[1]": "!= null",
            "entries[2]": "!= null",
            "entries[3]": "in [0, (u64)__builtin_return_address(1)]"
        }
    }
},
{
    "kretprobe:__msan_unpoison_alloca": {
        "description": "Unpoison memory allocated on the stack.",
        "pre": {
            "address": "!=null",
            "size": "!=null",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime": "==false"
        }
    }
},



{
    "kretprobe:copy_to_user": {
        "description": "Copy data from kernel space to user space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "to_copy": ">=0",
            "left": ">=0",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true"
        }
    }
},
{
    "kprobe:copy_to_user": {
        "description": "Copy data from kernel space to user space.",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "to_copy": ">=0",
            "left": ">=0",
            "kmsan_enabled": "==true",
            "kmsan_in_runtime()": "==true"
        }
    }
},
{
    "kretprobe:kmsan_internal_poison_memory": {
        "description": "Poison memory at the given address with the specified size and flags.",
        "pre": {
            "address": "!=null",
            "size": ">0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:kmsan_internal_poison_memory": {
        "description": "Poison memory at the given address with the specified size and flags.",
        "pre": {
            "address": "!=null",
            "size": ">0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:kmsan_internal_unpoison_memory": {
        "description": "Unpoison memory at the given address with the specified size.",
        "pre": {
            "address": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:kmsan_internal_unpoison_memory": {
        "description": "Unpoison the memory at the given address with the specified size.",
        "pre": {
            "address": "!=null",
            "size": "!=null"
        }
    }
},



{
    "kprobe:invalidate_mapping_pages": {
        "description": "Invalidates the mapping pages associated with a block device.",
        "pre": {
            "mapping": "!=null",
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_mapping": "!=null",
            "bdev->bd_inode->i_mapping->nrpages": ">0"
        }
    }
},
{
    "kretprobe:set_blocksize": {
        "description": "Set the block size for a block device.",
        "pre": {
            "bdev": "!=null",
            "size": {
                ">": "PAGE_SIZE",
                "<": 512,
                "!is_power_of_2": "size"
            }
        }
    }
},
{
    "kprobe:set_blocksize": {
        "description": "Set the block size for a block device.",
        "pre": {
            "bdev": "!=null",
            "size": {
                ">": "PAGE_SIZE",
                "<": 512,
                "!is_power_of_2": "size"
            }
        }
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block.",
        "pre": {
            "sb": "!=null",
            "size": ">= 512 && <= PAGE_SIZE",
            "sb->s_bdev": "!=null"
        },
        "post": {
            "sb->s_blocksize": "= size",
            "sb->s_blocksize_bits": "= blksize_bits(size)"
        }
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block.",
        "pre": {
            "sb": "!=null",
            "size": "is power of two",
            "size": ">= 512",
            "size": "<= PAGE_SIZE"
        }
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block",
        "pre": {
            "set_blocksize(sb->s_bdev, size)": "==0",
            "size": "is_power_of_two(size) && size >= 512 && size <= PAGE_SIZE"
        }
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Set the block size of the super block",
        "pre": {
            "sb": "!=null",
            "size": "is_power_of_two",
            "size_value": ">=512 && <=PAGE_SIZE",
            "blksize_bits(size)": "valid_value"
        }
    }
},




{
    "kretprobe:blkdev_get_by_dev": {
        "description": "Get the block device by device number",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "holder": "!=null",
            "hops": "!=null"
        },
        "post": {
            "return": {
                "type": "struct block_device",
                "constraints": [
                    {
                        "type": "reference",
                        "value": "!=ERR_PTR(-errno)"
                    }
                ]
            }
        }
    }
},
{
    "kprobe:blkdev_get_by_dev": {
        "description": "Get the block_device associated with the given device.",
        "pre": {
            "dev": "!=null",
            "mode": "!=null",
            "holder": "!=null",
            "hops": "!=null"
        },
        "post": {
            "return": "in [block_device, ERR_PTR(-errno)]"
        },
        "context": "Might sleep"
    }
},
{
    "kretprobe:blkdev_put_no_open": {
        "description": "Release the block device and decrement the reference count.",
        "pre": {
            "bdev": "!=null",
            "atomic_dec_and_test(&bdev->bd_openers)": "true",
            "blkdev_flush_mapping(bdev)": "called if atomic_dec_and_test(&bdev->bd_openers) returns true",
            "bdev->bd_disk->fops->release": "called if bdev->bd_disk->fops->release is not null"
        }
    }
},
{
    "kprobe:blkdev_put_no_open": {
        "description": "Release a block device without opening it.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_device.kobj": "!=null",
            "!kobject_get_unless_zero(&bdev->bd_device.kobj)": "true",
            "inode": "!=null"
        },
        "post": {
            "return": "bdev"
        }
    }
},
{
    "kretprobe:if (atomic_read(&bdev->bd_openers) == 1)sync_blockdev(bdev);mutex_lock(&disk->open_mutex);if (holder)bd_end_claim(bdev, holder);/* * Trigger event checking and tell drivers to flush MEDIA_CHANGE * event.  This is to ensure detection of media removal commanded * from userland - e.g. eject(1). ": {
        "description": "This function performs various operations related to block devices and media change events.",
        "pre": {
            "atomic_read(&bdev->bd_openers)": "== 1",
            "sync_blockdev(bdev)": "called",
            "mutex_lock(&disk->open_mutex)": "called",
            "holder": "null or not null",
            "bd_end_claim(bdev, holder)": "called if holder is not null"
        }
    }
},
{
    "kprobe:if (atomic_read(&bdev->bd_openers) == 1)sync_blockdev(bdev);mutex_lock(&disk->open_mutex);if (holder)bd_end_claim(bdev, holder);/* * Trigger event checking and tell drivers to flush MEDIA_CHANGE * event.  This is to ensure detection of media removal commanded * from userland - e.g. eject(1). `": {
        "description": "This function performs various operations related to block devices and media change events.",
        "pre": {
            "atomic_read(&bdev->bd_openers)": "== 1",
            "sync_blockdev(bdev)": "called",
            "mutex_lock(&disk->open_mutex)": "called",
            "holder": "null or not null",
            "bd_end_claim(bdev, holder)": "called if holder is not null"
        }
    }
},
{
    "kretprobe:__invalidate_device": {
        "description": "__invalidate_device function",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "bool",
            "sb": "get_super(bdev)",
            "res": "int",
            "sb != null": true,
            "res == 0": true
        }
    }
},
{
    "kprobe:__invalidate_device": {
        "description": "Invalidate the device and its associated super block.",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "bool",
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished.",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished.",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_sb": "!=null",
            "bdev->bd_inode->i_sb->s_bdev": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue->flush_fn": "!=null"
        }
    }
},
{
    "kprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_sb": "!=null",
            "bdev->bd_inode->i_sb->s_bdev": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue": "!=null",
            "bdev->bd_inode->i_sb->s_bdev->bd_disk->queue->flush_fn": "!=null"
        }
    }
},
{
    "kretprobe:struct_bio_set_fs_bio_set": {
        "description": "Conditions for struct bio_set fs_bio_set",
        "pre": {
            "fs_bio_set": "!=null",
            "bio_pool": "!=null",
            "iovec_pool": "!=null"
        }
    }
},
{
    "kprobe:fs_bio_set": {
        "description": "The bio_set containing bio and iovec memory pools used by IO code that does not need private memory pools.",
        "pre": {
            "fs_bio_set": "!=null"
        }
    }
},


{
    "kretprobe:bio_reset": {
        "description": "Reset the given bio structure.",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "in [BLK_OP_READ, BLK_OP_WRITE, BLK_OP_DISCARD, BLK_OP_FLUSH]"
        }
    }
},
{
    "kprobe:bio_reset": {
        "description": "Reset the fields of a bio structure.",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "in [READ, WRITE, READA, FLUSH, DISCARD, WRITE_SAME, WRITE_ZEROE WRITE_SAME_UNMAP]"
        }
    }
},
{
    "kretprobe:bio_chain": {
        "description": "Chain bio completions",
        "pre": {
            "bio": "!=null",
            "parent": "!=null",
            "bio->bi_private": "==null",
            "bio->bi_end_io": "==null"
        }
    }
},
{
    "kprobe:bio_chain": {
        "description": "Chain bio completions",
        "pre": {
            "bio": "!=null",
            "parent": "!=null",
            "bio.bi_private": "==null",
            "bio.bi_end_io": "==null"
        }
    }
},
{
    "kretprobe:bio_kmalloc": {
        "description": "kmalloc a bio",
        "pre": {
            "nr_vecs": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:bio_kmalloc": {
        "description": "kmalloc a bio",
        "pre": {
            "nr_vecs": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:bvec_alloc_gfp": {
        "description": "Make the first allocation restricted and don't dump info on allocation failure since we'll fall back to the mempool in case of failure.",
        "pre": {
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:bvec_alloc_gfp": {
        "description": "Allocate memory for a bio vector with a given GFP flag.",
        "pre": {
            "gfp": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:bio_init_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kprobe:bio_init_clone": {
        "description": "Clone a bio that shares the original bio's biovec.",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:bio_add_pc_page": {
        "description": "Attempt to add page to passthrough bio",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:bio_add_pc_page": {
        "description": "Attempt to add page to passthrough bio",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:__bio_add_page": {
        "description": "Add page(s) to a bio in a new segment.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kprobe:__bio_add_page": {
        "description": "Add page(s) to a bio in a new segment.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kretprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio.",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": ">=0",
            "off": ">=0",
            "len": "<=UINT_MAX",
            "off": "<=UINT_MAX"
        }
    }
},
{
    "kprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio.",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": "!=null",
            "off": "!=null",
            "len": "<= UINT_MAX",
            "off": "<= UINT_MAX"
        }
    }
},
{
    "kretprobe:submit_bio_wait": {
        "description": "Submit a bio and wait until it completes.",
        "pre": {
            "bio": "!=null",
            "bio->bi_private": "!=null"
        },
        "post": {
            "return": "in [0, bio_endio_error_code]"
        }
    }
},
{
    "kprobe:submit_bio_wait": {
        "description": "Submit a bio and wait until it completes.",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:bio_split": {
        "description": "Split a bio",
        "pre": {
            "bio": "!=null",
            "sectors": "!=null",
            "gfp": "!=null",
            "bs": "!=null"
        }
    }
},
{
    "kprobe:bio_split": {
        "description": "Split a bio",
        "pre": {
            "bio": "!=null",
            "sectors": ">=0",
            "gfp": ">=0",
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:bioset_exit": {
        "description": "Exit function for bioset",
        "pre": {
            "bs": "!=null",
            "bs": "allocated with kzalloc()",
            "bs": "zeroed but uninitialized"
        }
    }
},
{
    "kprobe:bioset_exit": {
        "description": "Exit function for bioset",
        "pre": {
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:disk_check_media_change": {
        "description": "Check if a removable media has been changed",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:disk_check_media_change": {
        "description": "Check if a removable media has been changed.",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_map_integrity_sg": {
        "description": "Map integrity metadata into a scatterlist",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_map_integrity_sg": {
        "description": "Map integrity metadata into a scatterlist",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null"
        }
    }
},
{
    "kretprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        }
    }
},
{
    "kretprobe:blk_integrity_register": {
        "description": "Register a gendisk as being integrity-capable",
        "pre": {
            "disk": "!=null",
            "template": "!=null"
        }
    }
},

{
    "kretprobe:blk_integrity_unregister": {
        "description": "Unregister block integrity profile",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_unregister": {
        "description": "Unregister block integrity profile",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_pm_runtime_init": {
        "description": "Block layer runtime PM initialization routine",
        "pre": {
            "q": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:blk_pm_runtime_init": {
        "description": "Block layer runtime PM initialization routine",
        "pre": {
            "q": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_suspend": {
        "description": "Pre runtime suspend check",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_pre_runtime_suspend": {
        "description": "Pre runtime suspend check",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing",
        "pre": {
            "q": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing",
        "pre": {
            "q": "!=null",
            "err": "!=null"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_resume": {
        "description": "Pre runtime resume processing",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_pre_runtime_resume": {
        "description": "Pre runtime resume processing",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_post_runtime_resume": {
        "description": "Performs the real work of restarting the queue after runtime resume.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_post_runtime_resume": {
        "description": "Performs the real work of restarting the queue after runtime resume.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio",
        "pre": {
            "bio": "!=null",
            "gfp_mask": "!=null",
            "nr_vecs": ">=0"
        }
    }
},
{
    "kprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio",
        "pre": {
            "bio": "!=null",
            "gfp_mask": "!=null",
            "nr_vecs": ">=0"
        }
    }
},
{
    "kretprobe:bio_integrity_add_page": {
        "description": "Attach a page containing integrity metadata to bio.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:bio_integrity_add_page": {
        "description": "Attach integrity metadata to bio by updating the page.",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO",
        "pre": {
            "bio": "!=null",
            "bio->bi_integrity": "==null",
            "bio->bi_data_dir": "in [WRITE, READ]",
            "bio->bi_bdev": "!=null",
            "bio->bi_sector": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO",
        "pre": {
            "bio": "!=null",
            "bio->bi_integrity": "==null",
            "bio->bi_data_dir": "in [WRITE, READ]",
            "bio->bi_bdev": "!=null",
            "bio->bi_sector": "!=null"
        }
    }
},
{
    "kretprobe:bio_integrity_trim": {
        "description": "Trim integrity vector",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_trim": {
        "description": "Trim integrity vector",
        "pre": {
            "bio": "!=null"
        }
    }
},


{
    "kretprobe:__blkdev_issue_zeroout": {
        "description": "Generate number of zero-filled write bios for block device.",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">0",
            "gfp_mask": ">=0",
            "biop": "!=null",
            "flags": "in [BLKDEV_ZERO_NOUNMAP, BLKDEV_ZERO_NOFALLBACK]"
        }
    }
},
{
    "kprobe:__blkdev_issue_zeroout": {
        "description": "Zero-fill a block range, either using hardware offload or by explicitly writing zeroes to the device.",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp_mask": ">=0",
            "biop": "!=null",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:blkdev_issue_secure_erase": {
        "description": "Issue a secure erase command to the block device.",
        "pre": {
            "bdev": "!=null",
            "sector": "!=null",
            "nr_sects": "!=null",
            "gfp": "!=null",
            "bs_mask": "= (bdev_logical_block_size(bdev) >> 9) - 1",
            "max_sectors": "= bdev_max_secure_erase_sectors(bdev)",
            "bio": "=null",
            "plug": "=null",
            "ret": "=0",
            "max_sectors": "> (UINT_MAX >> SECTOR_SHIFT)",
            "max_sectors": "= UINT_MAX >> SECTOR_SHIFT",
            "max_sectors": "&= ~bs_mask",
            "max_sectors": "== 0",
            "return": "-EOPNOTSUPP",
            "(sector | nr_sects)": "& bs_mask",
            "return": "-EINVAL",
            "bdev_read_only(bdev)": "== true",
            "return": "-EPERM"
        }
    }
},
{
    "kprobe:blkdev_issue_secure_erase": {
        "description": "Issue a secure erase command to the block device.",
        "pre": {
            "bdev": "!=null",
            "sector": "!=null",
            "nr_sects": "!=null",
            "gfp": "!=null",
            "bs_mask": "((bdev_logical_block_size(bdev) >> 9) - 1)",
            "max_sectors": "bdev_max_secure_erase_sectors(bdev)",
            "bio": "null",
            "plug": "null",
            "ret": "0",
            "max_sectors_check": "max_sectors > (UINT_MAX >> SECTOR_SHIFT)",
            "max_sectors_update": "max_sectors = UINT_MAX >> SECTOR_SHIFT",
            "max_sectors_mask": "max_sectors &= ~bs_mask",
            "max_sectors_zero_check": "max_sectors == 0",
            "sector_nr_sects_mask_check": "(sector | nr_sects) & bs_mask",
            "bdev_read_only_check": "bdev_read_only(bdev)"
        }
    }
},
{
    "kretprobe:ioc_lookup_icq": {
        "description": "Lookup io_cq from ioc",
        "pre": {
            "q": "!=null",
            "q->queue_lock": "held"
        }
    }
},
{
    "kprobe:ioc_lookup_icq": {
        "description": "Lookup io_cq from ioc",
        "pre": {
            "q": "!=null",
            "q->queue_lock": "held"
        }
    }
},
{
    "kretprobe:__register_blkdev": {
        "description": "Register a new block device",
        "pre": {
            "major": ">=1 and <=BLKDEV_MAJOR_MAX-1",
            "name": "!=null and unique within the system",
            "probe": "!=null"
        }
    }
},
{
    "kprobe:__register_blkdev": {
        "description": "Register a new block device",
        "pre": {
            "major": ">=1 && <=BLKDEV_MAJOR_MAX-1",
            "name": "!=null",
            "probe": "!=null"
        }
    }
},
{
    "kretprobe:device_add_disk": {
        "description": "Add disk information to kernel list",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kprobe:device_add_disk": {
        "description": "Add disk information to kernel list",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kretprobe:del_gendisk": {
        "description": "Delete the gendisk structure for the given disk.",
        "pre": {
            "disk": "!=null"
        },
        "post": {
            "disk": "==null"
        }
    }
},
{
    "kprobe:del_gendisk": {
        "description": "Delete a gendisk structure.",
        "pre": {
            "disk": "!=null"
        },
        "post": {
            "disk": "==null"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:invalidate_disk": {
        "description": "Invalidate the disk",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:invalidate_disk": {
        "description": "Invalidate the disk",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:set_disk_ro": {
        "description": "Set a gendisk read-only",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kprobe:set_disk_ro": {
        "description": "Set a gendisk read-only",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kretprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag.",
        "pre": {
            "flag": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_sync_queue": {
        "description": "This function does not cancel any asynchronous activity arising out of elevator or throttling code. That would require elevator_exit() and blkcg_exit_queue() to be called with queue lock initialized.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_sync_queue": {
        "description": "This function is responsible for synchronously queuing a block I/O request.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_put_queue": {
        "description": "Decrement the request_queue refcount and free it when the refcount reaches 0.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_put_queue": {
        "description": "Decrement the request_queue refcount and free it when the refcount reaches 0.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:__submit_bio_noacct": {
        "description": "Submit a bio without accounting.",
        "pre": {
            "bio": "!=null",
            "bio_list": "!=null",
            "bio_list_on_stack[0]": "!=null",
            "bio_list_on_stack[1]": "!=null"
        },
        "post": {
            "bio_list": "!=null",
            "bio_list_on_stack[0]": "!=null",
            "bio_list_on_stack[1]": "!=null"
        }
    }
},

{
    "kretprobe:blk_get_queue": {
        "description": "Increment the request_queue refcount",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": {
                "type": "pointer",
                "value": "q"
            }
        }
    }
},

{
    "kretprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "pre": {
            "plug": "!=null",
            "nr_ios": "!=null",
            "tsk": "!=null",
            "tsk->plug": "false",
            "plug->mq_list": "null",
            "plug->cached_rq": "null",
            "plug->nr_ios": "min_t(unsigned short, nr_io BLK_MAX_REQUEST_COUNT)",
            "plug->rq_count": "0",
            "plug->multiple_queues": "false",
            "plug->has_elevator": "false",
            "plug->nowait": "false",
            "INIT_LIST_HEAD(&plug->cb_list)": "null"
        }
    }
},
{
    "kprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "pre": {
            "plug": {
                "mq_list": "null",
                "cached_rq": "null",
                "nr_ios": "min_t(unsigned short, nr_io BLK_MAX_REQUEST_COUNT)",
                "rq_count": "0",
                "multiple_queues": "false",
                "has_elevator": "false",
                "nowait": "false",
                "cb_list": "INIT_LIST_HEAD"
            }
        }
    }
},


{
    "kretprobe:blk_start_plug": {
        "description": "Starts a block plug for efficient I/O batching.",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kprobe:blk_start_plug": {
        "description": "Starts a block plug for efficient I/O batching.",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kretprobe:__bio_split_to_limits": {
        "description": "Split a bio to fit the queue limits",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        }
    }
},
{
    "kprobe:__bio_split_to_limits": {
        "description": "Split a bio to fit the queue limits.",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        }
    }
},
{
    "kretprobe:WARN_ON(nsegs > blk_rq_nr_phys_segments(rq))": {
        "description": "Check if the number of segments is greater than the number of request's physical segments",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "sglist": "!=null",
            "last_sg": "!=null",
            "nsegs": ">=0",
            "rq->rq_flags": "!=null",
            "rq->special_vec": "!=null",
            "rq->bio": "!=null"
        }
    }
},
{
    "kprobe:WARN_ON(nsegs > blk_rq_nr_phys_segments(rq));return nsegs;}EXPORT_SYMBOL(__blk_rq_map_sg": {
        "description": "This function maps scatterlist segments to a request.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "sglist": "!=null",
            "last_sg": "!=null",
            "nsegs": ">= 0",
            "rq->rq_flags": "!=null",
            "rq->special_vec": "!=null",
            "rq->bio": "!=null"
        }
    }
},
{
    "kretprobe:init_opal_dev": {
        "description": "Initialize the opal_dev structure with the given data and send_recv functions.",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        },
        "post": {
            "return": "!=null",
            "dev->cmd": "!=null",
            "dev->resp": "!=null",
            "dev->unlk_lst": "initialized",
            "dev->dev_lock": "initialized",
            "dev->flags": "0",
            "dev->data": "data",
            "dev->send_recv": "send_recv",
            "check_opal_support(dev)": "== 0"
        }
    }
},
{
    "kprobe:init_opal_dev": {
        "description": "Initialize the opal_dev structure with the given data and send_recv functions.",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        }
    },
    "kprobe:kmalloc": {
        "description": "Allocate memory of size IO_BUFFER_LENGTH with GFP_KERNEL flag.",
        "pre": {
            "size": "IO_BUFFER_LENGTH",
            "flags": "GFP_KERNEL"
        }
    },
    "kprobe:goto": {
        "description": "Jump to the specified label if the condition is true.",
        "pre": {
            "condition": "err_free_dev",
            "label": "err_free_dev"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the opal_dev's unlk_lst field as an empty list.",
        "pre": {
            "list": "empty"
        }
    },
    "kprobe:mutex_init": {
        "description": "Initialize the opal_dev's dev_lock field as a mutex.",
        "pre": {
            "mutex": "initialized"
        }
    },
    "kprobe:check_opal_support": {
        "description": "Check if opal support is available for the given opal_dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:while (j < npages)bio_release_page(bio, pages[j++]);if (pages != stack_pages)kvfree(pages);/* couldn't stuff something into bio? `": {
        "description": "Release pages mapped into the bio.",
        "pre": {
            "j": "< npages",
            "bio": "!= null",
            "pages[j]": "!= null",
            "pages": "!= stack_pages"
        }
    }
},
{
    "kprobe:bio_release_page": {
        "description": "Release the pages mapped into the bio.",
        "pre": {
            "bio": "!=null",
            "pages": "!=null",
            "j": "< npages",
            "pages != stack_pages": "true",
            "pages != null": "true"
        }
    },
    "kprobe:kvfree": {
        "description": "Free the memory allocated for pages if they are not stack_pages.",
        "pre": {
            "pages": "!= stack_pages"
        }
    }
},


{
    "kretprobe:blk_rq_map_bio_alloc": {
        "description": "Allocate a bio and map it to the request queue.",
        "pre": {
            "rq": "!=null",
            "bio": "==null"
        },
        "post": {
            "bio": "!=null"
        }
    },
    "kretprobe:bio_iov_bvec_set": {
        "description": "Set the iov_iter of the bio to the provided iter.",
        "pre": {
            "bio": "!=null",
            "iter": "!=null"
        }
    },
    "kretprobe:blk_rq_bio_prep": {
        "description": "Prepare the bio for the request queue with the given number of segments.",
        "pre": {
            "rq": "!=null",
            "bio": "!=null",
            "nr_segs": ">=0"
        }
    }
},
{
    "kprobe:blk_rq_map_bio_alloc": {
        "description": "Allocate a bio and map it to a request.",
        "pre": {
            "rq": "!=null",
            "iter": "!=null"
        }
    },
    "kprobe:bio_iov_bvec_set": {
        "description": "Set the iov_iter for a bio.",
        "pre": {
            "bio": "!=null",
            "iter": "!=null"
        }
    },
    "kprobe:blk_rq_bio_prep": {
        "description": "Prepare a request with a bio.",
        "pre": {
            "rq": "!=null",
            "bio": "!=null",
            "nr_segs": ">=0"
        }
    }
},
{
    "kretprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests.",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": ">=0"
        }
    }
},
{
    "kretprobe:blk_set_stacking_limits": {
        "description": "Set default limits for stacking devices",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kprobe:blk_set_stacking_limits": {
        "description": "Set default limits for stacking devices",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue.",
        "pre": {
            "q": "!=null",
            "bounce": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue.",
        "pre": {
            "q": "!=null",
            "bounce": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue",
        "pre": {
            "q": "!=null",
            "chunk_sectors": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue.",
        "pre": {
            "q": "!=null",
            "chunk_sectors": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard.",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard.",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase.",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes.",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes.",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segment_size": {
        "description": "Enables a low level driver to set an upper limit on the size of a coalesced segment.",
        "pre": {
            "q": "!=null",
            "max_size": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_segment_size": {
        "description": "Set max segment size for blk_rq_map_sg",
        "pre": {
            "q": "!=null",
            "max_size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">= 512"
        }
    }
},
{
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">= 512"
        }
    }
},
{
    "kretprobe:blk_queue_physical_block_size": {
        "description": "Set physical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_physical_block_size": {
        "description": "Set physical block size for the queue",
        "pre": {
            "q": "!=null",
            "size": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset.",
        "pre": {
            "q": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset.",
        "pre": {
            "q": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:blk_limits_io_min": {
        "description": "Set minimum request size for a device",
        "pre": {
            "limits": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kprobe:blk_limits_io_min": {
        "description": "set minimum request size for a device",
        "pre": {
            "limits": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue",
        "pre": {
            "q": "!=null",
            "min": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue",
        "pre": {
            "q": "!=null",
            "min": ">=0"
        }
    }
},
{
    "kretprobe:blk_limits_io_opt": {
        "description": "set optimal request size for a device",
        "pre": {
            "limits": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:blk_limits_io_opt": {
        "description": "Set optimal request size for a device",
        "pre": {
            "limits": "!=null",
            "opt": "!=null",
            "optimal_io_size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue",
        "pre": {
            "q": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue",
        "pre": {
            "q": "!=null",
            "opt": "!=null"
        }
    }
},
{
    "kretprobe:blk_stack_limits": {
        "description": "Adjust queue_limits for stacked devices.",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": "!=null"
        }
    }
},
{
    "blk_stack_limits": {
        "description": "Adjust queue_limits for stacked devices",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": "!=null"
        }
    }
},
{
    "kretprobe:disk_stack_limits": {
        "description": "Adjust queue limits for stacked drivers",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:disk_stack_limits": {
        "description": "Adjust queue limits for stacked drivers.",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},

{
    "kprobe:blk_queue_max_segment_size": {
        "description": "Set the maximum segment size for the request queue.",
        "pre": {
            "q": "!=null",
            "max_size": "!=null"
        }
    },
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set the logical block size for the request queue.",
        "pre": {
            "q": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_dma_alignment": {
        "description": "set required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_dma_alignment": {
        "description": "Set required memory and length alignment for direct DMA transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_update_dma_alignment": {
        "description": "update required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_alignment": {
        "description": "update required memory and length alignment for direct dma transactions.",
        "pre": {
            "q": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth.",
        "pre": {
            "q": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth.",
        "pre": {
            "q": "!=null",
            "depth": ">=0"
        }
    }
},

{
    "kprobe:__blk_mq_alloc_requests": {
        "description": "Allocate requests for the given blk_mq_alloc_data structure.",
        "pre": {
            "data": "!=null",
            "data->q": "!=null",
            "data->q->q_usage_counter": "!=null",
            "nr": ">=1",
            "data->nr_tags": ">=nr",
            "data->cached_rq": "!=null"
        }
    }
},
{
    "kretprobe:if (force_irqthreads())return false;/* same CPU or cache domain?  Complete locally `": {
        "description": "Check if force_irqthreads() returns true and return false if it does.",
        "pre": {
            "force_irqthreads()": "== true"
        }
    }
},
{
    "kprobe:if (force_irqthreads())return false;/* same CPU or cache domain?  Complete locally `": {
        "description": "Check if force_irqthreads() returns true and return false if it does.",
        "pre": {
            "force_irqthreads()": "== true"
        }
    }
},
{
    "kretprobe:blk_mq_start_request": {
        "description": "Start processing a request",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_start_request": {
        "description": "Start processing a request",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blk_execute_rq_nowait": {
        "description": "Insert a fully prepared request at the back of the IO scheduler queue for execution. Don't wait for completion.",
        "pre": {
            "rq": "!=null",
            "at_head": "in [true, false]"
        }
    }
},
{
    "kprobe:blk_execute_rq_nowait": {
        "description": "Insert a request to IO scheduler for execution.",
        "pre": {
            "rq": "!=null",
            "at_head": "in [true, false]"
        }
    }
},
{
    "kretprobe:blk_mq_sched_requeue_request": {
        "description": "Requeue a request in the block multi-queue scheduler.",
        "pre": {
            "rq": "!=null",
            "q": "!=null",
            "rq->q": "==q",
            "rq->q->requeue_lock": "locked",
            "rq->queuelist": "not empty",
            "kick_requeue_list": "boolean"
        }
    }
},
{
    "kprobe:blk_mq_requeue_request": {
        "description": "Requeue a request in the IO scheduler queue.",
        "pre": {
            "rq": "!=null",
            "kick_requeue_list": "!=null",
            "q": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:if (rq->rq_flags & RQF_DONTPREP)": {
        "description": "Check if the RQF_DONTPREP flag is set in the request flags.",
        "pre": {
            "rq": "!=null",
            "rq_flags": "& RQF_DONTPREP != 0"
        }
    }
},
{
    "kprobe:blk_mq_requeue_work": {
        "description": "Requeue work for a request queue.",
        "pre": {
            "q": "!=null",
            "rq_list": "not empty",
            "flush_list": "not empty",
            "rq": "not null",
            "rq->rq_flags & RQF_DONTPREP": "is set"
        }
    }
},
{
    "kretprobe:blk_mq_hctx_next_cpu": {
        "description": "This function returns the next CPU to be used for the hardware context.",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_hctx_next_cpu": {
        "description": "Function to determine the next CPU for a hardware context in the blk-mq subsystem.",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kretprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously.",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously.",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kretprobe:blk_mq_stop_hw_queue": {
        "description": "Stop the hardware queue for the given blk_mq_hw_ctx.",
        "pre": {
            "hctx": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queue": {
        "description": "Stop the hardware queue associated with the given blk_mq_hw_ctx.",
        "pre": {}
    }
},
{
    "kretprobe:blk_mq_stop_hw_queues": {
        "description": "Stop hardware queues for the given request queue.",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queues": {
        "description": "Stop the hardware queues associated with the given request queue.",
        "pre": {}
    }
},
{
    "kretprobe:blk_mq_destroy_queue": {
        "description": "Shutdown a request queue",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_destroy_queue": {
        "description": "Shutdown a request queue",
        "pre": {
            "q": "!=null"
        }
    }
},




{
    "kretprobe:xen_alloc_unpopulated_pages": {
        "description": "alloc unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:xen_alloc_unpopulated_pages": {
        "description": "Allocates unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0 on succes error otherwise"
        }
    }
},
{
    "kretprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages.",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out.",
        "pre": {
            "nr_pages": "!=null",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_free_ballooned_pages": {
        "description": "Subtract `pgno` pages from `balloon_stats.target_unpopulated` and remove the remaining pages for accurate accounting.",
        "pre": {
            "pgno": "!=null",
            "pages": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:xen_free_ballooned_pages": {
        "description": "Subtract `pgno` pages from `target_unpopulated` and remove remaining pages for correct accounting.",
        "pre": {
            "pgno": "!=null",
            "pages": "!=null",
            "balloon_stats.target_unpopulated": "-= nr_pages - pgno"
        }
    }
},
{
    "kretprobe:st21nfca_hci_control_se": {
        "description": "Control the SE with the given parameters.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "in [NFC_SE_UICC, eSE]",
            "ST21NFCA_SE_MODE_ON": "!=null"
        },
        "post": {
            "r": "==ST21NFCA_ESE_HOST_ID"
        }
    }
},
{
    "kprobe:st21nfca_hci_control_se": {
        "description": "Control the SE with the given SE index.",
        "pre": {
            "hdev": "is_instance_of(struct nfc_hci_dev)",
            "se_idx": "is_instance_of(u32)"
        },
        "post": {
            "r": "== ST21NFCA_ESE_HOST_ID"
        }
    }
},
{
    "kretprobe:st21nfca_hci_disable_se": {
        "description": "Disable the SE with the given index in the ST21NFCA HCI device.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!=null",
            "se_idx": "==NFC_SE_UICC implies info->se_status->is_uicc_enable is true",
            "se_idx": "==NFC_SE_eSE implies info->se_status->is_ese_enable is true"
        },
        "post": {
            "r": ">=-1"
        }
    }
},
{
    "kprobe:st21nfca_hci_disable_se": {
        "description": "Disable the Secure Element (SE) with the given index.",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!=null",
            "se_idx": "== NFC_SE_UICC when info->se_status->is_uicc_enable is true",
            "se_idx": "== NFC_SE_eSE when info->se_status->is_ese_enable is true"
        }
    }
},
{
    "kretprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st21nfca_hci_se_io": {
        "description": "Free the memory allocated for cb_context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st21nfca_hci_se_io": {
        "description": "Free the memory allocated for the callback context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kretprobe:st21nfca_connectivity_event_received": {
        "description": "Connectivity event received",
        "pre": {
            "skb->len": "< 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG",
            "return": "-EPROTO",
            "aid_len": "skb->data[1]",
            "skb->len": "< aid_len + 4 || aid_len > sizeof(transaction->aid)",
            "return": "-EPROTO",
            "params_len": "skb->data[aid_len + 3]",
            "skb->data[2]": "== 0x82",
            "skb->data[aid_len + 4]": "<= skb->len"
        }
    }
},
{
    "kprobe:st21nfca_connectivity_event_received": {
        "description": "Connectivity event received",
        "pre": {
            "skb->len": "< 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG",
            "aid_len": "skb->len < aid_len + 4 || aid_len > sizeof(transaction->aid)",
            "params_len": "skb->data[aid_len + 3] != 82",
            "skb->len": "aid_len + 4 + params_len"
        }
    }
},
{
    "kretprobe:st21nfca_se_init": {
        "description": "Initialize the st21nfca_se_info structure",
        "pre": {
            "bwi_timer": "!=null",
            "se_active_timer": "!=null",
            "bwi_active": "false",
            "se_active": "false",
            "count_pipes": "0",
            "expected_pipes": "0",
            "xch_error": "false",
            "wt_timeout": "ST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI)"
        }
    }
},
{
    "kprobe:timer_setup": {
        "description": "Set up a timer.",
        "pre": {
            "timer": "!=null",
            "callback": "!=null",
            "data": "any"
        }
    },
    "kprobe:info->se_info.count_pipes": {
        "description": "Set the value of count_pipes.",
        "pre": {
            "count_pipes": "0"
        }
    },
    "kprobe:info->se_info.expected_pipes": {
        "description": "Set the value of expected_pipes.",
        "pre": {
            "expected_pipes": "0"
        }
    },
    "kprobe:info->se_info.xch_error": {
        "description": "Set the value of xch_error.",
        "pre": {
            "xch_error": "false"
        }
    },
    "kprobe:info->se_info.wt_timeout": {
        "description": "Set the value of wt_timeout.",
        "pre": {
            "wt_timeout": "ST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI)"
        }
    }
},
{
    "kretprobe:st21nfca_hci_probe": {
        "description": "Probe ST21NFCA HCI device",
        "pre": {
            "dev_mask": "!=null",
            "ST21NFCA_NUM_DEVICES": "!=null",
            "dev_num": "!=null",
            "dev_num": "< ST21NFCA_NUM_DEVICES"
        }
    }
},
{
    "kprobe:st21nfca_hci_probe": {
        "description": "Probe ST21NFCA HCI",
        "pre": {
            "dev_mask": "!=null",
            "ST21NFCA_NUM_DEVICES": "!=null",
            "dev_num": "!=null",
            "dev_num >= ST21NFCA_NUM_DEVICES": "true"
        }
    }
},
{
    "kretprobe:st21nfca_im_send_atr_req": {
        "description": "Send an ATR request using the ST21NFCA interface.",
        "pre": {
            "hdev": "!=null",
            "gb": "!=null",
            "gb_len": ">=0",
            "info": "!=null",
            "atr_req": "!=null",
            "target": "!=null",
            "size": ">=0",
            "skb": "!=null",
            "atr_req->cmd0": "==ST21NFCA_NFCIP1_REQ",
            "atr_req->cmd1": "==ST21NFCA_NFCIP1_ATR_REQ",
            "atr_req->did": "==0x0",
            "atr_req->bsi": "==0x00",
            "atr_req->bri": "==0x00",
            "atr_req->ppi": "==ST21NFCA_LR_BITS_PAYLOAD_SIZE_254B",
            "atr_req->length": "==sizeof(struct st21nfca_atr_req) + hdev->gb_len",
            "skb->data": "!=null",
            "skb->len": "==sizeof(struct st21nfca_atr_req) + gb_len + 1",
            "info->dep_info.to": "==ST21NFCA_DEFAULT_TIMEOUT",
            "info->dep_info.bri": "==atr_req->bri",
            "info->dep_info.bsi": "==atr_req->bsi",
            "info->async_cb_type": "==ST21NFCA_CB_TYPE_READER_F",
            "info->async_cb_context": "==info",
            "info->async_cb": "==st21nfca_im_recv_atr_res_cb"
        }
    }
},
{
    "kprobe:st21nfca_im_send_atr_req": {
        "description": "Send an ATR request using the ST21NFCA IM interface.",
        "pre": {
            "hdev": "!=null",
            "gb": "!=null",
            "gb_len": ">=0",
            "info": "!=null",
            "atr_req": "!=null",
            "target": "!=null",
            "size": ">=0",
            "skb": "!=null",
            "atr_req->cmd0": "==ST21NFCA_NFCIP1_REQ",
            "atr_req->cmd1": "==ST21NFCA_NFCIP1_ATR_REQ",
            "atr_req->did": "==0x0",
            "atr_req->bsi": "==0x00",
            "atr_req->bri": "==0x00",
            "atr_req->ppi": "==ST21NFCA_LR_BITS_PAYLOAD_SIZE_254B",
            "atr_req->length": "==sizeof(struct st21nfca_atr_req) + hdev->gb_len",
            "skb->data": "!=null",
            "skb->len": "==sizeof(struct st21nfca_atr_req) + gb_len + 1",
            "info->dep_info.to": "==ST21NFCA_DEFAULT_TIMEOUT",
            "info->dep_info.bri": "==atr_req->bri",
            "info->dep_info.bsi": "==atr_req->bsi",
            "info->async_cb_type": "==ST21NFCA_CB_TYPE_READER_F",
            "info->async_cb_context": "==info",
            "info->async_cb": "==st21nfca_im_recv_atr_res_cb",
            "info->dep_info.lri": "==ST21NFCA_PP2LRI(atr_req->ppi)",
            "skb->data[0]": "==info->dep_info.to | 0x10"
        }
    }
},
{
    "kretprobe:pn544_hci_probe": {
        "description": "Probe the pn544 HCI device.",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        }
    }
},
{
    "kprobe:pn544_hci_probe": {
        "description": "Probe the pn544 HCI device.",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        }
    }
},
{
    "kretprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st_nci_se_io": {
        "description": "Free the cb_context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kprobe:kfree(cb_context);return -ENODEV;}}EXPORT_SYMBOL(st_nci_se_io": {
        "description": "Free the memory allocated for the callback context and return -ENODEV.",
        "pre": {
            "cb_context": "!=null"
        }
    }
},
{
    "kretprobe:st_nci_se_init": {
        "description": "Initialize the st_nci_se_init function",
        "pre": {
            "ndev": "!=null",
            "se_status": "!=null"
        },
        "post": {
            "info": {
                "se_info": {
                    "bwi_timer": "!=null",
                    "bwi_active": "false",
                    "se_active_timer": "!=null",
                    "se_active": "false",
                    "xch_error": "false",
                    "wt_timeout": "ST_NCI_BWI_TO_TIMEOUT(ST_NCI_ATR_DEFAULT_BWI)",
                    "se_status": "se_status"
                }
            },
            "return": "0"
        }
    }
},

{
    "kretprobe:ndlc_open": {
        "description": "Toggle reset pin",
        "pre": {
            "ndlc": "!=null",
            "ndlc->ops": "!=null",
            "ndlc->ops->enable(ndlc->phy_id)": "called",
            "ndlc->powered": "==1",
            "return": "==0"
        }
    }
},



{
    "kretprobe:ndlc_send": {
        "description": "Add ndlc header to skb",
        "pre": {
            "ndlc": "!=null",
            "skb": "!=null"
        }
    }
},

{
    "kretprobe:ndlc_probe": {
        "description": "ndlc_probe function",
        "pre": {
            "ndlc": "!=null",
            "ndlc.ops": "phy_ops",
            "ndlc.phy_id": "phy_id",
            "ndlc.dev": "dev",
            "ndlc.powered": "0",
            "ndlc_id": "ndlc",
            "st_nci_probe": "ndlc, phy_headroom, phy_tailroom, se_status"
        }
    }
},
{
    "kprobe:ndlc_probe": {
        "description": "Probe function for ndlc",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "dev": "!=null",
            "phy_headroom": "!=null",
            "phy_tailroom": "!=null",
            "ndlc_id": "!=null",
            "se_status": "!=null"
        }
    }
},


{
    "kretprobe:tc_register_driver": {
        "description": "Register a new TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:tc_register_driver": {
        "description": "Register a new TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Retrieve the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": {
                "acl_node_mutex": "held"
            },
            "initiatorname": "!=null"
        }
    }
},
{
    "kprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Retrieve the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": {
                "acl_node_mutex": "held"
            },
            "initiatorname": "!=null"
        }
    }
},
{
    "kretprobe:kref_get": {
        "description": "Increments the reference count of the given kref object.",
        "pre": {
            "&acl->acl_kref": "!=null"
        }
    },
    "kretprobe:core_tpg_check_initiator_node_acl": {
        "description": "Checks the initiator node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:core_tpg_get_initiator_node_acl": {
        "description": "Gets the initiator node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:target_alloc_node_acl": {
        "description": "Allocates a node ACL for the given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kretprobe:tpg->se_tpg_tfo->tpg_check_demo_mode": {
        "description": "Checks if the given se_portal_group is in demo mode.",
        "pre": {
            "tpg": "!=null"
        }
    },
    "kretprobe:transport_free_session": {
        "description": "Frees the session and releases the reference to the dynamically generated node_acl.",
        "pre": {
            "session": "!=null"
        }
    }
},
{
    "kprobe:kref_get": {
        "description": "Increment the reference count of the kref object.",
        "pre": {
            "kref": "!=null"
        }
    },
    "kprobe:core_tpg_check_initiator_node_acl": {
        "description": "Check the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:core_tpg_get_initiator_node_acl": {
        "description": "Get the initiator node ACL for a given se_portal_group.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:target_alloc_node_acl": {
        "description": "Allocate a node ACL for a given se_portal_group and initiatorname.",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        }
    },
    "kprobe:tpg->se_tpg_tfo->tpg_check_demo_mode": {
        "description": "Check if the fabric is in demo mode for a given se_portal_group.",
        "pre": {
            "tpg": "!=null"
        }
    },
    "kprobe:transport_free_session": {
        "description": "Free the session and release the reference count of the node_acl.",
        "pre": {
            "session": "!=null"
        }
    }
},


{
    "kretprobe:core_tpg_set_initiator_node_tag": {
        "description": "Initiator nodeacl tags are not used internally, but may be used by userspace to emulate aliases or groups. Returns length of newly-set tag or -EINVAL.",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
        "post": {
            "return_value": "in [>=0, -EINVAL]"
        }
    }
},
{
    "kprobe:core_tpg_set_initiator_node_tag": {
        "description": "Set initiator nodeacl tags.",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
        "post": {
            "return": ">= -EINVAL"
        }
    }
},
{
    "kretprobe:core_tpg_register": {
        "description": "Register a target portal group with a given WWN.",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "int",
            "!se_tpg": "return -EINVAL",
            "se_tpg_tfo": "!=null"
        },
        "post": {
            "se_tpg_tfo": "!=null"
        }
    }
},
{
    "kprobe:core_tpg_register": {
        "description": "Register a target portal group with a given world wide name (WWN) and protocol ID.",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "int"
        },
        "post": {
            "ret": "int"
        }
    }
},



{
    "kprobe:spc_emulate_inquiry_std": {
        "description": "Set RMB (removable media) for tape devices",
        "pre": {
            "cmd": "!=null",
            "buf": "!=null",
            "cmd->se_lun": "!=null",
            "cmd->se_lun->lun_tpg": "!=null",
            "cmd->se_lun->lun_tpg->se_dev": "!=null",
            "cmd->se_sess": "!=null",
            "cmd->se_dev->transport": "!=null",
            "cmd->se_dev->transport->get_device_type(cmd->se_dev)": "== TYPE_TAPE",
            "buf[1]": "== 0x80",
            "buf[2]": "== 0x06"
        }
    }
},
{
    "kretprobe:spc_emulate_evpd_83": {
        "description": "No description provided.",
        "pre": {
            "dev": {
                "dev_flags": "& DF_EMULATED_VPD_UNIT_SERIAL == 0"
            }
        }
    }
},
{
    "kprobe:if (!(dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL))goto check_t10_vend_desc;": {
        "description": "Check if the DF_EMULATED_VPD_UNIT_SERIAL flag is not set in dev->dev_flags.",
        "pre": {
            "dev": {
                "dev_flags": "& ~DF_EMULATED_VPD_UNIT_SERIAL"
            }
        }
    }
},
{
    "kretprobe:spc_emulate_report_luns": {
        "description": "Emulate the REPORT LUNS command in the SPC-3 standard.",
        "pre": {
            "sess": "==null",
            "cmd": "!=null",
            "deve": "!=null",
            "nacl": "!=null",
            "slun": "!=null",
            "buf": "!=null",
            "lun_count": ">=0",
            "offset": ">=8",
            "len": "!=null"
        }
    }
},
{
    "kprobe:spc_emulate_report_luns": {
        "description": "Emulate the REPORT LUNS command in the SPC-3 standard.",
        "pre": {
            "cmd": "!=null",
            "cmd->se_sess": "!=null",
            "cmd->se_sess->se_node_acl": "!=null",
            "cmd->se_sess->se_node_acl->lun_entry_hlist": "!=null",
            "deve": "!=null",
            "&cmd->se_sess->se_node_acl->lun_entry_hlist": "!=null",
            "sess": "!=null",
            "nacl": "!=null",
            "slun": "!=null",
            "buf": "!=null",
            "lun_count": ">=0",
            "offset": ">=8",
            "len": "!=null"
        }
    }
},


{
    "kretprobe:transport_init_session": {
        "description": "Initialize a session object",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kprobe:transport_init_session": {
        "description": "Initialize a session object",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kretprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it.",
        "pre": {
            "sup_prot_ops": "!=null",
            "sup_prot_ops": "bitmask",
            "sup_prot_ops": "in [T10_PI_MODE1, T10_PI_MODE2, T10_PI_MODE3]"
        }
    }
},
{
    "kprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it.",
        "pre": {
            "sup_prot_ops": "!=null"
        }
    }
},
{
    "kretprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0"
        }
    }
},
{
    "kprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0"
        }
    }
},
{
    "if (se_nacl)": {
        "description": "Check if se_nacl is set for active se_session objects.",
        "pre": {
            "se_nacl": "!=null",
            "se_sess->se_tpg": "!=null",
            "se_sess->fabric_sess_ptr": "!=null"
        }
    }
},

{
    "kretprobe:target_setup_session": {
        "description": "Setup a session in the target",
        "pre": {
            "tag_num": "!= 0",
            "tag_size": "!= null",
            "prot_op": "!= null",
            "initiatorname": "!= null",
            "private": "!= null",
            "callback": "!= null"
        }
    },
    "kretprobe:transport_init_session_tags": {
        "description": "Initialize a session with tags",
        "pre": {
            "tag_num": "!= 0",
            "tag_size": "!= null",
            "prot_op": "!= null"
        }
    },
    "kretprobe:transport_alloc_session": {
        "description": "Allocate a session",
        "pre": {
            "tag_num": "== 0",
            "prot_op": "!= null"
        }
    },
    "kretprobe:IS_ERR": {
        "description": "Check if the session is an error",
        "pre": {
            "sess": "!= null"
        }
    }
},
{
    "kprobe:target_setup_session": {
        "description": "Setup a session in the target subsystem",
        "pre": {
            "tag_num": "!=0",
            "tag_size": "!=null",
            "prot_op": "!=null"
        }
    }
},
{
    "kretprobe:target_show_dynamic_sessions": {
        "description": "Function to show dynamic sessions in a target portal group.",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null",
            "se_sess": "!=null",
            "len": ">=0",
            "se_sess->se_node_acl": "!=null",
            "se_sess->se_node_acl->dynamic_node_acl": "!=null",
            "strlen(se_sess->se_node_acl->initiatorname) + 1 + len": "<=PAGE_SIZE"
        },
        "post": {
            "return": "len"
        }
    }
},
{
    "kprobe:}spin_unlock_bh(&se_tpg->session_lock);return len;}EXPORT_SYMBOL(target_show_dynamic_sessions": {
        "description": "This function is used to show dynamic sessions in a target portal group.",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null",
            "se_sess": "!=null",
            "len": ">=0",
            "se_sess->se_node_acl": "!=null",
            "se_sess->se_node_acl->dynamic_node_acl": "!=null",
            "strlen(se_sess->se_node_acl->initiatorname) + 1 + len": "<=PAGE_SIZE"
        }
    }
},






{
    "kretprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null",
            "page_83[1]": "& 0x30",
            "return_value": "unknown" 
        }
    }
},
{
    "kprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        }
    }
},
{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "Set the VPD identifier type.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
        "post": {
            "vpd->device_identifier_type": "= (page_83[1] & 0x0f)",
            "transport_dump_vpd_ident_type(vpd, NULL, 0)": "!=null"
        }
    }
},

{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
        "post": {
            "vpd->device_identifier_type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]"
        }
    }
},
{
    "kprobe:transport_set_vpd_ident_type": {
        "description": "Set the device identifier type in the VPD structure.",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        }
    }
},






{
    "kretprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "data_length": ">=0",
            "task_attr": ">=0",
            "data_dir": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd.",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "data_length": ">=0",
            "task_attr": ">=0",
            "data_dir": "in [0, 1]",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "!=null",
            "gfp": "!=null",
            "tag": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": "!=null",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "!=null",
            "gfp": "!=null",
            "tag": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:transport_get_sense_buffer": {
        "description": "Used when asking transport to copy Sense Data from the underlying LinuxSCSI struct scsi_cmnd",
        "pre": {
            "cmd": "!=null",
            "return_value": "!=null",
            "cmd->sense_reason": "valid_value"
        }
    }
},



{
    "kretprobe:transport_kmap_data_sg": {
        "description": "Transport kmap data scatterlist",
        "pre": {
            "cmd->t_data_nents": "==0",
            "sg": "!=null",
            "cmd->t_data_nents": "==1",
            "kmap(sg_page(sg)) + sg->offset": "!=null"
        }
    }
},
{
    "kprobe:transport_kmap_data_sg": {
        "description": "Map scatterlist data to pages for a SCSI command.",
        "pre": {
            "cmd->t_data_nents": "==0",
            "sg": "!=null",
            "cmd->t_data_nents": "==1",
            "kmap(sg_page(sg)) + sg->offset": "!=null"
        }
    }
},
{
    "kretprobe:transport_generic_new_cmd": {
        "description": "Handle new command in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "ret": "!=null"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    },
    "kprobe:transport_generic_request_failure": {
        "description": "Handle request failure in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "ret": "!=0"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:transport_generic_map_mem_to_cmd": {
        "description": "Maps memory to the command structure in the transport layer.",
        "pre": {
            "cmd": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0"
        },
        "post": {
            "ret": "==0",
            "cmd": "!=null"
        }
    }
},

{
    "kprobe:transport_generic_free_cmd": {
        "description": "Free a transport generic command",
        "pre": {
            "cmd": "!=null",
            "wait_for_tasks": "int",
            "cmd->CMD_T_TAS": "bool",
            "cmd->queue_status": "!=null when cmd->CMD_T_TAS",
            "cmd->aborted_task": "!=null when !cmd->CMD_T_TAS",
            "target_handle_abort": "!=null when !cmd->CMD_T_TAS"
        }
    }
},
{
    "kretprobe:target_submit_prep": {
        "description": "Prepare cmd for submission",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0",
            "sgl_prot": "!=null",
            "sgl_prot_count": ">=0",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:target_submit_prep": {
        "description": "Prepare cmd for submission",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0",
            "sgl_prot": "!=null",
            "sgl_prot_count": ">=0",
            "gfp": ">=0"
        }
    }
},




{
    "kretprobe:target_free_cmd_counter": {
        "description": "Free the command counter object if it is not stopped.",
        "pre": {
            "!atomic_read(&cmd_cnt->stopped)": true,
            "percpu_ref_put(&cmd_cnt->refcnt)": true,
            "percpu_ref_exit(&cmd_cnt->refcnt)": true
        }
    }
},
{
    "kprobe:target_free_cmd_counter": {
        "description": "Free the command counter if it is not stopped.",
        "pre": {
            "!atomic_read(&cmd_cnt->stopped)": true,
            "percpu_ref_put(&cmd_cnt->refcnt)": true,
            "percpu_ref_exit(&cmd_cnt->refcnt)": true
        }
    }
},
{
    "kretprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kretprobe:transport_cmd_check_stop_to_fabric": {
        "description": "Check if the transport command should stop to fabric.",
        "pre": {
            "cmd": "!=null"
        },
        "ret": {
            "value": ">=0"
        }
    }
},
{
    "kprobe:transport_cmd_check_stop_to_fabric": {
        "description": "Check if the transport command should stop to fabric.",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:target_submit": {
        "description": "Perform final initialization and submit cmd to LIO core",
        "pre": {
            "se_cmd": "!=null"
        },
        "post": {
            "return": "-EIO"
        }
    }
},
{
    "kprobe:target_submit": {
        "description": "Perform final initialization and submit cmd to LIO core",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kretprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator",
        "pre": {
            "cmd": "!=null",
            "cmd->scsi_command": "!=null",
            "cmd->scsi_command->cmnd": "!=null",
            "cmd->scsi_command->cmnd_len": ">0",
            "cmd->scsi_command->cmnd_len": "<=MAX_COMMAND_SIZE"
        }
    }
},
{
    "kretprobe:failure:INIT_WORK(&se_cmd->work, target_complete_tmr_failure);schedule_work(&se_cmd->work);return 0;}EXPORT_SYMBOL(target_submit_tmr);/* * Handle SAM-esque emulation for generic transport request failures. `": {
        "description": "For callback during failure handling, push this work off to process context with TMR_LUN_DOES_NOT_EXIST status.",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kprobe:failure:INIT_WORK(&se_cmd->work, target_complete_tmr_failure);schedule_work(&se_cmd->work);return 0;}EXPORT_SYMBOL(target_submit_tmr);/* * Handle SAM-esque emulation for generic transport request failures. `": {
        "description": "For callback during failure handling, push this work off to process context with TMR_LUN_DOES_NOT_EXIST status.",
        "pre": {
            "se_cmd": "!=null"
        }
    }
},
{
    "kretprobe:num_blocks = get_unaligned_be32(&cmd->t_task_cdb[28])": {
        "description": "Use the explicit range when non zero is supplied, otherwise calculate the remaining range based on ->get_blocks() - starting LBA.",
        "pre": {
            "cmd": "!=null",
            "cmd->t_task_cdb": "!=null",
            "cmd->t_task_cdb[28]": "!=null",
            "cmd->t_task_cdb[0]": "in [WRITE_SAME, WRITE_SAME_16]",
            "cmd->t_task_cdb[7]": "!=null when cmd->t_task_cdb[0] == WRITE_SAME",
            "cmd->t_task_cdb[10]": "!=null when cmd->t_task_cdb[0] == WRITE_SAME_16"
        }
    }
},
{
    "kprobe:num_blocks = get_unaligned_be32(&cmd->t_task_cdb[28]);/* * Use the explicit range when non zero is supplied, otherwise calculate * the remaining range based on ->get_blocks() - starting LBA. */": {
        "description": "This function retrieves the number of blocks from the command buffer.",
        "pre": {
            "cmd->t_task_cdb[0]": "== WRITE_SAME",
            "num_blocks": "!= null"
        }
    }
},
{
    "kretprobe:sbc_parse_cdb": {
        "description": "Parse SCSI command CDB",
        "pre": {
            "sectors": ">1"
        }
    }
},
{
    "kprobe:sbc_parse_cdb": {
        "description": "Parse SCSI command descriptor block (CDB) in sbc_parse_cdb function.",
        "pre": {
            "sectors": ">1"
        }
    }
},
{
    "kretprobe:core_alua_check_nonop_delay": {
        "description": "Check if the ALUA ActiveNonOptimized access state delay is enabled.",
        "pre": {
            "cmd": {
                "alua_nonop_delay": "==null"
            }
        }
    }
},
{
    "kprobe:core_alua_check_nonop_delay": {
        "description": "Check if the ALUA ActiveNonOptimized access state delay is enabled.",
        "pre": {
            "cmd": {
                "alua_nonop_delay": "==null"
            }
        }
    }
},
{
    "kretprobe:if (se_cmd->orig_fe_lun != 0)": {
        "description": "Check if orig_fe_lun is not equal to 0",
        "pre": {
            "orig_fe_lun": "!= 0"
        }
    }
},
{
    "if (se_cmd->orig_fe_lun != 0)": {
        "description": "Check if orig_fe_lun is not equal to zero.",
        "pre": {
            "se_cmd->orig_fe_lun": "!= 0"
        }
    }
},
{
    "kretprobe:target_configure_unmap_from_queue": {
        "description": "Configure unmap from queue for target",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null",
            "block_size": "!=null",
            "bdev_max_discard_sectors(bdev)": "!=0",
            "attrib->max_unmap_lba_count": "= bdev_max_discard_sectors(bdev) >> (ilog2(block_size) - 9)"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kprobe:target_configure_unmap_from_queue": {
        "description": "Configure unmap from queue for the target.",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null",
            "block_size": "!=null",
            "bdev_max_discard_sectors(bdev)": "!=0",
            "attrib->max_unmap_lba_count": "= bdev_max_discard_sectors(bdev) >> (ilog2(block_size) - 9)"
        }
    }
},
{
    "kretprobe:if (cdb[0] == REPORT_LUNS)": {
        "description": "Emulate the response for REPORT LUN pass everything else up.",
        "pre": {
            "cdb": {
                "index": 0,
                "value": "REPORT_LUNS"
            }
        }
    }
},

{
    "kretprobe:rcu_barrier();kfree(t->tf_tpg_base_cit.ct_attrs);kfree(t->tf_ops);kfree(t);return;}}mutex_unlock(&g_tf_lock);}EXPORT_SYMBOL(target_unregister_template": {
        "description": "Unregister a target template from the target fabric.",
        "pre": {
            "fo": "!=null",
            "t": "!=null",
            "t->tf_ops->fabric_name": "==fo->fabric_name",
            "atomic_read(&t->tf_access_cnt)": "==0"
        }
    }
},
{
    "kprobe:rcu_barrier": {
        "description": "Wait for any outstanding fabric se_deve_entry->rcu_head callbacks to complete post kfree_rcu(), before allowing fabric driver unload of TFO->module to proceed.",
        "pre": {
            "fo": "!=null",
            "t": "!=null",
            "t->tf_tpg_base_cit.ct_attrs": "!=null",
            "t->tf_ops": "!=null",
            "g_tf_lock": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Free the memory allocated for the given pointer.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return from the function.",
        "pre": {}
    },
    "kprobe:mutex_unlock": {
        "description": "Release the lock held by the given mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL": {
        "description": "Export a symbol for use by other modules.",
        "pre": {
            "symbol": "!=null"
        }
    }
},
{
    "kretprobe:rcu_barrier();kfree(tb);return;}}mutex_unlock(&backend_mutex);}EXPORT_SYMBOL(target_backend_unregister": {
        "description": "Unregister a target backend",
        "pre": {
            "ops": "!=null",
            "tb": "!=null",
            "backend_mutex": "locked",
            "backend_list": "contains(tb)",
            "tb->ops": "==ops",
            "tb->list": "in backend_list",
            "target_backend_ops->owner": "not null",
            "target_backend_ops->owner": "not unloaded",
            "target_backend_ops->owner": "not in call_rcu()",
            "target_backend_ops->owner": "not in rcu_head callbacks"
        }
    }
},
{
    "kprobe:rcu_barrier();kfree(tb);return;}}mutex_unlock(&backend_mutex);}EXPORT_SYMBOL(target_backend_unregister": {
        "description": "Wait for any outstanding backend driver ->rcu_head callbacks to complete post TBO->free_device() -> call_rcu(), before allowing backend driver module unload of target_backend_ops->owner to proceed.",
        "pre": {
            "ops": "!=null",
            "tb": "!=null",
            "backend_mutex": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_sequence_cmd": {
        "description": "",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": "!=null",
            "ret": "in [CMDSN_NORMAL_OPERATION, CMDSN_HIGHER_THAN_EXP, CMDSN_LOWER_THAN_EXP, CMDSN_MAXCMDSN_OVERRUN]",
            "reject": "in [true, false]",
            "reason": "in [ISCSI_REASON_BOOKMARK_NO_RESOURCES]",
            "cmdsn_ret": "in [CMDSN_NORMAL_OPERATION, CMDSN_HIGHER_THAN_EXP, CMDSN_LOWER_THAN_EXP, CMDSN_MAXCMDSN_OVERRUN]",
            "cmd->i_state": "in [ISTATE_REMOVE]"
        }
    }
},
{
    "kprobe:iscsit_sequence_cmd": {
        "description": "Function to sequence commands in iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_allocate_cmd": {
        "description": "Allocate an iSCSI command structure.",
        "pre": {
            "conn": "!=null",
            "state": "int"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iscsit_allocate_cmd": {
        "description": "Allocate an iscsit_cmd structure for the given iscsit_conn and state.",
        "pre": {
            "conn": "!=null",
            "state": "int"
        }
    }
},
{
    "kretprobe:iscsit_setup_scsi_cmd": {
        "description": "Check if the flags in the iscsi_scsi_req structure satisfy the condition.",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "not in [ISCSI_FLAG_CMD_WRITE, ISCSI_FLAG_CMD_FINAL]"
        }
    }
},
{
    "kprobe:iscsit_setup_scsi_cmd": {
        "description": "Setup SCSI command for iSCSI target",
        "pre": {
            "hdr": {
                "flags": {
                    "&": {
                        "ISCSI_FLAG_CMD_WRITE": "0",
                        "ISCSI_FLAG_CMD_FINAL": "0"
                    }
                }
            }
        }
    }
},
{
    "kretprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->immediate_data": "==null"
        }
    }
},
{
    "kprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->immediate_data": "==null"
        }
    }
},
{
    "kretprobe:atomic_long_add": {
        "description": "Add the payload length to the received data octets in the session.",
        "pre": {
            "payload_length": "!=null",
            "conn->sess->rx_data_octets": "!=null",
            "hdr->itt": "!=null",
            "hdr->ttt": "!=null",
            "hdr->datasn": "!=null",
            "ntohl(hdr->offset)": "!=null",
            "conn->cid": "!=null",
            "cmd->cmd_flags": "!=null"
        }
    }
},
{
    "kprobe:atomic_long_add": {
        "description": "Add a value to an atomic long variable.",
        "pre": {
            "payload_length": "!=null",
            "&conn->sess->rx_data_octets": "!=null",
            "hdr->itt": "!=null",
            "hdr->ttt": "!=null",
            "hdr->datasn": "!=null",
            "ntohl(hdr->offset)": "!=null",
            "payload_length": "!=null",
            "conn->cid": "!=null",
            "cmd->cmd_flags & ICF_GOT_LAST_DATAOUT": "!=null"
        }
    }
},
{
    "kretprobe:iscsit_check_post_dataout": {
        "description": "Increment post receive data and CRC values or perform within-command recovery.",
        "pre": {
            "cmd": "!=null",
            "hdr": "!=null",
            "data_crc_failed": "bool"
        },
        "post": {
            "rc": "in [DATAOUT_NORMAL, DATAOUT_WITHIN_COMMAND_RECOVERY, DATAOUT_SEND_R2T]"
        }
    }
},

{
    "kretprobe:if (hdr->ttt == cpu_to_be32(0xFFFFFFFF))": {
        "description": "Check if ttt is equal to 0xFFFFFFFF",
        "pre": {
            "hdr": "!=null",
            "ttt": "==cpu_to_be32(0xFFFFFFFF)"
        }
    }
},
{
    "if (hdr->ttt == cpu_to_be32(0xFFFFFFFF))": {
        "description": "Check if hdr->ttt is equal to cpu_to_be32(0xFFFFFFFF).",
        "pre": {
            "hdr->ttt": "== cpu_to_be32(0xFFFFFFFF)"
        }
    }
},


{
    "kretprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handle Task Management Command in iSCSI Target",
        "pre": {
            "function": "!= ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handle iSCSI task management command.",
        "pre": {
            "function": "!= ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kretprobe:text_ptr = strchr(text_in, '=');BUG_ON(!text_ptr);if (!strncmp(\"=All\", text_ptr, 5))": {
        "description": "This condition checks if the text_ptr is found and if the first 5 characters after text_ptr are equal to \"=All\".",
        "pre": {
            "text_in": "!=null",
            "text_ptr": "!=null",
            "strncmp_result": "==0"
        }
    }
},
{
    "kprobe:iscsit_process_text_cmd": {
        "description": "Process text command in iSCSI target",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->text_in_ptr": "!=null",
            "strchr(cmd->text_in_ptr, '=')": "!=null",
            "strncmp(strchr(cmd->text_in_ptr, '='), \"=All\", 5)": "true"
        }
    }
},
{
    "kretprobe:iscsit_handle_logout_cmd": {
        "description": "Handle logout command in the iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn_ret": "int",
            "logout_remove": "int",
            "reason_code": "u8",
            "hdr": "struct iscsi_logout",
            "tiqn": "struct iscsi_tiqn",
            "tiqn->logout_stats.lock": "spinlock_t",
            "hdr->flags": "int",
            "tiqn->logout_stats.normal_logouts": "int",
            "tiqn->logout_stats.abnormal_logouts": "int",
            "hdr->itt": "int",
            "hdr->cmdsn": "int",
            "hdr->exp_statsn": "int",
            "hdr->cid": "u16",
            "conn->cid": "u16",
            "conn->conn_state": "int",
            "cmd->iscsi_opcode": "int",
            "cmd->i_state": "int",
            "cmd->immediate_cmd": "int",
            "conn->sess->init_task_tag": "int",
            "cmd->init_task_tag": "int",
            "cmd->targ_xfer_tag": "int",
            "cmd->cmd_sn": "int",
            "cmd->exp_stat_sn": "int",
            "cmd->logout_cid": "u16",
            "cmd->logout_reason": "u8",
            "cmd->data_direction": "int"
        }
    }
},
{
    "kprobe:iscsit_handle_logout_cmd": {
        "description": "Handle logout command in the iSCSI target.",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn_ret": "int",
            "logout_remove": "int",
            "reason_code": "u8",
            "hdr": "struct iscsi_logout",
            "tiqn": "struct iscsi_tiqn",
            "tiqn->logout_stats.lock": "spinlock_t",
            "hdr->flags": "u8",
            "tiqn->logout_stats.normal_logouts": "int",
            "tiqn->logout_stats.abnormal_logouts": "int",
            "hdr->itt": "u32",
            "hdr->cmdsn": "u32",
            "hdr->exp_statsn": "u32",
            "hdr->cid": "u16",
            "conn->cid": "u16",
            "conn->conn_state": "TARG_CONN_STATE_LOGGED_IN",
            "cmd->iscsi_opcode": "ISCSI_OP_LOGOUT",
            "cmd->i_state": "ISTATE_SEND_LOGOUTRSP",
            "cmd->immediate_cmd": "int",
            "cmd->init_task_tag": "u32",
            "cmd->targ_xfer_tag": "0xFFFFFFFF",
            "cmd->cmd_sn": "be32_to_cpu(hdr->cmdsn)",
            "cmd->exp_stat_sn": "be32_to_cpu(hdr->exp_statsn)",
            "cmd->logout_cid": "be16_to_cpu(hdr->cid)",
            "cmd->logout_reason": "reason_code",
            "cmd->data_direction": "DMA_NONE"
        }
    }
},
{
    "kretprobe:switch (hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK)": {
        "description": "Handle ISCSI_FLAG_SNACK_TYPE_MASK in the switch statement.",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "& ISCSI_FLAG_SNACK_TYPE_MASK != 0",
            "hdr->itt": "!=null",
            "hdr->exp_statsn": "!=null",
            "hdr->begrun": "!=null",
            "hdr->runlength": "!=null",
            "conn->cid": "!=null"
        }
    }
},
{
    "kprobe:iscsit_handle_snack": {
        "description": "Handle ISCSI_INIT_SNACK request",
        "pre": {
            "conn": "!=null",
            "buf": "!=null",
            "hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK": "in [SNACK_DATA, SNACK_R2T]"
        }
    }
},




{
    "kretprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for iSCSI.",
        "pre": {
            "cmd": "!=null",
            "conn": "!=null",
            "hdr": "!=null",
            "network_transport": "in [ISCSI_TCP, ISCSI_UDP, ISCSI_SCTP]"
        },
        "post": {
            "cmd->maxcmdsn_inc": "0",
            "hdr->exp_cmdsn": "cpu_to_be32(conn->sess->exp_cmd_sn)",
            "hdr->max_cmdsn": "cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn))",
            "pr_debug": "\"Built Text Response: ITT: 0x%08x, TTT: 0x%08x, StatSN: 0x%08x, Length: %u, CID: %hu F: %d C: %d\\n\", cmd->init_task_tag, cmd->targ_xfer_tag, cmd->stat_sn, text_length, conn->cid, !!(hdr->flags & ISCSI_FLAG_CMD_FINAL), !!(hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)",
            "return": "text_length + padding"
        }
    }
},
{
    "kprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for iSCSI target.",
        "pre": {
            "cmd": {
                "maxcmdsn_inc": 0
            },
            "hdr": {
                "exp_cmdsn": "cpu_to_be32(conn->sess->exp_cmd_sn)",
                "max_cmdsn": "cpu_to_be32((u32) atomic_read(&conn->sess->max_cmd_sn))",
                "flags": "(hdr->flags & ISCSI_FLAG_CMD_FINAL) ? ISCSI_FLAG_CMD_FINAL : ISCSI_FLAG_TEXT_CONTINUE"
            },
            "conn": {
                "sess": {
                    "exp_cmd_sn": "!=null",
                    "max_cmd_sn": "!=null"
                }
            }
        }
    }
},

{
    "kprobe:iscsit_thread_reschedule": {
        "description": "Reschedule the iscsit_thread_check_cpumask function for the given connection.",
        "pre": {
            "conn": "!=null"
        }
    }
},



{
    "kprobe:timeout": {
        "description": "Assign the value 100000 to timeout.",
        "pre": {
            "timeout": "==100000"
        }
    },
    "kprobe:interrupt_data[0][0]": {
        "description": "Assign the value 1 to interrupt_data[0][0].",
        "pre": {
            "interrupt_data[0][0]": "==1"
        }
    },
    "kprobe:loop_condition": {
        "description": "Check the loop condition.",
        "pre": {
            "interrupt_data[0][0]": "!=0",
            "pmu_state": "!=idle"
        }
    }
},
{
    "kretprobe:req->data[0] = PMU_ADB_CMD;req->nbytes += 2;req->reply_expected = 1;req->reply_len = 0;ret = pmu_queue_request(req);break;}if (ret)": {
        "description": "This is the kretprobe function for the given code snippet.",
        "pre": {
            "req->data[0]": "= PMU_ADB_CMD",
            "req->nbytes": "+= 2",
            "req->reply_expected": "= 1",
            "req->reply_len": "= 0",
            "ret": "= pmu_queue_request(req)"
        }
    }
},

{
    "kretprobe:low_sleep_handler": {
        "description": "This function is a low-level sleep handler.",
        "pre": {},
        "post": {}
    },
    "kretprobe:enable_kernel_altivec": {
        "description": "This function enables the kernel's AltiVec support.",
        "pre": {},
        "post": {}
    },
    "kretprobe:enable_kernel_fp": {
        "description": "This function enables the kernel's floating-point support.",
        "pre": {},
        "post": {}
    },
    "kretprobe:pmu_polled_request": {
        "description": "This function handles polled requests for the PMU.",
        "pre": {
            "DEBUG_SLEEP": "defined"
        },
        "post": {
            "req": "!=null"
        }
    },
    "kretprobe:pmu_blink": {
        "description": "This function blinks the PMU.",
        "pre": {},
        "post": {
            "n": "is_integer"
        }
    }
},
{
    "kprobe:low_sleep_handler": {
        "description": "Handler for low sleep.",
        "pre": {}
    }
},




{
    "kretprobe:pmu_handle_data": {
        "description": "Handle data from an ADB command",
        "pre": {
            "data": "!=null",
            "len": ">=0"
        }
    }
},



{
    "kretprobe:init_pmu": {
        "description": "Initialize the PMU.",
        "pre": {},
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:init_pmu": {
        "description": "Initialize the PMU.",
        "pre": {}
    }
},
{
    "kretprobe:smu_queue_cmd": {
        "description": "Queue a command in the SMU command list.",
        "pre": {
            "smu_irq_inited": "==false",
            "smu->db_irq": "==false"
        },
        "post": {
            "cmd": "!=null",
            "cmd->data_len": "<= SMU_MAX_DATA",
            "cmd->reply_len": "<= SMU_MAX_DATA",
            "cmd->status": "==1",
            "smu->cmd_cur": "==null"
        }
    }
},
{
    "kprobe:smu_queue_cmd": {
        "description": "Queue a command in the SMU command list.",
        "pre": {
            "smu_irq_inited": "==false",
            "smu->db_irq": "==false",
            "cmd->data_len": "<= SMU_MAX_DATA",
            "cmd->reply_len": "<= SMU_MAX_DATA"
        }
    }
},

{
    "kprobe:find_via_cuda": {
        "description": "This is the find_via_cuda function.",
        "pre": {
            "CONFIG_MAC": "defined"
        }
    }
},
"ret": "is_int",
{
    "kprobe:macio_register_driver": {
        "description": "Registers a new MacIO device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kprobe:macio_unregister_driver": {
        "description": "Unregisters a new MacIO device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:macio_request_resource": {
        "description": "Request an MMIO resource",
        "pre": {
            "dev": "!=null",
            "resource_no": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:macio_request_resource": {
        "description": "Request an MMIO resource",
        "pre": {
            "dev": "!=null",
            "resource_no": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:macio_request_resources": {
        "description": "Reserve all memory resources",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:macio_request_resources": {
        "description": "Reserve all memory resources",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kretprobe:macio_release_resources": {
        "description": "Release reserved memory resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_resources": {
        "description": "Release reserved memory resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:for (i = 1; i < 16; i++)": {
        "description": "Loop from 1 to 15",
        "pre": {
            "i": ">=1",
            "i": "<16"
        }
    }
},
{
    "kprobe:for (i = 1; i < 16; i++)": {
        "description": "Loop from 1 to 15",
        "pre": {
            "i": ">=1",
            "i": "<16"
        }
    }
},


{
    "kretprobe:is_vmalloc_addr": {
        "description": "Check if the given CPU address is in the vmalloc region.",
        "pre": {
            "cpu_addr": "!=null",
            "cpu_addr": "in vmalloc region",
            "cpu_addr": "not in ioremapped region",
            "cpu_addr": "not in dma_alloc_coherent region",
            "cpu_addr": "not in generic dma memory pool"
        }
    }
},
{
    "kprobe:is_vmalloc_addr": {
        "description": "Check if the given CPU address is in the vmalloc region.",
        "pre": {
            "cpu_addr": "!=null",
            "cpu_addr": "in vmalloc region",
            "cpu_addr": "not in ioremapped region",
            "cpu_addr": "not in dma_alloc_coherent region",
            "cpu_addr": "not in generic dma memory pool"
        }
    }
},
{
    "kretprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "len": ">=0",
            "is_iomem": "!=null"
        }
    }
},
{
    "kprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "len": ">=0",
            "is_iomem": "!=null"
        }
    }
},


{
    "kretprobe:rproc_of_resm_mem_entry_init": {
        "description": "Allocate and initialize rproc_mem_entry struct from a reserved memory phandle.",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": "!=null",
            "len": ">=0",
            "da": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rproc_of_resm_mem_entry_init": {
        "description": "Allocate and initialize rproc_mem_entry struct from a reserved memory phandle.",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": "!=null",
            "len": "!=null",
            "da": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:rproc_of_parse_firmware": {
        "description": "Parse and return the firmware-name",
        "pre": {
            "dev": "!=null",
            "index": "int",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:rproc_of_parse_firmware": {
        "description": "Parse and return the firmware-name",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources for rproc.",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources for rproc.",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_boot": {
        "description": "Initiate the process of attaching to a detached remote processor.",
        "pre": {
            "rproc->state": "== RPROC_DETACHED"
        },
        "post": {
            "return": "rproc_boot(rproc)"
        }
    }
},

{
    "kretprobe:rproc_shutdown": {
        "description": "Shuts down the remote processor.",
        "pre": {
            "rproc": {
                "cached_table": "!=null",
                "table_ptr": "!=null",
                "table_sz": "!=null"
            },
            "GFP_KERNEL": "in [GFP_KERNEL]"
        },
        "post": {
            "return_value": "in [-ENOMEM]"
        }
    }
},

{
    "kretprobe:rproc_detach": {
        "description": "Detach the resource table from the remote processor.",
        "pre": {
            "rproc": "!=null",
            "rproc->cached_table": "!=null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": "!=null",
            "GFP_KERNEL": "!=null"
        },
        "post": {
            "rproc->cached_table": "==null",
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:rproc_detach": {
        "description": "Detach the resource table from the remote processor.",
        "pre": {
            "rproc": "!=null",
            "rproc->cached_table": "==null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": "!=null"
        }
    }
},
{
    "kretprobe:rproc_get_by_phandle": {
        "description": "Get the rproc handle associated with the given phandle.",
        "pre": {
            "phandle": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},

{
    "kretprobe:rproc_set_firmware": {
        "description": "Assign a new firmware to the rproc handle.",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:rproc_set_firmware": {
        "description": "Assign a new firmware to the rproc handle.",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:devm_rproc_add": {
        "description": "Resource managed rproc_add().",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:devm_rproc_add": {
        "description": "Resource managed rproc_add().",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        }
    }
},


{
    "kretprobe:if (rproc->table_ptr)": {
        "description": "Reset the virtio device section in the cached resource table only if there is one to work with.",
        "pre": {
            "rproc": "!=null",
            "rproc->table_ptr": "!=null"
        }
    }
},
{
    "kprobe:if (rproc->table_ptr)": {
        "description": "Check if rproc->table_ptr is not NULL.",
        "pre": {
            "rproc": {
                "table_ptr": "!=null"
            }
        }
    }
},
{
    "kretprobe:devm_rproc_alloc": {
        "description": "Resource managed rproc_alloc()",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:devm_rproc_alloc": {
        "description": "Resource managed rproc_alloc()",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc.",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_enable_iommu": {
        "description": "Enable IOMMU for the given rproc.",
        "pre": {
            "rproc": "!=null"
        },
        "post": {
            "return_value": "-ENOSYS"
        }
    }
},

{
    "kretprobe:rproc_coredump_add_segment": {
        "description": "Add segment of device memory to coredump",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_add_segment": {
        "description": "Add segment of device memory to coredump",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_add_custom_segment": {
        "description": "Add device memory to the list of segments to be included in the coredump and associate the segment with the given custom dump function and private data.",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null",
            "dumpfn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_add_custom_segment": {
        "description": "Add custom coredump segment",
        "pre": {
            "rproc": "!=null",
            "da": "!=null",
            "size": "!=null",
            "dumpfn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_set_elf_info": {
        "description": "Set coredump elf information",
        "pre": {
            "rproc": "!=null",
            "class": "!=null",
            "machine": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_set_elf_info": {
        "description": "Set coredump elf information",
        "pre": {
            "rproc": "!=null",
            "class": "!=null",
            "machine": "!=null"
        }
    }
},
{
    "kretprobe:rproc_coredump_using_sections": {
        "description": "Perform coredump using section headers",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_using_sections": {
        "description": "Perform coredump using section headers",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:st_slim_rproc_alloc": {
        "description": "Allocate and initialize slim rproc for use by device drivers based on the SLIM core.",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kprobe:st_slim_rproc_alloc": {
        "description": "Allocate and initialise slim rproc.",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        }
    }
},
{
    "kretprobe:st_slim_rproc_put": {
        "description": "Put slim rproc resources",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kprobe:st_slim_rproc_put": {
        "description": "Put slim rproc resources",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_vq_interrupt": {
        "description": "Tell remoteproc that a virtqueue is interrupted",
        "pre": {
            "rproc": "!=null",
            "notifyid": "!=null"
        },
        "post": {
            "return": "in [IRQ_NONE, IRQ_HANDLED]"
        }
    }
},
{
    "kprobe:rproc_vq_interrupt": {
        "description": "Tell remoteproc that a virtqueue is interrupted",
        "pre": {
            "rproc": "!=null",
            "notifyid": "!=null"
        },
        "post": {
            "return": "in [IRQ_NONE, IRQ_HANDLED]"
        }
    }
},
{
    "kretprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_load_rsc_table": {
        "description": "Load the resource table inside the remote processor's firmware, update @table_ptr.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:rproc_elf_load_rsc_table": {
        "description": "Load the resource table inside the remote processor's firmware, update @table_ptr.",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "Find the loaded resource table",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "Find the loaded resource table",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_user": {
        "description": "Get descriptor from user space.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "getrange": "!=null",
            "head": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]"
        }
    }
},

{
    "kretprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors.",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "true"
        }
    }
},
{
    "kprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors.",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_user": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_user": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_user": {
        "description": "Complete the user's access to the vring buffer.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_user": {
        "description": "Complete the user's consumption of completed buffers in the vring.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_user()": "called"
        }
    }
},
{
    "kretprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_kern": {
        "description": "Get descriptor from vringh",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]",
            "riov": "reusable",
            "wiov": "reusable"
        }
    }
},
{
    "kprobe:vringh_getdesc_kern": {
        "description": "Get the descriptor from the vringh structure and allocate memory for riov and wiov if needed. Returns 0 if there was no descriptor, 1 if there wa or -errno.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "any value"
        }
    }
},
{
    "kretprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_kern": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_kern": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_kern": {
        "description": "Complete a virtio ring operation in the kernel.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_kern()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_kern": {
        "description": "Completes the processing of a virtio ring buffer in the kernel.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_kern()": "called after this function"
        }
    }
},
{
    "kretprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "is_error(num)"
        }
    }
},
{
    "kprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "boolean",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "pre": {
            "vrh": "!=null",
            "features": "!=null",
            "num": ">=0",
            "weak_barriers": "is boolean",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_iotlb": {
        "description": "Get descriptor from vringh and handle IOTLB.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        },
        "post": {
            "return": "in [0, 1, -errno]",
            "head": "in [0, vrh->vring.num]",
            "riov": "!=null",
            "wiov": "!=null"
        }
    }
},
{
    "kprobe:vringh_getdesc_iotlb": {
        "description": "Get descriptor from the vringh iotlb.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "!=null"
        }
    }
},
{
    "kretprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov.",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return_value": "<=len"
        }
    }
},
{
    "kprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov.",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len"
        }
    }
},
{
    "kretprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s).",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_iotlb": {
        "description": "Enables notifications for the vring and returns false if there are no more buffers available.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_iotlb": {
        "description": "We want to know if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes.",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_iotlb": {
        "description": "Complete IOTLB operation for a vringh instance.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_iotlb()": "called after this function"
        }
    }
},
{
    "kprobe:vringh_complete_iotlb": {
        "description": "Complete IOTLB operation for a vringh instance.",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        },
        "post": {
            "vringh_need_notify_iotlb": "true"
        }
    }
},


{
    "kretprobe:cmd->param1 = CONFIGURATION_ZONE;cmd->param2 = cpu_to_le16(DEVICE_LOCK_ADDR);cmd->count = READ_COUNT;atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_READ;cmd->rxsize = READ_RSP_SIZE;}EXPORT_SYMBOL(atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "pre": {
            "cmd->word_addr": "!=null",
            "cmd->opcode": "!=null"
        }
    }
},
{
    "kprobe:cmd->param1 = CONFIGURATION_ZONE;cmd->param2 = cpu_to_le16(DEVICE_LOCK_ADDR);cmd->count = READ_COUNT;atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_READ;cmd->rxsize = READ_RSP_SIZE;}EXPORT_SYMBOL(atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "pre": {
            "cmd->word_addr": "!=null",
            "cmd->opcode": "!=null"
        }
    }
},
{
    "kretprobe:cmd->param2 = cpu_to_le16(keyid);atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_GENKEY;cmd->rxsize = GENKEY_RSP_SIZE;": {
        "description": "Initialize the genkey command in the atmel_i2c driver.",
        "pre": {
            "cmd": "!=null",
            "keyid": "!=null",
            "cmd->word_addr": "==COMMAND",
            "cmd->count": "==GENKEY_COUNT",
            "cmd->opcode": "==OPCODE_GENKEY",
            "cmd->param1": "==GENKEY_MODE_PRIVATE"
        }
    }
},
{
    "kprobe:cmd->param2 = cpu_to_le16(keyid);atmel_i2c_checksum(cmd);cmd->msecs = MAX_EXEC_TIME_GENKEY;cmd->rxsize = GENKEY_RSP_SIZE;": {
        "description": "Initialize the genkey command in the Atmel I2C driver.",
        "pre": {
            "cmd": "!=null",
            "keyid": "!=null",
            "cmd->word_addr": "COMMAND",
            "cmd->count": "GENKEY_COUNT",
            "cmd->opcode": "OPCODE_GENKEY",
            "cmd->param1": "GENKEY_MODE_PRIVATE"
        }
    }
},


{
    "kretprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response.",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response.",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:i2c_priv->wake_token_sz": {
        "description": "Set the value of i2c_priv->wake_token_sz using atmel_i2c_wake_token_sz function.",
        "pre": {
            "i2c_priv": "!=null",
            "bus_clk_rate": "!=null"
        }
    },
    "kretprobe:memset(i2c_priv->wake_token, 0, sizeof(i2c_priv->wake_token))": {
        "description": "Set the value of i2c_priv->wake_token to 0 using memset function.",
        "pre": {
            "i2c_priv->wake_token": "!=null"
        }
    },
    "kretprobe:atomic_set(&i2c_priv->tfm_count, 0)": {
        "description": "Set the value of i2c_priv->tfm_count to 0 using atomic_set function.",
        "pre": {
            "i2c_priv": "!=null"
        }
    },
    "kretprobe:i2c_set_clientdata(client, i2c_priv)": {
        "description": "Set the client data of i2c_priv using i2c_set_clientdata function.",
        "pre": {
            "client": "!=null",
            "i2c_priv": "!=null"
        }
    },
    "kretprobe:return device_sanity_check(client)": {
        "description": "Return the result of device_sanity_check function.",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:i2c_priv->wake_token_sz = atmel_i2c_wake_token_sz(bus_clk_rate);memset(i2c_priv->wake_token, 0, sizeof(i2c_priv->wake_token));atomic_set(&i2c_priv->tfm_count, 0);i2c_set_clientdata(client, i2c_priv);return device_sanity_check(client);": {
        "description": "Probe function for Atmel I2C driver.",
        "pre": {
            "client": "!=null",
            "client->adapter": "!=null",
            "client->adapter->dev": "!=null",
            "client->adapter->dev->parent": "!=null",
            "client->adapter->dev->parent->bus": "!=null",
            "client->adapter->dev->parent->bus->bus_type": "!=null",
            "client->adapter->dev->parent->bus->bus_type->name": "==\"i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_name": "==\"i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->name": "==\"atmel_i2c\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->name": "==\"atmel_i2c_probe\"",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->map": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->key": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->value": "!=null",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "client->adapter->dev->parent->bus->bus_type->dev_root->dev->driver->probe->pre->map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},

{
    "kprobe:kmap_atomic": {
        "description": "Map a page descriptor to a virtual address.",
        "pre": {
            "sg": "!=null",
            "it": "!=null",
            "it_page": "!=null"
        }
    },
    "kprobe:sg_page": {
        "description": "Get the page associated with a scatterlist entry.",
        "pre": {
            "sg": "!=null",
            "it": "!=null"
        }
    }
},
{
    "kretprobe:caam_strstatus": {
        "description": "Handle error status in the caam_strstatus function.",
        "pre": {
            "jrdev": "!=null",
            "status": "!=null",
            "error": "!=null",
            "ssrc": "status >> JRSTA_SSRC_SHIFT",
            "error_handling_function": "status_src[ssrc].report_ssed != null",
            "error_source_name": "status_src[ssrc].error"
        }
    }
},
{
    "kprobe:caam_strstatus": {
        "description": "Handle error status in the caam_strstatus function.",
        "pre": {
            "jrdev": "!=null",
            "status": "!=null",
            "error": "!=null",
            "ssrc": "status >> JRSTA_SSRC_SHIFT",
            "error_handling_function": "status_src[ssrc].report_ssed != null",
            "error_source_name": "status_src[ssrc].error"
        }
    }
},
{
    "kretprobe:edesc = aead_edesc_alloc": {
        "description": "Allocate extended descriptor",
        "pre": {
            "req": "!=null",
            "false": "not in [0, false]",
            "IS_ERR(edesc)": "==false"
        }
    },
    "kretprobe:caam_req->flc = &ctx->flc[DECRYPT]": {
        "description": "Set caam_req->flc to &ctx->flc[DECRYPT]",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null",
            "DECRYPT": "!=null"
        }
    },
    "kretprobe:caam_req->flc_dma = ctx->flc_dma[DECRYPT]": {
        "description": "Set caam_req->flc_dma to ctx->flc_dma[DECRYPT]",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null",
            "DECRYPT": "!=null"
        }
    },
    "kretprobe:caam_req->cbk = aead_decrypt_done": {
        "description": "Set caam_req->cbk to aead_decrypt_done",
        "pre": {
            "caam_req": "!=null",
            "aead_decrypt_done": "!=null"
        }
    },
    "kretprobe:caam_req->ctx = &req->base": {
        "description": "Set caam_req->ctx to &req->base",
        "pre": {
            "caam_req": "!=null",
            "req": "!=null",
            "base": "!=null"
        }
    },
    "kretprobe:caam_req->edesc = edesc": {
        "description": "Set caam_req->edesc to edesc",
        "pre": {
            "caam_req": "!=null",
            "edesc": "!=null"
        }
    },
    "kretprobe:ret = dpaa2_caam_enqueue(ctx->dev, caam_req)": {
        "description": "Set ret to dpaa2_caam_enqueue(ctx->dev, caam_req)",
        "pre": {
            "ret": "!=null",
            "ctx": "!=null",
            "dev": "!=null",
            "caam_req": "!=null"
        }
    },
    "kretprobe:ret != -EINPROGRESS && !(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)": {
        "description": "Check if ret is not -EINPROGRESS and not (-EBUSY and req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)",
        "pre": {
            "ret": "!=null",
            "-EINPROGRESS": "!=null",
            "-EBUSY": "!=null",
            "req": "!=null",
            "base": "!=null",
            "flags": "!=null",
            "CRYPTO_TFM_REQ_MAY_BACKLOG": "!=null"
        }
    }
},
{
    "kprobe:aead_edesc_alloc": {
        "description": "Allocate an extended descriptor for the AEAD request.",
        "pre": {
            "req": "!=null",
            "false": "true"
        }
    },
    "kprobe:IS_ERR": {
        "description": "Check if the extended descriptor is an error.",
        "pre": {
            "edesc": "!=null"
        }
    },
    "kprobe:PTR_ERR": {
        "description": "Get the error value from the extended descriptor.",
        "pre": {
            "edesc": "!=null"
        }
    },
    "kprobe:caam_req->flc": {
        "description": "Set the flc field of caam_req to the DECRYPT flc of ctx.",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null"
        }
    },
    "kprobe:caam_req->flc_dma": {
        "description": "Set the flc_dma field of caam_req to the DECRYPT flc_dma of ctx.",
        "pre": {
            "caam_req": "!=null",
            "ctx": "!=null"
        }
    },
    "kprobe:caam_req->cbk": {
        "description": "Set the cbk field of caam_req to aead_decrypt_done.",
        "pre": {
            "caam_req": "!=null"
        }
    },
    "kprobe:caam_req->ctx": {
        "description": "Set the ctx field of caam_req to the base field of req.",
        "pre": {
            "caam_req": "!=null",
            "req": "!=null"
        }
    },
    "kprobe:caam_req->edesc": {
        "description": "Set the edesc field of caam_req to edesc.",
        "pre": {
            "caam_req": "!=null",
            "edesc": "!=null"
        }
    },
    "kprobe:dpaa2_caam_enqueue": {
        "description": "Enqueue the caam_req to the dev.",
        "pre": {
            "ctx": "!=null",
            "caam_req": "!=null"
        }
    },
    "kprobe:ret": {
        "description": "Check the return value of dpaa2_caam_enqueue.",
        "pre": {
            "ret": "!=null",
            "ret": "!= -EINPROGRESS",
            "!(ret == -EBUSY && req->base.flags & CRYPTO_TFM_REQ_MAY_BACKLOG)": "true"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},
{
    "cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol) with no (null) decryption.",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0"
        }
    }
},

{
    "kretprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": "integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "is boolean",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "is boolean",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "is boolean",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "is boolean",
            "era": "is integer"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "is boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "is boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "encap": "in [true, false]",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "encap": "boolean",
            "is_qi": "boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES AND OP_ALG_AAI_XTS"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "cdata->alg": "& OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS"
        }
    }
},


{
    "kretprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0",
            "import_ctx": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0",
            "import_ctx": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_sk_hash": {
        "description": "shared descriptor for symmetric key cipher-based hash algorithms",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_sk_hash": {
        "description": "shared descriptor for symmetric key cipher-based hash algorithms",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">=0",
            "ctx_len": ">=0"
        }
    }
},
{
    "kretprobe:caam_drv_ctx_update": {
        "description": "Update the CAAM driver context",
        "pre": {
            "old_fq": "!=null"
        }
    }
},

{
    "kretprobe:caam_drv_ctx_init": {
        "description": "Initialize the caam_drv_ctx structure and perform operations on it.",
        "pre": {
            "qidev": "!=null",
            "cpu": "integer",
            "sh_desc": "integer",
            "num_words": "integer",
            "size": "integer",
            "hwdesc": "integer",
            "drv_ctx": "!=null",
            "cpus": "!=null"
        }
    }
},
{
    "kprobe:drv_ctx->prehdr[0] = cpu_to_caam32((1 << PREHDR_RSLS_SHIFT) | num_words);drv_ctx->prehdr[1] = cpu_to_caam32(PREHDR_ABS);memcpy(drv_ctx->sh_desc, sh_desc, desc_bytes(sh_desc));size = sizeof(drv_ctx->prehdr) + sizeof(drv_ctx->sh_desc);hwdesc = dma_map_single(qidev, drv_ctx->prehdr, size,DMA_BIDIRECTIONAL);if (dma_mapping_error(qidev, hwdesc))": {
        "description": "Initialize pre-header, set RSLS and SDLEN, and shared descriptor, and perform DMA mapping.",
        "pre": {
            "qidev": "!=null",
            "cpu": "!=null",
            "sh_desc": "!=null"
        }
    }
},


{
    "kretprobe:init_job_desc": {
        "description": "Initialize job description.",
        "pre": {
            "desc": "!=null",
            "info->key_mod_len": "<= CAAM_BLOB_KEYMOD_LENGTH",
            "encap": "in [true, false]",
            "op": "in [OP_PCLID_BLOB | OP_TYPE_ENCAP_PROTOCOL, OP_PCLID_BLOB | OP_TYPE_DECAP_PROTOCOL]",
            "output_len": "info->input_len + CAAM_BLOB_OVERHEAD when encap == true, info->input_len - CAAM_BLOB_OVERHEAD when encap == false",
            "desc": "!=null",
            "dma_in": "!=null",
            "dma_out": "!=null",
            "ctrlpriv": "!=null",
            "moo": "in [CSTA_MOO_SECURE, CSTA_MOO_TRUSTED]"
        }
    }
},
{
    "kprobe:init_job_desc": {
        "description": "Initialize the job description with the given parameters.",
        "pre": {
            "desc": "!=null",
            "info->key_mod_len": "<= CAAM_BLOB_KEYMOD_LENGTH",
            "encap": "in [true, false]",
            "output_len": "info->input_len + CAAM_BLOB_OVERHEAD if encap, info->input_len - CAAM_BLOB_OVERHEAD otherwise",
            "desc_bytes(desc)": ">= CAAM_BLOB_DESC_BYTES_MAX",
            "dma_mapping_error(jrdev, dma_in)": "false",
            "dma_mapping_error(jrdev, dma_out)": "false",
            "moo": "in [CSTA_MOO_SECURE, CSTA_MOO_TRUSTED]"
        }
    },
    "kprobe:append_key_as_imm": {
        "description": "Append the key as an immediate value to the job description.",
        "pre": {
            "desc": "!=null",
            "info->key_mod": "!=null",
            "info->key_mod_len": "!=null",
            "info->key_mod_len": "info->key_mod_len",
            "CLASS_2 | KEY_DEST_CLASS_REG": "!=null"
        }
    },
    "kprobe:append_seq_in_ptr_intlen": {
        "description": "Append the input sequence as a pointer with the given length to the job description.",
        "pre": {
            "desc": "!=null",
            "dma_in": "!=null",
            "info->input_len": "!=null",
            "info->input_len": "info->input_len",
            "0": "!=null"
        }
    },
    "kprobe:append_seq_out_ptr_intlen": {
        "description": "Append the output sequence as a pointer with the given length to the job description.",
        "pre": {
            "desc": "!=null",
            "dma_out": "!=null",
            "output_len": "!=null",
            "output_len": "output_len",
            "0": "!=null"
        }
    },
    "kprobe:append_operation": {
        "description": "Append the operation to the job description.",
        "pre": {
            "desc": "!=null",
            "op": "!=null"
        }
    },
    "kprobe:print_hex_dump_debug": {
        "description": "Print the hex dump debug information.",
        "pre": {
            "info->input": "!=null",
            "info->input_len": "!=null",
            "desc": "!=null",
            "desc_bytes(desc)": "!=null"
        }
    },
    "kprobe:caam_jr_enqueue": {
        "description": "Enqueue the job description to the CAAM JR device.",
        "pre": {
            "jrdev": "!=null",
            "desc": "!=null",
            "caam_blob_job_done": "!=null",
            "&testres": "!=null",
            "ret": "in [-EINPROGRES other]"
        }
    }
},


{
    "kretprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed.",
        "pre": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed.",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_free": {
        "description": "Free the Job Ring",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_free": {
        "description": "Free the Job Ring",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head.",
        "pre": {
            "dev": "!=null",
            "desc": "!=null",
            "cbk": "!=null",
            "areq": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head.",
        "pre": {
            "dev": "!=null",
            "desc": "!=null",
            "cbk": "!=null",
            "areq": "!=null"
        }
    }
},
{
    "kretprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_alloc_device": {
        "description": "Allocate rdi",
        "pre": {
            "size": "!=null",
            "nports": "!=null"
        }
    }
},
{
    "kprobe:rvt_alloc_device": {
        "description": "Allocate rdi",
        "pre": {
            "size": "!=null",
            "nports": "!=null"
        }
    }
},
{
    "kretprobe:rvt_dealloc_device": {
        "description": "Deallocate the rdi structure",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_dealloc_device": {
        "description": "Deallocate the rdi structure.",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_register_device": {
        "description": "register a driver",
        "pre": {
            "rdi": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:rvt_register_device": {
        "description": "Register a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_unregister_device": {
        "description": "Remove a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_unregister_device": {
        "description": "Remove a driver",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_init_port": {
        "description": "Initialize internal data for driver port",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rvt_init_port": {
        "description": "Init internal data for driver port",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        }
    }
},
{
    "kretprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->s_lock": "unlocked",
            "qp->s_hlock": "unlocked",
            "qp->r_lock": "unlocked",
            "lastwqe": "bool",
            "qp->ibqp.device": "!=null",
            "qp->ibqp.qp_context": "!=null"
        }
    }
},
{
    "kretprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->r_rq": "!=null",
            "qp->r_rq.size": ">0",
            "qp->ibqp.recv_cq": "!=null",
            "qp->ibqp.event_handler": "!=null"
        }
    }
},
{
    "kprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "qp->r_rq": "!=null",
            "qp->r_rq.size": ">0",
            "qp->ibqp.recv_cq": "!=null",
            "qp->ibqp.event_handler": "!=null"
        }
    }
},
{
    "kretprobe:rvt_comm_est": {
        "description": "Handle trap with QP established",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_comm_est": {
        "description": "Handle trap with QP established.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return index into ib_rvt_rnr_table",
        "pre": {
            "index": "!=null"
        }
    }
},
{
    "kprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return index into ib_rvt_rnr_table",
        "pre": {
            "index": "!=null"
        }
    }
},
{
    "kretprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP.",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP.",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kretprobe:rvt_add_rnr_timer": {
        "description": "Addstart an RNR timer on the QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null"
        }
    }
},
{
    "kprobe:rvt_add_rnr_timer": {
        "description": "Addstart an rnr timer on the QP",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null"
        }
    }
},
{
    "kretprobe:rdi->driver_f.stop_send_queue(qp);rvt_del_timers_sync(qp);/* Wait for things to stop `": {
        "description": "Stop the send queue and the retry timer",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null",
            "rdi->driver_f.stop_send_queue(qp)": "!=null",
            "rvt_del_timers_sync(qp)": "!=null",
            "rvt_stop_rc_timers(qp)": "!=null",
            "qp->s_flags": "&= ~(RVT_S_TIMER | RVT_S_ANY_WAIT)",
            "spin_unlock(&qp->s_lock)": "!=null",
            "spin_unlock(&qp->s_hlock)": "!=null",
            "spin_unlock_irq(&qp->r_lock)": "!=null"
        }
    }
},
{
    "kprobe:rdi->driver_f.stop_send_queue(qp);rvt_del_timers_sync(qp);/* Wait for things to stop": {
        "description": "Stop the send queue and the retry timer",
        "pre": {
            "qp": "!=null"
        }
    }
},




{
    "kretprobe:rvt_qp_iter_init": {
        "description": "Initializes an iterator for QP iteration.",
        "pre": {
            "rdi": "!=null",
            "v": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kprobe:rvt_qp_iter_init": {
        "description": "Initializes an iterator for QP iteration.",
        "pre": {
            "rdi": "!=null",
            "v": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter",
        "pre": {
            "iter": "!=null"
        },
        "post": {
            "iter->qp": "==0"
        }
    }
},
{
    "kprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter",
        "pre": {
            "iter": "!=null",
            "return": "in [0, 1]"
        },
        "post": {
            "iter->qp": "valid when return == 0"
        }
    }
},
{
    "kretprobe:rvt_qp_exit": {
        "description": "Clean up qps on device exit",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_qp_exit": {
        "description": "Clean up qps on device exit",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_copy_sge": {
        "description": "Copy data to SGE memory",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_copy_sge": {
        "description": "Copy data to SGE memory",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_ruc_loopback": {
        "description": "Handle UC and RC loopback requests",
        "pre": {
            "sqp": "!=null"
        }
    }
},

{
    "kretprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null",
            "qp.s_lock": "held"
        }
    }
},
{
    "kprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP.",
        "pre": {
            "qp": "!=null",
            "aeth": "!=null",
            "qp.s_lock": "held"
        }
    }
},
{
    "kretprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kretprobe:rvt_fast_reg_mr": {
        "description": "fast register physical MR",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "!=null",
            "access": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:rvt_fast_reg_mr": {
        "description": "Fast register physical memory region.",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kretprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey",
        "pre": {
            "qp": "!=null",
            "rkey": "!=null"
        }
    }
},
{
    "kprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey",
        "pre": {
            "qp": "!=null",
            "rkey": "!=null"
        }
    }
},
{
    "kretprobe:rvt_lkey_ok": {
        "description": "Check IB SGE for validity and initialize",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "is int"
        },
        "post": {
            "return": "in [0, 1, -errno]"
        }
    }
},
{
    "kprobe:rvt_lkey_ok": {
        "description": "Check IB SGE for validity and initialize",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "is int"
        }
    }
},
{
    "kretprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual addres length, and RKEY",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">0",
            "vaddr": "!=null",
            "rkey": "!=null",
            "acc": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual addres length, and RKEY",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">=0",
            "vaddr": "!=null",
            "rkey": ">=0",
            "acc": "in [0, 1]"
        }
    }
},
{
    "kretprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GID LID.",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GID LID.",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": "!=null"
        }
    }
},
{
    "kretprobe:ib_uverbs_get_ucontext_file": {
        "description": "We do not hold the hw_destroy_rwsem lock for this flow, instead srcu is used. It does not matter if someone races this with get_context, we get NULL or valid ucontext.",
        "pre": {
            "ufile": "!=null",
            "ufile->device": "!=null",
            "ufile->device->ib_dev": "!=null",
            "ufile->device->disassociate_srcu": "!=null",
            "ucontext": "!=null"
        }
    }
},
{
    "kprobe:ib_uverbs_get_ucontext_file": {
        "description": "Get the ib_ucontext file for a given ufile.",
        "pre": {
            "ufile": "!=null",
            "ufile->ucontext": "!=null",
            "ufile->device->ib_dev": "!=null",
            "ufile->device->disassociate_srcu": "!=null",
            "ucontext": "!=null"
        }
    }
},
{
    "kretprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context",
        "pre": {
            "cq": "!=null",
            "budget": ">=0"
        }
    }
},
{
    "kprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context",
        "pre": {
            "cq": "!=null",
            "budget": ">=0"
        }
    }
},
{
    "kretprobe:__ib_alloc_cq": {
        "description": "Allocate a completion queue",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_cq": {
        "description": "Allocate a completion queue.",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:__ib_alloc_cq_any": {
        "description": "Allocate a completion queue",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "poll_ctx": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_cq_any": {
        "description": "Allocate a completion queue.",
        "pre": {
            "dev": "!=null",
            "private": "!=null",
            "nr_cqe": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:ib_free_cq": {
        "description": "Free a completion queue",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kprobe:ib_free_cq": {
        "description": "Free a completion queue.",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kretprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe.",
        "pre": {
            "dev": "!=null",
            "nr_cqe": "!=null",
            "comp_vector_hint": "!=null",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]"
        }
    }
},
{
    "kprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe.",
        "pre": {
            "dev": "!=null",
            "nr_cqe": "!=null",
            "comp_vector_hint": "!=null",
            "poll_ctx": "in [IB_POLL_NORMAL, IB_POLL_BATCH, IB_POLL_SOFTIRQ]"
        }
    }
},
{
    "kretprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool.",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool.",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kretprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kretprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID.",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "!=null"
        }
    }
},
{
    "kprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID.",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "!=null"
        }
    }
},








{
    "kretprobe:ib_pack": {
        "description": "Pack a structure into a buffer",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_pack": {
        "description": "Pack a structure into a buffer",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_count": {
        "description": "The current usage of a specific object.",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]"
        }
    }
},
{
    "kprobe:rdma_restrack_count": {
        "description": "The current usage of specific object",
        "pre": {
            "dev": "!=null",
            "type": "in [valid values of enum rdma_restrack_type]"
        }
    }
},
{
    "kretprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource",
        "pre": {
            "res": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource",
        "pre": {
            "res": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack.",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in a fully automatic way.",
        "pre": {
            "res": "!=null",
            "type": "in [REstrack type values]"
        }
    }
},
{
    "kprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in a fully automatic way.",
        "pre": {
            "res": "!=null",
            "type": "in [REstrack type values]"
        }
    }
},
{
    "kretprobe:rdma_restrack_add": {
        "description": "Add object to the resource tracking database.",
        "pre": {
            "res": "!=null"
        }
    }
},

{
    "kretprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]",
            "id": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_TYPE_1, RDMA_RESTRACK_TYPE_2, RDMA_RESTRACK_TYPE_3]",
            "id": "!=null"
        },
        "post": {
            "return": "!= -ENOENT"
        }
    }
},
{
    "kretprobe:rdma_restrack_del": {
        "description": "Delete object from the resource tracking database.",
        "pre": {
            "res": "!=null"
        }
    }
},

{
    "kretprobe:sa_path_set_dmac_zero": {
        "description": "Set the destination MAC address to zero in the sa_path_rec structure.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kprobe:sa_path_set_dmac_zero(dst);}EXPORT_SYMBOL(ib_copy_path_rec_from_user": {
        "description": "Sets the destination MAC address to zero in the sa_path_rec structure.",
        "pre": {
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_join_multicast": {
        "description": "Join a multicast group in the InfiniBand subnet administrator (SA) layer.",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": "!=null",
            "callback": "!=null",
            "context": "!=null",
            "dev": "!=null",
            "member": "!=null",
            "multicast": "!=null",
            "ret": "!=null",
            "dev": "!=null",
            "start_port": "!=null",
            "group": "!=null",
            "mgid": "!=null"
        },
        "post": {
            "multicast": "!=null",
            "callback": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_join_multicast": {
        "description": "Join a multicast group on the InfiniBand device.",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": "!=null",
            "callback": "!=null",
            "context": "!=null"
        }
    }
},


{
    "kretprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ndev": "optional",
            "gid_type": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ndev": "optional",
            "gid_type": "!=null",
            "ah_attr": "!=null"
        }
    }
},
{
    "kretprobe:uverbs_uobject_put": {
        "description": "Called when the reference count is decreased and the uobject is freed.",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kprobe:uverbs_uobject_put": {
        "description": "Called when the reference count of a uobject is decreased and the uobject is freed.",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kretprobe:if_statement": {
        "description": "Check if the conditions for the if statement are met.",
        "pre": {
            "f->f_op": "!= fd_type->fops",
            "uobject->ufile": "!= ufile"
        }
    }
},

{
    "kretprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain.",
        "pre": {
            "device": "!=null",
            "flags": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain.",
        "pre": {
            "device": "!=null",
            "flags": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain.",
        "pre": {
            "pd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain.",
        "pre": {
            "pd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new new one.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new one.",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination.",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "!=null",
            "udata": "any",
            "xmit_slave": "any"
        }
    }
},
{
    "kprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "!=null",
            "udata": "in [null, !=null]",
            "xmit_slave": "in [null, !=null]",
            "pd->device": "!=null",
            "pd->device->ops.create_ah": "!=null",
            "rdma_zalloc_drv_obj_gfp(device, ib_ah, ...)": "!=null",
            "ah->device": "= pd->device",
            "ah->pd": "= pd",
            "ah->type": "= ah_attr->type",
            "ah->sgid_attr": "= rdma_update_sgid_attr(ah_attr, NULL)",
            "init_attr.ah_attr": "= ah_attr",
            "init_attr.flags": "= flags",
            "init_attr.xmit_slave": "= xmit_slave",
            "device->ops.create_user_ah(ah, &init_attr, udata)": "!=null",
            "device->ops.create_ah(ah, &init_attr, NULL)": "!=null",
            "ret": "= 0 if succes else appropriate error code",
            "ah->sgid_attr": "= null if ret != 0",
            "pd->usecnt": "incremented by 1"
        }
    }
},
{
    "kretprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector.",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:if (ip6h->version != 6)return (ip4h->version == 4) ? 4 : 0;/* version may be 6 or 4 because the first 20 bytes could be garbled */": {
        "description": "Check the version of the IP header and return a value based on the condition.",
        "pre": {
            "ip6h->version": "!= 6",
            "ip4h->version": "== 4"
        }
    }
},
{
    "kprobe:if (ip6h->version != 6)return (ip4h->version == 4) ? 4 : 0;/* version may be 6 or 4 because the first 20 bytes could be garbled `": {
        "description": "Check the version of the IP header and return 4 if it's IPv4, otherwise return 0.",
        "pre": {
            "ip6h->version": "!= 6",
            "ip4h->version": "== 4"
        }
    }
},
{
    "kretprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "!=null",
            "hop_limit": "!=null",
            "traffic_class": "!=null",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "!=null",
            "hop_limit": "!=null",
            "traffic_class": "!=null",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "!=null",
            "udata": "!=null",
            "srq_attr->max_wr": ">=0",
            "srq_attr->max_sge": ">=0"
        }
    }
},
{
    "kprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:if": {
        "description": "Check if the condition is true",
        "pre": {
            "qp_init_attr->cap.max_rdma_ctxs": "!=0"
        }
    },
    "kretprobe:rdma_rw_init_qp": {
        "description": "Initialize RDMA QP",
        "pre": {
            "device": "!=null",
            "qp_init_attr": "!=null"
        }
    },
    "kretprobe:create_qp": {
        "description": "Create QP",
        "pre": {
            "device": "!=null",
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "caller": "!=null"
        }
    },
    "kretprobe:IS_ERR": {
        "description": "Check if the return value is an error",
        "pre": {
            "qp": "!=null"
        }
    },
    "kretprobe:ib_qp_usecnt_inc": {
        "description": "Increment QP use count",
        "pre": {
            "qp": "!=null"
        }
    }
},

{
    "kretprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP.",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP.",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": "!=null",
            "udata": "!=null"
        }
    }
},


{
    "kretprobe:ib_alloc_mr": {
        "description": "Allocates a memory region",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, IB_MR_TYPE_MEM_WINDOW]",
            "max_num_sg": ">=0"
        }
    }
},
{
    "kprobe:ib_alloc_mr": {
        "description": "Allocates a memory region",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, IB_MR_TYPE_MEM_WINDOW]",
            "max_num_sg": ">=0"
        }
    }
},
{
    "kretprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        }
    }
},
{
    "kprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        }
    }
},
{
    "kretprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain.",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain.",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain.",
        "pre": {
            "xrcd": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain.",
        "pre": {
            "xrcd": "!=null",
            "udata": "in [valid_user_data, null]"
        }
    }
},
{
    "kretprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">=0",
            "wq_attr->max_sge": ">=0"
        }
    }
},
{
    "kprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain.",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">=0",
            "wq_attr->max_sge": ">=0"
        }
    }
},
{
    "kretprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ.",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ.",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "pre": {
            "mr": "!=null",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": "!=null",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": "!=null",
            "page_size": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "pre": {
            "mr": "!=null",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": ">=0",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": ">=0",
            "page_size": ">=0"
        }
    }
},
{
    "kretprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector.",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector.",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kretprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "pre": {
            "qp": "!=null",
            "qp->send_cq": "!=null",
            "qp->send_cq->poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ]",
            "qp->send_cq->poll_ctx == IB_POLL_DIRECT": {
                "cq->poll_ctx == IB_POLL_DIRECT": "true"
            },
            "qp->send_cq->poll_ctx == IB_POLL_SOFTIRQ": {
                "cq->poll_ctx == IB_POLL_SOFTIRQ": "true"
            }
        }
    }
},
{
    "kprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application.",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "pre": {
            "qp": "!=null",
            "cq": "!=null",
            "wc": "!=null",
            "wc->wr_cqe": "!=null",
            "cqe": "of type struct ib_drain_cqe",
            "cqe->done": "completed"
        }
    }
},
{
    "kprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "pre": {
            "cq": "!=null",
            "wc": "!=null"
        }
    }
},
{
    "kretprobe:__rdma_block_iter_start": {
        "description": "Initialize the ib_block_iter structure and assign the result of __fls(pgsz) to biter->__pg_bit.",
        "pre": {
            "biter": "!=null",
            "sglist": "!=null",
            "nents": ">=0",
            "pgsz": ">=0"
        }
    }
},
{
    "kprobe:biter->__pg_bit = __fls(pgsz)": {
        "description": "Assign the result of __fls(pgsz) to biter->__pg_bit",
        "pre": {
            "biter": {
                "__sg": "!=null",
                "__sg_nents": ">=0"
            },
            "sglist": "!=null",
            "nents": ">=0",
            "pgsz": ">=0"
        }
    }
},
{
    "kretprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers.",
        "pre": {
            "descs": "!=null",
            "num_counters": ">=0",
            "lifespan": ">=0"
        }
    }
},
{
    "kprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers.",
        "pre": {
            "descs": "!=null",
            "num_counters": ">=0",
            "lifespan": ">=0"
        }
    }
},
{
    "kretprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kretprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port",
        "pre": {
            "ibdev": "!=null",
            "port_num": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port",
        "pre": {
            "ibdev": "!=null",
            "port_num": "!=null",
            "groups": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure",
        "pre": {
            "payload_bytes": "!=null",
            "lrh_present": "!=null",
            "eth_present": "!=null",
            "vlan_present": "!=null",
            "grh_present": "!=null",
            "ip_version": "!=null",
            "udp_present": "!=null",
            "immediate_present": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure",
        "pre": {
            "payload_bytes": "!=null",
            "lrh_present": "!=null",
            "eth_present": "!=null",
            "vlan_present": "!=null",
            "grh_present": "!=null",
            "ip_version": "!=null",
            "udp_present": "!=null",
            "immediate_present": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_pack": {
        "description": "Pack UD header struct into wire format",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_pack": {
        "description": "Pack UD header struct into wire format",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},

{
    "kprobe:ib_ud_header_unpack": {
        "description": "Unpack UD header struct from wire format",
        "pre": {
            "buf": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": "!=null",
            "virt": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": "!=null",
            "virt": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory.",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]"
        }
    }
},
{
    "kprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory.",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]"
        }
    }
},
{
    "kretprobe:iwcm_reject_msg": {
        "description": "Returns the rejection message for a given reason in iWARP.",
        "pre": {
            "reason": "!=null",
            "index": "!=null",
            "index < ARRAY_SIZE(iwcm_rej_reason_strs)": true,
            "iwcm_rej_reason_strs[index]": "!=null"
        },
        "post": {
            "return": "iwcm_rej_reason_strs[index]",
            "return == \"unrecognized reason\"": false
        }
    }
},
{
    "kprobe:iwcm_reject_msg": {
        "description": "Returns the rejection message based on the given reason.",
        "pre": {
            "reason": "!=null",
            "index": "!=null",
            "iwcm_rej_reason_strs": "!=null",
            "ARRAY_SIZE(iwcm_rej_reason_strs)": "!=null",
            "iwcm_rej_reason_strs[index]": "!=null"
        }
    }
},


{
    "kretprobe:iw_cm_connect": {
        "description": "Get the ib_qp given the QPN",
        "pre": {
            "cm_id": "!=null",
            "cm_id->device": "!=null",
            "cm_id->device->ops.iw_get_qp": "valid_function",
            "iw_param": "!=null",
            "iw_param->qpn": "valid_value",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:iw_cm_connect": {
        "description": "Connect to an InfiniBand device using the iw_cm interface.",
        "pre": {
            "cm_id": "!=null",
            "cm_id->device": "!=null",
            "cm_id->device->ops.iw_get_qp": "!=null",
            "iw_param->qpn": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "sg_offset": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "sg_offset": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": "!=null",
            "rkey": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_wrs": {
        "description": "Return chain of WRs for a RDMA READ or WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "in [null, !=null]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_wrs": {
        "description": "Return chain of WRs for a RDMA READ or WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_post": {
        "description": "Post a RDMA READ or RDMA WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_post": {
        "description": "Post a RDMA READ or RDMA WRITE operation",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "cqe": "!=null",
            "chain_wr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": "!=null",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init.",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "!=null",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [DMA_TO_DEVICE, DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_mr_factor": {
        "description": "Return the number of MRs required for a payload",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "maxpages": "!=null"
        }
    }
},
{
    "kprobe:rdma_rw_mr_factor": {
        "description": "Return the number of MRs required for a payload.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "maxpages": "!=null"
        }
    }
},
{
    "kretprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not.",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not.",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_index": {
        "description": "Return a valid device pointer for the given index.",
        "pre": {
            "net": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ib_device_get_by_index": {
        "description": "Get the InfiniBand device pointer associated with the given index.",
        "pre": {
            "net": "!=null",
            "index": "!=null"
        },
        "post": {
            "return": "valid device pointer",
            "ib_device_put()": "return device reference count"
        }
    }
},
{
    "kretprobe:ib_device_get_by_name": {
        "description": "Find an IB device by name",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ib_device_get_by_name": {
        "description": "Find an IB device by name",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        }
    }
},
{
    "kretprobe:_ib_alloc_device": {
        "description": "Allocate memory for a struct ib_device with size 'size'. Remember to use ib_dealloc_device() to free the allocated memory.",
        "pre": {
            "size": "!=null"
        }
    }
},

{
    "kretprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data",
        "pre": {
            "dev": "!=null",
            "port": ">=1 and <=rdma_end_port()"
        }
    }
},
{
    "kprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data",
        "pre": {
            "dev": "!=null",
            "port": ">=1 && <=rdma_end_port()"
        }
    }
},




{
    "kretprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:down_write": {
        "description": "Acquire write lock on devices_rwsem",
        "pre": {
            "devices_rwsem": "!=null"
        }
    },
    "kretprobe:xa_load": {
        "description": "Load value from devices xarray and check equality",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kretprobe:xa_erase": {
        "description": "Erase entry from devices xarray",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kretprobe:up_write": {
        "description": "Release write lock on devices_rwsem",
        "pre": {
            "devices_rwsem": "!=null"
        }
    }
},
{
    "kprobe:down_write": {
        "description": "Downgrade the write lock on devices_rwsem.",
        "pre": {
            "devices_rwsem": "!=null"
        }
    },
    "kprobe:xa_load": {
        "description": "Load the value associated with device->index from the devices xarray.",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kprobe:xa_erase": {
        "description": "Erase the entry associated with device->index from the devices xarray.",
        "pre": {
            "devices": "!=null",
            "device->index": "!=null"
        }
    },
    "kprobe:up_write": {
        "description": "Upgrade the write lock on devices_rwsem.",
        "pre": {
            "devices_rwsem": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_client": {
        "description": "Register an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_register_client": {
        "description": "Register an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_client": {
        "description": "Unregister an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_client": {
        "description": "Unregister an IB client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_set_client_data": {
        "description": "Set IB client context",
        "pre": {
            "device": "!=null",
            "client": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ib_set_client_data": {
        "description": "Set IB client context",
        "pre": {
            "device": "!=null",
            "client": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_event_handler": {
        "description": "Register an IB event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_register_event_handler": {
        "description": "Register an IB event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_query_port": {
        "description": "Query IB port attributes",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_query_port": {
        "description": "Query IB port attributes",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device",
        "pre": {
            "ib_dev": "!=null",
            "ndev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device",
        "pre": {
            "ib_dev": "!=null",
            "ndev": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_netdev": {
        "description": "Find an IB device associated with a netdev",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, <specific driver ID>]"
        }
    }
},
{
    "kprobe:ib_device_get_by_netdev": {
        "description": "Find an IB device associated with a netdev",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN]"
        }
    }
},
{
    "kretprobe:ib_query_pkey": {
        "description": "Get P_Key table entry",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kprobe:ib_query_pkey": {
        "description": "Get P_Key table entry",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "pkey": "!=null"
        }
    }
},
{
    "kretprobe:ib_modify_device": {
        "description": "Change IB device attributes",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "!=null",
            "device_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_device": {
        "description": "Change IB device attributes",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "!=null",
            "device_modify": "!=null"
        }
    }
},
{
    "kretprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_modify_mask": "!=null",
            "port_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "port_modify_mask": "!=null",
            "port_modify": "!=null"
        }
    }
},
{
    "kretprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs.",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs.",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "pkey": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "pkey": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "pkey": "!=null",
            "gid": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "pkey": "!=null",
            "gid": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Store the value of cb_table in rdma_nl_types[index] using smp_store_release.",
        "pre": {
            "index": "!=null",
            "cb_table": "!=null",
            "is_nl_msg_valid(index, 0)": "!=false",
            "READ_ONCE(rdma_nl_types[index].cb_table)": "==null"
        }
    }
},

{
    "kretprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gid as needed, to the relevant RoCE devices.",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gid as needed, to the relevant RoCE devices.",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not.",
        "pre": {
            "gid": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not.",
        "pre": {
            "gid": "!=null"
        }
    }
},


{
    "kretprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries.",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": "!=null",
            "entries.length": "<= max_entries"
        }
    }
},
{
    "kprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries.",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": ">=0"
        }
    }
},
{
    "kretprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute",
        "pre": {
            "attr": "!=null",
            "caller_reference": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state.",
        "pre": {
            "attr": "!=null"
        },
        "post": {
            "return": "!=null",
            "return->state": "==UP"
        }
    }
},
{
    "kprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state.",
        "pre": {
            "attr": "!=null",
            "attr->netdev": "!=null",
            "attr->netdev->state": "==UP"
        },
        "post": {
            "retval": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry.",
        "pre": {
            "attr": "!=null",
            "vlan_id": "!=null",
            "smac": "!=null"
        },
        "post": {
            "return": "in [0, vlan_id, error]"
        }
    }
},
{
    "kprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry.",
        "pre": {
            "attr": "!=null",
            "vlan_id": "optional",
            "smac": "optional"
        }
    }
},


{
    "kretprobe:ib_create_qp_security": {
        "description": "Create the security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "is_ib": "==true",
            "ret": "==0",
            "qp->qp_sec": "!=null",
            "qp->qp_sec->mutex": "initialized",
            "qp->qp_sec->shared_qp_list": "initialized",
            "qp->qp_sec->error_list_count": "==0",
            "qp->qp_sec->error_complete": "initialized",
            "ret": "==0",
            "qp->qp_sec->security": "initialized"
        }
    },
    "kretprobe:ib_close_shared_qp_security": {
        "description": "Close the shared security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "sec->shared_qp_list": "in qp->qp_sec->shared_qp_list",
            "sec->mutex": "initialized"
        }
    }
},
{
    "kprobe:ib_create_qp_security": {
        "description": "Create the security context for the InfiniBand (IB) queue pair (QP).",
        "pre": {
            "is_ib": "==true",
            "ret": "==0",
            "qp->qp_sec": "!=null"
        }
    },
    "kprobe:check_qp_port_pkey_settings": {
        "description": "Check the port and PKey settings for the queue pair (QP).",
        "pre": {
            "real_qp->qp_sec->mutex": "locked",
            "ret": "==0"
        }
    },
    "kprobe:destroy_qp_security": {
        "description": "Destroy the security context for the queue pair (QP).",
        "pre": {
            "sec->shared_qp_list": "deleted"
        }
    },
    "kprobe:ib_close_shared_qp_security": {
        "description": "Close the shared security context for the queue pair (QP).",
        "pre": {
            "real_qp->qp_sec->mutex": "locked"
        }
    }
},
{
    "kretprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "any"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_io": {
        "description": "This function is called by drivers as part of their mmap() functions to send PCI-E BAR memory to userspace.",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": "!=null",
            "size": "!=null",
            "prot": "!=null",
            "entry": "!=null"
        },
        "post": {
            "return_value": "in [0, -EINVAL, -EAGAIN]"
        }
    }
},
{
    "kprobe:rdma_user_mmap_io": {
        "description": "This function is called by drivers as part of their mmap() functions to send PCI-E BAR memory to userspace.",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": "!=null",
            "size": "!=null",
            "prot": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "Return a reference to an entry if it exists or NULL if there is no match.",
        "pre": {
            "ucontext": "!=null",
            "pgoff": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "Get the rdma_user_mmap_entry with the specified page offset.",
        "pre": {
            "ucontext": "!=null",
            "pgoff": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable.",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range.",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": "!=null",
            "min_pgoff": "!=null",
            "max_pgoff": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range.",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": "!=null",
            "min_pgoff": "!=null",
            "max_pgoff": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_dmabuf_map_pages": {
        "description": "Map pages for the given umem_dmabuf",
        "pre": {
            "umem_dmabuf": "!=null",
            "sgt": "!=null",
            "sg": "!=null",
            "start": ">=0",
            "end": ">=0",
            "cur": ">=0",
            "nmap": ">=0",
            "ret": ">=0",
            "i": ">=0"
        }
    }
},
{
    "kprobe:start = ALIGN_DOWN(umem_dmabuf->umem.addres PAGE_SIZE);end = ALIGN(umem_dmabuf->umem.address + umem_dmabuf->umem.length, PAGE_SIZE);for_each_sgtable_dma_sg(sgt, sg, i)": {
        "description": "Map pages from umem_dmabuf to sg_table",
        "pre": {
            "umem_dmabuf": {
                "address": "!=null",
                "umem": {
                    "address": "!=null",
                    "length": "!=null"
                }
            },
            "sgt": "!=null",
            "sg": "!=null",
            "i": "!=null"
        }
    }
},
{
    "if (umem_dmabuf->first_sg)": {
        "description": "Check if the first scatter-gather element is present in umem_dmabuf.",
        "pre": {
            "umem_dmabuf": "!=null",
            "umem_dmabuf->first_sg": "!=null"
        }
    }
},
{
    "kprobe:if (umem_dmabuf->first_sg)": {
        "description": "Check if the `first_sg` field of `umem_dmabuf` is not null.",
        "pre": {
            "umem_dmabuf": "!=null",
            "umem_dmabuf->first_sg": "!=null"
        }
    }
},
{
    "kretprobe:rdma_copy_src_l2_addr": {
        "description": "Copy netdevice source addresses",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_src_l2_addr": {
        "description": "Copy netdevice source addresses",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem",
        "pre": {
            "device": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem",
        "pre": {
            "device": "!=null",
            "access": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem.",
        "pre": {
            "root": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "ops": "==invalidate"
        }
    }
},
{
    "kprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem.",
        "pre": {
            "root": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]",
            "ops": "==&invalidate"
        }
    }
},
{
    "kprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va",
        "pre": {
            "device": "!=null",
            "addr": "!=null",
            "size": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC]",
            "ops": "==&mmu_interval_notifier_ops_invalidate"
        }
    }
},


{
    "kretprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it.",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": "!=null",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "bool"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it.",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": "!=null",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "bool"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables.",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": ">=0",
            "page": "!=null",
            "access_mask": ">=0"
        },
        "post": {
            "return": "== -EFAULT"
        }
    }
},
{
    "kprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables.",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": "!=null",
            "page": "!=null",
            "access_mask": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query.",
        "pre": {
            "id": "!=null",
            "query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query.",
        "pre": {
            "id": "!=null",
            "query": "!=null"
        }
    }
},
{
    "kretprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record.",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": "!=null",
            "rec": "!=null",
            "comp_mask": "!=null",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null",
            "sa_query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": ">=0",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null",
            "sa_query": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_mad_agent": {
        "description": "Register to send/receive MADs",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "qp_type": "in [IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=0",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "!=null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kprobe:ib_register_mad_agent": {
        "description": "Register to send/receive MADs",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "qp_type": "in [IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=0",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "!=null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kretprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_send_mad": {
        "description": "Create and send an InfiniBand Management Datagram (MAD).",
        "pre": {
            "mad_agent": "!=null",
            "remote_qpn": "!=null",
            "pkey_index": "!=null",
            "rmpp_active": "!=null",
            "hdr_len": "!=null",
            "data_len": "!=null",
            "gfp_mask": "!=null",
            "base_version": "!=null",
            "opa": "!=null",
            "mad_agent_priv": "!=null",
            "mad_send_wr": "!=null",
            "pad": "!=null",
            "message_size": "!=null",
            "ret": "!=null",
            "size": "!=null",
            "buf": "!=null",
            "mad_size": "!=null"
        },
        "post": {
            "mad_send_wr->sg_list[1].length": "data_len",
            "mad_send_wr->sg_list[1].lkey": "mad_agent->qp->pd->local_dma_lkey",
            "mad_send_wr->mad_list.cqe.done": "ib_mad_send_done",
            "mad_send_wr->send_wr.wr.wr_cqe": "&mad_send_wr->mad_list.cqe",
            "mad_send_wr->send_wr.wr.sg_list": "mad_send_wr->sg_list",
            "mad_send_wr->send_wr.wr.num_sge": "2",
            "mad_send_wr->send_wr.wr.opcode": "IB_WR_SEND",
            "mad_send_wr->send_wr.wr.send_flags": "IB_SEND_SIGNALED",
            "mad_send_wr->send_wr.remote_qpn": "remote_qpn",
            "mad_send_wr->send_wr.remote_qkey": "IB_QP_SET_QKEY",
            "mad_send_wr->send_wr.pkey_index": "pkey_index"
        }
    }
},
{
    "kprobe:ib_create_send_mad": {
        "description": "Create and send an InfiniBand Management Datagram (MAD).",
        "pre": {
            "opa": true,
            "base_version": "OPA_MGMT_BASE_VERSION",
            "data_len": {
                "<": "mad_size - hdr_len"
            }
        },
        "post": {
            "mad_send_wr->sg_list[1].length": {
                "=": "data_len"
            },
            "mad_send_wr->sg_list[1].lkey": "mad_agent->qp->pd->local_dma_lkey",
            "mad_send_wr->mad_list.cqe.done": "ib_mad_send_done",
            "mad_send_wr->send_wr.wr.wr_cqe": "&mad_send_wr->mad_list.cqe",
            "mad_send_wr->send_wr.wr.sg_list": "mad_send_wr->sg_list",
            "mad_send_wr->send_wr.wr.num_sge": 2,
            "mad_send_wr->send_wr.wr.opcode": "IB_WR_SEND",
            "mad_send_wr->send_wr.wr.send_flags": "IB_SEND_SIGNALED",
            "mad_send_wr->send_wr.remote_qpn": "remote_qpn",
            "mad_send_wr->send_wr.remote_qkey": "IB_QP_SET_QKEY",
            "mad_send_wr->send_wr.pkey_index": "pkey_index",
            "rmpp_active": true
        }
    }
},


{
    "kretprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer.",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer.",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kretprobe:_uverbs_alloc": {
        "description": "Quickly allocate memory for use with a bundle",
        "pre": {
            "bundle": "!=null",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" 
        }
    }
},
{
    "kprobe:_uverbs_alloc": {
        "description": "Quickly allocate memory for use with a bundle",
        "pre": {
            "bundle": "!=null",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},




{
    "kretprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:cma_modify_qp_rts": {
        "description": "Modify the QP attributes to transition the QP state to RTS.",
        "pre": {
            "id_priv->id": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "qp": "!=null",
            "IB_QPS_RTS": "constant",
            "IB_QP_SQ_PSN": "constant"
        }
    },
    "kretprobe:cma_init_conn_qp": {
        "description": "Initialize the connection QP attributes.",
        "pre": {
            "id_priv": "!=null",
            "qp": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "IB_QPS_INIT": "constant"
        }
    },
    "kretprobe:rdma_create_qp": {
        "description": "Create a QP for RDMA communication.",
        "pre": {
            "id": "!=null",
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "ret": "int",
            "IB_QPT_UD": "constant",
            "IB_QPS_INIT": "constant"
        }
    },
    "kretprobe:rdma_destroy_qp": {
        "description": "Destroy the QP for RDMA communication.",
        "pre": {
            "id": "!=null"
        }
    },
    "kretprobe:cma_modify_qp_rtr": {
        "description": "Modify the QP attributes to transition the QP state to RTR.",
        "pre": {
            "id_priv": "!=null",
            "conn_param": "!=null",
            "qp_attr": "!=null",
            "qp_attr_mask": "!=null",
            "ret": "int",
            "IB_QPS_RTR": "constant"
        }
    }
},
{
    "kprobe:qp_attr.qp_state = IB_QPS_INIT;ret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);if (ret)goto out;ret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);if (ret)goto out;qp_attr.qp_state = IB_QPS_RTR;ret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);if (ret)goto out;BUG_ON(id_priv->cma_dev->device != id_priv->id.device);if (conn_param)qp_attr.max_dest_rd_atomic = conn_param->responder_resources;ret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);out:mutex_unlock(&id_priv->qp_mutex);return ret;}static int cma_modify_qp_rts(struct rdma_id_private *id_priv, struct rdma_conn_param *conn_param)": {
        "description": "Modify the QP attributes for the given rdma_id_private and rdma_conn_param in the RTS state.",
        "pre": {
            "qp_attr.qp_state": "= IB_QPS_INIT",
            "ret": "= 0",
            "rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask)": "= 0",
            "ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask)": "= 0",
            "qp_attr.qp_state": "= IB_QPS_RTR",
            "rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask)": "= 0",
            "BUG_ON(id_priv->cma_dev->device != id_priv->id.device)": "not triggered",
            "conn_param": "!= null",
            "qp_attr.max_dest_rd_atomic": "= conn_param->responder_resources",
            "ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask)": "= 0",
            "mutex_unlock(&id_priv->qp_mutex)": "not triggered",
            "return ret": "not specified"
        }
    }
},

{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel the address resolution for the given device address.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->id.route.addr.dev_addr": "!=null"
        }
    },
    "kprobe:cma_cancel_route": {
        "description": "Cancel the route query operation for the given id_priv.",
        "pre": {
            "id_priv": "!=null"
        }
    },
    "kprobe:cma_cancel_listens": {
        "description": "Cancel the listen operation for the given id_priv if certain conditions are met.",
        "pre": {
            "id_priv": "!=null",
            "cma_any_addr(cma_src_addr(id_priv))": "true",
            "!id_priv->cma_dev": "true"
        }
    },
    "kprobe:cma_release_port": {
        "description": "Release the port for the given id_priv.",
        "pre": {
            "id_priv": "!=null"
        }
    }
},
{
    "kretprobe:rdma_set_ack_timeout": {
        "description": "Set the acknowledgment timeout for the RDMA connection.",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rdma_set_ack_timeout": {
        "description": "Set the acknowledgment timeout for the RDMA connection.",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier.",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": ">=0",
            "min_rnr_timer": "<=31"
        }
    }
},
{
    "kprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier.",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": ">=0",
            "min_rnr_timer": "<=31"
        }
    }
},


{
    "kretprobe:rdma_resolve_addr": {
        "description": "Resolve the address for RDMA communication.",
        "pre": {
            "id": "!=null",
            "src_addr": "!=null",
            "dst_addr": "!=null",
            "timeout_ms": ">=0"
        }
    }
},
{
    "kprobe:rdma_resolve_addr": {
        "description": "Resolve the address of the RDMA connection manager (CM) identifier.",
        "pre": {
            "id": "!=null",
            "src_addr": "!=null",
            "dst_addr": "!=null",
            "timeout_ms": ">=0"
        }
    }
},
{
    "kretprobe:if (id_priv->reuseaddr)": {
        "description": "Check if the ID is reusable.",
        "pre": {
            "id_priv": {
                "reuseaddr": "true"
            }
        }
    }
},
{
    "kprobe:if (id_priv->reuseaddr)": {
        "description": "Check if the ID is allowed to be reusable.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->reuseaddr": "==true"
        }
    }
},
{
    "kretprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        }
    }
},
{
    "kretprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        }
    }
},
{
    "kretprobe:trace_cm_disconnect": {
        "description": "Initiate or respond to a disconnect.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->cm_id.ib": "!=null"
        }
    },
    "kretprobe:ib_send_cm_dreq": {
        "description": "Send a connection manager disconnect request.",
        "pre": {
            "id_priv": "!=null",
            "id_priv->cm_id.ib": "!=null"
        }
    }
},
{
    "id_priv": {
        "cm_id.ib": "!=null"
    }
},
{
    "kretprobe:rdma_join_multicast": {
        "description": "Join a multicast group in RDMA communication.",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:if (WARN_ON(id->qp))return -EINVAL;/* ULP is calling this wrong. `": {
        "description": "Join a multicast group for RDMA communication.",
        "pre": {
            "id": {
                "qp": "!=null"
            }
        }
    }
},
{
    "kretprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for future RDMA operation",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, RTRS_CLT_CON_TYPE_3]",
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NO_WAIT]"
        }
    }
},
{
    "kprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for future RDMA operation",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, RTRS_CLT_CON_TYPE_3]",
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NO_WAIT]"
        }
    }
},
{
    "kretprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},
{
    "kprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},


{
    "kretprobe:alloc_path": {
        "description": "Allocate a path for the rtrs_clt_sess structure.",
        "pre": {
            "clt_path": "!=null",
            "clt": "!=null",
            "delay_ms": ">=1000",
            "con_num": ">=0",
            "nr_poll_queues": ">=0"
        },
        "post": {
            "clt_path->s.con": "kcalloc(total_con, sizeof(*clt_path->s.con), GFP_KERNEL)",
            "!clt_path->s.con": "goto err_free_path",
            "clt_path->s.con_num": "total_con",
            "clt_path->s.irq_con_num": "con_num + 1",
            "clt_path->stats": "kzalloc(sizeof(*clt_path->stats), GFP_KERNEL)",
            "!clt_path->stats": "goto err_free_con",
            "clt_path->init_mutex": "mutex_init",
            "clt_path->s.uuid": "uuid_gen",
            "clt_path->s.dst_addr": "memcpy(&clt_path->s.dst_addr, path->dst, rdma_addr_size((struct sockaddr *)path->dst))"
        }
    }
},
{
    "kprobe:rtrs_clt_close_work": {
        "description": "Close the client work.",
        "pre": {}
    },
    "kprobe:rtrs_clt_err_recovery_work": {
        "description": "Perform error recovery work for the client.",
        "pre": {}
    },
    "kprobe:alloc_path": {
        "description": "Allocate a client path.",
        "pre": {
            "clt": "!=null",
            "path": "!=null",
            "con_num": ">=0",
            "nr_poll_queues": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA.",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        }
    }
},
{
    "kprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA.",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_clt_rdma_cq_direct": {
        "description": "If no path, return -1 for block layer not to try again",
        "pre": {
            "cnt": "-1",
            "con": "!=null",
            "clt_path": "!=null",
            "it": "!=null",
            "rcu_read_lock": "called",
            "path_it_init": "called with parameters (&it, clt)",
            "it.next_path(&it)": "!=null",
            "it.i < it.clt->paths_num": "true"
        },
        "post": {
            "return_value": "-1"
        }
    }
},

{
    "kretprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        },
        "post": {
            "return_value": "in [0, -ECOMM]"
        }
    }
},
{
    "kprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA request",
        "pre": {
            "id": "!=null",
            "status": "<=0"
        }
    }
},
{
    "kprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA request",
        "pre": {
            "id": "!=null",
            "status": "<=0"
        }
    }
},
{
    "kretprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv.",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv.",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname.",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname.",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth.",
        "pre": {
            "srv": "!=null"
        },
        "post": {
            "return_value": "is int"
        }
    }
},
{
    "kprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth.",
        "pre": {
            "srv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_open": {
        "description": "Open RTRS server context",
        "pre": {
            "ops": "!=null",
            "port": ">=0"
        }
    }
},
{
    "kprobe:rtrs_srv_open": {
        "description": "Open RTRS server context",
        "pre": {
            "ops": "!=null",
            "port": "!=null"
        }
    }
},


{
    "kretprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'.",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_sockaddr": {
        "description": "Converts a path string to source-destination addresses.",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rtrs_addr_to_sockaddr": {
        "description": "Converts a path string 'src,dst' or 'src@dst' to sockaddreses.",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "==null"
        }
    }
},
{
    "skb = __hci_cmd_sync": {
        "description": "Assign the return value of __hci_cmd_sync to skb",
        "pre": {
            "hdev": "!=null",
            "fw": "!=null",
            "cmd": "is of type struct hci_command_hdr",
            "fw_ptr": "is of type u8",
            "fw_size": "is of type size_t",
            "skb": "is of type struct sk_buff",
            "opcode": "is of type u16",
            "err": "is of type int",
            "__hci_cmd_sync": "return value is not an error"
        }
    }
},

{
    "kretprobe:vme_alloc_consistent": {
        "description": "Allocate contiguous memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:vme_alloc_consistent": {
        "description": "Allocate contiguous memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:vme_free_consistent": {
        "description": "Free previously allocated memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:vme_free_consistent": {
        "description": "Free previously allocated memory.",
        "pre": {
            "resource": "!=null",
            "size": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:vme_get_size": {
        "description": "Get the size of the window resource.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_get_size": {
        "description": "Returns the size of the window resource.",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_check_window": {
        "description": "Check the window for VME access.",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "vme_base": "!=null",
            "size": "!=null"
        },
        "post": {
            "retval": "in [-EINVAL, -EFAULT, 0]"
        }
    }
},
{
    "kprobe:vme_check_window": {
        "description": "Check the window for VME access.",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "vme_base": "!=null",
            "size": "!=null",
            "retval": "in [-EINVAL, -EFAULT]"
        }
    }
},
{
    "kretprobe:vme_slave_request": {
        "description": "Request a VME slave window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_request": {
        "description": "Request a VME slave window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_slave_set": {
        "description": "Set VME slave window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "buf_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_set": {
        "description": "Set VME slave window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "buf_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_slave_free": {
        "description": "Free VME slave window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_free": {
        "description": "Free VME slave window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_request": {
        "description": "Request a VME master window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_master_request": {
        "description": "Request a VME master window resource.",
        "pre": {
            "vdev": "!=null",
            "address": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_set": {
        "description": "Set VME master window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_master_set": {
        "description": "Set VME master window configuration.",
        "pre": {
            "resource": "!=null",
            "enabled": "!=null",
            "vme_base": "!=null",
            "size": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vme_master_write": {
        "description": "Write data out to VME space from a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:vme_master_write": {
        "description": "Write data out to VME space from a buffer.",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle.",
        "pre": {
            "resource": "!=null",
            "mask": "!=null",
            "compare": "!=null",
            "swap": "!=null",
            "offset": "!=null"
        },
        "post": {
            "return": ">=0",
            "resource": "is a VME master resource",
            "operation_supported": "true"
        }
    }
},
{
    "kprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle.",
        "pre": {
            "resource": "!=null",
            "mask": "!=null",
            "compare": "!=null",
            "swap": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_mmap": {
        "description": "Mmap region of VME master window.",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:vme_master_mmap": {
        "description": "Mmap region of VME master window.",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_free": {
        "description": "Free VME master window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_master_free": {
        "description": "Free VME master window",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_request": {
        "description": "Request a DMA controller.",
        "pre": {
            "vdev": "!=null",
            "route": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_request": {
        "description": "Request a DMA controller.",
        "pre": {
            "vdev": "!=null",
            "route": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_new_dma_list": {
        "description": "Return a pointer to a new VME DMA list.",
        "pre": {},
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:vme_new_dma_list": {
        "description": "Create a new VME DMA list.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_pattern_attribute": {
        "description": "Return a pointer to VME DMA attribute, NULL on failure.",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_pattern_attribute": {
        "description": "Generate conditions for the vme_dma_pattern_attribute function.",
        "pre": {
            "pattern": "!=null",
            "type": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_pci_attribute": {
        "description": "Create 'PCI' type VME DMA list attribute.",
        "pre": {
            "address": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_pci_attribute": {
        "description": "Create 'PCI' type VME DMA list attribute.",
        "pre": {
            "address": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_vme_attribute": {
        "description": "Create \"VME\" type VME DMA list attribute.",
        "pre": {
            "address": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_vme_attribute": {
        "description": "Create 'VME' type VME DMA list attribute.",
        "pre": {
            "address": "!=null",
            "aspace": "!=null",
            "cycle": "!=null",
            "dwidth": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_free_attribute": {
        "description": "Free the attributes associated with VME DMA.",
        "pre": {
            "attributes": "!=null"
        }
    }
},

{
    "kretprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution.",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution.",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:vme_irq_request": {
        "description": "Request a specific VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null",
            "callback": "!=null",
            "priv_data": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:vme_irq_request": {
        "description": "Request a specific VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null",
            "callback": "!=null",
            "priv_data": "!=null"
        }
    }
},
{
    "kretprobe:vme_irq_free": {
        "description": "Free a VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kprobe:vme_irq_free": {
        "description": "Free a VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kretprobe:vme_irq_generate": {
        "description": "Generate VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_irq_generate": {
        "description": "Generate VME interrupt.",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_request": {
        "description": "Request a VME location monitor",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_request": {
        "description": "Request a VME location monitor",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_set": {
        "description": "Configure location monitor",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_set": {
        "description": "Configure location monitor",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_get": {
        "description": "Retrieve location monitor settings",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_get": {
        "description": "Retrieve location monitor settings",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_attach": {
        "description": "Provide callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": ">=0",
            "callback": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_attach": {
        "description": "Provide callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null",
            "callback": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_detach": {
        "description": "Remove callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_detach": {
        "description": "Remove callback for location monitor address",
        "pre": {
            "resource": "!=null",
            "monitor": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_free": {
        "description": "Free allocated VME location monitor",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_free": {
        "description": "Free allocated VME location monitor",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_slot_num": {
        "description": "Retrieve slot ID",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:vme_slot_num": {
        "description": "Retrieve slot ID",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kretprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:__vme_register_driver_bus": {
        "description": "Register a VME driver",
        "pre": {
            "drv": "!=null",
            "bridge": "!=null",
            "ndevs": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__vme_register_driver_bus": {
        "description": "Register a VME driver",
        "pre": {
            "drv": "!=null",
            "bridge": "!=null",
            "ndevs": "!=null"
        }
    }
},
{
    "kretprobe:vme_unregister_driver": {
        "description": "Unregister a VME driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:vme_unregister_driver": {
        "description": "Unregister a VME driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:sscanf": {
        "description": "Read formatted data from a string",
        "pre": {
            "w": "!=null",
            "sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "!=null",
            "dir": "!=null",
            "ret": "!=null",
            "ret": "< 3"
        }
    }
},
{
    "kprobe:ret = sscanf": {
        "description": "Parse the string w->sname and store the results in intf_name, dai_id, and dir.",
        "pre": {
            "w": "!=null",
            "w->sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "!=null",
            "dir": "!=null",
            "ret": "!=null",
            "ret < 3": true
        }
    }
},
{
    "kretprobe:if (comp->card->instantiated)": {
        "description": "Check if the card is already instantiated.",
        "pre": {
            "comp": {
                "card": {
                    "instantiated": "==true"
                }
            }
        }
    }
},
{
    "kprobe:if (comp->card->instantiated)": {
        "description": "Check if the card is already instantiated.",
        "pre": {
            "comp": {
                "card": {
                    "instantiated": "==true"
                }
            }
        }
    }
},

{
    "list_for_each_entry_safe": {
        "description": "Iterate over the jack_list of the module structure and perform some operations on each entry.",
        "pre": {
            "jack": "!=null",
            "n": "!=null",
            "module": "!=null",
            "module.type": "struct gbaudio_module_info",
            "jack.type": "struct gbaudio_jack",
            "n.type": "struct gbaudio_jack"
        }
    }
},
{
    "kretprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:dev_set_drvdata": {
        "description": "Set the driver data of the device.",
        "pre": {
            "dev": "!=null",
            "indio_dev": "!=null",
            "bus": "!=null",
            "name": "!=null",
            "name[4]": "== '3' || name[4] == '5'",
            "name[6]": ">= '6'",
            "chip->bus": "== *bus",
            "chip->id": "ID_ADT7316 + (name[6] - '6') when name[4] == '3' || ID_ADT7516 + (name[6] - '6') when name[4] == '5'",
            "chip->id": "== ID_ADT7316 || chip->id == ID_ADT7516 when chip->id == ID_ADT7316 || chip->id == ID_ADT7516",
            "chip->dac_bits": "12 when chip->id == ID_ADT7316 || chip->id == ID_ADT7516 || chip->id == ID_ADT7317 || chip->id == ID_ADT7517, 10 when chip->id == ID_ADT7317 || chip->id == ID_ADT7517, 8 otherwise",
            "chip->ldac_pin": "!=null"
        },
        "post": {
            "return": "-ENODEV"
        }
    }
},
{
    "kprobe:dev_set_drvdata": {
        "description": "Set the driver data of the device.",
        "pre": {
            "dev": "!=null",
            "indio_dev": "!=null",
            "bus": "!=null",
            "name[4]": "== '3' or == '5'",
            "name[6]": ">= '6'",
            "chip->bus": "== *bus",
            "chip->id": "ID_ADT7316 + (name[6] - '6') when name[4] == '3', ID_ADT7516 + (name[6] - '6') when name[4] == '5'",
            "chip->id": "!=null",
            "chip->id": "== ID_ADT7316 or == ID_ADT7516 when chip->id == ID_ADT7316 or chip->id == ID_ADT7516",
            "chip->id": "== ID_ADT7317 or == ID_ADT7517 when chip->id == ID_ADT7317 or chip->id == ID_ADT7517",
            "chip->id": "!=null",
            "chip->dac_bits": "12 when chip->id == ID_ADT7316 or chip->id == ID_ADT7516, 10 when chip->id == ID_ADT7317 or chip->id == ID_ADT7517, 8 otherwise",
            "chip->ldac_pin": "devm_gpiod_get_optional(dev, \"adi,ldac\", GPIOD_OUT_LOW)",
            "chip->ldac_pin": "!=null"
        }
    }
},






{
    "kretprobe:ieee80211_resume_tx": {
        "description": "Resume transmission in the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "ieee->skb_drv_aggQ[queue_index]": "!=null",
            "ieee->skb_waitQ[queue_index]": "!=null",
            "txb->fragments[i]": "!=null",
            "ieee->dev": "!=null",
            "ieee->rate": "!=null",
            "ieee->lock": "acquired"
        }
    }
},
{
    "ieee80211_resume_tx": {
        "pre": {
            "USB_TX_DRIVER_AGGREGATION_ENABLE": "defined",
            "USB_TX_DRIVER_AGGREGATION_ENABLE": "undefined"
        }
    }
},
{
    "kretprobe:ieee80211_softmac_scan_syncro": {
        "description": "This function performs syncro scan blocking the caller until all channels in the allowed channel map have been checked.",
        "pre": {
            "ieee": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_softmac_scan_syncro": {
        "description": "This function performs syncro scan blocking the caller until all channels in the allowed channel map have been checked.",
        "pre": {
            "ieee": "!=null"
        }
    }
},


{
    "kretprobe:libipw_wx_set_encode": {
        "description": "Set the encryption for the wireless device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "dev": "!=null",
            "sec": "!=null",
            "i": ">=0",
            "key": "<WEP_KEYS",
            "key_provided": "in [0, 1]",
            "len": ">=0",
            "crypt": "!=null",
            "host_crypto": "in [0, 1]",
            "erq->flags & IW_ENCODE_DISABLED": "in [0, 1]",
            "erq->flags & IW_ENCODE_DISABLED && key_provided && crypt": "==0",
            "erq->flags & IW_ENCODE_DISABLED && !key_provided": "==1"
        }
    }
},
{
    "kprobe:libipw_wx_set_encode": {
        "description": "Set the encoding for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_encode_ext": {
        "description": "Set the extended encoding for IEEE 802.11 device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt[idx]": "!= null",
            "sec.flags": "|= SEC_ENABLED",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_encode_ext": {
        "description": "Set the extended encoding parameters for IEEE 802.11 device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt[idx]": "!= null",
            "sec.flags": "|= SEC_ENABLED",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},

{
    "kprobe:break;case IW_AUTH_CIPHER_PAIRWISE:case IW_AUTH_CIPHER_GROUP:case IW_AUTH_KEY_MGMT:/* *                  * Host AP driver does not use these parameters and allows *                                   * wpa_supplicant to control them internally. *                                                    */": {
        "description": "The function ieee80211_wx_set_auth is used to set the authentication parameters for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": "!=null",
            "extra": "!=null",
            "data.flags & IW_AUTH_INDEX": "in [IW_AUTH_WPA_VERSION]"
        }
    }
},
{
    "kretprobe:ieee80211_frag_cache_find": {
        "description": "Find the fragment entry in the cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_frag_cache_find": {
        "description": "Find the fragment entry in the cache based on the given parameters.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},

{
    "kprobe:if_memcmp": {
        "description": "Check if the memory contents of hdr->addr1 and ieee->dev->dev_addr are equal.",
        "pre": {
            "hdr->addr1": "!=null",
            "ieee->dev->dev_addr": "!=null"
        }
    }
},

{
    "kprobe:rtllib_wx_set_freq": {
        "description": "Set the frequency of the wireless device.",
        "pre": {
            "fwrq.e": "== 1"
        }
    }
},


{
    "kretprobe:spin_lock_irqsave": {
        "description": "Locks the spinlock and saves the IRQ state.",
        "pre": {
            "ieee": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:ieee80211_wx_get_wap": {
        "description": "Gets the wireless access point (WAP) address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.ap_addr.sa_family": "==ARPHRD_ETHER",
            "ieee.iw_mode": "!=IW_MODE_MONITOR"
        },
        "post": {
            "return": "==0"
        }
    },
    "kretprobe:spin_unlock_irqrestore": {
        "description": "Unlocks the spinlock and restores the IRQ state.",
        "pre": {
            "ieee": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:ieee80211_wx_get_wap": {
        "description": "Get the wireless access point (WAP) address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->ap_addr.sa_family": "==ARPHRD_ETHER",
            "ieee->iw_mode": "!=IW_MODE_MONITOR"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_wap": {
        "description": "Set the wireless access point (WAP) for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null",
            "ret": "int",
            "flags": "unsigned long",
            "ifup": "short",
            "dev": "!=null",
            "dev->flags": "IFF_UP"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_wap": {
        "description": "Set the wireless access point for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null",
            "ret": "int",
            "flags": "unsigned long",
            "ifup": "short",
            "dev": "!=null",
            "dev->flags": "IFF_UP"
        }
    }
},


{
    "kretprobe:ieee80211_wx_set_rate": {
        "description": "FIXME: we might want to limit rate also in management protocols.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "target_rate": "!=null",
            "ieee->rate": "target_rate * 100000"
        }
    }
},
{
    "kprobe:return 0;}EXPORT_SYMBOL(ieee80211_wx_set_rate": {
        "description": "FIXME: we might want to limit rate also in management protocols.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "target_rate": "!=null",
            "ieee->rate": "target_rate * 100000"
        }
    }
},
   "wrqu": {
       "rts": {
           "value": "ieee->rts",
           "fixed": "0"
       }
   }
   ```

4. `extra`: There is no specific constraint mentioned for this parameter in the documentation, so we can assume it can take any value. Therefore, we don't need to include it in the conditions.

Putting it all together, the JSON representation of the conditions for the `ieee80211_wx_get_rts` function would be:
,
{
    "kprobe:ieee80211_wx_get_rts": {
        "description": "Get the RTS (Request to Send) value from the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": {
                "rts": {
                    "value": "ieee->rts",
                    "fixed": 0
                }
            },
            "extra": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_scan": {
        "description": "This function is used to set the scan parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ret": "==0",
            "ieee->wx_mutex": "unlocked",
            "ieee->iw_mode": "in [IW_MODE_MONITOR, IW_MODE_NORMAL]",
            "ieee->proto_started": "true",
            "ieee->state": "in [IEEE80211_LINKED, IEEE80211_UNLINKED]"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_scan": {
        "description": "Set the scan parameters for the IEEE 802.11 device.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ret": "int",
            "ieee->wx_mutex": "locked",
            "ieee->iw_mode": "in [IW_MODE_MONITOR]",
            "ieee->proto_started": "true",
            "ieee->state": "in [IEEE80211_LINKED]"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Locks a spinlock and disables interrupts.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->essid.flags": "!=0",
            "wrqu->essid.length": "!=0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->essid.flags": "!=0",
            "wrqu->essid.length": "!=0"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_power": {
        "description": "Set the power parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.power.disabled": "==0",
            "wrqu.power.flags & IW_POWER_TIMEOUT": "!=0",
            "ieee->ps_period": "==wrqu.power.value / 1000"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_power": {
        "description": "Set the power parameters for the IEEE80211 device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu.power.disabled": "==0",
            "wrqu.power.flags & IW_POWER_TIMEOUT": "!=0",
            "wrqu.power.value": ">=0"
        }
    }
},

{
    "kprobe:/* goto exit; ": {
        "description": "This function contains a goto statement that jumps to the exit label.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "ieee->wx_mutex": "locked",
            "ieee->ps": "==IEEE80211_PS_DISABLED",
            "wrqu->power.disabled": "==1",
            "wrqu->power.flags & IW_POWER_TYPE": "==IW_POWER_TIMEOUT",
            "wrqu->power.flags": "==IW_POWER_TIMEOUT",
            "wrqu->power.value": "==ieee->ps_timeout * 1000"
        }
    }
},

{
    "kprobe:HTUpdateSelfAndPeerSetting": {
        "description": "Update self and peer settings for high throughput.",
        "pre": {
            "pNetwork": {
                "bssht": {
                    "bdHTInfoLen": "!= 0"
                }
            },
            "pHTInfo": {
                "CurrentOpMode": "= pPeerHTInfo->OptMode"
            }
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Set the specified memory range to a specific value.",
        "pre": {
            "s": "!=null",
            "c": "!=null",
            "n": ">=0"
        }
    },
    "kretprobe:dot11d_reset": {
        "description": "Reset the dot11d_info structure for the given ieee80211_device.",
        "pre": {
            "ieee": "!=null"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set new channel map",
        "pre": {
            "dot11d_info->channel_map": "==0",
            "dot11d_info->max_tx_pwr_dbm_list": "==0xFF"
        }
    }
},
{
    "kretprobe:pTriple": {
        "description": "Assigns a pointer to a structure of type chnl_txpower_triple.",
        "pre": {
            "pCoutryIe": "!=null",
            "CoutryIeLen": ">3",
            "NumTriples": ">0",
            "i": ">=0",
            "i": "<NumTriples"
        }
    }
},
{
    "kprobe:pTriple_assignment": {
        "description": "Assigns a pointer to a structure of type chnl_txpower_triple to pTriple.",
        "pre": {
            "pCoutryIe": "!=null",
            "NumTriples": ">0"
        }
    },
    "kprobe:for_loop": {
        "description": "Iterates over the triples.",
        "pre": {
            "i": ">=0",
            "i": "<NumTriples"
        }
    }
},




{
    "kretprobe:vchiq_shutdown": {
        "description": "Shutdown the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "instance->state": "!=null",
            "mutex_lock_killable(&state->mutex)": "==0"
        },
        "post": {
            "status": "==0"
        }
    }
},
{
    "kprobe:vchiq_shutdown": {
        "description": "Shutdown the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "instance->state": "!=null",
            "mutex_lock_killable(&state->mutex)": "==0"
        }
    }
},


{
    "kretprobe:vchiq_bulk_transmit": {
        "description": "Transmit bulk data over VCHIQ",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_transmit": {
        "description": "Transmit bulk data using the vchiq interface.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        }
    }
},
{
    "kretprobe:vchiq_bulk_receive": {
        "description": "Receives bulk data from VCHIQ instance.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_receive": {
        "description": "Receives bulk data using VCHIQ protocol.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null",
            "userdata": "!=null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]",
            "status": "!= -EAGAIN"
        }
    }
},




{
    "kretprobe:vchiq_queue_kernel_message": {
        "description": "Queue a kernel message in the VCHIQ instance.",
        "pre": {
            "instance": "!=null",
            "handle": "unsigned int",
            "data": "!=null",
            "size": "unsigned int"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_queue_kernel_message": {
        "description": "Queue a kernel message in the vchiq instance.",
        "pre": {
            "instance": "!=null",
            "handle": "!=null",
            "data": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:remote_event_create": {
        "description": "This function initializes a single remote_event and the associated wait_queue.",
        "pre": {
            "wq": "!=null",
            "event": "!=null"
        }
    }
},
{
    "kprobe:remote_event_create": {
        "description": "This function initializes a single remote_event and the associated wait_queue.",
        "pre": {
            "wq": "!=null",
            "event": "!=null"
        }
    }
},


{
    "kretprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry",
        "pre": {
            "work_queue_entry": "!=null"
        },
        "post": {
            "return_value": "in [0, <negative values>]"
        }
    }
},
{
    "kprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry",
        "pre": {
            "work_queue_entry": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kretprobe:rtllib_wx_get_wap": {
        "description": "Get the wireless access point address.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "flags": "unsigned long",
            "wrqu.ap_addr.sa_family": "ARPHRD_ETHER",
            "ieee.iw_mode": "not equal to IW_MODE_MONITOR"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spinlock and disable IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:eth_zero_addr": {
        "description": "Set the given Ethernet address to all zeros.",
        "pre": {
            "wrqu->ap_addr.sa_data": "!=null"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy memory area.",
        "pre": {
            "wrqu->ap_addr.sa_data": "!=null",
            "ieee->current_network.bssid": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore": {
        "description": "Release a spinlock and restore IRQs.",
        "pre": {
            "ieee->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:rtllib_wx_get_wap": {
        "description": "Get wireless access point information.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "flags": "!=null",
            "wrqu->ap_addr.sa_family": "ARPHRD_ETHER",
            "ieee->iw_mode": "not equal to IW_MODE_MONITOR"
        }
    }
},


{
    "wrqu->rts.disabled": "wrqu->rts.value == DEFAULT_RTS_THRESHOLD"
},
{
    "kprobe:rtllib_wx_get_rts": {
        "description": "Set the value of wrqu->rts.disabled based on wrqu->rts.value",
        "pre": {
            "wrqu->rts.value": "== DEFAULT_RTS_THRESHOLD"
        }
    }
},
{
    "kretprobe:rtllib_wx_set_scan": {
        "description": "Helper function for setting the scan mode in rtllib_device.",
        "pre": {
            "ieee->iw_mode": "==IW_MODE_MONITOR || ieee->proto_started == false",
            "ieee->link_state": "==MAC80211_LINKED"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:return 0;}out:return ret;}EXPORT_SYMBOL(rtllib_wx_set_scan": {
        "description": "Helper function for rtllib_wx_set_scan.",
        "pre": {
            "ieee->iw_mode": "==IW_MODE_MONITOR || !(ieee->proto_started)",
            "ret": "==0",
            "ieee->link_state": "==MAC80211_LINKED"
        }
    }
},


{
    "kretprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "pre": {
            "dev": "!=null",
            "bInitState": "bool"
        }
    }
},
{
    "kprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "pre": {
            "dev": "!=null",
            "bInitState": "bool"
        }
    }
},

{
    "kprobe:your_function_name": {
        "description": "Description of your function",
        "pre": {
            "ieee->link_state": "!= MAC80211_NOLINK",
            "ieee->iw_mode": {
                "== IW_MODE_INFRA": {
                    "net->capability": "& WLAN_CAPABILITY_ESS"
                },
                "== IW_MODE_ADHOC": {
                    "net->capability": "& WLAN_CAPABILITY_IBSS",
                    "net->channel": "> ieee->ibss_maxjoin_chal"
                }
            },
            "ieee->iw_mode": {
                "== IW_MODE_INFRA": null,
                "== IW_MODE_ADHOC": null
            }
        }
    }
},
{
    "kretprobe:rtllib_frag_cache_find": {
        "description": "Find the fragment entry in the fragment cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rtllib_frag_cache_find": {
        "description": "Find a fragment entry in the rtllib_frag_cache.",
        "pre": {
            "ieee": "!=null",
            "seq": "!=null",
            "frag": "!=null",
            "tid": "!=null",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "for (i = 0; i < NUM_WEP_KEYS; i++)": {
        "description": "Loop over the WEP keys",
        "pre": {
            "i": ">= 0",
            "i": "< NUM_WEP_KEYS"
        }
    }
},
{
    "kprobe:rtllib_wx_set_encode": {
        "description": "Set the encoding for the rtllib device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null"
        }
    }
},
{
    "kretprobe:rtllib_wx_set_encode_ext": {
        "description": "Set the encryption parameters for a wireless device.",
        "pre": {
            "idx": "!= 0",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "ieee->crypt_info.crypt[idx]": "!= null",
            "encoding->flags & IW_ENCODE_DISABLED": "== 0",
            "ext->alg": "!= IW_ENCODE_ALG_NONE"
        }
    }
},
{
    "kprobe:rtllib_wx_set_encode_ext": {
        "description": "Set the wireless encryption parameters.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "ieee->iw_mode": "==IW_MODE_INFRA",
            "idx": "!=0",
            "ext->alg": "!=IW_ENCODE_ALG_WEP",
            "encoding->flags & IW_ENCODE_DISABLED": "==0",
            "ext->alg": "!=IW_ENCODE_ALG_NONE"
        }
    }
},


{
    "kretprobe:alloc_rtllib": {
        "description": "Allocate rtllib device and initialize its variables.",
        "pre": {
            "ieee": "!=null",
            "sizeof_priv": "int",
            "dev": "!=null",
            "i": "int",
            "err": "int"
        },
        "post": {
            "ieee->fts": "DEFAULT_FTS",
            "ieee->scan_age": "DEFAULT_MAX_SCAN_AGE",
            "ieee->open_wep": "1"
        }
    }
},

{
    "kretprobe:rtllib_xmit_inter": {
        "description": "Transmit an skb on a rtllib device.",
        "pre": {
            ".duration_id": "== 0",
            ".seq_ctl": "== 0",
            ".qos_ctl": "== 0",
            "qos_activated": "== 1",
            "dest": "!= null",
            "src": "!= null",
            "crypt": "== null",
            "tcb_desc": "!= null",
            "bIsMulticast": "== false",
            "IsAmsdu": "== false",
            "boolbdhcp": "== false",
            "ieee->lock": "locked"
        }
    }
},

{
    "kretprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, -error_code]"
        }
    }
},
{
    "kretprobe:nvec_register_notifier": {
        "description": "Register a notifier block for nvec_chip events.",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": ">=0",
            "nvec_write_sync()": "called before nvec_register_notifier"
        }
    }
},
{
    "kprobe:nvec_register_notifier": {
        "description": "Register a notifier block for nvec events.",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_write_spi_emulate_9": {
        "description": "write SPI emulating 9-bit",
        "pre": {
            "par": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "len": "% 8 == 0",
            "par->extra": "!=null"
        }
    }
},
{
    "kprobe:fbtft_write_spi_emulate_9": {
        "description": "write SPI emulating 9-bit",
        "pre": {
            "par": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "len": "% 8 == 0",
            "par->extra": "!=null"
        }
    }
},




{
    "kretprobe:fbtft_write_vmem16_bus8": {
        "description": "Buffered write function for fbtft driver.",
        "pre": {
            "par->txbuf.buf": "==null",
            "par->fbtftops.write": "!=null",
            "vmem16": "!=null",
            "len": "!=null"
        }
    }
},

{
    "kretprobe:fbtft_write_vmem16_bus16": {
        "description": "Write the virtual memory buffer with 16-bit bus.",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:fbtft_write_vmem16_bus16": {
        "description": "Write the value of the entry in the screen buffer at the specified offset with 16-bit bus.",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:fbtft_register_backlight": {
        "description": "Register the backlight for the fbtft device.",
        "pre": {
            "par": "!=null",
            "bd": "!=null",
            "bl_props.type": "BACKLIGHT_RAW",
            "par->gpio.led[0]": "==false"
        }
    }
},
{
    "kprobe:fbtft_register_backlight": {
        "description": "Register the backlight for the fbtft device.",
        "pre": {
            "par": "!=null",
            "bd": "!=null",
            "bl_props.type": "BACKLIGHT_RAW",
            "par->gpio.led[0]": "==false"
        }
    }
},
{
    "kretprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure",
        "pre": {
            "display": "!=null",
            "dev": "!=null",
            "pdata": "!=null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure.",
        "pre": {
            "display": "!=null",
            "dev": "!=null",
            "pdata": "!=null",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a TFT frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a TFT frame buffer device",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function",
        "pre": {
            "par": "!=null"
        },
        "post": {
            "return_value": "is_integer"
        }
    }
},
{
    "kprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function",
        "pre": {
            "par": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_probe_common": {
        "description": "Generic device probe() helper function",
        "pre": {
            "display": "!=null",
            "sdev": "!=null",
            "pdev": "!=null",
            "sdev or pdev": "xor(sdev == null, pdev == null)",
            "return value": "==0"
        }
    }
},

{
    "kretprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:of_iommu_get_resv_regions": {
        "description": "Reserved region driver helper for device tree",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:of_iommu_get_resv_regions": {
        "description": "Reserved region driver helper for device tree.",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:iommu_group_alloc": {
        "description": "Allocate a new group",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iommu_group_alloc": {
        "description": "Allocate a new group",
        "pre": {
            "group": "!=null",
            "group->mutex": "unlocked",
            "group->default_domain": "!=null",
            "group->default_domain->type": "in [IOMMU_DOMAIN_BLOCKED, IOMMU_DOMAIN_IDENTITY, IOMMU_DOMAIN_UNMANAGED, IOMMU_DOMAIN_DMA, IOMMU_DOMAIN_DMA_FQ]"
        }
    }
},
{
    "kretprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources",
        "pre": {
            "domain": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources",
        "pre": {
            "domain": "!=null",
            "base": "!=null"
        }
    }
},
{
    "kretprobe:iommu_dma_get_resv_regions": {
        "description": "Reserved region driver helper",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:iommu_dma_get_resv_regions": {
        "description": "Reserved region driver helper",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},


{
    "kretprobe:amd_iommu_domain_enable_v2": {
        "description": "Save us all sanity checks whether devices already in the domain support IOMMUv2. Just force that the domain has no devices attached when it is switched into IOMMUv2 mode.",
        "pre": {
            "dom": "!=null",
            "pasids": "!=null",
            "pdom": "!=null",
            "flags": "!=null",
            "ret": "in [-EBUSY]"
        },
        "post": {
            "ret": "in [-EBUSY]"
        }
    }
},
{
    "kprobe:amd_iommu_domain_enable_v2": {
        "description": "Save us all sanity checks whether devices already in the domain support IOMMUv2. Just force that the domain has no devices attached when it is switched into IOMMUv2 mode.",
        "pre": {
            "dom": "!=null",
            "pasids": "!=null",
            "pdom": "!=null",
            "pdom->dev_cnt": "> 0",
            "pdom->flags & PD_IOMMUV2_MASK": "!= 0",
            "!pdom->gcr3_tbl": "true"
        },
        "post": {
            "ret": "-EBUSY"
        }
    }
},
{
    "kretprobe:device_flush_iotlb": {
        "description": "Command send function for flushing on-device TLB",
        "pre": {
            "dev_data": "!=null",
            "address": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:amd_iommu_flush_tlb_all": {
        "description": "Command send function for flushing on-device TLB",
        "pre": {
            "iommu": "!=null"
        }
    }
},
O,

{
    "kretprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used",
        "pre": {
            "pdev": "!=null",
            "pasid": "!=null",
            "sbdf": "!=null",
            "dev_state": "!=null",
            "dev_state->max_pasids": "!=null",
            "pasid_state": "!=null"
        }
    }
},
{
    "kprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used",
        "pre": {
            "pasid_state": "!=null"
        }
    }
},
{
    "kretprobe:amd_iommu_init_device": {
        "description": "Initialize the device state for AMD IOMMU",
        "pre": {
            "cc_platform_has(CC_ATTR_MEM_ENCRYPT)": true,
            "!amd_iommu_v2_supported()": true,
            "pasids <= 0 || pasids > (PASID_MASK + 1)": true,
            "sbdf": "!=null",
            "dev_state": "!=null",
            "dev_state->lock": "initialized",
            "dev_state->wq": "initialized",
            "dev_state->pdev": "!=null",
            "dev_state->sbdf": "!=null",
            "tmp": "!=null",
            "dev_state->pasid_levels": ">= 0",
            "dev_state->count": "1",
            "dev_state->max_pasids": "pasids",
            "ret": "-ENOMEM",
            "dev_state->states": "!=null",
            "dev_state->domain": "!=null"
        }
    }
},
{
    "kprobe:amd_iommu_init_device": {
        "description": "Initialize AMD IOMMU device",
        "pre": {
            "cc_platform_has(CC_ATTR_MEM_ENCRYPT)": true,
            "amd_iommu_v2_supported()": true,
            "pasids": {
                "constraint": "pasids <= 0 || pasids > (PASID_MASK + 1)",
                "value": "pasids"
            },
            "sbdf": {
                "constraint": "sbdf = get_pci_sbdf_id(pdev)",
                "value": "sbdf"
            },
            "dev_state": {
                "constraint": "dev_state = kzalloc(sizeof(*dev_state), GFP_KERNEL)",
                "value": "dev_state"
            },
            "dev_state == NULL": true,
            "spin_lock_init(&dev_state->lock)": true,
            "init_waitqueue_head(&dev_state->wq)": true,
            "dev_state->pdev": {
                "constraint": "dev_state->pdev = pdev",
                "value": "dev_state->pdev"
            },
            "dev_state->sbdf": {
                "constraint": "dev_state->sbdf = sbdf",
                "value": "dev_state->sbdf"
            },
            "tmp": {
                "constraint": "tmp = pasids",
                "value": "tmp"
            },
            "for (dev_state->pasid_levels = 0; (tmp - 1) & ~0x1ff; tmp >>= 9) dev_state->pasid_levels += 1": true,
            "atomic_set(&dev_state->count, 1)": true,
            "dev_state->max_pasids": {
                "constraint": "dev_state->max_pasids = pasids",
                "value": "dev_state->max_pasids"
            },
            "ret": {
                "constraint": "ret = -ENOMEM",
                "value": "ret"
            },
            "dev_state->states": {
                "constraint": "dev_state->states = (void *)get_zeroed_page(GFP_KERNEL)",
                "value": "dev_state->states"
            },
            "dev_state->states == NULL": true,
            "dev_state->domain": {
                "constraint": "dev_state->domain = iommu_domain_alloc(&pci_bus_type)",
                "value": "dev_state->domain"
            },
            "dev_state->domain == NULL": true
        }
    }
},
{
    "kretprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0, negative error value]"
        }
    }
},
{
    "kprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},


{
    "kretprobe:wait_event": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "pre": {
            "kc": "!=null",
            "atomic_read(&kc->nr_jobs)": "==0",
            "list_empty(&kc->callback_jobs)": "==true",
            "list_empty(&kc->complete_jobs)": "==true",
            "list_empty(&kc->io_jobs)": "==true",
            "list_empty(&kc->pages_jobs)": "==true"
        },
        "post": {
            "destroy_workqueue(kc->kcopyd_wq)": "called",
            "dm_io_client_destroy(kc->io_client)": "called",
            "client_free_pages(kc)": "called",
            "mempool_exit(&kc->job_pool)": "called",
            "kfree(kc)": "called"
        }
    }
},
{
    "kprobe:wait_event": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "pre": {
            "kc": "!=null",
            "atomic_read(&kc->nr_jobs)": "==0",
            "list_empty(&kc->callback_jobs)": "==true",
            "list_empty(&kc->complete_jobs)": "==true",
            "list_empty(&kc->io_jobs)": "==true",
            "list_empty(&kc->pages_jobs)": "==true",
            "kc->kcopyd_wq": "!=null",
            "kc->io_client": "!=null",
            "kc->job_pool": "initialized",
            "kc->kcopyd_wq->workqueue": "!=null"
        }
    }
},

{
    "kprobe:struct_io": {
        "description": "Helper for struct io",
        "pre": {
            "pool": "!=null",
            "bios": "!=null"
        }
    }
},
{
    "kretprobe:dm_kobject_release": {
        "description": "This function is called when releasing a dm kobject.",
        "pre": {
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:dm_kobject_release": {
        "description": "Release method for dm kobject.",
        "pre": {
            "kobj": "!=null"
        }
    }
},




{
    "kretprobe:return;if (bitmap->mddev->bitmap_info.external)return;if (!bitmap->storage.sb_page)": {
        "description": "Update the superblock of the bitmap.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null",
            "bitmap->mddev->bitmap_info.external": "false",
            "!bitmap->storage.sb_page": "true"
        }
    }
},
{
    "kprobe:return;if (bitmap->mddev->bitmap_info.external)return;if (!bitmap->storage.sb_page)": {
        "description": "Update the superblock of the bitmap.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null",
            "bitmap->mddev->bitmap_info.external": "false",
            "bitmap->storage.sb_page": "!=null"
        }
    }
},




{
    "kretprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync(struct bitmap  bitmap, sector_t offset, sector_t  block int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": "!=null",
            "blocks": "<= (PAGE_SIZE>>9)",
            "degraded": "!=null"
        }
    }
},
{
    "kprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync(struct bitmap  bitmap, sector_t offset, sector_t  block int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": "!=null",
            "blocks": "<= (PAGE_SIZE>>9)",
            "degraded": "!=null"
        }
    }
},




{
    "kretprobe:return": {
        "description": "The return value of the function.",
        "pre": {
            "bitmap": "!=null",
            "bitmap->sysfs_can_clear": "==true",
            "bitmap->mddev": "!=null",
            "mddev_is_clustered(bitmap->mddev)": "==true",
            "bitmap->mddev->cluster_info": "!=null",
            "bitmap->cluster_slot": "md_cluster_ops->slot_number(bitmap->mddev)"
        }
    }
},
{
    "kprobe:return": {
        "description": "Return statement",
        "pre": {}
    },
    "kprobe:if (bitmap->sysfs_can_clear)sysfs_put(bitmap->sysfs_can_clear);": {
        "description": "Check if sysfs_can_clear is not null and call sysfs_put",
        "pre": {
            "bitmap->sysfs_can_clear": "!=null"
        }
    },
    "kprobe:if (mddev_is_clustered(bitmap->mddev) && bitmap->mddev->cluster_info &&bitmap->cluster_slot == md_cluster_ops->slot_number(bitmap->mddev))md_cluster_stop(bitmap->mddev);": {
        "description": "Check if mddev is clustered, cluster_info is not null, and cluster_slot matches slot_number",
        "pre": {
            "mddev_is_clustered(bitmap->mddev)": "true",
            "bitmap->mddev->cluster_info": "!=null",
            "bitmap->cluster_slot": "==md_cluster_ops->slot_number(bitmap->mddev)"
        }
    },
    "kprobe:/* Shouldn't be needed - but just in case.... */": {
        "description": "Comment",
        "pre": {}
    }
},

{
    "kprobe:md_handle_request": {
        "description": "Handle a request in the mddev structure with the given bio.",
        "pre": {
            "mddev": "!=null",
            "bio": "!=null",
            "bio->bi_opf": "& REQ_NOWAIT != 0"
        }
    }
},
{
    "kretprobe:wait_event_lock_irq": {
        "description": "Flush requests wait until ongoing flush complete hence coalescing all the pending requests.",
        "pre": {
            "mddev->sb_wait": "!=null",
            "!mddev->flush_bio || ktime_before(req_start, mddev->prev_flush_start)",
            "mddev->lock": "!=null"
        }
    }
},
{
    "kprobe:wait_event_lock_irq": {
        "description": "Wait for an event while holding a lock and handling IRQs.",
        "pre": {
            "mddev": "!=null",
            "mddev->sb_wait": "!=null",
            "mddev->flush_bio": "!=null",
            "req_start": "!=null",
            "mddev->prev_flush_start": "!=null",
            "mddev->lock": "!=null",
            "!mddev->flush_bio || ktime_before(req_start, mddev->prev_flush_start)": "true"
        }
    }
},

{
    "kprobe:md_integrity_register": {
        "description": "Register integrity for md device",
        "pre": {
            "!mddev->gendisk": "true",
            "blk_get_integrity(mddev->gendisk)": "true"
        }
    }
},
{
    "kretprobe:md_integrity_add_rdev": {
        "description": "Add a new device to the MD RAID array with integrity checking.",
        "pre": {
            "mddev": "!=null",
            "rdev": "!=null",
            "mddev->gendisk": "!=null",
            "rdev->bdev->bd_disk": "!=null",
            "blk_integrity_compare(mddev->gendisk, rdev->bdev->bd_disk)": "==0"
        }
    }
},
{
    "kprobe:return 0;if (blk_integrity_compare(mddev->gendisk, rdev->bdev->bd_disk) != 0)": {
        "description": "Check the integrity of the block device associated with the given mddev.",
        "pre": {
            "mddev->gendisk": "!= null",
            "rdev->bdev->bd_disk": "!= null"
        }
    }
},






{
    "kretprobe:md_super_write": {
        "description": "Write first size bytes of page to sector of rdev. Increment mddev->pending_writes before returning and decrement it on completion, waking up sb_wait if zero is reached. If an error occurred, call md_error.",
        "pre": {
            "page": "!=null",
            "rdev->flags[Faulty]": "false",
            "rdev->meta_bdev": "!=null",
            "rdev->bdev": "!=null",
            "sector": "!=null",
            "size": "!=null",
            "mddev->flags[MD_FAILFAST_SUPPORTED]": "true",
            "rdev->flags[FailFast]": "true",
            "rdev->flags[LastDev]": "false"
        }
    }
},
{
    "kprobe:md_super_write": {
        "description": "Write the first size bytes of the page to the sector of rdev. Increment mddev->pending_writes before returning and decrement it on completion, waking up sb_wait if zero is reached. If an error occurred, call md_error.",
        "pre": {
            "mddev": "!=null",
            "rdev": "!=null",
            "sector": "!=null",
            "size": "!=null",
            "page": "!=null"
        }
    }
},




{
    "kretprobe:md_write_inc": {
        "description": "Incremental write operation in mddev",
        "pre": {
            "mddev": "!=null",
            "bi": "!=null"
        }
    }
},







{
    "kretprobe:ad_dpot_probe": {
        "description": "Probe function for ad_dpot",
        "pre": {
            "data->feat": "& F_RDACS_WONLY",
            "data->rdac_cache[i]": "= data->max_pos / 2"
        }
    },
    "kretprobe:ad_dpot_probe": {
        "description": "Probe function for ad_dpot",
        "pre": {
            "data->feat": "& F_CMD_INC",
            "err": "= sysfs_create_group(&dev->kobj, &ad525x_group_commands)"
        }
    }
},
{
    "kprobe:if (data->feat & F_RDACS_WONLY)data->rdac_cache[i] = data->max_pos / 2;}if (data->feat & F_CMD_INC)err = sysfs_create_group(&dev->kobj, &ad525x_group_commands);if (err)": {
        "description": "The given function performs certain operations based on the values of 'data->feat' and 'F_RDACS_WONLY' and 'F_CMD_INC'. It updates the 'data->rdac_cache[i]' with 'data->max_pos / 2' if 'data->feat & F_RDACS_WONLY' is true. It also creates a sysfs group using 'sysfs_create_group' if 'data->feat & F_CMD_INC' is true.",
        "pre": {
            "data->feat": "& F_RDACS_WONLY != 0",
            "data->rdac_cache[i]": "= data->max_pos / 2",
            "err": "= sysfs_create_group(&dev->kobj, &ad525x_group_commands)"
        }
    }
},
{
    "kretprobe:c2port_device_register": {
        "description": "Registers a C2 port device.",
        "pre": {
            "ops": "!=null",
            "ops->access": "!=null",
            "ops->c2d_dir": "!=null",
            "ops->c2ck_set": "!=null",
            "ops->c2d_get": "!=null",
            "ops->c2d_set": "!=null"
        }
    }
},
{
    "c2port_device_register": {
        "pre": {
            "name": "!=null",
            "ops": {
                "access": "!=null",
                "c2d_dir": "!=null",
                "c2ck_set": "!=null",
                "c2d_get": "!=null",
                "c2d_set": "!=null",
                "blocks_num": ">0",
                "block_size": ">0"
            },
            "devdata": "any"
        },
        "description": "Registers a C2 port device with the given name and operations."
    }
},
{
    "kretprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:fwnode_irq_get_byname": {
        "description": "Get IRQ from a fwnode using its name",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:fwnode_irq_get_byname": {
        "description": "Get IRQ from a fwnode using its name",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null"
        }
    }
},






{
    "kretprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that.",
        "pre": {
            "dev": "!=null",
            "gfp": "!=null",
            "fmt": "!=null",
            "ap": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that.",
        "pre": {
            "dev": "!=null",
            "gfp": "!=null",
            "fmt": "!=null",
            "ap": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kprobe:request_firmware_prepare": {
        "description": "Prepare to request firmware.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "dbuf": "!=null",
            "size": ">=0",
            "offset": ">=0",
            "opt_flags": ">=0"
        }
    }
},
{
    "kretprobe:firmware_request_cache": {
        "description": "Request firmware with no uevent set.",
        "pre": {
            "device": "!=null",
            "name": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},

{
    "kretprobe:intrequest_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kprobe:intrequest_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer.",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": "!=null",
            "offset": "!=null"
        }
    }
},
{
    "kretprobe:fw_abort_batch_reqs": {
        "description": "Handle failed batched requests and delay the release of struct fw_priv.",
        "pre": {
            "fw": "!=null"
        }
    }
},

{
    "kretprobe:if (capable(CAP_SYS_RAWIO))return true;/* Anybody who can open the device can do a read-safe command `": {
        "description": "Check if the user is capable of performing raw I/O operations and return true if so.",
        "pre": {
            "capable": "CAP_SYS_RAWIO",
            "open_for_write": "false"
        }
    }
},
{
    "kprobe:if (capable(CAP_SYS_RAWIO))return true;/* Anybody who can open the device can do a read-safe command `": {
        "description": "Check if the current user has the capability CAP_SYS_RAWIO and return true if so.",
        "pre": {
            "cmd": "!=null",
            "open_for_write": "!=null"
        }
    }
},
{
    "kretprobe:ioctl_probe": {
        "description": "Return host identification",
        "pre": {
            "host": "!=null",
            "buffer": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ioctl_probe": {
        "description": "Return host identification",
        "pre": {
            "host": "!=null",
            "buffer": "!=null"
        }
    }
},


{
    "kretprobe:scsi_print_command": {
        "description": "Print SCSI command details.",
        "pre": {
            "cmd": {
                "cmd_len": "> 16"
            }
        }
    }
},
{
    "kprobe:scsi_print_command": {
        "description": "Print SCSI command details.",
        "pre": {
            "cmd": {
                "cmd_len": ">16"
            }
        }
    }
},
{
    "kretprobe:scsi_change_queue_depth": {
        "description": "Change a device's queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": "!=null"
        }
    }
},
{
    "kprobe:scsi_change_queue_depth": {
        "description": "Change a device's queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kretprobe:scsi_track_queue_full": {
        "description": "Track QUEUE_FULL events to adjust queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kprobe:scsi_track_queue_full": {
        "description": "Track QUEUE_FULL events to adjust queue depth",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kretprobe:scsi_report_opcode": {
        "description": "Find out if a given command is supported",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null",
            "len": ">=20",
            "opcode": "!=null",
            "sa": ">=0"
        }
    }
},
{
    "kprobe:scsi_report_opcode": {
        "description": "Find out if a given command is supported",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null",
            "len": ">=20",
            "opcode": "!=null",
            "sa": ">=0"
        }
    }
},
{
    "kretprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null",
            "host_lock": "held",
            "device_status": "not in [DEVICE_DELETED, DEVICE_CANCELLED]",
            "lld_module_status": "not in [MODULE_UNLOADING]"
        }
    }
},
{
    "kprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null",
            "host_lock": "held",
            "device_status": "not in [deleted, cancelled]",
            "lld_module_status": "not in [unloading]"
        }
    }
},
{
    "kretprobe:scsi_device_put": {
        "description": "Release a reference to a scsi_device and decrements the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_put": {
        "description": "Release a reference to a scsi_device and decrement the use count of the underlying LLDD module.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:__scsi_iterate_devices": {
        "description": "__scsi_iterate_devices function",
        "pre": {
            "shost": "!=null",
            "prev": "!=null",
            "list": "!=null",
            "next": "!=null",
            "flags": "unsigned long",
            "shost.host_lock": "spin lock",
            "list->next": "!= &shost->__devices",
            "next": "list_entry(list->next, struct scsi_device, siblings)",
            "prev": "!=null"
        }
    }
},
{
    "kprobe:__scsi_iterate_devices": {
        "description": "Iterate through SCSI devices",
        "pre": {
            "shost": "!=null",
            "prev": "!=null",
            "list": "!=null",
            "next": "==null",
            "flags": "unsigned long",
            "list->next": "!=&shost->__devices",
            "!scsi_device_get(next)": "true"
        }
    }
},
{
    "kretprobe:starget_for_each_device": {
        "description": "Helper to walk all devices of a target",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:starget_for_each_device": {
        "description": "Helper to walk all devices of a target",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:__scsi_device_lookup_by_target": {
        "description": "Find a device given the target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "lun": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__scsi_device_lookup_by_target": {
        "description": "Find a device given the target (UNLOCKED)",
        "pre": {
            "starget": "!=null",
            "lun": "!=null"
        }
    }
},
{
    "kretprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued.",
        "pre": {
            "sdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kretprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with.",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with.",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them.",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them.",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_bus_reset": {
        "description": "ask host to perform a bus reset",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_bus_reset": {
        "description": "Ask host to perform a bus reset.",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset",
        "pre": {
            "scmd": "!=null",
            "sdev": {
                "was_reset": 1,
                "expecting_cc_ua": 1
            }
        }
    }
},


{
    "kretprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format).",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer failure timers",
        "pre": {
            "rport": "!=null",
            "rport->mutex": "held",
            "rport->reconnect_delay": ">=0",
            "rport->fast_io_fail_tmo": ">=0",
            "rport->dev_loss_tmo": ">=0",
            "rport->state": "!=SRP_RPORT_LOST"
        }
    }
},
{
    "kprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer failure timers",
        "pre": {
            "rport": "!=null",
            "rport->mutex": "held",
            "rport->reconnect_delay": ">=0",
            "rport->fast_io_fail_tmo": ">=0",
            "rport->dev_loss_tmo": ">=0",
            "rport->state": "not in [SRP_RPORT_LOST]",
            "shost": "!=null",
            "shost->shost_gendev": "!=null",
            "dev_name(&shost->shost_gendev)": "!=null",
            "system_long_wq": "!=null",
            "HZ": "constant"
        }
    }
},
{
    "kretprobe:__rport_fail_io_fast": {
        "description": "This function is called when an I/O operation fails on the SRP rport.",
        "pre": {
            "rport": "!=null",
            "res": "!=0",
            "shost": "!=null",
            "rport->failed_reconnects": ">=0",
            "rport->reconnect_delay": ">=0",
            "delay": ">=0",
            "system_long_wq": "!=null",
            "rport->reconnect_work": "!=null",
            "HZ": ">=0",
            "scsi_block_targets()": "called before this function"
        }
    }
},
{
    "kprobe:__rport_fail_io_fast": {
        "description": "This function is called when an I/O operation fails on the SRP rport.",
        "pre": {
            "rport": "!=null",
            "res": "==0",
            "shost": "!=null",
            "rport->failed_reconnects": ">=0",
            "rport->reconnect_delay": ">=0",
            "delay": ">=0",
            "system_long_wq": "!=null",
            "rport->reconnect_work": "!=null",
            "HZ": ">=0"
        }
    }
},
{
    "kretprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "==0 if sg lists are NULL",
            "return_value": "== -ENOMEM if mapping failed"
        }
    }
},
{
    "kprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": ">=0"
        },
        "error": {
            "return": "==0"
        }
    }
},
{
    "kretprobe:scsi_dma_unmap": {
        "description": "Unmap command's sg lists mapped by scsi_dma_map",
        "pre": {
            "cmd": "!=null"
        }
    }
},

{
    "kretprobe:u32fc_get_event_number": {
        "description": "Obtain the next sequential FC event number",
        "pre": {
            "fc_event_seq": "!=null"
        }
    }
},

{
    "kretprobe:fc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kprobe:fc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_post_event": {
        "description": "Called to post an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "event_data": "!=null"
        }
    }
},
{
    "kprobe:void fc_host_post_event": {
        "description": "Called to post an event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "event_code": "!=null",
            "event_data": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "data_len": "!=null",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kprobe:fc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host.",
        "pre": {
            "shost": "!=null",
            "event_number": "!=null",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn",
        "pre": {
            "shost": "!=null",
            "wwpn": "!=null"
        }
    }
},
{
    "kprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn",
        "pre": {
            "shost": "!=null",
            "wwpn": "!=null"
        }
    }
},
{
    "kretprobe:fc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN.",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kprobe:fc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN.",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_attach_transport": {
        "description": "Attach a transport to the fc_function_template.",
        "pre": {
            "ft": "!=null",
            "i": "!=null",
            "i->t.target_attrs.ac.attrs": "!=null",
            "i->t.target_attrs.ac.class": "&fc_transport_class.class",
            "i->t.target_attrs.ac.match": "fc_target_match",
            "i->t.target_size": "sizeof(struct fc_starget_attrs)",
            "i->t.host_attrs.ac.attrs": "!=null",
            "i->t.host_attrs.ac.class": "&fc_host_class.class",
            "i->t.host_attrs.ac.match": "fc_host_match",
            "i->t.host_size": "sizeof(struct fc_host_attrs)",
            "i->rport_attr_cont.ac.attrs": "!=null",
            "i->rport_attr_cont.ac.class": "&fc_rport_class.class",
            "i->rport_attr_cont.ac.match": "fc_rport_match",
            "i->vport_attr_cont.ac.attrs": "!=null",
            "i->vport_attr_cont.ac.class": "&fc_vport_class.class",
            "i->vport_attr_cont.ac.match": "fc_vport_match",
            "i->f": "ft"
        },
        "post": {
            "i->t.create_work_queue": 1,
            "i->t.user_scan": "fc_user_scan"
        }
    }
},
{
    "kprobe:fc_attach_transport": {
        "description": "Setup SCSI Target Attributes.",
        "pre": {
            "ft": "!=null",
            "i": "!=null",
            "i->t.create_work_queue": "==1",
            "i->t.user_scan": "fc_user_scan"
        }
    }
},
{
    "kretprobe:fc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:void_fc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_remote_port_create": {
        "description": "Create a new remote port entry",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        },
        "post": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:fc_remote_port_create": {
        "description": "Creates a remote port entry.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        },
        "post": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport.",
        "pre": {
            "rport": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport.",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport",
        "pre": {
            "cmnd": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport",
        "pre": {
            "cmnd": "!=null"
        }
    }
},
{
    "kretprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},




{
    "kretprobe:spi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:spi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement",
        "pre": {
            "starget": "!=null"
        }
    }
},
{
    "kprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement",
        "pre": {
            "starget": "!=null"
        }
    }
},

{
    "kprobe:} else if (msg[0] & 0x80)": {
        "description": "Identify",
        "pre": {
            "msg": "!=null",
            "msg[0]": "& 0x80 != 0"
        }
    }
},


{
    "kretprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:sas_get_address": {
        "description": "Return the SAS address of the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:sas_get_address": {
        "description": "Return the SAS address of the device",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_alloc": {
        "description": "Allocates and initializes a SAS PHY structure.",
        "pre": {
            "parent": "!=null",
            "number": ">=0"
        }
    }
},
{
    "kprobe:sas_phy_alloc": {
        "description": "Allocates and initializes a SAS PHY structure.",
        "pre": {
            "parent": "!=null",
            "number": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_free": {
        "description": "Free a SAS PHY",
        "pre": {
            "phy": "!=null",
            "phy->added": "==false"
        }
    }
},
{
    "kprobe:sas_phy_free": {
        "description": "Free a SAS PHY",
        "pre": {
            "phy": "!=null",
            "phy->added": "==false"
        }
    }
},
{
    "kretprobe:sas_port_alloc": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "port_id": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:sas_port_alloc": {
        "description": "Allocate and initialize a SAS port structure.",
        "pre": {
            "parent": "!=null",
            "port_id": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_alloc_num": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "==null"
        }
    }
},
{
    "kprobe:sas_port_alloc_num": {
        "description": "Allocate and initialize a SAS port structure",
        "pre": {
            "parent": "!=null",
            "parent_type": "in [Scsi_Host, sas_expander_device]"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_free": {
        "description": "Free a SAS PORT",
        "pre": {
            "port": "!=null",
            "port->added": "==false"
        }
    }
},
{
    "kprobe:sas_port_free": {
        "description": "Free a SAS PORT",
        "pre": {
            "port": "!=null",
            "port->added": "==false"
        }
    }
},
{
    "kretprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null",
            "port->phys": ">= 0",
            "port->phys_count": ">= 0",
            "port->phys_count": ">= 1",
            "port->phys_count": ">= 2 when port->wide_port == true"
        }
    }
},
{
    "kprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port.",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_initialize": {
        "description": "common rphy initialization",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_initialize": {
        "description": "common rphy initialization",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy",
        "pre": {
            "rphy": "!=null"
        }
    }
},


{
    "kretprobe:scsi_is_sas_port": {
        "description": "Check if a struct device represents a SAS port",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:scsi_is_sas_port": {
        "description": "Check if a struct device represents a SAS port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template.",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kretprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kretprobe:scsi_esp_register": {
        "description": "Register SCSI ESP device",
        "pre": {
            "esp": {
                "num_tags": "!=null"
            },
            "esp->host": {
                "transportt": "esp_transport_template",
                "max_lun": "ESP_MAX_LUN",
                "cmd_per_lun": 2,
                "unique_id": "instance"
            },
            "esp->host->irq": "!=null",
            "esp->dev": "!=null",
            "esp->rev": "!=null",
            "esp->cfreq": "!=null",
            "esp->cfact": "!=null",
            "esp->scsi_id": "!=null"
        }
    }
},

{
    "kretprobe:scsi_remove_host": {
        "description": "Remove a SCSI host",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_remove_host": {
        "description": "Remove a SCSI host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:scsi_add_host_with_dma": {
        "description": "Add a SCSI host with DMA device",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:scsi_add_host_with_dma": {
        "description": "Add a SCSI host with a DMA device.",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        }
    }
},


{
    "kretprobe:scsi_host_lookup": {
        "description": "Look up a SCSI host based on the host number.",
        "pre": {
            "hostnum": "!=null"
        }
    }
},

{
    "kretprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "pre": {
            "shost": "!=null"
        }
    }
},


{
    "kretprobe:#ifdef PROC_STATISTICShostdata->cmd_cnt[i] = 0;hostdata->disc_allowed_cnt[i] = 0;hostdata->disc_done_cnt[i] = 0;#endif}hostdata->input_Q = NULL;hostdata->selecting = NULL;hostdata->connected = NULL;hostdata->disconnected_Q = NULL;hostdata->state = S_UNCONNECTED;hostdata->dma = D_DMA_OFF;hostdata->level2 = L2_BASIC;hostdata->disconnect = DIS_ADAPTIVE;hostdata->args = DEBUG_DEFAULTS;hostdata->incoming_ptr = 0;hostdata->outgoing_len = 0;hostdata->default_sx_per = DEFAULT_SX_PER;hostdata->no_dma = 0;/* default is DMA enabled`": {
        "description": "Set various variables and fields to their default values.",
        "pre": {
            "hostdata->cmd_cnt[i]": "= 0",
            "hostdata->disc_allowed_cnt[i]": "= 0",
            "hostdata->disc_done_cnt[i]": "= 0",
            "hostdata->input_Q": "= NULL",
            "hostdata->selecting": "= NULL",
            "hostdata->connected": "= NULL",
            "hostdata->disconnected_Q": "= NULL",
            "hostdata->state": "= S_UNCONNECTED",
            "hostdata->dma": "= D_DMA_OFF",
            "hostdata->level2": "= L2_BASIC",
            "hostdata->disconnect": "= DIS_ADAPTIVE",
            "hostdata->args": "= DEBUG_DEFAULTS",
            "hostdata->incoming_ptr": "= 0",
            "hostdata->outgoing_len": "= 0",
            "hostdata->default_sx_per": "= DEFAULT_SX_PER",
            "hostdata->no_dma": "= 0"
        }
    }
},

{
    "kretprobe:tmp = (struct scsi_cmnd *) hostdata->input_Q; prev = NULL; while (tmp)": {
        "description": "Assign the value of hostdata->input_Q to tmp and initialize prev as NULL. Then, iterate over the linked list until tmp becomes NULL.",
        "pre": {
            "hostdata": "!=null",
            "hostdata->input_Q": "!=null",
            "tmp": "!=null",
            "prev": "==null"
        }
    }
},
{
    "kprobe:tmp = (struct scsi_cmnd *) hostdata->input_Q;prev = NULL;while (tmp)": {
        "description": "Loop through the input_Q and assign the value of tmp to each element of the input_Q.",
        "pre": {
            "hostdata": "!=null",
            "tmp": "!=null",
            "prev": "null"
        }
    }
},
{
    "kretprobe:cmd->host_scribble = NULL;cmd->result = 0;/* We use the Scsi_Pointer structure that's included with each command * as a scratchpad (as it's intended to be used!). The handy thing about * the SCp.xxx fields is that they're always associated with a given * cmd, and are preserved across disconnect-reselect. This means we * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages * if we keep all the critical pointers and counters in SCp: *  - SCp.ptr is the pointer into the RAM buffer *  - SCp.this_residual is the size of that buffer *  - SCp.buffer points to the current scatter-gather buffer *  - SCp.buffers_residual tells us how many S.G. buffers there are *  - SCp.have_data_in is not used *  - SCp.sent_command is not used *  - SCp.phase records this command's SRCID_ER bit setting `": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use.",
        "pre": {
            "cmd->host_scribble": "==null",
            "cmd->result": "==0"
        }
    }
},
{
    "kprobe:cmd->host_scribble = NULL;cmd->result = 0;/* We use the Scsi_Pointer structure that's included with each command * as a scratchpad (as it's intended to be used!). The handy thing about * the SCp.xxx fields is that they're always associated with a given * cmd, and are preserved across disconnect-reselect. This means we * can pretty much ignore SAVE_POINTERS and RESTORE_POINTERS messages * if we keep all the critical pointers and counters in SCp: *  - SCp.ptr is the pointer into the RAM buffer *  - SCp.this_residual is the size of that buffer *  - SCp.buffer points to the current scatter-gather buffer *  - SCp.buffers_residual tells us how many S.G. buffers there are *  - SCp.have_data_in is not used *  - SCp.sent_command is not used *  - SCp.phase records this command's SRCID_ER bit setting `": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use.",
        "pre": {
            "cmd->host_scribble": "==null",
            "cmd->result": "==0"
        }
    }
},


{
    "kretprobe:wd33c93_show_info": {
        "description": "Show information about the WD33C93 host.",
        "pre": {
            "m": "!=null",
            "instance": "!=null",
            "hd": "!=null",
            "cmd": "!=null",
            "x": "int",
            "hd.proc": "& PR_VERSION | PR_INFO | PR_STATISTICS | PR_CONNECTED | PR_INPUTQ | PR_DISCQ",
            "hd.clock_freq": "int",
            "hd.no_sync": "int",
            "hd.no_dma": "int",
            "hd.dma_mode": "int",
            "hd.fast": "int",
            "hd.sync_xfer": "array[7] of int",
            "hd.sync_stat": "array[7] of int",
            "hd.cmd_cnt": "array[7] of long",
            "hd.disc_allowed_cnt": "array[7] of long",
            "hd.disc_done_cnt": "array[7] of long",
            "hd.int_cnt": "long",
            "hd.dma_cnt": "long",
            "hd.pio_cnt": "long",
            "hd.connected": "bool",
            "cmd.device.id": "int",
            "cmd.device.lun": "long",
            "cmd.cmnd[0]": "int",
            "hd.input_Q": "!=null",
            "hd.disconnected_Q": "!=null"
        }
    }
},
{
    "kprobe:wd33c93_show_info": {
        "description": "Show information about the WD33C93 host.",
        "pre": {
            "m": "!=null",
            "instance": "!=null"
        }
    }
},
{
    "kretprobe:buf[len] = '\\0'; for (bp = buf; *bp; )": {
        "description": "Write information to wd33c93",
        "pre": {
            "instance": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:buf[len] = '\\0'; for (bp = buf; *bp; )": {
        "description": "Loop over the characters in the buffer array until a null character is encountered.",
        "pre": {
            "instance": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key.",
        "pre": {
            "compatible": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null",
            "flags": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key. If @compatible, add to the tail of the list, do not space pad, and set devinfo->compatible. The scsi_static_device_list entries are added with @compatible 1 and @clfags NULL.",
        "pre": {
            "compatible": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null",
            "flags": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key.",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [enum values]"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key.",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:scsi_get_device_flags_keyed": {
        "description": "Get device specific flags from the dynamic device list",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        }
    }
},
{
    "kprobe:scsi_get_device_flags_keyed": {
        "description": "Get device specific flags from the dynamic device list.",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        }
    }
},
{
    "kretprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list",
        "pre": {
            "key": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list",
        "pre": {
            "key": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH]",
            "buffer": "!=null",
            "bufflen": ">0",
            "timeout": ">=0",
            "retries": ">=0",
            "args": "optional"
        }
    }
},
{
    "kprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result.",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "!=null",
            "buffer": "!=null",
            "bufflen": "!=null",
            "timeout": "!=null",
            "retries": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kretprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "pre": {
            "shost": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "pre": {
            "shost": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kretprobe:scsi_block_requests": {
        "description": "Block SCSI requests",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_block_requests": {
        "description": "Block SCSI requests for the given SCSI host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:intscsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary.",
        "pre": {
            "sdev": "!=null",
            "dbd": "in [0, 1]",
            "modepage": "!=null",
            "subpage": "!=null",
            "buffer": "!=null",
            "len": ">=8",
            "timeout": ">=0",
            "retries": ">=0",
            "data": "!=null",
            "sshdr": "in [null, SCSI_SENSE_BUFFERSIZE]"
        }
    }
},
{
    "kprobe:intscsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary.",
        "pre": {
            "sdev": "!=null",
            "dbd": "in [0, 1]",
            "modepage": "!=null",
            "subpage": "!=null",
            "buffer": "!=null",
            "len": ">=8",
            "timeout": ">=0",
            "retries": ">=0",
            "data": "!=null",
            "sshdr": "in [null, SCSI_SENSE_BUFFERSIZE]"
        }
    }
},
{
    "kretprobe:intscsi_test_unit_ready": {
        "description": "Test if unit is ready",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:intscsi_test_unit_ready": {
        "description": "Test if unit is ready",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kretprobe:intscsi_device_set_state": {
        "description": "Take the given device through the device state model.",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_STATE_RUNNING, SCSI_STATE_BLOCK]",
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:intscsi_device_set_state": {
        "description": "Take the given device through the device state model.",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_STATE_RUNNING, SCSI_STATE_BLOCK]",
            "return": "int"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:intscsi_device_quiesce": {
        "description": "Block all commands except power management.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:intscsi_device_quiesce": {
        "description": "Block all commands except power management.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element.",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element.",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual addres previously mapped with scsi_kmap_atomic_sg.",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual addres previously mapped with scsi_kmap_atomic_sg.",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kretprobe:scsi_vpd_lun_id": {
        "description": "Return a unique device identification based on the information in the VPD page 0x83 of the device.",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">=0"
        }
    }
},
{
    "kprobe:scsi_vpd_lun_id": {
        "description": "Return a unique device identification based on the information in the VPD page 0x83 of the device.",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_vpd_tpg_id": {
        "description": "Return a target port group identifier from VPD page 0x83 of the SCSI device.",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kprobe:scsi_vpd_tpg_id": {
        "description": "Return a target port group identifier from VPD page 0x83 of the SCSI device.",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "pre": {
            "type": "!=null"
        },
        "post": {
            "return_value": "in scsi_device_types"
        }
    }
},
{
    "kprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "pre": {
            "type": "!=null",
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsilun_to_int": {
        "description": "Convert a scsi_lun to an int",
        "pre": {
            "scsilun": "!=null"
        }
    }
},
{
    "kprobe:scsilun_to_int": {
        "description": "Convert a scsi_lun to an int",
        "pre": {
            "scsilun": "!=null"
        }
    }
},
{
    "kretprobe:int_to_scsilun": {
        "description": "Reverts an int into a scsi_lun",
        "pre": {
            "lun": "!=null",
            "scsilun": "!=null"
        },
        "post": {
            "scsilun": "is struct scsi_lun",
            "scsilun.lun[0]": "== 0x04",
            "scsilun.lun[1]": "== 0xd2",
            "scsilun.lun[2]": "== 0x0b",
            "scsilun.lun[3]": "== 0x03",
            "scsilun.lun[4]": "== 0x00",
            "scsilun.lun[5]": "== 0x00",
            "scsilun.lun[6]": "== 0x00",
            "scsilun.lun[7]": "== 0x00"
        }
    }
},
{
    "kprobe:int_to_scsilun": {
        "description": "Reverts an int into a scsi_lun",
        "pre": {
            "lun": "!=null",
            "scsilun": "!=null"
        }
    }
},
{
    "kretprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        }
    }
},
{
    "kretprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format.",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer",
        "pre": {
            "desc": "!=null",
            "buf": "!=null",
            "key": "!=null",
            "asc": "!=null",
            "ascq": "!=null"
        }
    }
},
{
    "kprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer.",
        "pre": {
            "desc": "!=null",
            "buf": "!=null",
            "key": "!=null",
            "asc": "!=null",
            "ascq": "!=null"
        }
    }
},
{
    "kretprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "info": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "fp": ">=0",
            "bp": ">=0",
            "cd": "in [0, 1]"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer.",
        "pre": {
            "buf": "!=null",
            "buf_len": ">=0",
            "fp": ">=0",
            "bp": ">=0",
            "cd": "in [0, 1]"
        }
    }
},
{
    "kretprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null"
        },
        "post": {
            "return_value": "in [CHIP_TYPE_A, CHIP_TYPE_B, CHIP_TYPE_C]"
        }
    }
},
{
    "kprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_queuecommand_lck": {
        "description": "The qlogicfas408_queuecommand_lck function",
        "pre": {
            "cmd": "!=null",
            "done": "!=null",
            "priv": "!=null",
            "priv->qlcmd": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_queuecommand_lck": {
        "description": "Function for handling SCSI commands in the qlogicfas408 driver.",
        "pre": {
            "cmd": "!=null",
            "done": "!=null",
            "priv": "!=null",
            "priv->qlcmd": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_host_reset": {
        "description": "Reset SCSI bus",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_host_reset": {
        "description": "Reset SCSI bus",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_info": {
        "description": "Return info string",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_info": {
        "description": "Return info string",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": "!=null",
            "ip": "!=null",
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "==(unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2] > 1024": "true"
        }
    }
},
{
    "kprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": "!=null",
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "==(unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2] > 1024": "true"
        }
    }
},


{
    "kretprobe:qlogicfas408_setup": {
        "description": "Perform initialization tasks",
        "pre": {
            "qbase": "!=null",
            "id": "!=null",
            "int_type": "!=null"
        }
    }
},



{
    "kretprobe:qlogicfas408_disable_ints": {
        "description": "Disable interrupts",
        "pre": {
            "qbase": "!=null",
            "int_type": "!=null",
            "((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7)": true
        }
    }
},



{
    "kretprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:scsi_partsize": {
        "description": "Parse cylinder head sectors from PC partition table",
        "pre": {
            "bdev": "!=null",
            "capacity": "!=null",
            "geom": "!=null",
            "geom[0]": ">=0",
            "geom[1]": ">=0",
            "geom[2]": ">=0"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_partsize": {
        "description": "Parse cylinder head sectors from PC partition table",
        "pre": {
            "bdev": "!=null",
            "capacity": "!=null",
            "geom": "!=null",
            "geom[0]": ">=0",
            "geom[1]": ">=0",
            "geom[2]": ">=0"
        }
    }
},
{
    "kretprobe:logical_end": {
        "description": "Calculate the logical end value",
        "pre": {
            "logical_end": "!=null"
        }
    },
    "kretprobe:largest": {
        "description": "Pointer to the largest structure",
        "pre": {
            "largest": "!=null"
        }
    },
    "kretprobe:largest->start_sect": {
        "description": "Start sector value in the largest structure",
        "pre": {
            "largest->start_sect": "!=null"
        }
    },
    "kretprobe:largest->nr_sects": {
        "description": "Number of sectors value in the largest structure",
        "pre": {
            "largest->nr_sects": "!=null"
        }
    },
    "kretprobe:cyl": {
        "description": "Calculate the cyl value",
        "pre": {
            "cyl": "!=null"
        }
    },
    "kretprobe:largest_cyl": {
        "description": "Update largest_cyl if cyl > largest_cyl",
        "pre": {
            "largest_cyl": "!=null"
        }
    },
    "kretprobe:end_cyl": {
        "description": "Calculate the end_cyl value",
        "pre": {
            "end_cyl": "!=null"
        }
    },
    "kretprobe:end_head": {
        "description": "Assign the end_head value",
        "pre": {
            "end_head": "!=null"
        }
    },
    "kretprobe:end_sector": {
        "description": "Assign the end_sector value",
        "pre": {
            "end_sector": "!=null"
        }
    },
    "kretprobe:physical_end": {
        "description": "Calculate the physical_end value",
        "pre": {
            "physical_end": "!=null"
        }
    }
},
{
    "kprobe:logical_end": {
        "description": "Calculate the logical end value using the get_unaligned_le32 helper function.",
        "pre": {
            "largest": "!=null",
            "largest->start_sect": "!=null",
            "largest->nr_sects": "!=null"
        }
    }
},
{
    "kretprobe:device_remove_file": {
        "description": "Handles concurrent removal calls by serializing them and ignoring the second and later removal attempts.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null"
        }
    },
    "kretprobe:scsi_remove_device": {
        "description": "Serializes concurrent calls and ignores the second and later calls.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kretprobe:sysfs_unbreak_active_protection": {
        "description": "Unbreaks active protection if `kn` is not null.",
        "pre": {
            "kn": "!=null"
        }
    },
    "kretprobe:scsi_device_put": {
        "description": "Decrements the reference count of `sdev`.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kretprobe:store_state_field": {
        "description": "Stores the state field of a device.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:device_remove_file": {
        "description": "Remove a file associated with a device.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null"
        }
    },
    "kprobe:scsi_remove_device": {
        "description": "Remove a SCSI device.",
        "pre": {
            "sdev": "!=null"
        }
    },
    "kprobe:sysfs_unbreak_active_protection": {
        "description": "Unbreak active protection in sysfs.",
        "pre": {
            "kn": "!=null"
        }
    },
    "kprobe:scsi_device_put": {
        "description": "Put a reference to a SCSI device.",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_remove_target": {
        "description": "Try to remove a target and all its devices.",
        "pre": {
            "starget": "!=null",
            "shost": "!=null",
            "flags": "unsigned long",
            "sdev": "struct scsi_device",
            "sdev.channel": "!=starget.channel",
            "sdev.id": "!=starget.id",
            "sdev.sdev_state": "in [SDEV_DEL, SDEV_CANCEL]",
            "!get_device(&sdev.sdev_gendev)": "true",
            "shost.host_lock": "spin_lock_irqsave",
            "scsi_remove_device(sdev)": "true",
            "put_device(&sdev.sdev_gendev)": "true",
            "goto restart": "true",
            "spin_unlock_irqrestore(shost.host_lock, flags)": "true",
            "spin_unlock_irqrestore(shost.host_lock, flags)": "true"
        }
    }
},
{
    "kprobe:scsi_remove_target": {
        "description": "Try to remove a target and all its devices.",
        "pre": {
            "starget": "!=null",
            "shost": "!=null",
            "sdev": "!=null",
            "sdev->channel": "!=starget->channel",
            "sdev->id": "!=starget->id",
            "sdev->sdev_state": "in [SDEV_DEL, SDEV_CANCEL]",
            "!get_device(&sdev->sdev_gendev)": "true",
            "shost->host_lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphical chars from an INQUIRY result string",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphical chars from an INQUIRY result string",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:scsi_target_reap": {
        "description": "Reap the SCSI target and return the SCSI device.",
        "pre": {
            "starget": "!=null"
        },
        "post": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_target_reap": {
        "description": "Reap the SCSI target and put the device.",
        "pre": {
            "starget": "!=null"
        }
    },
    "kprobe:put_device": {
        "description": "Put the device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:__scsi_add_device": {
        "description": "Add a SCSI device.",
        "pre": {
            "shost": "!=null",
            "channel": "uint",
            "id": "uint",
            "lun": "u64",
            "hostdata": "!=null"
        }
    }
},
{
    "kretprobe:scsi_add_device": {
        "description": "Add a SCSI device to the SCSI host.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "hostdata": "!=null"
        }
    }
},
{
    "kprobe:scsi_add_device": {
        "description": "Add a SCSI device to the SCSI host.",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "hostdata": "!=null",
            "scsi_scan_type": "!=none",
            "starget": "!=null",
            "sdev": "!=null",
            "parent": "!=null",
            "shost->shost_gendev": "!=null",
            "scsi_host_scan_allowed(shost)": "==true",
            "scsi_autopm_get_host(shost)": "==0"
        }
    }
},
{
    "kretprobe:return;starget = scsi_alloc_target(parent, channel, id);if (!starget)return;scsi_autopm_get_target(starget);if (lun != SCAN_WILD_CARD)": {
        "description": "Scan a SCSI target",
        "pre": {
            "parent": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "rescan": "in [SCSI_SCAN_NORMAL, SCSI_SCAN_ASYNC]"
        }
    }
},
{
    "kprobe:return;starget = scsi_alloc_target(parent, channel, id);if (!starget)return;scsi_autopm_get_target(starget);if (lun != SCAN_WILD_CARD)": {
        "description": "Scan a SCSI target",
        "pre": {
            "parent": "!=null",
            "channel": "!=null",
            "id": "!=null",
            "lun": "!=null",
            "rescan": "in [SCSI_SCAN_NORMAL, SCSI_SCAN_ASYNC]"
        }
    }
},
{
    "kretprobe:scsi_scan_host_selected": {
        "description": "Scan and select a SCSI host.",
        "pre": {
            "sdev->sdev_state": "== SDEV_DEL",
            "channel": "!= SCAN_WILD_CARD",
            "channel": "> shost->max_channel",
            "id": "!= SCAN_WILD_CARD",
            "id": ">= shost->max_id",
            "lun": "!= SCAN_WILD_CARD",
            "lun": ">= shost->max_lun",
            "shost->async_scan": "== false",
            "scsi_host_scan_allowed(shost)": "== true",
            "scsi_autopm_get_host(shost)": "== 0",
            "channel": "== SCAN_WILD_CARD",
            "channel": "in [0, shost->max_channel]",
            "id": "!= null",
            "lun": "!= null",
            "rescan": "!= null",
            "scsi_autopm_put_host(shost)": "exists",
            "return": "== 0"
        }
    }
},
{
    "kprobe:scsi_sysfs_add_devices": {
        "description": "Add devices to sysfs for a SCSI host.",
        "pre": {
            "sdev->sdev_state": "== SDEV_DEL"
        }
    }
},


{
    "kretprobe:static inline intNCR_700_data_residual (struct Scsi_Host *host)": {
        "description": "Return residual data count of what's in the chip.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:static inline intNCR_700_data_residual (struct Scsi_Host *host)": {
        "description": "Return residual data count of what's in the chip.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Lock the host and check if istat has SCSI_INT_PENDING or DMA_INT_PENDING set.",
        "pre": {
            "host": "!=null",
            "host->host_lock": "!=null",
            "flags": "!=null",
            "istat": "!=null",
            "istat & (SCSI_INT_PENDING | DMA_INT_PENDING)": "!=0"
        }
    }
},
{
    "kprobe:spin_lock_irqsave": {
        "description": "Acquire a spin lock and disable interrupts.",
        "pre": {
            "host->host_lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:NCR_700_readb": {
        "description": "Read a byte from the NCR 700 device.",
        "pre": {
            "host": "!=null",
            "ISTAT_REG": "!=null"
        }
    },
    "kprobe:bitwise_and": {
        "description": "Perform a bitwise AND operation.",
        "pre": {
            "istat": "!=null",
            "SCSI_INT_PENDING | DMA_INT_PENDING": "!=null"
        }
    }
},
{
    "kretprobe:fas216_init_chip": {
        "description": "Initialise FAS216 state after reset",
        "pre": {
            "info": "!=null"
        }
    }
},

{
    "kretprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process",
        "pre": {
            "SCpnt": "!=null",
            "done": "!=null"
        }
    }
},
{
    "fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_internal_done": {
        "description": "Trigger restart of a waiting thread in fas216_command",
        "pre": {
            "SCpnt": "!=null",
            "SCpnt": "is_valid_scsi_cmnd",
            "fas216_command": "is_waiting_for_thread_restart"
        }
    }
},
{
    "kprobe:fas216_internal_done": {
        "description": "Description of the function",
        "pre": {
            "SCpnt": "Condition for SCpnt"
        }
    }
},
{
    "kretprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "pre": {
            "info": "!=null"
        },
        "post": {
            "return_value": "in [IRQ_NONE, IRQ_HANDLED, IRQ_WAKE_THREAD]"
        }
    }
},
{
    "kprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fas216_release": {
        "description": "Release all resources for FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:fas216_release": {
        "description": "Release all resources for FASNCRAMD SCSI ic.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_abort": {
        "description": "Abort this command.",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [FAILED, SUCCESS]"
        }
    }
},
{
    "kprobe:fas216_eh_abort": {
        "description": "Abort this command.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [FAILED, SUCCESS]"
        },
        "notes": "Further commands are blocked."
    }
},
{
    "kretprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "==FAILED"
        }
    }
},
{
    "kprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_initialise": {
        "description": "Initialize a message queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},

{
    "kretprobe:msgqueue_free": {
        "description": "Free a queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_free": {
        "description": "Free a queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_getmsg": {
        "description": "Return a message from the specified queue.",
        "pre": {
            "msgq": "!=null",
            "msgno": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_getmsg": {
        "description": "Return a message from the queue.",
        "pre": {
            "msgq": "!=null",
            "msgno": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "pre": {
            "msgq": "!=null",
            "length": "!=null",
            "...": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "pre": {
            "msgq": "!=null",
            "length": ">=0",
            "...": "valid message bytes"
        }
    }
},
{
    "kretprobe:msgqueue_flush": {
        "description": "Flush all messages from the message queue.",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_flush": {
        "description": "Flush all messages from message queue",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:queue_initialise": {
        "description": "Initializes a queue.",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_initialise": {
        "description": "Initialise a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:queue_free": {
        "description": "Free a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_free": {
        "description": "Free a queue",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "!=null"
        }
    }
},
{
    "kprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "int"
        },
        "post": {
            "return": "int"
        }
    }
},


{
    "kretprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null",
            "tag": "!=null"
        },
        "post": {
            "return": "struct scsi_cmnd",
            "constraints": "!=null"
        }
    }
},
{
    "kprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag",
        "pre": {
            "queue": "!=null",
            "target": "any",
            "lun": "any",
            "tag": "any"
        }
    }
},
{
    "kretprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues.",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target.",
        "pre": {
            "queue": "!=null",
            "target": "!=null"
        }
    }
},
{
    "kprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target.",
        "pre": {
            "queue": "!=null",
            "target": "!=null"
        }
    }
},
{
    "kretprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null"
        },
        "post": {
            "return_value": "in [0, !=0]"
        }
    }
},
{
    "kprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "pre": {
            "queue": "!=null",
            "target": "!=null",
            "lun": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance",
        "pre": {
            "fip": "!=null",
            "mode": "in [FIP_MODE_INIT, FIP_MODE_AUTO]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance",
        "pre": {
            "fip": "!=null",
            "mode": "in [FIP_MODE_1, FIP_MODE_2, FIP_MODE_3]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller",
        "pre": {
            "fip": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller",
        "pre": {
            "fip": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate.",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null",
            "return_value": "==0",
            "skb_length": "% 4 == 0",
            "skb_headroom": ">= 28",
            "skb_tailroom": ">= 8",
            "skb_type": "==fc_frame"
        }
    }
},
{
    "kprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate.",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null",
            "skb_length": "% 4 == 0",
            "skb_headroom": ">= 28",
            "skb_tailroom": ">= 8",
            "skb_type": "fc_frame"
        },
        "post": {
            "return_value": "== 0"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "pre": {
            "fip": "!=null",
            "state": "in [DISABLED, LINK_WAIT, AUTO, NON_FIP, ENABLED, VNMP_START, VNMP_PROBE1, VNMP_PROBE2, VNMP_CLAIM, VNMP_UP]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "pre": {
            "fip": "!=null",
            "state": "in [DISABLED, LINK_WAIT, AUTO, NON_FIP, ENABLED, VNMP_START, VNMP_PROBE1, VNMP_PROBE2, VNMP_CLAIM, VNMP_UP]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "fp": "!=null",
            "fip->flogi_oxid": "!=FC_XID_UNKNOWN"
        },
        "post": {
            "return_value": "!=0"
        }
    }
},
{
    "kprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "fp": "!=null",
            "fip->flogi_oxid": "!=FC_XID_UNKNOWN"
        }
    }
},
{
    "kretprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return_value": "0"
        }
    }
},
{
    "kprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:fc_frame_crc_check": {
        "description": "Check the CRC of the fc_frame",
        "pre": {
            "fp": "!=null",
            "bp": "!=null",
            "crc": "!=null",
            "error": "!=null",
            "len": ">=0",
            "fr_flags(fp)": "&= ~FCPHF_CRC_UNCHECKED",
            "len": "== (fr_len(fp) + 3) & ~3"
        },
        "post": {
            "error": "== (crc ^ fr_crc(fp))"
        }
    }
},
{
    "kprobe:fc_frame_crc_check": {
        "description": "Calculate the CRC and check for errors in the fc_frame structure.",
        "pre": {
            "fp": "!=null",
            "bp": "!=null",
            "crc": "!=null",
            "error": "!=null",
            "len": ">=0",
            "fr_flags(fp)": "&= ~FCPHF_CRC_UNCHECKED",
            "len": "==((fr_len(fp) + 3) & ~3)"
        }
    }
},

{
    "kprobe:fc_frame_alloc_fill": {
        "description": "Allocate and fill an FC frame.",
        "pre": {
            "lp": "!=null",
            "payload_len": ">=0"
        }
    }
},
{
    "kretprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_create": {
        "description": "Create a new remote port",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_create": {
        "description": "Create a new remote port",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_destroy": {
        "description": "Free a remote port after the last reference is released",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_destroy": {
        "description": "Free a remote port after the last reference is released",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout",
        "pre": {
            "rport": "!=null",
            "timeout": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout",
        "pre": {
            "rport": "!=null",
            "timeout": "!=null",
            "timeout": "is_integer",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:fc_rport_login": {
        "description": "Start the remote port login state machine",
        "pre": {
            "rdata": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_login": {
        "description": "Start the remote port login state machine",
        "pre": {
            "rdata": "!=null"
        }
    }
},


{
    "kretprobe:fc_rport_recv_req": {
        "description": "Handler for requests",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_recv_req": {
        "description": "Handler for requests",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "pre": {
            "rport_event_queue": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "pre": {
            "rport_event_queue": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port",
        "pre": {
            "rport": "!=null"
        }
    }
},

{
    "kprobe:fc_disc_config": {
        "description": "Configure the discovery layer for a local port",
        "pre": {
            "lport": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0"
        }
    }
},
{
    "kprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0"
        }
    }
},
{
    "kretprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID",
        "pre": {
            "n_port": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID",
        "pre": {
            "n_port": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null",
            "lp_mutex": "held"
        }
    }
},
{
    "kprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null",
            "lp_mutex": "held"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "pre": {
            "fc_cpu_mask": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "pre": {
            "fc_cpu_mask": "!=null"
        }
    }
},
{
    "kretprobe:fc_seq_send_locked": {
        "description": "Send the frame.",
        "pre": {
            "fr_max_payload(fp)": true,
            "sp->cnt": ">= 0",
            "fr_len(fp)": ">= sizeof(*fh)",
            "fh": "!= null"
        }
    }
},
{
    "kprobe:fc_seq_send_locked": {
        "description": "Send the frame.",
        "pre": {
            "fp": "!=null",
            "sp": "!=null",
            "fr_max_payload(fp)": "!=0",
            "fr_len(fp)": ">sizeof(*fh)"
        }
    }
},
{
    "kretprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence.",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence.",
        "pre": {
            "sp": "!=null"
        }
    }
},


{
    "kretprobe:fc_seq_assign": {
        "description": "Assigns a sequence to a Fibre Channel frame.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_seq_assign": {
        "description": "Assign a sequence to a frame in the Fibre Channel protocol.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        }
    }
},
{
    "kprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        }
    }
},
{
    "kretprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "!=null",
            "timer_msec": ">=0"
        }
    }
},
{
    "kprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence",
        "pre": {
            "lport": "!=null",
            "fp": "!=null",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "!=null",
            "timer_msec": ">=0"
        }
    }
},
{
    "kretprobe:fc_exch_update_stats": {
        "description": "Update exchange manager stats for the local port.",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_update_stats": {
        "description": "Update exches stats to lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_2, FC_CLASS_3]",
            "min_xid": ">=0",
            "max_xid": ">=0",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_1, FC_CLASS_2, FC_CLASS_3, FC_CLASS_4]",
            "min_xid": ">=0",
            "max_xid": ">=min_xid",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fill_hdr": {
        "description": "Fill FC header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "any",
            "f_ctl": "any",
            "seq_cnt": "any",
            "parm_offset": "any"
        }
    }
},
{
    "kprobe:fc_fill_hdr": {
        "description": "Fill FC header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "!=null",
            "f_ctl": "!=null",
            "seq_cnt": "!=null",
            "parm_offset": "!=null"
        }
    }
},
{
    "kretprobe:fc_fill_reply_hdr": {
        "description": "Fill FC reply header fields based on request.",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "is an enum value",
            "parm_offset": "is an integer value"
        }
    }
},
{
    "kprobe:fc_fill_reply_hdr": {
        "description": "Fill FC reply header fields based on request",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "is an enum value",
            "parm_offset": "is an unsigned integer"
        }
    }
},
{
    "kretprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        },
        "post": {
            "return": "in [0, negative error]"
        }
    }
},
{
    "kprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider.",
        "pre": {
            "type": "in [FC_TYPE_FCP]",
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_port_state": {
        "description": "Return the port state of the given Scsi_Host",
        "pre": {
            "shost": "!=null"
        }
    }
},

{
    "kretprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host.",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics",
        "pre": {
            "shost": "!=null",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_login": {
        "description": "Start the lport state machine",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fabric_login": {
        "description": "Start the lport state machine",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkup": {
        "description": "Handler for transport linkup events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkup": {
        "description": "Handler for transport linkup events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric",
        "pre": {
            "lport": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "pre": {
            "lport": "!=null",
            "mfs": "!=null"
        }
    }
},
{
    "kprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "pre": {
            "lport": "!=null",
            "mfs": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint.",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint.",
        "pre": {
            "lport": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_reset": {
        "description": "Reset a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_reset": {
        "description": "Reset a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_config": {
        "description": "Configure a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_config": {
        "description": "Configure a fc_lport",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kretprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_abort": {
        "description": "Abort a command",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_abort": {
        "description": "Abort a command",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host.",
        "pre": {
            "sc_cmd": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host.",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host",
        "pre": {
            "sdev": "!=null",
            "sdev->host": "!=null",
            "sdev->host->cmd_per_len": ">=0"
        }
    }
},
{
    "kprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host",
        "pre": {
            "sdev": "!=null",
            "sdev->host": "!=null",
            "sdev->host->cmd_per_len": ">=0"
        }
    }
},
{
    "kretprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame",
        "pre": {
            "lport": "!=null",
            "did": "!=null",
            "fp": "!=null",
            "op": "!=null",
            "resp": "!=null",
            "arg": "!=null",
            "timer_msec": "!=null"
        }
    }
},
{
    "kprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame",
        "pre": {
            "lport": "!=null",
            "did": "!=null",
            "fp": "!=null",
            "op": "!=null",
            "resp": "!=null",
            "arg": "!=null",
            "timer_msec": "!=null"
        }
    }
},
{
    "kretprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer",
        "pre": {
            "lport": "!=null"
        }
    }
},


{
    "kretprobe:i = phys_suspended(ha);if (i)dev_info(ha->dev, \"waiting up to 25 seconds for %d phy%s to resume\\n\", i, i > 1 ? \"s\" : \"\");wait_event_timeout(ha->eh_wait_q, phys_suspended(ha) == 0, tmo);for (i = 0; i < ha->num_phys; i++)": {
        "description": "Resume the SAS host adapter and wait for all phys to resume",
        "pre": {
            "ha": "!=null",
            "tmo": ">=0",
            "i": ">=0",
            "ha->dev": "!=null",
            "ha->num_phys": ">=0"
        }
    }
},
{
    "kprobe:i = phys_suspended(ha);if (i)dev_info(ha->dev, \"waiting up to 25 seconds for %d phy%s to resume\\n\", i, i > 1 ? \"s\" : \"\");wait_event_timeout(ha->eh_wait_q, phys_suspended(ha) == 0, tmo);for (i = 0; i < ha->num_phys; i++)": {
        "description": "Resume SAS host adapter and wait for all phys to resume",
        "pre": {
            "ha": "!=null",
            "tmo": ">=0",
            "i": ">=0",
            "i > 1 ? \"s\" : \"\"": "is a valid string",
            "phys_suspended(ha)": "==0"
        }
    }
},
{
    "kretprobe:sas_suspend_ha": {
        "description": "Suspend the SAS host adapter and flush suspend events while unregistered.",
        "pre": {
            "ha": "!=null",
            "ha->drain_mutex": "!=null",
            "ha->sas_port": "!=null",
            "ha->num_phys": ">=0",
            "port": "!=null",
            "port->discover_event": "in [DISCE_SUSPEND]",
            "ha->core.shost": "!=null",
            "ha->core.shost->host_blocked": "==true"
        }
    }
},
{
    "kprobe:sas_suspend_ha": {
        "description": "Suspend the SAS host adapter and flush suspend events while unregistered.",
        "pre": {
            "ha": "!=null",
            "ha->drain_mutex": "!=null"
        }
    }
},



{
    "kprobe:mutex_lock": {
        "description": "Locks the specified mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:tgt->tgt_stop": {
        "description": "Sets tgt_stop flag to 1.",
        "pre": {
            "tgt": "!=null"
        }
    },
    "kprobe:qlt_clear_tgt_db": {
        "description": "Clears the target database for qlt.",
        "pre": {
            "tgt": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlocks the specified mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlocks the qla_tgt_mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:ql_dbg": {
        "description": "Debugs the target management.",
        "pre": {
            "vha": "!=null",
            "tgt": "!=null"
        }
    },
    "kprobe:spin_lock_irqsave": {
        "description": "Locks the specified spin lock and saves the IRQ state.",
        "pre": {
            "lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:do": {
        "description": "Performs the specified action.",
        "pre": {
            "action": "!=null"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "The ql_dbg function",
        "pre": {
            "vha": "!=null",
            "vha->flags.online": "!=null",
            "qla2x00_reset_active(vha)": "!=null",
            "mcmd->reset_count": "!=null",
            "qpair->chip_reset": "!=null",
            "mcmd->flags": "== QLA24XX_MGMT_SEND_NACK"
        },
        "post": {
            "mcmd->sess": "!=null",
            "mcmd->sess->vha": "!=null",
            "mcmd->sess->vha->hw": "!=null",
            "mcmd->qpair": "!=null",
            "mcmd->qpair->qp_lock_ptr": "!=null"
        }
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Debug function ql_dbg",
        "pre": {
            "vha": "!=null",
            "mcmd": "!=null",
            "mcmd->sess": "!=null",
            "mcmd->sess->vha": "!=null",
            "mcmd->sess->vha->hw": "!=null",
            "mcmd->qpair": "!=null",
            "mcmd->qpair->qp_lock_ptr": "!=null",
            "mcmd->flags": "== QLA24XX_MGMT_SEND_NACK",
            "vha->flags.online": "== true",
            "mcmd->reset_count": "== mcmd->qpair->chip_reset"
        }
    }
},

{
    "kprobe:qlt_xmit_response": {
        "description": "Transmit response for qla_tgt_cmd",
        "pre": {
            "cmd->state": "QLA_TGT_STATE_PROCESSED",
            "ql_dbg_qp": {
                "arg1": "ql_dbg_async",
                "arg2": "qpair",
                "arg3": "0xe101",
                "arg4": {
                    "format": "RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\n",
                    "args": [
                        "vha->flags.online",
                        "qla2x00_reset_active(vha)",
                        "cmd->reset_count",
                        "qpair->chip_reset"
                    ]
                }
            },
            "res": "0"
        },
        "post": {
            "goto": "out_unmap_unlock"
        }
    }
},
{
    "kretprobe:qlt_rdy_to_xfer": {
        "description": "Calculate number of entries and segments required",
        "pre": {
            "cmd->aborted": "== 1",
            "cmd->write_data_transferred": "== 0",
            "cmd->state": "== QLA_TGT_STATE_DATA_IN",
            "vha->hw->tgt.tgt_ops->handle_data(cmd)": "No specific constraint mentioned",
            "ql_dbg_qp(ql_dbg_async, qpair, 0xe102,\"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\\n\",vha->flags.online, qla2x00_reset_active(vha),cmd->reset_count, qpair->chip_reset)": "No specific constraint mentioned"
        },
        "post": {
            "return value": "== 0"
        }
    }
},
{
    "kprobe:qlt_rdy_to_xfer": {
        "description": "Calculate number of entries and segments required",
        "pre": {
            "cmd->aborted": "1",
            "cmd->write_data_transferred": "0",
            "cmd->state": "QLA_TGT_STATE_DATA_IN",
            "vha->hw->tgt.tgt_ops->handle_data(cmd)": "called"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "Debug function for qla_target",
        "pre": {
            "cmd": "!=null",
            "vha": "!=null",
            "cmd->tgt": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd->tag": ">=0",
            "cmd->aborted": "==1",
            "cmd->sg_mapped": "==0"
        }
    }
},
{
    "kprobe:qlt_abort_cmd": {
        "description": "Terminating exchange for aborted cmd",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "cmd->tgt->vha": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd.tag": "!=null",
            "cmd->aborted": "1",
            "cmd->trc_flags": "&= TRC_ABORT",
            "cmd->cmd_lock": "unlocked",
            "cmd->qpair": "!=null",
            "cmd->atio": "!=null",
            "cmd->atio": "!=0",
            "cmd->atio": "!=1"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "Debug function for qla_target.",
        "pre": {
            "vha": "!=null",
            "cmd": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->se_cmd.transport_state": "!=null",
            "cmd->se_cmd.t_state": "!=null",
            "cmd->se_cmd.se_cmd_flags": "!=null"
        },
        "post": {
            "cmd->aborted": "1",
            "cmd->trc_flags": "|= TRC_ABORT"
        }
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Debug function for qla_target",
        "pre": {
            "ql_dbg_tgt_mgt": "!=null",
            "vha": "!=null",
            "cmd": "!=null",
            "cmd->se_cmd.transport_state": "!=null",
            "cmd->se_cmd.t_state": "!=null",
            "cmd->se_cmd.se_cmd_flags": "!=null"
        }
    },
    "kprobe:qlt_send_term_exchange": {
        "description": "Send termination exchange for qla_target",
        "pre": {
            "cmd->qpair": "!=null",
            "cmd": "!=null",
            "&cmd->atio": "!=null",
            "0": "!=null",
            "1": "!=null"
        }
    },
    "kprobe:qlt_abort_cmd": {
        "description": "Abort command for qla_target",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "tgt->vha": "!=null",
            "&cmd->se_cmd": "!=null",
            "se_cmd->tag": "!=null"
        }
    },
    "kprobe:qlt_free_cmd": {
        "description": "Free command for qla_target",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:qlt_lport_register": {
        "description": "Register lport with external module",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": "!=null",
            "npiv_wwpn": "!=null",
            "npiv_wwnn": "!=null",
            "callback": "!=null"
        }
    }
},
{
    "kprobe:qlt_lport_register": {
        "description": "Register lport with external module.",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": "!=null",
            "npiv_wwpn": "!=null",
            "npiv_wwnn": "!=null",
            "callback": "!=null"
        }
    }
},

{
    "kprobe:qlt_lport_deregister": {
        "description": "Deregister lport",
        "pre": {
            "vha": "!=null"
        },
        "post": {
            "lport_deregistered": "true"
        }
    }
},
{
    "kretprobe:SDMMC_GET_HDATA_WIDTH": {
        "description": "Get the host data width - this assumes that HCON has been set with the correct values.",
        "pre": {
            "mci_readl(host, HCON)": "!=null",
            "i": "!=0"
        }
    }
},




{
    "kprobe:mci_writel": {
        "description": "Write the value of host->fifoth_val to the FIFOTH register and invalidate host->prev_blksz with zero.",
        "pre": {
            "host": {
                "type": "struct dw_mci",
                "slot": {
                    "mmc": {
                        "gpio_cd": "exists",
                        "removable": false
                    }
                },
                "biu_clk": "prepared and enabled",
                "ciu_clk": "prepared and enabled",
                "ctrl_reset": false,
                "use_dma": true,
                "dma_ops": {
                    "init": "defined"
                }
            },
            "FIFOTH": "host->fifoth_val",
            "host->prev_blksz": 0
        }
    }
},
{
    "kretprobe:cqhci_resume": {
        "description": "Re-enable is done upon first request",
        "pre": {
            "mmc": "!=null",
            "request_count": ">0",
            "return_value": "==0"
        }
    }
},





{
    "kretprobe:mmc_request_done": {
        "description": "Finish processing an MMC request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_request_done": {
        "description": "Finish processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},


{
    "kretprobe:__mmc_start_request": {
        "description": "Starts an MMC request and waits for it to be done.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->done": "!=null",
            "mmc_wait_for_req_done()": "called"
        }
    }
},
{
    "kprobe:__mmc_start_request": {
        "description": "Starts an MMC request",
        "pre": {
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request.",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors.",
        "pre": {
            "host": "!=null"
        },
        "post": {
            "return": "int"
        },
        "side_effects": [
            "Stop CQE",
            "Stop eMMC",
            "Discard queue in eMMC",
            "Discard queue in CQE",
            "Call mmc_cqe_request_done() on all requests"
        ],
        "error_handling": {
            "eMMC_queue_discard": "Return error if eMMC fails to discard its queue"
        }
    }
},
{
    "kretprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->cap_cmd_during_tfr": "==true"
        }
    }
},
{
    "kprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done",
        "pre": {
            "host": "!=null",
            "mrq": "!=null",
            "mrq->cap_cmd_during_tfr": "==true"
        }
    }
},
{
    "kretprobe:cmd.flags": {
        "description": "Wait for command completion and discard the entire queue.",
        "pre": {
            "host": "!=null",
            "cmd": "!=null",
            "cmd.flags": "in [MMC_RSP_R1B | MMC_CMD_AC]",
            "cmd.flags": "&= ~MMC_RSP_CRC"
        }
    }
},
{
    "kprobe:mmc_wait_for_cmd": {
        "description": "Wait for a command to complete on the MMC host.",
        "pre": {
            "host": "!=null",
            "cmd": {
                "opcode": "MMC_CMDQ_TASK_MGMT",
                "arg": 1
            }
        }
    }
},
{
    "kretprobe:mmc_set_data_timeout": {
        "description": "set the timeout for a data command",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        }
    }
},
{
    "kprobe:mmc_set_data_timeout": {
        "description": "Set the timeout for a data command.",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        },
        "post": {
            "data_timeout_parameters": "computed correctly according to the algorithm given the card type"
        }
    }
},
{
    "kretprobe:__mmc_claim_host": {
        "description": "Exclusively claim a host",
        "pre": {
            "host": "!=null",
            "ctx": "!=null",
            "abort": "!=null",
            "*abort": "==0"
        }
    }
},
{
    "kprobe:__mmc_claim_host": {
        "description": "Exclusively claim a host.",
        "pre": {
            "host": "!=null",
            "ctx": "!=null",
            "abort": "!=null",
            "*abort": "==0"
        }
    }
},
{
    "kretprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL))__pm_wakeup_event(host->w 5000);host->detect_change = 1;mmc_schedule_delayed_work(&host->detect, delay);}/** *mmc_detect_change - process change of state on a MMC socket *@host: host which changed state. *@delay: optional delay to wait before detection (jiffies) * *MMC drivers should call this when they detect a card has been *inserted or removed. The MMC layer will confirm that any *present card is still functional, and initialize any newly *inserted. ": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "pre": {
            "cd_irq": "==true",
            "host->caps & MMC_CAP_NEEDS_POLL": "==0",
            "__pm_wakeup_event(host->w 5000)": "called",
            "host->detect_change": "==1",
            "mmc_schedule_delayed_work(&host->detect, delay)": "called"
        }
    }
},
{
    "kprobe:if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL))__pm_wakeup_event(host->w 5000);host->detect_change = 1;mmc_schedule_delayed_work(&host->detect, delay);}/** *mmc_detect_change - process change of state on a MMC socket *@host: host which changed state. *@delay: optional delay to wait before detection (jiffies) * *MMC drivers should call this when they detect a card has been *inserted or removed. The MMC layer will confirm that any *present card is still functional, and initialize any newly *inserted. ": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "pre": {
            "cd_irq": true,
            "host->caps & MMC_CAP_NEEDS_POLL": false
        }
    }
},
{
    "kretprobe:if (arg == MMC_TRIM_ARG)erase_timeout = card->ext_csd.trim_timeout;elseerase_timeout = card->ext_csd.hc_erase_timeout;} else": {
        "description": "Calculate the erase timeout based on the arguments and card properties.",
        "pre": {
            "card": "!=null",
            "arg": "!=null",
            "qty": "!=null",
            "card->ext_csd.rev": ">= 6",
            "card->ext_csd.erase_group_def & 1": "== 1"
        }
    }
},
{
    "kprobe:if (arg == MMC_TRIM_ARG)erase_timeout = card->ext_csd.trim_timeout;elseerase_timeout = card->ext_csd.hc_erase_timeout;} else": {
        "description": "Helper function for MMC erase timeout calculation.",
        "pre": {
            "card": "!=null",
            "arg": "!=null",
            "qty": "!=null",
            "card->ext_csd.rev": ">=6",
            "card->ext_csd.erase_group_def & 1": "==1"
        }
    }
},

{
    "kprobe:mmc_can_discard": {
        "description": "Check if the MMC card supports discard feature.",
        "pre": {
            "card": "!=null",
            "card->ext_csd.feature_support": "& MMC_DISCARD_FEATURE"
        }
    }
},
{
    "kretprobe:if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))return card->pref_erase;max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);if (mmc_can_trim(card))": {
        "description": "Calculate the maximum discard value for the MMC card.",
        "pre": {
            "card": "!=null",
            "mmc_card_mmc(card)": "true",
            "!(card->ext_csd.erase_group_def & 1)": "true",
            "card->pref_erase": "!=null",
            "mmc_do_calc_max_discard(card, MMC_ERASE_ARG)": "!=null",
            "mmc_can_trim(card)": "true"
        }
    }
},
{
    "kprobe:if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))return card->pref_erase;max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);if (mmc_can_trim(card))": {
        "description": "Calculate the maximum discard value for the MMC card.",
        "pre": {
            "card": "!=null",
            "mmc_card_mmc(card)": "true",
            "!(card->ext_csd.erase_group_def & 1)": "true",
            "card->pref_erase": "!=null",
            "max_discard": "not in [null, 0]",
            "mmc_do_calc_max_discard(card, MMC_ERASE_ARG)": "not in [null, 0]",
            "mmc_can_trim(card)": "true"
        }
    }
},
{
    "kretprobe:mmc_hw_reset": {
        "description": "Reset the card in hardware",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:mmc_hw_reset": {
        "description": "Reset the card in hardware",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kretprobe:if (!ret && host->ops->get_cd && !host->ops->get_cd(host))": {
        "description": "Check if the card is removed and the card detect status and alive check are in sync.",
        "pre": {
            "ret": "false",
            "host->ops->get_cd": "true",
            "!host->ops->get_cd(host)": "true"
        }
    }
},
{
    "kprobe:if (!ret && host->ops->get_cd && !host->ops->get_cd(host))": {
        "description": "Check if the card is removed and reschedule a detect work 200ms later if necessary.",
        "pre": {
            "ret": "false",
            "host->ops->get_cd": "true",
            "!host->ops->get_cd(host)": "true"
        }
    }
},


{
    "kretprobe:if (ctx->cd_irq >= 0)irq = ctx->cd_irq;else if (!(host->caps & MMC_CAP_NEEDS_POLL))irq = gpiod_to_irq(ctx->cd_gpio);if (irq >= 0)": {
        "description": "Condition for assigning value to 'irq' variable in the given function",
        "pre": {
            "ctx->cd_irq": ">= 0",
            "host->caps & MMC_CAP_NEEDS_POLL": "== 0",
            "gpiod_to_irq(ctx->cd_gpio)": ">= 0",
            "irq": ">= 0"
        }
    }
},
{
    "kprobe:if (ctx->cd_irq >= 0)irq = ctx->cd_irq;else if (!(host->caps & MMC_CAP_NEEDS_POLL))irq = gpiod_to_irq(ctx->cd_gpio);if (irq >= 0)": {
        "description": "Condition for assigning irq value based on ctx->cd_irq and host->caps",
        "pre": {
            "ctx->cd_irq": ">= 0",
            "host->caps & MMC_CAP_NEEDS_POLL": "== 0",
            "gpiod_to_irq(ctx->cd_gpio)": ">= 0",
            "irq": ">= 0"
        }
    }
},
{
    "kretprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection.",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "!=null",
            "debounce": ">=0"
        }
    }
},
{
    "kprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection.",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "!=null",
            "debounce": ">=0"
        }
    }
},
{
    "kretprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards",
        "pre": {
            "card": "!=null",
            "card->manual_bkops_enabled": "==true",
            "card->urgent_bkops_level": ">0"
        }
    }
},
{
    "kprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards",
        "pre": {
            "card": "!=null",
            "card->manual_bkops_enabled": "==true",
            "card->urgent_bkops_level": ">0"
        }
    }
},
{
    "kretprobe:mmc_register_driver": {
        "description": "Register a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_register_driver": {
        "description": "Register a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure.",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure.",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mmc_add_host": {
        "description": "Initialise host hardware.",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_add_host": {
        "description": "initialise host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_remove_host": {
        "description": "Remove host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_remove_host": {
        "description": "Remove host hardware",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM",
        "pre": {
            "directory": "!=null",
            "key": "!=null",
            "buf": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM",
        "pre": {
            "directory": "!=null",
            "key": "!=null",
            "buf": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fw_device_enable_phys_dma": {
        "description": "Enable physical DMA for the given fw_device.",
        "pre": {
            "device": "!=null",
            "device->card": "!=null",
            "device->card->driver": "!=null",
            "device->card->driver->enable_phys_dma": "!=null",
            "device->node_id": ">= generation"
        }
    }
},
{
    "kprobe:fw_device_enable_phys_dma": {
        "description": "Enable physical DMA for the given fw_device.",
        "pre": {
            "device": "!=null",
            "device->card": "!=null",
            "device->card->driver": "!=null",
            "device->card->driver->enable_phys_dma": "!=null",
            "device->node_id": ">= generation"
        }
    }
},
{
    "kretprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued.",
        "pre": {
            "card": "!=null",
            "transaction": "!=null",
            "tstamp": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued.",
        "pre": {
            "card": "!=null",
            "transaction": "!=null"
        }
    }
},
{
    "kretprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep.",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "in [TCODE_...]",
            "destination_id": ">generation",
            "speed": "any",
            "offset": "any",
            "payload": "DMA-mapped when length > 8 or not local request",
            "length": "any",
            "callback": "!=null",
            "with_tstamp": "any",
            "callback_data": "any"
        }
    }
},
{
    "kprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep. In case of lock request specify one of the firewire-core specific %TCODE_ constants instead of %TCODE_LOCK_REQUEST in @tcode. Make sure that the value in @destination_id is not older than the one in @generation. Otherwise the request is in danger to be sent to a wrong node. In case of asynchronous stream packets i.e. %TCODE_STREAM_DATA, the caller needs to synthesize @destination_id with fw_stream_packet_destination_id(). It will contain tag, channel, and sy data instead of a node ID then. The payload buffer at @data is going to be DMA-mapped except in case of @length <= 8 or of local (loopback) requests. Hence make sure that the buffer complies with the restrictions of the streaming DMA mapping API. @payload must not be freed before the @callback is called. In case of request types without payload, @data is NULL and @length is 0. After the transaction is completed successfully or unsuccessfully, the @callback will be called. Among its parameters is the response code which is either one of the rcodes per IEEE 1394 or, in case of internal error the firewire-core specific %RCODE_SEND_ERROR. The other firewire-core specific rcodes (%RCODE_CANCELLED, %RCODE_BUSY, %RCODE_GENERATION, %RCODE_NO_ACK) denote transaction timeout, busy responder, stale request generation, or missing ACK respectively. Note some timing corner cases: fw_send_request() may complete much earlier than when the request packet actually hits the wire. On the other hand, transaction completion and hence execution of @callback may happen even before fw_send_request() returns.",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "int",
            "destination_id": "int",
            "generation": "int",
            "speed": "int",
            "offset": "unsigned long long",
            "payload": "void*",
            "length": "size_t",
            "callback": "union fw_transaction_callback",
            "with_tstamp": "bool",
            "callback_data": "void*"
        }
    }
},
{
    "kretprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "quadlet-aligned",
            "region->end": "quadlet-aligned",
            "handler->length": "quadlet-aligned"
        },
        "post": {
            "return value": "==0"
        }
    }
},
{
    "kprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "quadlet-aligned",
            "region->end": "quadlet-aligned",
            "handler->length": "quadlet-aligned"
        }
    }
},
{
    "kretprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler",
        "pre": {
            "handler": "!=null",
            "handler->callback": "!=null",
            "handler->callback()": "not running on any CPU"
        }
    }
},
{
    "kprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler",
        "pre": {
            "handler": "!=null",
            "handler->callback": "!=null",
            "handler->callback()": "not running on any CPU"
        }
    }
},
{
    "kretprobe:fw_send_response": {
        "description": "Send response packet for asynchronous transaction.",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "int"
        }
    }
},
{
    "kprobe:fw_send_response": {
        "description": "Send response packet for asynchronous transaction.",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "!=null"
        }
    }
},
{
    "kretprobe:fw_get_request_speed": {
        "description": "Returns the speed at which the request was received.",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kprobe:fw_get_request_speed": {
        "description": "returns speed at which the @request was received",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kretprobe:fw_core_handle_request": {
        "description": "Handle a request in the fw_core_handle_request function.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "p->ack": "in [ACK_PENDING, ACK_COMPLETE]",
            "HEADER_GET_TCODE(p->header[0])": "is_link_internal",
            "request": "==allocate_request(card, p)"
        }
    }
},
{
    "kprobe:fw_core_handle_request": {
        "description": "Handle a request in the fw_core module.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "p->ack": "in [ACK_PENDING, ACK_COMPLETE]",
            "HEADER_GET_TCODE(p->header[0])": "is_link_internal",
            "request": "==allocate_request(card, p)"
        }
    }
},
{
    "switch (tcode)": {
        "description": "Handle the response based on the value of tcode.",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "t": "null",
            "flags": "any",
            "data": "any",
            "data_length": "any",
            "tcode": "any",
            "tlabel": "any",
            "source": "any",
            "rcode": "any"
        },
        "post": {
            "t": "null",
            "flags": "unchanged",
            "data": "unchanged",
            "data_length": "unchanged",
            "tcode": "unchanged",
            "tlabel": "unchanged",
            "source": "unchanged",
            "rcode": "unchanged"
        }
    }
},
{
    "switch (tcode)": {
        "description": "Handle the response based on the value of tcode.",
        "pre": {
            "p": {
                "header": {
                    "0": {
                        "!=null": true
                    }
                }
            },
            "tcode": "!=null",
            "tlabel": "!=null",
            "source": "!=null",
            "rcode": "!=null",
            "card": {
                "lock": "!=null",
                "transaction_list": {
                    "iter": {
                        "node_id": "!=null",
                        "tlabel": "!=null",
                        "try_cancel_split_timeout": "!=null"
                    }
                },
                "tlabel_mask": "!=null"
            },
            "t": "!=null"
        }
    }
},

{
    "kprobe:fw_rcode_string": {
        "description": "Convert a firewire result code to an error description.",
        "pre": {
            "rcode": "!=null",
            "rcode_type": "int",
            "rcode": "in [FIREWIRE_RESULT_CODE_1, FIREWIRE_RESULT_CODE_2, ...]"
        }
    }
},

{
    "kprobe:fw_core_add_descriptor": {
        "description": "Check if the descriptor is valid and the length of all blocks in the descriptor adds up to exactly the length of the block.",
        "pre": {
            "desc": "!=null",
            "i": "=0",
            "ret": "=0",
            "i < desc->length": "true",
            "i += (desc->data[i] >> 16) + 1": "true",
            "i != desc->length": "false",
            "mutex_lock(&card_mutex)": "true",
            "config_rom_length + required_space(desc) > 256": "true"
        }
    }
},
{
    "kretprobe:card->br_short = short_reset": {
        "description": "Set the value of card->br_short to short_reset.",
        "pre": {
            "card": "!=null",
            "short_reset": "!=null"
        }
    }
},
{
    "kprobe:fw_schedule_bus_reset": {
        "description": "Schedule a bus reset for the given firewire card.",
        "pre": {
            "card": "!=null",
            "delayed": "!=null",
            "short_reset": "!=null"
        }
    }
},
{
    "kretprobe:dummy_driver.free_iso_context": {
        "description": "Free the ISO context of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->free_iso_context": "!=null",
            "flags": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:dummy_driver.stop_iso": {
        "description": "Stop the ISO of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->stop_iso": "!=null",
            "flags": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:card->driver = &dummy_driver": {
        "description": "Assign the dummy driver to card->driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "dummy_driver": "!=null",
            "card->lock": "!=null"
        }
    },
    "kretprobe:spin_lock_irqsave(&card->lock, flags)": {
        "description": "Acquire a spin lock with IRQ save.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kretprobe:fw_destroy_nodes(card)": {
        "description": "Destroy the nodes in fw_destroy_nodes.",
        "pre": {
            "card": "!=null"
        }
    },
    "kretprobe:spin_unlock_irqrestore(&card->lock, flags)": {
        "description": "Release a spin lock with IRQ restore.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:dummy_driver.free_iso_context": {
        "description": "Free the ISO context of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->free_iso_context": "!=null",
            "card->driver->free_iso_context": "dummy_driver.free_iso_context"
        }
    },
    "kprobe:dummy_driver.stop_iso": {
        "description": "Stop the ISO of the dummy driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->stop_iso": "!=null",
            "card->driver->stop_iso": "dummy_driver.stop_iso"
        }
    },
    "kprobe:card->driver = &dummy_driver": {
        "description": "Assign the dummy driver to the card's driver.",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver": "&dummy_driver"
        }
    },
    "kprobe:spin_lock_irqsave(&card->lock, flags)": {
        "description": "Acquire a spin lock and save the IRQ flags.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:fw_destroy_nodes(card)": {
        "description": "Destroy the nodes associated with the card.",
        "pre": {
            "card": "!=null"
        }
    },
    "kprobe:spin_unlock_irqrestore(&card->lock, flags)": {
        "description": "Release the spin lock and restore the IRQ flags.",
        "pre": {
            "card": "!=null",
            "card->lock": "!=null",
            "flags": "!=null"
        }
    }
},


{
    "kretprobe:fw_iso_resource_manage": {
        "description": "Allocate or deallocate a channel and/or bandwidth.",
        "pre": {
            "card": "!=null",
            "generation": ">=0",
            "channels_mask": ">=0",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "in [true, false]"
        },
        "post": {
            "channel": "<0 or >=0",
            "bandwidth": "=0 or >0"
        }
    }
},
{
    "kprobe:fw_iso_resource_manage": {
        "description": "Allocate or deallocate a channel and/or bandwidth.",
        "pre": {
            "card": "!=null",
            "generation": ">=0",
            "channels_mask": ">=0",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "in [true, false]",
            "channel < 0": "bandwidth = 0",
            "generation is stale": "channel = -EAGAIN",
            "channel allocation fails": "bandwidth = 0",
            "bandwidth allocation fails": "channel < 0"
        }
    }
},
{
    "kretprobe:devfreq_get_freq_range": {
        "description": "Get the current frequency range",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_get_freq_range": {
        "description": "Get the current frequency range.",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior",
        "pre": {
            "devfreq": "!=null",
            "freq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior",
        "pre": {
            "devfreq": "!=null",
            "freq": "!=null"
        }
    }
},

{
    "kprobe:devfreq_update_target": {
        "description": "Update the target frequency for a devfreq device.",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        }
    }
},
{
    "kretprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_interval": {
        "description": "Update device devfreq monitoring interval",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},
{
    "kprobe:devfreq_update_interval": {
        "description": "Update device devfreq monitoring interval",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},


{
    "kretprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device.",
        "pre": {
            "devfreq": "==null"
        }
    }
},
{
    "kprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device.",
        "pre": {
            "devfreq": "==null"
        }
    }
},
{
    "kretprobe:devm_devfreq_add_device": {
        "description": "Resource-managed devfreq_add_device()",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_add_device": {
        "description": "Resource-managed devfreq_add_device()",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device.",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback.",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback.",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore.",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "== DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},

{
    "kprobe:rio_query_mport": {
        "description": "Query mport device attributes",
        "pre": {
            "port": "!=null",
            "mport_attr": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
            "len": "<=5"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_update": {
        "description": "Update a register",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_update": {
        "description": "Update a register",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Send a simple command",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Send a simple command",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Command with data",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "size": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Command with data",
        "pre": {
            "scu": "!=null",
            "cmd": "!=null",
            "sub": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "size": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kretprobe:wmi_driver_unregister": {
        "description": "Unregister a WMI driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:wmi_driver_unregister": {
        "description": "Unregister a WMI driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:dcdbas_smi_request": {
        "description": "generate SMI request",
        "pre": {
            "smi_data_lock": "!=null"
        }
    }
},

{
    "kretprobe:intel_punit_ipc_simple_command": {
        "description": "Simple IPC command",
        "pre": {
            "cmd": "!=null",
            "para1": ">=0",
            "para1": "<=255",
            "para2": ">=0",
            "para2": "<=255"
        }
    }
},
{
    "kprobe:intel_punit_ipc_simple_command": {
        "description": "Simple IPC command",
        "pre": {
            "cmd": "!=null",
            "para1": ">=0",
            "para2": ">=0"
        }
    }
},
{
    "kretprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "ec_msg->result": "==EC_RES_IN_PROGRESS"
        },
        "post": {
            "return": "== -EAGAIN"
        }
    }
},
{
    "kprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "ec_msg->result": "==EC_RES_IN_PROGRESS"
        },
        "post": {
            "return": "== -EAGAIN"
        }
    }
},
{
    "kretprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_cmd_xfer": {
        "description": "Execute an EC command and handle communication with the EC device.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return_value": {
                ">": 0,
                "=": 0,
                "<": 0
            }
        }
    }
},
{
    "kprobe:cros_ec_cmd_xfer": {
        "description": "Execute an EC command and transfer data between the Linux host and the EC.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null",
            "has_more_events": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null",
            "has_more_events": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        },
        "post": {
            "return_value": "in [IRQ_NONE, IRQ_HANDLED, IRQ_WAKE_THREAD]"
        }
    }
},
{
    "kprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "in [IRQ_HANDLED, IRQ_NONE]"
        }
    }
},
{
    "kretprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device.",
        "pre": {
            "ec_dev": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read/write bytes to MEC EMI port.",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": "!=null",
            "length": "!=null",
            "buf": "!=null"
        },
        "post": {
            "return_value": "is an 8-bit checksum of all bytes read/written"
        }
    }
},
{
    "kprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read/write bytes to MEC EMI port.",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": "!=null",
            "length": "!=null",
            "buf": "!=null"
        },
        "post": {
            "return": "is an 8-bit checksum of all bytes read/written"
        }
    }
},


{
    "kretprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "pre": {
            "tm": "!=null"
        }
    }
},
{
    "kprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "pre": {
            "tm": "!=null"
        }
    }
},


{
    "kretprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload.",
        "pre": {
            "hd": "!=null"
        }
    }
},
{
    "kprobe:voidmptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload.",
        "pre": {
            "hd": "!=null"
        }
    }
},


{
    "kretprobe:for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++)": {
        "description": "Loop over the physical disks",
        "pre": {
            "i": ">= 0",
            "i": "< ioc->raid_data.pIocPg3->NumPhysDisks"
        }
    }
},
{
    "kprobe:for (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++)": {
        "description": "Loop over the physical disks in the RAID data",
        "pre": {
            "ioc": "!=null",
            "channel": "!=null",
            "id": "!=null"
        }
    }
},


{
    "kretprobe:mptscsih_info_scsiio": {
        "description": "Debug print info on reply frame",
        "pre": {
            "ioc": "!=null",
            "sc": "!=null",
            "pScsiReply": "!=null"
        }
    }
},
{
    "kprobe:mptscsih_info_scsiio": {
        "description": "Debug print info on reply frame",
        "pre": {
            "ioc": "!=null",
            "sc": "!=null",
            "pScsiReply": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine.",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},



{
    "kprobe:mptscsih_slave_configure": {
        "description": "Configure a SCSI device in the mptscsih driver.",
        "pre": {
            "sdev": "!=null",
            "sh": "!=null",
            "vtarget": "!=null",
            "vdevice": "!=null",
            "starget": "!=null",
            "hd": "!=null",
            "ioc": "!=null",
            "ioc->bus_type": "==SPI",
            "sdev->sdtr": "!=null",
            "sdev->wdtr": "!=null",
            "sdev->ppr": "!=null",
            "sdev->inquiry_len": "!=null",
            "vdevice->configured_lun": "==1",
            "sdev->queue_depth": "!=null",
            "vtarget->tflags": "!=null",
            "vtarget->negoFlags": "!=null",
            "vtarget->maxOffset": "!=null",
            "vtarget->minSyncFactor": "!=null",
            "sdev->tagged_supported": "!=null",
            "sdev->simple_tags": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCES FAILED]"
        }
    }
},
{
    "kretprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCES FAILED]"
        }
    }
},
{
    "kretprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return_value": "in [SUCCES FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">=0x200000",
            "geom": "!=null"
        }
    }
},
{
    "kprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">=0x200000",
            "geom": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_change_queue_depth": {
        "description": "This function will set a device's queue depth.",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kprobe:intmptscsih_change_queue_depth": {
        "description": "This function will set a device's queue depth.",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kretprobe:intmpt_raid_phys_disk_get_num_paths": {
        "description": "Returns the number of paths associated with the given physical disk number.",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null"
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_get_num_paths": {
        "description": "Returns the number of paths associated with the given physical disk number.",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_raid_phys_disk_pg1": {
        "description": "Returns the physical disk page 1",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "!=null"
        },
        "post": {
            "return_value": "in [0, -EFAULT, -ENOMEM]"
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_pg1": {
        "description": "Returns physical disk page 1",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "==null"
        }
    }
},
{
    "kretprobe:intmpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:intmpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management.",
        "pre": {
            "ioc": "!=null",
            "flags": "==0"
        }
    }
},
{
    "kprobe:voidmpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management.",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panics the kernel.",
        "pre": {
            "ioc": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panics the kernel.",
        "pre": {
            "ioc": "!=null"
        }
    }
},


{
    "kretprobe:intmpt_attach": {
        "description": "Install a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:intmpt_attach": {
        "description": "Install a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},

{
    "kprobe:mpt_detach": {
        "description": "Remove a PCI intelligent MPT adapter.",
        "pre": {
            "pdev": "!=null"
        }
    }
},


{
    "kretprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},


{
    "kretprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler.",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in [MPT_DRIVER_CLASS]",
            "func_name": "!=null"
        }
    }
},
{
    "kprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler.",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in [MPT_DRIVER_CLASS values]",
            "func_name": "!=null"
        }
    }
},
{
    "kretprobe:mpt_deregister": {
        "description": "Deregister a protocol driver's resources.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_deregister": {
        "description": "Deregister a protocol driver's resources.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler.",
        "pre": {
            "cb_idx": "!=null",
            "ev_cbfunc": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler.",
        "pre": {
            "cb_idx": "!=null",
            "ev_cbfunc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null",
            "reset_func": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null",
            "reset_func": "!=null"
        }
    }
},
{
    "kretprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler.",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null"
        }
    }
},
{
    "kprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "ioc.active": "==true"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame": {
        "description": "Send a protocol-specific MPT request frame to an IOC",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame": {
        "description": "Send a protocol-specific MPT request frame to an IOC.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kretprobe:if (!cb_idx || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == NULL)": {
        "description": "Check for (valid) IO callback!",
        "pre": {
            "cb_idx": "==0 || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == NULL"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if cb_idx is null or greater than or equal to MPT_MAX_PROTOCOL_DRIVERS or MptCallbacks[cb_idx] is null.",
        "pre": {
            "cb_idx": "==null || cb_idx >= MPT_MAX_PROTOCOL_DRIVERS || MptCallbacks[cb_idx] == null"
        }
    }
},
{
    "kretprobe:intmpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "reqBytes": "!=null",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, !CAN_SLEEP]"
        }
    }
},
{
    "kprobe:intmpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method.",
        "pre": {
            "cb_idx": "!=null",
            "ioc": "!=null",
            "reqBytes": ">=0",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, !CAN_SLEEP]"
        }
    }
},
{
    "kretprobe:intmpt_verify_adapter": {
        "description": "Given IOC identifier, set pointer to its adapter structure.",
        "pre": {
            "iocid": "!=null",
            "iocpp": "!=null"
        },
        "post": {
            "iocid": "found",
            "iocpp": "set if iocid is found",
            "return_value": "-1 if iocid is not found"
        }
    }
},
{
    "kprobe:intmpt_verify_adapter": {
        "description": "Given IOC identifier, set pointer to its adapter structure.",
        "pre": {
            "iocid": "!=null",
            "iocpp": "!=null"
        }
    }
},

"pre": {
    "ioc": "!=null"
},


{
    "kretprobe:if (ioc->alt_ioc)ioc = ioc->alt_ioc;": {
        "description": "Check if `ioc->alt_ioc` is not null and assign its value to `ioc`.",
        "pre": {
            "ioc": "!=null",
            "ioc->alt_ioc": "!=null"
        }
    }
},


{
    "kprobe:mpt_remove_dead_ioc_func": {
        "description": "kthread context to remove dead ioc",
        "pre": {
            "arg": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},


{
    "kretprobe:intmpt_alloc_fw_memory": {
        "description": "Allocate firmware memory",
        "pre": {
            "ioc": "!=null",
            "size": ">=0"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:intmpt_alloc_fw_memory": {
        "description": "Allocate firmware memory",
        "pre": {
            "ioc": "!=null",
            "size": ">=0"
        }
    }
},




{
    "kretprobe:intmpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "any",
            "phys_disk": "any"
        },
        "post": {
            "return": {
                "constraints": [
                    "0",
                    "-EFAULT",
                    "-ENOMEM"
                ]
            }
        }
    }
},
{
    "kprobe:intmpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null",
            "phys_disk": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kretprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver",
        "pre": {
            "drv": "!=null",
            "id_table": "properly populated",
            "probe_routine": "valid"
        }
    }
},
{
    "kprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_add_device": {
        "description": "Add a SuperHyway module",
        "pre": {
            "base": "!=null",
            "sdev": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:superhyway_add_device": {
        "description": "Add a SuperHyway module",
        "pre": {
            "base": "!=null",
            "sdev": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes.",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence",
        "pre": {
            "hba": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence",
        "pre": {
            "hba": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_get_local_unipro_ver": {
        "description": "Get the local UniPro version for the given UFS HBA.",
        "pre": {
            "hba": "!=null",
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "return": "in [UFS_UNIPRO_VER_1_41, UFS_UNIPRO_VER_1_6]"
        }
    }
},
{
    "kprobe:ufshcd_get_local_unipro_ver": {
        "description": "Get the local UniPro version for the given UFS HBA.",
        "pre": {
            "hba": "!=null",
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "return": "in [UFS_UNIPRO_VER_1_41, UFS_UNIPRO_VER_1_6]"
        }
    }
},
{
    "kretprobe:ufshcd_system_suspend": {
        "description": "System suspend callback for UFS controller",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ufshcd_system_suspend": {
        "description": "System suspend callback for the UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_system_resume": {
        "description": "system resume callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_system_resume": {
        "description": "system resume callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_suspend": {
        "description": "runtime suspend callback",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ufshcd_runtime_suspend": {
        "description": "runtime suspend callback",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_resume": {
        "description": "Runtime resume routine for UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_runtime_resume": {
        "description": "Runtime resume routine for the UFS controller.",
        "pre": {
            "dev": "!=null"
        }
    }
},




{
    "kretprobe:v4l2_async_nf_register": {
        "description": "Register a v4l2_async_notifier structure.",
        "pre": {
            "notifier": "!=null",
            "notifier->list": "!=null",
            "notifier_list": "!=null",
            "list_lock": "!=null"
        }
    }
},
{
    "kprobe:v4l2_async_nf_register": {
        "description": "Register a v4l2_async_notifier",
        "pre": {
            "&notifier->list": "!=null",
            "&notifier_list": "!=null",
            "&list_lock": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_async_register_subdev": {
        "description": "Register a V4L2 subdevice asynchronously.",
        "pre": {
            "sd->fwnode": "==null",
            "sd->dev": "!=null",
            "list_lock": "mutex_locked",
            "sd->async_list": "list_empty",
            "notifier_list": "list_not_empty"
        }
    }
},
{
    "kprobe:if (!sd->fwnode && sd->dev)sd->fwnode = dev_fwnode(sd->dev);mutex_lock(&list_lock);INIT_LIST_HEAD(&sd->async_list);list_for_each_entry(notifier, &notifier_list, list)": {
        "description": "Register a V4L2 async sub-device",
        "pre": {
            "sd->fwnode": "==null",
            "sd->dev": "!=null",
            "list_lock": "locked",
            "sd->async_list": "initialized",
            "notifier": "in notifier_list"
        }
    }
},
{
    "kretprobe:v4l2_norm_to_name": {
        "description": "Converts a V4L2 standard ID to its corresponding name.",
        "pre": {
            "id": "!=null",
            "myid": "!=null",
            "standards": "!=null",
            "i": ">=0",
            "i": "<=length(standards)",
            "standards[i].std": "!=null",
            "myid": "==standards[i].std"
        },
        "post": {
            "return": "!=null",
            "return": "standards[i].descr"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if myid is not equal to id and raise a bug if it is.",
        "pre": {
            "myid": "!= id"
        }
    },
    "kprobe:v4l2_norm_to_name": {
        "description": "Convert v4l2_std_id to its corresponding name.",
        "pre": {
            "id": "!= null"
        }
    },
    "kprobe:return": {
        "description": "Return the description corresponding to the given id.",
        "pre": {
            "standards[i].std": "== myid"
        }
    }
},
{
    "kretprobe:v4l2_m2m_schedule_next_job": {
        "description": "Description of the function",
        "pre": {
            "m2m_dev": "!=null",
            "m2m_ctx": "!=null"
        },
        "post": {
            "return_value": "Constraints on the return value"
        }
    }
},



{
    "kretprobe:vdev->minor = -1;/* the release callback MUST be present `": {
        "description": "Set the minor value of the video device to -1, indicating that it has never been registered.",
        "pre": {
            "vdev": "!=null",
            "vdev->minor": "-1"
        }
    }
},

{
    "kretprobe:video_unregister_device": {
        "description": "Unregister a video4linux device",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:video_unregister_device": {
        "description": "Unregister a video4linux device",
        "pre": {
            "vdev": "!=null"
        }
    }
},


{
    "kretprobe:v4l2_ctrl_type_op_equal": {
        "description": "Checks if two v4l2_ctrl objects are equal based on their type.",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null",
            "ctrl->type": "in [V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_STRING]",
            "ctrl->type == V4L2_CTRL_TYPE_BUTTON": "return false",
            "ctrl->type == V4L2_CTRL_TYPE_STRING": {
                "i": ">=0",
                "i < ctrl->elems": {
                    "idx": "= i * ctrl->elem_size",
                    "ptr1.p_char + idx": "!=null",
                    "ptr2.p_char + idx": "!=null",
                    "strcmp(ptr1.p_char + idx, ptr2.p_char + idx)": "return false"
                },
                "return true"
            },
            "default": "!memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size)"
        }
    }
},
{
    "kprobe:v4l2_ctrl_type_op_equal": {
        "description": "Checks if two v4l2_ctrl pointers are equal based on the control type.",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null",
            "ctrl->type": "in [V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_STRING]",
            "ctrl->type == V4L2_CTRL_TYPE_BUTTON": "return false",
            "ctrl->type == V4L2_CTRL_TYPE_STRING": {
                "i": ">=0",
                "i < ctrl->elems": {
                    "idx": "= i * ctrl->elem_size",
                    "ptr1.p_char + idx": "!=null",
                    "ptr2.p_char + idx": "!=null",
                    "strcmp(ptr1.p_char + idx, ptr2.p_char + idx)": "return false"
                },
                "return true"
            },
            "default": "!memcmp(ptr1.p_const, ptr2.p_const, ctrl->elems * ctrl->elem_size)"
        }
    }
},
{
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of entrie safely removing each entry from the list.",
        "pre": {
            "ref": "!=null",
            "next_ref": "!=null",
            "&hdl->ctrl_refs": "!=null",
            "node": "!=null"
        }
    }
},

{
    "kretprobe:if (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev))": {
        "description": "Add immediately at the end of the list if the list is empty, or if the last element in the list has a lower ID. This ensures that when elements are added in ascending order the insertion is an O(1) operation.",
        "pre": {
            "list_empty(&hdl->ctrl_refs)": true,
            "id": "> node2id(hdl->ctrl_refs.prev)"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the list is empty or if the ID is greater than the ID of the last element in the list.",
        "pre": {
            "list_empty(&hdl->ctrl_refs)": true,
            "id": "> node2id(hdl->ctrl_refs.prev)"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_get_menu": {
        "description": "Retrieve the menu items for a specific control identified by the id parameter.",
        "pre": {
            "id": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_get_menu": {
        "description": "Get the menu associated with the control identified by *id*.",
        "pre": {
            "id": "!=null",
            "v4l2_ctrl_get_menu(id)": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_add_handler": {
        "description": "Add a control handler to another control handler in the V4L2 framework.",
        "pre": {
            "hdl": "==null",
            "add": "==null",
            "hdl == add": "==true"
        }
    }
},
{
    "kprobe:v4l2_ctrl_add_handler": {
        "description": "Add a control handler to another control handler.",
        "pre": {
            "hdl": "==null",
            "add": "==null",
            "hdl == add": "==true"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_cluster": {
        "description": "v4l2_ctrl_cluster(unsigned ncontrol struct v4l2_ctrl controls) - bool has_volatiles = false; int i; The first control is the master control and it must not be NULL",
        "pre": {
            "ncontrols": ">0",
            "controls[0]": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_cluster": {
        "description": "v4l2_ctrl_cluster(unsigned ncontrol struct v4l2_ctrl controls)",
        "pre": {
            "ncontrols": "!=0",
            "controls[0]": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_activate": {
        "description": "Invert the 'active' flag to set the 'inactive' flag.",
        "pre": {
            "ctrl": "!=null",
            "active": "==false"
        }
    }
},
{
    "kprobe:v4l2_ctrl_activate": {
        "description": "Activate or deactivate the V4L2 control.",
        "pre": {
            "ctrl": "!=null",
            "active": "bool",
            "inactive": "!active"
        }
    }
},


{
    "kretprobe:v4l2_ctrl_handler_setup": {
        "description": "Setup the V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "hdl->lock": "held",
            "ctrls": "not empty",
            "ctrls[i].done": "false",
            "ctrls[i].cluster[0]": "not handled"
        }
    }
},
{
    "kprobe:v4l2_ctrl_handler_setup": {
        "description": "Setup the V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "hdl->lock": "held",
            "ctrls": "not empty",
            "ctrls[i].done": "false",
            "ctrls[i].cluster[0]": "not handled"
        }
    }
},
{
    "kretprobe:v4l2_g_ext_ctrls_common": {
        "description": "Get extended controls for a video device.",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "==V4L2_CTRL_WHICH_REQUEST_VAL",
            "p_req_valid": "==true"
        }
    }
},
{
    "kprobe:v4l2_g_ext_ctrls_common": {
        "description": "Get extended controls from a V4L2 control handler.",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "==V4L2_CTRL_WHICH_REQUEST_VAL",
            "p_req_valid": "==true"
        }
    }
},

{
    "kprobe:v4l2_ctrl_g_ctrl": {
        "description": "Get the value of the v4l2_ctrl structure.",
        "pre": {
            "ctrl": "!=null",
            "ctrl.is_int": "==true"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_g_ctrl_int64": {
        "description": "Get the value of a 64-bit integer control.",
        "pre": {
            "ctrl": "!=null",
            "ctrl->is_ptr": "==false",
            "ctrl->type": "==V4L2_CTRL_TYPE_INTEGER64"
        },
        "post": {
            "return": "==0",
            "c.value64": "==0"
        }
    }
},
{
    "kprobe:v4l2_ctrl_g_ctrl_int64": {
        "description": "Get the value of a 64-bit integer control.",
        "pre": {
            "ctrl": "!=null",
            "ctrl.is_ptr": "==false",
            "ctrl.type": "==V4L2_CTRL_TYPE_INTEGER64"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl": {
        "description": "Set the value of a V4L2 control.",
        "pre": {
            "ctrl": {
                "is_int": "true"
            },
            "val": "!=null"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl": {
        "description": "Set the value of a v4l2 control.",
        "pre": {
            "ctrl": {
                "is_int": "==true",
                "handler": {
                    "lock": "held"
                }
            },
            "WARN_ON(!ctrl->is_int)": "==false",
            "return": "-EINVAL",
            "ctrl->val": "=val",
            "set_ctrl": {
                "args": ["NULL", "ctrl", "0"]
            },
            "EXPORT_SYMBOL": "__v4l2_ctrl_s_ctrl"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "Set the value of the control to the specified 64-bit integer.",
        "pre": {
            "ctrl": {
                "is_ptr": false,
                "type": "V4L2_CTRL_TYPE_INTEGER64"
            },
            "val": "!=null"
        },
        "post": {
            "return": "-EINVAL",
            "ctrl->p_new.p_s64": "val"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "Sets the value of a V4L2 control to a 64-bit integer.",
        "pre": {
            "ctrl->is_ptr": "false",
            "ctrl->type": "V4L2_CTRL_TYPE_INTEGER64",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_string": {
        "description": "Sets the control value to a string.",
        "pre": {
            "ctrl": {
                "type": "== V4L2_CTRL_TYPE_STRING",
                "handler": {
                    "lock": "held"
                }
            },
            "s": "!= null"
        },
        "post": {
            "return": "== -EINVAL",
            "ctrl": {
                "p_new": {
                    "p_char": "strscpy( ctrl->p_new.p_char, ctrl->maximum + 1)"
                }
            },
            "set_ctrl": {
                "args": ["NULL", "ctrl", "0"]
            }
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_string": {
        "description": "__v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl ctrl, const char s)",
        "pre": {
            "ctrl": "!=null",
            "s": "!=null",
            "ctrl->type": "==V4L2_CTRL_TYPE_STRING",
            "return": "==0"
        },
        "post": {
            "ctrl->handler->lock": "held"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_compound": {
        "description": "Set the value of a compound control.",
        "pre": {
            "ctrl": "!=null",
            "type": "!=null",
            "p": "!=null",
            "ctrl->type": "==type"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_compound": {
        "description": "Set the value of a compound control.",
        "pre": {
            "ctrl": "!=null",
            "type": "!=null",
            "p": "!=null",
            "ctrl->type": "==type",
            "return": "== -EINVAL",
            "ctrl->handler->lock": "is held"
        }
    }
},
{
    "kretprobe:find_ref": {
        "description": "Find a reference in the control handler.",
        "pre": {
            "hdl": "!=null",
            "id": "!=null"
        }
    },
    "kretprobe:list_empty": {
        "description": "Check if the control references list is empty.",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:find_ref": {
        "description": "Find the reference for a control handler and query extended control.",
        "pre": {
            "hdl": "!=null",
            "qc": "!=null",
            "next_flags": "V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND",
            "id": "qc->id & V4L2_CTRL_ID_MASK",
            "ref": "!=null",
            "ctrl": "!=null",
            "hdl->lock": "locked"
        }
    }
},






{
    "kretprobe:v4l2_ctrl_request_complete": {
        "description": "v4l2_ctrl_request_complete() could not allocate a control handler object to store the completed state in. So return ENOMEM to indicate that there was an out-of-memory error.",
        "pre": {
            "set": "==null",
            "new_hdl": "!=null",
            "ret": "==ENOMEM"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the condition is true",
        "pre": {
            "set": "==null"
        }
    },
    "kprobe:ERR_PTR": {
        "description": "Return an error pointer",
        "pre": {
            "set": "==null"
        }
    },
    "kprobe:kzalloc": {
        "description": "Allocate memory for new_hdl",
        "pre": {
            "new_hdl": "==null"
        }
    },
    "kprobe:v4l2_ctrl_handler_init": {
        "description": "Initialize v4l2 control handler",
        "pre": {
            "ret": "==null"
        }
    },
    "kprobe:v4l2_ctrl_request_bind": {
        "description": "Bind v4l2 control request",
        "pre": {
            "ret": "==null"
        }
    }
},
{
    "kretprobe:media_request_object_find": {
        "description": "Find the media request object for the given request and main handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        },
        "post": {
            "obj": "!=null",
            "obj->completed": "==false"
        }
    }
},
{
    "kprobe:media_request_object_find": {
        "description": "Find the media request object for the given request and control handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        }
    },
    "kprobe:v4l2_ctrl_request_setup": {
        "description": "Setup the V4L2 control request with the given media request and control handler.",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        }
    },
    "kprobe:obj->completed": {
        "description": "Check if the 'completed' flag of the media request object is set.",
        "pre": {
            "obj": "!=null",
            "obj->completed": "==false"
        }
    }
},
{
    "kretprobe:s5h1409_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1409_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:zl10036_read_status_reg": {
        "description": "Read the status register of the zl10036 device.",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "ret": "< 0"
        }
    }
},
{
    "kprobe:zl10036_read_status_reg": {
        "description": "Read the status register of the zl10036 device.",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "fe->ops.i2c_gate_ctrl": "exists => fe->ops.i2c_gate_ctrl(1)"
        }
    }
},


{
    "kretprobe:cx24123_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24123_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:lg2160_attach": {
        "description": "Attach function for lg2160",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->fic_ver": "0xff",
            "state->parade_id": "0xff",
            "config->lg_chip": "in [LG2160, LG2161]",
            "state->frontend.demodulator_priv": "state",
            "state->current_frequency": "-1",
            "state->frontend.dtv_property_cache.atscmh_parade_id": "1"
        }
    }
},
{
    "kprobe:state->frontend.dtv_property_cache.atscmh_parade_id = 1;return &state->frontend;}EXPORT_SYMBOL(lg2160_attach": {
        "description": "Attach the LG2160 frontend to the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->fic_ver": "0xff",
            "state->parade_id": "0xff",
            "config->lg_chip": "in [LG2160, LG2161]",
            "state->frontend.demodulator_priv": "state",
            "state->current_frequency": "-1",
            "state->frontend.dtv_property_cache.atscmh_parade_id": "1"
        }
    }
},
{
    "kretprobe:state = kzalloc(sizeof(*state), GFP_KERNEL);if (!state)return NULL;/* setup the state `": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:state = kzalloc(sizeof(*state), GFP_KERNEL);if (!state)return NULL;/* setup the state `": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "state": "!=null",
            "sizeof(*state)": "!=0",
            "GFP_KERNEL": "in [GFP_KERNEL, GFP_ATOMIC, GFP_NOWAIT]"
        }
    }
},
{
    "kretprobe:cx22702_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "sizeof(struct cx22702_state)": "!=null",
            "GFP_KERNEL": "!=null"
        }
    },
    "kprobe:if (state == NULL)goto error": {
        "description": "Check if the allocated memory is NULL",
        "pre": {
            "state": "==null"
        }
    },
    "kprobe:/* setup the state `": {
        "description": "Setup the state",
        "pre": {}
    }
},
{
    "kretprobe:tda10023_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10023_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        }
    }
},
{
    "kretprobe:nxt6000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:nxt6000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:s5h1411_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1411_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:mt312_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:mt312_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},

{
    "kprobe:lgs8gxx_read_reg": {
        "description": "Read a register from the lgs8gxx device.",
        "pre": {
            "priv": "!=null",
            "data": "any"
        }
    }
},
{
    "kretprobe:dprintk": {
        "description": "Prints a debug message.",
        "pre": {
            "state": "!=null",
            "state->pid_ctrl_index": "==state->pid_ctrl_index+1",
            "state->pid_ctrl[state->pid_ctrl_index].cmd": "==DIB9000_PID_FILTER_CTRL",
            "state->pid_ctrl[state->pid_ctrl_index].onoff": "==onoff",
            "mutex_lock_interruptible(&state->demod_lock)": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:dib9000_fw_pid_filter_ctrl": {
        "description": "Postpone the pid filtering cmd.",
        "pre": {
            "fe": "!=null",
            "onoff": "!=null",
            "state": "!=null",
            "state->demodulator_priv": "!=null",
            "state->pid_ctrl_index": "!=null",
            "state->pid_ctrl_index": "< 9"
        }
    }
},
{
    "kretprobe:dib9000_i2c_enumeration": {
        "description": "Enumeration function for dib9000_i2c",
        "pre": {
            "new_addr": "first_addr + (k << 1)",
            "client.i2c_addr": "default_addr",
            "dib9000_i2c_write16(&client, 1817, 3)": "true",
            "dib9000_i2c_write16(&client, 1796, 0)": "true",
            "dib9000_i2c_write16(&client, 1227, 1)": "true",
            "dib9000_i2c_write16(&client, 1227, 0)": "true",
            "client.i2c_addr": "new_addr",
            "dib9000_i2c_write16(&client, 1817, 3)": "true",
            "dib9000_i2c_write16(&client, 1796, 0)": "true",
            "dib9000_i2c_write16(&client, 1227, 1)": "true",
            "dib9000_i2c_write16(&client, 1227, 0)": "true",
            "if (dib9000_identify(&client) == 0)": "true"
        }
    }
},
{
    "kprobe:dib9000_i2c_enumeration": {
        "description": "Enumeration function for dib9000 i2c devices.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "first_addr": "!=null"
        }
    }
},
{
    "kretprobe:dib9000_attach": {
        "description": "Attach the dib9000 device to the i2c adapter with the given configuration.",
        "pre": {
            "i2c_adap": "!=null",
            "i2c_addr": "!=null",
            "cfg": "!=null",
            "st": "!=null",
            "fe": "!=null",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_SERIAL",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_PAR_GATED_CLK",
            "st->chip.d9.cfg.output_mode": "=OUTMODE_MPEG2_FIFO",
            "dib9000_identify(&st->i2c)": "=0",
            "st->i2c.i2c_adap": "=i2c_adap",
            "st->i2c.i2c_addr": "=i2c_addr",
            "st->i2c.i2c_write_buffer": "=st->i2c_write_buffer",
            "st->i2c.i2c_read_buffer": "=st->i2c_read_buffer",
            "st->gpio_dir": "=DIB9000_GPIO_DEFAULT_DIRECTIONS",
            "st->gpio_val": "=DIB9000_GPIO_DEFAULT_VALUES",
            "st->gpio_pwm_pos": "=DIB9000_GPIO_DEFAULT_PWM_POS",
            "st->platform.risc.mbx_if_lock": "!=null",
            "st->platform.risc.mbx_lock": "!=null",
            "st->platform.risc.mem_lock": "!=null",
            "st->platform.risc.mem_mbx_lock": "!=null",
            "st->demod_lock": "!=null",
            "st->get_frontend_internal": "=0",
            "st->pid_ctrl_index": "=-2",
            "st->fe[0]": "=fe",
            "fe->demodulator_priv": "=st",
            "st->fe[0]->ops": "=dib9000_ops"
        },
        "post": {
            "return": "=fe"
        }
    }
},
{
    "kprobe:dib9000_attach": {
        "description": "Attaches a DIB9000 device to an I2C adapter.",
        "pre": {
            "i2c_adap": "!=null",
            "i2c_addr": "!=null",
            "cfg": "!=null",
            "st": "!=null",
            "fe": "!=null",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_SERIAL",
            "st->chip.d9.cfg.output_mode": "!=OUTMODE_MPEG2_PAR_GATED_CLK",
            "st->chip.d9.cfg.output_mode": "=OUTMODE_MPEG2_FIFO",
            "dib9000_identify(&st->i2c)": "==0",
            "st->tuner_adap.dev.parent": "=i2c_adap->dev.parent",
            "st->tuner_adap.name": "=DIB9000_FW TUNER ACCESS",
            "st->tuner_adap.algo": "=&dib9000_tuner_algo",
            "st->tuner_adap.algo_data": "=NULL",
            "i2c_set_adapdata(&st->tuner_adap, st)": "!=NULL",
            "i2c_add_adapter(&st->tuner_adap)": "<0",
            "st->component_bus.dev.parent": "=i2c_adap->dev.parent",
            "st->component_bus.name": "=DIB9000_FW COMPONENT BUS ACCESS",
            "st->component_bus.algo": "=&dib9000_component_bus_algo",
            "st->component_bus.algo_data": "=NULL",
            "st->component_bus_speed": "=340",
            "i2c_set_adapdata(&st->component_bu st)": "!=NULL",
            "i2c_add_adapter(&st->component_bus)": "<0",
            "dib9000_fw_reset(fe)": "",
            "return": "fe",
            "component_bus_add_error": "i2c_del_adapter(&st->tuner_adap)",
            "error": "kfree(st)",
            "return": "NULL"
        }
    }
},


{
    "kretprobe:dibx000_i2c_gate_ctrl": {
        "description": "Initialize the i2c-master by closing the gate",
        "pre": {
            "mst": "!=null",
            "mst->i2c_write_buffer": "!=null",
            "device_rev": "is u16",
            "i2c_adap": "!=null",
            "i2c_addr": "is u8"
        },
        "post": {
            "ret": "==1",
            "mutex_unlock(&mst->i2c_buffer_lock)": "called"
        }
    }
},
{
    "kprobe:dibx000_i2c_gate_ctrl": {
        "description": "Initialize the i2c-master by closing the gate.",
        "pre": {
            "mst": "!=null",
            "mst->i2c_write_buffer": "!=null",
            "device_rev": "is u16",
            "i2c_adap": "!=null",
            "i2c_addr": "is u8"
        }
    }
},
{
    "kretprobe:l64781_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:l64781_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "ter_state": "==null"
        }
    }
},
{
    "kprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "cab_state": "==null"
        }
    }
},
{
    "kprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ddb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null",
            "ter_state": "==null",
            "cab_state": "==null"
        }
    }
},
{
    "kprobe:stv0367ddb_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb6000_attach": {
        "description": "Attach STB6000 tuner to DVB frontend",
        "pre": {
            "ret": "==2",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "priv": "!=null"
        },
        "post": {
            "fe": "!=null"
        }
    }
},
{
    "kprobe:stb6000_attach": {
        "description": "Attach STB6000 frontend to DVB frontend",
        "pre": {
            "fe": {
                "ops": {
                    "i2c_gate_ctrl": "!=null"
                }
            },
            "ret": "==2",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:cx24113_agc_callback": {
        "description": "This function is the kretprobe for cx24113_agc_callback.",
        "pre": {
            "fe": "!=null",
            "fe->ops.read_signal_strength": "!=null",
            "fe->tuner_priv": "!=null",
            "s": "!=null",
            "i": "!=null",
            "cx24113_agc_table[state->gain_level][i]": "> s",
            "s": "<= -25",
            "i": "<= (sizeof(cx24113_agc_table[0]) - 1) / 5"
        }
    }
},
{
    "kprobe:fe->ops.read_signal_strength": {
        "description": "Reads the signal strength from the frontend.",
        "pre": {
            "fe": "!=null",
            "fe->ops.read_signal_strength": "!=null"
        }
    },
    "kprobe:dprintk": {
        "description": "Prints the signal strength.",
        "pre": {
            "format": "is a string",
            "arguments": [
                {
                    "type": "int",
                    "value": "signal strength: %d"
                },
                {
                    "type": "int",
                    "value": "s"
                }
            ]
        }
    },
    "kprobe:cx24113_agc_table": {
        "description": "Accesses the AGC table.",
        "pre": {
            "state": "!=null",
            "state->gain_level": "!=null",
            "i": "!=null",
            "cx24113_agc_table[state->gain_level][i]": "!=null",
            "s": "!=null"
        }
    },
    "kprobe:cx24113_set_gain_settings": {
        "description": "Sets the gain settings.",
        "pre": {
            "state": "!=null",
            "s": "!=null"
        }
    },
    "kprobe:EXPORT_SYMBOL(cx24113_agc_callback)": {
        "description": "Exports the cx24113_agc_callback symbol."
    }
},
{
    "kretprobe:cx24113_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24113_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "state": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "state": "==null"
        }
    },
    "state.config": {
        "description": "Set the configuration value",
        "pre": {
            "state.config": "!=null"
        }
    },
    "state.i2c": {
        "description": "Set the i2c value",
        "pre": {
            "state.i2c": "!=null"
        }
    },
    "state.prevUCBS2": {
        "description": "Set the prevUCBS2 value",
        "pre": {
            "state.prevUCBS2": "==0"
        }
    },
    "ds3000_attach": {
        "description": "Check if the demod is present",
        "pre": {
            "ds3000_attach": "!=null"
        }
    }
},
{
    "ds3000_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:cx24116_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:cx24116_attach": {
        "description": "Allocate memory for the internal state and check if the demod is present.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:isl6405_attach": {
        "description": "Attach the isl6405 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": "& 0x80 != 0",
            "override_clear": "& 0x80 == 0"
        }
    }
},
{
    "kprobe:isl6405_attach": {
        "description": "Attach the isl6405 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": "& 0x80 != 0",
            "override_clear": "& 0x80 == 0"
        }
    }
},
{
    "kretprobe:tda10048_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10048_attach": {
        "description": "Attach the tda10048 device with the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:cx24110_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:cx24110_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv6110_attach": {
        "description": "Attach STV6110 tuner to DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "reg0": "array of size 9",
            "msg": "array of size 1",
            "ret": "int",
            "priv": "null",
            "priv.i2c_address": "config->i2c_address",
            "priv.i2c": "i2c",
            "priv.mclk": "config->mclk",
            "priv.clk_div": "config->clk_div",
            "priv.gain": "config->gain",
            "priv.regs": "array of size 8",
            "fe.ops.tuner_ops": "struct dvb_tuner_ops",
            "fe.tuner_priv": "priv"
        },
        "post": {
            "return": "fe"
        }
    }
},
{
    "kprobe:stv6110_attach": {
        "description": "Attach STV6110 tuner to DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "config->i2c_address": "!=null",
            "reg0": "!=null",
            "msg": "!=null",
            "ret": "!=null",
            "priv": "==null"
        }
    }
},
{
    "kretprobe:bcm3510_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:bcm3510_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:s5h1432_attach": {
        "description": "Attach the s5h1432 device to the i2c adapter and allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:s5h1432_attach": {
        "description": "Attach the s5h1432 device to the i2c adapter and allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:new_addr": {
        "description": "Assigns a new address to the 'dmcst->i2c_addr' variable and identifies the dib3000mc device.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": "int",
            "default_addr": "int",
            "cfg": "!=null",
            "k": "int",
            "new_addr": "int",
            "DIB3000MC_I2C_ADDRESS": "array",
            "dmcst": "!=null",
            "dmcst->i2c_adap": "i2c_adapter",
            "dmcst->cfg": "!=null",
            "dmcst->i2c_addr": "int"
        },
        "post": {
            "return_value": "int",
            "dmcst->i2c_addr": "new_addr",
            "dib3000mc_identify(dmcst)": "0"
        }
    }
},
{
    "kprobe:new_addr = DIB3000MC_I2C_ADDRESS[k]; dmcst->i2c_addr = new_addr; if (dib3000mc_identify(dmcst) != 0)": {
        "description": "This function sets the new address for the DIB3000MC device and identifies it.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "cfg": "!=null",
            "k": ">=0",
            "new_addr": "in DIB3000MC_I2C_ADDRESS",
            "dmcst": "!=null",
            "dmcst->i2c_adap": "==i2c",
            "k >= 0": "true"
        }
    }
},



{
    "kprobe:u8_ltg2": {
        "description": "Check if ltg2 is non-zero when current_band is BAND_CBAND.",
        "pre": {
            "state->current_band": "==BAND_CBAND",
            "ltg2": "!=0"
        }
    }
},
{
    "kretprobe:or51211_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:or51211_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:zl10039_attach": {
        "description": "Attach the zl10039 tuner to the dvb_frontend.",
        "pre": {
            "fe": "!=null",
            "i2c_addr": "!=null",
            "i2c": "!=null",
            "state": "==null"
        }
    }
},
{
    "kprobe:if (fe->ops.i2c_gate_ctrl)fe->ops.i2c_gate_ctrl(fe, 1);/* check if this is a valid tuner `": {
        "description": "Open i2c gate",
        "pre": {
            "fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "i2c_addr": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:usleep_range": {
        "description": "IQ Generator disable",
        "pre": {
            "min_usec": "==4000",
            "max_usec": "==6000"
        }
    }
},
{
    "kprobe:usleep_range": {
        "description": "IQ Generator disable",
        "pre": {
            "min_usec": "==4000",
            "max_usec": "==6000"
        }
    }
},
{
    "kretprobe:stv090x_attach": {
        "description": "Attach function for stv090x",
        "pre": {
            "state->demod_mode": "= config->demod_mode",
            "state->device": "= config->device"
        }
    }
},
{
    "kprobe:stv090x_attach": {
        "description": "Attach the STV090x demodulator with the given configuration.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "demod": "in [STV090X_DEMOD_SINGLE, STV090X_DEMOD_DUAL]",
            "state": "!=null",
            "state->verbose": "!=null",
            "state->config": "!=null",
            "state->i2c": "!=null",
            "state->frontend.ops": "!=null",
            "state->frontend.demodulator_priv": "!=null",
            "state->demod": "in [STV090X_DEMOD_SINGLE, STV090X_DEMOD_DUAL]",
            "state->demod_mode": "= config->demod_mode",
            "state->device": "= config->device"
        }
    }
},
{
    "kretprobe:ves1x93_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ves1x93_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb0899_attach": {
        "description": "Attach the stb0899 configuration and i2c adapter to the stb0899 state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "state->verbose": "!=null",
            "state->config": "= config",
            "state->i2c": "= i2c",
            "state->frontend.ops": "= stb0899_ops",
            "state->frontend.demodulator_priv": "= state",
            "state->internal.inversion": "= config->inversion",
            "stb0899_get_dev_id(state)": "== -ENODEV"
        }
    }
},
{
    "kprobe:stb0899_attach": {
        "description": "Attach the stb0899 configuration and i2c adapter to the stb0899 state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:lgdt3306a_attach": {
        "description": "Attach the lgdt3306a driver to the i2c adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "state->cfg": "==config",
            "state->i2c_adap": "==i2c_adap",
            "state->frontend.ops": "==lgdt3306a_ops",
            "state->frontend.demodulator_priv": "==state"
        }
    }
},
{
    "kprobe:lgdt3306a_attach": {
        "description": "Attach the lgdt3306a driver to the specified configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        }
    }
},
{
    "kretprobe:dvb_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc(sizeof(struct dvb_dummy_fe_state), GFP_KERNEL);if (!state)return NULL;/* create dvb_frontend": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:ec100_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "sizeof(struct ec100_state)": "!=null",
            "GFP_KERNEL": "!=null"
        }
    },
    "kprobe:if (state == NULL)goto error": {
        "description": "Check if the allocated memory is NULL",
        "pre": {
            "state": "==null"
        }
    },
    "kprobe:/* setup the state `": {
        "description": "Setup the state",
        "pre": {}
    }
},


{
    "kretprobe:lgs8gl5_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:lgs8gl5_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:new_addr": {
        "description": "The new address is calculated as (0x40 + k) << 1. The i2c address is set to the new address. If dib7000m_identify(&st) returns a non-zero value, the condition is not satisfied.",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "!=null",
            "cfg": "!=null",
            "k": ">=0",
            "new_addr": ">=0",
            "dib7000m_identify(&st)": "==0"
        }
    }
},
{
    "kprobe:new_addr": {
        "description": "Assign a new address to the variable new_addr.",
        "pre": {
            "k": ">= 0",
            "no_of_demods": ">= 0",
            "i2c": "!= null",
            "default_addr": "!= null",
            "cfg": "!= null"
        }
    },
    "kprobe:st.i2c_addr": {
        "description": "Assign the value of new_addr to st.i2c_addr.",
        "pre": {
            "new_addr": "!= null",
            "st": "!= null"
        }
    },
    "kprobe:dib7000m_identify": {
        "description": "Check if dib7000m_identify(&st) returns 0.",
        "pre": {
            "st": "!= null"
        }
    }
},


{
    "kretprobe:si21xx_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:si21xx_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:nxt200x_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:nxt200x_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:ascot2e_attach": {
        "description": "Attach the ascot2e driver to the dvb_frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "data": "!=null",
            "priv": "!=null",
            "priv": "kzalloc(sizeof(struct ascot2e_priv), GFP_KERNEL)",
            "priv->i2c_address": "(config->i2c_address >> 1)",
            "priv->i2c": "i2c",
            "priv->set_tuner_data": "config->set_tuner_priv",
            "priv->set_tuner": "config->set_tuner_callback",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "fe->ops.i2c_gate_ctrl(fe, 1)": "null",
            "data[0]": "16"
        }
    }
},
{
    "kprobe:ascot2e_attach": {
        "description": "Attach the ascot2e driver to the DVB frontend.",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:state->uio_mask = config->antenna_gpio;/* Default gpio to DVB-C `": {
        "description": "Set the default gpio to DVB-C",
        "pre": {
            "state": "!=null",
            "config": "!=null",
            "config->antenna_gpio": "!=null"
        }
    }
},
{
    "kprobe:state->uio_mask = config->antenna_gpio;/* Default gpio to DVB-C `": {
        "description": "Set the value of state's uio_mask to config's antenna_gpio.",
        "pre": {
            "state": "!=null",
            "config->antenna_gpio": "!=null"
        }
    }
},
{
    "kretprobe:dib0070_wbd_offset": {
        "description": "Calculate and return the WBD offset value based on the current gain.",
        "pre": {
            "state": "!=null",
            "tmp": "!=null",
            "state->wbd_gain_current": ">= 6",
            "state->wbd_offset_3_3[state->wbd_gain_current - 6]": "!=null"
        }
    }
},
{
    "kprobe:dib0070_wbd_offset": {
        "description": "Calculate and return the WBD offset for the given state.",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:tda10086_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:tda10086_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:CDRXD": {
        "description": "Attach a DRXD device with the given configuration, private data, I2C adapter, and device.",
        "pre": {
            "config": "!=null",
            "priv": "!=null",
            "i2c": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:CDRXD": {
        "description": "Attach the drxd device with the given configuration, private data, I2C adapter, and device.",
        "pre": {
            "config": "!=null",
            "priv": "!=null",
            "i2c": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:lgdt3305_attach": {
        "description": "Attach LGDT3305 hardware",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
            "state": "!=null",
            "ret": "int",
            "val": "u8",
            "config->i2c_addr": "int",
            "state->cfg": "config",
            "state->i2c_adap": "i2c_adap",
            "state->frontend.ops": "memcpy(&lgdt3305_op sizeof(struct dvb_frontend_ops))",
            "state->frontend.demodulator_priv": "state"
        },
        "post": {
            "ret": "!=null",
            "state->current_frequency": "-1",
            "state->current_modulation": "-1",
            "return": "&state->frontend"
        },
        "fail": {
            "lg_warn": "unable to detect %s hardware\n",
            "config->demod_chip": "LGDT3304 or LGDT3305",
            "state": "kfree(state)",
            "return": "NULL"
        }
    }
},
{
    "kprobe:lgdt3305_attach": {
        "description": "Attach the LGDT3305 demodulator to the given configuration and I2C adapter.",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        }
    },
    "kprobe:lgdt3305_read_reg": {
        "description": "Read the value of the register at the given address using the LGDT3305 demodulator state.",
        "pre": {
            "state": "!=null",
            "reg_addr": "!=null",
            "value": "!=null"
        }
    },
    "kprobe:lgdt3305_write_reg": {
        "description": "Write the given value to the register at the given address using the LGDT3305 demodulator state.",
        "pre": {
            "state": "!=null",
            "reg_addr": "!=null",
            "value": "!=null"
        }
    }
},

{
    "kprobe:atbm8830_read_reg": {
        "description": "Read the value of the register with ID REG_CHIP_ID.",
        "pre": {
            "priv": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ves1820_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:state = kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:tda10021_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda10021_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "!=null"
        }
    }
},
{
    "kretprobe:isl6421_attach": {
        "description": "Attach the isl6421 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": ">=0",
            "override_clear": ">=0",
            "override_tone": "is boolean",
            "isl6421": "!=null",
            "isl6421->config": "==ISL6421_ISEL1",
            "isl6421->i2c": "==i2c",
            "isl6421->i2c_addr": "==i2c_addr",
            "fe->sec_priv": "==isl6421"
        }
    }
},
{
    "kprobe:isl6421_attach": {
        "description": "Attach the isl6421 helper to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "!=null",
            "override_set": ">=0",
            "override_clear": ">=0",
            "override_tone": "is boolean",
            "isl6421": "!=null"
        }
    }
},
{
    "kretprobe:s921_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:struct_s921_state_kzalloc": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kretprobe:ts2020_attach": {
        "description": "This is only used by ts2020_probe() so can be on the stack",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "config.fe": "!=null",
            "config.attach_in_use": "true",
            "board_info": "!=null",
            "board_info.type": "==\"ts2020\"",
            "board_info.addr": "==config.tuner_address",
            "board_info.platform_data": "==&pdata",
            "client": "!=null",
            "i2c_client_has_driver(client)": "==false"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ts2020_attach": {
        "description": "This is only used by ts2020_probe() so can be on the stack",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:dib3000mb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:dib3000mb_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        }
    }
},
{
    "kretprobe:isl6423->reg_3 = 0x02 << 5": {
        "description": "Set the value of isl6423->reg_3 to 0x02 shifted left by 5 bits.",
        "pre": {
            "isl6423": "!=null",
            "fe": "!=null",
            "i2c": "!=null",
            "config": "!=null",
            "SR3H": "0",
            "SR3M": "1",
            "SR3L": "0"
        }
    }
},
{
    "kprobe:isl6423->reg_3 = 0x02 << 5;/* SR4H = 0, SR4M = 1, SR4L = 1 */": {
        "description": "Set the value of isl6423->reg_3 to 0x02 shifted left by 5 bits.",
        "pre": {
            "isl6423": "!=null",
            "reg_3": "==0x02 << 5",
            "SR4H": "==0",
            "SR4M": "==1",
            "SR4L": "==1"
        }
    }
},
{
    "kretprobe:cx22700_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:cx22700_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:mt352_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:mt352_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:au8522_i2c_gate_ctrl": {
        "description": "Manage the gate control for the au8522 demodulator.",
        "pre": {
            "fe": "!=null",
            "enable": "any",
            "state": "!=null"
        }
    }
},

{
    "kretprobe:au8522_led_ctrl": {
        "description": "Control an LED in the au8522_state structure.",
        "pre": {
            "state": "!=null",
            "led": ">= 0",
            "led_config": "!=null",
            "led_config->gpio_leds": "!=null",
            "led_config->num_led_states": "!=null",
            "led_config->led_states": "!=null"
        }
    }
},
{
    "kprobe:au8522_led_ctrl": {
        "description": "Control an LED in the au8522_state structure.",
        "pre": {
            "state": "!=null",
            "led": ">=0",
            "led_config": "!=null",
            "led_config->gpio_leds": "!=null",
            "led_config->num_led_states": "!=null",
            "led_config->led_states": "!=null"
        }
    }
},



{
    "kprobe:au8522_sleep": {
        "description": "Power down the AU8522 chip if the digital side is currently using it.",
        "pre": {
            "state->operational_mode": "== AU8522_ANALOG_MODE"
        }
    }
},
{
    "kretprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:tda8083_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:tda8083_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stb6100_attach": {
        "description": "Attach STB6100 tuner to dvb_frontend",
        "pre": {
            "fe": "!=null",
            "state": "!=null",
            "stb6100_ops": "!=null",
            "fe->tuner_priv": "==state",
            "fe->ops.tuner_ops": "==stb6100_ops"
        }
    }
},
{
    "kprobe:stb6100_attach": {
        "description": "Attach STB6100 tuner",
        "pre": {
            "fe": "!=null",
            "config": "unknown",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "==null"
        }
    }
},
{
    "kprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:struct s5h1420_state *state = kzalloc(sizeof(struct s5h1420_state), GFP_KERNEL);": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kprobe:s5h1420_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:drx39xxj_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "demod": "!=null",
            "demod_addr": "!=null",
            "demod_comm_attr": "!=null",
            "demod_ext_attr": "!=null"
        }
    }
},
{
    "kprobe:drx39xxj_attach": {
        "description": "Allocate memory for the internal state.",
        "pre": {
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "demod_addr": "!=null",
            "demod_comm_attr": "!=null",
            "demod_ext_attr": "!=null",
            "demod": "!=null",
            "p": "!=null",
            "result": "int"
        }
    }
},
{
    "kretprobe:fimc_find_remote_sensor": {
        "description": "Find the remote sensor for a given media entity.",
        "pre": {
            "pad": "!=null",
            "is_media_entity_v4l2_subdev(pad->entity)": "true",
            "sd->grp_id": "in [GRP_ID_FIMC_IS_SENSOR, GRP_ID_SENSOR]"
        }
    }
},
{
    "pad": "!=null"
},
{
    "kretprobe:mtk_v4l2_err": {
        "description": "mtk_v4l2_err function",
        "pre": {
            "ctx": "!=null",
            "command": "!=null",
            "timeout_ms": ">=0",
            "hw_id": ">=0"
        }
    }
},

{
    "kretprobe:vdoa_device_run": {
        "description": "Progressive, no sync, 1 frame per run",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "dst_q_data->pixelformat": "== V4L2_PIX_FMT_YUYV",
            "val": "== VDOAC_PFS",
            "writel(val, vdoa->regs + VDOAC)": "success",
            "writel(dst_q_data->height << 16 | dst_q_data->width, vdoa->regs + VDOAFP)": "success",
            "val": "== dst",
            "writel(val, vdoa->regs + VDOAIEBA00)": "success",
            "writel(src_q_data->bytesperline << 16 | dst_q_data->bytesperline, vdoa->regs + VDOASL)": "success",
            "dst_q_data->pixelformat": "== V4L2_PIX_FMT_NV12 || dst_q_data->pixelformat == V4L2_PIX_FMT_NV21",
            "val": "== dst_q_data->bytesperline * dst_q_data->height",
            "writel(val, vdoa->regs + VDOAIUBO)": "success",
            "val": "== src",
            "writel(val, vdoa->regs + VDOAVEBA0)": "success",
            "val": "== round_up(src_q_data->bytesperline * src_q_data->height, 4096)",
            "writel(val, vdoa->regs + VDOAVUBO)": "success"
        }
    }
},

{
    "kretprobe:vdoa_context_configure": {
        "description": "Configure the VDOA context",
        "pre": {
            "ctx": "!=null",
            "width": ">=16 && <=8192 && %16==0",
            "height": ">=16 && <=4096 && %16==0",
            "pixelformat": "==V4L2_PIX_FMT_YUYV || ==V4L2_PIX_FMT_NV12"
        }
    }
},
{
    "kprobe:vdoa_context_configure": {
        "description": "Configure the VDOA context with the given parameters.",
        "pre": {
            "ctx": "!=null",
            "width": ">=16 && <=8192 && %16==0",
            "height": ">=16 && <=4096 && %16==0",
            "pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12]"
        }
    }
},
{
    "kretprobe:DUMPREG": {
        "description": "Dump registers specific to VPE or VIP based on who is using it.",
        "pre": {
            "vpdma": "!=null",
            "dev": "valid device",
            "PID": "!=null",
            "LIST_ADDR": "!=null",
            "LIST_ATTR": "!=null",
            "LIST_STAT_SYNC": "!=null",
            "BG_RGB": "!=null",
            "BG_YUV": "!=null",
            "SETUP": "!=null",
            "MAX_SIZE1": "!=null",
            "MAX_SIZE2": "!=null",
            "MAX_SIZE3": "!=null",
            "group": "in [0, 3]"
        }
    }
},
{
    "kprobe:DUMPREG(INT_CHAN_STAT(0))": {
        "description": "Dump register INT_CHAN_STAT(0)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_MASK(0))": {
        "description": "Dump register INT_CHAN_MASK(0)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_STAT(3))": {
        "description": "Dump register INT_CHAN_STAT(3)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CHAN_MASK(3))": {
        "description": "Dump register INT_CHAN_MASK(3)",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT0_STAT)": {
        "description": "Dump register INT_CLIENT0_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT0_MASK)": {
        "description": "Dump register INT_CLIENT0_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT1_STAT)": {
        "description": "Dump register INT_CLIENT1_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_CLIENT1_MASK)": {
        "description": "Dump register INT_CLIENT1_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_LIST0_STAT)": {
        "description": "Dump register INT_LIST0_STAT",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    },
    "kprobe:DUMPREG(INT_LIST0_MASK)": {
        "description": "Dump register INT_LIST0_MASK",
        "pre": {
            "vpdma": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list for VPDMA.",
        "pre": {
            "list": "!=null",
            "size": ">=0",
            "type": "in [VPDMA_LIST_TYPE_NORMAL]"
        }
    }
},
{
    "kprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list for VPDMA.",
        "pre": {
            "list": "!=null",
            "size": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:vpdma_update_dma_addr": {
        "description": "Update DMA address in vpdma_data structure",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "in [0, 1]",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:vpdma_update_dma_addr": {
        "description": "Update DMA address in vpdma_data structure",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "in [0, 1]",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:sc_set_hs_coeffs": {
        "description": "Set the high-speed coefficients for the given sc_data structure.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "!=null",
            "dst_w": "!=null",
            "sixteenths": "int",
            "idx": "int",
            "i": "int",
            "j": "int",
            "coeff_h": "u16",
            "cp": "const u16",
            "dst_w_condition": "dst_w > src_w",
            "dst_w_condition2": "(dst_w << 1) < src_w"
        },
        "post": {
            "dst_w_update": "if dst_w_condition2 then dst_w <<= 1"
        }
    }
},
{
    "kprobe:sc_set_hs_coeffs": {
        "description": "Set the high-speed coefficients for the given sc_data structure.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "!=null",
            "dst_w": "!=null",
            "sixteenths": "int",
            "idx": "int",
            "i": "int",
            "j": "int",
            "coeff_h": "u16",
            "cp": "const u16",
            "dst_w > src_w": "bool",
            "(dst_w << 1) < src_w": "bool"
        }
    }
},
{
    "kretprobe:sc_set_vs_coeffs": {
        "description": "Function to update coefficients for the vertical scaler",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "!=null",
            "dst_h": "!=null",
            "coeff_v": "!=null",
            "cp": "!=null",
            "idx": "in [VS_UP_SCALE, VS_1_TO_1_SCALE, VS_LT_9_16_SCALE + sixteenths - 8]",
            "sixteenths": ">= 8",
            "i": ">= 0",
            "j": ">= 0"
        }
    }
},
{
    "kprobe:sc_set_vs_coeffs": {
        "description": "Set vertical scaler coefficients.",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "!=null",
            "dst_h": "!=null"
        }
    }
},
{
    "kretprobe:sc_config_scaler": {
        "description": "Configure the scaler",
        "pre": {
            "sc": "!=null",
            "sc_reg0": "!=null",
            "sc_reg8": "!=null",
            "sc_reg17": "!=null",
            "src_w": ">=0",
            "src_h": ">=0",
            "dst_w": ">=0",
            "dst_h": ">=0"
        }
    }
},
{
    "kprobe:sc_config_scaler": {
        "description": "Configure the scaler",
        "pre": {
            "sc": "!=null",
            "sc_reg0": "!=null",
            "sc_reg8": "!=null",
            "sc_reg17": "!=null",
            "src_w": "!=null",
            "src_h": "!=null",
            "dst_w": "!=null",
            "dst_h": "!=null"
        }
    }
},





{
    "kprobe:return;}if (s->type == CX18_ENC_STREAM_TYPE_VBI &&test_bit(CX18_F_S_INTERNAL_USE, &s->s_flags))": {
        "description": "Release the cx18 stream.",
        "pre": {
            "s": "!=null",
            "s->type": "== CX18_ENC_STREAM_TYPE_VBI",
            "test_bit(CX18_F_S_INTERNAL_USE, &s->s_flags)": "== true"
        }
    }
},

{
    "kprobe:captype = CAPTURE_CHANNEL_TYPE_VBI;#endifcx->vbi.frame = 0;cx->vbi.inserted_frame = 0;memset(cx->vbi.sliced_mpeg_size,0, sizeof(cx->vbi.sliced_mpeg_size));break;default:return -EINVAL;": {
        "description": "Set capture type to VBI and initialize related variables.",
        "pre": {
            "cx": "!=null",
            "cx->vbi.frame": "==0",
            "cx->vbi.inserted_frame": "==0",
            "cx->vbi.sliced_mpeg_size": "array of zeros with size sizeof(cx->vbi.sliced_mpeg_size)"
        },
        "return": "-EINVAL"
    }
},
{
    "kretprobe:CX18_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "atomic_read(&cx->tot_capturing)": "== 0",
            "s->type": "== CX18_ENC_STREAM_TYPE_MPG",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kretprobe:set_bit": {
        "description": "Set bit CX18_F_S_STOPPING in s->s_flags",
        "pre": {
            "s->s_flags": "!= null"
        }
    },
    "kretprobe:cx18_vapi": {
        "description": "Call cx18_vapi function",
        "pre": {
            "cx": "!= null",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kretprobe:cx18_stop_v4l2_encode_stream": {
        "description": "Stop v4l2 encode stream",
        "pre": {
            "s": "!= null",
            "gop_end": "!= null"
        }
    }
},
{
    "kprobe:CX18_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "atomic_read(&cx->tot_capturing)": "== 0",
            "s->type": "== CX18_ENC_STREAM_TYPE_MPG",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the CX18_F_S_STOPPING flag",
        "pre": {
            "s->s_flags": "!= null"
        }
    },
    "kprobe:cx18_vapi": {
        "description": "Call cx18_vapi function",
        "pre": {
            "cx": "!= null",
            "CX18_CPU_CAPTURE_STOP": "!= null",
            "s->handle": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:cX18_stop_v4l2_encode_stream": {
        "description": "Stop V4L2 encode stream",
        "pre": {
            "s": "!= null",
            "gop_end": "!= null"
        }
    },
    "kprobe:cx18_stream_enabled": {
        "description": "Check if the stream is enabled",
        "pre": {
            "s": "!= null"
        }
    }
},
{
    "kretprobe:cx88_risc_buffer": {
        "description": "Calculate and allocate RISC buffer for cx88 device.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "top_offset": ">=0",
            "bottom_offset": ">=0",
            "bpl": ">=0",
            "padding": ">=0",
            "lines": ">=0"
        },
        "post": {
            "instructions": ">=0",
            "risc->size": ">=0",
            "risc->dma": "=0",
            "risc->cpu": "!=null"
        }
    }
},
{
    "kprobe:cx88_risc_buffer": {
        "description": "Function to estimate risc mem",
        "pre": {
            "pci": "!=null",
            "risc.size": ">0",
            "risc.dma": "is an integer",
            "risc.cpu": "valid memory address",
            "sglist": "!=null",
            "top_offset": "!=null",
            "bottom_offset": "!=null",
            "bpl": "!=null",
            "padding": "!=null",
            "lines": "!=null"
        }
    }
},
{
    "kretprobe:cx88_risc_databuffer": {
        "description": "Estimate RISC memory usage for cx88 driver.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": ">=0",
            "lines": ">=0",
            "lpi": ">=0"
        },
        "post": {
            "instructions": ">=0",
            "risc->size": "instructions * 8",
            "risc->dma": "0",
            "risc->cpu": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": "!=null",
            "lines": "!=null",
            "lpi": "!=null"
        }
    }
},
{
    "kretprobe:.fifo_start = 0x185400": {
        "description": "The same as audio IN",
        "pre": {
            ".fifo_start": "== 0x185400"
        }
    }
},
{
    "kprobe:.fifo_start = 0x185400": {
        "description": "Same as audio IN",
        "pre": {
            ".fifo_start": "==0x185400"
        }
    }
},







{
    "kprobe:cx_andor": {
        "description": "Set the scale and filters for the cx88 video device.",
        "pre": {
            "core": "!=null",
            "width": "!=null",
            "height": "!=null",
            "field": "in [V4L2_FIELD_ANY, V4L2_FIELD_NONE, V4L2_FIELD_TOP, V4L2_FIELD_BOTTOM, V4L2_FIELD_INTERLACED, V4L2_FIELD_SEQ_TB, V4L2_FIELD_SEQ_BT, V4L2_FIELD_ALTERNATE, V4L2_FIELD_INTERLACED_TB, V4L2_FIELD_INTERLACED_BT, V4L2_FIELD_ALTERNATE_TB, V4L2_FIELD_ALTERNATE_BT]",
            "swidth": "norm_swidth(core->tvnorm)",
            "sheight": "norm_maxh(core->tvnorm)",
            "value": "!=null",
            "norm": "v4l2_norm_to_name(core->tvnorm)",
            "height": "2 if !V4L2_FIELD_HAS_BOTH(field) else height",
            "value": "(width - norm_hdelay(core->tvnorm)) * swidth & 0x3fe",
            "value": "(swidth * 4096 / width) - 4096",
            "width": "width",
            "value": "(0x10000 - (sheight - 512) * (height - 512) / 512) & 0x1fff",
            "sheight": "sheight",
            "value": "0",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value",
            "value": "value | (1 << 19)",
            "value": "value | (1 << 15) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 16) if core->tvnorm & V4L2_STD_SECAM else value",
            "value": "value | (1 << 13) | (1 << 5) if INPUT(core->input).type == CX88_VMUX_SVIDEO else value",
            "value": "value | (1 << 3) if field == V4L2_FIELD_INTERLACED else value",
            "value": "value | (1 << 0) if width < 385 else value",
            "value": "value | (1 << 1) if width < 193 else value",
            "value": "value | (3 << 5) if nocomb else value",
            "value": "value"
        }
    }
},


{
    "kretprobe:cx88_vdev_init": {
        "description": "Initialize cx88 video device",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null",
            "core->v4l2_dev": "!=null",
            "pci->dev": "!=null",
            "video_device_release_empty": "!=null",
            "core->lock": "!=null",
            "core->name": "!=null",
            "type": "!=null",
            "core->board.name": "!=null"
        }
    }
},
{
    "kprobe:vfd->v4l2_dev = &core->v4l2_dev;vfd->dev_parent = &pci->dev;vfd->release = video_device_release_empty;vfd->lock = &core->lock;snprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", core->name, type, core->board.name);}EXPORT_SYMBOL(cx88_vdev_init": {
        "description": "Initialize the video device structure for cx88 driver.",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null",
            "vfd->v4l2_dev": "==&core->v4l2_dev",
            "vfd->dev_parent": "==&pci->dev",
            "vfd->release": "==video_device_release_empty",
            "vfd->lock": "==&core->lock",
            "snprintf(vfd->name, sizeof(vfd->name), \"%s %s (%s)\", core->name, type, core->board.name);": "executes successfully"
        }
    }
},




{
    "kretprobe:cx8802_register_driver": {
        "description": "Register a cx8802 driver",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kretprobe:cx8802_unregister_driver": {
        "description": "Unregister the cx8802 driver",
        "pre": {
            "d->type_id": "!= drv->type_id",
            "err": "== 0"
        }
    }
},
{
    "kprobe:cx8802_unregister_driver": {
        "description": "Unregister the cx8802 driver",
        "pre": {
            "d->type_id": "!= drv->type_id",
            "err": "== 0"
        }
    }
},


{
    "kretprobe:break;}/* If software stereo detection is not supported...": {
        "description": "This function checks if software stereo detection is supported.",
        "pre": {
            "core": "!=null",
            "t": "!=null",
            "core->astat": "!=reg",
            "reg": "!=null",
            "m[mode]": "!=null",
            "p[pilot]": "!=null",
            "aud_ctl_names[cx_read(AUD_CTL) & 63]": "!=null",
            "t->capability": "& (V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_SAP | V4L2_TUNER_CAP_LANG1 | V4L2_TUNER_CAP_LANG2)",
            "t->rxsubchans": "= UNSET",
            "t->audmode": "= V4L2_TUNER_MODE_MONO",
            "mode": "= 0, 1, 2, 3",
            "core->tvaudio": "= WW_BTSC, WW_BG, WW_DK, WW_M, WW_EIAJ",
            "core->use_nicam": "= false",
            "t->rxsubchans": "= cx88_dsp_detect_stereo_sap(core)"
        }
    }
},



{
    "kretprobe:memset": {
        "description": "Set the memory block starting at &t with 0, for a size of sizeof(t).",
        "pre": {
            "&t": "!=null",
            "sizeof(t)": ">0",
            "core->audiomode_manual": "==UNSET"
        },
        "post": {
            "core->tvaudio": "in [WW_BG, WW_DK, WW_M, WW_I, WW_L]",
            "core->use_nicam": "==true"
        }
    },
    "kretprobe:cx88_get_stereo": {
        "description": "Get the stereo information for the given core and store it in &t.",
        "pre": {
            "core": "!=null",
            "&t": "!=null"
        },
        "post": {
            "core->tvaudio": "in [WW_BG, WW_DK, WW_M, WW_I, WW_L]",
            "core->use_nicam": "==true"
        }
    }
},
{
    "memset": {
        "pre": {
            "dest": "!=null",
            "value": "0",
            "count": "sizeof(t)"
        }
    },
    "cx88_get_stereo": {
        "pre": {
            "core": "!=null",
            "t": "!=null"
        }
    },
    "core->audiomode_manual": {
        "pre": {
            "core": "!=null",
            "core->audiomode_manual": "!=UNSET"
        }
    }
},
{
    "kretprobe:cx_write": {
        "description": "Write a value to the map represented by MO_DDSCFG_IO.",
        "pre": {
            "MO_DDSCFG_IO": "!=null",
            "value": "==0x5"
        }
    }
},
{
    "kprobe:cx_write": {
        "description": "Write a value to the map represented by MO_DDSCFG_IO.",
        "pre": {
            "MO_DDSCFG_IO": "!=null",
            "value": "0x5"
        }
    }
},


{
    "kretprobe:usleep_range": {
        "description": "Sleep for a specified range of microseconds.",
        "pre": {
            "usec_min": "== 10000",
            "usec_max": "== 20000"
        }
    },
    "kretprobe:cx88_set_tvaudio": {
        "description": "Set the TV audio for the cx88 core.",
        "pre": {
            "core": "!= null"
        }
    },
    "kretprobe:EXPORT_SYMBOL(cx88_set_freq": {
        "description": "Exported symbol for cx88_set_freq function.",
        "pre": {}
    }
},
{
    "kprobe:usleep_range": {
        "description": "Sleep for a specified range of microseconds.",
        "pre": {
            "min": "10000",
            "max": "20000"
        }
    },
    "kprobe:cx88_set_tvaudio": {
        "description": "Set the TV audio for the cx88 core.",
        "pre": {
            "core": "!=null"
        }
    },
    "kprobe:return": {
        "description": "Return 0.",
        "pre": {}
    },
    "kprobe:EXPORT_SYMBOL(cx88_set_freq": {
        "description": "Export the symbol cx88_set_freq.",
        "pre": {}
    }
},
{
    "kretprobe:cx88_dsp_detect_stereo_sap": {
        "description": "If audio RDS fifo is disabled, we can't read the samples",
        "pre": {
            "core": "!=null",
            "samples": "!=null",
            "N": "!=null",
            "ret": "!=null",
            "cx_read(MO_AUD_DMACNTRL) & 0x04": "==0",
            "cx_read(AUD_CTL) & EN_FMRADIO_EN_RDS": "==0",
            "wait_time": ">=500"
        }
    }
},



{
    "kretprobe:ivtv_stop_v4l2_encode_stream": {
        "description": "Stop the capture of the IVTV V4L2 encode stream.",
        "pre": {
            "s->type": "== IVTV_DEC_STREAM_TYPE_VOUT",
            "atomic_read(&itv->capturing)": "== 0"
        }
    }
},
{
    "kprobe:IVTV_DEBUG_INFO": {
        "description": "Stop Capture",
        "pre": {
            "s->type": "== IVTV_DEC_STREAM_TYPE_VOUT",
            "atomic_read(&itv->capturing)": "== 0"
        }
    }
},

{
    "kprobe:ivtv_claim_stream": {
        "description": "Claim a stream in the ivtv driver",
        "pre": {
            "s->fh": "== &id->fh"
        }
    }
},



{
    "kprobe:ivtv_msleep_timeout": {
        "description": "Sleep for a specified number of milliseconds with a timeout.",
        "pre": {
            "msecs": ">=0",
            "intr": "is an integer"
        }
    }
},
{
    "kretprobe:ivtv_setup_pci": {
        "description": "PCI Device Setup",
        "pre": {
            "itv": "!=null",
            "pdev": "!=null",
            "pci_id": "!=null",
            "retval": "in [-EIO, -ENXIO]"
        },
        "post": {
            "retval": {
                "==": "-EIO",
                "goto": "free_worker"
            },
            "retval": {
                "==": "-ENXIO",
                "goto": "free_mem"
            }
        }
    }
},


{
    "kprobe:request_module": {
        "description": "Initialize ivtv-alsa for this instance of the cx18 device",
        "pre": {
            "module": "=='ivtv-alsa'"
        }
    }
},
{
    "kretprobe:ivtv_open_id": {
        "description": "Open the ivtv device with the given id.",
        "pre": {
            "itv": "!=null",
            "fh": "!=null",
            "fw_retry_count": ">0",
            "video_input": "!=null",
            "fh.itv": "==itv",
            "fh.type": "==IVTV_ENC_STREAM_TYPE_MPG",
            "test_bit(IVTV_F_I_FAILED, &itv->i_flags)": "==0",
            "test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags)": "==0"
        }
    }
},
{
    "kprobe:struct_ivtv_open_id_fh": {
        "description": "Function struct ivtv_open_id fh",
        "pre": {
            "fh.itv": "!=null",
            "fh.type": "IVTV_ENC_STREAM_TYPE_MPG",
            "test_bit(IVTV_F_I_FAILED, &itv->i_flags)": "false",
            "test_and_set_bit(IVTV_F_I_INITED, &itv->i_flags)": "false",
            "fw_retry_count": "> 0"
        }
    }
},
{
    "kretprobe:cx25821_set_gpiopin_direction": {
        "description": "Check for valid pinNumber",
        "pre": {
            "dev": "!=null",
            "pin_number": ">= 0",
            "pin_logic_value": "!=null"
        }
    }
},
{
    "kprobe:cx25821_set_gpiopin_direction": {
        "description": "Check for valid pinNumber",
        "pre": {
            "dev": "!=null",
            "pin_number": ">= 0",
            "pin_logic_value": "!=null"
        }
    }
},

{
    "kprobe:cx25821_sram_channel_setup_audio": {
        "description": "Setup audio for cx25821 device",
        "pre": {
            "dev": "!=null",
            "ch": {
                "cmds_start": "==0",
                "ptr1_reg": "!=null",
                "ptr2_reg": "!=null",
                "cnt2_reg": "!=null",
                "cnt1_reg": "!=null"
            },
            "bpl": "!=null",
            "risc": "!=null"
        }
    }
},





{
    "kprobe:cx25821_risc_databuffer_audio": {
        "description": "Jump and write need an extra dword",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": "!=null",
            "lines": "!=null",
            "lpi": "!=null"
        }
    }
},
{
    "kretprobe:0,   /* n_slots */": {
        "description": "altera_ci_init(struct altera_ci_config  config, int ci_nr)",
        "pre": {
            "config": "!=null",
            "ci_nr": "int",
            "state": "!=null",
            "temp_int": "!=null",
            "inter": "!=null",
            "ret": "int",
            "store": "u8",
            "state->internal": "!=null",
            "state->nr": "int",
            "state->ca.owner": "THIS_MODULE",
            "state->ca.read_attribute_mem": "altera_ci_read_attribute_mem",
            "state->ca.write_attribute_mem": "altera_ci_write_attribute_mem",
            "state->ca.read_cam_control": "altera_ci_read_cam_ctl",
            "state->ca.write_cam_control": "altera_ci_write_cam_ctl",
            "state->ca.slot_reset": "altera_ci_slot_reset",
            "state->ca.slot_shutdown": "altera_ci_slot_shutdown",
            "state->ca.slot_ts_enable": "altera_ci_slot_ts_ctl",
            "state->ca.poll_slot_status": "altera_poll_ci_slot_status",
            "state->ca.data": "!=null",
            "dvb_ca_en50221_init(config->adapter,   &state->ca,     flags": "ret"
        }
    }
},
{
    "kprobe:0,   /* n_slots `": {
        "description": "Initialize the altera_ci_state structure for the given configuration and ci_nr.",
        "pre": {
            "config": "!=null",
            "ci_nr": "int",
            "state": "kzalloc(sizeof(struct altera_ci_state), GFP_KERNEL)",
            "temp_int": "find_inode(config->dev)",
            "inter": "NULL or kzalloc(sizeof(struct fpga_internal), GFP_KERNEL)",
            "ret": "int",
            "store": "u8",
            "temp_int != NULL": "bool",
            "inter->cis_used++": "bool",
            "inter->fpga_rw = config->fpga_rw": "bool",
            "mutex_init(&inter->fpga_mutex)": "void",
            "inter->strt_wrk = 1": "void",
            "state->internal = inter": "void",
            "state->nr = ci_nr - 1": "void",
            "state->ca.owner = THIS_MODULE": "void",
            "state->ca.read_attribute_mem = altera_ci_read_attribute_mem": "void",
            "state->ca.write_attribute_mem = altera_ci_write_attribute_mem": "void",
            "state->ca.read_cam_control = altera_ci_read_cam_ctl": "void",
            "state->ca.write_cam_control = altera_ci_write_cam_ctl": "void",
            "state->ca.slot_reset = altera_ci_slot_reset": "void",
            "state->ca.slot_shutdown = altera_ci_slot_shutdown": "void",
            "state->ca.slot_ts_enable = altera_ci_slot_ts_ctl": "void",
            "state->ca.poll_slot_status = altera_poll_ci_slot_status": "void",
            "state->ca.data = state": "void",
            "ret = dvb_ca_en50221_init(config->adapter, &state->ca, flags)": "int"
        }
    }
},
{
    "kretprobe:dst_probe": {
        "description": "Check if the ASIC is present",
        "pre": {
            "state": "!=null",
            "dvb_adapter": "!=null",
            "dst_probe(state)": "< 0"
        }
    }
},




{
    "kprobe:bt878_risc_program": {
        "description": "Start the bt878 device with the given control register, op_sync_orin, and irq_err_ignore values.",
        "pre": {
            "bt": "!=null",
            "controlreg": "&= ~0x1f",
            "controlreg": "|= 0x1b",
            "btwrite(bt->risc_dma, BT878_ARISC_START)": "!=null",
            "int_mask": "in [6, 2, 8, 4, 0]"
        }
    }
},

{
    "sof_ipc3_do_rx_work": {
        "description": "Function for handling received IPC messages",
        "pre": {
            "cmd": "!=null",
            "cmd": "in [0, SOF_GLB_TYPE_MASK]"
        }
    }
},
{
    "kretprobe:ddbridge_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ddbridge_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},

{
    "kprobe:case 1:core_dbg": {
        "description": "Setting GPIO to static value",
        "pre": {
            "dev": "!=null",
            "bit_no": "!=null",
            "value": "!=null"
        }
    }
},




{
    "kretprobe:saa7134_buffer_queue": {
        "description": "Queue a buffer for DMA transfer.",
        "pre": {
            "dev": "!=null",
            "q": "!=null",
            "buf": "!=null",
            "dev->pci": "!=null",
            "q->dma": "!=null",
            "buf->size": ">0",
            "buf->data": "!=null",
            "buf->dma": "!=null",
            "buf->dma->cpu": "!=null",
            "buf->dma->dma_addr": "!=null",
            "buf->dma->size": ">0",
            "buf->dma->cpu->pci": "!=null",
            "buf->dma->cpu->pt": "!=null",
            "buf->dma->cpu->pt->cpu": "!=null",
            "buf->dma->cpu->pt->dma": "!=null",
            "buf->dma->cpu->pt->size": ">0",
            "buf->dma->cpu->pt->cpu->pci": "!=null",
            "buf->dma->cpu->pt->cpu->pt": "!=null",
            "buf->dma->cpu->pt->cpu->pt->cpu": "!=null",
            "buf->dma->cpu->pt->cpu->pt->dma": "!=null",
            "buf->dma->cpu->pt->cpu->pt->size": ">0"
        }
    }
},




{
    "kprobe:if (0 != card(dev).gpiomask)": {
        "description": "Check if the gpiomask of the card associated with the given dev is not equal to zero.",
        "pre": {
            "card(dev)": {
                "gpiomask": "!=0"
            }
        }
    }
},




{
    "kretprobe:snd_tea575x_s_hw_freq_seek": {
        "description": "Seek hardware frequency in the snd_tea575x driver.",
        "pre": {
            "tea->cannot_read_data": "==0",
            "a->tuner": "==0",
            "a->wrap_around": "==0",
            "file->f_flags & O_NONBLOCK": "==0",
            "a->rangelow || a->rangehigh": "==1",
            "bands[i].rangelow == a->rangelow && bands[i].rangehigh == a->rangehigh": "exists i such that (i == BAND_FM && tea->tea5759) || (i == BAND_FM_JAPAN && !tea->tea5759) || (i == BAND_AM && !tea->has_am)"
        }
    }
},
{
    "kprobe:if (i != tea->band)": {
        "description": "Check if the value of i is not equal to the value of tea->band.",
        "pre": {
            "i": "!=null",
            "tea->band": "!=null"
        }
    }
},


{
    "kretprobe:snd_tea575x_init": {
        "description": "Initialize snd_tea575x structure",
        "pre": {
            "tea->cannot_read_data": "true",
            "v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK)": "called",
            "tea->cannot_mute": "false"
        }
    }
},
{
    "kprobe:snd_tea575x_init": {
        "description": "Initialize the snd_tea575x structure.",
        "pre": {
            "tea": {
                "cannot_read_data": true,
                "cannot_mute": false
            }
        }
    }
},
{
    "kretprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation.",
        "pre": {
            "ev": "!=null",
            "max": "!=null",
            "timings": "!=null",
            "n": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation.",
        "pre": {
            "ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation.",
        "pre": {
            "ev": "!=null",
            "*ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        },
        "post": {
            "return": "in [0, -ENOBUFS]",
            "*ev": "!=null"
        }
    }
},
{
    "kprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation.",
        "pre": {
            "ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_encode_scancode": {
        "description": "Encode a scancode as raw events",
        "pre": {
            "protocol": "!=null",
            "scancode": "!=null",
            "events": "!=null",
            "max": "!=null"
        },
        "post": {
            "return_value": ">=0",
            "return_value": "<=max"
        }
    }
},
{
    "kprobe:ir_raw_encode_scancode": {
        "description": "Encode a scancode as raw events",
        "pre": {
            "protocol": "!=null",
            "scancode": "!=null",
            "events": "!=null",
            "max": "!=null"
        },
        "post": {
            "return": ">=0",
            "return": "!= -ENOBUFS",
            "return": "!= -EINVAL"
        }
    }
},
{
    "kretprobe:ir_raw_encode_carrier": {
        "description": "Get carrier used for protocol",
        "pre": {
            "protocol": "!=null",
            "protocol": "in [RC_PROTO_1, RC_PROTO_2, RC_PROTO_3, ...]",
            "return_value": ">=0",
            "return_value": "!=EINVAL"
        }
    }
},
{
    "kprobe:ir_raw_encode_carrier": {
        "description": "Get carrier used for protocol",
        "pre": {
            "protocol": "!=null",
            "protocol": "in [RC_PROTO_1, RC_PROTO_2, RC_PROTO_3, ...]",
            "return_value": ">=0",
            "return_value": "<=MAX_CARRIER_VALUE",
            "return_value": "!=EINVAL"
        }
    }
},












{
    "kretprobe:dprintk": {
        "description": "Prints a debug message if reading from EEPROM fails.",
        "pre": {
            "proposed_mac": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:eth_zero_addr": {
        "description": "Sets the proposed MAC address to zero if reading from EEPROM fails.",
        "pre": {
            "proposed_mac": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    },
    "kretprobe:getmac_tt": {
        "description": "Retrieves the MAC address from the EEPROM and stores it in decodedMAC.",
        "pre": {
            "decodedMAC": "!=null",
            "encodedMAC": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},

{
    "kretprobe:flexcop_pid_feed_control": {
        "description": "Toggle complete-TS-streaming when certain conditions are met.",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "is boolean",
            "dvbdmxfeed->index": ">= max_pid_filter",
            "fc->extra_feedcount": "+= onoff ? 1 : -1",
            "max_pid_filter": "== 6",
            "fc->skip_6_hw_pid_filter": "== 0",
            "fc->has_32_hw_pid_filter": "== 1",
            "fc->feedcount": "+= onoff ? 1 : -1"
        }
    }
},
{
    "kprobe:flexcop_pid_feed_control": {
        "description": "Toggle complete-TS-streaming when certain conditions are met.",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "in [0, 1]",
            "fc->skip_6_hw_pid_filter": "!=null",
            "fc->has_32_hw_pid_filter": "!=null",
            "max_pid_filter": "!=null",
            "dvbdmxfeed->index": ">= max_pid_filter",
            "fc->extra_feedcount": "+= onoff ? 1 : -1",
            "max_pid_filter": "-= 6",
            "fc->skip_6_hw_pid_filter": "-= 6",
            "max_pid_filter": "+= 32",
            "fc->has_32_hw_pid_filter": "+= 32",
            "fc->feedcount": "+= onoff ? 1 : -1"
        }
    }
},
{
    "kretprobe:flexcop_sram_set_dest": {
        "description": "Sets the destination of the flexcop sram.",
        "pre": {
            "fc": "!=null",
            "dest": "!=null",
            "target": "!=null",
            "v": "!=null",
            "v.sram_dest_reg_714.NET_Dest": "if dest & FC_SRAM_DEST_NET",
            "v.sram_dest_reg_714.CAI_Dest": "if dest & FC_SRAM_DEST_CAI",
            "v.sram_dest_reg_714.CAO_Dest": "if dest & FC_SRAM_DEST_CAO",
            "v.sram_dest_reg_714.MEDIA_Dest": "if dest & FC_SRAM_DEST_MEDIA",
            "fc->rev": "!= FLEXCOP_III || target != FC_SRAM_DEST_TARGET_FC3_CA",
            "err": "target == FC_SRAM_DEST_TARGET_FC3_CA",
            "return": "0"
        }
    }
},
{
    "kprobe:return 0;}EXPORT_SYMBOL(flexcop_sram_set_dest": {
        "description": "Sets the destination of the flexcop sram.",
        "pre": {
            "fc": "!=null",
            "dest": "!=null",
            "target": "!=null",
            "v": "!=null",
            "v.sram_dest_reg_714.NET_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.CAI_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.CAO_Dest": "in [0, 1]",
            "v.sram_dest_reg_714.MEDIA_Dest": "in [0, 1]"
        }
    }
},
{
    "kretprobe:flexcop_i2c_request": {
        "description": "Perform an I2C request using the FlexCop adapter.",
        "pre": {
            "i2c->no_base_addr": true,
            "len": 0,
            "op": "FC_WRITE"
        }
    }
},
{
    "kprobe:flexcop_i2c_request": {
        "description": "Perform an I2C request using the FlexCop adapter.",
        "pre": {
            "i2c->no_base_addr": "true",
            "len": "0",
            "op": "FC_WRITE"
        }
    }
},
{
    "kretprobe:flexcop_i2c_init": {
        "description": "Initialize the I2C interface of the flexcop device.",
        "pre": {
            "fc": "!=null",
            "ret": "==0"
        }
    }
},
{
    "kprobe:flexcop_i2c_init": {
        "description": "Initialize the I2C interface of the flexcop device.",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:vb2_buffer_in_use": {
        "description": "Check if the buffer is in use by multiple users.",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "vb->num_planes": ">0",
            "vb->planes[plane].mem_priv": "!=null",
            "call_memop(vb, num_user mem_priv)": ">1"
        }
    }
},
{
    "kprobe:vb2_buffer_in_use": {
        "description": "Check if the buffer is in use by multiple users.",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "vb->num_planes": ">0",
            "vb->planes[0].mem_priv": "!=null",
            "call_memop(vb, num_user mem_priv)": ">1"
        }
    }
},
{
    "kretprobe:__verify_mmap_ops": {
        "description": "Verify the memory operations for mmap",
        "pre": {
            "q": "!=null",
            "memory": "==VB2_MEMORY_MMAP"
        }
    }
},
{
    "kprobe:__verify_mmap_ops": {
        "description": "Verify the memory operations for mmap.",
        "pre": {
            "q": "!=null",
            "memory": "==VB2_MEMORY_MMAP"
        }
    }
},


{
    "kretprobe:dvb_frontend_detach": {
        "description": "Detach the DVB frontend and remove the list entry.",
        "pre": {
            "fe->dvb.frontend": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:dvb_frontend_detach": {
        "description": "Detach the DVB frontend and remove the list entry.",
        "pre": {
            "fe->dvb.frontend": "!=null"
        }
    }
},
{
    "kretprobe:vb2_querybuf": {
        "description": "Query video buffer information",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:vb2_querybuf": {
        "description": "Query video buffer information",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:vb2_create_framevec": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "length": "!=null",
            "write": "!=null"
        }
    }
},
{
    "kprobe:vb2_create_framevec": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "length": "!=null",
            "write": "!=null"
        }
    }
},
{
    "kretprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns and free the passed vector.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:get_vaddr_frames": {
        "description": "Map virtual addresses to page frame numbers or page pointers.",
        "pre": {
            "start": "!=null",
            "nr_frames": ">= 0",
            "write": "in [true, false]",
            "vec": "!=null"
        }
    }
},
{
    "kprobe:get_vaddr_frames": {
        "description": "Map virtual addresses to pfns",
        "pre": {
            "start": "!=null",
            "nr_frames": "!=null",
            "write": "!=null",
            "vec": "!=null",
            "vec->entries": ">=nr_frames"
        }
    }
},
{
    "kretprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them and invalidate the frame vector.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pages": {
        "description": "Convert frame vector to contain page pointers",
        "pre": {
            "vec": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:frame_vector_to_pages": {
        "description": "Convert frame vector to contain page pointers.",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pfns": {
        "description": "convert frame vector to contain pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_to_pfns": {
        "description": "convert frame vector to contain pfns",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_create": {
        "description": "Allocate and initialize structure for pinned pfns",
        "pre": {
            "nr_frames": ">= 0"
        }
    }
},
{
    "kprobe:frame_vector_create": {
        "description": "Allocate and initialize structure for pinned pfns.",
        "pre": {
            "nr_frames": ">= 0"
        }
    }
},
{
    "kretprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector",
        "pre": {
            "vec": "!=null"
        }
    }
},


{
    "kretprobe:dibusb_dib3000mc_tuner_attach": {
        "description": "Attach DIB3000MC tuner to DVB USB adapter",
        "pre": {
            "le16_to_cpu(adap->dev->udev->descriptor.idVendor)": "USB_VID_LITEON",
            "le16_to_cpu(adap->dev->udev->descriptor.idProduct)": "USB_PID_LITEON_DVB_T_WARM",
            "a": "0x00",
            "a": "0x80",
            "desc": "2",
            "desc & 0x80": "true"
        }
    }
},
{
    "kprobe:dvb_attach": {
        "description": "Attach a DVB device to the adapter.",
        "pre": {
            "dvb_pll_attach": "!=null",
            "adap->fe_adap[0].fe": "!=null",
            "0x60": "!=null",
            "tun_i2c": "!=null",
            "DVB_PLL_ENV57H1XD5": "!=null"
        }
    }
},
{
    "kretprobe:usb_cypress_load_firmware": {
        "description": "Load firmware to a Cypress USB device.",
        "pre": {
            "udev": "!=null",
            "fw": "!=null",
            "type": "int",
            "hx": "!=null",
            "buf": "!=null",
            "ret": "int",
            "pos": "int",
            "cpu_cs_register": "u16",
            "buf_size": "sizeof(hx)",
            "buf_allocation": "!null",
            "stop_CPU": "true"
        },
        "post": {
            "ret": "==1"
        }
    }
},
{
    "kprobe:usb_cypress_load_firmware": {
        "description": "Load firmware to a Cypress USB device.",
        "pre": {
            "udev": "!=null",
            "fw": "!=null",
            "type": "int"
        }
    },
    "kprobe:usb_cypress_writemem": {
        "description": "Write data to the Cypress USB device memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "int",
            "buf": "!=null",
            "buf_size": "int"
        }
    },
    "kprobe:dvb_usb_get_hexline": {
        "description": "Get a line of hexadecimal data from a DVB USB device.",
        "pre": {
            "fw": "!=null",
            "hx": "!=null",
            "pos": "int"
        }
    }
},
{
    "kretprobe:usb_cypress_writemem": {
        "description": "Write data to a Cypress USB device's memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "!=null",
            "buf": "!=null",
            "1": "!=null",
            "usb_cypress_writemem(udev, cpu_cs_register, buf, 1)": "!=1"
        }
    }
},
{
    "kprobe:usb_cypress_writemem": {
        "description": "Write data to a Cypress USB device's memory.",
        "pre": {
            "udev": "!=null",
            "cpu_cs_register": "!=null",
            "buf": {
                "type": "array",
                "length": 1,
                "values": [0]
            },
            "1": "==1"
        }
    }
},
{
    "kretprobe:for (i = 0; i < d->props.rc.legacy.rc_map_size; i++)if (rc5_custom(&keymap[i]) == keybuf[1] &&rc5_data(&keymap[i]) == keybuf[3])": {
        "description": "Check if the conditions for the given function are satisfied.",
        "pre": {
            "d": "!=null",
            "keybuf": "!=null",
            "event": "!=null",
            "state": "!=null",
            "i": ">=0",
            "i": "< d->props.rc.legacy.rc_map_size",
            "rc5_custom(&keymap[i])": "== keybuf[1]",
            "rc5_data(&keymap[i])": "== keybuf[3]"
        }
    }
},
{
    "kprobe:for": {
        "description": "Loop through the rc_map_table and check if rc5_custom(&keymap[i]) is equal to keybuf[1] and rc5_data(&keymap[i]) is equal to keybuf[3].",
        "pre": {
            "d": "!=null",
            "keybuf": "array of size 5",
            "event": "!=null",
            "state": "!=null",
            "i": ">=0 and < d->props.rc.legacy.rc_map_size",
            "keymap": "!=null",
            "keymap[i]": "!=null",
            "keybuf[1]": "!=null",
            "keybuf[3]": "!=null",
            "rc5_custom(&keymap[i])": "== keybuf[1]",
            "rc5_data(&keymap[i])": "== keybuf[3]"
        }
    }
},
{
    "kretprobe:dvb_usb_generic_rw": {
        "description": "Reads and writes data using the DVB USB generic interface.",
        "pre": {
            "ret": "== 0",
            "rbuf": "!= null",
            "rlen": "!= 0"
        }
    }
},
{
    "if (!ret && rbuf && rlen)": {
        "description": "Check the conditions for the given function",
        "pre": {
            "d": "!=null",
            "wbuf": "!=null",
            "wlen": "!=0"
        },
        "post": {
            "ret": "false",
            "rbuf": "!=null",
            "rlen": "!=0"
        }
    }
},





{
    "kprobe:;} else if (ret == RECONNECTS_USB)": {
        "description": "Condition for the function `;} else if (ret == RECONNECTS_USB)`",
        "pre": {
            "intf": "any",
            "id": "any"
        }
    }
},

{
    "kprobe:if (d->rc_polling_active)cancel_delayed_work_sync(&d->rc_query_work);for (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--)": {
        "description": "Stop remote controller poll",
        "pre": {
            "d": {
                "rc_polling_active": true
            },
            "i": ">= 0"
        }
    }
},
{
    "kretprobe:usb_urb_submitv2": {
        "description": "Submit a USB urb for streaming.",
        "pre": {
            "d": "is of type struct dvb_usb_device",
            "d->adapter[i].stream": "!=null",
            "d->props->streaming_ctrl": "exists",
            "fe": "is of type struct dvb_frontend",
            "d->adapter[i].active_fe": "!= -1",
            "d->adapter[i].dvb_adap.priv": "exists",
            "d->adapter[i].fe[active_fe]": "exists",
            "dvb_frontend_resume(fe)": "returns a value"
        }
    }
},
{
    "kprobe:usb_urb_submitv2": {
        "description": "Submit a USB urb for streaming.",
        "pre": {
            "d": {
                "adapter": {
                    "i": {
                        "stream": "!=null"
                    }
                },
                "props": {
                    "streaming_ctrl": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:gspca_expo_autogain": {
        "description": "Function for automatic gain adjustment in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_knee": "!=null",
            "exposure_knee": "!=null",
            "v4l2_ctrl_g_ctrl(gspca_dev->autogain)": "!=0"
        }
    }
},
{
    "kprobe:gspca_expo_autogain": {
        "description": "Function for automatic gain adjustment in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_knee": "!=null",
            "exposure_knee": "!=null",
            "v4l2_ctrl_g_ctrl(gspca_dev->autogain)": "!=0"
        }
    }
},
{
    "kretprobe:gspca_coarse_grained_expo_autogain": {
        "description": "Autogain function for gspca_dev",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null",
            "gain_low": "!=null",
            "gain_high": "!=null",
            "gain": "!=null",
            "orig_gain": "!=null",
            "exposure": "!=null",
            "orig_exposure": "!=null",
            "steps": "!=null",
            "retval": "!=null"
        },
        "post": {
            "retval": "==0",
            "gain": "==orig_gain",
            "exposure": "==orig_exposure",
            "steps": "==(desired_avg_lum - avg_lum) / deadzone",
            "gain_low": "==(gspca_dev->gain->maximum - gspca_dev->gain->minimum) * 5 / 2 + gspca_dev->gain->minimum",
            "gain_high": "==(gspca_dev->gain->maximum - gspca_dev->gain->minimum) * 5 / 4 + gspca_dev->gain->minimum"
        }
    }
},
{
    "kprobe:gspca_coarse_grained_expo_autogain": {
        "description": "Function for coarse-grained exposure autogain in gspca_dev.",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "!=null",
            "desired_avg_lum": "!=null",
            "deadzone": "!=null"
        }
    }
},

{
    "kprobe:gspca_frame_add": {
        "description": "Add a frame to the gspca device.",
        "pre": {
            "gspca_dev": "!=null",
            "packet_type": "in [GSPCA_PACKET_TYPE_1, GSPCA_PACKET_TYPE_2, GSPCA_PACKET_TYPE_3, GSPCA_PACKET_TYPE_4]",
            "data": "!=null",
            "len": ">=0",
            "buf": "==null"
        }
    }
},
{
    "kretprobe:gspca_dev_probe2": {
        "description": "Probe the gspca_dev structure for the given usb_interface, usb_device_id, sd_desc, dev_size, and module.",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "sd_desc": "!=null",
            "dev_size": "< sizeof *gspca_dev",
            "module": "!=null"
        }
    }
},
{
    "kprobe:gspca_dev_probe2": {
        "description": "Probe the gspca_dev structure for a USB device.",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "sd_desc": "!=null",
            "dev_size": "< sizeof *gspca_dev",
            "module": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_device_put": {
        "description": "Disconnects the gspca device from the v4l2 device.",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "gspca_dev->v4l2_dev": "!=null",
            "gspca_dev->present": "false",
            "gspca_dev->usb_lock": "unlocked"
        },
        "post": {
            "gspca_dev->present": "false",
            "gspca_dev->input_dev": "null",
            "gspca_dev->v4l2_dev": "disconnected",
            "gspca_dev->vdev": "unregistered",
            "gspca_dev->usb_lock": "unlocked"
        }
    }
},
{
    "kprobe:v4l2_device_put": {
        "description": "Release the reference to the v4l2_device structure.",
        "pre": {
            "gspca_dev": "!=null",
            "gspca_dev->v4l2_dev": "!=null"
        }
    }
},
{
    "kretprobe:gspca_suspend": {
        "description": "Suspends the gspca device.",
        "pre": {
            "intf": "!=null",
            "message": "!=null",
            "gspca_dev": "=usb_get_intfdata(intf)",
            "gspca_dev->queue": "vb2_start_streaming_called(&gspca_dev->queue)",
            "gspca_dev->usb_lock": "mutex_lock(&gspca_dev->usb_lock)",
            "gspca_dev->frozen": "=1"
        }
    }
},
{
    "kprobe:gspca_suspend": {
        "description": "Suspends the gspca device.",
        "pre": {
            "intf": "!=null",
            "message": "!=null"
        }
    }
},
{
    "kretprobe:gspca_resume": {
        "description": "Resume function for gspca driver",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "streaming": "int",
            "ret": "int",
            "gspca_dev->usb_lock": "mutex",
            "gspca_dev->frozen": "int",
            "gspca_dev->usb_err": "int",
            "gspca_dev->sd_desc": "!=null"
        }
    }
},
{
    "kprobe:gspca_resume": {
        "description": "Resume function for gspca driver.",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "streaming": "in [0, 1]",
            "ret": "int",
            "mutex_unlock": "called"
        }
    }
},
{
    "kretprobe:ttusbdecfe_dvbs_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "state": "==null"
        }
    }
},
{
    "kprobe:ttusbdecfe_dvbs_attach": {
        "description": "Allocate memory for the internal state",
        "pre": {
            "config": "!=null"
        }
    }
},
{
    "kretprobe:mt2060_readreg": {
        "description": "Read a register from the MT2060 device.",
        "pre": {
            "priv": "!=null",
            "REG_PART_REV": "!=null",
            "id": "!=null",
            "mt2060_readreg(priv, REG_PART_REV, &id)": "!=0"
        }
    }
},
{
    "kprobe:mt2060_readreg": {
        "description": "Read a register from the MT2060 tuner.",
        "pre": {
            "priv": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:fc0012_readreg": {
        "description": "Reads a register from the fc0012 tuner chip.",
        "pre": {
            "priv": "!=null",
            "i2c": "!=null",
            "cfg": "!=null",
            "fe": "!=null",
            "chip_id": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:fc0012_readreg": {
        "description": "Read a register from the fc0012 tuner.",
        "pre": {
            "priv": "!=null",
            "0x00": "is an integer",
            "&chip_id": "!=null"
        }
    }
},
{
    "kretprobe:mc44s803_readreg": {
        "description": "Reads a register from the MC44S803 device.",
        "pre": {
            "priv": "!=null",
            "reg": "!=null",
            "id": "!=null",
            "ret": "!=null",
            "priv->cfg": "!=null",
            "priv->i2c": "!=null",
            "priv->fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null"
        },
        "post": {
            "ret": "==0",
            "id": "==0x14"
        }
    }
},
{
    "kprobe:mc44s803_readreg": {
        "description": "Reads a register from the MC44S803 device.",
        "pre": {
            "priv": "!=null",
            "reg": "!=null",
            "id": "!=null",
            "ret": "!=null",
            "priv->cfg": "!=null",
            "priv->i2c": "!=null",
            "priv->fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "fe->ops.i2c_gate_ctrl(fe, 1)": "returns 0",
            "MC44S803_REG_MS(reg, MC44S803_ID)": "== 0x14"
        }
    }
},


{
    "kretprobe:mxl5005s_attach": {
        "description": "Attach the MXL5005S silicon tuner.",
        "pre": {
            "rf_freq_hz": "!=null"
        }
    }
},

{
    "kretprobe:qt1010_attach": {
        "description": "Attach the qt1010 tuner chip to the dvb_frontend",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kprobe:qt1010_attach": {
        "description": "Attach the qt1010 tuner chip to the dvb_frontend structure.",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        }
    }
},






{
    "kretprobe:fc0013_rc_cal_add": {
        "description": "Push rc_cal value and get rc_cal value",
        "pre": {
            "fe": "!=null",
            "rc_val": "!=null",
            "priv": "!=null",
            "ret": "!=null",
            "rc_cal": "!=null",
            "val": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null"
        }
    }
},

{
    "kretprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "==0x0d",
            "value": "==0x01"
        }
    },
    "kretprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "==0x10",
            "value": "==0x00"
        }
    },
    "kretprobe:fe->ops.i2c_gate_ctrl": {
        "description": "Close the I2C-gate.",
        "pre": {
            "fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "value": "==0"
        }
    }
},
{
    "kprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "0x0d",
            "value": "0x01"
        }
    },
    "kprobe:fc0013_writereg": {
        "description": "Write a value to a register in fc0013_priv structure.",
        "pre": {
            "priv": "!=null",
            "reg": "0x10",
            "value": "0x00"
        }
    },
    "kprobe:fe->ops.i2c_gate_ctrl": {
        "description": "Control the I2C gate in fe->ops structure.",
        "pre": {
            "fe": "!=null",
            "value": "0"
        }
    }
},

{
    "goto fail;case 1:/* new tuner instance": {
        "description": "N/A",
        "pre": {
            "fe": "!=null",
            "cfg": "!=null"
        }
    }
},


{
    "kretprobe:unsigned int msb;unsigned int logentry;unsigned int significand;unsigned int interpolation;if (unlikely(value == 0))": {
        "description": "This function calculates the logarithm base 2 of the given value.",
        "pre": {
            "value": "==0"
        }
    }
},
{
    "kprobe:unsigned int msb;unsigned int logentry;unsigned int significand;unsigned int interpolation;if (unlikely(value == 0))": {
        "description": "Calculates the logarithm base 2 of the given value.",
        "pre": {
            "value": "!=0"
        }
    }
},
{
    "kretprobe:u64 log;if (unlikely(value == 0))": {
        "description": "Calculate the base-10 logarithm of a 32-bit unsigned integer value, but return an incorrect result if the value is 0.",
        "pre": {
            "value": "!= 0"
        }
    }
},
{
    "kprobe:u64 log;if (unlikely(value == 0))": {
        "description": "Calculate the logarithm base 10 of the given value.",
        "pre": {
            "value": "==0"
        }
    }
},




{
    "kretprobe:dvbdev_check_free_adapter_num": {
        "description": "Check if the adapter number is free.",
        "pre": {
            "num": ">= 0",
            "num": "< DVB_MAX_ADAPTERS"
        }
    }
},

{
    "kretprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null",
            "change_type": "in [DVB_CA_CAMCHANGE_1, DVB_CA_CAMCHANGE_2, DVB_CA_CAMCHANGE_3, ...]"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null",
            "change_type": "in [DVB_CA_CAMCHANGE_1, DVB_CA_CAMCHANGE_2, DVB_CA_CAMCHANGE_3, ...]"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred.",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device.",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "!=null",
            "slot_count": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device.",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "!=null",
            "slot_count": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "pre": {
            "pubca": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "pre": {
            "pubca": "!=null"
        }
    }
},


{
    "kretprobe:dvb_ringbuffer_free": {
        "description": "Free the dvb_ringbuffer structure.",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "== smp_load_acquire(&rbuf->pwrite)"
        }
    }
},
{
    "kprobe:dvb_ringbuffer_free": {
        "description": "Check if the read pointer (pread) is equal to the value loaded from the write pointer (pwrite).",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "== smp_load_acquire(&rbuf->pwrite)"
        }
    }
},
{
    "kretprobe:dvb_ringbuffer_avail": {
        "description": "Calculate the available space in the dvb_ringbuffer.",
        "pre": {
            "rbuf": "!=null",
            "avail": "!=null",
            "smp_load_acquire": "called",
            "smp_store_release": "called in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()"
        }
    }
},
{
    "kprobe:dvb_ringbuffer_avail": {
        "description": "Calculate the available space in a ring buffer",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pwrite": "!=null",
            "rbuf->pread": "!=null",
            "rbuf->size": "!=null"
        },
        "helper": "dvb_ringbuffer_avail(struct dvb_ringbuffer rbuf)",
        "helper_doc": "ssize_t avail; smp_load_acquire() to load write pointer on reader side; this pairs with smp_store_release() in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()"
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Update the read pointer to ensure that buf is not overwritten until read is complete.",
        "pre": {
            "rbuf": "!=null",
            "rbuf->pread": "==0"
        }
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Update the value of rbuf->pread to 0 using smp_store_release.",
        "pre": {
            "rbuf": "!=null"
        }
    }
},
{
    "kretprobe:if (sec->secbuf[0] != 0xff || sec->secbuf[n - 1] != 0xff)": {
        "description": "Check if the first and last bytes of secbuf are not equal to 0xff.",
        "pre": {
            "sec": {
                "secbuf": {
                    "0": "!= 0xff",
                    "n - 1": "!= 0xff"
                }
            }
        }
    }
},

{
    "kretprobe:isac_rme_irq": {
        "description": "Handle ISAC RME interrupt.",
        "pre": {
            "isac": "!=null",
            "val": "& 0x40 != 0"
        }
    }
},
{
    "kprobe:isac_rme_irq": {
        "description": "Handle ISAC RME interrupt.",
        "pre": {
            "isac": "!=null",
            "val": "& 0x40 != 0"
        }
    }
},
{
    "kretprobe:mISDNisac_irq": {
        "description": "This function handles the interrupt for mISDN ISAC.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null",
            "ipac": "!=null",
            "maxloop": ">=0",
            "ipac.type": "& [IPAC_TYPE_IPACX, IPAC_TYPE_IPAC]"
        },
        "post": {
            "ista": "ReadIPAC(ipac, IPAC_ISTA)",
            "cnt": "maxloop + 1",
            "ipac.type": "& [IPAC_TYPE_IPACX, IPAC_TYPE_IPAC]"
        },
        "helpers": {
            "ipac_irq": {
                "description": "This helper function handles the interrupt for IPAC.",
                "pre": {
                    "ipac": "!=null",
                    "ista": "!=null"
                }
            },
            "mISDNisac_irq": {
                "description": "This helper function handles the interrupt for mISDN ISAC.",
                "pre": {
                    "isac": "!=null",
                    "ista": "!=null"
                }
            },
            "ReadIPAC": {
                "description": "This helper function reads the value of IPAC register.",
                "pre": {
                    "ipac": "!=null",
                    "reg": "in [ISACX_ISTA, IPAC_ISTA]"
                },
                "post": {
                    "value": ">=0"
                }
            },
            "ReadISAC": {
                "description": "This helper function reads the value of ISAC register.",
                "pre": {
                    "isac": "!=null",
                    "reg": "ISAC_ISTA"
                },
                "post": {
                    "value": ">=0"
                }
            }
        }
    }
},
{
    "kprobe:mISDNisac_irq": {
        "description": "Interrupt handler for mISDN ISAC IRQ.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null"
        }
    },
    "kprobe:ipac_irq": {
        "description": "Interrupt handler for IPAC IRQ.",
        "pre": {
            "ipac": "!=null",
            "ista": "!=null"
        }
    },
    "kprobe:ReadIPAC": {
        "description": "Read IPAC register.",
        "pre": {
            "ipac": "!=null",
            "reg": "!=null"
        }
    },
    "kprobe:mISDNisac_irq(isac, istad);}if (ista & (IPAC__ICA | IPAC__EXA))ipac_irq(&ipac->hscx[0], ista);if (ista & (IPAC__ICB | IPAC__EXB))ipac_irq(&ipac->hscx[1], ista);ista = ReadIPAC(ipac, IPAC_ISTA);}} else if (ipac->type & IPAC_TYPE_HSCX)": {
        "description": "Interrupt handler for mISDN ISAC IRQ with additional conditions.",
        "pre": {
            "isac": "!=null",
            "istad": "!=null",
            "ipac": "!=null",
            "ista": "!=null",
            "ipac->hscx[0]": "!=null",
            "ipac->hscx[1]": "!=null",
            "ReadIPAC(ipac, IPAC_ISTA)": "!=null",
            "ipac->type": "!=null",
            "IPAC_TYPE_HSCX": "!=null"
        }
    }
},
{
    "kretprobe:ipac->hscx[i].slot": {
        "description": "Set the value of ipac->hscx[i].slot based on the condition (i == 0)",
        "pre": {
            "ipac": "!=null",
            "i": "!=null",
            "ipac->hscx[i].slot": "in [0x2f, 0x03]"
        }
    },
    "kretprobe:ipac->init": {
        "description": "Set the value of ipac->init",
        "pre": {
            "ipac": "!=null",
            "ipac->init": "=ipac_init"
        }
    },
    "kretprobe:ipac->release": {
        "description": "Set the value of ipac->release",
        "pre": {
            "ipac": "!=null",
            "ipac->release": "=free_ipac"
        }
    },
    "kretprobe:ret": {
        "description": "Calculate the value of ret based on the conditions",
        "pre": {
            "ISDN_P_B_RAW": "!=null",
            "ISDN_P_B_MASK": "!=null",
            "ret": "=((1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) | (1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)))"
        }
    }
},
{
    "kprobe:ipac->hscx[i].slot": {
        "description": "Set the value of ipac->hscx[i].slot based on the condition (i == 0)",
        "pre": {
            "ipac": "!=null",
            "i": "!=null",
            "ipac->hscx[i].slot": "in [0x2f, 0x03]"
        }
    },
    "kprobe:ipac->init": {
        "description": "Set the value of ipac->init",
        "pre": {
            "ipac": "!=null",
            "ipac->init": "=ipac_init"
        }
    },
    "kprobe:ipac->release": {
        "description": "Set the value of ipac->release",
        "pre": {
            "ipac": "!=null",
            "ipac->release": "=free_ipac"
        }
    },
    "kprobe:ret": {
        "description": "Calculate the value of ret based on the conditions",
        "pre": {
            "ret": "=((1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) | (1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK)))"
        }
    }
},
{
    "kretprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        },
        "post": {
            "return_value": ">=0",
            "status_flag": "in [HDLC_END_OF_FRAME, HDLC_FRAMING_ERROR, HDLC_CRC_ERROR, HDLC_LENGTH_ERROR]"
        }
    }
},
{
    "kprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kretprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream.",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kretprobe:capi_ctr_handle_message": {
        "description": "Handle incoming CAPI message",
        "pre": {
            "ctr": "!=null",
            "appl": "!=null",
            "skb": "!=null"
        }
    }
},

{
    "kretprobe:capi_ctr_ready": {
        "description": "Signal CAPI controller ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_ready": {
        "description": "Signal CAPI controller ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:attach_capi_ctr": {
        "description": "register CAPI controller",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, < 0]"
        }
    }
},
{
    "kprobe:attach_capi_ctr": {
        "description": "Register CAPI controller",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:detach_capi_ctr": {
        "description": "Unregister CAPI controller",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return_value": "in [0, < 0]"
        }
    }
},
{
    "kprobe:detach_capi_ctr": {
        "description": "Unregister CAPI controller",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:mISDN_ctrl_bchannel": {
        "description": "mISDN_ctrl_bchannel function",
        "pre": {
            "cq->p1": "!= 0",
            "cq->p2": "> MISDN_CTRL_RX_SIZE_IGNORE"
        }
    }
},


{
    "kprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set dch->rx_skb to NULL.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->len": ">=2"
        }
    },
    "kprobe:mISDN_HEAD_P": {
        "description": "Set hh->prim to PH_DATA_IND and hh->id to the SAPI TEI value from dch->rx_skb->data.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->data": "!=null"
        }
    },
    "kprobe:get_sapi_tei": {
        "description": "Get the SAPI TEI value from dch->rx_skb->data.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->data": "!=null"
        }
    },
    "kprobe:skb_queue_tail": {
        "description": "Append dch->rx_skb to the end of dch->rqueue.",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rqueue": "!=null"
        }
    },
    "kprobe:schedule_event": {
        "description": "Schedule an event with the FLG_RECVQUEUE flag for dch.",
        "pre": {
            "dch": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},
{
    "kretprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set it to NULL.",
        "pre": {
            "ech": "!=null",
            "ech->rx_skb": "!=null",
            "ech->rx_skb->len": ">=2",
            "hh": "!=null",
            "hh->prim": "PH_DATA_E_IND",
            "hh->id": "get_sapi_tei(ech->rx_skb->data)",
            "dch": "!=null",
            "dch->rqueue": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},
{
    "kprobe:dev_kfree_skb": {
        "description": "Free the skb buffer and set it to NULL.",
        "pre": {
            "ech->rx_skb": "!=null",
            "ech->rx_skb->len": ">=2",
            "hh": "!=null",
            "hh->prim": "PH_DATA_E_IND",
            "hh->id": "get_sapi_tei(ech->rx_skb->data)",
            "dch->rqueue": "!=null",
            "FLG_RECVQUEUE": "!=null"
        }
    }
},

{
    "kprobe:recv_Bchannel": {
        "description": "Receive data on a B channel.",
        "pre": {
            "bch": "!=null",
            "bch->rx_skb": "!=null",
            "bch->rx_skb->len": "!=null"
        }
    }
},



{
    "kprobe:bchannel_senddata": {
        "description": "Check oversize",
        "pre": {
            "skb->len": "<= 0"
        }
    }
},



{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kretprobe:mISDN_unregister_device": {
        "description": "Unregister a mISDN device.",
        "pre": {
            "dev": "!=null",
            "debug": "& DEBUG_CORE",
            "dev_name(&dev->dev)": "!=null",
            "dev->id": "!=null",
            "sysfs_remove_link(&dev->dev.kobj, \"device\")": "success"
        }
    }
},
{
    "kprobe:mISDN_unregister_device": {
        "description": "Unregister a mISDN device.",
        "pre": {
            "dev": "!=null",
            "dev_name(&dev->dev)": "!=null",
            "dev->id": "!=null",
            "debug & DEBUG_CORE": "!=null",
            "sysfs_remove_link(&dev->dev.kobj, \"device\")": "!=null"
        }
    }
},
{
    "kretprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own \"apm get power status\" function.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own \"apm get power status\" function.",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and take appropriate action.",
        "pre": {
            "event": "in [APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and take appropriate action.",
        "pre": {
            "event": "in [APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kretprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel.",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel.",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kretprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kretprobe:amp->gpio_dump(amp, m);break;case '\\n':/* end of settings string, do nothing `": {
        "description": "This function is used to dump the GPIO settings.",
        "pre": {
            "amp": "!=null",
            "m": "!=null",
            "file": "!=null",
            "data": "!=null",
            "len": ">=0",
            "ppos": ">=0",
            "dev": "!=null",
            "i": ">=0",
            "err": ">=0",
            "c": "!=null"
        }
    }
},
{
    "kprobe:amp->gpio_dump": {
        "description": "Dump GPIO settings",
        "pre": {
            "amp": "!=null",
            "m": "!=null"
        }
    }
},
{
    "kretprobe:nsc_gpio_write": {
        "description": "Common file-ops routines for both scx200_gpio and pc87360_gpio.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null"
        }
    },
    "kretprobe:nsc_gpio_read": {
        "description": "Common file-ops routines for both scx200_gpio and pc87360_gpio.",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(nsc_gpio_write);EXPORT_SYMBOL(nsc_gpio_read)": {
        "description": "common file-ops routines for both scx200_gpio and pc87360_gpio",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": "!=null",
            "ppos": "!=null",
            "m": "!=null",
            "value": "!=null",
            "amp": "!=null",
            "amp->gpio_get(m)": "!=null",
            "put_user(value ? '1' : '0', buf)": "!=EFAULT"
        }
    }
},



{
    "kprobe:try_to_generate_entropy": {
        "description": "Wait for the input pool to be seeded and thus guaranteed to supply cryptographically secure random numbers.",
        "pre": {
            "wait_for_random_bytes": "!=null",
            "entropy_collector": "true"
        }
    }
},
{
    "kretprobe:rng_is_initialized": {
        "description": "Check if the input pool has been seeded.",
        "pre": {},
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:rng_is_initialized": {
        "description": "Check if the input pool has been seeded.",
        "pre": {
            "pool": "seeded"
        }
    }
},
{
    "kretprobe:u32 rand = get_random_u32();u64 mult;": {
        "description": "This function is technically undefined for ceil == 0, and in fact for the non-underscored constant version in the header, we build bug on that. But for the non-constant case, it's convenient to have that evaluate to being a straight call to get_random_u32(), so that get_random_u32_inclusive() can work over its whole range without undefined behavior.",
        "pre": {
            "ceil": "!=0"
        }
    }
},
{
    "kprobe:u32 rand = get_random_u32();u64 mult;": {
        "description": "This function is technically undefined for ceil == 0, and in fact for the non-underscored constant version in the header, we build bug on that. But for the non-constant case, it's convenient to have that evaluate to being a straight call to get_random_u32(), so that get_random_u32_inclusive() can work over its whole range without undefined behavior.",
        "pre": {
            "ceil": "!=0"
        }
    }
},
{
    "kretprobe:parse_trust_cpu": {
        "description": "Parses the trust_cpu argument and initializes the trust_cpu variable.",
        "pre": {
            "arg": "!=null"
        }
    }
},
{
    "kprobe:parse_trust_cpu": {
        "description": "Parses the trust_cpu argument and initializes the trust_cpu and trust_bootloader variables.",
        "pre": {
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer.",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer.",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kretprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type.",
        "pre": {
            "bridge": "!=null",
            "page_count": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type.",
        "pre": {
            "bridge": "!=null",
            "page_count": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:agp_copy_info": {
        "description": "Copy bridge state information",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:agp_copy_info": {
        "description": "Copy bridge state information",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT.",
        "pre": {
            "curr": "!=null",
            "pg_start": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT.",
        "pre": {
            "curr": "!=null",
            "pg_start": "!=null"
        }
    }
},
{
    "kretprobe:agp_collect_device_status": {
        "description": "Determine correct agp_cmd from various agp_stat's",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null",
            "bridge_agpstat": "!=null"
        }
    }
},
{
    "kprobe:agp_collect_device_status": {
        "description": "determine correct agp_cmd from various agp_stat's",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null",
            "bridge_agpstat": "!=null"
        }
    }
},
{
    "kretprobe:get_agp_version": {
        "description": "Exit early if already set by errata workarounds.",
        "pre": {
            "bridge->major_version": "== 0",
            "bridge->dev": "!= null",
            "bridge->capndx": "!= null",
            "&ncapid": "!= null"
        }
    }
},

{
    "kretprobe:agp_generic_enable": {
        "description": "Enable AGP and perform AGP version specific operations.",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null"
        }
    }
},
{
    "kprobe:return;bridge_agpstat |= AGPSTAT_AGP_ENABLE;/* Do AGP version specific frobbing.": {
        "description": "Enable AGP and perform AGP version specific operations.",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "!=null"
        }
    }
},
{
    "kretprobe:agp_generic_create_gatt_table": {
        "description": "Create a GATT table for the AGP bridge.",
        "pre": {
            "bridge->driver->size_type": "== LVL2_APER_SIZE",
            "return": "== -EINVAL",
            "table": "= NULL",
            "i": "= bridge->aperture_size_idx",
            "temp": "= bridge->current_size",
            "page_order": "= 0",
            "num_entries": "= 0",
            "bridge->driver->size_type": "!= FIXED_APER_SIZE"
        }
    }
},
{
    "kprobe:agp_generic_create_gatt_table": {
        "description": "Create a generic GATT table for AGP bridge",
        "pre": {
            "bridge->driver->size_type": "== LVL2_APER_SIZE",
            "return": "== -EINVAL",
            "table": "= NULL",
            "i": "= bridge->aperture_size_idx",
            "temp": "= bridge->current_size",
            "page_order": "= 0",
            "num_entries": "= 0",
            "bridge->driver->size_type": "!= FIXED_APER_SIZE"
        }
    }
},


{
    "kretprobe:agp_generic_insert_memory": {
        "description": "Insert AGP memory into the system.",
        "pre": {
            "mem": "!=null",
            "pg_start": "!=null",
            "type": "!=null",
            "bridge": "!=null",
            "bridge": "!=0",
            "mem->page_count": "==0",
            "bridge->current_size": "!=null",
            "bridge->driver->size_type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]",
            "bridge->driver->size_type == U8_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_8(bridge->current_size)->num_entries",
            "bridge->driver->size_type == U16_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_16(bridge->current_size)->num_entries",
            "bridge->driver->size_type == U32_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_32(bridge->current_size)->num_entries",
            "bridge->driver->size_type == FIXED_APER_SIZE": "bridge->current_size->num_entries == A_SIZE_FIX(bridge->current_size)->num_entries",
            "bridge->driver->size_type == LVL2_APER_SIZE": "The generic routines can't deal with 2 level gatt's"
        },
        "post": {
            "return": "-EINVAL",
            "default:num_entries": "0",
            "break": ""
        }
    }
},
{
    "kprobe:agp_generic_insert_memory": {
        "description": "Insert AGP memory into the generic AGP bridge.",
        "pre": {
            "mem": "!=null",
            "pg_start": "!=null",
            "type": "!=null",
            "bridge": "!=null",
            "bridge->current_size": "!=null",
            "bridge->driver->size_type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "!=null"
        }
    }
},
{
    "kretprobe:return -EINVAL;}/* AK: bogu should encode addresses > 4GB": {
        "description": "The generic routines know nothing of memory types",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "mem->bridge": "!=null",
            "mem->page_count": "!=0",
            "type": "==mem->type",
            "pg_start + mem->page_count": ">num_entries",
            "pg_start + mem->page_count": ">pg_start",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "!=0"
        }
    }
},
{
    "return -EINVAL;}/* AK: bogu should encode addresses > 4GB `": {
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "valid memory type",
            "bridge": "!=null",
            "mem->page_count": ">0",
            "type == mem->type": true,
            "pg_start + mem->page_count <= num_entries": true,
            "pg_start + mem->page_count > pg_start": true,
            "mask_type != 0": true
        }
    }
},
{
    "kretprobe:agp_return_size": {
        "description": "Allocates memory in the agp_return_size function.",
        "pre": {
            "agp_generic_alloc_user": { "page_count": "!=null", "type": "!=null" },
            "new": "!=null",
            "type": "!=0",
            "scratch_pages": "!=null",
            "agp_create_memory": { "scratch_pages": "!=null" },
            "new": "==null",
            "bridge->driver->agp_alloc_pages": "!=null",
            "bridge->driver->agp_alloc_page": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:agp_return_size": {
        "description": "Allocate memory using the agp_return_size function.",
        "pre": {
            "page_count": ">= 0",
            "type": ">= 0"
        }
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0",
            "page": "!=null",
            "i": ">=0",
            "ret": "==-ENOMEM"
        },
        "post": {
            "page": "!=NULL",
            "i": "<num_pages",
            "ret": "==0"
        }
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0",
            "page": "!=null",
            "i": ">=0",
            "ret": "==-ENOMEM"
        },
        "post": {
            "page": "!=NULL",
            "i": "<num_pages",
            "ret": "==0"
        }
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocate pages for AGP memory.",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">=0"
        }
    }
},
{
    "kretprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "pre": {
            "bridge": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kretprobe:agp_generic_mask_memory": {
        "description": "Mask the memory address based on the bridge's driver masks.",
        "pre": {
            "bridge": "!=null",
            "addr": "!=null",
            "type": "int"
        }
    }
},
{
    "kprobe:agp_generic_mask_memory": {
        "description": "Mask the memory address based on the bridge's driver masks.",
        "pre": {
            "bridge": "!=null",
            "addr": "!=null",
            "type": "int"
        }
    }
},
{
    "kretprobe:pci_write_config_word": {
        "description": "Set gart pointer",
        "pre": {
            "agp_bridge->dev": "!=null",
            "agp_bridge->capndx+AGPAPSIZE": "!=null",
            "current_size->size_value": "!=null"
        }
    }
},
{
    "kprobe:pci_write_config_word": {
        "description": "Write a 16-bit word to a configuration register of a PCI device.",
        "pre": {
            "agp_bridge->dev": "!=null",
            "agp_bridge->capndx+AGPAPSIZE": "unknown",
            "current_size->size_value": "unknown"
        }
    }
},
{
    "kretprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:agp_backend_release": {
        "description": "Release the lock on the AGP backend.",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:agp_backend_release": {
        "description": "Release the lock on the agp backend.",
        "pre": {
            "bridge": "!=null"
        }
    }
},




{
    "kretprobe:intel_gmch_enable_gtt": {
        "description": "Enable the GTT for Intel GMCH.",
        "pre": {
            "INTEL_GTT_GEN": ">= 3",
            "writel(0, intel_private.registers+GFX_FLSH_CNTL)": true,
            "reg": "intel_private.registers+I810_PGETBL_CTL",
            "writel(intel_private.PGETBL_save, reg)": true,
            "HAS_PGTBL_EN && (readl(reg) & I810_PGETBL_ENABLED) == 0": true
        }
    }
},
{
    "kprobe:intel_gmch_enable_gtt": {
        "description": "Enable the GTT for Intel GMCH.",
        "pre": {
            "INTEL_GTT_GEN": ">= 3",
            "reg": "!=null",
            "gmch_ctrl": "!=null",
            "intel_private.bridge_dev": "!=null",
            "I830_GMCH_CTRL": "!=null",
            "I830_GMCH_ENABLED": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},


{
    "kretprobe:intel_gmch_probe": {
        "description": "Probe the Intel GMCH chipset.",
        "pre": {
            "bridge_pdev": "!=null",
            "gpu_pdev": "!=null",
            "bridge": "!=null",
            "intel_gtt_chipsets[i].name": "!=null",
            "gpu_pdev->device": "intel_gtt_chipsets[i].gmch_chip_id",
            "intel_private.pcidev": "pci_dev_get(gpu_pdev)",
            "intel_private.driver": "intel_gtt_chipsets[i].gtt_driver",
            "intel_private.driver": "!=null",
            "INTEL_GTT_GEN": "> 1",
            "bridge->driver": "&intel_fake_agp_driver",
            "bridge->dev_private_data": "&intel_private",
            "bridge->dev": "bridge_pdev"
        }
    }
},
{
    "kprobe:intel_gmch_probe": {
        "description": "Probe the Intel GMCH chipset.",
        "pre": {
            "bridge_pdev": "!=null",
            "gpu_pdev": "!=null",
            "bridge": "!=null",
            "intel_gtt_chipsets[i].name": "!=null",
            "gpu_pdev->device": "intel_gtt_chipsets[i].gmch_chip_id",
            "intel_private.pcidev": "pci_dev_get(gpu_pdev)",
            "intel_private.driver": "intel_gtt_chipsets[i].gtt_driver",
            "intel_private.driver": "!=null",
            "INTEL_GTT_GEN": "> 1",
            "bridge->driver": "&intel_fake_agp_driver",
            "bridge->dev_private_data": "&intel_private",
            "bridge->dev": "bridge_pdev"
        }
    }
},
{
    "kretprobe:kobject_put": {
        "description": "Decrement the reference count of the kernel object.",
        "pre": {
            "kobj": "!=null"
        }
    },
    "kretprobe:unregister_chrdev": {
        "description": "Unregister a character device.",
        "pre": {}
    },
    "for_loop": {
        "description": "Iterate over 'num_nodes' variable.",
        "pre": {
            "i": ">=0",
            "i": "<num_nodes"
        }
    }
},
{
    "kprobe:kobject_put": {
        "description": "Decrement the reference count of the kobject.",
        "pre": {
            "unit->cdev->kobj": "!=null"
        }
    },
    "kprobe:unregister_chrdev": {
        "description": "Unregister a character device.",
        "pre": {}
    },
    "for_loop": {
        "description": "Loop over the range [0, num_nodes) with variable i.",
        "pre": {
            "i": ">=0",
            "i": "<num_nodes"
        }
    }
},
{
    "kretprobe:xillybus_isr": {
        "description": "The xillybus_isr function assumes the interrupt is allocated exclusively to it, which is the natural case for MSI and several other hardware-oriented interrupts. Sharing is not allowed.",
        "pre": {
            "irq": ">= 0",
            "data": "!= null"
        }
    }
},
{
    "kprobe:xillybus_isr": {
        "description": "Interrupt service routine for the xillybus device.",
        "pre": {
            "irq": "!=null",
            "data": "!=null"
        }
    }
},


{
    "kretprobe:flush_workqueue(xillybus_wq);}EXPORT_SYMBOL(xillybus_endpoint_remove": {
        "description": "Remove an xillybus endpoint and perform necessary cleanup operations.",
        "pre": {
            "endpoint": "!=null",
            "endpoint->dev": "!=null"
        }
    }
},

{
    "kretprobe:ipmi_addr_src_to_str": {
        "description": "Converts the source address to a string representation.",
        "pre": {
            "src": "!=null",
            "src": "enum ipmi_addr_src",
            "src": "< SI_LAST => src = 0"
        }
    }
},
{
    "kprobe:return addr_src_to_str[src];}EXPORT_SYMBOL(ipmi_addr_src_to_str": {
        "description": "Helper function to convert ipmi_addr_src to string.",
        "pre": {
            "src": "!=null",
            "src": "enum ipmi_addr_src",
            "src": "< SI_LAST => src = 0"
        }
    }
},
{
    "kretprobe:ipmi_init_msghandler": {
        "description": "Initialize the IPMI message handler.",
        "pre": {
            "rv": "!=null"
        }
    },
    "kretprobe:mutex_lock": {
        "description": "Lock the smi_watchers_mutex.",
        "pre": {}
    },
    "kretprobe:list_add": {
        "description": "Add the watcher to the smi_watchers list.",
        "pre": {
            "watcher": "!=null",
            "link": "!=null",
            "smi_watchers": "!=null"
        }
    },
    "kretprobe:srcu_read_lock": {
        "description": "Acquire the read lock on the ipmi_interfaces_srcu.",
        "pre": {
            "index": "!=null"
        }
    },
    "kretprobe:list_for_each_entry_rcu": {
        "description": "Iterate over the ipmi_interfaces list.",
        "pre": {
            "intf": "!=null",
            "link": "!=null",
            "lockdep_is_held": "(&smi_watchers_mutex)"
        }
    }
},
{
    "kprobe:ipmi_init_msghandler": {
        "description": "Initialize the IPMI message handler.",
        "pre": {
            "rv": "=0",
            "watcher": "!=null",
            "intf": "!=null",
            "index": ">=0",
            "lockdep_is_held(&smi_watchers_mutex)": "=true"
        }
    }
},
{
    "kretprobe:ipmi_create_user": {
        "description": "Create an IPMI user.",
        "pre": {
            "if_num": "!=null",
            "handler": "==null",
            "handler_data": "!=null",
            "user": "!=null"
        }
    }
},
{
    "kprobe:ipmi_create_user": {
        "description": "Create a new IPMI user.",
        "pre": {
            "if_num": "!=null",
            "handler": "==null",
            "handler_data": "!=null",
            "user": "!=null"
        }
    }
},
{
    "kretprobe:ipmi_get_smi_info": {
        "description": "Get SMI information for the specified interface.",
        "pre": {
            "if_num": "!=null",
            "data": "!=null"
        },
        "post": {
            "rv": "== -EINVAL",
            "intf->handlers->get_smi_info": "== null => rv = -ENOTTY",
            "intf->handlers->get_smi_info(intf->send_info, data)": "rv = return value"
        }
    }
},
{
    "kprobe:return -EINVAL;found:if (!intf->handlers->get_smi_info)rv = -ENOTTY;elserv = intf->handlers->get_smi_info(intf->send_info, data);srcu_read_unlock(&ipmi_interfaces_srcu, index);return rv;}EXPORT_SYMBOL(ipmi_get_smi_info": {
        "description": "Helper function to get SMI information.",
        "pre": {
            "if_num": "!=null",
            "data": "!=null"
        }
    }
},


{
    "kretprobe:goto out;/* Deliver any queued events. */": {
        "description": "Deliver any queued events.",
        "pre": {
            "user": "!=null",
            "val": "bool",
            "flags": "unsigned long",
            "intf": "struct ipmi_smi",
            "msg": "struct ipmi_recv_msg",
            "msg2": "struct ipmi_recv_msg",
            "msgs": "struct list_head",
            "index": "int"
        }
    }
},
{
    "kprobe:goto out;/* Deliver any queued events. */": {
        "description": "Deliver any queued events.",
        "pre": {
            "user": "!=null",
            "val": "bool",
            "flags": "unsigned long",
            "intf": "struct ipmi_smi",
            "msg": "struct ipmi_recv_msg",
            "msg2": "struct ipmi_recv_msg",
            "msgs": "struct list_head",
            "index": "int",
            "acquire_ipmi_user": "function",
            "return": "-ENODEV",
            "INIT_LIST_HEAD": "function",
            "spin_lock_irqsave": "function",
            "atomic_inc_return": "function",
            "need_waiter": "function",
            "atomic_dec": "function",
            "intf->delivering_events": "bool"
        }
    }
},
{
    "kretprobe:is_cmd_rcvr_exclusive": {
        "description": "Check if the command receiver is exclusive.",
        "pre": {
            "intf": "!=null",
            "netfn": "!=null",
            "cmd": "!=null",
            "chans": "!=null"
        }
    }
},
{
    "kprobe:is_cmd_rcvr_exclusive": {
        "description": "Check if the command receiver is exclusive.",
        "pre": {
            "intf": "!=null",
            "netfn": "!=null",
            "cmd": "!=null",
            "chans": "!=null"
        }
    }
},


{
    "kretprobe:device_remove_file": {
        "description": "Remove a file associated with the device.",
        "pre": {
            "intf->si_dev": "!=null",
            "&intf->nr_msgs_devattr": "!=null",
            "&intf->nr_users_devattr": "!=null"
        }
    }
},
{
    "kprobe:device_remove_file": {
        "description": "Call all the watcher interfaces to tell them that an interface is going away.",
        "pre": {
            "intf": "!=null",
            "intf->si_dev": "!=null",
            "&intf->nr_msgs_devattr": "!=null",
            "&intf->nr_users_devattr": "!=null"
        }
    }
},




{
    "kretprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize a list head.",
        "pre": {
            "list": "!=null"
        }
    },
    "kretprobe:list_splice_init_rcu": {
        "description": "Splice the list 'list' into 'head' and initialize 'list'.",
        "pre": {
            "list": "!=null",
            "head": "!=null",
            "synchronize_rcu": "!=null"
        }
    },
    "kretprobe:mutex_unlock": {
        "description": "Unlock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of given type, safe against removal of list entry.",
        "pre": {
            "rcvr": "!=null",
            "rcvr2": "!=null",
            "list": "!=null",
            "link": "!=null"
        }
    },
    "kretprobe:kfree": {
        "description": "Free a memory region.",
        "pre": {
            "rcvr": "!=null"
        }
    },
    "kretprobe:for": {
        "description": "Loop over a range of values.",
        "pre": {
            "i": ">=0",
            "i": "<IPMI_IPMB_NUM_SEQ"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize a list head.",
        "pre": {
            "list": "!=null"
        }
    },
    "kprobe:list_splice_init_rcu": {
        "description": "Splice the list 'list' into 'head' and initialize 'list'.",
        "pre": {
            "list": "!=null",
            "head": "!=null"
        }
    },
    "kprobe:mutex_unlock": {
        "description": "Unlock a mutex.",
        "pre": {
            "mutex": "!=null"
        }
    },
    "kprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of given type, safe against removal of list entry.",
        "pre": {
            "entry": "!=null",
            "list": "!=null"
        }
    },
    "kprobe:kfree": {
        "description": "Free a memory region.",
        "pre": {
            "ptr": "!=null"
        }
    },
    "kprobe:IPMI_IPMB_NUM_SEQ": {
        "description": "Number of IPMB sequences.",
        "pre": {
            "i": ">= 0",
            "i": "< IPMI_IPMB_NUM_SEQ"
        }
    }
},
{
    "kretprobe:platform_device_alloc": {
        "description": "Allocate a platform device with the given name and instance number.",
        "pre": {
            "name": "!=null",
            "inst": "!=null"
        }
    }
},
{
    "kprobe:platform_device_alloc": {
        "description": "Allocate a platform device with the given name and instance.",
        "pre": {
            "name": "!=null",
            "inst": "!=null"
        }
    }
},
{
    "kretprobe:tpm_dev->io_lpcpd": {
        "description": "Assign the value returned by devm_gpiod_get_optional to tpm_dev->io_lpcpd.",
        "pre": {
            "dev": "!=null",
            "tpm_dev": "!=null",
            "tpm_dev->io_lpcpd": "!=null",
            "tpm_dev->io_lpcpd": "GPIOD_OUT_HIGH"
        }
    },
    "kretprobe:ret": {
        "description": "Assign the value returned by PTR_ERR_OR_ZERO to ret.",
        "pre": {
            "ret": "!=null"
        }
    },
    "kretprobe:if (ret)": {
        "description": "Check if ret is non-zero.",
        "pre": {
            "ret": "!=0"
        }
    }
},
{
    "kprobe:tpm_dev->io_lpcpd = devm_gpiod_get_optional": {
        "description": "Get LPCPD GPIO. If lpcpd pin is not specified. This is not an issue as power management can be also managed by TPM specific commands.",
        "pre": {
            "phy_id": "!=null",
            "ops": "!=null",
            "dev": "!=null",
            "irq": "!=null"
        }
    }
},
{
    "kretprobe:bbc_i2c_readb": {
        "description": "Read a byte from the I2C bus.",
        "pre": {
            "client": "!=null",
            "byte": "!=null",
            "off": "!=null",
            "bp": "!=null",
            "address": "!=null",
            "status": "!=null",
            "ret": "-1",
            "bp->i2c_bussel_reg": "==null or !=null",
            "client->bus": "!=null",
            "bp->i2c_control_regs": "!=null",
            "I2C_PCF_START": "!=null",
            "wait_for_pin(bp, &status)": "true",
            "off": "!=null",
            "(wait_for_pin(bp, &status) || (status & I2C_PCF_LRB) != 0)": "false",
            "I2C_PCF_STOP": "!=null"
        }
    }
},
{
    "writeb": {
        "description": "Write a byte to a specific address",
        "pre": {
            "address": "!=null",
            "bp->i2c_control_regs + 0x1": "valid_memory_address",
            "I2C_PCF_START": "unknown",
            "bp->i2c_control_regs + 0x0": "valid_memory_address",
            "wait_for_pin(bp, &status)": "unknown",
            "status": "valid_memory_address"
        }
    }
},


{
    "kretprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels.",
        "pre": {
            "channels": "!=null",
            "operations_pending": ">0"
        }
    }
},
{
    "kprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels.",
        "pre": {
            "channels": "!=null"
        }
    }
},
{
    "kretprobe:dmaengine_put": {
        "description": "Let DMA drivers be removed when ref_count == 0",
        "pre": {
            "ref_count": "== 0"
        }
    }
},
{
    "kprobe:dmaengine_put": {
        "description": "let DMA drivers be removed when ref_count == 0",
        "pre": {
            "ref_count": "== 0"
        }
    }
},

{
    "kprobe:dma_async_device_register": {
        "description": "Register a DMA device asynchronously.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found",
        "pre": {
            "device": "!=null"
        }
    }
},

{
    "kprobe:iowrite32": {
        "description": "Write a 32-bit value to a memory address.",
        "pre": {
            "value": "!=null",
            "address": "!=null"
        }
    },
    "kprobe:mcf_edma_remove": {
        "description": "Remove the Freescale eDMA engine.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kretprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "pre": {
            "pdev": "!=null",
            "irq_num": "!=null"
        }
    }
},
{
    "kretprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "!=null"
        }
    }
},
{
    "kprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "!=null"
        }
    }
},
{
    "kretprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        }
    }
},
{
    "kretprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "pre": {
            "chan": "!=null",
            "arg": "!=null",
            "chan->device": "!=null",
            "chan->device->device_alloc_chan_resources": "!=null",
            "shdma_alloc_chan_resources": "!=null",
            "chan->device->device_alloc_chan_resources != shdma_alloc_chan_resources": "true",
            "schan": "!=null",
            "sdev": "!=null",
            "schan->slave_id": "generated by set_slave function from slave ID passed in from xlate",
            "slave_id": "directly passed into filter function by the driver"
        }
    }
},
{
    "kprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "pre": {
            "chan": "!=null",
            "arg": "!=null",
            "chan->device->device_alloc_chan_resources": "==shdma_alloc_chan_resources",
            "schan": "=to_shdma_chan(chan)",
            "sdev": "=to_shdma_dev(chan)",
            "schan->slave_id": "=set_slave(sdev, slave_id)"
        }
    }
},


{
    "kretprobe:schan->dma_chan.device = &sdev->dma_dev;dma_cookie_init(&schan->dma_chan);schan->dev = sdev->dma_dev.dev;schan->id = id;if (!schan->max_xfer_len)schan->max_xfer_len = PAGE_SIZE;spin_lock_init(&schan->chan_lock);/* Init descripter manage list": {
        "description": "Initialize the descriptor management list for schan.",
        "pre": {
            "sdev": "!=null",
            "schan": "!=null",
            "id": "int",
            "schan->dma_chan.device": "&sdev->dma_dev",
            "schan->dev": "sdev->dma_dev.dev",
            "schan->max_xfer_len": "PAGE_SIZE"
        }
    }
},
{
    "shdma_chan_probe": {
        "description": "Probe function for shdma_chan",
        "pre": {
            "sdev": {
                "dma_dev": {
                    "dev": "!=null"
                }
            },
            "schan": {
                "dma_chan": {
                    "device": "!=null"
                },
                "dev": "!=null",
                "max_xfer_len": "!=null"
            }
        }
    }
},
{
    "kretprobe:if (!sdev->ops || !sdev->desc_size || !sdev->ops->embedded_desc || !sdev->ops->start_xfer || !sdev->ops->setup_xfer || !sdev->ops->set_slave || !sdev->ops->desc_setup || !sdev->ops->slave_addr || !sdev->ops->channel_busy || !sdev->ops->halt_channel || !sdev->ops->desc_completed)": {
        "description": "Check if any of the required callbacks or variables are missing or invalid.",
        "pre": {
            "sdev->ops": "==null",
            "sdev->desc_size": "==null",
            "sdev->ops->embedded_desc": "==null",
            "sdev->ops->start_xfer": "==null",
            "sdev->ops->setup_xfer": "==null",
            "sdev->ops->set_slave": "==null",
            "sdev->ops->desc_setup": "==null",
            "sdev->ops->slave_addr": "==null",
            "sdev->ops->channel_busy": "==null",
            "sdev->ops->halt_channel": "==null",
            "sdev->ops->desc_completed": "==null"
        },
        "post": {
            "return": "-EINVAL"
        }
    },
    "kretprobe:sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL); if (!sdev->schan)": {
        "description": "Allocate memory for sdev->schan and check if the allocation was successful.",
        "pre": {
            "chan_num": "!=null"
        },
        "post": {
            "sdev->schan": "==null",
            "return": "-ENOMEM"
        }
    },
    "kretprobe:INIT_LIST_HEAD(&dma_dev->channels)": {
        "description": "Initialize the list head of dma_dev->channels.",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:if (!sdev->ops || !sdev->desc_size || !sdev->ops->embedded_desc || !sdev->ops->start_xfer || !sdev->ops->setup_xfer || !sdev->ops->set_slave || !sdev->ops->desc_setup || !sdev->ops->slave_addr || !sdev->ops->channel_busy || !sdev->ops->halt_channel || !sdev->ops->desc_completed)": {
        "description": "Check if any of the required callbacks or variables are missing or invalid.",
        "pre": {
            "sdev->ops": "==null",
            "sdev->desc_size": "==null",
            "sdev->ops->embedded_desc": "==null",
            "sdev->ops->start_xfer": "==null",
            "sdev->ops->setup_xfer": "==null",
            "sdev->ops->set_slave": "==null",
            "sdev->ops->desc_setup": "==null",
            "sdev->ops->slave_addr": "==null",
            "sdev->ops->channel_busy": "==null",
            "sdev->ops->halt_channel": "==null",
            "sdev->ops->desc_completed": "==null"
        },
        "post": {
            "return": "-EINVAL"
        }
    },
    "kprobe:sdev->schan = kcalloc(chan_num, sizeof(*sdev->schan), GFP_KERNEL); if (!sdev->schan)": {
        "description": "Allocate memory for sdev->schan and check if the allocation was successful.",
        "pre": {
            "chan_num": "!=null"
        },
        "post": {
            "sdev->schan": "==null",
            "return": "-ENOMEM"
        }
    },
    "kprobe:INIT_LIST_HEAD(&dma_dev->channels)": {
        "description": "Initialize the list head of dma_dev->channels."
    }
},
{
    "kretprobe:pci_match_id": {
        "description": "See if a PCI device matches a given pci_id table",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pci_match_id": {
        "description": "See if a PCI device matches a given pci_id table",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__pci_register_driver": {
        "description": "Register a new PCI driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:__pci_register_driver": {
        "description": "Register a new PCI driver",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        }
    }
},
{
    "kretprobe:pci_unregister_driver": {
        "description": "Unregister a PCI driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pci_unregister_driver": {
        "description": "Unregister a PCI driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pm_runtime_put_sync": {
        "description": "If the device is still on, set the power state as 'unknown', since it might change by the next time we load the driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pm_runtime_put_sync": {
        "description": "Decrease the runtime PM usage counter for a device and wait for it to reach zero.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:driver_register": {
        "description": "Register a PCI driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},



{
    "kretprobe:if (res->flags & IORESOURCE_ROM_SHADOW)return 0;root = pci_find_parent_resource(dev, res);if (!root)": {
        "description": "Claim a PCI resource for a device.",
        "pre": {
            "dev": "!=null",
            "resource": "!=null",
            "res->flags": "& IORESOURCE_UNSET == 0",
            "root": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:pci_claim_resource": {
        "description": "Claim a PCI resource for a device.",
        "pre": {
            "dev": "!=null",
            "resource": "!=null",
            "res.flags": "& IORESOURCE_UNSET == 0"
        }
    }
},
{
    "kretprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "flags": "IORESOURCE_PREFETCH | IORESOURCE_MEM_64",
            "pcibios_align_resource": "!=null",
            "dev": "!=null"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "flags": "IORESOURCE_PREFETCH | IORESOURCE_MEM_64",
            "pcibios_align_resource": "!=null",
            "dev": "!=null"
        },
        "post": {
            "ret": "0"
        }
    }
},
{
    "kretprobe:pci_resize_resource": {
        "description": "Resize a PCI resource based on the provided parameters.",
        "pre": {
            "dev": "!=null",
            "resno": "is_valid_resno",
            "size": "is_positive_integer",
            "host": "!=null",
            "host->preserve_config": "is_boolean"
        },
        "post": {
            "if host->preserve_config == true": {
                "return": "-ENOTSUPP"
            },
            "else": {
                "return": "is_integer"
            }
        }
    }
},
{
    "kprobe:host = pci_find_host_bridge(dev->bus);if (host->preserve_config)return -ENOTSUPP;/* Make sure the resource isn't assigned before resizing it.": {
        "description": "Check if we must preserve the firmware's resource assignment",
        "pre": {
            "dev": "!=null",
            "resno": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": "!=null",
            "available_buses": "!=null",
            "pass": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": "!=null",
            "available_buses": "!=null",
            "pass": "in [0, 1]"
        }
    }
},
{
    "kretprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_read_dev_vendor_id": {
        "description": "Read the device and vendor ID from the PCI bus.",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "l": "!=null",
            "timeout": "!=null",
            "bridge": "!=null",
            "bridge.vendor": "== PCI_VENDOR_ID_IDT",
            "bridge.device": "== 0x80b5"
        }
    }
},
{
    "kprobe:pci_bus_read_dev_vendor_id": {
        "description": "Read the device and vendor ID of a PCI device on a specific bus.",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "l": "!=null",
            "timeout": "!=null",
            "bridge": "!=null",
            "bridge.vendor": "== PCI_VENDOR_ID_IDT",
            "bridge.device": "== 0x80b5"
        }
    }
},
{
    "kretprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on a bus for devices",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "devfn": "must have zero function"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on a bus for devices",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "devfn": "must have zero function"
        }
    }
},


{
    "kretprobe:pci_read_vpd_any": {
        "description": "Read the VPD (Vital Product Data) of a PCI device at the specified offset.",
        "pre": {
            "dev": "!=null",
            "off": "!=null",
            "size": "==1",
            "header": "!=null",
            "header[0]": "in [0x00, 0xff]",
            "header[0] & PCI_VPD_LRDT": "!=0"
        }
    }
},
{
    "kprobe:pci_read_vpd_any": {
        "description": "Read VPD (Vital Product Data) from a PCI device.",
        "pre": {
            "dev": "!=null",
            "off": "!=null",
            "header": "!=null",
            "header[0]": "in [0x00, 0xff]",
            "header[0] & PCI_VPD_LRDT": "==0",
            "pci_read_vpd_any(dev, off, 1, header)": "==1",
            "pci_read_vpd_any(dev, off + 1, 2, &header[1])": "!=2"
        }
    }
},
{
    "kretprobe:while": {
        "description": "Loop condition for the while loop",
        "pre": {
            "i": ">= 0",
            "len": ">= i + PCI_VPD_LRDT_TAG_SIZE",
            "buf[i]": "& PCI_VPD_LRDT"
        }
    }
},
{
    "kprobe:while": {
        "description": "Loop while the condition (i + PCI_VPD_LRDT_TAG_SIZE <= len && buf[i] & PCI_VPD_LRDT) is true.",
        "pre": {
            "i": ">=0",
            "len": ">=0",
            "buf": "!=null",
            "buf[i]": "& PCI_VPD_LRDT != 0"
        }
    }
},
{
    "kretprobe:vga_remove_vgacon": {
        "description": "Deactivate VGA console by unbinding and unregistering vgacon if pdev is the default VGA device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:vga_remove_vgacon": {
        "description": "Deactivate VGA console by unbinding and unregistering vgacon if pdev is the default VGA device.",
        "pre": {
            "pdev": "!=null"
        }
    }
},




{
    "kretprobe:vga_set_legacy_decoding": {
        "description": "Update the device decodes and counter",
        "pre": {
            "pdev": "!=null",
            "decodes": "!=null",
            "userspace": "!=null",
            "vgadev": "!=null",
            "flags": "!=null",
            "decodes": "&= VGA_RSRC_LEGACY_MASK",
            "vga_lock": "acquired",
            "vgadev_find(pdev)": "!=null",
            "userspace && vgadev->set_decode": "true"
        }
    }
},
{
    "kprobe:vga_set_legacy_decoding": {
        "description": "Update the device decodes + counter.",
        "pre": {
            "pdev": "!=null",
            "decodes": "!=null",
            "userspace": "!=null",
            "vgadev": "!=null",
            "vgadev->set_decode": "!=null",
            "userspace && vgadev->set_decode": "false"
        }
    }
},
{
    "kretprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client.",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        }
    }
},
{
    "kprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client.",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource from a parent bus",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "type_mask": "!=null",
            "alignf": "!=null",
            "alignf_data": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_alloc_resource": {
        "description": "Allocate a resource from a parent bus",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": "!=null",
            "align": "!=null",
            "min": "!=null",
            "type_mask": "!=null",
            "alignf": "!=null",
            "alignf_data": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_map_rom": {
        "description": "Map a PCI ROM to kernel space",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:pci_map_rom": {
        "description": "Map a PCI ROM to kernel space",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space.",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_bus": {
        "description": "Locate PCI bus from a given domain and bus number",
        "pre": {
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kprobe:pci_find_bus": {
        "description": "Locate PCI bus from a given domain and bus number.",
        "pre": {
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus.",
        "pre": {
            "bus": "!=null",
            "domain": "!=null",
            "busnr": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_slot": {
        "description": "Locate PCI device for a given PCI slot",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:pci_get_slot": {
        "description": "Locate PCI device for a given PCI slot",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bu and slot.",
        "pre": {
            "domain": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bu and slot.",
        "pre": {
            "domain": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendor, subvendor, device, and subdevice ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "ss_vendor": "!=null",
            "ss_device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendor, subvendor, device, and subdevice ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "ss_vendor": "!=null",
            "ss_device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendor and device ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendor and device ID.",
        "pre": {
            "vendor": "!=null",
            "device": "!=null",
            "from": "in [null, valid_pci_dev]"
        }
    }
},
{
    "kretprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class.",
        "pre": {
            "class": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class.",
        "pre": {
            "class": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not.",
        "pre": {
            "ids": "!=null"
        }
    }
},
{
    "kprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not.",
        "pre": {
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null",
            "thread_fn": "!=null",
            "dev_id": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null",
            "thread_fn": "!=null",
            "dev_id": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq.",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq.",
        "pre": {
            "dev": "!=null",
            "nr": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:pci_info": {
        "description": "PCI info function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    },
    "kretprobe:pci_write_config_dword": {
        "description": "PCI write config dword function",
        "pre": {
            "bridge": "!=null",
            "region": "!=null",
            "res": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    },
    "kretprobe:pcibios_resource_to_bus": {
        "description": "PCIBIOS resource to bus function",
        "pre": {
            "bridge": "!=null",
            "region": "!=null",
            "res": "!=null",
            "bus": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->busn_res": "!=null",
            "res->flags": "& IORESOURCE_IO != 0"
        }
    }
},
{
    "kprobe:pci_info": {
        "description": "PCI info function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    },
    "kprobe:pci_write_config_dword": {
        "description": "PCI write config dword function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    },
    "kprobe:pcibios_resource_to_bus": {
        "description": "PCIBIOS resource to bus function",
        "pre": {
            "bridge": "!=null",
            "res": "!=null",
            "region": "!=null",
            "bus": "!=null",
            "busn_res": "!=null",
            "bridge->bus": "!=null",
            "bridge->bus->resource[0]": "!=null",
            "bridge->bus->resource[1]": "!=null",
            "bridge->bus->resource[1]->flags": "& IORESOURCE_IO"
        }
    }
},
{
    "if (pci_is_root_bus(bus))": {
        "description": "Check if the given bus is the root bus.",
        "pre": {
            "bus": "!=null",
            "bus->devices": "!=null",
            "bus->devices->bus_list": "!=null",
            "bus->devices->bus_list->next": "!=null",
            "bus->devices->bus_list->next->bus": "==null"
        }
    }
},
{
    "kprobe:pci_is_root_bus": {
        "description": "Check if the given bus is the root bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:if (ret)*val = 0;return ret;}/* * For Functions that do not implement the Slot Capabilitie * Slot Statu and Slot Control register these spaces must * be hardwired to 0b, with the exception of the Presence Detect * State bit in the Slot Status register of Downstream Port * which must be hardwired to 1b.  (PCIe Base Spec 3.0, sec 7.8)": {
        "description": "Conditions for the given function",
        "pre": {
            "ret": "==0",
            "*val": "==0"
        }
    }
},
{
    "kprobe:pci_read_config_word": {
        "description": "Read a 16-bit word from the PCI configuration space at the specified offset.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "=0"
        }
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Read a 32-bit capability register from a PCI Express device.",
        "pre": {
            "dev": "!=null",
            "pos": "is a multiple of 4",
            "val": "=0"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Read a 32-bit capability register from a PCI Express device.",
        "pre": {
            "dev": "!=null",
            "pos": "is a multiple of 4",
            "val": "=0",
            "ret": "!=null",
            "pci_capability_reg_implemented(dev, pos)": "true",
            "pci_read_config_dword(dev, pci_pcie_cap(dev) + po val)": "succeeds"
        }
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Read a dword from the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        },
        "post": {
            "val": "= 0 if pci_read_config_dword() fails"
        }
    },
    "kretprobe:pcie_capability_write_word": {
        "description": "Write a word to the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        },
        "post": {
            "return": "= 0"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Read a dword from the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        }
    },
    "kprobe:pcie_capability_write_word": {
        "description": "Write a word to the PCI configuration space at the specified position.",
        "pre": {
            "dev": "!=null",
            "pos": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "dev": "!=null",
            "cap": "!=null",
            "cap": "in [PCI_CAP_ID_PM, PCI_CAP_ID_AGP, PCI_CAP_ID_VPD, PCI_CAP_ID_SLOTID, PCI_CAP_ID_MSI, PCI_CAP_ID_CHSWP, PCI_CAP_ID_PCIX, PCI_CAP_ID_EXP]"
        }
    }
},
{
    "kprobe:pci_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "dev": "!=null",
            "cap": "!=null",
            "cap": "in [PCI_CAP_ID_PM, PCI_CAP_ID_AGP, PCI_CAP_ID_VPD, PCI_CAP_ID_SLOTID, PCI_CAP_ID_MSI, PCI_CAP_ID_CHSWP, PCI_CAP_ID_PCIX, PCI_CAP_ID_EXP]"
        }
    }
},
{
    "kretprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities",
        "pre": {
            "bus": "!=null",
            "devfn": "!=null",
            "cap": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_parent_resource": {
        "description": "Return resource region of parent bus of given region.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_find_parent_resource": {
        "description": "Return the resource region of the parent bus of the given region.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_resource": {
        "description": "Return matching PCI device resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_find_resource": {
        "description": "Return matching PCI device resource",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending.",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:pci_reenable_device": {
        "description": "Resume abandoned device",
        "pre": {
            "dev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kprobe:pci_reenable_device": {
        "description": "Resume abandoned device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space. Initialize the PCI device before it's used by a driver. Ask low-level code to enable Memory resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space",
        "pre": {
            "dev": "!=null",
            "device_status": "is_suspended(dev) == true",
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device().",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device().",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_pin_device": {
        "description": "Pin managed PCI device",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_pin_device": {
        "description": "Pin managed PCI device",
        "pre": {
            "pdev": "!=null",
            "pdev->enabled": "==true"
        }
    }
},
{
    "kretprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#.",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_OFF, PCI_POWER_ON, PCI_POWER_UNKNOWN]"
        }
    }
},
{
    "kretprobe:pci_pme_active": {
        "description": "Restore PME configuration after config space restore.",
        "pre": {
            "dev": "!=null",
            "enable": "bool",
            "pmcsr": "u16",
            "dev->pme_support": "==true",
            "dev->pm_cap + PCI_PM_CTRL": "!=null"
        }
    }
},
{
    "kprobe:pci_pme_active": {
        "description": "Restore PME configuration after config space restore.",
        "pre": {
            "dev": "!=null",
            "enable": "bool"
        }
    }
},
{
    "kretprobe:__pci_enable_wake": {
        "description": "Enable or disable a PCI device as a wakeup event source.",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_OFF, PCI_POWER_ON, PCI_POWER_UNKNOWN]",
            "enable": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EINVAL, error_code]"
        }
    }
},
{
    "kprobe:__pci_enable_wake": {
        "description": "Enable PCI device as wakeup event source",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_STATE_D0, PCI_POWER_STATE_D1, PCI_POWER_STATE_D2, PCI_POWER_STATE_D3hot, PCI_POWER_STATE_D3cold]",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state.",
        "pre": {
            "dev": "!=null",
            "dev->power_state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]",
            "dev->can_wakeup": "==true",
            "dev->power_manageable": "==true"
        }
    }
},
{
    "kprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_rebar_get_possible_sizes": {
        "description": "Get possible sizes for BAR",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null",
            "bar": "is_resizable_bar(bar)"
        },
        "post": {
            "return_value": "is_valid_size(return_value)"
        }
    }
},
{
    "kprobe:pci_rebar_get_possible_sizes": {
        "description": "Get possible sizes for BAR",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port.",
        "pre": {
            "dev": "!=null",
            "cap_mask": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port",
        "pre": {
            "dev": "!=null",
            "cap_mask": "in [PCI_EXP_DEVCAP2_ATOMIC_COMP32, PCI_EXP_DEVCAP2_ATOMIC_COMP64, PCI_EXP_DEVCAP2_ATOMIC_COMP128]"
        }
    }
},

{
    "kprobe:pci_release_region": {
        "description": "Releases the PCI IO and memory resources previously reserved by a successful call to pci_request_region(). Call this function only after all use of the PCI regions has ceased.",
        "pre": {
            "pdev": "!=null",
            "bar": "!=null"
        }
    }
},
{
    "kretprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null"
        }
    }
},
{
    "kretprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null",
            "res_name": "!=null",
            "excl": "!=null"
        }
    }
},
{
    "kprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources.",
        "pre": {
            "pdev": "!=null",
            "bars": "!=null",
            "res_name": "!=null",
            "excl": "!=null"
        }
    }
},


{
    "kretprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        },
        "post": {
            "return": "in [0, EBUSY]"
        }
    }
},
{
    "kprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        }
    }
},
{
    "kretprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space",
        "pre": {
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space",
        "pre": {
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:pci_unmap_iospace": {
        "description": "Unmap the memory mapped IO space",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_iospace": {
        "description": "Unmap the memory mapped IO space",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "pre": {
            "dev": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_cfg_resource": {
        "description": "Check, request region and ioremap cfg resource.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfg_resource": {
        "description": "Check, request region and ioremap cfg resource.",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_update_current_state": {
        "description": "Update the current state of the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->current_state": "!=null",
            "atomic_inc_return(&dev->enable_cnt)": "> 1"
        }
    }
},
{
    "kprobe:pci_update_current_state": {
        "description": "Update the current state of the PCI device.",
        "pre": {
            "dev": "!=null",
            "dev->current_state": "!=null",
            "atomic_inc_return(&dev->enable_cnt)": "> 1"
        }
    }
},
{
    "kretprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi() function.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi()",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction for the given PCI device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [0, -ERRNO]"
        }
    }
},
{
    "kprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction on the PCI device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_max_mmrbc": {
        "description": "Get PCI-X maximum designed memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": ">=0"
        }
    }
},
{
    "kprobe:pcix_get_max_mmrbc": {
        "description": "get PCI-X maximum designed memory read byte count",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_mmrbc": {
        "description": "get PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": "!=null"
        }
    }
},
{
    "kprobe:pcix_get_mmrbc": {
        "description": "Get PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "mmrbc": ">=0"
        }
    }
},
{
    "kretprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_readrq": {
        "description": "Get PCI Express read request size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcie_get_readrq": {
        "description": "get PCI Express read request size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_mps": {
        "description": "get PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "!=null",
            "rq": "!=null",
            "bridge": "!=null",
            "v": "!=null",
            "max_mrrs": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:pcie_get_mps": {
        "description": "get PCI Express maximum payload size",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation.",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        }
    }
},
{
    "kprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation.",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        }
    }
},


{
    "kretprobe:pcie_get_width_cap": {
        "description": "Query for the PCI device's link width capability",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "in [PCIE_LINK_WIDTH_UNKNOWN, PCIE_LINK_WIDTH_1, PCIE_LINK_WIDTH_2, PCIE_LINK_WIDTH_4, PCIE_LINK_WIDTH_8, PCIE_LINK_WIDTH_12, PCIE_LINK_WIDTH_16, PCIE_LINK_WIDTH_32]"
        }
    }
},
{
    "kprobe:pcie_get_width_cap": {
        "description": "Query for the PCI device's link width capability",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kprobe:__pcie_print_link_status": {
        "description": "Report the PCI device's link speed and width",
        "pre": {
            "dev": "!=null",
            "verbose": "!=null"
        }
    }
},
{
    "kretprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource",
        "pre": {
            "dev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource",
        "pre": {
            "dev": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device and any children.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device and any children",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:msi->eq_cpu = dma_alloc_coherent": {
        "description": "Allocate coherent memory for msi->eq_cpu",
        "pre": {
            "msi->eq_cpu": "!=null",
            "msi->nr_eq_region * EQ_MEM_REGION_SIZE": "!=null",
            "dma_alloc_coherent(pcie->dev, msi->nr_eq_region * EQ_MEM_REGION_SIZE, &msi->eq_dma, GFP_KERNEL)": "==null"
        }
    }
},
{
    "kprobe:dma_alloc_coherent": {
        "description": "Allocate coherent memory for DMA",
        "pre": {
            "pcie->dev": "!=null",
            "msi->nr_eq_region": "!=null",
            "EQ_MEM_REGION_SIZE": "!=null",
            "&msi->eq_dma": "!=null",
            "GFP_KERNEL": "!=null"
        }
    }
},
{
    "kretprobe:axi_addr -= ob->axi_offset;/* iterate through all OARR/OMAP mapping windows": {
        "description": "Translate the AXI address to the internal address used by the iProc PCIe core before programming the OARR",
        "pre": {
            "axi_addr": ">= ob->axi_offset"
        }
    }
},
{
    "kprobe:axi_addr -= ob->axi_offset;/* iterate through all OARR/OMAP mapping windows": {
        "description": "Translate the AXI address to the internal address used by the iProc PCIe core before programming the OARR",
        "pre": {
            "axi_addr": ">= ob->axi_offset"
        }
    }
},
{
    "kretprobe:aspm_disabled": {
        "description": "Check if ASPM is disabled on a device",
        "pre": {
            "aspm_disabled": "true",
            "link": "!=null"
        },
        "post": {
            "return_value": "-EINVAL"
        }
    }
},
{
    "kprobe:if (aspm_disabled)": {
        "description": "Check if ASPM is disabled on a device.",
        "pre": {
            "aspm_disabled": "==true"
        }
    }
},
{
    "kretprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null",
            "state": "in [ASPM_LINK_STATE_0, ASPM_LINK_STATE_1, ASPM_LINK_STATE_2, ASPM_LINK_STATE_3]"
        }
    }
},
{
    "kprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states.",
        "pre": {
            "pdev": "!=null",
            "state": "!=null"
        }
    }
},
{
    "kretprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "pre": {
            "dev": "!=null",
            "dev->ptm_cap": "is u16",
            "ptm": "=dev->ptm_cap",
            "ctrl": "is u32",
            "ptm": "!=0",
            "ctrl": "is read from PCI configuration space at offset ptm + PCI_PTM_CTRL",
            "ctrl": "is updated with bitwise AND operation",
            "ctrl": "is written back to PCI configuration space at offset ptm + PCI_PTM_CTRL"
        }
    }
},
{
    "kprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "pre": {
            "dev": "!=null",
            "dev->ptm_cap": "!=0",
            "ptm": "=dev->ptm_cap",
            "ctrl": "is u32",
            "ctrl": "is read from PCI configuration space at offset ptm + PCI_PTM_CTRL",
            "ctrl": "is updated with bitwise AND operation",
            "ctrl": "is written to PCI configuration space at offset ptm + PCI_PTM_CTRL"
        }
    }
},
{
    "kretprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware.",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware.",
        "pre": {
            "pdev": "!=null"
        }
    }
},


{
    "kretprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device",
        "pre": {
            "dev": "!=null",
            "pci_msi_enabled()": "true",
            "!dev->msi_enabled": "true"
        }
    }
},
{
    "kprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device",
        "pre": {
            "pci_msi_enabled()": true,
            "dev": "==null",
            "dev->msi_enabled": "==false",
            "msi_lock_descs(&dev->dev)": true,
            "pci_msi_shutdown(dev)": true,
            "pci_free_msi_irqs(dev)": true,
            "msi_unlock_descs(&dev->dev)": true
        }
    }
},
{
    "kretprobe:pci_enable_msix_range": {
        "description": "Enable MSI-X interrupts for a PCI device within a specified range.",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">=minvec"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pci_enable_msix_range": {
        "description": "Enable MSI-X interrupts for a PCI device within a specified range of vectors.",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">=minvec"
        }
    }
},
{
    "kretprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "affd": "==null or !=null"
        }
    }
},
{
    "kprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "!=null",
            "affd": "null or &struct irq_affinity"
        }
    }
},
{
    "kretprobe:pci_alloc_irq_vectors": {
        "description": "Allocate IRQ vectors for a PCI device.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">=min_vecs",
            "flags": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:pci_alloc_irq_vectors": {
        "description": "Allocate IRQ vectors for a PCI device.",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">=min_vecs",
            "flags": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        }
    }
},
{
    "kprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        }
    }
},
{
    "kretprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "nvec": ">=0",
            "nvec < minvec": "-ENOSPC",
            "nvec > maxvec": "nvec = maxvec",
            "pci_setup_msi_context(dev) != 0": "return pci_setup_msi_context(dev)",
            "!pci_setup_msi_device_domain(dev)": "return -ENODEV",
            "affd != null": {
                "nvec = irq_calc_affinity_vectors(minvec, nvec, affd)",
                "nvec < minvec": "return -ENOSPC"
            },
            "rc == 0": "return nvec",
            "rc < 0": "return rc",
            "rc < minvec": "return -ENOSPC",
            "nvec = rc"
        }
    }
},
{
    "kretprobe:pci_msi_mask_irq": {
        "description": "Generic IRQ chip callback to mask PCI MSI interrupts",
        "pre": {
            "data": "!=null",
            "desc": "msi_desc_to_pci_dev(data)",
            "desc->pci.mask_pos": "!=null",
            "desc->pci.msi_mask": "!=null",
            "lock": "properly initialized",
            "flags": "properly initialized"
        }
    }
},



{
    "kretprobe:return -ENODEV;}pc_host = container_of(dev->bus->op struct bcma_drv_pci_host, pci_ops);return bcma_core_irq(pc_host->pdev->core, 0);}EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq": {
        "description": "bcma_core_pci_pcibios_map_irq function",
        "pre": {
            "dev": "!=null",
            "dev->bus": "!=null",
            "dev->bus->ops": "!=null",
            "dev->bus->ops->read": "!=bcma_core_pci_hostmode_read_config",
            "pc_host": "!=null",
            "pc_host->pdev": "!=null",
            "pc_host->pdev->core": "!=null"
        }
    }
},
{
    "kprobe:return -ENODEV;}pc_host = container_of(dev->bus->op struct bcma_drv_pci_host, pci_ops);return bcma_core_irq(pc_host->pdev->core, 0);}EXPORT_SYMBOL(bcma_core_pci_pcibios_map_irq": {
        "description": "bcma_core_pci_pcibios_map_irq function",
        "pre": {
            "dev": "!=null",
            "dev->bus": "!=null",
            "dev->bus->ops": "!=null",
            "dev->bus->ops->read": "!=bcma_core_pci_hostmode_read_config"
        }
    }
},
{
    "kretprobe:dio_register_driver": {
        "description": "Register a new DIO driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:dio_register_driver": {
        "description": "Register a new DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:driver_register": {
        "description": "Register a driver with the DIO subsystem.",
        "pre": {
            "drv": "!=null",
            "drv->driver": "!=null",
            "dio_bus_type": "register with core"
        }
    }
},
{
    "kprobe:driver_register": {
        "description": "Register a driver with the DIO subsystem.",
        "pre": {
            "drv": {
                "driver": "!=null"
            },
            "dio_bus_type": "register with core"
        }
    }
},
{
    "kretprobe:devm_extcon_register_notifier": {
        "description": "Resource-managed extcon_register_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        },
        "post": {
            "return": "int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:devm_extcon_register_notifier": {
        "description": "Resource-managed extcon_register_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "unsigned int",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:devm_extcon_register_notifier_all": {
        "description": "Resource-managed extcon_register_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:devm_extcon_register_notifier_all": {
        "description": "Resource-managed extcon_register_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all()",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dmi_check_system": {
        "description": "Check system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:dmi_check_system": {
        "description": "Check system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kretprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image.",
        "pre": {
            "buf": "!=null",
            "dmi_ver": "unknown"
        }
    }
},
{
    "kprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image.",
        "pre": {
            "buf": "!=null",
            "buf[16]": "== 'DMI'",
            "buf[0]": "== 'SMBIOS'"
        }
    }
},
{
    "kretprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "pre": {
            "str": "!=null"
        }
    }
},


{
    "kretprobe:dmi_get_date": {
        "description": "Parse a DMI date",
        "pre": {
            "field": "!=null",
            "yearp": "!=null",
            "monthp": "!=null",
            "dayp": "!=null"
        }
    }
},
{
    "kprobe:dmi_get_date": {
        "description": "Parse a DMI date",
        "pre": {
            "field": ">=0",
            "yearp": ">=0",
            "monthp": ">=0",
            "dayp": ">=0"
        }
    }
},
{
    "kretprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field.",
        "pre": {
            "return_value": ">=0 or <0",
            "errno": "in [-ENXIO, <other negative error codes>]"
        }
    }
},
{
    "kprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field.",
        "pre": {
            "return_value": ">=0",
            "errno": "in [-ENXIO, <0]",
            "dmi_field_present": "true",
            "dmi_field_parseable": "true"
        }
    }
},
{
    "kretprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all cpus",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu",
        "pre": {
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata",
        "pre": {
            "peripheral": "!=null",
            "metadata": "!=null",
            "size": ">=0",
            "ctx": "optional"
        }
    }
},
{
    "kprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata",
        "pre": {
            "peripheral": "!=null",
            "metadata": "!=null",
            "size": ">=0",
            "ctx": "optional"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading.",
        "pre": {
            "peripheral": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading.",
        "pre": {
            "peripheral": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor.",
        "pre": {
            "peripheral": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor",
        "pre": {
            "peripheral": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        },
        "post": {
            "return_value": "is a boolean"
        }
    }
},
{
    "kprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral.",
        "pre": {
            "peripheral": "!=null",
            "peripheral": "is an integer",
            "peripheral": ">= 0"
        }
    }
},
{
    "kretprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface.",
        "pre": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface.",
        "pre": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table for the IOMMU.",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        },
        "post": {
            "ret": "==0"
        }
    }
},
{
    "kprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table for the IOMMU.",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership",
        "pre": {
            "dev": "!=null",
            "mem_region": "!=null",
            "mem_sz": "!=null",
            "src": "!=null",
            "src_sz": "!=null",
            "dest": "!=null",
            "dest_sz": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership.",
        "pre": {
            "dev": "!=null",
            "mem_region": "!=null",
            "mem_sz": "!=null",
            "src": "!=null",
            "src_sz": "!=null",
            "dest": "!=null",
            "dest_sz": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_ocmem_lock_available": {
        "description": "Check if OCMEM lock/unlock interface is available.",
        "pre": {
            "return_value": "is_bool"
        }
    }
},
{
    "kprobe:qcom_scm_ocmem_lock_available": {
        "description": "is OCMEM lock/unlock interface available",
        "pre": {},
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "pre": {
            "id": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "pre": {
            "id": "!=null",
            "offset": "!=null",
            "size": "!=null"
        }
    }
},


{
    "kretprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP.",
        "pre": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP.",
        "pre": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request.",
        "pre": {
            "req": "!=null",
            "req_cnt": ">=0",
            "resp": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request.",
        "pre": {
            "req": "!=null",
            "req_cnt": "!=null",
            "resp": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_iommu_set_pt_format": {
        "description": "Sets the page table format for the specified secure ID, context number, and page table format.",
        "pre": {
            "sec_id": "!=null",
            "ctx_num": "!=null",
            "pt_fmt": "in [0, 1]"
        }
    }
},
{
    "kprobe:qcom_scm_iommu_set_pt_format": {
        "description": "Sets the page table format for the specified secure ID, context number, and page table format.",
        "pre": {
            "sec_id": "!=null",
            "ctx_num": "!=null",
            "pt_fmt": "in [0, 1]"
        }
    }
},
{
    "kretprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "pre": {
            "return_value": "==1"
        }
    }
},
{
    "kprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "pre": {
            "void": "null"
        }
    }
},
{
    "kretprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware using an OP-TEE call to start a secure boot process.",
        "pre": {
            "return_value": ">= -4095",
            "errno": "< 0"
        }
    }
},
{
    "kprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware. Uses an OP-TEE call to start a secure boot process.",
        "pre": {
            "return_value": "==0"
        }
    }
},
{
    "kretprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory using an OP-TEE call.",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory using an OP-TEE call.",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        }
    }
},
{
    "var": "!=null",
    "end": "!=null",
    "nvram_buf": "!=null",
    "sizeof(struct nvram_header)": "!=null",
    "var < end": true,
    "*var": "!=null",
    "name": "!=null",
    "val": "!=null",
    "val_len": "!=null"
},
{
    "kprobe:bcm47xx_nvram_getenv": {
        "description": "Look for name=value and return value",
        "pre": {
            "name": "!=null",
            "val": "!=null",
            "val_len": "!=null",
            "var": "!=null",
            "value": "!=null",
            "end": "!=null",
            "eq": "!=null",
            "err": "!=null",
            "nvram_len": "!=null",
            "nvram_buf": "!=null",
            "sizeof(struct nvram_header)": "!=null",
            "sizeof(nvram_buf)": "!=null",
            "var < end": true,
            "*var": "!=0"
        }
    }
},


{
    "kretprobe:smp_rmb();tegra_ivc_invalidate_frame(ivc, ivc->rx.phy ivc->rx.position, 0, ivc->frame_size);return tegra_ivc_frame_virt(ivc, &ivc->rx.map, ivc->rx.position, map);}EXPORT_SYMBOL(tegra_ivc_read_get_next_frame": {
        "description": "Order observation of ivc->rx.position potentially indicating new data before data read.",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kprobe:smp_rmb": {
        "description": "Read memory barrier that guarantees ordering of memory accesses.",
        "pre": {},
        "post": {}
    },
    "kprobe:tegra_ivc_invalidate_frame": {
        "description": "Invalidate a frame in the tegra_ivc structure.",
        "pre": {
            "ivc": "!=null",
            "ivc->rx.phys": "!=null",
            "ivc->rx.position": "!=null",
            "ivc->frame_size": "!=null"
        },
        "post": {}
    },
    "kprobe:tegra_ivc_frame_virt": {
        "description": "Get the virtual address of a frame in the tegra_ivc structure.",
        "pre": {
            "ivc": "!=null",
            "&ivc->rx.map": "!=null",
            "ivc->rx.position": "!=null",
            "map": "!=null"
        },
        "post": {}
    },
    "kprobe:EXPORT_SYMBOL(tegra_ivc_read_get_next_frame": {
        "description": "Exported symbol for tegra_ivc_read_get_next_frame function.",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        },
        "post": {}
    }
},
{
    "kretprobe:tegra_ivc_check_read": {
        "description": "Check if the tegra_ivc read operation is successful.",
        "pre": {
            "ivc": "!=null"
        },
        "post": {
            "err": "< 0"
        }
    },
    "kretprobe:tegra_ivc_advance_rx": {
        "description": "Advance the tegra_ivc receive buffer.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kretprobe:tegra_ivc_flush": {
        "description": "Flush the tegra_ivc buffer with the given parameters.",
        "pre": {
            "ivc": "!=null",
            "rx": ">= 0"
        },
        "post": {
            "ivc->rx.position": ">= ivc->tx.position"
        }
    }
},
{
    "kprobe:tegra_ivc_check_read": {
        "description": "Check if the tegra_ivc read operation is successful.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kprobe:tegra_ivc_advance_rx": {
        "description": "Advance the tegra_ivc receive buffer.",
        "pre": {
            "ivc": "!=null"
        }
    },
    "kprobe:tegra_ivc_flush": {
        "description": "Flush the tegra_ivc buffer.",
        "pre": {
            "ivc": "!=null",
            "rx": "!=null"
        }
    }
},
{
    "kretprobe:smp_wmb;tegra_ivc_advance_tx;tegra_ivc_flush": {
        "description": "Ensure our write to ivc->tx.position occurs before our read from ivc->rx.position.",
        "pre": {
            "ivc": "!=null",
            "ivc->tx.phys": "!=null",
            "ivc->tx.position": "!=null",
            "ivc->rx.position": "!=null"
        }
    }
},
{
    "kprobe:smp_wmb();tegra_ivc_advance_tx(ivc);tegra_ivc_flush(ivc, ivc->tx.phys + tx);/* * Ensure our write to ivc->tx.position occurs before our read from * ivc->rx.position.": {
        "description": "Order any possible stores to the frame before update of ivc->tx.position.",
        "pre": {
            "ivc": "!=null",
            "tx": "!=null",
            "ivc->tx.phys": "!=null",
            "tx.position": "!=null",
            "ivc->rx.position": "!=null"
        }
    }
},
{
    "kretprobe:tegra_ivc_notified": {
        "description": "Function to handle notifications in tegra_ivc",
        "pre": {
            "ivc": "!=null",
            "localremoteaction": "in [SYNCEST, SYNCACK, ACKEST, ACKACK, ACKSYNC, ESTEST, ESTACK, ESTSYNC]"
        },
        "post": {
            "conditions": {
                "SYNCEST": {
                    "counter_reset": true,
                    "state_transition": "EST",
                    "notification": true
                },
                "SYNCACK": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                },
                "ACKEST": {
                    "state_transition": "EST",
                    "notification": true
                },
                "ACKACK": {
                    "state_transition": "EST",
                    "notification": true
                },
                "ACKSYNC": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                },
                "ESTEST": {
                    "notification": false
                },
                "ESTACK": {
                    "notification": false
                },
                "ESTSYNC": {
                    "counter_reset": true,
                    "state_transition": "ACK",
                    "notification": true
                }
            }
        }
    }
},

{
    "kretprobe:tegra_ivc_init": {
        "description": "Initialize tegra_ivc structure",
        "pre": {
            "ivc": "!=null",
            "peer": "!=null",
            "rx": "!=null",
            "rx_phys": "!=null",
            "tx": "!=null",
            "tx_phys": "!=null",
            "num_frames": ">=0",
            "frame_size": ">=0",
            "notify": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:tegra_ivc_init": {
        "description": "Initialize the tegra_ivc structure with the given parameters.",
        "pre": {
            "ivc": "!=null",
            "peer": "!=null",
            "rx": "!=null",
            "rx_phys": "!=null",
            "tx": "!=null",
            "tx_phys": "!=null",
            "num_frames": ">=0",
            "frame_size": ">=0",
            "notify": "!=null",
            "data": "!=null",
            "err": "int",
            "queue_size": "size_t"
        },
        "post": {
            "queue_size": "tegra_ivc_total_queue_size(num_frames * frame_size)",
            "err": "<0 => return err"
        }
    }
},

{
    "kprobe:meson_sm_call": {
        "description": "generic SMC32 call to the secure-monitor",
        "pre": {
            "fw": "!=null",
            "cmd_index": "!=null",
            "ret": "!=null",
            "arg0": "!=null",
            "arg1": "!=null",
            "arg2": "!=null",
            "arg3": "!=null",
            "arg4": "!=null"
        }
    }
},
{
    "kretprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">=0",
            "cmd_index": ">=0",
            "arg0": "any",
            "arg1": "any",
            "arg2": "any",
            "arg3": "any",
            "arg4": "any"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">=0",
            "cmd_index": ">=0",
            "arg0": ">=0",
            "arg1": ">=0",
            "arg2": ">=0",
            "arg3": ">=0",
            "arg4": ">=0"
        }
    }
},


{
    "kretprobe:imx_scu_call_rpc": {
        "description": "SCU firmware API call",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "bool",
            "((struct imx_sc_rpc_msg *)msg)->svc": "!=null",
            "((struct imx_sc_rpc_msg *)msg)->func": "!=null"
        },
        "post": {
            "ret": "!=null"
        }
    }
},
{
    "kprobe:imx_scu_call_rpc": {
        "description": "SCU firmware API call",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "bool",
            "((struct imx_sc_rpc_msg *)msg)->svc": "!=null",
            "((struct imx_sc_rpc_msg *)msg)->func": "!=null"
        }
    }
},
{
    "kretprobe:imx_sc_rm_is_resource_owned": {
        "description": "Check if a resource is owned by the SCU firmware.",
        "pre": {
            "ipc": "!=null",
            "resource": "!=null"
        }
    }
},
{
    "kprobe:imx_sc_rm_is_resource_owned": {
        "description": "Check if a resource is owned by the SCU firmware.",
        "pre": {
            "ipc": "!=null",
            "msg": "!=null",
            "hdr": "!=null",
            "hdr->ver": "==IMX_SC_RPC_VERSION",
            "hdr->svc": "==IMX_SC_RPC_SVC_RM",
            "hdr->func": "==IMX_SC_RM_FUNC_IS_RESOURCE_OWNED",
            "hdr->size": "==2",
            "msg.resource": "!=null"
        }
    }
},
{
    "kretprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP)",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP).",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        }
    }
},
{
    "kretprobe:ch = mbox_request_channel_byname": {
        "description": "Request a mailbox channel by name.",
        "pre": {
            "cl": "!=null",
            "dev": "!=null",
            "ret": "==0",
            "i": ">=0",
            "imx_sc_irq_ipc_handle": "!=null",
            "ch": "!=null",
            "imx_scu_irq_callback": "!=null"
        }
    }
},
{
    "kprobe:ch = mbox_request_channel_byname": {
        "description": "Request a mailbox channel by name.",
        "pre": {
            "cl": "!=null",
            "dev": "!=null",
            "ret": "==0",
            "i": ">=0",
            "imx_sc_irq_ipc_handle": "!=null",
            "ch": "!=null",
            "imx_scu_irq_callback": "!=null"
        }
    }
},
{
    "kretprobe:w1_register_family": {
        "description": "Register a device family driver",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kprobe:w1_register_family": {
        "description": "Register a device family driver",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kretprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kretprobe:w1_add_master_device": {
        "description": "Registers a new master device",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kprobe:w1_add_master_device": {
        "description": "Registers a new master device",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kretprobe:atomic_set": {
        "description": "Set the value of the entry associated with *dev->refcnt* to 1.",
        "pre": {
            "dev": "!=null",
            "dev->refcnt": "==1"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head *dev->slist* and *dev->async_list*.",
        "pre": {
            "dev": "!=null",
            "dev->slist": "is empty",
            "dev->async_list": "is empty"
        }
    },
    "kretprobe:mutex_init": {
        "description": "Initialize the mutex *dev->mutex*, *dev->bus_mutex*, and *dev->list_mutex*.",
        "pre": {
            "dev": "!=null",
            "dev->mutex": "is initialized",
            "dev->bus_mutex": "is initialized",
            "dev->list_mutex": "is initialized"
        }
    },
    "kretprobe:memcpy": {
        "description": "Copy the content of *device* to *dev->dev*.",
        "pre": {
            "dev": "!=null",
            "device": "!=null",
            "sizeof(struct device)": "is valid",
            "dev->dev": "is equal to *device*"
        }
    },
    "kretprobe:dev_set_name": {
        "description": "Set the name of *dev->dev* to 'w1_bus_master%u', where %u is replaced with *dev->id*.",
        "pre": {
            "dev": "!=null",
            "dev->dev": "is initialized",
            "dev->id": "is valid",
            "dev->name": "is equal to 'w1_bus_master%u', where %u is replaced with *dev->id*"
        }
    },
    "kretprobe:snprintf": {
        "description": "Format the string 'w1_bus_master%u', where %u is replaced with *dev->id*, and store it in *dev->name*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid",
            "dev->name": "is equal to the formatted string 'w1_bus_master%u', where %u is replaced with *dev->id*"
        }
    },
    "kretprobe:device_register": {
        "description": "Register the device *dev->dev* and store the return value in *err*.",
        "pre": {
            "dev": "!=null",
            "dev->dev": "is initialized",
            "err": "is valid",
            "*err": "is the return value of device_register(&dev->dev)"
        }
    }
},
{
    "kprobe:atomic_set": {
        "description": "Set the value of the entry associated with *dev->refcnt* to 1.",
        "pre": {
            "dev": "!=null",
            "dev->refcnt": "==1"
        }
    },
    "kprobe:INIT_LIST_HEAD": {
        "description": "Initialize the list head *dev->slist*.",
        "pre": {
            "dev": "!=null",
            "dev->slist": "is empty"
        }
    },
    "kprobe:mutex_init": {
        "description": "Initialize the mutex *dev->mutex*.",
        "pre": {
            "dev": "!=null",
            "dev->mutex": "is unlocked"
        }
    },
    "kprobe:memcpy": {
        "description": "Copy the content of *device* to *dev->dev*.",
        "pre": {
            "dev": "!=null",
            "device": "!=null",
            "sizeof(struct device)": "is valid"
        }
    },
    "kprobe:dev_set_name": {
        "description": "Set the name of *dev->dev* to \"w1_bus_master%u\", where %u is replaced with *dev->id*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid"
        }
    },
    "kprobe:snprintf": {
        "description": "Format the string \"w1_bus_master%u\" with *dev->id* and store it in *dev->name*.",
        "pre": {
            "dev": "!=null",
            "dev->id": "is valid",
            "sizeof(dev->name)": "is valid"
        }
    },
    "kprobe:device_register": {
        "description": "Register *dev->dev* as a device.",
        "pre": {
            "dev": "!=null",
            "err": "==0"
        }
    }
},
{
    "kretprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">=0",
            "type": "in [MBIM, QMI...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">=0",
            "type": "in [MBIM, QMI...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kretprobe:cdc_parse_cdc_header": {
        "description": "Parse the extra headers present in CDC devices.",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        },
        "post": {
            "return_value": ">= -EINVAL"
        }
    }
},
{
    "kprobe:cdc_parse_cdc_header": {
        "description": "Parse the extra headers present in CDC devices.",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:usb_serial_suspend": {
        "description": "Suspend the USB serial interface",
        "pre": {
            "serial": "!=null",
            "serial->suspend_count++": "!=0"
        }
    }
},
{
    "kprobe:usb_serial_suspend": {
        "description": "Suspend the USB serial interface",
        "pre": {
            "serial": "!=null",
            "serial->suspend_count": "==0"
        }
    }
},
{
    "kretprobe:usb_serial_resume": {
        "description": "Resume the USB serial interface.",
        "pre": {
            "serial->suspend_count": "==0",
            "serial": "!=null",
            "serial->type->resume": "!=null",
            "rv": "!=null"
        }
    }
},
{
    "kprobe:usb_serial_resume": {
        "description": "Resume the USB serial interface",
        "pre": {
            "intf": "!=null",
            "serial": "!=null",
            "rv": "int",
            "serial->suspend_count": "==0",
            "serial->type->resume": "!=null"
        }
    }
},
{
    "kretprobe:usb_wwan_dtr_rts": {
        "description": "Set the RTS and DTR states of the USB WWAN port and send setup.",
        "pre": {
            "port": "!=null",
            "on": "is_boolean",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        }
    }
},
{
    "kprobe:usb_wwan_dtr_rts": {
        "description": "Set the RTS and DTR states of the USB WWAN port and send setup.",
        "pre": {
            "port": "!=null",
            "on": "in [0, 1]"
        }
    }
},
{
    "kretprobe:usb_wwan_tiocmset": {
        "description": "Set or clear the TIOCM_RTS and TIOCM_DTR flags for a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "set": "!=0",
            "clear": "!=0",
            "port": "!=null",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        },
        "post": {
            "portdata.rts_state": "in [0, 1]",
            "portdata.dtr_state": "in [0, 1]"
        }
    }
},
{
    "kprobe:usb_wwan_tiocmset": {
        "description": "Sets the TIOCM_RTS and TIOCM_DTR bits in the portdata structure based on the set and clear arguments.",
        "pre": {
            "tty": "!=null",
            "set": "!=null",
            "clear": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "intfdata": "!=null",
            "intfdata.use_send_setup": "==true"
        },
        "post": {
            "portdata.rts_state": "in [0, 1]",
            "portdata.dtr_state": "in [0, 1]"
        }
    }
},
{
    "kretprobe:usb_wwan_write": {
        "description": "Write data to a USB WWAN device.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "portdata": "!=null",
            "intfdata": "!=null",
            "i": ">=0",
            "left": ">=0",
            "todo": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kprobe:usb_wwan_write": {
        "description": "Write data to a USB WWAN device.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "portdata": "!=null",
            "intfdata": "!=null",
            "i": ">=0",
            "left": ">=0",
            "todo": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kretprobe:usb_wwan_chars_in_buffer": {
        "description": "Calculate the number of characters in the buffer of a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "i": ">=0",
            "data_len": ">=0",
            "this_urb": "!=null"
        }
    }
},
{
    "kprobe:usb_wwan_chars_in_buffer": {
        "description": "Calculate the number of characters in the buffer of a USB WWAN port.",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "portdata": "!=null",
            "i": ">=0",
            "data_len": ">=0",
            "this_urb": "!=null"
        }
    }
},



{
    "kprobe:spin_lock_irq": {
        "description": "Acquire a spinlock and disable interrupts.",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:--intfdata->open_ports": {
        "description": "Decrement the value of open_ports in intfdata by 1.",
        "pre": {
            "intfdata": "!=null",
            "intfdata->open_ports": ">0"
        }
    },
    "kprobe:intfdata->interface->needs_remote_wakeup": {
        "description": "Set the value of needs_remote_wakeup in intfdata's interface to 0.",
        "pre": {
            "intfdata": "!=null",
            "intfdata->interface": "!=null"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Release the spinlock and enable interrupts.",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:gemini_sata_bridge_enabled": {
        "description": "Check if the SATA bridge is enabled for the given sata_gemini structure and is_ata1 flag.",
        "pre": {
            "sg->sata_bridge": "==true",
            "sg->muxmode": "in [GEMINI_MUXMODE_2, GEMINI_MUXMODE_3]",
            "!is_ata1": "==true when sg->muxmode == GEMINI_MUXMODE_2",
            "is_ata1": "==true when sg->muxmode == GEMINI_MUXMODE_3"
        },
        "post": {
            "return": "==true"
        }
    }
},
{
    "kprobe:gemini_sata_bridge_enabled": {
        "description": "Check if the Gemini SATA bridge is enabled for the given sata_gemini structure and is_ata1 flag.",
        "pre": {
            "sg->sata_bridge": "!=null",
            "sg->muxmode": "in [GEMINI_MUXMODE_2, GEMINI_MUXMODE_3]",
            "is_ata1": "in [true, false]",
            "sg->muxmode == GEMINI_MUXMODE_2 && !is_ata1": "false",
            "sg->muxmode == GEMINI_MUXMODE_3 && is_ata1": "false"
        },
        "post": {
            "return": "true"
        }
    }
},
{
    "kretprobe:gemini_sata_setup_bridge": {
        "description": "Setup the Gemini SATA bridge.",
        "pre": {
            "sg": "!=null",
            "bridge": "!=null",
            "pclk": "!=null",
            "ret": "int",
            "ret == 0": true,
            "bridge == 0 || bridge == 1": true
        }
    }
},
{
    "kprobe:gemini_sata_setup_bridge": {
        "description": "Setup the Gemini SATA bridge.",
        "pre": {
            "sg": "!=null",
            "bridge": "!=null",
            "pclk": "!=null",
            "ret": "int"
        }
    }
},


{
    "kretprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine.",
        "pre": {
            "ap": "!=null"
        }
    }
},
{
    "kprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine.",
        "pre": {
            "ap": "!=null"
        }
    }
},
{
    "kretprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading.",
        "pre": {
            "indio_dev": "!=null",
            "ev_code": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading.",
        "pre": {
            "indio_dev": "!=null",
            "ev_code": "!=null",
            "timestamp": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "!=null"
        }
    }
},
{
    "kprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property.",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        }
    }
},
{
    "kretprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__iio_device_register": {
        "description": "Register an IIO device",
        "pre": {
            "indio_dev": "!=null",
            "this_mod": "!=null",
            "indio_dev->info": "!=null"
        }
    }
},
{
    "kprobe:__iio_device_register": {
        "description": "Register an IIO device.",
        "pre": {
            "indio_dev": {
                "info": "!=null"
            },
            "this_mod": "!=null"
        }
    }
},
{
    "kretprobe:iio_read_channel_ext_info": {
        "description": "Read channel-specific extended information and write it to the buffer.",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:iio_read_channel_ext_info": {
        "description": "Read extended information about a channel.",
        "pre": {
            "dev": "!=null",
            "attr": "any",
            "buf": "any"
        }
    }
},
{
    "kretprobe:dev_set_name": {
        "description": "Set the name used for the sysfs directory etc.",
        "pre": {
            "trig_info->dev": "!=null",
            "trig_info->id": "!=null"
        }
    },
    "kretprobe:device_add": {
        "description": "Add the device to the list of available triggers held by the IIO core.",
        "pre": {
            "ret": "==0"
        }
    },
    "kretprobe:iio_trigger_register": {
        "description": "Register the IIO trigger.",
        "pre": {
            "trig_info": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kprobe:dev_set_name": {
        "description": "Set the name of the device.",
        "pre": {
            "trig_info->dev": "!=null",
            "trig_info->id": "!=null"
        }
    },
    "kprobe:device_add": {
        "description": "Add the device to the list of available triggers held by the IIO core.",
        "pre": {
            "ret": "==0"
        }
    },
    "kprobe:iio_trigger_register": {
        "description": "Register the IIO trigger.",
        "pre": {
            "trig_info": "!=null",
            "ret": ">=0"
        }
    }
},
{
    "kretprobe:device_del": {
        "description": "Unregister an IIO trigger device.",
        "pre": {
            "trig_info": "!=null",
            "trig_info->dev": "!=null",
            "iio_trigger_list_lock": "locked",
            "iio_trigger_ida": "initialized",
            "trig_info->list": "in iio_trigger_list",
            "trig_info->id": "in iio_trigger_ida"
        },
        "post": {
            "iio_trigger_list_lock": "unlocked",
            "iio_trigger_ida": "updated"
        }
    }
},
{
    "kprobe:device_del": {
        "description": "Unregister an IIO trigger device.",
        "pre": {
            "trig_info": "!=null",
            "trig_info->dev": "!=null",
            "iio_trigger_list_lock": "locked",
            "trig_info->list": "in iio_trigger_list",
            "iio_trigger_ida": "initialized",
            "trig_info->id": "in iio_trigger_ida"
        },
        "post": {
            "iio_trigger_list_lock": "unlocked"
        }
    }
},
{
    "kretprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device.",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device.",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},




{
    "kretprobe:qcom_vadc_map_temp_voltage": {
        "description": "Map temperature to voltage using linear interpolation.",
        "pre": {
            "pts": "!=null",
            "tablesize": ">0",
            "input": "!=null"
        }
    }
},

{
    "kretprobe:is_stm32_lptim_trigger": {
        "description": "Check if the trigger is a valid STM32 IIO Low-Power Timer Trigger",
        "pre": {
            "trig": "!=null"
        },
        "post": {
            "return_value": "in [true, false]"
        }
    }
},
{
    "kprobe:is_stm32_lptim_trigger": {
        "description": "Check if the trigger is a valid STM32 IIO Low-Power Timer Trigger.",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex referenced by &priv->lock.",
        "pre": {
            "priv": {
                "lock": "!=null"
            },
            "sms": 6,
            "priv->enabled": false
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex associated with priv->lock.",
        "pre": {
            "priv->lock": "!=null",
            "sms": "==6",
            "!priv->enabled": "true"
        }
    }
},
{
    "kretprobe:amba_driver_register": {
        "description": "Register an AMBA device driver with the Linux device model core. If devices pre-exist, the driver's probe function will be called.",
        "pre": {
            "drv": "!=null"
        }
    }
},

{
    "kretprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:amba_device_register": {
        "description": "Register an AMBA device",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:amba_device_register": {
        "description": "Register an AMBA device",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:amba_request_regions": {
        "description": "Request all memory regions associated with the device.",
        "pre": {
            "dev": "!=null",
            "name": "!=null or ==null"
        }
    }
},
{
    "kprobe:amba_request_regions": {
        "description": "Request all memory regions associated with the device.",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:amba_release_regions": {
        "description": "Release mem regions associated with device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_release_regions": {
        "description": "Release mem regions associated with device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_init": {
        "description": "Initialize the MSI context",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        }
    }
},
{
    "kprobe:ntb_msi_init": {
        "description": "Initialize the MSI context",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows",
        "pre": {
            "ntb": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kretprobe:ntbm_msi_request_threaded_irq": {
        "description": "Allocate an MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "!=null",
            "name": "!=null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_request_threaded_irq": {
        "description": "Allocate an MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "!=null",
            "name": "!=null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        }
    }
},
{
    "kretprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt",
        "pre": {
            "ntb": "!=null",
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt",
        "pre": {
            "ntb": "!=null",
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null",
            "msi_addr": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt",
        "pre": {
            "ntb": "!=null",
            "peer": "!=null",
            "desc": "!=null",
            "msi_addr": "!=null"
        }
    }
},
{
    "kretprobe:tty_register_ldisc": {
        "description": "Install a line discipline",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_register_ldisc": {
        "description": "Install a line discipline",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_init": {
        "description": "Initialize tty_port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_init": {
        "description": "Initialize tty_port",
        "pre": {
            "port": "!=null"
        }
    }
},


{
    "kretprobe:tty_port_tty_set": {
        "description": "Set the tty of a port",
        "pre": {
            "port": "!=null",
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_port_tty_set": {
        "description": "Set the tty of a port",
        "pre": {
            "port": "!=null",
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "tty->termios.c_cflag & HUPCL": "==0",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "tty->termios.c_cflag & HUPCL": "!=0",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_raise_dtr_rts": {
        "description": "Raise DTRRTS",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_raise_dtr_rts": {
        "description": "Raise DTRRTS",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference.",
        "pre": {
            "port": "!=null",
            "port->ops->shutdown": "!=null"
        }
    }
},
{
    "kprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_block_til_ready": {
        "description": "Waiting logic for tty open",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_port_block_til_ready": {
        "description": "Waiting logic for tty open",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_close_start": {
        "description": "Function to close a tty port",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null",
            "tty_lock": "held"
        },
        "post": {
            "return_value": "in [0, 1]"
        }
    }
},
{
    "kprobe:tty_port_close_start": {
        "description": "Called before closing a TTY port.",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null",
            "locking": "TTY lock held",
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:tty_port_open": {
        "description": "Generic tty->ops->open handler",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_port_open": {
        "description": "generic tty->ops->open handler",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes",
        "pre": {
            "tty": "!=null",
            "sig": "!=null"
        }
    }
},
{
    "kprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes",
        "pre": {
            "tty": "!=null",
            "sig": "!=null"
        }
    }
},

{
    "kprobe:.c_iflag = ICRNL | IXON,.c_oflag = OPOST | ONLCR,.c_cflag = B38400 | CS8 | CREAD | HUPCL,.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN,.c_cc = INIT_C_CC,.c_ispeed = 38400,.c_ospeed = 38400,/* .c_line = N_TTY,": {
        "description": "Set the termios structure for tty standard input/output.",
        "pre": {
            ".c_iflag": "ICRNL | IXON",
            ".c_oflag": "OPOST | ONLCR",
            ".c_cflag": "B38400 | CS8 | CREAD | HUPCL",
            ".c_lflag": "ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN",
            ".c_cc": "INIT_C_CC",
            ".c_ispeed": 38400,
            ".c_ospeed": 38400
        }
    }
},
{
    "kretprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:__tty_hangup": {
        "description": "Actual handler for hangup events",
        "pre": {
            "tty": "!=null",
            "exit_session": "is int"
        }
    }
},
{
    "kprobe:__tty_hangup": {
        "description": "Actual handler for hangup events",
        "pre": {
            "tty": "!=null",
            "exit_session": "int"
        }
    }
},
{
    "kretprobe:tty_vhangup": {
        "description": "Process vhangup for tty",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_vhangup": {
        "description": "Process vhangup for tty",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "pre": {
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "pre": {
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:stop_tty": {
        "description": "Perform flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->ops->stop": "!=null"
        }
    }
},
{
    "kprobe:stop_tty": {
        "description": "Perform flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->ops->stop": "!=null"
        }
    }
},
{
    "kretprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->flow.tco_stopped": "==false",
            "tty->flow.stopped": "=false",
            "tty->ops.start": "!=null"
        },
        "post": {
            "tty->ops.start(tty)": "called",
            "tty_wakeup(tty)": "called"
        }
    }
},
{
    "kprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible.",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "==false",
            "tty->flow.tco_stopped": "==false",
            "tty->ops->start": "!=null"
        }
    }
},
{
    "if (cons_filp)": {
        "description": "Check if `cons_filp` is not NULL.",
        "pre": {
            "cons_filp": "!=null"
        }
    }
},
{
    "if (cons_filp)": {
        "description": "Check if `cons_filp` is not null.",
        "pre": {
            "cons_filp": "!=null"
        }
    }
},
{
    "kretprobe:tty_do_resize": {
        "description": "Resize event for tty",
        "pre": {
            "tty": "!=null",
            "ws": "!=null"
        }
    }
},
{
    "kprobe:tty_do_resize": {
        "description": "Resize event for tty",
        "pre": {
            "tty": "!=null",
            "ws": "!=null",
            "termios_variables_updated": true,
            "signals_sent": true
        }
    }
},
{
    "kretprobe:do_SAK": {
        "description": "Executes do_SAK() into process context. Less stack use in devfs functions. alloc_tty_struct() always uses kmalloc().",
        "pre": {
            "context": "in [process]",
            "stack_use": "<= [devfs_functions]",
            "alloc_tty_struct": "uses [kmalloc]"
        }
    }
},

{
    "kretprobe:tty_register_device": {
        "description": "Register a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kprobe:tty_register_device": {
        "description": "Register a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null",
            "device": "!=null"
        }
    }
},
{
    "kretprobe:tty_unregister_device": {
        "description": "Unregister a tty device",
        "pre": {
            "driver": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:tty_unregister_device": {
        "description": "Unregister a tty device",
        "pre": {
            "driver": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:__tty_alloc_driver": {
        "description": "Allocate tty driver",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [TTY_DRIVER_1, TTY_DRIVER_2, ...]"
        }
    }
},
{
    "kprobe:__tty_alloc_driver": {
        "description": "Allocate tty driver",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [TTY_DRIVER_1, TTY_DRIVER_2, TTY_DRIVER_3]"
        }
    }
},
{
    "kretprobe:INIT_WORK": {
        "description": "Release a tty kref",
        "pre": {
            "tty": "!=null",
            "driver": "!=null",
            "owner": "!=null",
            "tty->files_lock": "unlocked",
            "tty->tty_files": "not in list",
            "tty->ctrl.pgrp": "pid released",
            "tty->ctrl.session": "pid released"
        }
    }
},
{
    "kprobe:INIT_WORK": {
        "description": "Initialize a work item and schedule it for execution.",
        "pre": {
            "tty": "!=null",
            "driver": "!=null",
            "owner": "!=null",
            "tty->files_lock": "locked",
            "tty->tty_files": "not in list",
            "tty->ctrl.pgrp": "valid PID",
            "tty->ctrl.session": "valid PID"
        }
    },
    "kprobe:schedule_work": {
        "description": "Schedule a work item for execution.",
        "pre": {
            "tty->hangup_work": "initialized"
        }
    }
},
{
    "kretprobe:tty_register_driver": {
        "description": "Register a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_register_driver": {
        "description": "Register a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver",
        "pre": {
            "driver": "!=null"
        }
    }
},


{
    "kretprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed.",
        "pre": {
            "termios": "!=null"
        },
        "post": {
            "speed": "!=null"
        }
    }
},
{
    "kretprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack. Takes the termios rwsem to protect against parallel throttle/unthrottle and also to ensure the driver can consistently reference its own termios data at this point when implementing software flow control. Drivers should, however, remember that the stack can issue a throttle, then change flow control method, then unthrottle.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack.",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kretprobe:tty_termios_copy_hw": {
        "description": "Copy hardware settings from old termios to new termios",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_copy_hw": {
        "description": "Copy hardware settings from old termios to new termios.",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_hw_change": {
        "description": "Check for setting change",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "bits_changed": "in [true, false]",
            "speed_change_needed": "in [true, false]"
        }
    }
},
{
    "kprobe:tty_termios_hw_change": {
        "description": "Check for setting change between two termios structures or a speed change is needed.",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:return_tty_mode_ioctl": {
        "description": "Helper function for handling ioctl commands in the n_tty driver.",
        "pre": {
            "tty": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:return_tty_mode_ioctl": {
        "description": "Helper function for handling ioctl commands in the n_tty driver.",
        "pre": {
            "tty": "!=null",
            "cmd": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kretprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:tty_insert_flip_string_flags": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:tty_insert_flip_string_flags": {
        "description": "Add characters to the tty buffer",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:__tty_insert_flip_char": {
        "description": "Add one character to the tty buffer",
        "pre": {
            "port": "!=null",
            "ch": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kprobe:__tty_insert_flip_char": {
        "description": "Add one character to the tty buffer",
        "pre": {
            "port": "!=null",
            "ch": "!=null",
            "flag": "!=null"
        }
    }
},
{
    "kretprobe:tty_flip_buffer_push": {
        "description": "Push terminal buffers",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_flip_buffer_push": {
        "description": "Push terminal buffers",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:orig_log_level = console_loglevel;console_loglevel = CONSOLE_LOGLEVEL_DEFAULT;op_p = __sysrq_get_key_op(key);if (op_p)": {
        "description": "Handle sysrq key operation",
        "pre": {
            "key": "!=null",
            "check_mask": "!=null",
            "orig_log_level": "!=null",
            "orig_suppress_printk": "!=null",
            "i": "!=null",
            "suppress_printk": "!=null"
        }
    }
},
{
    "kprobe:orig_log_level = console_loglevel;console_loglevel = CONSOLE_LOGLEVEL_DEFAULT;op_p = __sysrq_get_key_op(key);if (op_p)": {
        "description": "Handle sysrq key operation",
        "pre": {
            "key": "!=null",
            "check_mask": "!=null",
            "orig_log_level": "!=null",
            "orig_suppress_printk": "!=null",
            "i": "!=null",
            "suppress_printk": "!=null"
        }
    }
},
{
    "kretprobe:fg_console": {
        "description": "Helper for managing virtual consoles.",
        "pre": {
            "fg_console": "!=null",
            "last_console": "!=null",
            "want_console": "!=null",
            "saved_variants": "!=null"
        }
    }
},
{
    "kprobe:int_fg_console": {
        "description": "Helper function for fg_console",
        "pre": {
            "fg_console": "!=null",
            "last_console": "!=null",
            "want_console": "!=null",
            "saved_variants": "!=null"
        }
    }
},


{
    "kretprobe:return_resize_screen": {
        "description": "This function is being called here to cover the case where the userspace calls the FBIOPUT_VSCREENINFO twice, passing the same fb_var_screeninfo containing the fields yresxres equal to a number non-multiple of vc_font.height and yres_virtualxres_virtual equal to number lesser than the vc_font.height and yresxres. In the second call, the struct fb_var_screeninfo isn't being modified by the underlying driver because of the if above, and this causes the fbcon_display->vrows to become negative and it eventually leads to out-of-bound access by the imageblit function. To give the correct values to the struct and to not have to deal with possible errors from the code below, we call the resize_screen here as well.",
        "pre": {
            "vc": "!=null",
            "new_cols": "<= VC_MAXCOL",
            "new_rows": "<= VC_MAXROW",
            "new_screen_size": "> KMALLOC_MAX_SIZE",
            "!new_screen_size": "!=null",
            "newscreen": "!=null",
            "vc->vc_uni_lines": "!=null"
        }
    }
},
{
    "kprobe:resize_screen": {
        "description": "Resizes the screen based on the given parameters.",
        "pre": {
            "vc": "!=null",
            "new_cols": "!=null",
            "new_rows": "!=null",
            "user": "!=null",
            "new_screen_size": "> KMALLOC_MAX_SIZE || == 0",
            "newscreen": "==null",
            "vc->vc_uni_lines": "!=null"
        }
    }
},
{
    "kretprobe:conswitchp": {
        "description": "Description of the conswitchp function",
        "pre": {
            "con_is_bound(csw)": true,
            "con_driver_map[i]": "!= null",
            "con_driver_map[i]": "!= csw",
            "con_is_bound(defcsw)": false
        }
    }
},



{
    "kretprobe:give_up_console": {
        "description": "Unregister console driver",
        "pre": {
            "csw": "!=null"
        }
    }
},


{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},


{
    "kretprobe:con_set_default_unimap": {
        "description": "Set default unicode map for the console being updated.",
        "pre": {
            "vc": "!=null",
            "console_lock": "held",
            "font": "exists in uni_hash.tbl"
        }
    }
},
{
    "kprobe:con_set_default_unimap": {
        "description": "Set default unicode map for the console.",
        "pre": {
            "vc": "!=null"
        }
    }
},
{
    "kretprobe:con_copy_unimap": {
        "description": "Copy unimap between two virtual terminals.",
        "pre": {
            "dst_vc": "!=null",
            "src_vc": "!=null"
        }
    }
},


{
    "kprobe:sunserial_register_minors": {
        "description": "Register the driver on the first call",
        "pre": {
            "drv": "!=null",
            "count": "!=null"
        }
    },
    "kprobe:uart_register_driver": {
        "description": "Register the UART driver",
        "pre": {
            "drv": "!=null",
            "drv->nr": "==count"
        }
    }
},
{
    "kretprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate for a mouse.",
        "pre": {
            "mouse_got_break": "==true",
            "ctr": "<8"
        }
    }
},
{
    "kprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate for a mouse.",
        "pre": {
            "mouse_got_break": "==1",
            "ctr": "<8"
        }
    }
},
{
    "kretprobe:uart_write_wakeup": {
        "description": "Schedule write processing",
        "pre": {
            "port": "!=null",
            "port->lock": "held",
            "port->transmit_buffer_size": "< threshold"
        }
    }
},
{
    "kprobe:uart_write_wakeup": {
        "description": "Schedule write processing for a specific port.",
        "pre": {
            "port": "!=null",
            "port->lock": "held"
        }
    }
},
{
    "kretprobe:uart_update_timeout": {
        "description": "Update per-port frame timing information",
        "pre": {
            "port": "!=null",
            "cflag": "!=null",
            "baud": "!=null"
        }
    }
},
{
    "kprobe:uart_update_timeout": {
        "description": "Update per-port frame timing information",
        "pre": {
            "port": "!=null",
            "cflag": "!=null",
            "baud": "!=null"
        }
    }
},
{
    "kretprobe:uart_get_baud_rate": {
        "description": "Return baud rate for a particular port",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kprobe:uart_get_baud_rate": {
        "description": "Return baud rate for a particular port.",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null",
            "min": "!=null",
            "max": "!=null"
        }
    }
},
{
    "kretprobe:uart_get_divisor": {
        "description": "Return uart clock divisor",
        "pre": {
            "port": "!=null",
            "baud": "!=null",
            "baud_base": "!=null",
            "custom_divisor": "!=38400"
        }
    }
},
{
    "kprobe:uart_get_divisor": {
        "description": "Return uart clock divisor",
        "pre": {
            "port": "!=null",
            "baud": "!=null",
            "baud_base": "!=null",
            "custom_divisor": "!=38400"
        }
    }
},
{
    "kretprobe:if (!console_suspend_enabled && uart_console(uport))": {
        "description": "Check if the console is not suspended and the UART console is enabled.",
        "pre": {
            "console_suspend_enabled": "== false",
            "uart_console(uport)": "!= 0"
        }
    }
},
{
    "kprobe:if": {
        "description": "Check if the console is not suspended and the UART console is enabled for the given uart_port.",
        "pre": {
            "console_suspend_enabled": "==false",
            "uart_console(uport)": "==true"
        }
    }
},
{
    "kretprobe:uart_console": {
        "description": "Check if the UART console is active for the given UART port.",
        "pre": {
            "drv": "!=null",
            "uport": "!=null",
            "state": "!=null",
            "port": "!=null",
            "tty_dev": "!=null",
            "match": "!=null",
            "termios": "!=null",
            "port->mutex": "locked",
            "tty_dev": "child of uport->dev with match and serial_match_port",
            "uport->suspended": "false",
            "device_may_wakeup(tty_dev)": "true",
            "irqd_is_wakeup_set(irq_get_irq_data(uport->irq))": "true",
            "disable_irq_wake(uport->irq)": "called",
            "put_device(tty_dev)": "called",
            "port->mutex": "unlocked"
        }
    }
},
{
    "kprobe:uart_console": {
        "description": "Check if the UART console is active for the given UART port.",
        "pre": {
            "uport": "!=null"
        }
    }
},
{
    "kretprobe:uart_register_driver": {
        "description": "Register a driver with the uart core layer",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kprobe:uart_register_driver": {
        "description": "Register a driver with the uart core layer",
        "pre": {
            "drv": {
                "port": "==null"
            }
        }
    }
},
{
    "kretprobe:uart_unregister_driver": {
        "description": "Remove a driver from the uart core layer.",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kprobe:uart_unregister_driver": {
        "description": "Remove a driver from the uart core layer",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kretprobe:uart_match_port": {
        "description": "Are the two ports equivalent?",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        }
    }
},
{
    "kprobe:uart_match_port": {
        "description": "Are the two ports equivalent?",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        }
    }
},
{
    "kretprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kretprobe:serial8250_resume_port": {
        "description": "Resume one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},
{
    "kprobe:serial8250_resume_port": {
        "description": "Resume one serial port.",
        "pre": {
            "line": "!=null"
        }
    }
},


{
    "kretprobe:serial8250_isa_devs": {
        "description": "This function registers and unregisters 16x50 serial ports at runtime to support PCMCIA modems and PCI multiport cards.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:serial8250_unregister_port": {
        "description": "Unregister a serial port from the 8250 serial driver.",
        "pre": {
            "i": "!=null"
        }
    },
    "kprobe:serial8250_suspend": {
        "description": "Suspend the 8250 serial driver for a platform device.",
        "pre": {
            "dev": "!=null",
            "state": "!=null"
        }
    },
    "kprobe:serial8250_resume": {
        "description": "Resume the 8250 serial driver for a platform device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:serial8250_probe": {
        "description": "Probe the 8250 serial driver for a platform device.",
        "pre": {}
    },
    "kprobe:serial8250_remove": {
        "description": "Remove the 8250 serial driver for a platform device.",
        "pre": {}
    }
},
{
    "kretprobe:serial8250_rpm_get": {
        "description": "Retrieve the RPM value for the serial port.",
        "pre": {
            "up": "!=null",
            "port": "!=null",
            "flags": "!=null",
            "cval": "!=null",
            "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
        }
    }
},
{
    "kprobe:serial8250_rpm_get": {
        "description": "Get the RPM value for the serial port.",
        "pre": {
            "up": "!=null",
            "port->lock": "!=null",
            "cval": "any",
            "baud": "any",
            "quot": "any",
            "frac": "any"
        }
    }
},

{
    "kprobe:convert_ifc_address": {
        "description": "Convert the base address",
        "pre": {
            "addr_base": "!=null",
            "addr_base": "is a valid physical address"
        }
    }
},
{
    "kretprobe:fsl_ifc_find": {
        "description": "Find IFC bank",
        "pre": {
            "addr_base": "!=null"
        },
        "post": {
            "return": "is_int",
            "return >= 0": true
        }
    }
},
{
    "kprobe:fsl_ifc_find": {
        "description": "Find IFC bank",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:of_get_min_tck": {
        "description": "Extract min timing values for ddr",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_get_min_tck": {
        "description": "Extract min timing values for DDR.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_ddr_timings": {
        "description": "Extracts the DDR timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kprobe:of_get_ddr_timings": {
        "description": "Extracts the DDR timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "in [LPDDR2, S2S4]",
            "nr_frequencies": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr3_get_min_tck": {
        "description": "Extract min timing values for lpddr3",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_min_tck": {
        "description": "Extract min timing values for lpddr3",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr3_get_ddr_timings": {
        "description": "Extracts the lpddr3 timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_ddr_timings": {
        "description": "Extracts the lpddr3 timings and updates the number of frequencies available.",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "!=null",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kretprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip.",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of banks referenced by a device",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of banks referenced by a device",
        "pre": {
            "dev": "!=null",
            "dev.child_of": "NEMC",
            "return": ">=0"
        }
    }
},
{
    "kretprobe:jz4780_nemc_set_type": {
        "description": "Set the type of device connected to a bank",
        "pre": {
            "dev": "!=null",
            "bank": "unsigned int",
            "type": "enum jz4780_nemc_bank_type"
        }
    }
},

{
    "kretprobe:jz4780_nemc_assert": {
        "description": "(De-)asserts the chip enable pin for the NAND device connected to the specified bank.",
        "pre": {
            "dev": "!=null",
            "bank": "!=null",
            "assert": "in [true, false]"
        }
    }
},
{
    "kprobe:jz4780_nemc_assert": {
        "description": "(De-)assert a NAND device's chip enable pin",
        "pre": {
            "dev": "!=null",
            "bank": "!=null",
            "assert": "!=null"
        }
    }
},
{
    "kretprobe:regmap_update_bits": {
        "description": "Update bits in the regmap",
        "pre": {
            "rpc->regmap": "!=null",
            "RPCIF_PHYCNT": "!=null",
            "RPCIF_PHYCNT_HS": "!=null",
            "0": "!=null",
            "RPCIF_PHYCNT_PHYMEM_MASK": "!=null",
            "RPCIF_PHYCNT_PHYMEM(hyperflash ? 3 : 0)": "!=null"
        }
    }
},
{
    "kprobe:regmap_update_bits": {
        "description": "Update bits in the regmap",
        "pre": {
            "rpc->regmap": "!=null",
            "RPCIF_PHYCNT": "!=null",
            "RPCIF_PHYCNT_HS": "!=null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "pre": {
            "bytes_left": ">= max",
            "nbytes": "in [1, 2, 4, 8]",
            "bytes_left > nbytes": true,
            "nbytes == 8": false
        }
    }
},
{
    "kretprobe:gpmc_cs_disable_mem": {
        "description": "Disable CS while changing base address and size mask.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num"
        }
    },
    "kretprobe:gpmc_cs_set_memconf": {
        "description": "Set memory configuration for CS.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num",
            "res->start": "!= null",
            "resource_size(res)": "!= null"
        },
        "post": {
            "r": "< 0"
        }
    }
},
{
    "kprobe:gpmc_cs_disable_mem": {
        "description": "Disable CS while changing base address and size mask.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num"
        }
    },
    "kprobe:gpmc_cs_set_memconf": {
        "description": "Set memory configuration for CS.",
        "pre": {
            "cs": ">= 0 and < gpmc_cs_num",
            "res->start": "!= null",
            "resource_size(res)": "!= null"
        }
    }
},
{
    "kretprobe:gpmc_configure": {
        "description": "Write request to configure gpmc",
        "pre": {
            "cmd": "!=null",
            "wval": "!=null"
        },
        "post": {
            "return": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
        }
    }
},
{
    "kprobe:gpmc_configure": {
        "description": "Write request to configure gpmc",
        "pre": {
            "cmd": "!=null",
            "wval": "!=null"
        }
    }
},
{
    "kretprobe:vfio_info_cap_add": {
        "description": "Add a vfio_info_cap_header to the caps list.",
        "pre": {
            "caps": "!=null"
        }
    }
},

{
    "kretprobe:vfio_pin_pages": {
        "description": "Pin pages for VFIO device",
        "pre": {
            "device": "!=null",
            "iova": "!=null",
            "npage": "!=null",
            "prot": "!=null",
            "pages": "!=null",
            "group->container": "cannot change while a vfio device is open"
        },
        "post": {
            "return": "-EINVAL",
            "conditions": [
                "!pages",
                "!npage",
                "WARN_ON(!vfio_assert_device_open(device))",
                "vfio_device_has_container(device)",
                "vfio_device_container_pin_pages(device, iova, npage, prot, pages)",
                "device->iommufd_access"
            ]
        }
    }
},
{
    "kprobe:vfio_pin_pages": {
        "description": "Pin pages for VFIO device",
        "pre": {
            "device": "!=null",
            "iova": "!=null",
            "npage": "!=null",
            "prot": "!=null",
            "pages": "!=null",
            "group->container": "cannot change while a vfio device is open"
        }
    }
},
{
    "kretprobe:vfio_dma_rw": {
        "description": "Perform DMA read or write operation on the VFIO device.",
        "pre": {
            "device": "!=null",
            "iova": "<= ULONG_MAX",
            "data": "!=null",
            "len": "> 0",
            "write": "bool"
        }
    }
},
{
    "kprobe:vfio_dma_rw": {
        "description": "Perform read or write operation on the VFIO device's DMA memory.",
        "pre": {
            "device": "!=null",
            "iova": "<=ULONG_MAX",
            "data": "!=null",
            "len": ">0",
            "write": "bool"
        }
    }
},


{
    "kretprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return_value": "< 0"
        }
    }
},
{
    "kprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mdev_unregister_driver": {
        "description": "Unregister an MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdev_unregister_driver": {
        "description": "Unregister MDEV driver",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pps_register_source": {
        "description": "Add a PPS source in the system",
        "pre": {
            "info": "!=null",
            "default_params": "!=null"
        }
    }
},
{
    "kprobe:pps_register_source": {
        "description": "Add a PPS source in the system",
        "pre": {
            "info": "!=null",
            "default_params": "!=null"
        }
    }
},
{
    "kretprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system",
        "pre": {
            "pps": "!=null"
        }
    }
},
{
    "kprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system",
        "pre": {
            "pps": "!=null"
        }
    }
},




{
    "kretprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "Destroy the rpmsg character device endpoint device.",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "eptdev": "!=null",
            "ept_lock": "!=null",
            "rpdev": "in [null, !=null]",
            "ept": "in [null, !=null]"
        }
    }
},
{
    "kprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "Destroy the rpmsg character device endpoint device.",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "eptdev": "!=null",
            "eptdev->default_ept": "==false",
            "eptdev->ept": "==null",
            "eptdev->ept_lock": "is unlocked"
        }
    }
},
{
    "kretprobe:qcom_smd_register_edge": {
        "description": "Register an edge based on a device_node",
        "pre": {
            "parent": "!=null",
            "node": "!=null"
        }
    }
},

{
    "kretprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children.",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "!=null",
            "chinfo": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint",
        "pre": {
            "ept": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint",
        "pre": {
            "ept": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_send": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_send": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_sendto": {
        "description": "Send a message across to the remote processor, specifying the destination address.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_sendto": {
        "description": "Send a message across to the remote processor, specifying the destination address.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_send_offchannel": {
        "description": "send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:rpmsg_send_offchannel": {
        "description": "Send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_trysend": {
        "description": "Send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_trysend": {
        "description": "send a message across to the remote processor",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_trysendto": {
        "description": "Send a message across to the remote processor, specifying the destination.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_trysendto": {
        "description": "Send a message across to the remote processor, specifying the destination.",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers.",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        },
        "post": {
            "return_value": "in [POLLIN, POLLOUT, POLLERR, POLLHUP, POLLNVAL]"
        }
    }
},
{
    "kprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers.",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_trysend_offchannel": {
        "description": "Send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_trysend_offchannel": {
        "description": "send a message using explicit srcdst addresses",
        "pre": {
            "ept": "!=null",
            "src": "!=null",
            "dst": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message.",
        "pre": {
            "ept": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message.",
        "pre": {
            "ept": "!=null"
        }
    }
},


{
    "kretprobe:__register_rpmsg_driver": {
        "description": "Register an rpmsg driver with the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__register_rpmsg_driver": {
        "description": "Register an rpmsg driver with the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null"
        },
        "post": {
            "return": "in [0, error_value]"
        }
    }
},
{
    "kprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus.",
        "pre": {
            "rpdrv": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev",
        "pre": {
            "rpdev": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev",
        "pre": {
            "rpdev": "!=null"
        }
    }
},

{
    "kprobe:blackhole_netdev": {
        "description": "A device used for dsts that are marked expired!",
        "pre": {
            "blackhole_netdev": "!=null"
        }
    }
},
{
    "kretprobe:mii_link_ok": {
        "description": "Checks if the MII reports link status upok.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_link_ok": {
        "description": "Check if the MII reports link status upok.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface",
        "pre": {
            "mii": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null",
            "ecmd_cleared": "==false"
        }
    }
},
{
    "kprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null",
            "cmd_cleared": "==false"
        }
    }
},
{
    "kprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd.",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd.",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in cmd.",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return_value": ">= -1"
        }
    }
},
{
    "kprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in cmd.",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_link": {
        "description": "Check MII link status",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_link": {
        "description": "Check MII link status",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_media": {
        "description": "Check the MII interface for a carrier speed duplex change",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "!=null",
            "init_media": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:mii_check_media": {
        "description": "Check the MII interface for a carrier speed duplex change.",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "in [0, 1]",
            "init_media": "in [0, 1]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces.",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null",
            "duplex_chg_out": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null",
            "duplex_chg_out": "!=null"
        }
    }
},
{
    "kretprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device.",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "ret": "in [0, 1]"
        }
    }
},
{
    "kprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null"
        }
    }
},
{
    "kretprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null",
            "devad": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "sense": "!=null"
        }
    }
},
{
    "kprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register.",
        "pre": {
            "mdio": "!=null",
            "prtad": "!=null",
            "devad": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "sense": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise.",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": "!=null"
        }
    }
},
{
    "kprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise.",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface",
        "pre": {
            "mdio": "!=null"
        }
    }
},
{
    "kprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface",
        "pre": {
            "mdio": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_gset_npage": {
        "description": "get settings for ETHTOOL_GSET",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kprobe:mdio45_ethtool_gset_npage": {
        "description": "get settings for ETHTOOL_GSET",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "get settings for ETHTOOL_GLINKSETTINGS",
        "pre": {
            "mdio": "!=null",
            "cmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "get settings for ETHTOOL_GLINKSETTINGS",
        "pre": {
            "mdio": "!=null",
            "cmd": "!=null",
            "npage_adv": "!=null",
            "npage_lpa": "!=null"
        }
    }
},
{
    "kretprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "!=null"
        }
    }
},


{
    "kretprobe:s->hdlcrx.bitstream >>= 16;s->hdlcrx.bitstream |= word << 16;s->hdlcrx.bitbuf >>= 16;s->hdlcrx.bitbuf |= word << 16;s->hdlcrx.numbits += 16;for(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00, mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; i >= 0; i--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1, mask5 <<= 1, mask6 = (mask6 << 1) | 1)": {
        "description": "The given function performs various bit operations on the hdlcrx structure.",
        "pre": {
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "word": "!=null",
            "i": ">= 0",
            "mask1": "!=null",
            "mask2": "!=null",
            "mask3": "!=null",
            "mask4": "!=null",
            "mask5": "!=null",
            "mask6": "!=null"
        }
    }
},
{
    "kprobe:s->hdlcrx.bitstream >>= 16;s->hdlcrx.bitstream |= word << 16;s->hdlcrx.bitbuf >>= 16;s->hdlcrx.bitbuf |= word << 16;s->hdlcrx.numbits += 16;for(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00, mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; i >= 0; i--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1, mask5 <<= 1, mask6 = (mask6 << 1) | 1)": {
        "description": "Helper function for HDLC driver receiver.",
        "pre": {
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->hdlcrx.in_hdlc_rx": "== 0",
            "s->hdlcrx.hbuf": "not empty"
        }
    }
},
{
    "kretprobe:hdlcdrv_transmitter": {
        "description": "Transmitter function in HDLCDRV",
        "pre": {
            "pkt_len": ">= HDLCDRV_MAXFLEN || < 2"
        }
    }
},
{
    "kprobe:hdlcdrv_transmitter": {
        "description": "Condition for pkt_len in hdlcdrv_transmitter function",
        "pre": {
            "pkt_len": ">= HDLCDRV_MAXFLEN || < 2"
        }
    }
},
{
    "kretprobe:hdlcdrv_arbitrate": {
        "description": "Arbitrate the network driver interface.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->hdlctx.ptt": "== false",
            "s->skb": "!=null",
            "s->ch_params.fulldup": "== true",
            "s->hdlcrx.dcd": "== true",
            "s->hdlctx.slotcnt": "> 0",
            "get_random_u8()": "<= s->ch_params.ppersist"
        }
    }
},
{
    "kprobe:hdlcdrv_arbitrate": {
        "description": "Arbitrate the HDLC driver",
        "pre": {
            "dev": "any",
            "s": {
                "s != null",
                "s->magic == HDLCDRV_MAGIC",
                "s->hdlctx.ptt == false",
                "s->skb != null",
                "s->ch_params.fulldup in [true, false]",
                "if s->ch_params.fulldup: call start_tx(dev, s)",
                "if s->hdlcrx.dcd: set s->hdlctx.slotcnt = s->ch_params.slottime",
                "if s->hdlctx.slotcnt > 0: return",
                "set s->hdlctx.slotcnt = s->ch_params.slottime",
                "if get_random_u8() > s->ch_params.ppersist: call start_tx(dev, s)"
            }
        }
    }
},
{
    "kretprobe:s = netdev_priv(dev);s->magic = HDLCDRV_MAGIC;s->ops = ops;dev->base_addr = baseaddr;dev->irq = irq;dev->dma = dma;err = register_netdev(dev);if (err < 0)": {
        "description": "Register a network device with the HDLCDRV driver.",
        "pre": {
            "dev": "!=null",
            "ops": "!=null",
            "baseaddr": "!=null",
            "irq": "!=null",
            "dma": "!=null",
            "privsize": ">= sizeof(struct hdlcdrv_state)"
        }
    }
},
{
    "kprobe:netdev_priv": {
        "description": "Get the private data associated with a network device.",
        "pre": {
            "dev": "!=null"
        }
    },
    "kprobe:HDLCDRV_MAGIC": {
        "description": "Set the magic value of the HDLCDRV state.",
        "pre": {
            "s": "!=null",
            "s->magic": "= HDLCDRV_MAGIC"
        }
    },
    "kprobe:HDLCDRV_OPS": {
        "description": "Set the ops value of the HDLCDRV state.",
        "pre": {
            "s": "!=null",
            "s->ops": "= ops"
        }
    },
    "kprobe:dev->base_addr": {
        "description": "Set the base address of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "= baseaddr"
        }
    },
    "kprobe:dev->irq": {
        "description": "Set the IRQ of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->irq": "= irq"
        }
    },
    "kprobe:dev->dma": {
        "description": "Set the DMA of the network device.",
        "pre": {
            "dev": "!=null",
            "dev->dma": "= dma"
        }
    },
    "kprobe:register_netdev": {
        "description": "Register a network device.",
        "pre": {
            "dev": "!=null",
            "err": "< 0"
        }
    }
},
{
    "kretprobe:hdlcdrv_receiver": {
        "description": "Receives data from the HDLC driver.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->opened": "== true",
            "s->ops->receive": "!=null"
        }
    }
},
{
    "kprobe:hdlcdrv_receiver": {
        "description": "Receives data from the HDLC driver.",
        "pre": {
            "dev": "!=null",
            "s": "!=null",
            "s->magic": "== HDLCDRV_MAGIC",
            "s->opened": "== true",
            "s->ops->close": "!=null"
        }
    }
},
{
    "kretprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for the specified net.",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        }
    }
},
{
    "kprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for specified net.",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:chan->ppp = NULL;/* * This ensures that we have returned from any calls into * the channel's start_xmit or ioctl routine before we proceed. */": {
        "description": "Set chan->ppp to NULL to ensure that we have returned from any calls into the channel's start_xmit or ioctl routine before proceeding.",
        "pre": {
            "chan": "!=null"
        },
        "post": {
            "chan->ppp": "==null"
        }
    }
},
{
    "kprobe:chan->ppp = NULL;/* * This ensures that we have returned from any calls into * the channel's start_xmit or ioctl routine before we proceed. */": {
        "description": "Set chan->ppp to NULL to ensure that we have returned from any calls into the channel's start_xmit or ioctl routine before proceeding.",
        "pre": {
            "chan": "!=null",
            "chan->ppp": "==null"
        }
    }
},
{
    "kretprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "pre": {
            "chan": "!=null",
            "pch": "!=null",
            "pch->file.index": "!=null",
            "return value": "-1"
        }
    }
},
{
    "kprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "pre": {
            "chan": "!=null",
            "return": "int",
            "return >= -1"
        }
    }
},
{
    "kretprobe:ppp_dev_name": {
        "description": "Return the PPP device interface name of a channel.",
        "pre": {
            "chan": "!=null"
        }
    }
},

{
    "kretprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "pre": {
            "chan": "!=null"
        }
    }
},

{
    "kprobe:ppp_bridge_channels": {
        "description": "Bridge two channels in a PPP network.",
        "pre": {
            "pch": "!=null",
            "pchb": "!=null",
            "pch->ops->start_xmit": "!=null",
            "pchb->ops->start_xmit": "!=null",
            "pch->bridge_instance": "==null",
            "pchb->bridge_instance": "==null",
            "pch->unit": "==null",
            "pchb->unit": "==null"
        }
    }
},
{
    "kretprobe:ppp_input_error": {
        "description": "We come in here to process a received frame. The receive side of the ppp unit is locked.",
        "pre": {
            "chan": "!=null",
            "code": "!=null",
            "pch": "!=null",
            "skb": "!=null",
            "pch->ppp": "!=null",
            "skb->len": "==0"
        }
    }
},
{
    "kprobe:skb->cb[0] = code;ppp_do_recv(pch->ppp, skb, pch);}}read_unlock_bh(&pch->upl);}/* * We come in here to process a received frame. * The receive side of the ppp unit is locked. `": {
        "description": "This function is used to process a received frame in the ppp unit.",
        "pre": {
            "skb": "!=null",
            "code": "!=null",
            "pch": "!=null",
            "pch->ppp": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kretprobe:ppp_output_wakeup": {
        "description": "Compression control.",
        "pre": {
            "chan": "!=null",
            "pch": "!=null",
            "ppp_channel_push(pch)": "called"
        }
    }
},
{
    "kprobe:ppp_output_wakeup": {
        "description": "Compression control.",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "pre": {
            "cp": "!=null",
            "compress_proto": "!=null",
            "compressor_list_lock": "!=null"
        },
        "post": {
            "ret": "in [-EEXIST, -ENOMEM, 0]"
        }
    }
},
{
    "kprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "pre": {
            "cp": "!=null",
            "compress_proto": "!=null",
            "compressor_list_lock": "!=null",
            "compressor_list": "!=null",
            "ret": "in [-EEXIST, -ENOMEM, 0]"
        }
    }
},
{
    "kretprobe:find_compressor": {
        "description": "Find a compressor.",
        "pre": {
            "type": "is_integer"
        },
        "post": {
            "return": "is_pointer",
            "return_constraints": {
                "if return != null": {
                    "return->compress_proto": "type"
                }
            }
        }
    }
},


{
    "kprobe:pppox_unbind_sock": {
        "description": "Clear connection to ppp device, if attached.",
        "pre": {
            "sk": {
                "sk_state": "&",
                "value": "in [PPPOX_BOUND, PPPOX_CONNECTED]"
            }
        }
    }
},


{
    "kretprobe:lan9303_probe": {
        "description": "Probe function for lan9303",
        "pre": {
            "chip->reset_duration": ">1000",
            "chip->reset_duration": "=1000"
        },
        "post": {
            "return": "=0"
        }
    }
},
{
    "kprobe:lan9303_probe": {
        "description": "Probe function for lan9303",
        "pre": {
            "chip->reset_duration": ">1000",
            "chip->reset_duration": "=1000",
            "np": "!=null"
        }
    }
},


{
    "kprobe:dev->info = info;dev_info(dev->dev, \"found switch: %s, rev %i\\n\", dev->info->dev_name, dev->chip_rev);ret = ksz_check_device_id(dev);if (ret)return ret;dev->dev_ops = dev->info->ops;ret = dev->dev_ops->init(dev);if (ret)return ret;dev->ports = devm_kzalloc(dev->dev,  dev->info->port_cnt * sizeof(struct ksz_port),  GFP_KERNEL);if (!dev->ports)return -ENOMEM;for (i = 0; i < dev->info->port_cnt; i++)": {
        "description": "Register a KSZ switch device",
        "pre": {
            "dev": "!=null",
            "info": "!=null",
            "dev->dev": "!=null",
            "dev->info->dev_name": "!=null",
            "dev->chip_rev": "!=null",
            "ret": "!=null",
            "dev->info->ops": "!=null",
            "dev->dev_ops": "!=null",
            "dev->ports": "!=null",
            "dev->info->port_cnt": "!=null",
            "i": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "dev": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "pre": {
            "ds": "!=null",
            "port": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:b53_fdb_add": {
        "description": "Add a forwarding database entry to the b53 device.",
        "pre": {
            "ds": "!=null",
            "port": "int",
            "addr": "!=null",
            "vid": "u16",
            "db": "!=null",
            "priv": "!=null",
            "ret": "int"
        },
        "post": {
            "ret": "int"
        }
    }
},
{
    "kprobe:b53_fdb_add": {
        "description": "Add a forwarding database entry to the B53 switch.",
        "pre": {
            "ds": "!=null",
            "port": "int",
            "addr": "!=null",
            "vid": "u16",
            "db": "!=null",
            "priv": "!=null",
            "ret": "int"
        }
    }
},
S,
S,
S,
{
    "kprobe:b53_mdb_add": {
        "description": "Add an entry to the MDB (Multicast Database) of a B53 switch.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "mdb": "!=null",
            "db": "!=null",
            "priv": "!=null",
            "ret": "!=null",
            "is5325(priv) || is5365(priv)": "true",
            "mutex_lock(&priv->arl_mutex)": "true",
            "b53_arl_op(priv, 0, port, mdb->addr, mdb->vid, true)": "ret",
            "mutex_unlock(&priv->arl_mutex)": "true",
            "return": "ret"
        }
    }
},
S,
{
    "kprobe:b53_br_join": {
        "description": "Join a bridge in the b53 switch driver.",
        "pre": {
            "dev->chip_id": "== BCM7278_DEVICE_ID",
            "port": "== 7"
        },
        "return": "-EINVAL",
        "comment": "Make this port leave the all VLANs join since we will have proper VLAN entries from now on."
    }
},
{
    "kretprobe:b53_br_leave": {
        "description": "Leave a bridge for a specific port",
        "pre": {
            "dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge)": true,
            "b53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg)": true,
            "reg &= ~BIT(port)": true,
            "b53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg)": true,
            "dev->ports[port].vlan_ctl_mask = reg": true
        },
        "post": {}
    }
},
{
    "kprobe:b53_br_leave": {
        "description": "Leave a bridge for a specific port in a DSA switch.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "bridge": "!=null"
        }
    }
},
S,
{
    "kprobe:[function name]": {
        "description": "[description of the function]",
        "pre": {
            "[argument1]": "[condition1]",
            "[argument2]": "[condition2]",
            ...
        }
    }
},
{
    "kretprobe:b53_mirror_del": {
        "description": "Update the desired ingress/egress register.",
        "pre": {
            "ds": "!=null",
            "port": "!=null",
            "mirror": "!=null",
            "dev": "!=null",
            "loc_disable": "false",
            "other_loc_disable": "false",
            "reg": "!=null",
            "loc": "!=null",
            "mirror->ingress": "in [true, false]",
            "loc": "in [B53_IG_MIR_CTL, B53_EG_MIR_CTL]"
        }
    }
},
{
    "kprobe:b53_read16": {
        "description": "Read a 16-bit value from the specified device and location.",
        "pre": {
            "dev": "!=null",
            "B53_MGMT_PAGE": "!=null",
            "loc": "!=null",
            "&reg": "!=null",
            "port": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:__set_bit": {
        "description": "Set a bit in the supported_interfaces field of the config structure.",
        "pre": {
            "config": "!=null",
            "config->supported_interfaces": "!=null",
            "PHY_INTERFACE_MODE_GMII": "!=null"
        }
    }
},
S,
{
    "kretprobe:b53_switch_alloc": {
        "description": "Allocate and initialize a b53 switch.",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:b53_switch_alloc": {
        "description": "Allocate and initialize a b53 switch",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "!=null"
        }
    }
},
S,
{
    "kprobe:b53_write16": {
        "description": "Write 16 bits to the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_VLAN_PAGE": "!=null",
            "B53_VLAN_TABLE_ACCESS_25": "!=null",
            "0xf": "!=null"
        }
    },
    "kprobe:b53_read16": {
        "description": "Read 16 bits from the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_VLAN_PAGE": "!=null",
            "B53_VLAN_TABLE_ACCESS_25": "!=null",
            "&tmp": "!=null"
        }
    },
    "kprobe:dev->chip_id = BCM5325_DEVICE_ID": {
        "description": "Set the chip ID to BCM5325_DEVICE_ID if tmp is equal to 0xf.",
        "pre": {
            "tmp": "==0xf"
        }
    },
    "kprobe:dev->chip_id = BCM5365_DEVICE_ID": {
        "description": "Set the chip ID to BCM5365_DEVICE_ID if tmp is not equal to 0xf.",
        "pre": {
            "tmp": "!=0xf"
        }
    },
    "kprobe:break": {
        "description": "Break from the switch statement.",
        "pre": {}
    },
    "kprobe:case BCM5389_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5395_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5397_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:case BCM5398_DEVICE_ID": {
        "description": "Set the chip ID to the value of id8.",
        "pre": {}
    },
    "kprobe:ret = b53_read32": {
        "description": "Read 32 bits from the specified register in the B53 switch.",
        "pre": {
            "dev": "!=null",
            "B53_MGMT_PAGE": "!=null",
            "B53_DEVICE_ID": "!=null",
            "&id32": "!=null"
        }
    },
    "kprobe:if (ret)": {
        "description": "Check if the return value of b53_read32 is non-zero.",
        "pre": {}
    },
    "kprobe:switch (id32)": {
        "description": "Switch statement based on the value of id32.",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:mt76_wcid_key_setup": {
        "description": "Setup the key for the mt76_wcid structure.",
        "pre": {
            "dev": "!=null",
            "wcid": "!=null",
            "key": "!=null",
            "key->cipher": "==WLAN_CIPHER_SUITE_CCMP"
        }
    }
},
S,
S,
S,
{
    "kretprobe:memset": {
        "description": "Initialize the pktq structure by setting the specified number of precursors to zero.",
        "pre": {
            "pq": "!=null",
            "num_prec": ">= 0",
            "max_len": ">= 0",
            "prec": ">= 0",
            "prec": "< num_prec"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Initialize the pktq structure by zeroing out the requested number of precursors.",
        "pre": {
            "pq": "!=null",
            "num_prec": ">=0",
            "max_len": ">=0",
            "prec": ">=0",
            "prec < num_prec": true
        }
    }
},
{
    "kretprobe:ath_hw_setbssidmask": {
        "description": "Filter out bssids we listen",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kprobe:ath_hw_setbssidmask": {
        "description": "Filter out bssids we listen",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kretprobe:ath_hw_cycle_counters_update": {
        "description": "common function to update cycle counters",
        "pre": {
            "common": "!=null",
            "common->cc_lock": "held"
        }
    }
},
{
    "kprobe:ath_hw_cycle_counters_update": {
        "description": "Common function to update cycle counters in the ath_common struct for the device.",
        "pre": {
            "common": "!=null",
            "common->cc_lock": "held"
        }
    }
},
{
    "kretprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address for a key in the key cache.",
        "pre": {
            "common": "!=null",
            "entry": ">=0",
            "mac": "!=null"
        },
        "post": {
            "return": "bool"
        }
    }
},
{
    "kprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address for a key in the key cache.",
        "pre": {
            "common": "!=null",
            "entry": ">=0",
            "mac": "!=null",
            "unicast_flag": "=AR_KEYTABLE_VALID",
            "ah": "!=null",
            "entry": "<common->keymax",
            "mac": "!=NULL"
        }
    }
},
{
    "kretprobe:idx = key->keyidx;} elsereturn -EIO;} else": {
        "description": "Set the value of 'idx' based on 'key->keyidx' and return -EIO if not satisfied.",
        "pre": {
            "key": "!=null",
            "key->keyidx": "!=null",
            "idx": ">= 0"
        }
    }
},
{
    "kprobe:ath_key_config": {
        "description": "Configure the ATH key.",
        "pre": {
            "common": "any",
            "vif": "any",
            "sta": "any",
            "key": {
                "cipher": "in [0, WLAN_CIPHER_SUITE_WEP40, WLAN_CIPHER_SUITE_WEP104, WLAN_CIPHER_SUITE_TKIP, WLAN_CIPHER_SUITE_CCMP]",
                "keylen": ">0",
                "key": "!=null",
                "flags": "!& IEEE80211_KEY_FLAG_PAIRWISE",
                "vif.type": "in [NL80211_IFTYPE_AP, NL80211_IFTYPE_ADHOC]",
                "vif.addr": "!=null",
                "gmac[0]": "= vif.addr[0] | 0x01",
                "sta.addr": "!=null",
                "gmac[0]": "= sta.addr[0] | 0x01",
                "key.keyidx": ">0",
                "sta": "!=null",
                "mac": "= sta.addr"
            }
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:ath_reg_apply_radar_flags": {
        "description": "Apply radar flags for custom regulatory request",
        "pre": {
            "wiphy": "!=null",
            "request": "!=null",
            "reg": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath_rxbuf_alloc": {
        "description": "Cache-line-align. This is important (for the 5210 at least) as not doing so causes bogus data in rx'd frames.",
        "pre": {
            "common": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:ath_rxbuf_alloc": {
        "description": "Cache-line-align. This is important (for the 5210 at least) as not doing so causes bogus data in rx'd frames.",
        "pre": {
            "common": "!=null",
            "len": "!=null",
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_wmi_shutdown": {
        "description": "Shutdown the WMI module in ath6kl.",
        "pre": {
            "ar": "!=null",
            "ar->wmi": "!=null",
            "ar->flag": "!=null",
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_wmi_shutdown": {
        "description": "Shutdown the WMI module in ath6kl.",
        "pre": {
            "ar": "!=null",
            "ar->wmi": "!=null",
            "ar->flag": "!=null",
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_core_init": {
        "description": "Initialize the ath6kl core.",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]"
        },
        "post": {
            "ret": "==0",
            "ar->ath6kl_wq": "!=null",
            "ret": "==0"
        }
    },
    "kretprobe:ath6kl_hif_power_on": {
        "description": "Turn on power to get hardware (target) version.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_bmi_get_target_info": {
        "description": "Get target information from BMI.",
        "pre": {
            "ar": "!=null",
            "targ_info": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_bmi_init": {
        "description": "Initialize BMI.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_init_hw_params": {
        "description": "Initialize hardware parameters.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    },
    "kretprobe:ath6kl_htc_create": {
        "description": "Create HTC target.",
        "pre": {
            "ar": "!=null"
        },
        "post": {
            "ar->htc_target": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_core_init": {
        "description": "Initialize the ath6kl core.",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]"
        }
    },
    "kprobe:ath6kl_htc_mbox_attach": {
        "description": "Attach ath6kl HTC mailbox.",
        "pre": {
            "ar": "!=null"
        }
    },
    "kprobe:ath6kl_htc_pipe_attach": {
        "description": "Attach ath6kl HTC pipe.",
        "pre": {
            "ar": "!=null"
        }
    },
    "kprobe:ath6kl_bmi_init": {
        "description": "Initialize the ath6kl BMI.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kretprobe:ath6kl_core_create": {
        "description": "Create the ath6kl core structure.",
        "pre": {
            "dev": "!=null",
            "ar": "!=null",
            "ctr": ">=0",
            "ctr": "<AP_MAX_NUM_STA"
        }
    }
},
{
    "kprobe:ath6kl_core_create": {
        "description": "Create the ath6kl core structure.",
        "pre": {
            "dev": "!=null",
            "ctr": ">=0",
            "ctr": "<AP_MAX_NUM_STA"
        }
    }
},
{
    "kretprobe:trace_ath6kl_log_dbg_dump": {
        "description": "Logs debug information with optional message and prefix, and dumps buffer in hex format.",
        "pre": {
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kprobe:trace_ath6kl_log_dbg_dump": {
        "description": "Logs debug information and dumps a hex representation of a buffer.",
        "pre": {
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:ath6kl_tx_data_cleanup": {
        "description": "Clean up function for transmitting data in ath6kl.",
        "pre": {
            "ar": "!=null",
            "prev_state": "!=null",
            "ret": "!=null",
            "wow": "!=null"
        }
    }
},
{
    "kprobe:ath6kl_tx_data_cleanup": {
        "description": "Clean up the transmission data in ath6kl.",
        "pre": {
            "ar": "!=null",
            "prev_state": "!=null",
            "ret": "!=null",
            "wow": "!=null",
            "mode": "in [ATH6KL_CFG_SUSPEND_WOW]"
        }
    }
},
{
    "kretprobe:ath9k_cmn_beacon_config_sta": {
        "description": "No need to configure beacon if we are not associated",
        "pre": {
            "common": {
                "op_flags": "!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)"
            }
        }
    }
},
{
    "kprobe:ath9k_cmn_beacon_config_sta": {
        "description": "Check if the bit ATH_OP_PRIM_STA_VIF is not set in the op_flags field of the common structure.",
        "pre": {
            "common.op_flags": "not test_bit(ATH_OP_PRIM_STA_VIF)"
        }
    }
},
{
    "kretprobe:conf->intval = TU_TO_USEC(conf->beacon_interval)": {
        "description": "Convert the beacon interval from TU to microseconds and assign it to conf->intval.",
        "pre": {
            "conf": "!=null",
            "conf->beacon_interval": "!=null"
        },
        "post": {
            "conf->intval": "= TU_TO_USEC(conf->beacon_interval)"
        }
    }
},
{
    "kprobe:ath9k_cmn_beacon_config_ap": {
        "description": "Configure the beacon for an access point.",
        "pre": {
            "ah": "!=null",
            "conf": "!=null",
            "bc_buf": "!=null",
            "conf->intval": "!=null",
            "conf->intval": "/= bc_buf",
            "conf->nexttbtt": "= ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah), conf->beacon_interval)",
            "conf->enable_beacon": "= true",
            "ah->imask": "|= ATH9K_INT_SWBA",
            "conf->beacon_interval": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath9k_hw_btcoex_init_2wire": {
        "description": "Connect bt_active to baseband.",
        "pre": {
            "ah": "!=null",
            "btcoex_hw": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for Bluetooth and WLAN coexistence.",
        "pre": {
            "ah": "!=null",
            "bt_weight": "!=null",
            "wlan_weight": "!=null",
            "stomp_type": "in [0, 1, 2, 3]",
            "mci_hw": "!=null",
            "concur_tx": "==true",
            "btcoex_hw": "!=null",
            "tx_prio[stomp_type]": "!=null",
            "ar9003_wlan_weights[stomp_type]": "!=null",
            "i": "!=null",
            "AR_SREV_9300_20_OR_LATER(ah)": "==false"
        }
    }
},
{
    "kprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for Bluetooth and WLAN coexistence in the ATH9K hardware.",
        "pre": {
            "ah": "!=null",
            "bt_weight": "!=null",
            "wlan_weight": "!=null",
            "stomp_type": "in [0, 1, 2, 3]",
            "mci_hw": "!=null",
            "btcoex_hw": "!=null",
            "mci_hw.concur_tx": "==true",
            "btcoex_hw.tx_prio[stomp_type]": "==true",
            "ar9003_wlan_weights[stomp_type]": "!=null",
            "i": "!=null",
            "AR_SREV_9300_20_OR_LATER(ah)": "==false"
        }
    }
},
{
    "kretprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": "!=null",
            "btcoex_hw->wlanactive_gpio": "is a valid GPIO port",
            "btcoex_hw->wlanactive_gpio": "is configured as an output",
            "btcoex_hw->wlanactive_gpio": "is configured as TX_FRAME output",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME when AR9002",
            "btcoex_hw->wlanactive_gpio": "is configured as muxed with AR_GPIO_OUTPUT_MUX_AS_TX_FRAME when AR9003 and above"
        }
    }
},
{
    "kprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": "!=null",
            "btcoex_hw->wlanactive_gpio": "is a valid GPIO port",
            "btcoex_hw->wlanactive_gpio": "is configured as an output",
            "btcoex_hw->wlanactive_gpio": "is configured as TX_FRAME output",
            "btcoex_hw->wlanactive_gpio": "is configured as AR_GPIO_OUTPUT_MUX_AS_TX_FRAME",
            "btcoex_hw->wlanactive_gpio": "is configured for AR9002 or above",
            "btcoex_hw->wlanactive_gpio": "is configured for AR9003 or above"
        }
    }
},
{
    "kretprobe:ath9k_hw_btcoex_bt_stomp": {
        "description": "Configures appropriate weight based on stomp type.",
        "pre": {
            "ah": "!=null",
            "stomp_type": "unknown constraints"
        }
    }
},
{
    "kprobe:ath9k_hw_btcoex_bt_stomp": {
        "description": "Configures appropriate weight based on stomp type.",
        "pre": {
            "ah": "!=null",
            "stomp_type": "in [ATH_BTCOEX_STOMP_NONE, ...]"
        }
    }
},
{
    "kretprobe:ar9003_paprd_enable": {
        "description": "Enable or disable PAPRD for different sub-bands in the 5GHz band.",
        "pre": {
            "ah": "!=null",
            "val": "!=null",
            "chan": "!=null",
            "is2ghz": "==false",
            "modalHeader5G.papdRateMaskHt20": "!=null",
            "modalHeader5G.papdRateMaskHt20[30]": "==0",
            "modalHeader5G.papdRateMaskHt20[29]": "==0",
            "modalHeader5G.papdRateMaskHt20[28]": "==0"
        }
    }
},
{
    "kprobe:ar9003_paprd_enable": {
        "description": "Enable or disable PAPRD for different sub-bands in the 5GHz band.",
        "pre": {
            "ah": "!=null",
            "val": "!=null",
            "chan": "!=null",
            "is2ghz": "==false",
            "modalHeader5G.papdRateMaskHt20": "& 0x40000000 == 0",
            "modalHeader5G.papdRateMaskHt20": "& 0x20000000 == 0",
            "modalHeader5G.papdRateMaskHt20": "& 0x10000000 == 0"
        }
    }
},
{
    "kretprobe:REG_RMW_FIELD": {
        "description": "Modify a register field with a new value.",
        "pre": {
            "ah": "!=null",
            "AR_PHY_PAPRD_CTRL1_B2": "!=null",
            "AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL": "!=null",
            "training_power": "!=null"
        }
    }
},
{
    "kprobe:REG_RMW_FIELD": {
        "description": "Modify a register field using a read-modify-write operation.",
        "pre": {
            "ah": "!=null",
            "AR_PHY_PAPRD_CTRL1_B2": "!=null",
            "AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL": "!=null",
            "training_power": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_paprd_is_done": {
        "description": "Check if PAPRD training is done and return the result.",
        "pre": {
            "ah": "!=null",
            "paprd_done": "==0x1",
            "agc2_pwr": "<=PAPRD_IDEAL_AGC2_PWR_RANGE"
        }
    }
},
{
    "kprobe:ar9003_paprd_is_done": {
        "description": "Check if PAPRD training is done and AGC2 power is within the ideal range.",
        "pre": {
            "ah": "!=null",
            "paprd_done": "==1",
            "agc2_pwr": "<=PAPRD_IDEAL_AGC2_PWR_RANGE"
        }
    }
},
{
    "kretprobe:ath9k_hw_loadnf": {
        "description": "Try to get calibrated noise floor value",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "h": "null or !=null",
            "i": ">=0 and <NUM_NF_READINGS",
            "j": ">=0",
            "chainmask": ">=0",
            "common": "!=null",
            "default_nf": "!=null",
            "bb_agc_ctl": "!=null",
            "nfval": "!=null",
            "ah->caldata": "null or !=null",
            "ah->caldata->nfCalHist": "null or !=null",
            "ah->nf_override": "null or !=null",
            "h[i].privNF": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_loadnf": {
        "description": "Try to get calibrated noise floor value",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "h": "in [null, !=null]",
            "i": ">=0",
            "j": ">=0",
            "chainmask": ">=0",
            "common": "!=null",
            "default_nf": "!=null",
            "bb_agc_ctl": "!=null",
            "nfval": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_hw_bstuck_nfcal": {
        "description": "Trigger a noise floor calibration to recover from stuck beacons.",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null",
            "caldata->cal_flags": "!test_bit(NFCAL_PENDING, &caldata->cal_flags)",
            "REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) & AR_PHY_AGC_CONTROL_NF": "==0"
        }
    }
},
{
    "kprobe:ath9k_hw_bstuck_nfcal": {
        "description": "If beacons are stuck, trigger a noise floor calibration to adapt to a noisy environment.",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:result = MS": {
        "description": "While receiving unsupported rate frame rx state machine gets into a state 0xb and if phy_restart happens in that state, BB would go hang. If RXSM is in 0xb state after first bb panic, ensure to disable the phy_restart.",
        "pre": {
            "ah": "!=null",
            "ah->bb_watchdog_last_status": "==0xb",
            "AR_PHY_WATCHDOG_RX_OFDM_SM": "!=null",
            "result": "!=null",
            "result": "==0xb",
            "ah->bb_hang_rx_ofdm": "!=null"
        }
    }
},
{
    "kprobe:result = MS": {
        "description": "Perform a bitwise shift operation on ah->bb_watchdog_last_status with AR_PHY_WATCHDOG_RX_OFDM_SM and assign the result to 'result'. If 'result' is equal to 0xb or ah->bb_hang_rx_ofdm is true, then execute the following code.",
        "pre": {
            "ah": "!=null",
            "ah->bb_watchdog_last_status": "!=null",
            "AR_PHY_WATCHDOG_RX_OFDM_SM": "!=null",
            "result": "!=null",
            "result == 0xb || ah->bb_hang_rx_ofdm": "true"
        }
    }
},
{
    "kretprobe:ath9k_hw_updatetxtriglevel": {
        "description": "adjusts the frame trigger level",
        "pre": {
            "ah": "!=null",
            "bIncTrigLevel": "!=null",
            "ah": "is a struct of type ath_hw",
            "bIncTrigLevel": "is a boolean",
            "frame_trigger_level": ">= 0",
            "frame_trigger_level": "<= 384 if ah is a dual stream device",
            "frame_trigger_level": "<= 2048 if ah is a single stream device"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_resettxqueue": {
        "description": "Reset the transmit queue.",
        "pre": {
            "AR_SREV_9300_20_OR_LATER(ah)": true,
            "ah->opmode": "!= NL80211_IFTYPE_ADHOC"
        }
    }
},
{
    "kprobe:ath9k_hw_resettxqueue": {
        "description": "Reset the transmit queue.",
        "pre": {
            "AR_SREV_9300_20_OR_LATER(ah)": true,
            "ah->opmode": "!=NL80211_IFTYPE_ADHOC"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ath9k_hw_init_config": {
        "description": "Initialize the configuration of the ath9k hardware.",
        "pre": {
            "num_possible_cpus()": "> 1",
            "ah->config.serialize_regmode": "SER_REG_MODE_AUTO",
            "NR_CPUS": "> 1",
            "ah->config.serialize_regmode == SER_REG_MODE_AUTO": "true"
        }
    }
},
{
    "kprobe:ath9k_hw_init_config": {
        "description": "Initialize the configuration of the ath9k hardware.",
        "pre": {
            "num_possible_cpus()": "> 1",
            "ah->config.serialize_regmode": "SER_REG_MODE_AUTO",
            "NR_CPUS": "> 1"
        }
    }
},
{
    "kretprobe:ath9k_hw_init_global_settings": {
        "description": "Initialize global settings for ath9k_hw.",
        "pre": {
            "ah": "!=null",
            "ah->curchan": "!=null",
            "ah->misc_mode": "==0",
            "IS_CHAN_A_FAST_CLOCK(ah, ah->curchan)": "in [true, false]",
            "IS_CHAN_5GHZ(ah->curchan)": "in [true, false]",
            "IS_CHAN_HALF_RATE(ah->curchan)": "in [true, false]",
            "IS_CHAN_QUARTER_RATE(ah->curchan)": "in [true, false]",
            "AR_SREV_9287(ah)": "in [true, false]",
            "AR_SREV_9287_13_OR_LATER(ah)": "in [true, false]"
        },
        "post": {
            "slottime": "!=null",
            "acktimeout": "!=null",
            "ctstimeout": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_init_global_settings": {
        "description": "Initialize global settings for ath9k_hw.",
        "pre": {
            "ah": "!=null",
            "chan": "!=null",
            "acktimeout": "!=null",
            "ctstimeout": "!=null",
            "ack_offset": "!=null",
            "slottime": "!=null",
            "sifstime": "!=null",
            "rx_lat": "!=null",
            "tx_lat": "!=null",
            "eifs": "!=null",
            "ack_shift": "!=null",
            "reg": "!=null"
        }
    }
},
{
    "kretprobe:if (REG_READ(ah, AR_CFG) == 0xdeadbeef)": {
        "description": "Check if REG_READ(ah, AR_CFG) is equal to 0xdeadbeef",
        "pre": {
            "ah": "!=null",
            "AR_CFG": "== 0xdeadbeef"
        }
    },
    "kretprobe:if (AR_SREV_9300(ah))": {
        "description": "Check if AR_SREV_9300(ah) is true",
        "pre": {
            "ah": "!=null"
        }
    },
    "kretprobe:if (AR_SREV_9285_12_OR_LATER(ah))": {
        "description": "Check if AR_SREV_9285_12_OR_LATER(ah) is true",
        "pre": {
            "ah": "!=null"
        }
    },
    "kretprobe:last_val = REG_READ(ah, AR_OBS_BUS_1)": {
        "description": "Assign the value of REG_READ(ah, AR_OBS_BUS_1) to last_val",
        "pre": {
            "ah": "!=null",
            "AR_OBS_BUS_1": "!=null"
        }
    }
},
{
    "kprobe:if (REG_READ(ah, AR_CFG) == 0xdeadbeef)return false;if (AR_SREV_9300(ah))return !ath9k_hw_detect_mac_hang(ah);if (AR_SREV_9285_12_OR_LATER(ah))return true;last_val = REG_READ(ah, AR_OBS_BUS_1);do": {
        "description": "Function with multiple conditions",
        "pre": {
            "REG_READ(ah, AR_CFG)": "== 0xdeadbeef",
            "AR_SREV_9300(ah)": "true",
            "ath9k_hw_detect_mac_hang(ah)": "false",
            "AR_SREV_9285_12_OR_LATER(ah)": "true",
            "REG_READ(ah, AR_OBS_BUS_1)": "!= null"
        }
    }
},
{
    "kretprobe:ath9k_hw_ar9330_reset_war": {
        "description": "Reset WMAC if doing a cold reset or if there are pending frames in the TX queues.",
        "pre": {
            "ah": "!=null",
            "type": "int"
        }
    }
},
{
    "kprobe:ath9k_hw_ar9330_reset_war": {
        "description": "Reset AR9330 WAR: call external reset function to reset WMAC if doing a cold reset or if there are pending frames in the TX queues.",
        "pre": {
            "ah": "!=null",
            "type": "int"
        }
    }
},
{
    "kretprobe:switch (ah->hw_version.devid)": {
        "description": "Check the hardware version and perform specific actions based on the device ID.",
        "pre": {
            "ah": "!=null",
            "ah->hw_version.devid": "!=null",
            "ah->hw_version.devid": "in [AR5008, AR9001, AR9002, AR9003]"
        }
    }
},
S,
{
    "kretprobe:REG_WRITE": {
        "description": "Write a value to a register.",
        "pre": {
            "ah": "!=null",
            "AR_TSFOOR_THRESHOLD": "!=null",
            "bs->bs_tsfoor_threshold": "!=null"
        }
    }
},
{
    "kprobe:REG_WRITE": {
        "description": "Write a value to a register.",
        "pre": {
            "ah": "!=null",
            "AR_TSFOOR_THRESHOLD": "!=null",
            "bs->bs_tsfoor_threshold": "!=null"
        }
    }
},
{
    "kretprobe:ah->radar_conf.ext_channel = IS_CHAN_HT40(chan);ath9k_hw_set_radar_params(ah);return 0;": {
        "description": "Set radar configuration and return 0.",
        "pre": {
            "ah": "!=null",
            "chan": "!=null"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ath9k_hw_chip_test": {
        "description": "Check if the chip is working correctly.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_chip_test": {
        "description": "Disable PCIe for all families including legacy.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_hw_init_desc": {
        "description": "Initialize the descriptor for the ath9k_hw module.",
        "pre": {
            "AR_ISR": "= ~0",
            "AR_RSSI_THR": "= INIT_RSSI_THR",
            "ah->opmode": "= ah->opmode"
        }
    }
},
S,
S,
S,
{
    "kretprobe:if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))": {
        "description": "Condition for the kretprobe function if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))",
        "pre": {
            "ah": "!=null",
            "tsf": "!=null"
        },
        "post": {
            "AR_SREV_9100(ah)": "true",
            "ath9k_hw_gettsf64(ah) < tsf": "true"
        }
    }
},
{
    "kprobe:if (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf))": {
        "description": "Condition for the given function",
        "pre": {
            "AR_SREV_9100(ah)": true,
            "ath9k_hw_gettsf64(ah) < tsf": true
        }
    }
},
{
    "kretprobe:timer_table->timers[timer_index] = timer;timer->index = timer_index;timer->trigger = trigger;timer->overflow = overflow;timer->arg = arg;if ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled)": {
        "description": "Allocate a hardware generic timer slot",
        "pre": {
            "timer_table": "!=null",
            "timer": "!=null",
            "timer_index": ">= AR_FIRST_NDP_TIMER && < ATH_MAX_GEN_TIMER",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index > AR_FIRST_NDP_TIMER && !timer_table->tsf2_enabled": "true"
        }
    }
},
{
    "kprobe:timer_table->timers[timer_index] = timer;timer->index = timer_index;timer->trigger = trigger;timer->overflow = overflow;timer->arg = arg;if ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled)": {
        "description": "Allocate a hardware generic timer slot",
        "pre": {
            "timer_table": "!=null",
            "timer": "!=null",
            "timer_index": ">= AR_FIRST_NDP_TIMER && < ATH_MAX_GEN_TIMER",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index > AR_FIRST_NDP_TIMER && !timer_table->tsf2_enabled": true
        }
    }
},
S,
S,
{
    "kretprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "pre": {
            "ah": "!=null",
            "timer": "!=null",
            "timer_table": "!=null",
            "timer_table->timers[timer->index]": "==null"
        }
    }
},
{
    "kprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "pre": {
            "ah": "!=null",
            "timer": "!=null"
        }
    }
},
{
    "kretprobe:ath_gen_timer_isr": {
        "description": "Get hardware generic timer interrupt status",
        "pre": {
            "trigger_mask": "!=null",
            "thresh_mask": "!=null",
            "trigger_mask": "&= timer_table->timer_mask",
            "thresh_mask": "&= timer_table->timer_mask",
            "index": "for_each_set_bit(&thresh_mask, ARRAY_SIZE(timer_table->timers))"
        }
    }
},
{
    "kprobe:trigger_mask = ah->intr_gen_timer_trigger;thresh_mask = ah->intr_gen_timer_thresh;trigger_mask &= timer_table->timer_mask;thresh_mask &= timer_table->timer_mask;for_each_set_bit(index, &thresh_mask, ARRAY_SIZE(timer_table->timers))": {
        "description": "Get hardware generic timer interrupt status",
        "pre": {
            "ah": "!=null",
            "timer_table": "!=null",
            "trigger_mask": "!=null",
            "thresh_mask": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:AR_SREV_9280_20_OR_LATER": {
        "description": "Check if the AR_SREV is 9280 or later",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
S,
{
    "kretprobe:memset": {
        "description": "Set the memory block starting at &ht_info->mcs to zero.",
        "pre": {
            "&ht_info->mcs": "!=null"
        }
    },
    "kretprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams based on the given txchainmask and max_streams.",
        "pre": {
            "ah->txchainmask": "!=null",
            "max_streams": "!=null"
        }
    },
    "kretprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams based on the given rxchainmask and max_streams.",
        "pre": {
            "ah->rxchainmask": "!=null",
            "max_streams": "!=null"
        }
    },
    "kretprobe:ath_dbg": {
        "description": "Print the number of TX streams and RX streams.",
        "pre": {
            "common": "!=null",
            "CONFIG": "!=null",
            "tx_streams": "!=null",
            "rx_streams": "!=null"
        }
    },
    "kretprobe:if": {
        "description": "Check if the number of TX streams is not equal to the number of RX streams.",
        "pre": {
            "tx_streams": "!=rx_streams"
        }
    }
},
{
    "kprobe:memset": {
        "description": "Set the memory at ht_info->mcs to zero.",
        "pre": {
            "ht_info": {
                "mcs": "0"
            }
        }
    },
    "kprobe:ath9k_cmn_count_streams": {
        "description": "Count the number of streams for txchainmask and rxchainmask.",
        "pre": {
            "ah": "!=null",
            "txchainmask": "!=null",
            "max_streams": "!=null",
            "rxchainmask": "!=null"
        }
    },
    "kprobe:ath_dbg": {
        "description": "Print the number of TX streams and RX streams.",
        "pre": {
            "common": "!=null",
            "CONFIG": "!=null",
            "tx_streams": "!=null",
            "rx_streams": "!=null"
        }
    },
    "kprobe:if": {
        "description": "Check if the number of TX streams is not equal to the number of RX streams.",
        "pre": {
            "tx_streams": "!=rx_streams"
        }
    }
},
{
    "kretprobe:rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);if (rxsp->status11 & AR_RxKeyIdxValid)rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);elserxs->rs_keyix = ATH9K_RXKEYIX_INVALID;rxs->rs_rate = MS(rxsp->status1, AR_RxRate);rxs->rs_more = (rxsp->status2 & AR_RxMore) ? 1 : 0;rxs->rs_firstaggr = (rxsp->status11 & AR_RxFirstAggr) ? 1 : 0;rxs->rs_isaggr = (rxsp->status11 & AR_RxAggr) ? 1 : 0;rxs->rs_moreaggr = (rxsp->status11 & AR_RxMoreAggr) ? 1 : 0;rxs->rs_antenna = (MS(rxsp->status4, AR_RxAntenna) & 0x7);rxs->enc_flags |= (rxsp->status4 & AR_GI) ? RX_ENC_FLAG_SHORT_GI : 0;rxs->enc_flags |=(rxsp->status4 & AR_STBC) ? (1 << RX_ENC_FLAG_STBC_SHIFT) : 0;rxs->bw = (rxsp->status4 & AR_2040) ? RATE_INFO_BW_40 : RATE_INFO_BW_20;rxs->evm0 = rxsp->status6;rxs->evm1 = rxsp->status7;rxs->evm2 = rxsp->status8;rxs->evm3 = rxsp->status9;rxs->evm4 = (rxsp->status10 & 0xffff);if (rxsp->status11 & AR_PreDelimCRCErr)rxs->rs_flags |= ATH9K_RX_DELIM_CRC_PRE;if (rxsp->status11 & AR_PostDelimCRCErr)rxs->rs_flags |= ATH9K_RX_DELIM_CRC_POST;if (rxsp->status11 & AR_DecryptBusyErr)rxs->rs_flags |= ATH9K_RX_DECRYPT_BUSY;if ((rxsp->status11 & AR_RxFrameOK) == 0)": {
        "description": "Generate conditions for rxs->rs_rssi, rxs->rs_rssi_ctl, rxs->rs_rssi_ext, rxs->rs_keyix, rxs->rs_rate, rxs->rs_more, rxs->rs_firstaggr, rxs->rs_isaggr, rxs->rs_moreaggr, rxs->rs_antenna, rxs->enc_flags, rxs->bw, rxs->evm0, rxs->evm1, rxs->evm2, rxs->evm3, rxs->evm4, rxs->rs_flags",
        "pre": {
            "rxs->rs_rssi": "!=null",
            "rxs->rs_rssi_ctl[0]": "!=null",
            "rxs->rs_rssi_ctl[1]": "!=null",
            "rxs->rs_rssi_ctl[2]": "!=null",
            "rxs->rs_rssi_ext[0]": "!=null",
            "rxs->rs_rssi_ext[1]": "!=null",
            "rxs->rs_rssi_ext[2]": "!=null",
            "rxs->rs_keyix": "!=null",
            "rxs->rs_rate": "!=null",
            "rxs->rs_more": "!=null",
            "rxs->rs_firstaggr": "!=null",
            "rxs->rs_isaggr": "!=null",
            "rxs->rs_moreaggr": "!=null",
            "rxs->rs_antenna": "!=null",
            "rxs->enc_flags": "!=null",
            "rxs->bw": "!=null",
            "rxs->evm0": "!=null",
            "rxs->evm1": "!=null",
            "rxs->evm2": "!=null",
            "rxs->evm3": "!=null",
            "rxs->evm4": "!=null",
            "rxs->rs_flags": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_process_rxdesc_edma": {
        "description": "Process RX descriptor in ath9k hardware.",
        "pre": {
            "ah": "!=null",
            "rxs": "!=null",
            "buf_addr": "!=null",
            "rxsp": "!=null",
            "phyerr": "!=null",
            "rxsp->status11 & AR_RxDone": "!=0",
            "MS(rxsp->ds_info, AR_DescId)": "==0x168c",
            "(rxsp->ds_info & (AR_TxRxDesc | AR_CtrlStat))": "==0",
            "rxs->rs_status": "==0",
            "rxs->rs_flags": "==0",
            "rxs->enc_flags": "==0",
            "rxs->bw": "==RATE_INFO_BW_20",
            "rxs->rs_datalen": "==rxsp->status2 & AR_DataLen",
            "rxs->rs_tstamp": "==rxsp->status3"
        }
    }
},
{
    "kretprobe:ath9k_cmn_rx_accept": {
        "description": "Key miss events are only relevant for pairwise keys where the descriptor does contain a valid key index. This has been observed mostly with CCMP encryption.",
        "pre": {
            "rx_stats->rs_keyix": "== ATH9K_RXKEYIX_INVALID || !test_bit(rx_stats->rs_keyix, common->ccmp_keymap)",
            "is_valid_tkip": "&& !ieee80211_is_ctl(fc) && !ieee80211_has_morefrags(fc) && !(le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG)",
            "rx_stats->rs_status": "& ATH9K_RXERR_MIC"
        }
    }
},
{
    "kprobe:ath9k_cmn_rx_accept": {
        "description": "Accept an incoming packet in the ath9k driver.",
        "pre": {
            "common": "!=null",
            "hdr": "!=null",
            "rxs": "!=null",
            "rx_stats": "!=null",
            "decrypt_error": "!=null",
            "rxfilter": "!=null",
            "common->ah": "!=null",
            "hdr->frame_control": "!=null",
            "rx_stats->rs_keyix": "==ATH9K_RXKEYIX_INVALID || !test_bit(rx_stats->rs_keyix, common->tkip_keymap)",
            "is_valid_tkip": "rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID && test_bit(rx_stats->rs_keyix, common->tkip_keymap)",
            "strip_mic": "is_valid_tkip && ieee80211_is_data(hdr->frame_control) && ieee80211_has_protected(hdr->frame_control) && !(rx_stats->rs_status & (ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC | ATH9K_RXERR_KEYMISS))"
        }
    }
},
{
    "kretprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "See if any padding is done by the hw and remove it.",
        "pre": {
            "common": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "decrypt_error": "!=null",
            "ah": "common->ah",
            "hdr": "!=null",
            "hdrlen": "ieee80211_get_hdrlen_from_skb(skb)",
            "padpos": "!=null",
            "padsize": "(4 - padpos % 4) % 4",
            "keyix": "!=null",
            "fc": "hdr->frame_control"
        }
    }
},
{
    "kprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "See if any padding is done by the hw and remove it.",
        "pre": {
            "common": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "decrypt_error": "!=null",
            "ah": "!=null",
            "hdr": "!=null",
            "hdrlen": "!=null",
            "padpos": "!=null",
            "padsize": "!=null",
            "keyix": "!=null",
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:ath9k_cmn_process_rate": {
        "description": "Process rate for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "sband": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "i": ">=0",
            "ah": "!=null",
            "ah.curchan": "!=null",
            "ah.curchan.chan": "!=null",
            "ah.curchan.chan.band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "hw.wiphy": "!=null",
            "hw.wiphy.bands": "!=null",
            "hw.wiphy.bands[band]": "!=null",
            "rxs.bw": "in [RATE_INFO_BW_5, RATE_INFO_BW_10]",
            "rx_stats.rs_rate": ">=0",
            "rx_stats.rs_rate & 0x80": "==0"
        },
        "post": {
            "rxs.encoding": "==RX_ENC_HT",
            "rxs.enc_flags": "|=rx_stats.enc_flags",
            "rxs.bw": "==rx_stats.bw",
            "rxs.rate_idx": "==rx_stats.rs_rate & 0x7f",
            "return": "==0"
        }
    }
},
{
    "kprobe:ath9k_cmn_process_rate": {
        "description": "Process rate for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "sband": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "i": ">=0",
            "ah": "!=null",
            "ah.curchan": "!=null",
            "ah.curchan.chan": "!=null",
            "ah.curchan.chan.band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "hw.wiphy": "!=null",
            "hw.wiphy.bands": "!=null",
            "hw.wiphy.bands[band]": "!=null",
            "rxs.bw": "in [RATE_INFO_BW_5, RATE_INFO_BW_10]",
            "rx_stats.rs_rate": ">=0",
            "rx_stats.rs_rate & 0x7f": "==rxs.rate_idx",
            "rx_stats.rs_rate & 0x80": "in [0, 1]"
        }
    }
},
S,
{
    "kprobe:if (rx_stats->rs_moreaggr)": {
        "description": "Check if rs_moreaggr is true.",
        "pre": {
            "rx_stats": "!=null",
            "rx_stats->rs_moreaggr": "==true"
        }
    }
},
{
    "kretprobe:ath9k_cmn_update_txpow": {
        "description": "Update the transmit power level.",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "!=null",
            "new_txpow": "!=null",
            "txpower": "!=null",
            "reg": "!=null",
            "reg->power_limit": "!=new_txpow",
            "ah->curchan": "!=null"
        }
    }
},
{
    "kprobe:ath9k_cmn_update_txpow": {
        "description": "Update the transmit power level for the ath9k wireless driver.",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "!=null",
            "new_txpow": "!=null",
            "txpower": "!=null",
            "reg": "!=null",
            "reg->power_limit": "!=new_txpow",
            "ah->curchan": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:rval = REG_READ(ah, AR_WOW_PATTERN);val = AR_WOW_STATUS(rval);/* * Mask only the WoW events that we have enabled. Sometimes * we have spurious WoW events from the AR_WOW_PATTERN * register. This mask will clean it up.": {
        "description": "Read the WoW status register to know the wakeup reason.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:rval = REG_READ(ah, AR_WOW_PATTERN);val = AR_WOW_STATUS(rval);/* * Mask only the WoW events that we have enabled. Sometimes * we have spurious WoW events from the AR_WOW_PATTERN * register. This mask will clean it up.": {
        "description": "Read the WoW status register to know the wakeup reason.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:REG_SET_BIT": {
        "description": "",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_HOST_PME_EN | AR_PMCTRL_PWR_PM_CTRL_ENA | AR_PMCTRL_AUX_PWR_DET | AR_PMCTRL_WOW_PME_CLR": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null",
            "AR_WOW_PATTERN": "!=null"
        }
    }
},
{
    "kprobe:REG_SET_BIT": {
        "description": "Set specific bits in the register",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_HOST_PME_EN": "!=null",
            "AR_PMCTRL_PWR_PM_CTRL_ENA": "!=null",
            "AR_PMCTRL_AUX_PWR_DET": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null"
        }
    },
    "kprobe:REG_CLR_BIT": {
        "description": "Clear specific bits in the register",
        "pre": {
            "ah": "!=null",
            "AR_PCIE_PM_CTRL(ah)": "!=null",
            "AR_PMCTRL_WOW_PME_CLR": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_sample_tx_ts": {
        "description": "Status timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_sample_tx_ts": {
        "description": "Status timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_node_init": {
        "description": "Initialize ath_node related information.",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_init": {
        "description": "Init ath_node related info",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_node_deinit": {
        "description": "Deinitialize ath_node related info",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_deinit": {
        "description": "Deinitialize ath_node related info.",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_reset": {
        "description": "Reset dynack processing",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_reset": {
        "description": "Reset dynack processing",
        "pre": {
            "ah": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_mci_get_interrupt": {
        "description": "This function is responsible for getting interrupts in the AR9003 MCI module.",
        "pre": {
            "ar9003_mci_state(ah, MCI_STATE_ENABLE)": true,
            "mci->bt_state": "!= MCI_BT_SLEEP",
            "!mci->halted_bt_gpm": true
        },
        "post": {
            "mci->ready": false
        }
    }
},
{
    "kprobe:ar9003_mci_get_interrupt": {
        "description": "This function handles the interrupt for ar9003_mci.",
        "pre": {
            "ar9003_mci_state(ah, MCI_STATE_ENABLE)": true,
            "mci->bt_state != MCI_BT_SLEEP": true,
            "!mci->halted_bt_gpm": true
        }
    }
},
{
    "description": "Check if gpm_type is MCI_GPM_BT_CAL_GRANT and recv_type is MCI_GPM_BT_CAL_REQ",
    "pre": {
        "gpm_type": "== MCI_GPM_BT_CAL_GRANT",
        "recv_type": "== MCI_GPM_BT_CAL_REQ"
    }
},
{
    "description": "Check if gpm_type is MCI_GPM_BT_CAL_GRANT and recv_type is MCI_GPM_BT_CAL_REQ",
    "pre": {
        "gpm_type": "== MCI_GPM_BT_CAL_GRANT",
        "recv_type": "== MCI_GPM_BT_CAL_REQ"
    }
},
{
    "kretprobe:ath_cmn_process_fft": {
        "description": "Process FFT data for spectral scan.",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": "!=null",
            "tsf": "!=null",
            "rs->rs_phyerr": "not in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ath_cmn_process_fft": {
        "description": "Process FFT data for spectral scan.",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": {
                "rs_phyerr": "not in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]"
            }
        }
    }
},
{
    "kretprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "Spectral scan trigger function for ath9k_cmn",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "rxfilter": "!=null",
            "ath9k_hw_ops(spec_priv->ah)->spectral_scan_trigger": "!=null",
            "spec_priv->spec_config.enabled": "==true",
            "ath_ps_ops(common)->wakeup": "!=null",
            "ath9k_hw_getrxfilter(spec_priv->ah)": "!=null",
            "ath9k_hw_setrxfilter(spec_priv->ah, rxfilter | ATH9K_RX_FILTER_PHYRADAR | ATH9K_RX_FILTER_PHYERR)": "!=null"
        }
    }
},
{
    "kprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "Trigger the spectral scan on the specified hardware.",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "rxfilter": "!=null",
            "ath9k_hw_ops(spec_priv->ah)->spectral_scan_trigger": "!=null",
            "spec_priv->spec_config.enabled": "==true"
        }
    }
},
S,
S,
{
    "kretprobe:ath11k_ce_get_shadow_config": {
        "description": "Check if shadow configuration is already done.",
        "pre": {
            "ab": "!=null",
            "shadow_cfg": "!=null",
            "shadow_cfg_len": "!=null",
            "ab->hw_params.supports_shadow_regs": "==true"
        },
        "post": {
            "*shadow_cfg_len": "==0"
        }
    }
},
{
    "kprobe:ath11k_ce_get_shadow_config": {
        "description": "Get the shadow configuration for CE (Copy Engine) registers in ath11k.",
        "pre": {
            "shadow_cfg_len": "==0",
            "ab->hw_params.supports_shadow_regs": "==false"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:ath11k_core_suspend": {
        "description": "Suspend the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==true"
        }
    }
},
{
    "kprobe:ath11k_core_suspend": {
        "description": "Suspend the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==false"
        }
    }
},
{
    "kretprobe:ath11k_core_resume": {
        "description": "Resume the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar || ar->state != ATH11K_STATE_OFF": "==true"
        }
    }
},
{
    "kprobe:ath11k_core_resume": {
        "description": "Resume the ath11k core.",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true",
            "pdev": "!=null",
            "ar": "!=null",
            "!ar->state": "==ATH11K_STATE_OFF"
        }
    }
},
S,
S,
{
    "kretprobe:done:return tot_work_done;}EXPORT_SYMBOL(ath11k_dp_service_srng": {
        "description": "Function to handle ath11k_dp_service_srng",
        "pre": {
            "ab": "!=null",
            "irq_grp": "!=null",
            "budget": "!=null",
            "napi": "!=null",
            "hal_params": "!=null",
            "grp_id": "!=null",
            "work_done": ">=0",
            "i": ">=0",
            "j": ">=0",
            "tot_work_done": ">=0",
            "ab->hw_params.max_tx_ring": ">=0",
            "ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num": ">=0",
            "ab->hw_params.ring_mask->tx[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_err[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_wbm_rel[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rx_mon_status[grp_id]": ">=0",
            "ab->num_radios": ">=0",
            "ab->hw_params.num_rxmda_per_pdev": ">=0",
            "ab->hw_params.ring_mask->reo_status[grp_id]": ">=0",
            "ab->hw_params.ring_mask->rxdma2host[grp_id]": ">=0",
            "ab->hw_params.ring_mask->host2rxdma[grp_id]": ">=0",
            "id": ">=0",
            "ath11k_ab_to_ar(ab, id)": "!=null",
            "ath11k_ab_to_ar(ab, id)->dp": "!=null",
            "ath11k_ab_to_ar(ab, id)->dp->rx_refill_buf_ring": "!=null",
            "ab->hw_params.hal_params->rx_buf_rbm": ">=0"
        }
    }
},
S,
{
    "kretprobe:ath11k_debugfs_soc_destroy": {
        "description": "Destroy the debugfs_soc object for ath11k_base",
        "pre": {
            "ab": "!=null",
            "ab->debugfs_soc": "!=null"
        }
    }
},
{
    "kprobe:ath11k_debugfs_soc_destroy": {
        "description": "Destroy the debugfs_soc directory associated with the ath11k_base structure.",
        "pre": {
            "ab": "!=null"
        }
    }
},
S,
{
    "kprobe:trace_ath11k_log_dbg_dump": {
        "description": "Debug dump function for ath11k",
        "pre": {
            "ab": "!=null",
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);__ath11k_pcic_write32(ab, offset, value);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);}EXPORT_SYMBOL(ath11k_pcic_write32": {
        "description": "The `ath11k_pcic_write32` function writes a 32-bit value to a specific offset in the `ab` device's memory.",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START",
            "value": "!=null",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "==0",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);__ath11k_pcic_write32(ab, offset, value);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);}EXPORT_SYMBOL(ath11k_pcic_write32": {
        "description": "Function to write a 32-bit value to the PCI configuration space of the ath11k device.",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START",
            "value": "!=null",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "!=null",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required": {
        "description": "Check if wakeup is required before accessing the device.",
        "pre": {
            "test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags)": "true",
            "offset": ">= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        },
        "post": {
            "ret": "null",
            "val": "!= null"
        }
    },
    "kretprobe:ab->pci.ops->wakeup": {
        "description": "Call the wakeup function of ab->pci.ops if wakeup is required.",
        "pre": {
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!= null"
        },
        "post": {
            "ret": "null"
        }
    },
    "kretprobe:__ath11k_pcic_read32": {
        "description": "Read a 32-bit value from the device.",
        "pre": {
            "ab": "!= null",
            "offset": ">= ATH11K_PCI_WINDOW_START"
        },
        "post": {
            "val": "!= null"
        }
    },
    "kretprobe:ab->pci.ops->release": {
        "description": "Call the release function of ab->pci.ops if wakeup is not required and ret is null.",
        "pre": {
            "wakeup_required": "true",
            "ret": "null",
            "ab->pci.ops->release": "!= null"
        },
        "post": {}
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);val = __ath11k_pcic_read32(ab, offset);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);return val;}EXPORT_SYMBOL(ath11k_pcic_read32": {
        "description": "Function to read a 32-bit value from the PCI configuration space of the ATH11K device.",
        "pre": {
            "ab": "!=null",
            "offset": ">=ATH11K_PCI_WINDOW_START",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "0",
            "val": "!=null",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:wakeup_required": {
        "description": "Check if wakeup is required before accessing the device.",
        "pre": {
            "test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags)": "true",
            "offset": ">= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        }
    },
    "kretprobe:ab->pci.ops->wakeup": {
        "description": "Call the wakeup function of the PCI operations.",
        "pre": {
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!= null"
        }
    },
    "kretprobe:__ath11k_pcic_read32": {
        "description": "Read a 32-bit value from the device.",
        "pre": {
            "ab": "!= null",
            "offset": ">= ATH11K_PCI_WINDOW_START"
        }
    },
    "kretprobe:ab->pci.ops->release": {
        "description": "Call the release function of the PCI operations.",
        "pre": {
            "wakeup_required": "true",
            "!ret": "true",
            "ab->pci.ops->release": "!= null"
        }
    }
},
{
    "kprobe:wakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;if (wakeup_required && ab->pci.ops->wakeup)ret = ab->pci.ops->wakeup(ab);val = __ath11k_pcic_read32(ab, offset);if (wakeup_required && !ret && ab->pci.ops->release)ab->pci.ops->release(ab);return val;}EXPORT_SYMBOL(ath11k_pcic_read": {
        "description": "Function to read a 32-bit value from the PCI configuration space of the ath11k device.",
        "pre": {
            "ab": "!=null",
            "offset": ">=ATH11K_PCI_WINDOW_START",
            "wakeup_required": "true",
            "ab->pci.ops->wakeup": "!=null",
            "ret": "0",
            "ab->pci.ops->release": "!=null"
        }
    }
},
{
    "kretprobe:ath11k_pcic_ext_irq_enable": {
        "description": "Enable external IRQ for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "irq_grp": "!=null",
            "irq_grp->ab": "!=null",
            "irq_grp->num_irq": ">=0",
            "irq_grp->irqs[i]": ">=0",
            "irq_grp->ab->irq_num[irq_grp->irqs[i]]": ">=0"
        }
    }
},
{
    "kprobe:ath11k_pcic_ext_irq_enable": {
        "description": "Enable external IRQ for ath11k_base.",
        "pre": {
            "!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags)": true,
            "i": ">= 0",
            "i": "< irq_grp->num_irq",
            "enable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]])": true
        }
    }
},
{
    "for (i = 0, msi_data_idx = 0; i < ab->hw_params.ce_count; i++)": {
        "description": "Loop over CE parameters",
        "pre": {
            "i": "integer",
            "msi_data_idx": "integer",
            "ab->hw_params.ce_count": "integer"
        }
    }
},
{
    "kprobe:ath11k_pcic_config_irq": {
        "description": "Configure CE irqs",
        "pre": {
            "ab->hw_params.ce_count": ">0",
            "i": ">=0",
            "msi_data_idx": ">=0"
        }
    }
},
{
    "kretprobe:ath11k_pcic_register_pci_ops": {
        "description": "Register PCI operations for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "!pci_ops->get_msi_irq": true,
            "!pci_ops->window_write32": true,
            "!pci_ops->window_read32": true
        }
    }
},
{
    "kprobe:ath11k_pcic_register_pci_ops": {
        "description": "Register PCI operations for ath11k_base.",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "!pci_ops->get_msi_irq": true,
            "!pci_ops->window_write32": true,
            "!pci_ops->window_read32": true
        }
    }
},
{
    "kretprobe:write_index = CE_RING_IDX_INCR(nentries_mask, write_index);/* WORKAROUND `": {
        "description": "Update the write index of the source ring in the CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": "> 0",
            "transfer_id": ">= 0",
            "flags": ">= 0",
            "ar": "!=null",
            "src_ring": "!=null",
            "nentries_mask": ">= 0",
            "sw_index": ">= 0",
            "write_index": ">= 0",
            "ctrl_addr": ">= 0",
            "desc_flags": ">= 0",
            "ret": ">= 0"
        }
    }
},
{
    "kprobe:write_index = CE_RING_IDX_INCR(nentries_mask, write_index);/* WORKAROUND `": {
        "description": "Update the value of write_index using CE_RING_IDX_INCR function.",
        "pre": {
            "nentries_mask": "!=null",
            "write_index": "!=null"
        }
    }
},
{
    "kretprobe:__ath10k_ce_send_revert": {
        "description": "This function must be called only if there is an incomplete scatter-gather transfer (before index register is updated) that needs to be cleaned up.",
        "pre": {
            "pipe": "!=null",
            "pipe->ar": "!=null",
            "pipe->ar->ce": "!=null",
            "pipe->src_ring": "!=null",
            "pipe->ctrl_addr": "!=null",
            "ce->ce_lock": "held"
        }
    }
},
{
    "kprobe:__ath10k_ce_send_revert": {
        "description": "This function must be called only if there is an incomplete scatter-gather transfer (before index register is updated) that needs to be cleaned up.",
        "pre": {
            "pipe": "!=null",
            "pipe->ar": "!=null",
            "pipe->ar->ce": "!=null",
            "pipe->src_ring": "!=null",
            "pipe->ctrl_addr": "!=null",
            "ce->ce_lock": "held"
        }
    }
},
{
    "kretprobe:_ath10k_ce_send_nolock": {
        "description": "Send data using the ath10k_ce_send function.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:_ath10k_ce_send_nolock": {
        "description": "Send data using the ath10k_ce_send helper.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "pre": {
            "pipe": "!=null",
            "nentries": "!=null",
            "ar": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "ctrl_addr": "!=null",
            "cur_write_idx": "!=null",
            "cur_write_idx + nentries": "== dest_ring->sw_index",
            "nentries": "-= 1",
            "write_index": "= CE_RING_IDX_ADD(nentries_mask, write_index, nentries)",
            "ath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index)": "",
            "dest_ring->write_index": "= write_index"
        }
    }
},
{
    "kprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "pre": {
            "pipe": "!=null",
            "nentries": "!=null",
            "ar": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "ctrl_addr": "!=null",
            "cur_write_idx": "!=null",
            "((cur_write_idx + nentries) & nentries_mask)": "== dest_ring->sw_index",
            "nentries": "-= 1",
            "write_index": "= CE_RING_IDX_ADD(nentries_mask, write_index, nentries)",
            "ath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index)": "",
            "dest_ring->write_index": "= write_index"
        }
    }
},
{
    "kretprobe:ath10k_ce_rx_post_buf": {
        "description": "Post a buffer to the receive ring of the ath10k CE pipe.",
        "pre": {
            "pipe": "!=null",
            "ctx": "!=null",
            "paddr": "!=null",
            "ar": "!=null",
            "ce": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "write_index": "!=null",
            "sw_index": "!=null",
            "base": "!=null",
            "desc": "!=null",
            "ctrl_addr": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_rx_post_buf": {
        "description": "Post a buffer to the receive ring of the ath10k CE pipe.",
        "pre": {
            "pipe": "!=null",
            "ctx": "!=null",
            "paddr": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_completed_recv_next_nolock": {
        "description": "Copy in one go for performance reasons",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null",
            "dest_ring": "!=null",
            "nentries_mask": "!=null",
            "sw_index": "!=null",
            "base": "!=null",
            "desc": "!=null",
            "sdesc": "!=null",
            "nbytes": "!=null",
            "nbytes": "==0"
        }
    }
},
{
    "kprobe:sdesc = *desc;nbytes = __le16_to_cpu(sdesc.nbytes);if (nbytes == 0)": {
        "description": "Copy in one go for performance reasons",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kretprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_revoke_recv_next": {
        "description": "Return data from completed destination descriptor",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null",
            "ce_state->dest_ring": "!=null",
            "dest_ring->nentries_mask": "!=null",
            "dest_ring->sw_index": "!=null",
            "dest_ring->write_index": "!=null",
            "dest_ring->write_index": "!=dest_ring->sw_index",
            "dest_ring->base_addr_owner_space": "!=null",
            "dest_ring->base_addr_owner_space[dest_ring->sw_index]": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_revoke_recv_next": {
        "description": "Revoke the next received data from the ath10k CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_src_ring_read_index_get": {
        "description": "Read the index from the source ring.",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null"
        }
    },
    "kretprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "Send the next completed transfer without locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "src_ring": "!=null",
            "src_ring->nentries_mask": "!=null",
            "src_ring->sw_index": "!=null",
            "src_ring->hw_index": "!=null",
            "ar": "!=null",
            "ar->hw_params.rri_on_ddr": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, -EIO]"
        }
    }
},
{
    "kprobe:ath10k_ce_src_ring_read_index_get": {
        "description": "Read the index from the source ring.",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null"
        }
    },
    "kprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "Send the next completed transfer without locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "src_ring": "!=null",
            "src_ring.hw_index": "read_index",
            "src_ring.nentries_mask": "!=null",
            "src_ring.sw_index": "!=null",
            "read_index": "!=0xffffffff",
            "read_index": "&= nentries_mask",
            "src_ring.hw_index": "read_index"
        }
    }
},
{
    "kretprobe:ath10k_ce_cancel_send_next": {
        "description": "Cancel the next send operation on the CE pipe.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "==null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null",
            "src_ring": "!=null",
            "nentries_mask": "!=null",
            "sw_index": "!=null",
            "write_index": "!=null",
            "ar": "!=null",
            "ce": "!=null"
        }
    }
},
{
    "kprobe:src_ring->per_transfer_context[sw_index] = NULL;/* Update sw_index `": {
        "description": "Update sw_index in src_ring and set per_transfer_context[sw_index] to NULL.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null"
        }
    }
},
{
    "kretprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "The caller takes responsibility for any necessary locking.",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_engine_int_status_clear": {
        "description": "Clear before handling Misc CE interrupts",
        "pre": {
            "ar": "!=null",
            "ctrl_addr": "!=null",
            "wm_regs.cc_mask | wm_regs.wm_mask": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_engine_int_status_clear": {
        "description": "Clear before handling Misc CE interrupts.",
        "pre": {
            "ar": "!=null",
            "ce_id": "!=null",
            "ce_state": "!=null",
            "wm_regs": "!=null",
            "ctrl_addr": "!=null",
            "wm_regs->cc_mask | wm_regs->wm_mask": "!=null"
        }
    }
},
{
    "kretprobe:continue;ath10k_ce_per_engine_service(ar, ce_id);}}EXPORT_SYMBOL(ath10k_ce_per_engine_service_any": {
        "description": "This function services the per-engine interrupt for the ath10k device.",
        "pre": {
            "ar": "!=null",
            "ce_id": ">=0",
            "intr_summary": ">=0",
            "intr_summary & (1 << ce_id)": "!=0"
        }
    }
},
{
    "kprobe:continue;ath10k_ce_per_engine_service(ar, ce_id);}}EXPORT_SYMBOL(ath10k_ce_per_engine_service_any": {
        "description": "Performs per-engine service for ath10k.",
        "pre": {
            "ar": "!=null",
            "ce_id": ">=0 && <=CE_COUNT",
            "intr_summary": ">=0"
        }
    }
},
{
    "kretprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engines that are not using polling mode.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engines that are not using polling mode.",
        "pre": {
            "ar": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "pre": {
            "ar->hw_params.delay_unmap_buffer": "true",
            "ep->ul_pipe_id": "== 3"
        },
        "post": {
            "hdr": "!= null",
            "ep->ep_ops.ep_tx_complete": "false"
        }
    }
},
{
    "kprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "pre": {
            "ar->hw_params.delay_unmap_buffer": "true",
            "ep->ul_pipe_id": "== 3"
        }
    }
},
{
    "kretprobe:ath10k_htc_tx_completion_handler": {
        "description": "Handle the completion of a transmit operation in the ath10k_htc module.",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:ath10k_htc_tx_completion_handler": {
        "description": "Handles the completion of a transmit operation in the ath10k_htc module.",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:trailer_present": {
        "description": "Check if the trailer is present in the header flags",
        "pre": {
            "hdr": "!=null",
            "hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT": "!=0"
        }
    }
},
{
    "kprobe:trailer_present": {
        "description": "Check if the trailer is present in the header flags",
        "pre": {
            "hdr": "!=null",
            "hdr->flags": "!=null",
            "hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT": "!=0"
        }
    }
},
S,
{
    "kprobe:ath10k_core_create_board_name": {
        "description": "Create the board name for ath10k_core.",
        "pre": {
            "ar": "!=null",
            "boardname": "!=null",
            "sizeof(boardname)": ">=100",
            "true": "true",
            "true": "true"
        }
    }
},
{
    "kretprobe:ath10k_core_stop": {
        "description": "Try to suspend target.",
        "pre": {
            "ar->state": "!= ATH10K_STATE_RESTARTING && != ATH10K_STATE_UTF",
            "ar->conf_mutex": "held"
        },
        "post": {
            "ar->id.bmi_ids_valid": "false"
        }
    }
},
S,
{
    "kretprobe:set_bit": {
        "description": "Set a bit in a bitfield.",
        "pre": {
            "bitfield": "!=null",
            "bit": "!=null",
            "value": "!=null"
        }
    },
    "kretprobe:ath10k_core_probe_fw": {
        "description": "Probe the firmware of the ath10k core.",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:set_bit": {
        "description": "Set a bit in a given memory location.",
        "pre": {
            "bit": ">= 0",
            "addr": "!= null"
        }
    }
},
{
    "kretprobe:ath10k_spectral_destroy": {
        "description": "Destroy the spectral functionality in ath10k.",
        "pre": {
            "ar": "!=null",
            "cancel_work_sync(&ar->register_work)": "called",
            "test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags)": "true",
            "ath10k_thermal_unregister(ar)": "called",
            "stop_spectral_before_unregistering": "true",
            "parent_debugfs_tree_freed_recursively": "false"
        }
    }
},
{
    "kprobe:ath10k_spectral_destroy": {
        "description": "Unregister from mac80211 before stopping HTC and HIF.",
        "pre": {
            "ar": "!=null",
            "ar->register_work": "cancelled",
            "ar->dev_flags": "contains ATH10K_FLAG_CORE_REGISTERED",
            "ath10k_thermal_unregister(ar)": "called",
            "spectral": "stopped",
            "mac80211": "unregistered",
            "relayfs debugfs file": "removed",
            "parent debugfs tree": "not recursively freed"
        }
    }
},
{
    "kretprobe:ath10k_core_create_board_name": {
        "description": "Create board name for ath10k core.",
        "pre": {
            "ar": "!=null",
            "name": "!=null",
            "name_len": ">= (9 + ATH10K_SMBIOS_BDF_EXT_STR_LENGTH)",
            "with_variant": "boolean",
            "with_chip_id": "boolean"
        }
    }
},
{
    "ath10k_core_create_board_name": {
        "description": "Create the board name for ath10k core.",
        "pre": {
            "ar": "!=null",
            "name": "!=null",
            "name_len": ">= (9 + ATH10K_SMBIOS_BDF_EXT_STR_LENGTH)",
            "with_variant": "boolean",
            "with_chip_id": "boolean"
        }
    }
},
{
    "kretprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k.",
        "pre": {
            "ar": "!=null",
            "mask": "in [ATH10K_DBG_MASK_1, ATH10K_DBG_MASK_2, ATH10K_DBG_MASK_3]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k.",
        "pre": {
            "ar": "!=null",
            "mask": "!=null",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": "!=null"
        }
    }
},
{
    "kretprobe:size += hw->region_table.size * sizeof(struct ath10k_dump_ram_data_hdr)": {
        "description": "Reserve space for the headers",
        "pre": {
            "hw": "!=null",
            "hw->region_table.size": ">0",
            "sizeof(struct ath10k_dump_ram_data_hdr)": ">0"
        }
    }
},
S,
{
    "kretprobe:ath10k_coredump_new": {
        "description": "Create a new coredump for the ath10k driver.",
        "pre": {
            "ar": "!=null",
            "crash_data": "!=null",
            "ar->coredump.fw_crash_data": "!=null",
            "ar->dump_mutex": "held",
            "ath10k_coredump_mask": "==0"
        },
        "post": {
            "return": "crash_data",
            "crash_data->guid": "generated",
            "crash_data->timestamp": "generated"
        }
    }
},
{
    "kprobe:ath10k_coredump_new": {
        "description": "Create a new coredump for the ath10k driver.",
        "pre": {
            "ar": "!=null",
            "crash_data": "!=null",
            "ar->coredump.fw_crash_data": "!=null",
            "lockdep_assert_held(&ar->dump_mutex)": "true",
            "ath10k_coredump_mask": "!=0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:try_module_get": {
        "description": "Get a module reference to avoid unloading and schedule removal.",
        "pre": {
            "THIS_MODULE": "!=null"
        }
    }
},
{
    "kprobe:try_module_get": {
        "description": "Get a module reference to avoid unloading and schedule removal.",
        "pre": {
            "THIS_MODULE": "!=null"
        }
    }
},
{
    "kretprobe:il_update_stats": {
        "description": "Record all the MGMT, CTRL, and DATA packets for both TX and Rx using debugfs to display the rxrx_stats.",
        "pre": {
            "il": "!=null",
            "is_tx": "is boolean",
            "fc": "is 16-bit little-endian",
            "len": "is 16-bit"
        }
    }
},
{
    "kprobe:il_update_stats": {
        "description": "Record MGMT, CTRL, and DATA packets for both TX and Rx",
        "pre": {
            "il": "!=null",
            "is_tx": "is boolean",
            "fc": "!=null",
            "len": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:BUG_ON": {
        "description": "Check if cmd->callback is not null.",
        "pre": {
            "cmd->callback": "==null"
        }
    },
    "kretprobe:D_INFO": {
        "description": "Print debug information for the command.",
        "pre": {
            "cmd": "!=null",
            "cmd->id": "!=null"
        }
    },
    "kretprobe:set_bit": {
        "description": "Set the S_HCMD_ACTIVE bit in il->status.",
        "pre": {
            "il": "!=null",
            "&il->status": "!=null"
        }
    },
    "kretprobe:il_enqueue_hcmd": {
        "description": "Enqueue the command in il.",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd_idx": "<0"
        }
    }
},
{
    "kprobe:BUG_ON": {
        "description": "Check if cmd->callback is not null.",
        "pre": {
            "cmd->callback": "==null"
        }
    },
    "kprobe:D_INFO": {
        "description": "Print debug information about the command being sent.",
        "pre": {
            "cmd->id": "!=null"
        }
    },
    "kprobe:set_bit": {
        "description": "Set the S_HCMD_ACTIVE bit in il->status.",
        "pre": {
            "il->status": "!=null"
        }
    },
    "kprobe:il_enqueue_hcmd": {
        "description": "Enqueue the command in il and get the index.",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd_idx": "<0"
        }
    }
},
{
    "kretprobe:BUG_ON(cmd->flags & CMD_WANT_SKB)": {
        "description": "Check if the CMD_WANT_SKB flag is set in the flags field of the cmd structure.",
        "pre": {
            "cmd": "!=null",
            "cmd->flags": "& CMD_WANT_SKB != 0"
        }
    }
},
{
    "kprobe:BUG_ON(cmd->flags & CMD_WANT_SKB);/* Assign a generic callback if one is not provided */": {
        "description": "Check if the CMD_WANT_SKB flag is set in the flags field of the cmd structure and trigger a bug if it is.",
        "pre": {
            "cmd": {
                "flags": "& CMD_WANT_SKB == 0"
            }
        }
    }
},
{
    "kretprobe:intil_eeprom_init": {
        "description": "Read EEPROM contents. Load the EEPROM contents from the adapter into il->eeprom. Note: This routine uses the non-debug IO access functions.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_eeprom_init": {
        "description": "Read EEPROM contents from adapter into il->eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:intil_init_channel_map": {
        "description": "Set up driver's info for all possible channels",
        "pre": {
            "il": "!=null",
            "band": "!=null",
            "channel": "!=null",
            "ch_info": "!=null",
            "eeprom_ch": "!=null",
            "il_is_channel_valid(ch_info)": "==0",
            "eeprom_ch->flags & EEPROM_CHANNEL_VALID": "==0",
            "ch_info->ht40_extension_channel": "==clear_ht40_extension_channel"
        }
    }
},
{
    "kprobe:intil_init_channel_map": {
        "description": "Set up driver's info for all possible channels",
        "pre": {
            "il": "!=null",
            "band": "!=null",
            "channel": "!=null",
            "il_is_channel_valid(il_get_channel_info(il, band, channel))": "==true",
            "D_EEPROM": "called",
            "ch_info->ht40_extension_channel": "==clear_ht40_extension_channel",
            "return": "==0"
        }
    }
},
{
    "kretprobe:il_free_channel_map": {
        "description": "undo allocations in il_init_channel_map",
        "pre": {}
    }
},
{
    "kprobe:il_free_channel_map": {
        "description": "undo allocations in il_init_channel_map",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:intil_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:intil_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null",
            "ms": ">=0"
        }
    }
},
{
    "kprobe:intil_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan",
        "pre": {
            "il": "!=null",
            "ms": ">=0"
        }
    }
},
S,
S,
{
    "kretprobe:il_get_passive_dwell_time": {
        "description": "Calculate the passive dwell time based on the given parameters.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        }
    }
},
{
    "kprobe:il_get_passive_dwell_time": {
        "description": "Get the passive dwell time for the given parameters.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        }
    }
},
{
    "kretprobe:il_mac_hw_scan": {
        "description": "Scan the hardware for available networks.",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "req->n_channels": ">0",
            "il->mutex": "locked",
            "il->status": "!S_SCANNING"
        },
        "post": {
            "ret": "is an integer"
        }
    }
},
{
    "kprobe:il_mac_hw_scan": {
        "description": "Scan the hardware for available networks.",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "req": "!=null",
            "il": "!=null",
            "ret": "int",
            "req->n_channels": ">0",
            "il->mutex": "locked",
            "il->status": "bit not set for S_SCANNING"
        }
    }
},
{
    "kretprobe:u16il_fill_probe_req": {
        "description": "Fill in all required fields and IE for probe request",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": ">=0",
            "left": ">=0"
        }
    }
},
{
    "kprobe:u16il_fill_probe_req": {
        "description": "fill in all required fields and IE for probe request",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": "any",
            "left": "any"
        }
    }
},
S,
S,
{
    "kretprobe:il_clear_ucode_stations": {
        "description": "Clear ucode station table bits",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_clear_ucode_stations": {
        "description": "Clear ucode station table bits",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
{
    "kprobe:il_restore_stations": {
        "description": "Restore driver known stations to device. All stations considered active by driver, but not present in ucode, are restored. Function sleeps.",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "pre": {
            "q": "!=null",
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:voidil_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:voidil_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:il_set_decrypted_flag": {
        "description": "Set the decrypted flag in the il_priv structure based on the decrypt_res value.",
        "pre": {
            "il": "!=null",
            "hdr": "!=null",
            "decrypt_res": "!=null",
            "stats": "!=null",
            "fc": "!=null",
            "fc": "&",
            "fc": "IEEE80211_FCTL_PROTECTED",
            "decrypt_res": "&",
            "decrypt_res": "RX_RES_STATUS_SEC_TYPE_MSK"
        }
    }
},
S,
{
    "kretprobe:il_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kprobe:il_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "pre": {
            "il": "!=null",
            "txq_id": "is_integer"
        }
    }
},
{
    "kprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        }
    }
},
{
    "kretprobe:il_tx_queue_free": {
        "description": "Deallocate DMA queue.",
        "pre": {
            "il": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kprobe:voidil_tx_queue_free": {
        "description": "Deallocate DMA queue.",
        "pre": {
            "il": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kretprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_queue_space": {
        "description": "Calculate the available space in the il_queue",
        "pre": {
            "q": "!=null",
            "q->read_ptr": "!=null",
            "q->write_ptr": "!=null",
            "q->n_bd": "!=null",
            "q->n_win": "!=null"
        },
        "post": {
            "s": ">= 0"
        }
    }
},
{
    "kprobe:il_queue_space": {
        "description": "Calculate the available space in the il_queue",
        "pre": {
            "q": "!=null",
            "q->read_ptr": "!=null",
            "q->write_ptr": "!=null",
            "q->n_bd": "!=null",
            "q->n_win": "!=null",
            "s": "!=null",
            "s": "q->read_ptr - q->write_ptr",
            "q->read_ptr > q->write_ptr": "s -= q->n_bd",
            "s <= 0": "s += q->n_win"
        }
    }
},
S,
S,
{
    "kretprobe:il_queue_init": {
        "description": "Initialize queue's highlow-water marks, and headtail idxes",
        "pre": {
            "il": "!=null",
            "&txq->q": "!=null",
            "slots": "in [TFD_CMD_SLOTS, TFD_TX_CMD_SLOTS]",
            "txq_id": "!=null"
        }
    }
},
{
    "kprobe:il_queue_init": {
        "description": "Initialize queue's highlow-water marks, and headtail idxes.",
        "pre": {
            "il": "!=null",
            "txq->q": "!=null",
            "slots": "!=null",
            "txq_id": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them",
        "pre": {
            "il": "!=null",
            "rxb": "!=null",
            "rxb->async_callback": "!=null",
            "rxb->async_callback_return": "==1",
            "rxb->skb": "==null || rxb->async_callback_return != 1"
        }
    }
},
{
    "kprobe:il_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them",
        "pre": {
            "il": "!=null",
            "rxb": "!=null",
            "rxb->callback": "!=null",
            "rxb->callback_return": "==1",
            "rxb->skb": "==null"
        }
    }
},
{
    "kretprobe:intil_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:intil_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_free_geos": {
        "description": "undo allocations in il_init_geos",
        "pre": {}
    }
},
{
    "kprobe:il_free_geos": {
        "description": "undo allocations in il_init_geos",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:u8il_prep_station": {
        "description": "Prepare station information for addition",
        "pre": {
            "il": "!=null",
            "addr": "!=null",
            "is_ap": "is boolean",
            "sta": "!=null",
            "sta_lock": "held"
        }
    }
},
S,
{
    "kretprobe:il->timing.atim_win = 0;beacon_int = il_adjust_beacon_interval(beacon_int, il->hw_params.max_beacon_itrvl * TIME_UNIT);il->timing.beacon_interval = cpu_to_le16(beacon_int);tsf = il->timestamp;/* tsf is modifed by do_div: copy it`": {
        "description": "Set the timing parameters for the il structure.",
        "pre": {
            "il": "!=null",
            "il->timing.atim_win": "==0",
            "beacon_int": "!=null",
            "il->hw_params.max_beacon_itrvl": "!=null",
            "TIME_UNIT": "!=null",
            "il->timing.beacon_interval": "!=null",
            "beacon_int": "!=null",
            "tsf": "!=null",
            "il->timestamp": "!=null"
        }
    }
},
{
    "kprobe:il_send_rxon_timing": {
        "description": "Send RXON timing information.",
        "pre": {
            "il": "!=null",
            "beacon_int": ">=0",
            "tsf": "!=null"
        }
    }
},
{
    "kretprobe:if ((rxon->ofdm_basic_rates & RATE_6M_MASK) == 0 && (rxon->cck_basic_rates & RATE_1M_MASK) == 0)": {
        "description": "Check if basic rates 6Mbps and 1Mbps are supported",
        "pre": {
            "rxon->ofdm_basic_rates": "& RATE_6M_MASK == 0",
            "rxon->cck_basic_rates": "& RATE_1M_MASK == 0"
        }
    }
},
{
    "kprobe:il_check_rxon_cmd": {
        "description": "Check if basic rates 6Mbps and 1Mbps are supported.",
        "pre": {
            "rxon->ofdm_basic_rates": "& RATE_6M_MASK == 0",
            "rxon->cck_basic_rates": "& RATE_1M_MASK == 0"
        }
    }
},
{
    "kretprobe:intil_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed",
        "pre": {
            "il": "!=null",
            "staging_rxon": "!=null",
            "active_rxon": "!=null",
            "staging_rxon != active_rxon": true,
            "staging_rxon.RXON_FILTER_ASSOC_MSK": "!=0"
        }
    }
},
{
    "kprobe:intil_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed.",
        "pre": {
            "il": "!=null",
            "staging_rxon": "!=active_rxon",
            "active_rxon": "!=null",
            "RXON_FILTER_ASSOC_MSK": "!=null"
        }
    }
},
S,
{
    "kprobe:il_get_lowest_plcp": {
        "description": "Assign the lowest rate",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
{
    "kprobe:clear_ht_channel_mode_before_set_mode": {
        "description": "Clear the HT channel mode before setting the mode.",
        "pre": {
            "il": "!=null",
            "ht_conf": "!=null",
            "il.ht.enabled": "==true",
            "il.staging.flags": "& ~(RXON_FLG_CHANNEL_MODE_MSK | RXON_FLG_CTRL_CHANNEL_LOC_HI_MSK | RXON_FLG_HT40_PROT_MSK | RXON_FLG_HT_PROT_MSK)",
            "il.staging.flags": "|= cpu_to_le32(il.ht.protection << RXON_FLG_HT_OPERATING_MODE_POS)"
        }
    }
},
{
    "kretprobe:intil_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON",
        "pre": {
            "il": "!=null",
            "ch": "!=null",
            "ch->band": "!=null"
        }
    }
},
{
    "kprobe:intil_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON.",
        "pre": {
            "il": "!=null",
            "ch": "!=null",
            "ch->band": "!=null"
        }
    }
},
{
    "kretprobe:il_set_flags_for_band": {
        "description": "Set flags for the given band in il_set_flags_for_band function.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_5GHZ, NL80211_BAND_2GHZ]",
            "vif": "!=null",
            "vif->bss_conf.use_short_slot": "==true"
        },
        "post": {
            "il->staging.flags": "|= RXON_FLG_SHORT_SLOT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_BAND_24G_MSK",
            "il->staging.flags": "|= RXON_FLG_AUTO_DETECT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_CCK_MSK"
        }
    }
},
{
    "kprobe:il_set_flags_for_band": {
        "description": "Set flags for the given band in il_priv structure.",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_5GHZ]",
            "vif": "!=null",
            "vif->bss_conf.use_short_slot": "==true"
        },
        "post": {
            "il->staging.flags": "|= RXON_FLG_SHORT_SLOT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_BAND_24G_MSK",
            "il->staging.flags": "|= RXON_FLG_AUTO_DETECT_MSK",
            "il->staging.flags": "&= ~RXON_FLG_CCK_MSK"
        }
    }
},
{
    "kretprobe:il_connection_init_rx_config": {
        "description": "Initialize RX configuration for il_connection",
        "pre": {
            "il": "!=null",
            "ch_info": "!=null",
            "il->staging": "memset(&il->staging, 0, sizeof(il->staging))",
            "il->iw_mode": "in [NL80211_IFTYPE_UNSPECIFIED, NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC]",
            "il->staging.dev_type": "in [RXON_DEV_TYPE_ESS, RXON_DEV_TYPE_IBSS]",
            "il->staging.filter_flags": "in [RXON_FILTER_ACCEPT_GRP_MSK, RXON_FILTER_BCON_AWARE_MSK | RXON_FILTER_ACCEPT_GRP_MSK]",
            "il->staging.flags": "RXON_FLG_SHORT_PREAMBLE_MSK when il->iw_mode == NL80211_IFTYPE_ADHOC",
            "il->staging.channel": "cpu_to_le16(ch_info->channel)",
            "il->band": "ch_info->band",
            "il_set_flags_for_band(il, il->band, il->vif)": "il_set_flags_for_band(il, il->band, il->vif)",
            "il->staging.ofdm_basic_rates": "(IL_OFDM_RATES_MASK >> IL_FIRST_OFDM_RATE) & 0xFF",
            "il->staging.cck_basic_rates": "(IL_CCK_RATES_MASK >> IL_FIRST_CCK_RATE) & 0xF"
        }
    }
},
S,
{
    "kretprobe:il_irq_handle_error": {
        "description": "Called for HW or SW error interrupt from card",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_irq_handle_error": {
        "description": "called for HW or SW error interrupt from card",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:_il_apm_stop": {
        "description": "Stop device's busmaster DMA activity.",
        "pre": {
            "il": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:il_sta_ucode_activate": {
        "description": "Activate the ucode for a specific station in the il_priv structure.",
        "pre": {
            "il": "!=null",
            "sta_id": "!=null",
            "il->tx_power_next": "!=null",
            "il->ops->post_scan": "!=null",
            "il->mutex": "!=null",
            "il->sta_lock": "held"
        }
    }
},
{
    "kprobe:il_sta_ucode_activate": {
        "description": "Activate the microcode for the specified station ID in the il_priv structure.",
        "pre": {
            "il": "!=null",
            "sta_id": "!=null",
            "il->tx_power_next": "!=null",
            "il->ops": "!=null",
            "il->ops->post_scan": "!=null",
            "il->mutex": "!=null",
            "il->sta_lock": "held"
        }
    }
},
{
    "kretprobe:reset": {
        "description": "Check if the interface needs to be reset",
        "pre": {
            "il": "!=null",
            "vif": "!=null",
            "reset": "!=null",
            "il->vif": "==vif",
            "il->vif": "!=null",
            "!reset": "true"
        }
    }
},
{
    "kprobe:reset": {
        "description": "Reset function for il_mac_add_interface",
        "pre": {
            "il->vif": "!=null",
            "il->vif->type": "==vif->type",
            "il->vif->addr": "==vif->addr",
            "il_is_ready_rf(il)": "==true"
        }
    }
},
{
    "kretprobe:if (!external && !il->cfg->mod_params->restart_fw)": {
        "description": "Check if external is false and il->cfg->mod_params->restart_fw is false.",
        "pre": {
            "external": "==false",
            "il->cfg->mod_params->restart_fw": "==false"
        }
    }
},
{
    "if (!external && !il->cfg->mod_params->restart_fw)": {
        "description": "Check if the request is from external and fw_restart module parameter is not set.",
        "pre": {
            "external": false,
            "il->cfg->mod_params->restart_fw": false
        }
    }
},
{
    "kretprobe:err = -EBUSY;goto out;}/* success `": {
        "description": "Function: err = -EBUSY;goto out;}/* success `",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "newtype": "in [nl80211_iftype values]",
            "newp2p": "boolean",
            "err": "-EOPNOTSUPP when newp2p == true",
            "il->vif": "!=null",
            "il_is_ready_rf(il)": "true"
        }
    }
},
{
    "err": "-EBUSY",
    "hw": "!=null",
    "vif": "!=null",
    "newtype": "enum value",
    "newp2p": "bool value"
},
S,
S,
S,
S,
S,
{
    "kprobe:dev_consume_skb_irq": {
        "description": "Consume the skb associated with il->beacon_skb and reset related variables.",
        "pre": {
            "il": "!=null",
            "il->beacon_skb": "==null",
            "il->timestamp": "==0",
            "il->lock": "!=null",
            "flags": "!=null",
            "il_scan_cancel_timeout": "!=null",
            "il_is_ready_rf(il)": "==false"
        }
    }
},
{
    "kretprobe:il_mac_bss_info_changed": {
        "description": "Function to handle changes in MAC BSS info",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "bss_conf": "!=null",
            "changes": "!=null"
        }
    }
},
{
    "kprobe:il_mac_bss_info_changed": {
        "description": "Function to handle changes in MAC BSS info",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "bss_conf": "!=null",
            "changes": "!=null"
        }
    }
},
{
    "kretprobe:inta_mask = _il_rd(il, CSR_INT_MASK);/* just for debug `": {
        "description": "This helper function reads the value of CSR_INT_MASK and assigns it to the variable inta_mask.",
        "pre": {
            "il": "!=null",
            "CSR_INT_MASK": "!=null"
        }
    }
},
{
    "kprobe:inta_mask = _il_rd(il, CSR_INT_MASK);/* just for debug `": {
        "description": "This helper function reads the value of CSR_INT_MASK and assigns it to the variable inta_mask.",
        "pre": {
            "il": "!=null",
            "CSR_INT_MASK": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        }
    }
},
{
    "kprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        }
    }
},
{
    "kretprobe:libipw_wx_get_encode": {
        "description": "Get the encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "len": "int",
            "key": "int",
            "sec": "!=null",
            "LIBIPW_DEBUG_WX": "string",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "char",
            "module": "char",
            "ops": "!=null",
            "crypt": "!=null",
            "dev": "!=null"
        },
        "post": {
            "erq->flags": "int",
            "sec->enabled": "bool",
            "erq->length": "int",
            "erq->flags": "int",
            "ieee->open_wep": "bool"
        }
    },
    "kretprobe:libipw_wx_set_encodeext": {
        "description": "Set the extended encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "idx": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "char",
            "module": "char",
            "ops": "!=null",
            "crypt": "!=null",
            "sec": "!=null"
        },
        "post": {
            "crypt": "!=null",
            "group_key": "int"
        }
    }
},
{
    "kprobe:libipw_wx_get_encode": {
        "description": "Get the encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null",
            "erq": "!=null",
            "len": "int",
            "key": "int",
            "sec": "!=null",
            "LIBIPW_DEBUG_WX": "macro",
            "WEP_KEYS": "macro",
            "memcpy": "function",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "const char",
            "module": "const char",
            "ops": "struct lib80211_crypto_ops",
            "crypt": "struct lib80211_crypt_data",
            "sec.flags": "int",
            "idx": "int"
        },
        "post": {
            "return": "int"
        }
    },
    "kprobe:libipw_wx_set_encodeext": {
        "description": "Set the extended encoding information for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "dev": "!=null",
            "encoding": "!=null",
            "ext": "!=null",
            "i": "int",
            "ret": "int",
            "group_key": "int",
            "alg": "const char",
            "module": "const char",
            "ops": "struct lib80211_crypto_ops",
            "crypt": "struct lib80211_crypt_data",
            "sec.flags": "int",
            "idx": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
S,
{
    "libipw_xmit": {
        "description": "Transmit a packet using the libipw driver.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "ieee": "!=null",
            "skb->priority": "=0",
            "ieee->is_queue_full": "!=null",
            "(*ieee->is_queue_full)(dev, priority)": "=0",
            "ieee->lock": "!=null"
        }
    }
},
{
    "kretprobe:libipw_xmit": {
        "description": "Transmit an skb through a net_device.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:netdev_tx_t_libipw_xmit": {
        "description": "Transmit a network device packet using the libipw driver.",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:libipw_freq_to_channel": {
        "description": "Converts frequency to channel number based on the geography map.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null"
        },
        "post": {
            "return": "in [0, ieee->geo.bg_channels, ieee->geo.a_channels]"
        }
    }
},
{
    "kprobe:libipw_set_geo": {
        "description": "Set the geography map for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "geo": "!=null",
            "ieee->geo.bg_channels": "==0",
            "ieee->geo.a_channels": "==0"
        }
    },
    "kprobe:libipw_freq_to_channel": {
        "description": "Convert frequency to channel for the libipw device.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null",
            "freq": "% 100000 == 0",
            "ieee->freq_band & LIBIPW_24GHZ_BAND": "!=0",
            "ieee->freq_band & LIBIPW_52GHZ_BAND": "!=0"
        },
        "post": {
            "return": "!=0"
        }
    }
},
{
    "kretprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "pre": {
            "ieee.geo.bg_channels": "== 0",
            "ieee.geo.a_channels": "== 0",
            "return": "== 0",
            "ieee.freq_band": "& LIBIPW_24GHZ_BAND",
            "i": "< ieee.geo.bg_channels"
        }
    }
},
{
    "kprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "pre": {
            "ieee.geo.bg_channels": "== 0",
            "ieee.geo.a_channels": "== 0",
            "ieee.freq_band": "& LIBIPW_24GHZ_BAND",
            "for (i = 0; i < ieee.geo.bg_channels; i++)": "",
            "if (ieee.freq_band & LIBIPW_24GHZ_BAND)": "",
            "if (ieee.geo.bg_channels == 0 && ieee.geo.a_channels == 0)": "return 0"
        }
    }
},
{
    "kretprobe:libipw_freq_to_channel": {
        "description": "Converts a frequency to a channel number.",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null",
            "ieee.geo.bg_channels": "==0",
            "ieee.geo.a_channels": "==0"
        },
        "post": {
            "return": "!=0",
            "ch.channel": "!=null",
            "return": "ch.freq"
        }
    }
},
S,
S,
S,
{
    "kretprobe:alloc_libipw": {
        "description": "Allocate memory for libipw device",
        "pre": {
            "sizeof_priv": ">= 0",
            "monitor": "in {0, 1}",
            "dev": "!= null",
            "ieee": "!= null",
            "ieee->dev": "== dev",
            "ieee->wdev.wiphy": "!= null",
            "ieee->wdev.iftype": "in {NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC}"
        }
    },
    "kretprobe:libipw_networks_allocate": {
        "description": "Allocate memory for libipw networks",
        "pre": {
            "ieee": "!= null",
            "err": ">= 0"
        }
    }
},
{
    "alloc_libipw": {
        "description": "Allocate memory for libipw device",
        "pre": {
            "sizeof_priv": ">= 0",
            "monitor": "in [0, 1]"
        },
        "post": {
            "ieee->wdev.wiphy": "!= null",
            "ieee->dev->ieee80211_ptr": "!= null",
            "ieee->wdev.iftype": "in [NL80211_IFTYPE_STATION, NL80211_IFTYPE_ADHOC]"
        }
    }
},
{
    "kretprobe:free_libipw": {
        "description": "Free resources used by libipw.",
        "pre": {
            "monitor": "==0",
            "ieee->wdev.wiphy": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:free_libipw": {
        "description": "Free resources used by the libipw driver.",
        "pre": {
            "dev": "!=null",
            "monitor": "==0",
            "ieee->wdev.wiphy": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:wlcore_read": {
        "description": "Read the tx results from the chipset.",
        "pre": {
            "wl": "!=null",
            "memmap": "!=null",
            "memmap->tx_result": "!=null",
            "wl->tx_res_if": "!=null",
            "sizeof(*wl->tx_res_if)": ">0",
            "false": "true"
        }
    }
},
{
    "kprobe:wlcore_read": {
        "description": "Read the tx results from the chipset.",
        "pre": {
            "wl": "!=null",
            "memmap": "!=null",
            "memmap->tx_result": "!=null",
            "wl->tx_res_if": "!=null",
            "sizeof(*wl->tx_res_if)": "!=null",
            "false": "is boolean",
            "ret": "< 0",
            "fw_counter": "le32_to_cpu(wl->tx_res_if->tx_result_fw_counter)"
        }
    }
},
{
    "kretprobe:orinoco_stop": {
        "description": "Stop the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "err": "!=null",
            "priv.hw_unavailable": "!=true"
        }
    }
},
{
    "kprobe:orinoco_stop": {
        "description": "Stop the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "err": "int",
            "priv.hw_unavailable": "bool"
        }
    }
},
S,
S,
{
    "kretprobe:orinoco_change_mtu": {
        "description": "Change the MTU of the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "priv": "!=null",
            "priv->nicbuf_size": "!=null",
            "ETH_HLEN": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "dev->mtu": "new_mtu"
        }
    }
},
{
    "kprobe:orinoco_change_mtu": {
        "description": "Change the MTU of the orinoco network device.",
        "pre": {
            "dev": "!=null",
            "new_mtu": "!=null",
            "priv": "!=null",
            "priv == ndev_priv(dev)": true,
            "(new_mtu + ENCAPS_OVERHEAD + sizeof(struct ieee80211_hdr)) > (priv->nicbuf_size - ETH_HLEN)": true
        },
        "post": {
            "dev->mtu": "new_mtu",
            "return": "0"
        }
    }
},
{
    "kretprobe:orinoco_process_xmit_skb": {
        "description": "Encapsulate Ethernet-II frames",
        "pre": {
            "eh": {
                "h_proto": "> ETH_DATA_LEN"
            }
        }
    }
},
{
    "kprobe:orinoco_process_xmit_skb": {
        "description": "Encapsulate Ethernet-II frames",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "priv": "!=null",
            "tx_control": "!=null",
            "mic_buf": "!=null",
            "priv->encode_alg": "== ORINOCO_ALG_TKIP",
            "priv->keys[priv->tx_key].key": "!=null",
            "ntohs(eh->h_proto)": "> ETH_DATA_LEN"
        }
    }
},
{
    "kretprobe:if (priv->iw_mode == NL80211_IFTYPE_MONITOR)": {
        "description": "Check if the iw_mode of the priv struct is equal to NL80211_IFTYPE_MONITOR.",
        "pre": {
            "priv": "!=null",
            "priv->iw_mode": "== NL80211_IFTYPE_MONITOR"
        }
    }
},
{
    "kprobe:__orinoco_ev_rx": {
        "description": "Handle frames in monitor mode",
        "pre": {
            "dev": "!=null",
            "hw": "!=null",
            "priv": "!=null",
            "stats": "!=null",
            "wstats": "!=null",
            "skb": "null",
            "rxfid": "!=null",
            "status": "!=null",
            "length": "!=null",
            "desc": "!=null",
            "rx_data": "!=null",
            "err": "!=null"
        },
        "post": {
            "stats.rx_crc_errors": "stats.rx_crc_errors + 1"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "wdev = netdev_priv(dev)": {
        "description": "Assign the value of netdev_priv(dev) to wdev.",
        "pre": {
            "dev": "!=null"
        }
    },
    "wdev->wiphy = wiphy": {
        "description": "Assign the value of wiphy to wdev->wiphy.",
        "pre": {
            "wiphy": "!=null"
        }
    },
    "wdev->iftype = NL80211_IFTYPE_STATION": {
        "description": "Assign the value NL80211_IFTYPE_STATION to wdev->iftype.",
        "pre": {}
    }
},
{
    "kprobe:wdev = netdev_priv(dev);wdev->wiphy = wiphy;wdev->iftype = NL80211_IFTYPE_STATION;/* Setup / override net_device fields": {
        "description": "Initialize wireless_dev structure and set net_device fields.",
        "pre": {
            "wdev": "!=null",
            "wdev->wiphy": "!=null",
            "wdev->iftype": "==NL80211_IFTYPE_STATION",
            "dev": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kprobe:PRISM2_NO_KERNEL_IEEE80211_MGMTproc_create_seq_data": {
        "description": "Create a sequential file in the /proc file system for ap_control and ap.",
        "pre": {
            "local_info_t": "!=null",
            "local": {
                "ap": {
                    "proc": "!=null"
                }
            },
            "ap": {
                "proc": "!=null"
            }
        }
    }
},
{
    "kretprobe:list_for_each_entry_safe": {
        "description": "Iterate over a list of entries, safely removing each entry from the list.",
        "pre": {
            "sta": "!=null",
            "n": "!=null",
            "&ap->sta_list": "!=null",
            "list": "!=null"
        }
    }
},
S,
{
    "kretprobe:hostap_ap_tx_cb": {
        "description": "Callback function for hostap_ap_tx_cb",
        "pre": {
            "skb": "!=null",
            "ok": "int",
            "data": "!=null",
            "ap": "!=null",
            "sta_fw_ver": "int"
        },
        "post": {
            "ap->nullfunc_ack": {
                "value": "1",
                "condition": "sta_fw_ver == PRISM2_FW_VER(0,8,0)"
            }
        }
    }
},
{
    "kprobe:hostap_ap_tx_cb": {
        "description": "Callback function for hostap_ap_tx.",
        "pre": {
            "skb": "!=null",
            "ok": "!=null",
            "data": "!=null",
            "ap": "!=null",
            "sta_fw_ver": "!=null",
            "ap->nullfunc_ack": "in [0, 1]",
            "sta_fw_ver == PRISM2_FW_VER(0,8,0)": "ap->nullfunc_ack == 1",
            "sta_fw_ver == PRISM2_FW_VER(1,4,2)": "printk(KERN_WARNING \"%s: Warning: secondary station firmware version 1.4.2 does not seem to work in Host AP mode\\n\", ap->local->dev->name)"
        }
    }
},
{
    "kretprobe:hostap_handle_sta_tx_exc": {
        "description": "Handle TX exception for a station in hostap",
        "pre": {
            "sta": "!=null",
            "rate": ">0",
            "old": ">=0"
        }
    }
},
S,
S,
S,
{
    "kretprobe:tx.crypt": {
        "description": "Set the value of tx.crypt",
        "pre": {
            "tx": {
                "crypt": "!=null"
            },
            "local": {
                "crypt_info": {
                    "crypt": "!=null",
                    "tx_keyidx": "!=null"
                }
            }
        }
    },
    "kretprobe:tx.host_encrypt": {
        "description": "Set the value of tx.host_encrypt",
        "pre": {
            "tx": {
                "host_encrypt": 1
            }
        }
    }
},
{
    "kprobe:tx.crypt": {
        "description": "Set the value of tx.crypt",
        "pre": {
            "tx": {
                "crypt": {
                    "index": "local->crypt_info.tx_keyidx",
                    "value": "!=null"
                }
            }
        }
    },
    "kprobe:tx.host_encrypt": {
        "description": "Set the value of tx.host_encrypt",
        "pre": {
            "tx": {
                "host_encrypt": 1
            }
        }
    }
},
{
    "kretprobe:hostap_get_porttype": {
        "description": "Get the port type for the local_info_t structure.",
        "pre": {
            "local_info_t": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:hostap_set_string": {
        "description": "Set a string value for the hostap interface.",
        "pre": {
            "dev": "!=null",
            "rid": "!=null",
            "val": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "len": "<=MAX_SSID_LEN",
            "buf[0]": "len",
            "buf[2]": "val",
            "buf[2 + len]": "0",
            "iface": "!=null",
            "iface->local": "!=null",
            "iface->local->func": "!=null",
            "iface->local->func->set_rid": "!=null",
            "iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2)": "!=null",
            "hostap_get_porttype(local_info_t *local)": "!=null"
        }
    }
},
{
    "kretprobe:keylen = 6; /* first 5 octets`": {
        "description": "104-bit support seems to require that all the keys are set to the same keylen",
        "pre": {
            "local_info_t": "!=null",
            "local": "!=null",
            "val": "!=null",
            "old_val": "!=null",
            "i": "!=null",
            "keylen": "= 6",
            "len": "!=null",
            "idx": "!=null",
            "keybuf": "!=null",
            "encrypt_type": "in [NONE, WEP, OTHER]",
            "local->crypt_info.tx_keyidx": "!=null",
            "local->crypt_info.crypt[idx]": "!=null",
            "local->crypt_info.crypt[idx]->ops": "!=null",
            "local->crypt_info.crypt[idx]->ops->name": "!=null",
            "local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1)": ">= 0",
            "val": "!= old_val",
            "local->privacy_invoked": "!=null",
            "HFA384X_WEPFLAGS_PRIVACYINVOKED": "!=null",
            "local->open_wep": "!=null",
            "HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED": "!=null",
            "local->ieee_802_1x": "!=null",
            "local->wpa": "!=null",
            "local->host_decrypt": "!=null",
            "HFA384X_WEPFLAGS_HOSTENCRYPT": "!=null",
            "HFA384X_WEPFLAGS_HOSTDECRYPT": "!=null",
            "hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)": "!=null",
            "encrypt_type": "= WEP"
        }
    }
},
{
    "kprobe:keylen = 6; /* first 5 octets": {
        "description": "Set the key length to 6 for the first 5 octets.",
        "pre": {
            "local_info_t": "!=null",
            "local": "!=null",
            "val": "!=null",
            "old_val": "!=null",
            "i": "!=null",
            "keylen": "==6",
            "len": "!=null",
            "idx": "!=null",
            "keybuf": "!=null",
            "encrypt_type": "in [NONE, WEP, OTHER]",
            "local->crypt_info.tx_keyidx": "!=null",
            "local->crypt_info.crypt[idx]": "!=null",
            "local->crypt_info.crypt[idx]->ops": "!=null",
            "local->crypt_info.crypt[idx]->ops->name": "!=null",
            "local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2, 1)": ">=0",
            "val": "!=old_val",
            "local->privacy_invoked": "!=null",
            "HFA384X_WEPFLAGS_PRIVACYINVOKED": "!=null",
            "local->open_wep": "!=null",
            "HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED": "!=null",
            "local->ieee_802_1x": "!=null",
            "local->wpa": "!=null",
            "local->host_decrypt": "!=null",
            "HFA384X_WEPFLAGS_HOSTENCRYPT": "!=null",
            "HFA384X_WEPFLAGS_HOSTDECRYPT": "!=null",
            "hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)": ">=0"
        }
    }
},
{
    "kretprobe:hostap_set_word": {
        "description": "Set the value of the specified register in the hostap driver.",
        "pre": {
            "local": "!=null",
            "val": "!=null",
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "!= PRISM2_AUTH_OPEN",
            "val": "!= PRISM2_AUTH_SHARED_KEY"
        }
    }
},
{
    "kprobe:hostap_set_word": {
        "description": "Set the value of a word in the hostap driver.",
        "pre": {
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "!= PRISM2_AUTH_OPEN",
            "val": "!= PRISM2_AUTH_SHARED_KEY"
        }
    }
},
S,
{
    "kprobe:hostap_80211_get_hdrlen": {
        "description": "Calculate the header length of a hostap frame.",
        "pre": {
            "fc": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:hostap_set_multicast_list": {
        "description": "Set the multicast list for the hostap interface.",
        "pre": {
            "work": "!=null",
            "local": "!=null",
            "dev": {
                "flags": {
                    "&": ["IFF_ALLMULTI", "IFF_PROMISC"]
                }
            }
        }
    }
},
{
    "map": "!=null",
    "key": "!=null",
    "value": "!=null",
    "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
    "map_type": "not in [BPF_MAP_TYPE_ARRAY, BPF_MAP_TYPE_PERCPU_ARRAY] when flags == BPF_NOEXIST"
},
{
    "kretprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "pre": {
            "rx_stats": {
                "signal": "!=null",
                "noise": "!=null",
                "rate": "!=null"
            },
            "skb": {
                "len": ">=2"
            },
            "hdr": {
                "frame_control": "!=null",
                "frame_control_ftype": "(frame_control & IEEE80211_FCTL_FTYPE) >> 2 != null",
                "frame_control_stype": "(frame_control & IEEE80211_FCTL_STYPE) >> 4 != null",
                "frame_control_tods": "(frame_control & IEEE80211_FCTL_TODS) != null",
                "frame_control_fromds": "(frame_control & IEEE80211_FCTL_FROMDS) != null",
                "addr1": "!=null",
                "addr2": "!=null",
                "addr3": "!=null",
                "addr4": "!=null"
            }
        }
    }
},
{
    "kprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "pre": {
            "dev": "any",
            "skb": {
                "len": ">=2"
            },
            "rx_stats": {
                "signal": "!=null",
                "noise": "!=null",
                "rate": "!=null"
            },
            "type": "any"
        }
    }
},
S,
{
    "kprobe:hostap_info_init": {
        "description": "Initialize hostap info",
        "pre": {
            "local": "!=null",
            "local->info_list": "is empty",
            "PRISM2_NO_STATION_MODES": "not defined"
        }
    }
},
{
    "kretprobe:info = (struct hfa384x_info_frame *) skb->data; buf = skb->data + sizeof(*info); left = skb->len - sizeof(*info); switch (le16_to_cpu(info->type))": {
        "description": "Process hostap info",
        "pre": {
            "skb": {
                "data": "!=null",
                "len": "!=null"
            },
            "info": {
                "type": "!=null"
            },
            "buf": "!=null",
            "left": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kprobe:stop_atmel_card": {
        "description": "Stop the Atmel card and perform cleanup operations.",
        "pre": {
            "dev": "!=null",
            "priv": "!=null",
            "priv->bus_type": "==BUS_TYPE_PCCARD"
        },
        "post": {
            "dev": "unregister_netdev(dev)",
            "priv->management_timer": "del_timer_sync(&priv->management_timer)",
            "priv->firmware": "kfree(priv->firmware)",
            "dev->irq": "free_irq(dev->irq, dev)",
            "dev->base_addr": "release_region(dev->base_addr, 32)",
            "NULL": "remove_proc_entry(\"driver/atmel\", NULL)",
            "NULL": "free_netdev(dev)"
        }
    }
},
{
    "kretprobe:rtw_phy_read_rf_sipi": {
        "description": "Reads a value from the RF SIPI address.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, hal->rf_phy_num)",
            "addr": "!=null",
            "mask": "!=null"
        }
    }
},
S,
{
    "kretprobe:rtw_phy_set_tx_power_level": {
        "description": "Set the transmit power level for a specific channel and path in the rtw_dev structure.",
        "pre": {
            "rtwdev": "!=null",
            "ch": "!=null",
            "path": "!=null",
            "hal": "!=null",
            "hal.current_band_type": "==RTW_BAND_2G",
            "rs": ">=RTW_RATE_SECTION_CCK",
            "rs": "<RTW_RATE_SECTION_MAX"
        }
    }
},
{
    "kprobe:rtw_phy_set_tx_power_level": {
        "description": "Set the transmit power level for a specific channel and path.",
        "pre": {
            "rtwdev": "!=null",
            "ch": "!=null",
            "path": "!=null",
            "hal->current_band_type": "==RTW_BAND_2G",
            "rs": ">=RTW_RATE_SECTION_CCK",
            "rs": "<RTW_RATE_SECTION_MAX"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:rtw_power_mode_change": {
        "description": "Toggle the request power mode",
        "pre": {
            "rtwdev": "!=null",
            "enter": true,
            "request": "!=null",
            "BIT_RPWM_TOGGLE": "!=null"
        }
    }
},
{
    "kprobe:rtw_power_mode_change": {
        "description": "Toggle the request power mode",
        "pre": {
            "rtwdev": "!=null",
            "enter": "!=null",
            "request": "!=null",
            "confirm": "!=null",
            "polling": "!=null",
            "ret": "!=null",
            "request": "is_bit_set(request, BIT_RPWM_TOGGLE)",
            "confirm": "0",
            "polling": "0",
            "ret": "0"
        }
    }
},
{
    "kretprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "Receive C2H command in the firmware.",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": "!=null",
            "skb": "!=null",
            "skb->data + pkt_offset": "!=null",
            "skb->len - pkt_offset - 2": ">=0",
            "skb->cb": "!=null"
        },
        "post": {
            "*((u32 *)skb->cb)": "pkt_offset"
        }
    }
},
{
    "kprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "Receives a command from firmware and performs further operations based on the command ID.",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:rtw_tx_report_enqueue": {
        "description": "Enqueue a transmit report",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "sn": "!=null"
        },
        "post": {
            "drv_data": "!=null",
            "*drv_data": "sn",
            "tx_report.q_lock": "locked",
            "tx_report.queue": "contains(skb)",
            "tx_report.purge_timer": "modified"
        }
    }
},
S,
S,
S,
{
    "kretprobe:rtw_pci_probe": {
        "description": "Probe function for rtw_pci",
        "pre": {
            "rtwdev->chip->id": "== RTW_CHIP_TYPE_8821C",
            "bridge->vendor": "== PCI_VENDOR_ID_INTEL"
        },
        "post": {
            "rtwpci->rx_no_aspm": "== true"
        }
    }
},
{
    "kprobe:rtw_pci_probe": {
        "description": "Probe function for rtw_pci",
        "pre": {
            "rtwdev->chip->id": "== RTW_CHIP_TYPE_8821C",
            "bridge->vendor": "== PCI_VENDOR_ID_INTEL"
        }
    }
},
{
    "kretprobe:rtw_ops_start": {
        "description": "Starts the rtw_ops",
        "pre": {
            "txq": {
                "ac": "IEEE80211_AC_VO"
            }
        },
        "post": {
            "__rtw_tx_work": {},
            "queue_work": {
                "tx_wq": "!=null",
                "work": "&rtwdev->tx_work"
            }
        }
    }
},
{
    "kprobe:rtw_ops_start": {
        "description": "Start the rtw_ops",
        "pre": {
            "txq->ac": "== IEEE80211_AC_VO",
            "__rtw_tx_work(rtwdev)": "called if txq->ac == IEEE80211_AC_VO",
            "queue_work(rtwdev->tx_wq, &rtwdev->tx_work)": "called if txq->ac != IEEE80211_AC_VO"
        }
    }
},
{
    "kretprobe:rtw_coex_write_scbd": {
        "description": "Write to the scbd array in the rtw_coex structure.",
        "pre": {
            "chip": {
                "new_scbd10_def": "==false"
            },
            "bitpos": "& COEX_SCBD_FIX2M"
        }
    }
},
{
    "if (!chip->new_scbd10_def && (bitpos & COEX_SCBD_FIX2M))": {
        "description": "Check if the new_scbd10_def is false and bitpos has the COEX_SCBD_FIX2M flag set.",
        "pre": {
            "chip": {
                "new_scbd10_def": "==false"
            },
            "bitpos": {
                "&": ["COEX_SCBD_FIX2M"]
            }
        }
    }
},
S,
S,
{
    "kretprobe:rtw89_phy_write_rf": {
        "description": "Write RF register in the rtw89_phy_write_rf function.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, rtwdev->chip->rf_path_num)",
            "addr": ">= 0",
            "mask": ">= 0",
            "data": ">= 0",
            "chip": "!=null",
            "base_addr": "!=null",
            "direct_addr": "!=null",
            "RFREG_MASK": "!=null"
        }
    }
},
{
    "kprobe:rtw89_phy_write_rf": {
        "description": "Write RF register in the rtw89_phy_write_rf function.",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [0, rtwdev->chip->rf_path_num)",
            "addr": ">=0 && <=255",
            "mask": ">=0",
            "data": ">=0",
            "chip": "!=null",
            "base_addr": "!=null",
            "direct_addr": "!=null",
            "RFREG_MASK": "!=null",
            "rtw89_phy_write32_mask": "!=null"
        }
    }
},
{
    "kretprobe:rtw89_phy_write32_idx": {
        "description": "Write a 32-bit value to a PHY register at the specified address.",
        "pre": {
            "rtwdev": "!=null",
            "addr": "!=null",
            "mask": "!=null",
            "data": "!=null",
            "phy_idx": "in [RTW89_PHY_IDX_0, RTW89_PHY_IDX_1]"
        },
        "post": {
            "ofst": "= 0 if phy_page >= 0x40 && phy_page <= 0x4f, else = 0x2000"
        }
    }
},
S,
{
    "kretprobe:drv_info_len": {
        "description": "Calculate the length of drv_info in 8-byte units.",
        "pre": {
            "rtwdev": "!=null",
            "desc_info": "!=null",
            "data": "!=null",
            "data_offset": "!=null",
            "chip": "!=null",
            "rxd_s": "!=null",
            "rxd_l": "!=null",
            "shift_len": "!=null"
        },
        "post": {
            "drv_info_len": "desc_info->drv_info_size << 3"
        }
    }
},
{
    "kprobe:drv_info_len": {
        "description": "Calculate the length of drv_info in 8-byte units.",
        "pre": {
            "rtwdev": "!=null",
            "desc_info": "!=null",
            "data": "!=null",
            "data_offset": "!=null",
            "chip": "!=null",
            "rxd_s": "!=null",
            "rxd_l": "!=null",
            "shift_len": "!=null",
            "drv_info_len": "!=null"
        }
    }
},
{
    "kretprobe:rtw89_core_rx_process_phy_ppdu_iter": {
        "description": "Process the PHY PPDU in the RX path of the rtw89_core driver.",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "phy_ppdu": "!=null",
            "rxinfo": "!=null",
            "rx_cnt_valid": "in [true, false]",
            "plcp_size": ">=0",
            "usr_num": ">=0",
            "phy_sts": "!=null"
        }
    }
},
{
    "kprobe:rtw89_core_rx_process_phy_ppdu_iter": {
        "description": "Process PHY PPDU in RX core",
        "pre": {
            "usr_num": "& BIT(0) != 0",
            "rx_cnt_valid": "true",
            "plcp_size": ">= 0",
            "phy_ppdu->buf": "!= null",
            "phy_ppdu->len": "skb->data + skb->len - phy_sts"
        }
    }
},
S,
S,
S,
{
    "kprobe:cancel_work_sync": {
        "description": "Cancel a work item and wait for it to complete.",
        "pre": {
            "rtwdev": "!=null",
            "mutex": "!=null",
            "rtw89_leave_ps_mode": "!=null",
            "hw": "!=null",
            "changed": "!=null",
            "IEEE80211_CONF_CHANGE_IDLE": "!=null",
            "IEEE80211_CONF_CHANGE_CHANNEL": "!=null"
        }
    },
    "kprobe:mutex_lock": {
        "description": "Lock a mutex.",
        "pre": {
            "rtwdev": "!=null",
            "mutex": "!=null"
        }
    },
    "kprobe:rtw89_leave_ps_mode": {
        "description": "Leave power save mode.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_leave_ips": {
        "description": "Leave idle power save mode.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_core_tx_write": {
        "description": "Write a transmit frame to the core.",
        "pre": {
            "rtwdev": "!=null",
            "vif": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "qsel": "!=null"
        }
    },
    "kprobe:rtw89_core_tx_kick_off": {
        "description": "Kick off the transmit process.",
        "pre": {
            "rtwdev": "!=null",
            "qsel": "!=null"
        }
    },
    "kprobe:ieee80211_schedule_txq": {
        "description": "Schedule a transmission queue.",
        "pre": {
            "hw": "!=null",
            "txq": "!=null"
        }
    },
    "kprobe:queue_work": {
        "description": "Queue a work item.",
        "pre": {
            "rtwdev": "!=null",
            "txq_wq": "!=null",
            "txq_work": "!=null"
        }
    },
    "kprobe:rtw89_core_start": {
        "description": "Start the core.",
        "pre": {
            "rtwdev": "!=null"
        }
    },
    "kprobe:rtw89_core_stop": {
        "description": "Stop the core.",
        "pre": {
            "rtwdev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:elsetbl_w1 = cxtbl[8];if (dm->leak_ap && (type == BTC_CXP_PFIX || type == BTC_CXP_PAUTO2))": {
        "description": "Set the value of elsetbl_w1 to the entry at index 8 in cxtbl if dm->leak_ap is true and type is either BTC_CXP_PFIX or BTC_CXP_PAUTO2.",
        "pre": {
            "dm->leak_ap": "==true",
            "type": "in [BTC_CXP_PFIX, BTC_CXP_PAUTO2]"
        }
    }
},
{
    "kprobe:elsetbl_w1": {
        "description": "Set the value of elsetbl_w1 based on the conditions",
        "pre": {
            "dm->leak_ap": true,
            "type": {
                "in": ["BTC_CXP_PFIX", "BTC_CXP_PAUTO2"]
            }
        }
    }
},
{
    "kretprobe:rtl_init_rfkill": {
        "description": "Initialize RFKill state",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv->rfkill.rfkill_state": "==true",
            "hw->wiphy": "!=null",
            "valid": "!=null"
        }
    }
},
{
    "kprobe:rtl_init_rfkill": {
        "description": "Set the initial state of rfkill to on.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv.rfkill.rfkill_state": "true",
            "hw.wiphy": "!=null",
            "valid": "!=null"
        }
    },
    "kprobe:wiphy_rfkill_set_hw_state": {
        "description": "Set the hardware state of wiphy rfkill to 0.",
        "pre": {
            "hw.wiphy": "!=null",
            "state": "0"
        }
    },
    "kprobe:rtlpriv.cfg.ops.radio_onoff_checking": {
        "description": "Perform radio on/off checking.",
        "pre": {
            "hw": "!=null",
            "valid": "!=null"
        }
    }
},
{
    "kretprobe:rtl_get_tcb_desc": {
        "description": "Helper function to get the TCB descriptor for special data and management frames.",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "tcb_desc": "!=null",
            "tcb_desc->hw_rate": "!=null",
            "tcb_desc->use_spe_rpt": "in [0, 1]",
            "fc": "!=null",
            "ieee80211_is_data(fc)": "==true"
        }
    }
},
{
    "kprobe:rtl_get_tcb_desc": {
        "description": "Helper function to get the TCB (Transmit Control Block) descriptor.",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "tcb_desc": "!=null",
            "tcb_desc->hw_rate": "is used for special data and mgt frames"
        }
    }
},
{
    "kretprobe:if (!mac->act_scanning) return;": {
        "description": "Check if scanning is active",
        "pre": {
            "mac": "!=null",
            "mac.act_scanning": "==false"
        }
    }
},
{
    "kprobe:if (!mac->act_scanning) return;": {
        "description": "Check if this is a beacon",
        "pre": {
            "mac": {
                "act_scanning": false
            }
        }
    }
},
{
    "kretprobe:skb_queue_tail": {
        "description": "Enqueue an skb into the c2hcmd_queue.",
        "pre": {
            "rtlpriv": "!=null",
            "hw": "!=null",
            "skb": "!=null",
            "rtl_c2h_fast_cmd(hw, skb)": true
        },
        "post": {
            "skb_queue_tail(&rtlpriv->c2hcmd_queue, skb)": true
        }
    }
},
{
    "kprobe:skb_queue_tail": {
        "description": "Enqueue an skb to the c2hcmd_queue.",
        "pre": {
            "hw": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "if (skb)": {
        "description": "Check if skb is not null",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "if (skb)": {
        "description": "Check if skb is not null.",
        "pre": {
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_init": {
        "description": "Initialize the spin lock for usb_lock.",
        "pre": {
            "usb_lock": "!=null"
        }
    }
},
S,
{
    "kretprobe:wait_for_completion(&rtlpriv->firmware_loading_complete);clear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);/*ieee80211_unregister_hw will call ops_stop `": {
        "description": "Wait for completion of firmware loading and clear a bit in rtlpriv->status.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->firmware_loading_complete": "==true",
            "&rtlpriv->status": "!=null",
            "RTL_STATUS_INTERFACE_START": "is not set",
            "ieee80211_unregister_hw": "will call ops_stop"
        }
    }
},
{
    "kprobe:wait_for_completion(&rtlpriv->firmware_loading_complete);clear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);/*ieee80211_unregister_hw will call ops_stop `": {
        "description": "Function to wait for completion of firmware loading and clear a bit in the status variable.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->firmware_loading_complete": "==true",
            "rtlpriv->status": "!=null",
            "RTL_STATUS_INTERFACE_START": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:rtl_cmd_send_packet": {
        "description": "Send a packet using RTL commands.",
        "pre": {
            "hw": "!=null",
            "skb": "!=null",
            "ring": "!=null",
            "pdesc": "!=null",
            "flags": "!=null",
            "rtlpriv": "!=null",
            "rtlpci": "!=null",
            "pskb": "!=null"
        }
    }
},
S,
{
    "kretprobe:rtl_ps_enable_nic": {
        "description": "Reset trx ring",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "rtlhal": "!=null",
            "rtlmac": "!=null",
            "rtlhal.interface": "==INTF_PCI",
            "rtlpriv.intf_ops.reset_trx_ring": "called with argument hw",
            "is_hal_stop(rtlhal)": "==true"
        }
    }
},
{
    "kprobe:rtl_ps_enable_nic": {
        "description": "Reset trx ring",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "rtlhal": "!=null",
            "rtlmac": "!=null",
            "rtlhal.interface": "==INTF_PCI",
            "rtlpriv.intf_ops": "!=null",
            "rtlpriv.intf_ops.reset_trx_ring": "!=null",
            "is_hal_stop(rtlhal)": "==true"
        }
    }
},
{
    "kretprobe:rtl_deinit_deferred_work": {
        "description": "Disable Interrupt",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv.hw": "==hw",
            "timer_stopped": "==true"
        }
    }
},
{
    "kprobe:rtl_deinit_deferred_work": {
        "description": "Disable Interrupt",
        "pre": {
            "hw": "!=null",
            "hw.type": "==struct ieee80211_hw",
            "hw.priv": "!=null",
            "hw.priv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv": "!=null",
            "hw.priv.rtlpriv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw": "==hw",
            "hw.priv.rtlpriv.hw.type": "==struct ieee80211_hw",
            "hw.priv.rtlpriv.hw.priv": "==hw.priv",
            "hw.priv.rtlpriv.hw.priv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv": "==hw.priv.rtlpriv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.type": "==struct rtl_priv",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.hw": "==hw",
            "hw.priv.rtlpriv.hw.priv.rtlpriv.hw.type": "==struct ieee80211_hw"
        }
    }
},
{
    "kretprobe:rtl_pci_probe": {
        "description": "Initialize cfg and intf_ops",
        "pre": {
            "rtlpriv.proximity.proxim_on": false,
            "pcipriv.dev.pdev": "pdev"
        }
    }
},
{
    "kprobe:rtl_pci_probe": {
        "description": "Probe function for rtl_pci",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:efuse_initialize": {
        "description": "Initialize the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null"
        }
    },
    "kretprobe:efuse_read_1byte": {
        "description": "Read one byte from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "data": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null",
            "k": "!=null",
            "efuse_len": "!=null",
            "address": "<= efuse_len"
        },
        "post": {
            "data": "!=null"
        }
    },
    "kretprobe:efuse_write_1byte": {
        "description": "Write one byte to the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "bytetemp": "!=null",
            "temp": "!=null",
            "k": "!=null",
            "efuse_len": "!=null",
            "address": "<= efuse_len",
            "value": "!=null"
        }
    },
    "kretprobe:read_efuse_byte": {
        "description": "Read a byte from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "_offset": "!=null",
            "pbuf": "!=null",
            "value32": "!=null",
            "readbyte": "!=null",
            "retry": "!=null"
        },
        "post": {
            "pbuf": "!=null"
        }
    },
    "kretprobe:read_efuse": {
        "description": "Read data from the efuse.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlefuse": "!=null",
            "efuse_tbl": "!=null",
            "rtemp8": "!=null",
            "efuse_addr": "!=null",
            "offset": "!=null",
            "wren": "!=null",
            "u1temp": "!=null",
            "i": "!=null",
            "j": "!=null",
            "efuse_max_section": "!=null",
            "efuse_len": "!=null",
            "efuse_word": "!=null",
            "efuse_utilized": "!=null",
            "efuse_usage": "!=null",
            "_offset": "<= efuse_len",
            "_size_byte": "!=null"
        },
        "post": {
            "pbuf": "!=null"
        }
    }
},
{
    "kprobe:efuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], GFP_ATOMIC);if (!efuse_tbl)return;efuse_word = kcalloc(EFUSE_MAX_WORD_UNIT, sizeof(u16 *), GFP_ATOMIC);if (!efuse_word)goto out;for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++)": {
        "description": "Allocate memory for efuse_tbl and efuse_word.",
        "pre": {
            "rtlpriv": "!=null",
            "rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]": "!=null",
            "GFP_ATOMIC": "!=null",
            "efuse_tbl": "==null",
            "efuse_word": "==null",
            "EFUSE_MAX_WORD_UNIT": "!=null",
            "sizeof(u16 *)": "!=null",
            "i": "!=null",
            "i": "< EFUSE_MAX_WORD_UNIT"
        }
    }
},
{
    "kretprobe:rtl_cam_del_entry": {
        "description": "Delete an entry from the RTL CAM.",
        "pre": {
            "i": "= 4",
            "i": "< TOTAL_CAM_ENTRY"
        }
    }
},
{
    "kprobe:rtl_cam_del_entry": {
        "description": "Does STA already exist?",
        "pre": {
            "hw": "!=null",
            "sta_addr": "!=null",
            "sta_addr": "!is_zero_ether_addr(sta_addr)"
        }
    }
},
{
    "kretprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Fill IQK matrix for path A in _rtl92c_phy_path_a_fill_iqk_matrix function.",
        "pre": {
            "hw": "!=null",
            "b_patha_ok": "!=null",
            "result": "!=null",
            "final_candidate": "!=null",
            "reg_ea4": "==0"
        }
    }
},
{
    "kprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Function _rtl92c_phy_path_a_fill_iqk_matrix",
        "pre": {
            "hw": "!=null",
            "b_patha_ok": "!=null",
            "result": "!=null",
            "final_candidate": "!=null",
            "reg_ea4": "==0"
        }
    }
},
{
    "kretprobe:rtl92c_dm_initial_gain_min_pwdb": {
        "description": "Calculate the minimum received signal strength value.",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "dm_digtable": "!=null",
            "rssi_val_min": ">10000"
        }
    }
},
S,
{
    "kretprobe:rtl92c_dm_watchdog": {
        "description": "Watchdog function for rtl92c_dm",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "fw_current_inpsmode": "bool",
            "fw_ps_awake": "bool",
            "ppsc->p2p_ps_info.p2p_ps_mode": "bool",
            "ppsc->rfpwr_state": "ERFON",
            "!fw_current_inpsmode": "true",
            "fw_ps_awake": "true",
            "!ppsc->rfchange_inprogress": "true"
        }
    }
},
{
    "kprobe:rtl92c_dm_watchdog": {
        "description": "Watchdog function for rtl92c_dm",
        "pre": {
            "hw": "!=null"
        }
    }
},
{
    "kretprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine AMPDU setting for BT coexistence.",
        "pre": {
            "undec_sm_pwdb": ">= 67",
            "curr_bt_rssi_state": "&= (~BT_RSSI_STATE_NORMAL_POWER)",
            "undec_sm_pwdb": "< 62",
            "curr_bt_rssi_state": "|= BT_RSSI_STATE_NORMAL_POWER"
        }
    }
},
{
    "kprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine AMPDU setting for BT coexistence.",
        "pre": {
            "undec_sm_pwdb": ">= 67",
            "curr_bt_rssi_state": "&= (~BT_RSSI_STATE_NORMAL_POWER)",
            "undec_sm_pwdb": "< 62",
            "curr_bt_rssi_state": "|= BT_RSSI_STATE_NORMAL_POWER"
        }
    }
},
S,
S,
{
    "kretprobe:if (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq))": {
        "description": "Check if the FLAG_MPI bit is set in ai->flags and the ai->txq is not empty.",
        "pre": {
            "ai": "!=null",
            "FLAG_MPI": "is set in ai->flags",
            "ai->txq": "is not empty"
        }
    }
},
{
    "description": "Check if the FLAG_MPI bit is set in ai->flags and the ai->txq is not empty.",
    "pre": {
        "ai->flags": "test_bit(FLAG_MPI, &ai->flags)",
        "ai->txq": "!skb_queue_empty(&ai->txq)"
    }
},
{
    "init_airo_card": {
        "pre": {
            "dev": "!=null",
            "ai": "!=null",
            "irq": null,
            "port": null,
            "is_pcmcia": null,
            "pci": "!=null",
            "dmdev": "!=null"
        },
        "description": "Create the network device object."
    }
},
S,
{
    "kretprobe:reset_airo_card": {
        "description": "Reset the airo card.",
        "pre": {
            "!test_bit(FLAG_MPI, &ai->flags)": true,
            "for (i = 0; i < MAX_FIDS; i++)": {
                "ai->fids[i]": "transmit_allocate(ai, AIRO_DEF_MTU, i >= MAX_FIDS/2)"
            },
            "enable_interrupts(ai)": true,
            "netif_wake_queue(dev)": true
        }
    }
},
S,
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancel the synchronous execution of work associated with the kevent of the device.",
        "pre": {
            "dev": "!=null",
            "kevent": "!=null"
        }
    },
    "kretprobe:del_timer_sync": {
        "description": "Delete the timer associated with the delay of the device synchronously.",
        "pre": {
            "dev": "!=null",
            "delay": "!=null"
        }
    },
    "kretprobe:free_percpu": {
        "description": "Free the per-CPU statistics of the network.",
        "pre": {
            "net": "!=null",
            "tstats": "!=null"
        }
    },
    "kretprobe:free_netdev": {
        "description": "Free the network device.",
        "pre": {
            "net": "!=null"
        }
    },
    "kretprobe:usbnet_probe": {
        "description": "Probe the USB network device.",
        "pre": {}
    }
},
S,
{
    "kretprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status",
        "pre": {
            "phydev": "!=null",
            "(*phydev)": "valid_phy_device_struct"
        }
    }
},
{
    "kprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from the target phy_device struct.",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return_value": ">0"
        }
    }
},
{
    "kprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from the phydev.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask.",
        "pre": {
            "speed": "!=null",
            "duplex": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask.",
        "pre": {
            "speed": "!=null",
            "duplex": "!=null",
            "features": "!=null"
        }
    }
},
{
    "kretprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "int"
        }
    }
},
{
    "kprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "int"
        },
        "post": {
            "return": "int"
        }
    }
},
{
    "kprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:phy_do_ioctl_running": {
        "description": "Generic ndo_eth_ioctl implementation but test first.",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kretprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test": {
        "description": "Start a cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test": {
        "description": "Start a cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kretprobe:phy_config_aneg": {
        "description": "Configures auto-negotiation for the PHY device.",
        "pre": {
            "phydev": "!=null",
            "phydev->is_c45": "==true",
            "!(phydev->c45_ids.devices_in_package & BIT(0))": "==true"
        },
        "post": {
            "return_value": "genphy_c45_config_aneg(phydev)"
        }
    }
},
{
    "kprobe:phy_config_aneg": {
        "description": "Configure autonegotiation for the PHY device.",
        "pre": {
            "phydev": "!=null",
            "phydev->is_c45": "==true",
            "!(phydev->c45_ids.devices_in_package & BIT(0))": "==true"
        }
    }
},
{
    "kretprobe:linkmode_and": {
        "description": "Verify the settings we care about.",
        "pre": {
            "advertising": "!=null",
            "advertising": "!=null",
            "phydev->supported": "!=null",
            "cmd->base.autoneg": "!=null",
            "cmd->base.duplex": "!=null",
            "cmd->base.speed": "!=null",
            "cmd->base.phy_address": "==phydev->mdio.addr"
        }
    }
},
{
    "kprobe:linkmode_and": {
        "description": "Verify the settings we care about.",
        "pre": {
            "advertising": "!=null",
            "advertising": "!=null",
            "phydev->supported": "!=null",
            "cmd->base.autoneg": "!=null",
            "cmd->base.duplex": "!=null",
            "cmd->base.speed": "!=null",
            "cmd->base.phy_address": "phydev->mdio.addr"
        }
    }
},
{
    "kretprobe:phy_error": {
        "description": "Enter ERROR state for this PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->lock": "not held",
            "context": "not interrupt"
        }
    }
},
{
    "kprobe:phy_error": {
        "description": "Enter ERROR state for the PHY device and inform the controller that the link is down.",
        "pre": {
            "phydev": "!=null",
            "phydev->lock": "not held",
            "context": "not interrupt"
        }
    }
},
{
    "kretprobe:phy_request_interrupt": {
        "description": "Request and enable interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "irq": "valid IRQ number"
        }
    }
},
{
    "kprobe:phy_request_interrupt": {
        "description": "Request and enable interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "irq": "valid IRQ number"
        }
    }
},
{
    "kretprobe:phy_free_interrupt": {
        "description": "Disable and free interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->irq": "==PHY_POLL"
        }
    }
},
{
    "kprobe:phy_free_interrupt": {
        "description": "Disable and free interrupt for a PHY device",
        "pre": {
            "phydev": "!=null",
            "phydev->irq": "==PHY_POLL"
        }
    }
},
{
    "kretprobe:phy_stop_machine": {
        "description": "stop the PHY state machine tracking",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_stop_machine": {
        "description": "Stop the PHY state machine tracking",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:phy_init_eee": {
        "description": "init and check the EEE feature",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_init_eee": {
        "description": "init and check the EEE feature",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:phy_get_eee_err": {
        "description": "Report the EEE wake error count",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_get_eee_err": {
        "description": "Report the EEE wake error count.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_eee": {
        "description": "get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_eee": {
        "description": "Get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_wol": {
        "description": "Configure Wake On LAN",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kretprobe:mdio_device_create": {
        "description": "Allocate and initialize an MDIO device.",
        "pre": {
            "bus": "!=null",
            "addr": "int"
        },
        "post": {
            "mdiodev": "!=null",
            "mdiodev->dev.release": "==mdio_device_release",
            "mdiodev->dev.parent": "==&bus->dev",
            "mdiodev->dev.bus": "==&mdio_bus_type",
            "mdiodev->device_free": "==mdio_device_free",
            "mdiodev->device_remove": "==mdio_device_remove",
            "mdiodev->bus": "==bus",
            "mdiodev->addr": "==addr"
        }
    }
},
{
    "kprobe:mdio_device_create": {
        "description": "Allocate and initialize an MDIO device.",
        "pre": {
            "bus": "!=null",
            "addr": "int"
        }
    }
},
{
    "kretprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "pre": {
            "mdiodev->bus": "==bus",
            "mdiodev->addr": "==addr",
            "dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr)": "called",
            "device_initialize(&mdiodev->dev)": "called"
        },
        "post": {
            "return": "mdiodev"
        }
    }
},
{
    "kprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->addr": "!=null",
            "dev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr)": "success",
            "device_initialize(&mdiodev->dev)": "success"
        }
    }
},
{
    "kretprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_eee_is_active": {
        "description": "get EEE status",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        }
    }
},
{
    "kprobe:genphy_c45_eee_is_active": {
        "description": "get EEE status",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_ethtool_get_eee": {
        "description": "get EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
S,
{
    "kretprobe:genphy_c45_ethtool_set_eee": {
        "description": "set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null",
            "data->eee_enabled": "in [true, false]"
        }
    }
},
{
    "kprobe:genphy_c45_ethtool_set_eee": {
        "description": "set EEE supported and status",
        "pre": {
            "phydev": "!=null",
            "data": "!=null",
            "data->eee_enabled": "in [true, false]"
        }
    }
},
{
    "kretprobe:mdio_device_reset": {
        "description": "Reset the MDIO device and register it with the MDIO bus.",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->addr": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags & MDIO_DEVICE_FLAG_PHY": "!=0"
        }
    }
},
{
    "kprobe:mdio_device_reset": {
        "description": "Reset the MDIO device.",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags & MDIO_DEVICE_FLAG_PHY": "!=0"
        }
    }
},
{
    "kretprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure",
        "pre": {
            "size": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus.",
        "pre": {
            "mdio_name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus.",
        "pre": {
            "mdio_name": "!=null"
        }
    }
},
{
    "kretprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus.",
        "pre": {
            "mdio_bus_np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus.",
        "pre": {
            "mdio_bus_np": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus.",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus. MDIO devices which are not PHYs will not be brought up by this function.",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:bus->state = MDIOBUS_UNREGISTERED": {
        "description": "Set the state of the bus to MDIOBUS_UNREGISTERED",
        "pre": {
            "bus": "!=null",
            "bus->state": "==MDIOBUS_UNREGISTERED"
        }
    },
    "kretprobe:err = device_register(&bus->dev)": {
        "description": "Register the device",
        "pre": {
            "bus": "!=null",
            "&bus->dev": "!=null",
            "err": "!=null"
        }
    },
    "kretprobe:if (err)": {
        "description": "Handle error",
        "pre": {
            "err": "!=0"
        }
    }
},
{
    "kprobe:bus->state = MDIOBUS_UNREGISTERED; err = device_register(&bus->dev); if (err)": {
        "description": "Update the state of the bus to MDIOBUS_UNREGISTERED and register the device. If an error occurs during registration, the state will not be updated.",
        "pre": {
            "bus": "!=null",
            "bus->state": "==MDIOBUS_UNREGISTERED",
            "err": "!=null",
            "device_register(&bus->dev)": "returns 0 on success"
        }
    }
},
{
    "kretprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        },
        "post": {
            "return_value": ">= 0"
        }
    }
},
{
    "kprobe:__mdiobus_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device.",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        }
    }
},
{
    "kprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device.",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        }
    }
},
{
    "kretprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper.",
        "pre": {
            "node": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper.",
        "pre": {
            "node": "!=null",
            "port": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper.",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper.",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kretprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support.",
        "pre": {
            "phydev": "!=null",
            "max_speed": "!=null"
        }
    }
},
{
    "kprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support.",
        "pre": {
            "phydev": "!=null",
            "max_speed": "!=null"
        }
    }
},
{
    "kretprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": ">=0 && <=31",
            "regnum": ">=0 && <=65535"
        }
    }
},
{
    "kprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": ">=0 && <=31",
            "regnum": ">=0 && <=65535"
        }
    }
},
{
    "kretprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "pre": {
            "phydev": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kretprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "mask": "!=null",
            "set": "!=null"
        },
        "post": {
            "return_value": "in [-errno, 0, 1]"
        }
    }
},
{
    "kprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register",
        "pre": {
            "phydev": "!=null",
            "page": "!=null",
            "regnum": "!=null",
            "mask": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kretprobe:phy_register_fixup": {
        "description": "Creates a new phy_fixup and adds it to the list",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null",
            "run": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null"
        }
    }
},
{
    "kprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list.",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "!=null",
            "phy_uid_mask": "!=null"
        }
    }
},
{
    "kretprobe:phy_device_create": {
        "description": "We allocate the device, and initialize the default values.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "phy_id": "!=null",
            "is_c45": "!=null",
            "c45_ids": "!=null"
        }
    }
},
{
    "kprobe:phy_device_create": {
        "description": "We allocate the device, and initialize the default values.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "phy_id": "!=null",
            "is_c45": "!=null",
            "c45_ids": "!=null"
        }
    }
},
{
    "kretprobe:get_phy_device": {
        "description": "Probe for a PHY at @addr on @bus.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "is_c45": "!=null"
        },
        "post": {
            "return": "!=null",
            "return": "is instance of struct phy_device",
            "return": "is not %-ENODEV",
            "return": "is not %-EIO"
        }
    }
},
{
    "kprobe:get_phy_device": {
        "description": "Probe for a PHY at @addr on @bus and return the @phy_device struct.",
        "pre": {
            "bus": "!=null",
            "addr": "!=null",
            "is_c45": "!=null"
        }
    }
},
{
    "kretprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:if (!netdev)goto out;if (netdev->wol_enabled)return false;/* As long as not all affected network drivers support the * wol_enabled flag, let's check for hints that WoL is enabled. * Don't suspend PHY if the attached netdev parent may wake up. * The parent may point to a PCI device, as in tg3 driver. */": {
        "description": "Check if WoL is enabled and avoid suspending PHY if the attached netdev parent may wake up.",
        "pre": {
            "netdev": "==null",
            "netdev->wol_enabled": "==true"
        }
    }
},
{
    "kprobe:netdev_suspend": {
        "description": "Check if the netdev is suspended and return false if WOL is enabled.",
        "pre": {
            "netdev": "==null",
            "netdev->wol_enabled": "==true"
        }
    }
},
{
    "kretprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device.",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return_value": "in [0, -EIO, -ENODEV]"
        }
    }
},
{
    "kprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device.",
        "pre": {
            "phydev": "!=null"
        },
        "return": {
            "success": "0",
            "bus_access_error": "-EIO",
            "invalid_devices_in_package": "-ENODEV"
        }
    }
},
{
    "kretprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device.",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_XGMII]"
        }
    }
},
{
    "kprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device.",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_XGMII]"
        }
    }
},
{
    "kretprobe:phydev->irq_rerun": {
        "description": "Rerun interrupts which were postponed by phy_interrupt() because they occurred during the system sleep transition.",
        "pre": {
            "phydev": "!=null",
            "phydev->irq_rerun": "==true"
        }
    }
},
{
    "kprobe:if (phydev->irq_rerun)": {
        "description": "Check if the `irq_rerun` flag of `phydev` is true.",
        "pre": {
            "phydev": {
                "irq_rerun": "==true"
            }
        }
    }
},
{
    "kretprobe:phy_sfp_attach": {
        "description": "attach the SFP bus to the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_attach": {
        "description": "attach the SFP bus to the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_sfp_detach": {
        "description": "detach the SFP bus from the PHY upstream network device",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_detach": {
        "description": "Detach the SFP bus from the PHY upstream network device.",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect": {
        "description": "Connect an ethernet device to a PHY device.",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_RTBI, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII_ID, PHY_INTERFACE_MODE_RGMII_RXID, PHY_INTERFACE_MODE_RGMII_TXID, PHY_INTERFACE_MODE_SGMII_2500, PHY_INTERFACE_MODE_QSGMII, PHY_INTERFACE_MODE_XGMII, PHY_INTERFACE_MODE_2500BASEX, PHY_INTERFACE_MODE_USXGMII, PHY_INTERFACE_MODE_INTERNAL]"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:phy_connect": {
        "description": "Connect an Ethernet device to a PHY device.",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "any",
            "interface": "any"
        }
    }
},
{
    "kretprobe:WARN_ON": {
        "description": "Check if the PHY device state is not PHY_HALTED, PHY_READY, or PHY_UP.",
        "pre": {
            "phydev->state": "not in [PHY_HALTED, PHY_READY, PHY_UP]"
        }
    },
    "kretprobe:phy_init_hw": {
        "description": "Initialize the PHY hardware.",
        "pre": {}
    },
    "kretprobe:phy_resume": {
        "description": "Resume the PHY device.",
        "pre": {}
    },
    "kretprobe:return": {
        "description": "Return the value of the previous helper function.",
        "pre": {
            "ret": ">= 0"
        }
    },
    "kretprobe:no_resume": {
        "description": "Label for the 'no_resume' section.",
        "pre": {}
    },
    "kretprobe:phy_interrupt_is_valid": {
        "description": "Check if the PHY interrupt is valid.",
        "pre": {
            "phydev": "!= null"
        }
    }
},
{
    "kprobe:phy_resume": {
        "description": "Resume the PHY device.",
        "pre": {
            "phydev": {
                "mac_managed_pm": "false",
                "suspended_by_mdio_bus": "true"
            }
        }
    }
},
{
    "kretprobe:phy_reset_after_clk_enable": {
        "description": "Perform a PHY reset if needed.",
        "pre": {
            "phydev": "!=null",
            "return_value": "in [-1, 0, 1]",
            "flags": "!=null",
            "reset_needed": "if flags indicate a reset is needed",
            "error": "return_value < 0"
        }
    }
},
{
    "kprobe:phy_reset_after_clk_enable": {
        "description": "Perform a PHY reset if needed.",
        "pre": {
            "phydev": "!=null",
            "ret": "!=0"
        }
    }
},
{
    "kretprobe:genphy_config_eee_advert": {
        "description": "disable unwanted eee mode advertisement",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_config_eee_advert": {
        "description": "disable unwanted eee mode advertisement",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_setup_forced": {
        "description": "Configures MII_BMCR to force speedduplex to the values in phydev.",
        "pre": {
            "phydev": "!=null",
            "phydev.speed": "valid",
            "phydev.duplex": "valid",
            "phydev.MII_BMCR": "valid"
        }
    }
},
S,
{
    "kretprobe:genphy_read_master_slave": {
        "description": "Reads the master/slave configuration and state of a PHY device.",
        "pre": {
            "phydev": "!=null",
            "cfg": "in [MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "state": "in [MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_UNKNOWN]",
            "val": ">=0",
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN]",
            "val & CTL1000_ENABLE_MASTER": "==0 or ==CTL1000_ENABLE_MASTER",
            "val & CTL1000_AS_MASTER": "==0 or ==CTL1000_AS_MASTER",
            "val & CTL1000_PREFER_MASTER": "==0 or ==CTL1000_PREFER_MASTER",
            "val & LPA_1000MSFAIL": "==0 or ==LPA_1000MSFAIL",
            "phydev->link": "==0 or ==1"
        }
    }
},
{
    "kprobe:genphy_read_master_slave": {
        "description": "Function to read the master-slave configuration and state of a PHY device.",
        "pre": {
            "phydev": "!=null",
            "cfg": "in [MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "state": "in [MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_UNKNOWN]",
            "val": ">=0",
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN]",
            "val & CTL1000_ENABLE_MASTER": "!=0",
            "val & CTL1000_AS_MASTER": "!=0",
            "val & CTL1000_PREFER_MASTER": "!=0",
            "val & LPA_1000MSFAIL": "!=0",
            "phydev->link": "!=0"
        }
    }
},
{
    "kretprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "pre": {
            "phydev": "!=null",
            "phydev->dev": "!=null",
            "phydev->dev->type": "==PHY_DEVICE_TYPE",
            "phydev->dev->bus": "==PHY_DEVICE_BUS",
            "phydev->dev->addr": "==PHY_DEVICE_ADDR"
        }
    }
},
S,
S,
{
    "kretprobe:__genphy_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "changed": "is bool"
        }
    }
},
{
    "kprobe:__genphy_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "changed": "is bool"
        }
    }
},
{
    "kretprobe:genphy_c37_config_aneg": {
        "description": "restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null",
            "auto-negotiation": "in [enabled, disabled]",
            "advertising": "!=null when auto-negotiation == enabled",
            "BMCR": "!=null when auto-negotiation == disabled"
        }
    }
},
{
    "kprobe:genphy_c37_config_aneg": {
        "description": "Restart auto-negotiation or write BMCR",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "auto_negotiation_enabled": {
                "true": {
                    "advertising_configured": "true",
                    "auto_negotiation_restarted": "true"
                },
                "false": {
                    "bmcr_written": "true"
                }
            }
        }
    }
},
{
    "kretprobe:genphy_aneg_done": {
        "description": "Return auto-negotiation status",
        "pre": {
            "phydev": "!=null",
            "return_value": "in [0, BMSR_ANEGCOMPLETE]"
        }
    }
},
{
    "kprobe:genphy_aneg_done": {
        "description": "Returns the auto-negotiation status",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_read_status_fixed": {
        "description": "Read the link parameters for !aneg mode",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_read_status_fixed": {
        "description": "Read the current duplex and speed state for a PHY operating with autonegotiation disabled.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c37_read_status": {
        "description": "Check the link status and update current link state",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_c37_read_status": {
        "description": "Check the link status and update the current link state.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:genphy_read_abilities": {
        "description": "Read PHY abilities from Clause 22 registers",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_read_abilities": {
        "description": "Read PHY abilities from Clause 22 registers",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode",
        "pre": {
            "phydev": "!=null",
            "link_mode": "!=null"
        }
    }
},
{
    "kprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode",
        "pre": {
            "phydev": "!=null",
            "link_mode": "!=null"
        }
    }
},
{
    "kretprobe:phy_advertise_supported": {
        "description": "Advertise all supported modes",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_advertise_supported": {
        "description": "Advertise all supported modes",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_support_asym_pause": {
        "description": "Enable support of asym pause",
        "pre": {
            "phydev": "!=null"
        }
    }
},
S,
{
    "kretprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported.",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool",
            "autoneg": "bool"
        }
    }
},
{
    "kprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported. Generally called from the set_pauseparam .ndo.",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool",
            "autoneg": "bool"
        }
    }
},
{
    "kretprobe:phy_set_asym_pause": {
        "description": "Configure advertised Pause support depending on if transmit and receiver pause is supported. If there has been a change in adverting, trigger a new autoneg. Generally called from the set_pauseparam .ndo.",
        "pre": {
            "phydev": "!=null",
            "rx": "is_boolean",
            "tx": "is_boolean"
        }
    }
},
{
    "kprobe:phy_set_asym_pause": {
        "description": "Configure Pause and Asym Pause",
        "pre": {
            "phydev": "!=null",
            "rx": "bool",
            "tx": "bool"
        }
    }
},
{
    "kretprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting.",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        }
    }
},
{
    "kprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting.",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_pause": {
        "description": "Resolve negotiated pause modes",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kprobe:phy_get_pause": {
        "description": "Resolve negotiated pause modes",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_internal_delay": {
        "description": "Returns the index of the internal delay",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "boolean"
        }
    }
},
{
    "kprobe:phy_get_internal_delay": {
        "description": "Returns the index of the internal delay",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "boolean"
        }
    }
},
{
    "kretprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device",
        "pre": {
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device.",
        "pre": {
            "phy_fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device.",
        "pre": {
            "phy_fwnode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size()",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size().",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register()",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "any"
        }
    }
},
{
    "kretprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information.",
        "pre": {
            "bus": "!=null",
            "cb": "valid_function_pointer"
        }
    }
},
{
    "kprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information.",
        "pre": {
            "bus": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board.",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        },
        "context": "can sleep"
    }
},
{
    "kprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board.",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        },
        "context": "can sleep"
    }
},
{
    "kretprobe:pcs_np = of_get_parent": {
        "description": "Get the parent node of np using of_get_parent function.",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "pcs_np": "!=null"
        }
    },
    "kretprobe:!pcs_np": {
        "description": "Return ERR_PTR(-ENODEV) if pcs_np is null.",
        "pre": {
            "pcs_np": "==null"
        },
        "post": {
            "return_value": "ERR_PTR(-ENODEV)"
        }
    },
    "kretprobe:!of_device_is_available(pcs_np)": {
        "description": "Return ERR_PTR(-ENODEV) if pcs_np is not available.",
        "pre": {
            "pcs_np": "!=null"
        },
        "post": {
            "return_value": "ERR_PTR(-ENODEV)"
        }
    }
},
{
    "kprobe:miic_create": {
        "description": "Create a miic device.",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "pcs_np": "!=null",
            "!pcs_np": "false",
            "!of_device_is_available(pcs_np)": "false"
        }
    }
},
{
    "kretprobe:mdio_device_put": {
        "description": "Put the reference to the MDIO device and return the PCS.",
        "pre": {
            "mdio": "!=null",
            "pcs": "!=null"
        }
    }
},
{
    "kprobe:mdio_device_put": {
        "description": "Put the reference to the MDIO device.",
        "pre": {
            "mdio": "!=null"
        }
    },
    "kprobe:return_pcs": {
        "description": "Return the PCS structure.",
        "pre": {
            "pcs": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:qede_rdma_unregister_driver": {
        "description": "Unregister the QEDR driver for RDMA.",
        "pre": {
            "drv": "!=null",
            "edev": "!=null",
            "qedr_dev_list_lock": "locked"
        },
        "post": {
            "qedr_drv": "null",
            "qedr_dev_list_lock": "unlocked"
        }
    }
},
{
    "kprobe:qede_rdma_unregister_driver": {
        "description": "Unregister the QEDR driver for RDMA.",
        "pre": {
            "drv": "!=null",
            "edev": {
                "rdma_info": {
                    "qedr_dev": "!=null",
                    "exp_recovery": "false"
                }
            }
        }
    }
},
{
    "kretprobe:mlx5_create_cq": {
        "description": "Create a completion queue (CQ) and add it to the comp EQ CQ tree to receive completion events.",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "out": "!=null",
            "outlen": ">=0",
            "eqn": ">=0",
            "din": "!=null",
            "eq": "!=null",
            "err": ">=0",
            "cq->cqn": ">=0",
            "cq->cons_index": ">=0",
            "cq->arm_sn": ">=0",
            "cq->eq": "!=null",
            "cq->uid": ">=0",
            "cq->refcount": ">=0",
            "cq->free": "!=null",
            "cq->comp": "!=null"
        }
    }
},
{
    "kprobe:mlx5_create_cq": {
        "description": "Create a completion queue (CQ) in mlx5_core_dev.",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": "!=null",
            "inlen": ">=0",
            "out": "!=null",
            "outlen": ">=0"
        }
    }
},
{
    "kretprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in mlx5.",
        "pre": {
            "ft_attr": {
                "level": ">= fs_prio->num_levels"
            }
        }
    }
},
{
    "kprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in mlx5 with the given attributes.",
        "pre": {
            "ft_attr": {
                "level": ">= fs_prio->num_levels"
            }
        }
    }
},
{
    "kretprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Create an auto-grouped flow table in the mlx5 driver.",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": "!=null",
            "ft_attr->autogroup.max_num_groups": "!=null",
            "ft": "!=null",
            "ft->max_fte": "!=null",
            "autogroups_max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null"
        },
        "post": {
            "ft": "!=null",
            "ft->max_fte": "!=null",
            "autogroups_max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null",
            "ft->autogroup.active": "true",
            "ft->autogroup.required_groups": "(autogroups_max_fte / MAX_FLOW_GROUP_SIZE) - 1",
            "ft->autogroup.max_fte": "autogroups_max_fte"
        }
    }
},
{
    "kprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Create an auto-grouped flow table in the mlx5 driver.",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": "!=null",
            "ft_attr->autogroup.max_num_groups": "!=null",
            "ft": "!=null",
            "autogroups_max_fte": "!=null",
            "ft->max_fte": "!=null",
            "max_num_groups": "!=null",
            "num_reserved_entries": "!=null"
        }
    }
},
{
    "kretprobe:build_match_list": {
        "description": "Builds a match list",
        "pre": {
            "match_head": "!=null",
            "ft": "!=null",
            "spec": "!=null",
            "flow_act->fg": "!=null",
            "take_write": "boolean"
        }
    }
},
{
    "build_match_list": {
        "pre": {
            "&match_head": "!=null",
            "ft": "unknown",
            "spec": "unknown",
            "flow_act->fg": "unknown",
            "take_write": "unknown"
        }
    }
},
S,
S,
S,
{
    "kprobe:tree_init_node": {
        "description": "Initialize a tree node for the rule.",
        "pre": {
            "rule": "!=null",
            "node": "!=null",
            "del_sw_hw_rule": "!=null",
            "dest": "!=null",
            "dest[i].type": "!=MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE",
            "list_add(&rule->node.list, &fte->node.children)": "true",
            "list_add_tail(&rule->node.list, &fte->node.children)": "true"
        }
    }
},
{
    "kretprobe:mlx5_get_flow_namespace": {
        "description": "Get the flow namespace based on the given parameters.",
        "pre": {
            "dev": "!=null",
            "type": "in [MLX5_FLOW_NAMESPACE_FDB, MLX5_FLOW_NAMESPACE_PORT_SEL, MLX5_FLOW_NAMESPACE_SNIFFER_RX, MLX5_FLOW_NAMESPACE_SNIFFER_TX, MLX5_FLOW_NAMESPACE_FDB_BYPASS, MLX5_FLOW_NAMESPACE_EGRESS, MLX5_FLOW_NAMESPACE_EGRESS_IPSEC, MLX5_FLOW_NAMESPACE_EGRESS_MACSEC, MLX5_FLOW_NAMESPACE_RDMA_RX, MLX5_FLOW_NAMESPACE_RDMA_RX_KERNEL, MLX5_FLOW_NAMESPACE_RDMA_TX, MLX5_FLOW_NAMESPACE_RDMA_RX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_TX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_RX_IPSEC, MLX5_FLOW_NAMESPACE_RDMA_TX_IPSEC]",
            "steering": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlx5_eq_enable": {
        "description": "Enable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eq_get_eqe": {
        "description": "Get the EQ entry from the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "valid value",
            "ci": "eq->cons_index + cc",
            "nent": "eq_get_size(eq)",
            "eqe": "get_eqe(eq, ci & (nent - 1))",
            "ownership_bit_check": "(eqe->owner & 1) ^ !!(ci & nent)",
            "eqe_result": "(ownership_bit_check ? NULL : eqe)"
        },
        "post": {
            "return_value": "eqe"
        }
    }
},
{
    "kprobe:mlx5_eq_get_eqe": {
        "description": "Get the EQ entry from the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "any"
        }
    }
},
{
    "kretprobe:wmb();}EXPORT_SYMBOL(mlx5_eq_update_ci": {
        "description": "Updates the consumer index of the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "!=null",
            "arm": "in [true, false]",
            "addr": "!=null",
            "val": "!=null",
            "eq->cons_index": "!=null",
            "eq->eqn": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:wmb();}EXPORT_SYMBOL(mlx5_eq_update_ci": {
        "description": "Updates the consumer index of the mlx5_eq structure.",
        "pre": {
            "eq": "!=null",
            "cc": "!=null",
            "arm": "in [true, false]",
            "addr": "!=null",
            "val": "!=null",
            "eq->cons_index": "!=null",
            "eq->eqn": "!=null",
            "addr": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:mlx5_eq_create_generic": {
        "description": "Generic EQ API for mlx5_core consumers. Needed For RDMA ODP EQ for now.",
        "pre": {
            "dev": "!=null",
            "param": "!=null"
        },
        "post": {
            "return": "err",
            "dev": "unchanged",
            "param": "unchanged"
        }
    }
},
{
    "kprobe:mlx5_eq_create_generic": {
        "description": "Generic EQ API for mlx5_core consumers. Needed For RDMA ODP EQ for now.",
        "pre": {
            "dev": "!=null",
            "param": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_fc_counters_lookup_next": {
        "description": "Access a reference to struct mlx5_fc and perform operations on it.",
        "pre": {
            "dev": "!=null",
            "id": "!=null"
        },
        "post": {
            "struct mlx5_fc": "!=null",
            "counter list": "valid order of operations",
            "destroy": "not called after dump",
            "query": "consistent packets and bytes"
        }
    }
},
S,
S,
S,
{
    "kretprobe:find_rl_entry": {
        "description": "Finds an entry where we can register the given rate. If the rate already exists, return the entry where it is registered, otherwise return the first available entry. If the table is full, return NULL.",
        "pre": {
            "table": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dedicated": "in [true, false]"
        }
    }
},
{
    "kprobe:find_rl_entry": {
        "description": "Finds an entry where we can register the given rate. If the rate already exists, return the entry where it is registered, otherwise return the first available entry. If the table is full, return NULL.",
        "pre": {
            "table": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dedicated": "in [true, false]"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy data from rl_in to entry->rl_raw and set uid. Then call mlx5_set_pp_rate_limit_cmd with dev, entry, and true as arguments.",
        "pre": {
            "entry->rl_raw": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dev": "!=null",
            "entry": "!=null",
            "err": "!=null",
            "dev->priv.rl_table->max_size": "!=0",
            "rate": "!=0",
            "rate": ">=dev->priv.rl_table->min_rate",
            "rate": "<=dev->priv.rl_table->max_rate",
            "table->rl_lock": "locked",
            "table": "!=null",
            "table->rl_lock": "locked",
            "entry->refcount": "!=0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source to destination memory.",
        "pre": {
            "entry->rl_raw": "!=null",
            "rl_in": "!=null",
            "uid": "!=null",
            "dev": "!=null",
            "dedicated_entry": "in [true, false]",
            "index": "!=null"
        }
    }
},
S,
{
    "kprobe:mlx5_free_bfreg": {
        "description": "Free a BF register in mlx5_core_dev.",
        "pre": {
            "mdev": "!=null",
            "bfreg": "!=null",
            "bfregs": "!=null",
            "up": "!=null",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eswitch_add_send_to_vport_rule": {
        "description": "Add a rule to send packets to a virtual port in mlx5_eswitch.",
        "pre": {
            "on_esw": "!=null",
            "from_esw": "!=null",
            "rep": "!=null",
            "sqn": "!=null",
            "vport": "!=null",
            "mlx5_eswitch_vport_match_metadata_enabled(on_esw)": "true"
        }
    }
},
{
    "kprobe:mlx5_eswitch_add_send_to_vport_rule": {
        "description": "Add a rule to send packets to a vport in the mlx5 eswitch.",
        "pre": {
            "on_esw": "!=null",
            "from_esw": "!=null",
            "rep": "!=null",
            "sqn": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mlx5_eswitch_vport_match_metadata_enabled": {
        "description": "Check if vport metadata matching is enabled.",
        "pre": {
            "misc2": "!=null",
            "misc2.metadata_reg_c_0": 0,
            "misc2.metadata_reg_c_0": 0,
            "memchr_inv(misc2, 0, MLX5_ST_SZ_BYTES(fte_match_set_misc2))": false,
            "spec.match_criteria_enable": "& ~MLX5_MATCH_MISC_PARAMETERS_2"
        }
    }
},
{
    "kprobe:mlx5_eswitch_vport_match_metadata_enabled": {
        "description": "Check if vport metadata matching is enabled.",
        "pre": {
            "esw": "!=null",
            "spec->match_value": "!=null",
            "spec->match_criteria": "!=null"
        }
    }
},
{
    "kretprobe:if (esw_attr->out_count - esw_attr->split_count > 1)return -EOPNOTSUPP;err = esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i);if (err)return err;if (esw_attr->dests[esw_attr->split_count].pkt_reformat)": {
        "description": "The kretprobe function with the given condition",
        "pre": {
            "esw_attr->out_count - esw_attr->split_count": "> 1",
            "esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i)": "== 0",
            "err": "== 0",
            "esw_attr->dests[esw_attr->split_count].pkt_reformat": "!= null"
        }
    }
},
{
    "kprobe:if (esw_attr->out_count - esw_attr->split_count > 1)return -EOPNOTSUPP;err = esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i);if (err)return err;if (esw_attr->dests[esw_attr->split_count].pkt_reformat)": {
        "description": "The given function checks if the difference between 'out_count' and 'split_count' in 'esw_attr' is greater than 1. If it is, it returns -EOPNOTSUPP. Otherwise, it calls the 'esw_setup_chain_dest' function with the provided arguments. If an error occurs during the setup, it returns the error code. Finally, it checks if 'pkt_reformat' is set in 'esw_attr->dests[esw_attr->split_count]' and performs some action based on that.",
        "pre": {
            "esw_attr->out_count - esw_attr->split_count": "> 1",
            "esw_setup_chain_dest(dest, flow_act, chains, attr->dest_chain, 1, 0, *i)": "!= null",
            "err": "== null",
            "esw_attr->dests[esw_attr->split_count].pkt_reformat": "!= null"
        }
    }
},
{
    "kretprobe:mlx5_sriov_blocking_notifier_unregister": {
        "description": "Unregister a VF from a notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_sriov_blocking_notifier_unregister": {
        "description": "Unregister a VF from a notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_sriov_blocking_notifier_register": {
        "description": "Register a VF notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_sriov_blocking_notifier_register": {
        "description": "Register a VF notification block chain.",
        "pre": {
            "mdev": "!=null",
            "vf_id": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_eswitch_get_core_dev": {
        "description": "Get the mdev device",
        "pre": {
            "esw": "!=null"
        }
    }
},
{
    "kprobe:mlx5_eswitch_get_core_dev": {
        "description": "Get the mdev device",
        "pre": {
            "esw": "!=null"
        }
    }
},
S,
{
    "kprobe:mlx5_cmd_check": {
        "description": "Aborted due to PCI error or via reset flow mlx5_cmd_trigger_completions()",
        "pre": {
            "dev": "!=null",
            "err": "== -ENXIO",
            "in": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kretprobe:mlx5_cmd_do": {
        "description": "Executes a fw command, wait for completion.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        },
        "post": {
            "return": {
                "type": "int",
                "constraints": [
                    "-EREMOTEIO",
                    "0",
                    "< 0"
                ]
            }
        }
    }
},
{
    "kprobe:mlx5_cmd_do": {
        "description": "Executes a fw command, wait for completion.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        },
        "post": {
            "-EREMOTEIO": "outbox.status != MLX5_CMD_STAT_OK",
            "0": "outbox.status == MLX5_CMD_STAT_OK",
            "< 0": "Command execution couldn't be performed by firmware or driver"
        }
    }
},
S,
S,
{
    "kretprobe:mlx5_cmd_exec_polling": {
        "description": "Executes a fw command, poll for completion. Needed for driver force teardown, when command completion EQ will not be available to complete the command.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        }
    }
},
{
    "kprobe:mlx5_cmd_exec_polling": {
        "description": "Executes a fw command, poll for completion. Needed for driver force teardown, when command completion EQ will not be available to complete the command.",
        "pre": {
            "dev": "!=null",
            "in": "!=null",
            "in_size": ">=0",
            "out": "!=null",
            "out_size": ">=0"
        }
    }
},
{
    "kretprobe:mlx5_cmd_init_async_ctx": {
        "description": "Initialize async context for mlx5 command",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null",
            "ctx->num_inflight": "==1",
            "ctx->inflight_done": "is initialized"
        }
    }
},
{
    "kprobe:mlx5_cmd_init_async_ctx": {
        "description": "Initialize the async context for mlx5 command handling.",
        "pre": {
            "dev": "!=null",
            "ctx": "!=null",
            "ctx->dev": "==dev",
            "ctx->num_inflight": "==1",
            "ctx->inflight_done": "not in [null, 0]"
        }
    }
},
{
    "kretprobe:mlx5_cmd_cleanup_async_ctx": {
        "description": "Cleanup the async context for mlx5_cmd",
        "pre": {},
        "post": {
            "mlx5_cmd_exec_cb": "==null"
        }
    }
},
{
    "kprobe:mlx5_cmd_cleanup_async_ctx": {
        "description": "Cleanup the async context for mlx5_cmd",
        "pre": {
            "mlx5_cmd_exec_cb_called": true,
            "mlx5_cmd_exec_cb_not_called_during_cleanup": true,
            "mlx5_cmd_exec_cb_not_called_after_cleanup": true
        }
    }
},
S,
{
    "kprobe:mlx5_vf_get_core_dev": {
        "description": "Get the associated mlx5_core_dev for the given pci_dev.",
        "pre": {
            "pdev": "!=null"
        },
        "post": {
            "return": "in [valid pointer to mlx5_core_dev, NULL]"
        }
    }
},
S,
S,
{
    "kretprobe:if (mlx5_lag_is_multipath(dev0))return;tracker = ldev->tracker;do_bond = tracker.is_bonded && mlx5_lag_check_prereq(ldev);}if (do_bond && !__mlx5_lag_is_active(ldev))": {
        "description": "Condition for the given function",
        "pre": {
            "mlx5_lag_is_multipath(dev0)": true,
            "ldev->tracker.is_bonded": true,
            "mlx5_lag_check_prereq(ldev)": true,
            "__mlx5_lag_is_active(ldev)": false
        }
    }
},
{
    "kprobe:mlx5_lag_is_multipath": {
        "description": "Check if the given device is in multipath mode.",
        "pre": {
            "dev0": "!=null"
        }
    },
    "kprobe:mlx5_lag_check_prereq": {
        "description": "Check if the prerequisites for lag bonding are met.",
        "pre": {
            "ldev": "!=null"
        }
    },
    "kprobe:__mlx5_lag_is_active": {
        "description": "Check if the given device is active in the lag.",
        "pre": {
            "ldev": "!=null"
        }
    },
    "kprobe:do_bond": {
        "description": "Check if bonding should be performed.",
        "pre": {
            "tracker.is_bonded": "==true",
            "ldev": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_gen_guid_change_eqe": {
        "description": "Generate an event queue entry for a GUID change event.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "dev->persist->num_vfs": "< slave",
            "eqe": "memset(&eqe, 0, sizeof(eqe))",
            "eqe.type": "MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT",
            "eqe.subtype": "MLX4_DEV_PMC_SUBTYPE_GUID_INFO",
            "eqe.event.port_mgmt_change.port": "mlx4_phys_to_slave_port(dev, slave, port)"
        },
        "post": {
            "return": "mlx4_GEN_EQE(dev, slave, &eqe)"
        }
    }
},
{
    "kprobe:mlx4_gen_guid_change_eqe": {
        "description": "Generate a GUID change event for mlx4 device.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "dev->persist->num_vfs": "< slave",
            "eqe": "memset(&eqe, 0, sizeof(eqe))",
            "eqe.type": "MLX4_EVENT_TYPE_PORT_MNG_CHG_EVENT",
            "eqe.subtype": "MLX4_DEV_PMC_SUBTYPE_GUID_INFO",
            "eqe.event.port_mgmt_change.port": "mlx4_phys_to_slave_port(dev, slave, port)",
            "mlx4_GEN_EQE(dev, slave, &eqe)": "return 0"
        }
    }
},
{
    "kretprobe:mlx4_gen_port_state_change_eqe": {
        "description": "Generate an event queue entry for port state change.",
        "pre": {
            "dev": "!=null",
            "slave": "int",
            "port": "u8",
            "port_subtype_change": "u8"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:mlx4_gen_port_state_change_eqe": {
        "description": "Generate a port state change event for a specific slave port.",
        "pre": {
            "dev->persist->num_vfs": "< slave",
            "eqe.subtype": "in [MLX4_EVENT_TYPE_PORT_CHANGE]",
            "slave_port": "calculated using mlx4_phys_to_slave_port(dev, slave, port)"
        }
    }
},
{
    "kretprobe:set_and_calc_slave_port_state": {
        "description": "Change the slave's port state based on the new event and previous state.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "event": "in [MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN, MLX4_PORT_STATE_DEV_EVENT_PORT_UP, MLX4_PORT_STATE_IB_EVENT_GID_VALID, MLX4_PORT_STATE_IB_EVENT_GID_INVALID]",
            "gen_event": "!=null"
        }
    }
},
{
    "kprobe:set_and_calc_slave_port_state": {
        "description": "Change the slave's port state based on the new event and previous state.",
        "pre": {
            "dev": "!=null",
            "slave": "!=null",
            "port": "!=null",
            "event": "in [MLX4_PORT_STATE_DEV_EVENT_PORT_DOWN, MLX4_PORT_STATE_DEV_EVENT_PORT_UP, MLX4_PORT_STATE_IB_EVENT_GID_VALID, MLX4_PORT_STATE_IB_EVENT_GID_INVALID]",
            "gen_event": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:eq_set_ci": {
        "description": "Set the congestion index of the specified eq.",
        "pre": {
            "eq": "!=null",
            "eq_index": "MLX4_EQ_ASYNC",
            "value": "1"
        }
    },
    "kretprobe:return": {
        "description": "Return 0."
    },
    "kretprobe:err_out_unmap": {
        "description": "Handle error and free eq_table.eq.",
        "pre": {
            "i": ">0"
        },
        "post": {
            "eq_table.eq[i]": "null"
        }
    },
    "kretprobe:CONFIG_RFS_ACCEL": {
        "description": "Handle RFS acceleration.",
        "pre": {
            "i": "1",
            "i": "<=dev.caps.num_ports"
        }
    }
},
{
    "kprobe:eq_set_ci": {
        "description": "Set the ci value of the eq element in the eq_table array.",
        "pre": {
            "&priv->eq_table.eq[MLX4_EQ_ASYNC]": "!=null",
            "1": "not specified"
        }
    }
},
{
    "kretprobe:mutex_unlock": {
        "description": "Unlock the mutex associated with the pool_lock in msix_ctl.",
        "pre": {
            "priv": "!=null",
            "priv->msix_ctl.pool_lock": "locked"
        }
    }
},
{
    "kprobe:mutex_unlock": {
        "description": "Unlock the mutex associated with the pool_lock in the msix_ctl structure.",
        "pre": {
            "priv": "!=null",
            "priv->msix_ctl.pool_lock": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_slave_from_roce_gid": {
        "description": "Calculate the globally unique slave id",
        "pre": {
            "found_ix": "< MLX4_ROCE_PF_GIDS",
            "slave_gid": "== 0"
        },
        "pre_else_if": {
            "found_ix": "< MLX4_ROCE_PF_GIDS + (vf_gids % num_vfs) * (vf_gids / num_vfs + 1)",
            "slave_gid": "== ((found_ix - MLX4_ROCE_PF_GIDS) / (vf_gids / num_vfs + 1)) + 1"
        },
        "pre_else": {
            "slave_gid": "== ((found_ix - MLX4_ROCE_PF_GIDS - ((vf_gids % num_vfs) * ((vf_gids / num_vfs + 1)))) / (vf_gids / num_vfs)) + vf_gids % num_vfs + 1"
        }
    }
},
{
    "kprobe:mlx4_get_slave_from_roce_gid": {
        "description": "Calculate the globally unique slave id",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "gid": "!=null",
            "slave_id": "!=null",
            "priv": "!=null",
            "i": ">=0",
            "found_ix": ">=-1",
            "vf_gids": ">=0",
            "slaves_pport": "!=null",
            "num_vfs": ">=0",
            "slave_gid": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_module_info": {
        "description": "Read cable module eeprom data",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:mlx4_get_module_info": {
        "description": "Read cable module eeprom data",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "offset": "!=null",
            "size": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_ALLOCATE_VPP_get": {
        "description": "Allocate VPPs for mlx4 device",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "available_vpp": "!=null",
            "vpp_p_up": "!=null",
            "i": ">=0",
            "i": "< MLX4_NUM_UP",
            "vpp_p_up[i]": "!=null"
        },
        "post": {
            "available_vpp": "== be32_to_cpu(out_param->available_vpp)",
            "vpp_p_up[i]": "== be32_to_cpu(out_param->vpp_p_up[i])",
            "out": "mlx4_free_cmd_mailbox(dev, mailbox)",
            "return": "err"
        }
    }
},
{
    "kprobe:mlx4_ALLOCATE_VPP_get": {
        "description": "Total number of supported VPPs",
        "pre": {
            "dev": "!=null",
            "port": "!=null",
            "available_vpp": "!=null",
            "vpp_p_up": "!=null"
        }
    }
},
{
    "kretprobe:mlx4_get_parav_qkey": {
        "description": "Get the paravirtualized QKey for a given QPN.",
        "pre": {
            "dev": "!=null",
            "qpn": "!=null",
            "qkey": "!=null",
            "qk": "MLX4_RESERVED_QKEY_BASE",
            "condition1": "qpn >= dev->phys_caps.base_tunnel_sqpn + 8 * MLX4_MFUNC_MAX || qpn < dev->phys_caps.base_proxy_sqpn",
            "condition2": "qpn >= dev->phys_caps.base_tunnel_sqpn",
            "tunnel_qp": "true"
        },
        "post": {
            "qkey": "qk",
            "return": "0"
        }
    }
},
{
    "kprobe:mlx4_get_parav_qkey": {
        "description": "Get the paravirtualized QKey for a given QPN.",
        "pre": {
            "dev": "!=null",
            "qpn": "!=null",
            "qkey": "!=null",
            "qk": "MLX4_RESERVED_QKEY_BASE",
            "qpn >= dev->phys_caps.base_tunnel_sqpn + 8 && qpn < dev->phys_caps.base_proxy_sqpn": true
        },
        "post": {
            "*qkey": "qk",
            "return": 0
        }
    }
},
{
    "kretprobe:mlx4_tunnel_steer_add": {
        "description": "Add a tunnel steer rule for inner eth header",
        "pre": {
            "spec_eth_inner.id": "MLX4_NET_TRANS_RULE_ID_ETH"
        }
    }
},
"spec_eth_inner.id": "MLX4_NET_TRANS_RULE_ID_ETH",
S,
S,
{
    "kretprobe:mlxsw_emad_rx_listener_func": {
        "description": "The mlxsw_emad_rx_listener_func function in the bpftrace kretprobe.",
        "pre": {
            "mlxsw_core": "!=null",
            "skb": "!=null",
            "trans->tx_info": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlxsw_core_event_listener_register": {
        "description": "Register an event listener in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "el": "!=null",
            "priv": "!=null",
            "el_item": "==null",
            "rxl.func": "mlxsw_core_event_listener_func",
            "rxl.local_port": "MLXSW_PORT_DONT_CARE",
            "rxl.trap_id": "el->trap_id"
        },
        "post": {
            "return": "0",
            "err": "==null"
        }
    }
},
{
    "kprobe:mlxsw_core_event_listener_register": {
        "description": "Register an event listener in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "el": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_core_driver_register": {
        "description": "Register an mlxsw driver.",
        "pre": {
            "mlxsw_driver": "!=null"
        }
    }
},
S,
{
    "kretprobe:mlxsw_core_trap_state_set": {
        "description": "Not supported for event listener",
        "pre": {
            "mlxsw_core": "!=null",
            "listener": "!=null",
            "enabled": "!=null",
            "listener.is_event": "==false",
            "listener.is_event": "!=true",
            "listener->is_event": "==false",
            "listener->is_event": "!=true",
            "WARN_ON(listener->is_event)": "==false",
            "WARN_ON(listener->is_event)": "!=true",
            "return": "==0",
            "return": "!=EINVAL",
            "action": "in [listener->en_action, listener->dis_action]",
            "trap_group": "in [listener->en_trap_group, listener->dis_trap_group]",
            "mlxsw_reg_hpkt_pack(hpkt_pl, action, listener->trap_id, trap_group, listener->is_ctrl)": "==0",
            "err": "==0",
            "mlxsw_reg_write(mlxsw_core, MLXSW_REG(hpkt), hpkt_pl)": "==0",
            "mlxsw_core_rx_listener_state_set(mlxsw_core, &listener->rx_listener, enabled)": "==0"
        }
    }
},
{
    "kprobe:mlxsw_core_trap_state_set": {
        "description": "Not supported for event listener",
        "pre": {
            "mlxsw_core": "!=null",
            "listener": "!=null",
            "enabled": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_reg_trans_bulk_wait": {
        "description": "Wait for completion of multiple mlxsw_reg_trans operations in bulk.",
        "pre": {
            "bulk_list": "!=null",
            "trans": "!=null",
            "tmp": "!=null",
            "sum_err": "int",
            "err": "int",
            "err != 0": "sum_err == 0"
        }
    }
},
{
    "kprobe:mlxsw_reg_trans_bulk_wait": {
        "description": "Wait for the completion of multiple register transactions in bulk.",
        "pre": {
            "bulk_list": "!=null"
        }
    }
},
{
    "kretprobe:get_random_bytes": {
        "description": "Generate random bytes and store them in the variable tid.",
        "pre": {
            "tid": "!=null"
        }
    },
    "kretprobe:atomic64_set": {
        "description": "Set the value of the variable tid to the left-shifted value of tid by 32.",
        "pre": {
            "tid": "!=null",
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:INIT_LIST_HEAD": {
        "description": "Initialize the variable mlxsw_core->emad.trans_list as an empty list.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:spin_lock_init": {
        "description": "Initialize the spin lock variable mlxsw_core->emad.trans_list_lock.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_core_trap_register": {
        "description": "Register the trap listener mlxsw_emad_rx_listener with mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_emad_tlv_enable": {
        "description": "Enable the TLV feature for mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_core_trap_unregister": {
        "description": "Unregister the trap listener mlxsw_emad_rx_listener from mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:destroy_workqueue": {
        "description": "Destroy the workqueue mlxsw_core->emad_wq.",
        "pre": {
            "mlxsw_core": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_emad_fini": {
        "description": "Finalize the mlxsw_core->emad structure.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_query": {
        "description": "Query the mlxsw_core with the mgir register.",
        "pre": {
            "mlxsw_core": "!=null",
            "mgir": "!=null",
            "mgir_pl": "!=null",
            "err": "==0"
        }
    },
    "kretprobe:mlxsw_reg_mgir_fw_info_string_tlv_get": {
        "description": "Get the string TLV from the mgir firmware info.",
        "pre": {
            "mgir_pl": "!=null",
            "string_tlv": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_mgir_fw_info_latency_tlv_get": {
        "description": "Get the latency TLV from the mgir firmware info.",
        "pre": {
            "mgir_pl": "!=null",
            "latency_tlv": "!=null"
        }
    },
    "kretprobe:mlxsw_emad_tlv_disable": {
        "description": "Disable the TLV feature for mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null"
        }
    },
    "kretprobe:mlxsw_emad_init": {
        "description": "Initialize the mlxsw_core->emad structure.",
        "pre": {
            "mlxsw_core": "!=null",
            "emad_wq": "!=null",
            "tid": "!=null",
            "err": "==0"
        }
    }
},
{
    "kprobe:get_random_bytes": {
        "description": "Generate random bytes and store them in the variable tid. Then left shift tid by 32 bits. Set the value of the atomic64 variable mlxsw_core->emad.tid to tid. Initialize the list head mlxsw_core->emad.trans_list. Initialize the spin lock mlxsw_core->emad.trans_list_lock. Register the trap mlxsw_emad_rx_listener with mlxsw_core using mlxsw_core_trap_register. If there is an error, go to err_trap_register. Enable the TLV mlxsw_emad_tlv_enable with mlxsw_core. If there is an error, go to err_emad_tlv_enable. Set mlxsw_core->emad.use_emad to true. Return 0. If there is an error, unregister the trap mlxsw_emad_rx_listener with mlxsw_core using mlxsw_core_trap_unregister. Go to err_trap_register. Destroy the workqueue mlxsw_core->emad_wq. Return the error code.",
        "pre": {
            "tid": "!=null",
            "mlxsw_core->emad.tid": "tid << 32",
            "mlxsw_core->emad.trans_list": "INIT_LIST_HEAD",
            "mlxsw_core->emad.trans_list_lock": "spin_lock_init",
            "err": "0",
            "mlxsw_core": "!=null",
            "mlxsw_emad_rx_listener": "!=null",
            "mlxsw_emad_tlv_enable": "!=null",
            "mlxsw_core_trap_register": "!=null",
            "mlxsw_core_trap_unregister": "!=null",
            "err_trap_register": "!=null",
            "err_emad_tlv_enable": "!=null",
            "destroy_workqueue": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:mlxsw_core_lag_mapping_get": {
        "description": "Get the local port for the lag port and push it up.",
        "pre": {
            "mlxsw_core": "!=null",
            "rx_info->u.lag_id": "!=null",
            "rx_info->lag_port_index": "!=null"
        }
    }
},
{
    "kprobe:mlxsw_core_lag_mapping_get": {
        "description": "Get the local port for the lag port.",
        "pre": {
            "mlxsw_core": "!=null",
            "rx_info->u.lag_id": "!=null",
            "rx_info->lag_port_index": "!=null"
        }
    }
},
{
    "kretprobe:if (err == -EAGAIN && !called_again)": {
        "description": "Condition for if (err == -EAGAIN && !called_again)",
        "pre": {
            "err": "== -EAGAIN",
            "called_again": "== false"
        }
    }
},
{
    "kprobe:if (err == -EAGAIN && !called_again)": {
        "description": "Condition for the given function",
        "pre": {
            "err": "== -EAGAIN",
            "called_again": "== false"
        }
    }
},
{
    "kretprobe:mlxsw_core_resources_query": {
        "description": "This function queries the resources of the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mbox": "!=null",
            "res": "!=null",
            "index": ">=0",
            "i": ">=0",
            "data": ">=0",
            "id": ">=0",
            "err": ">=0"
        },
        "post": {
            "return": "-EIO"
        }
    }
},
{
    "kprobe:return -EIO;}EXPORT_SYMBOL(mlxsw_core_resources_query": {
        "description": "This function is used to query resources in the mlxsw_core.",
        "pre": {
            "mlxsw_core": "!=null",
            "mbox": "!=null",
            "res": "!=null",
            "index": ">=0",
            "i": ">=0",
            "data": ">=0",
            "id": ">=0",
            "err": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_MAX_QUERIES": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_PER_QUERY": ">=0",
            "MLXSW_CMD_QUERY_RESOURCES_TABLE_END_ID": ">=0",
            "MLXSW_RESOURCES_QUERY_MAX_QUERIES": ">=0"
        }
    }
},
{
    "kretprobe:mlxsw_afa_block_create": {
        "description": "Create an mlxsw_afa_block structure and initialize it with the given mlxsw_afa structure.",
        "pre": {
            "mlxsw_afa": "!=null"
        },
        "post": {
            "block": "!=null",
            "block->resource_list": "initialized",
            "block->afa": "mlxsw_afa"
        }
    }
},
{
    "kprobe:mlxsw_afa_block_create": {
        "description": "Create an mlxsw_afa_block structure and initialize it with the given mlxsw_afa.",
        "pre": {
            "mlxsw_afa": "!=null"
        }
    }
},
{
    "kretprobe:mlxsw_afa_block_first_kvdl_index": {
        "description": "Get the KVD linear index of the second set in the given block.",
        "pre": {
            "block": "!=null",
            "block->first_set": "!=null",
            "block->first_set->next": "!=null"
        },
        "post": {
            "return": "block->first_set->next->kvdl_index"
        }
    }
},
S,
{
    "kretprobe:mlxsw_afa_cookie_lookup": {
        "description": "Lookup the cookie associated with the given cookie index.",
        "pre": {
            "mlxsw_afa": "!=null",
            "cookie_index": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mlxsw_afa_cookie_lookup": {
        "description": "Lookup the cookie associated with the given cookie_index in mlxsw_afa.",
        "pre": {
            "cookie_index": "!=0",
            "cookie_index": "!=null",
            "idr_find_result": "!=null",
            "return_value": "!=null"
        }
    }
},
{
    "kretprobe:return;if (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) || WARN_ON(elinfo->item.size.bytes != len))return;__mlxsw_item_memcpy_to(values->storage.key, key_value, storage_item, 0);__mlxsw_item_memcpy_to(values->storage.mask, mask_value, storage_item, 0);mlxsw_afk_element_usage_add(&values->elusage, element);}EXPORT_SYMBOL(mlxsw_afk_values_add_buf": {
        "description": "mlxsw_afk_values_add_buf function",
        "pre": {
            "values": "!=null",
            "element": "in [valid enum values]",
            "key_value": "!=null",
            "mask_value": "!=null",
            "len": "!=null",
            "elinfo->type": "== MLXSW_AFK_ELEMENT_TYPE_BUF",
            "elinfo->item.size.bytes": "== len",
            "mask_value": "!=0"
        }
    }
},
{
    "kprobe:return;if (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) || WARN_ON(elinfo->item.size.bytes != len))return;__mlxsw_item_memcpy_to(values->storage.key, key_value, storage_item, 0);__mlxsw_item_memcpy_to(values->storage.mask, mask_value, storage_item, 0);mlxsw_afk_element_usage_add(&values->elusage, element);}EXPORT_SYMBOL(mlxsw_afk_values_add_buf": {
        "description": "mlxsw_afk_values_add_buf function",
        "pre": {
            "values": "!=null",
            "element": "in [MLXSW_AFK_ELEMENT_TYPE_BUF]",
            "key_value": "!=null",
            "mask_value": "!=null",
            "len": "!=null",
            "mask": "==0"
        }
    }
},
{
    "kretprobe:mlxsw_env_query_module_eeprom": {
        "description": "Verify if transceiver provides diagnostic monitoring page",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "SFP_DIAGMON": "in [0, 1]",
            "diag_mon": "in [0, 1]",
            "read_size": ">= 1",
            "modinfo->type": "ETH_MODULE_SFF_8472",
            "modinfo->eeprom_len": "ETH_MODULE_SFF_8472_LEN"
        },
        "post": {
            "err": "= 0 if read_size >= 1, else -EIO"
        }
    }
},
S,
{
    "kretprobe:mlxsw_env_validate_cable_ident": {
        "description": "Validate module identifier value.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "qsfp": "!=null",
            "cmis": "!=null",
            "ee->len": "!=0",
            "mlxsw_env_linecard_is_active(mlxsw_env, slot_index)": "==true"
        }
    }
},
{
    "kprobe:mlxsw_env_validate_cable_ident": {
        "description": "Validate cable identifier value.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "qsfp": "!=null",
            "cmis": "!=null",
            "err": "!=null",
            "i": "!=null",
            "ee->len": "!=null"
        }
    }
},
{
    "kretprobe:device_addr = page->offset": {
        "description": "Assign the value of page->offset to device_addr.",
        "pre": {
            "page": "!=null",
            "page->offset": "!=null"
        }
    },
    "kretprobe:while (bytes_read < page->length)": {
        "description": "Loop until bytes_read is less than page->length.",
        "pre": {
            "bytes_read": "!=null",
            "page": "!=null",
            "page->length": "!=null"
        }
    }
},
{
    "kprobe:device_addr = page->offset; while (bytes_read < page->length)": {
        "description": "This condition represents the function 'device_addr = page->offset; while (bytes_read < page->length)'.",
        "pre": {
            "page->offset": "!=null",
            "page->length": ">bytes_read"
        }
    }
},
{
    "kretprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_mcion_pack": {
        "description": "Pack the mcion payload with slot index and module.",
        "pre": {
            "mcion_pl": "!=null",
            "slot_index": "!=null",
            "module": "!=null"
        }
    },
    "kretprobe:mlxsw_reg_query": {
        "description": "Query the mlxsw core with mcion payload.",
        "pre": {
            "mlxsw_core": "!=null",
            "mcion_pl": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kprobe:mlxsw_reg_mcion_pack": {
        "description": "Pack the mcion payload with slot index and module.",
        "pre": {
            "mcion_pl": "!=null",
            "slot_index": "!=null",
            "module": "!=null"
        }
    },
    "kprobe:mlxsw_reg_query": {
        "description": "Query mlxsw_core with mcion payload.",
        "pre": {
            "mlxsw_core": "!=null",
            "mcion_pl": "!=null"
        }
    }
},
{
    "kretprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active in the mlxsw_env.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kretprobe:mlxsw_env_module_enable_set": {
        "description": "Set the power mode of a module in the mlxsw_env.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "low_power": "in [true, false]",
            "extack": "!=null"
        },
        "post": {
            "err": "==0"
        }
    }
},
{
    "kprobe:__mlxsw_env_linecard_is_active": {
        "description": "Check if the line card is active in the mlxsw_env.",
        "pre": {
            "mlxsw_env": "!=null",
            "slot_index": "!=null"
        }
    },
    "kprobe:mlxsw_env_module_enable_set": {
        "description": "Set the power mode of a module in the mlxsw_env.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "low_power": "in [true, false]",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:__mlxsw_env_set_module_power_mode": {
        "description": "Set the power mode of a module in the mlxsw_env environment.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "module_info": "!=null",
            "err": "int",
            "mlxsw_env": "!=null",
            "mlxsw_env->line_cards_lock": "mutex_locked",
            "module_info->power_mode_policy": "==ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO",
            "module_info->num_ports_up": "==0"
        },
        "post": {
            "module_info->num_ports_up": "++"
        }
    }
},
{
    "kprobe:__mlxsw_env_set_module_power_mode": {
        "description": "Set the power mode of a module in the mlxsw environment.",
        "pre": {
            "mlxsw_core": "!=null",
            "slot_index": "!=null",
            "module": "!=null",
            "module_info": "!=null",
            "err": "int",
            "mlxsw_env": "!=null",
            "mlxsw_env->line_cards_lock": "mutex",
            "module_info->power_mode_policy": "== ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO",
            "module_info->num_ports_up": "== 0"
        },
        "post": {
            "module_info->num_ports_up": "++"
        },
        "goto": {
            "out_inc": "label",
            "out_unlock": "label"
        },
        "return": "err"
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:bnxt_register_async_events": {
        "description": "Register asynchronous events for the bnxt driver.",
        "pre": {
            "edev": "!=null",
            "events_bmap": "!=null",
            "max_id": "!=null",
            "dev": "!=null",
            "bp": "!=null",
            "ulp": "!=null",
            "async_events_bmap": "events_bmap"
        }
    }
},
{
    "kprobe:bnxt_register_async_events": {
        "description": "Register asynchronous events for the bnxt driver.",
        "pre": {
            "edev": "!=null",
            "events_bmap": "!=null",
            "max_id": "!=null",
            "dev": "!=null",
            "bp": "!=null",
            "ulp": "!=null",
            "async_events_bmap": "events_bmap"
        }
    }
},
S,
S,
{
    "kretprobe:hnae3_register_ae_algo": {
        "description": "Register a AE algorithm to hnae3 framework",
        "pre": {
            "ae_algo": "!=null"
        }
    }
},
{
    "kprobe:hnae3_register_ae_algo": {
        "description": "Register a AE algorithm to hnae3 framework.",
        "pre": {
            "ae_algo": "!=null"
        }
    }
},
{
    "kretprobe:hnae3_register_ae_dev": {
        "description": "Registers an AE device to the hnae3 framework",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kprobe:hnae3_register_ae_dev": {
        "description": "Registers an AE device to the hnae3 framework.",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kretprobe:hnae3_unregister_ae_dev": {
        "description": "Unregisters an AE device.",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kprobe:hnae3_unregister_ae_dev": {
        "description": "Unregisters an AE device",
        "pre": {
            "ae_dev": "!=null"
        }
    }
},
{
    "kretprobe:hns_dsaf_roce_reset": {
        "description": "Reset dsaf and roce",
        "pre": {
            "dsaf_fwnode": "!=null",
            "dereset": "in [false, true]"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:hns_dsaf_roce_reset": {
        "description": "Reset dsaf and roce",
        "pre": {
            "dsaf_fwnode": "!=null",
            "dereset": "in [false, true]"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
S,
S,
{
    "kretprobe:hnae_get_handle": {
        "description": "Get a handle from the AE",
        "pre": {
            "owner_dev": "!=null",
            "fwnode": "!=null",
            "port_id": "!=null",
            "bops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:hnae_get_handle": {
        "description": "Get a handle from the AE.",
        "pre": {
            "owner_dev": "!=null",
            "fwnode": "!=null",
            "port_id": "!=null",
            "bops": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kretprobe:hnae_ae_register": {
        "description": "Register a AE engine to hnae framework",
        "pre": {
            "hdev": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:hnae_ae_register": {
        "description": "Register a AE engine to hnae framework.",
        "pre": {
            "hdev": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:hnae_ae_unregister": {
        "description": "Unregisters a HNAE AE engine",
        "pre": {
            "hdev": "!=null"
        }
    }
},
{
    "kprobe:hnae_ae_unregister": {
        "description": "Unregisters a HNAE AE engine.",
        "pre": {
            "hdev": "!=null"
        }
    }
},
{
    "kretprobe:wx_irq_disable": {
        "description": "Mask off interrupt generation on the NIC",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_irq_disable": {
        "description": "Mask off interrupt generation on the NIC",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wr32m": {
        "description": "Let firmware know the driver has taken over if drv is true, otherwise let firmware take over control of hw.",
        "pre": {
            "wx": "!=null",
            "WX_CFG_PORT_CTL": "!=null",
            "WX_CFG_PORT_CTL_DRV_LOAD": "!=null",
            "drv": "in [true, false]"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Let firmware know the driver has taken over if drv is true, otherwise let firmware take over control of hw.",
        "pre": {
            "wx": "!=null",
            "drv": "in [true, false]",
            "WX_CFG_PORT_CTL": "if drv == true then == WX_CFG_PORT_CTL_DRV_LOAD else == 0"
        }
    }
},
{
    "kretprobe:wx_mng_present": {
        "description": "Returns 0 when management capability is present",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:wx_mng_present": {
        "description": "Returns 0 when management capability is present",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_host_interface_command": {
        "description": "Issue command to manageability block",
        "pre": {
            "wx": "!=null",
            "buffer": "!=null",
            "length": "is_multiple_of(4)",
            "timeout": ">=0",
            "return_data": "is_boolean"
        }
    }
},
{
    "kprobe:wx_host_interface_command": {
        "description": "Issue command to manageability block",
        "pre": {
            "wx": "!=null",
            "buffer": "!=null",
            "length": "is_multiple_of(4)",
            "timeout": "is_positive",
            "return_data": "is_boolean"
        }
    }
},
{
    "kretprobe:wx_read_ee_hostif_data": {
        "description": "Read EEPROM word using a host interface cmd assuming that the semaphore is already obtained.",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:wx_read_ee_hostif_data": {
        "description": "Read EEPROM word using a host interface cmd assuming that the semaphore is already obtained.",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:wx_read_ee_hostif_buffer": {
        "description": "Read EEPROM word(s) using hostif",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "words": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:wx_read_ee_hostif_buffer": {
        "description": "Read EEPROM word(s) using hostif",
        "pre": {
            "wx": "!=null",
            "offset": "!=null",
            "words": "!=null",
            "data": "!=null"
        }
    }
},
S,
{
    "kprobe:wx_reset_hostif": {
        "description": "Send reset cmd to fw",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_get_mac_addr": {
        "description": "Generic get MAC address",
        "pre": {
            "wx": "!=null",
            "mac_addr": "!=null"
        }
    }
},
{
    "kprobe:wx_get_mac_addr": {
        "description": "Generic get MAC address",
        "pre": {
            "wx": "!=null",
            "mac_addr": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_set_mac": {
        "description": "Change the Ethernet Address of the NIC",
        "pre": {
            "netdev": "!=null",
            "p": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:wx_set_mac": {
        "description": "Change the Ethernet Address of the NIC",
        "pre": {
            "netdev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:wr32m(wx, WX_MAC_RX_CFG, WX_MAC_RX_CFG_RE, 0);}}}EXPORT_SYMBOL(wx_disable_rx": {
        "description": "Disable the MAC receiver.",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_RE": "!=null",
            "0": "==0"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Disable the MAC receiver.",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_RE": "!=null",
            "0": "==0"
        }
    }
},
{
    "kretprobe:fctrl": {
        "description": "Set the conditions for the fctrl function",
        "pre": {
            "fctrl": "!=null",
            "fctrl & (WX_PSR_CTL_UPE | WX_PSR_CTL_MPE)": "== 0",
            "vmolr": "!=null",
            "vmolr & (WX_PSR_VM_L2CTL_UPE | WX_PSR_VM_L2CTL_MPE | WX_PSR_VM_L2CTL_ROPE | WX_PSR_VM_L2CTL_ROMPE)": "== 0",
            "vlnctrl": "!=null",
            "vlnctrl & (WX_PSR_VLAN_CTL_VFE | WX_PSR_VLAN_CTL_CFIEN)": "== 0"
        }
    }
},
{
    "kprobe:fctrl": {
        "description": "Set the control flags for the given net device.",
        "pre": {
            "netdev": "!=null",
            "netdev.type": "==struct net_device",
            "netdev.features": "!=null"
        }
    }
},
{
    "kretprobe:wx_change_mtu": {
        "description": "Change the Maximum Transfer Unit",
        "pre": {
            "netdev": "!=null",
            "new_mtu": "!=null",
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:wx_change_mtu": {
        "description": "Change the Maximum Transfer Unit",
        "pre": {
            "netdev": "!=null",
            "new_mtu": "!=null",
            "new_mtu": ">=0"
        }
    }
},
{
    "kretprobe:wr32m": {
        "description": "Disable the rx queue by clearing the RRCFG.EN bit.",
        "pre": {
            "wx": "!=null",
            "ring": "!=null",
            "ring->reg_idx": "!=null",
            "rxdctl": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kprobe:wr32m": {
        "description": "Disable the RX queue by clearing the RRCFG.EN bit.",
        "pre": {
            "wx": "!=null",
            "ring": "!=null",
            "ring->reg_idx": "!=null",
            "rxdctl": "!=null",
            "ret": "!=null"
        }
    }
},
{
    "kretprobe:wx_disable_sec_rx_path": {
        "description": "Stops the receive data path",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_disable_sec_rx_path": {
        "description": "Stops the receive data path",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_disable_pcie_master": {
        "description": "Disable PCI-express master access",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_disable_pcie_master": {
        "description": "Disable PCI-express master access",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_stop_adapter": {
        "description": "Generic stop TxRx units",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_stop_adapter": {
        "description": "Generic stop TxRx units",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wr32m": {
        "description": "Clear counters on read",
        "pre": {
            "wx": "!=null",
            "WX_MAC_RX_CFG": "!=null",
            "WX_MAC_RX_CFG_JE": "!=null",
            "WX_MAC_RX_CFG_JE_size": ">2048"
        }
    }
},
S,
{
    "kretprobe:wx_get_pcie_msix_counts": {
        "description": "Gets MSI-X vector count",
        "pre": {
            "wx": "!=null",
            "msix_count": "!=null",
            "max_msix_count": "!=null"
        }
    }
},
{
    "kprobe:wx_get_pcie_msix_counts": {
        "description": "Gets MSI-X vector count",
        "pre": {
            "wx": "!=null",
            "msix_count": "!=null",
            "max_msix_count": "!=null"
        }
    }
},
{
    "kretprobe:wx_configure_rx": {
        "description": "Configure Receive Unit after Reset",
        "pre": {
            "wx": "!=null",
            "wx->netdev": "!=null",
            "VLAN ID": "0",
            "wx->active_vlans": "!=null",
            "vid": ">=0"
        }
    }
},
S,
{
    "kretprobe:wx_vlan_rx_kill_vid": {
        "description": "Remove VID from filter table",
        "pre": {
            "netdev": "!=null",
            "proto": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kprobe:wx_vlan_rx_kill_vid": {
        "description": "Remove VID from filter table",
        "pre": {
            "netdev": "!=null",
            "proto": "!=null",
            "vid": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_xmit_frame_ring": {
        "description": "Record the location of the first descriptor for this packet.",
        "pre": {
            "skb": {
                "shinfo": {
                    "frags": {
                        "f": {
                            "count": ">= 0",
                            "size": ">= 0"
                        }
                    },
                    "nr_frags": "> 0"
                }
            },
            "tx_ring": "!= null",
            "count": ">= 0"
        }
    }
},
{
    "kprobe:wx_xmit_frame_ring": {
        "description": "Record the location of the first descriptor for this packet.",
        "pre": {
            "skb": {
                "shinfo": {
                    "frags": {
                        "f": {
                            "count": ">= 0",
                            "size": ">= 0"
                        }
                    },
                    "nr_frags": "> 0"
                }
            },
            "tx_ring": "!= null",
            "count": ">= 0"
        }
    }
},
{
    "kretprobe:wx_clear_interrupt_scheme": {
        "description": "Clear the current interrupt scheme settings",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clear_interrupt_scheme": {
        "description": "Clear the current interrupt scheme settings",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_set_num_queues": {
        "description": "Set interrupt mode",
        "pre": {
            "wx": "!=null",
            "ret": "is int"
        }
    }
},
{
    "kprobe:wx_set_num_queues": {
        "description": "Set interrupt mode",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_free_irq": {
        "description": "Free IRQs based on specific conditions",
        "pre": {
            "q_vector->rx.ring": "==false",
            "q_vector->tx.ring": "==false",
            "entry->vector": "!=null",
            "q_vector": "!=null",
            "wx->mac.type": "==wx_mac_em",
            "wx->msix_entries[vector].vector": "!=null",
            "wx": "!=null"
        }
    }
},
{
    "wx_free_irq": {
        "description": "Free the IRQ associated with the given wx structure.",
        "pre": {
            "!q_vector->rx.ring && !q_vector->tx.ring": true,
            "!(pdev->msix_enabled)": {
                "action": "free_irq(pdev->irq, wx)"
            },
            "pdev->msix_enabled": {
                "for": "vector",
                "range": {
                    "start": 0,
                    "end": "wx->num_q_vectors"
                },
                "pre": {
                    "q_vector": "wx->q_vector[vector]",
                    "entry": "&wx->msix_entries[vector]",
                    "action": "free_irq(entry->vector, q_vector)"
                }
            }
        }
    }
},
{
    "kretprobe:wx_setup_isb_resources": {
        "description": "Allocate interrupt status resources",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:wx_setup_isb_resources": {
        "description": "Allocate interrupt status resources",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_free_isb_resources": {
        "description": "Allocate all queues Rx resources",
        "pre": {
            "wx": "!=null"
        },
        "post": {
            "return_value": "in [0, -1]"
        }
    }
},
{
    "kprobe:wx_free_isb_resources": {
        "description": "Allocate all queues Rx resources",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_configure_vectors": {
        "description": "Configure vectors for hardware",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_configure_vectors": {
        "description": "Configure vectors for hardware",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_clean_all_rx_rings": {
        "description": "Free Rx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clean_all_rx_rings": {
        "description": "Free Rx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kretprobe:wx_clean_all_tx_rings": {
        "description": "Free Tx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
{
    "kprobe:wx_clean_all_tx_rings": {
        "description": "Free Tx Buffers for all queues",
        "pre": {
            "wx": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:wx_get_stats64": {
        "description": "Get System Network Statistics",
        "pre": {
            "netdev": "!=null",
            "stats": "!=null"
        }
    }
},
S,
{
    "kretprobe:otx2_set_mac_address": {
        "description": "Set the MAC address for the given net device.",
        "pre": {
            "netdev": "!=null",
            "p": "!=null",
            "pfvf": "!=null",
            "addr": "!=null",
            "addr->sa_data": "is_valid_ether_addr(addr->sa_data)",
            "otx2_hw_set_mac_addr(pfvf, addr->sa_data)": "true"
        }
    }
},
{
    "kprobe:otx2_set_mac_address": {
        "description": "Set the MAC address for the given network device.",
        "pre": {
            "netdev": "!=null",
            "p": "!=null",
            "pfvf": "!=null",
            "addr": "!=null",
            "is_valid_ether_addr(addr->sa_data)": "true",
            "otx2_hw_set_mac_addr(pfvf, addr->sa_data)": "true"
        }
    }
},
{
    "kretprobe:otx2_get_mac_from_af": {
        "description": "If AF doesn't provide a valid MAC, generate a random one",
        "pre": {
            "netdev": "!=null",
            "pfvf": "!=null",
            "err": "!=null",
            "pfvf->dev": "!=null",
            "pfvf->dev": "is of type struct device",
            "pfvf->dev": "has a valid MAC address",
            "err": "==0"
        }
    }
},
{
    "kprobe:if (!is_valid_ether_addr(netdev->dev_addr))eth_hw_addr_random(netdev);": {
        "description": "Generate a random MAC address if the AF does not provide a valid MAC.",
        "pre": {
            "netdev": "!=null",
            "netdev->dev_addr": "!is_valid_ether_addr(netdev->dev_addr)"
        }
    }
},
{
    "kretprobe:otx2_txschq_config": {
        "description": "Set topology e.t.c configuration",
        "pre": {
            "pfvf": "!=null",
            "lvl": "== NIX_TXSCH_LVL_SMQ",
            "prio": "!=null",
            "txschq_for_pfc": "!=null"
        }
    }
},
{
    "kprobe:otx2_txschq_config": {
        "description": "Set topology e.t.c configuration",
        "pre": {
            "pfvf": "!=null",
            "lvl": "== NIX_TXSCH_LVL_SMQ",
            "prio": "!=null",
            "txschq_for_pfc": "!=null"
        }
    }
},
{
    "kretprobe:otx2_detach_resources": {
        "description": "Detach resources",
        "pre": {
            "mbox": "!=null",
            "mbox->lock": "locked",
            "detach": "!=null"
        }
    }
},
{
    "kprobe:otx2_detach_resources": {
        "description": "Detach resources",
        "pre": {
            "mbox": "!=null"
        },
        "post": {
            "detach->partial": "==false"
        }
    }
},
S,
S,
{
    "kretprobe:otx2_config_pause_frm": {
        "description": "Use max receive length supported by hardware for loopback devices",
        "pre": {
            "is_otx2_lbkvf(pfvf->pdev)": true,
            "req->maxlen": "maxlen",
            "otx2_sync_mbox_msg(&pfvf->mbox)": "err",
            "mutex_unlock(&pfvf->mbox.lock)": true
        }
    }
},
{
    "kprobe:otx2_config_pause_frm": {
        "description": "Configure pause frame for OTX2 NIC.",
        "pre": {
            "is_otx2_lbkvf(pfvf->pdev)": true,
            "req->maxlen": "maxlen",
            "otx2_sync_mbox_msg(&pfvf->mbox)": "err",
            "mutex_unlock(&pfvf->mbox.lock)": true
        }
    }
},
{
    "kretprobe:pfvf->tot_lmt_lines": {
        "description": "Assigns the value of (num_online_cpus() * LMT_BURST_SIZE) to pfvf->tot_lmt_lines.",
        "pre": {
            "pfvf": "!=null",
            "num_online_cpus()": ">= 0",
            "LMT_BURST_SIZE": ">= 0"
        }
    },
    "kretprobe:pfvf->hw.lmt_info": {
        "description": "Allocates memory for struct otx2_lmt_info and assigns it to pfvf->hw.lmt_info.",
        "pre": {
            "pfvf": "!=null",
            "alloc_percpu(struct otx2_lmt_info)": "!=null"
        }
    },
    "kretprobe:mutex_lock(&pfvf->mbox.lock)": {
        "description": "Locks the mutex pfvf->mbox.lock.",
        "pre": {
            "pfvf": "!=null",
            "mutex_lock(&pfvf->mbox.lock)": "success"
        }
    },
    "kretprobe:req = otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": {
        "description": "Allocates memory for struct lmtst_tbl_setup_req and assigns it to req.",
        "pre": {
            "pfvf": "!=null",
            "otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": "!=null"
        }
    },
    "kretprobe:!req": {
        "description": "Checks if req is null.",
        "pre": {
            "req": "==null"
        }
    }
},
{
    "kprobe:pfvf->tot_lmt_lines": {
        "description": "Assign the value of (num_online_cpus() * LMT_BURST_SIZE) to pfvf->tot_lmt_lines.",
        "pre": {
            "pfvf": "!=null",
            "num_online_cpus()": "!=null",
            "LMT_BURST_SIZE": "!=null"
        }
    },
    "kprobe:pfvf->hw.lmt_info": {
        "description": "Allocate memory for struct otx2_lmt_info and assign it to pfvf->hw.lmt_info.",
        "pre": {
            "pfvf": "!=null",
            "alloc_percpu(struct otx2_lmt_info)": "!=null"
        }
    },
    "kprobe:mutex_lock(&pfvf->mbox.lock)": {
        "description": "Lock the mutex pfvf->mbox.lock.",
        "pre": {
            "pfvf": "!=null",
            "pfvf->mbox.lock": "!=null"
        }
    },
    "kprobe:req = otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": {
        "description": "Allocate memory for struct lmtst_tbl_setup_req and assign it to req.",
        "pre": {
            "req": "!=null",
            "otx2_mbox_alloc_msg_lmtst_tbl_setup(&pfvf->mbox)": "!=null"
        }
    },
    "kprobe:!req": {
        "description": "Check if req is not null.",
        "pre": {
            "req": "==null"
        }
    }
},
{
    "kretprobe:otx2_free_ntuple_mcam_entries": {
        "description": "Free current ntuple mcam entries and allocate new ones with requested count.",
        "pre": {
            "pfvf": "!=null",
            "count": "!=0",
            "flow_cfg": "!=null",
            "req": "!=null",
            "rsp": "!=null",
            "ent": ">=0",
            "allocated": ">=0"
        }
    }
},
{
    "kprobe:otx2_free_ntuple_mcam_entries": {
        "description": "Free current ntuple mcam entries and allocate new ones with requested count.",
        "pre": {
            "pfvf": "!=null",
            "count": "!=0",
            "flow_cfg": "!=null",
            "flow_cfg.flow_ent": "==null"
        }
    }
},
{
    "kretprobe:otx2_sq_append_skb": {
        "description": "Check if there is enough room between producer and consumer index.",
        "pre": {
            "netdev": "!=null",
            "sq": "!=null",
            "skb": "!=null",
            "qidx": "!=null",
            "txq": "!=null",
            "pfvf": "!=null",
            "offset": "!=null",
            "num_segs": "!=null",
            "free_desc": "!=null",
            "sqe_hdr": "!=null",
            "sq->cons_head": "!=null",
            "sq->head": "!=null",
            "sq->sqe_cnt": "!=null",
            "sq->sqe_thresh": "!=null",
            "otx2_get_sqe_count(pfvf, skb)": "!=null",
            "skb_shinfo(skb)->nr_frags": "!=null"
        },
        "post": {
            "free_desc": "<= (sq->sqe_cnt - 1)",
            "free_desc": ">= sq->sqe_thresh",
            "free_desc": ">= otx2_get_sqe_count(pfvf, skb)",
            "num_segs": "= (skb_shinfo(skb)->nr_frags + 1)"
        }
    }
},
{
    "kprobe:otx2_sq_append_skb": {
        "description": "Check if there is enough room between producer and consumer index.",
        "pre": {
            "netdev": "!=null",
            "sq": "!=null",
            "skb": "!=null",
            "qidx": "!=null",
            "free_desc": "(sq->cons_head - sq->head - 1 + sq->sqe_cnt) & (sq->sqe_cnt - 1)",
            "sqe_thresh": "!=null",
            "otx2_get_sqe_count(pfvf, skb)": "!=null",
            "num_segs": "skb_shinfo(skb)->nr_frags + 1"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Free the memory allocated for tc_entries_bitmap.",
        "pre": {
            "tc": {
                "tc_entries_bitmap": "!=null"
            }
        }
    },
    "kretprobe:kcalloc": {
        "description": "Allocate memory for tc_entries_bitmap using kcalloc.",
        "pre": {
            "nic": {
                "flow_cfg": {
                    "max_flows": "!=0"
                }
            }
        }
    }
},
{
    "kprobe:kfree": {
        "description": "Free the memory allocated for tc_entries_bitmap.",
        "pre": {
            "tc->tc_entries_bitmap": "==null"
        }
    },
    "kprobe:kcalloc": {
        "description": "Allocate memory for tc_entries_bitmap.",
        "pre": {
            "nic->flow_cfg->max_flows": "!=0",
            "tc->tc_entries_bitmap": "==null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:otx2_write64": {
        "description": "Write a 64-bit value to the specified address.",
        "pre": {
            "pf": "!=null",
            "RVU_PF_VFME_INT_ENA_W1CX(0)": "!=null",
            "INTR_MASK(vfs)": "!=null"
        }
    },
    "kretprobe:pci_irq_vector": {
        "description": "Get the IRQ vector for the specified device.",
        "pre": {
            "pf->pdev": "!=null",
            "RVU_PF_INT_VEC_VFME0": "!=null"
        }
    },
    "kretprobe:free_irq": {
        "description": "Free the specified IRQ.",
        "pre": {
            "irq": "!=null",
            "pf": "!=null"
        }
    }
},
S,
{
    "kretprobe:u16 htb_maj_id = smp_load_acquire(&pf->qos.maj_id);if (unlikely(htb_maj_id))": {
        "description": "Load the value of `pf->qos.maj_id` into `htb_maj_id` and check if it is non-zero.",
        "pre": {
            "pf": "!=null",
            "pf->qos.maj_id": "!=null",
            "htb_maj_id": "!=0"
        }
    }
},
{
    "kprobe:u16 htb_maj_id = smp_load_acquire(&pf->qos.maj_id);if (unlikely(htb_maj_id))": {
        "description": "Load the value of `pf->qos.maj_id` into `htb_maj_id` using `smp_load_acquire` and check if it is non-zero.",
        "pre": {
            "pf": "!=null",
            "pf->qos.maj_id": "!=null",
            "htb_maj_id": "!=0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:otx2_mbox_msg_send": {
        "description": "Send a message through the OTX2 mailbox.",
        "pre": {
            "mbox": "!=null",
            "devid": "int",
            "mdev": "!=null",
            "hw_mbase": "!=null",
            "tx_hdr": "!=null",
            "rx_hdr": "!=null",
            "msgs_offset": "int",
            "mdev->mbase": "!=null",
            "mbox->tx_start": "int",
            "mdev->msg_size": "!=null",
            "mdev->mbase + mbox->tx_start + msgs_offset": "!=null",
            "hw_mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->msg_size": "!=null",
            "mdev->msg_size": "int",
            "mdev->mbox_lock": "spin_lock"
        },
        "post": {
            "tx_hdr->msg_size": "mdev->msg_size"
        }
    }
},
{
    "kprobe:otx2_mbox_msg_send": {
        "description": "Send a message through the OTX2 mailbox.",
        "pre": {
            "mbox": "!=null",
            "devid": "!=null",
            "mdev": "!=null",
            "hw_mbase": "!=null",
            "tx_hdr": "!=null",
            "rx_hdr": "!=null",
            "msgs_offset": "!=null",
            "mdev->mbase": "!=null",
            "hw_mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->mbase + mbox->tx_start + msgs_offset": "!=null",
            "mdev->msg_size": "!=null",
            "mdev->mbase": "!=hw_mbase",
            "memcpy(hw_mbase + mbox->tx_start + msgs_offset, mdev->mbase + mbox->tx_start + msgs_offset, mdev->msg_size)": "valid",
            "spin_lock(&mdev->mbox_lock)": "valid",
            "tx_hdr->msg_size": "mdev->msg_size",
            "bounce_buffer": "not implemented"
        }
    }
},
S,
{
    "kprobe:otx2_mbox_alloc_msg_rsp": {
        "description": "Check if there is space in mailbox",
        "pre": {
            "mbox": "!=null",
            "devid": "!=null",
            "size": "!=null",
            "size_rsp": "!=null",
            "mdev": "!=null",
            "msghdr": "null",
            "mbox_lock": "locked"
        },
        "post": {
            "msghdr": "!=null"
        },
        "goto": {
            "exit": {
                "conditions": [
                    "(mdev->msg_size + size) > mbox->tx_size - msgs_offset",
                    "(mdev->rsp_size + size_rsp) > mbox->rx_size - msgs_offset",
                    "mdev->msg_size == 0"
                ]
            }
        }
    }
},
{
    "kretprobe:ocelot_match_all_as_mac_etype": {
        "description": "Matches on MAC_ETYPE keys such as destination and source MAC on this ingress port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "lookup": "!=null",
            "on": "!=null"
        }
    }
},
{
    "kprobe:ocelot_match_all_as_mac_etype": {
        "description": "Matches on MAC_ETYPE keys such as destination and source MAC on this ingress port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "lookup": "!=null",
            "on": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_disable_reservation_watermarks": {
        "description": "Disable reservation watermarks for the ocelot device on a specific port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kprobe:ocelot_disable_reservation_watermarks": {
        "description": "Disable reservation watermarks for the ocelot device on the specified port.",
        "pre": {
            "ocelot": "!=null",
            "port": ">=0"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:ocelot_ptp_gettime64": {
        "description": "Get the current time from the Ocelot PTP clock.",
        "pre": {
            "ns": {
                "type": "int",
                "range": {
                    "min": "0x3ffffff0",
                    "max": "0x3fffffff"
                }
            }
        }
    }
},
{
    "kprobe:ocelot_ptp_gettime64": {
        "description": "Get the current time from the Ocelot PTP clock.",
        "pre": {
            "ns": ">=0x3ffffff0",
            "ns": "<=0x3fffffff"
        }
    }
},
{
    "kretprobe:ocelot_ptp_adjtime": {
        "description": "Adjust the time of the PTP clock on the Ocelot device.",
        "pre": {
            "ptp": "!=null",
            "delta": ">= -(NSEC_PER_SEC * 2) && <= (NSEC_PER_SEC * 2)"
        }
    }
},
{
    "kprobe:ocelot_ptp_adjtime": {
        "description": "Adjust the time of the PTP clock.",
        "pre": {
            "ptp": "!=null",
            "delta": "delta > -(NSEC_PER_SEC * 2) && delta < (NSEC_PER_SEC * 2)"
        }
    }
},
{
    "kretprobe:ocelot_ptp_adjfine": {
        "description": "Check if the adjustment value is greater than or equal to (1L << 30).",
        "pre": {
            "adj": ">= (1L << 30)"
        }
    }
},
{
    "kprobe:ocelot_ptp_adjfine": {
        "description": "Check if the adjustment value is greater than or equal to (1L << 30).",
        "pre": {
            "adj": ">= (1L << 30)"
        }
    }
},
{
    "kretprobe:ocelot_ptp_enable": {
        "description": "Enable PTP on the Ocelot switch.",
        "pre": {
            "rq->perout.flags": "& ~(PTP_PEROUT_DUTY_CYCLE | PTP_PEROUT_PHASE) == 0",
            "rq->perout.index": ">= 0",
            "rq->perout.period.sec": "== 1",
            "rq->perout.period.nsec": "== 0"
        },
        "post": {
            "return": "== -EOPNOTSUPP"
        }
    }
},
S,
S,
S,
{
    "kretprobe:ocelot_port_txtstamp_request": {
        "description": "Check the conditions for the ocelot_port_txtstamp_request function.",
        "pre": {
            "ptp_cmd": "!=null",
            "ptp_class": "!=PTP_CLASS_NONE"
        }
    }
},
{
    "kprobe:ocelot_port_txtstamp_request": {
        "description": "Request PTP timestamping for the Ocelot port.",
        "pre": {
            "ptp_cmd": "!=null",
            "ptp_class": "!=PTP_CLASS_NONE"
        }
    }
},
{
    "kretprobe:ocelot_get_txtstamp": {
        "description": "Retrieve the ts ID and Tx port",
        "pre": {
            "val": "!=null",
            "val & SYS_PTP_STATUS_PTP_MESS_VLD": "==0",
            "val & SYS_PTP_STATUS_PTP_OVFL": "!=0"
        }
    }
},
{
    "ocelot_get_txtstamp": {
        "description": "Retrieve the ts ID and Tx port",
        "pre": {
            "val & SYS_PTP_STATUS_PTP_MESS_VLD": "== 0",
            "val & SYS_PTP_STATUS_PTP_OVFL": "!= 0"
        }
    }
},
{
    "kretprobe:ocelot_init_timestamp": {
        "description": "Initialize the timestamp for the ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "info": "!=null",
            "ptp_clock": "!=null",
            "i": ">=0",
            "ocelot->ptp_info": "!=null",
            "ocelot->ptp_pins": "!=null",
            "p->name": "string",
            "sizeof(p->name)": ">=0",
            "p->index": ">=0",
            "p->func": "in [PTP_PF_NONE, PTP_PF_OTHER]",
            "ocelot->ptp_info.pin_config": "!=null",
            "ptp_clock": "!=null",
            "IS_ERR(ptp_clock)": "false"
        },
        "post": {
            "return": "0"
        }
    }
},
{
    "kprobe:ocelot_init_timestamp": {
        "description": "Initialize the timestamp for the ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "info": "!=null",
            "ptp_clock": "!=null",
            "i": ">=0",
            "i": "< OCELOT_PTP_PINS_NUM",
            "p": "!=null",
            "p->name": "!=null",
            "sizeof(p->name)": ">= sizeof(char)",
            "p->index": ">=0",
            "p->func": "in [PTP_PF_NONE]",
            "ocelot->ptp_info": "!=null",
            "ocelot->ptp_info.pin_config": "!=null",
            "ptp_clock": "!=null",
            "IS_ERR(ptp_clock)": "==0",
            "PTR_ERR(ptp_clock)": "==0"
        }
    }
},
{
    "kretprobe:ocelot_mact_learn": {
        "description": "Set MAC_CPU_COPY if the CPU port is used by a multicast entry",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mac": "!=null",
            "vid": "!=null",
            "type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]"
        },
        "post": {
            "cmd": "& ANA_TABLES_MACACCESS_MAC_CPU_COPY != 0",
            "mc_ports": "& BIT(ocelot->num_phys_ports) != 0"
        }
    }
},
{
    "kprobe:ocelot_mact_learn": {
        "description": "Set MAC_CPU_COPY if the CPU port is used by a multicast entry",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mac": "!=null",
            "vid": "!=null",
            "type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]"
        }
    }
},
{
    "kretprobe:ocelot_write": {
        "description": "Issue a forget command",
        "pre": {
            "ocelot": "!=null",
            "mac": "!=null",
            "vid": "!=null"
        }
    }
},
{
    "kprobe:ocelot_write": {
        "description": "Issue a forget command",
        "pre": {
            "ocelot": "!=null",
            "mac": "!=null",
            "vid": "!=null"
        }
    }
},
S,
S,
S,
S,
S,
S,
{
    "kretprobe:ocelot_vlan_add": {
        "description": "Add a VLAN to the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "vid": "!=0",
            "pvid": "bool",
            "untagged": "bool"
        }
    }
},
{
    "kprobe:ocelot_vlan_member_add": {
        "description": "Add a VLAN member to the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "vid": "!=null",
            "untagged": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_port_set_pvid": {
        "description": "Set the Port VLAN ID (PVID) for the specified port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "NULL": "true"
        }
    }
},
{
    "kprobe:ocelot_port_set_pvid": {
        "description": "Set the PVID (Port VLAN ID) for a specific port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "NULL": "==null"
        }
    }
},
{
    "kretprobe:ocelot_rx_frame_word": {
        "description": "Read the FCS",
        "pre": {
            "ocelot": "!=null",
            "grp": "!=null",
            "false": "!=null",
            "&val": "!=null"
        }
    }
},
{
    "kprobe:ocelot_rx_frame_word": {
        "description": "Read a word from the frame buffer.",
        "pre": {
            "ocelot": "!=null",
            "grp": "is an integer",
            "false": "is a boolean value",
            "&val": "!=null"
        }
    }
},
S,
{
    "ocelot_port_inject_frame": {
        "description": "Inject a frame into the Ocelot switch port.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "grp": "!=null",
            "rew_op": "!=null",
            "skb": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:ocelot_set_ageing_time": {
        "description": "Set the ageing time for the ocelot structure.",
        "pre": {
            "ocelot": "!=null",
            "msecs": "!=null",
            "age_period": "!=null",
            "age_period": "!=0"
        }
    }
},
{
    "kprobe:ocelot_set_ageing_time": {
        "description": "Set the ageing time for the Ocelot device.",
        "pre": {
            "ocelot": "!=null",
            "msecs": "!=null",
            "age_period": "!=null",
            "age_period": "!=0"
        }
    }
},
{
    "kretprobe:ocelot_port_mdb_add": {
        "description": "Add a multicast database entry to the Ocelot switch port.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": "!=null",
            "bridge": "!=null",
            "mdb->addr": "!=null",
            "mdb->vid": "int",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "int",
            "ocelot_multicast_get(ocelot, mdb->addr, vid)": "!=null"
        }
    }
},
{
    "kprobe:ocelot_port_mdb_add": {
        "description": "Add a multicast database entry for a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": {
                "addr": "!=null",
                "vid": "int"
            },
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_port_mdb_del": {
        "description": "Delete a multicast database entry associated with a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "int",
            "mdb": "!=null",
            "bridge": "!=null",
            "addr": "array of unsigned char with length ETH_ALEN",
            "mc": "struct ocelot_multicast",
            "pgid": "struct ocelot_pgid",
            "vid": "u16",
            "mc != null": true,
            "mc->entry_type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "u16",
            "ocelot_multicast_get(ocelot, mdb->addr, vid)": "!=null",
            "ocelot_encode_ports_to_mdb(addr, mc)": "void",
            "ocelot_mact_forget(ocelot, addr, vid)": "void",
            "ocelot_pgid_free(ocelot, mc->pgid)": "void",
            "mc->ports &= ~BIT(port)": "void",
            "mc->ports": "!=0",
            "list_del(&mc->list)": "void",
            "devm_kfree(ocelot->dev, mc)": "void",
            "return": "int"
        }
    }
},
{
    "kprobe:ocelot_port_mdb_del": {
        "description": "Delete a multicast database entry associated with a port in the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "mdb": "!=null",
            "bridge": "!=null",
            "addr": "array of size ETH_ALEN",
            "mc": "!=null",
            "pgid": "!=null",
            "vid": "int",
            "mc != null": true,
            "mc->entry_type": "in [ENTRYTYPE_MACv4, ENTRYTYPE_MACv6]",
            "ocelot_vlan_unaware_pvid(ocelot, bridge)": "int",
            "mc->pgid->ports": "!=null",
            "mc->pgid->index": "!=null"
        },
        "post": {
            "return value": "int",
            "ocelot_mact_learn(ocelot, pgid->index, addr, vid, mc->entry_type)": "int"
        }
    }
},
S,
S,
{
    "kretprobe:ocelot_fields_write": {
        "description": "Set Pause watermark hysteresis",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "field": "in [SYS_PAUSE_CFG_PAUSE_START, SYS_PAUSE_CFG_PAUSE_STOP]",
            "value": "!=null"
        }
    }
},
{
    "kprobe:ocelot_fields_write": {
        "description": "Write ocelot fields",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "field": "in [SYS_PAUSE_CFG_PAUSE_START, SYS_PAUSE_CFG_PAUSE_STOP]",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:ocelot_init_port": {
        "description": "Set MAC IFG Gaps",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "ocelot_port": "!=null",
            "ocelot_port->tx_skbs": "!=null",
            "TX_IFG": "==5",
            "FDX": "in [true, false]",
            "RX_IFG1": "if FDX == true then ==0 else ==5",
            "RX_IFG2": "if FDX == true then ==0 else ==5"
        }
    }
},
S,
{
    "kretprobe:ocelot_reset": {
        "description": "Reset the ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "err": "int",
            "val": "u32",
            "ocelot->regfields[SYS_RESET_CFG_MEM_INIT]": "1",
            "ocelot->regfields[SYS_RESET_CFG_MEM_ENA]": "1"
        },
        "post": {
            "err": "int",
            "val": "!val",
            "ocelot->regfields[SYS_RESET_CFG_CORE_ENA]": "1"
        }
    }
},
{
    "kprobe:ocelot_reset": {
        "description": "Reset the Ocelot switch core.",
        "pre": {
            "ocelot": "!=null",
            "ocelot->regfields[SYS_RESET_CFG_MEM_INIT]": "1",
            "ocelot->regfields[SYS_RESET_CFG_MEM_ENA]": "1",
            "ocelot->regfields[SYS_RESET_CFG_CORE_ENA]": "1"
        }
    }
},
{
    "kretprobe:ocelot_mrp_trap_add": {
        "description": "Add a trap for MRP in Ocelot.",
        "pre": {
            "filter": "!=null",
            "filter->key.etype.dmac.value": "!=null",
            "mrp_test_dmac": "!=null",
            "filter->key.etype.dmac.mask": "!=null",
            "mrp_mask": "!=null"
        }
    }
},
{
    "kprobe:ocelot_mrp_trap_add": {
        "description": "Add a trap for MRP (Multiple Registration Protocol) on the Ocelot switch.",
        "pre": {
            "ocelot": "!=null",
            "port": "!=null",
            "filter->key.etype.dmac.value": "!=null",
            "filter->key.etype.dmac.mask": "!=null",
            "filter->key.etype.dmac.mask[5]": "==0x00"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:stats->rx_bytes": {
        "description": "Assign the value of s[OCELOT_STAT_RX_OCTETS] to stats->rx_bytes.",
        "pre": {
            "stats": "!=null",
            "s[OCELOT_STAT_RX_OCTETS]": "!=null"
        }
    }
},
{
    "kprobe:stats->rx_bytes": {
        "description": "Get Rx stats",
        "pre": {
            "stats": "!=null",
            "ocelot": "!=null",
            "port": ">=0",
            "s": "!=null"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:xcv_setup_link": {
        "description": "Set operating speed and reset datapaths.",
        "pre": {
            "xcv": "!=null",
            "link_speed": "in [100, 10]",
            "link_up": "==true"
        }
    }
},
{
    "kprobe:xcv_setup_link": {
        "description": "Set up the link configuration.",
        "pre": {
            "link_up": "in [true, false]",
            "link_speed": "in [10, 100]",
            "speed": "in [0, 1] when link_speed == 10 or link_speed == 100"
        }
    }
},
{
    "kretprobe:bgx_set_dmac_cam_filter_mac": {
        "description": "Configure DCAM filtering for designated LMAC",
        "pre": {
            "cam_dmac": "!=0",
            "bgx": "!=null",
            "lmacid": ">=0",
            "idx": ">=0"
        }
    }
},
S,
{
    "kretprobe:bgx_set_xcast_mode": {
        "description": "Set the filtering mode for the given bgx, lmac, and mode.",
        "pre": {
            "node": "!=null",
            "bgx_idx": "!=null",
            "lmacid": "!=null",
            "mode": "!=null",
            "cfg": "!=null",
            "cfg": "&= ~(CAM_ACCEPT | BGX_MCAST_MODE(MCAST_MODE_MASK))",
            "cfg": "updated with appropriate filtering mode"
        }
    }
},
{
    "kprobe:cfg &= ~(CAM_ACCEPT | BGX_MCAST_MODE(MCAST_MODE_MASK))": {
        "description": "Check requested bits and set filtering mode appropriately.",
        "pre": {
            "cfg": "!=null",
            "CAM_ACCEPT": "!=null",
            "BGX_MCAST_MODE(MCAST_MODE_MASK)": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:iavf_register_client": {
        "description": "Register a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:iavf_register_client": {
        "description": "Register a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:iavf_unregister_client": {
        "description": "Unregister a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:iavf_unregister_client": {
        "description": "Unregister a iavf client driver with the L2 driver",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:neigh_event_send": {
        "description": "Send a neighbor event.",
        "pre": {
            "e->neigh": "!=null",
            "e->lock": "!=null",
            "e->state": "==L2T_STATE_STALE"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
S,
S,
S,
S,
S,
{
    "kretprobe:alloc_l2e": {
        "description": "Allocate a new entry for l2t_data.",
        "pre": {
            "d": "!=null"
        }
    }
},
{
    "e = alloc_l2e(d); if (e)": {
        "description": "Allocate a new entry",
        "pre": {
            "d": "!=null",
            "neigh": "!=null",
            "physdev": "!=null",
            "priority": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_register_client": {
        "description": "Register an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_register_client": {
        "description": "Register an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_unregister_client": {
        "description": "Unregister an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_unregister_client": {
        "description": "Unregister an offload client",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:cxgb3_queue_tid_release": {
        "description": "Release a TID in the cxgb3 queue.",
        "pre": {
            "tdev": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kprobe:cxgb3_queue_tid_release": {
        "description": "Release a TID in the cxgb3 queue.",
        "pre": {
            "tdev": "!=null",
            "tid": "!=null"
        }
    }
},
{
    "kretprobe:ppm_get_cpu_entries": {
        "description": "Try to get the CPU entries from the general pool.",
        "pre": {
            "ppm": "!=null",
            "npods": ">0",
            "caller_data": "!=null"
        }
    }
},
{
    "kprobe:ppm_get_cpu_entries": {
        "description": "Try to get the index from the general pool.",
        "pre": {
            "ppm": "!=null",
            "npods": ">0",
            "caller_data": "!=null"
        }
    }
},
{
    "kretprobe:cxgbi_ppm_make_ppod_hdr": {
        "description": "Generate pagepod header for cxgbi_ppm.",
        "pre": {
            "ppm": "!=null",
            "tag": "&= 0x3FFFFFFF",
            "tid": "!=null",
            "offset": "!=null",
            "length": "!=null",
            "hdr": "!=null",
            "hdr.ddp_tag": "&= 0xC0000000",
            "hdr.ddp_tag_wire": "&!= 0xC0000000"
        }
    }
},
{
    "kprobe:cxgbi_ppm_make_ppod_hdr": {
        "description": "The ddp tag in pagepod should be with bit 31:30 set to 0. The ddp Tag on the wire should be with non-zero 31:30 to the peer",
        "pre": {
            "ppm": "!=null",
            "tag": "&= 0x3FFFFFFF",
            "tid": "!=null",
            "offset": "!=null",
            "length": "!=null",
            "hdr": "!=null",
            "hdr.vld_tid": "htonl(PPOD_VALID_FLAG | PPOD_TID(tid))",
            "hdr.rsvd": "0",
            "hdr.pgsz_tag_clr": "htonl(tag & ppm.tformat.idx_clr_mask)",
            "hdr.max_offset": "htonl(length)",
            "hdr.page_offset": "htonl(offset)"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_get_srq_entry": {
        "description": "Read the SRQ table entry",
        "pre": {
            "dev": "!=null",
            "srq_idx": "!=null",
            "entryp": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_get_srq_entry": {
        "description": "Read the SRQ table entry",
        "pre": {
            "dev": "!=null",
            "srq_idx": "!=null",
            "entryp": "!=null"
        }
    }
},
{
    "kretprobe:neigh_event_send": {
        "description": "Send a packet on the fast-path if the l2t_entry state is valid or update the state if it is stale.",
        "pre": {
            "e->neigh": "!=null",
            "e->state": "==L2T_STATE_STALE",
            "e->lock": "!=null"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
{
    "kprobe:neigh_event_send": {
        "description": "Send a neighbor event",
        "pre": {
            "e->neigh": "!=null",
            "e->lock": "!=null",
            "e->state": "==L2T_STATE_STALE"
        },
        "post": {
            "e->state": "==L2T_STATE_VALID"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_l2t_alloc_switching": {
        "description": "Allocates an L2T entry for switch filters",
        "pre": {
            "dev": "!=null",
            "vlan": "!=null",
            "port": "!=null",
            "dmac": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_l2t_alloc_switching": {
        "description": "Allocates an L2T entry for switch filters",
        "pre": {
            "dev": "!=null",
            "vlan": "!=null",
            "port": "!=null",
            "dmac": "!=null"
        }
    }
},
S,
{
    "kprobe:cxgb4_alloc_stid": {
        "description": "Allocate a stid for the given tid_info structure.",
        "pre": {
            "t": "!=null",
            "family": "== PF_INET6",
            "data": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:cxgb4_create_server": {
        "description": "Create an IP server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": "!=null",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_create_server": {
        "description": "Create an IP server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "vlan": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_create_server6": {
        "description": "Create an IPv6 server for the given port and address.",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_create_server6": {
        "description": "Create an IPv6 server",
        "pre": {
            "dev": "!=null",
            "stid": ">=0",
            "sip": "!=null",
            "sport": ">=0",
            "queue": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_best_mtu": {
        "description": "Find the entry in the MTU table closest to an MTU.",
        "pre": {
            "mtus": "!=null",
            "mtu": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_best_mtu": {
        "description": "Find the entry in the MTU table closest to an MTU.",
        "pre": {
            "mtus": "!=null",
            "mtu": "!=null",
            "idx": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_best_aligned_mtu": {
        "description": "Find the best MTU with data size alignment",
        "pre": {
            "mtus": "!=null",
            "header_size": "!=null",
            "data_size_max": "!=null",
            "data_size_align": "!=null",
            "mtu_idxp": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_best_aligned_mtu": {
        "description": "Find the best MTU with data size alignment",
        "pre": {
            "mtus": "!=null",
            "header_size": "!=null",
            "data_size_max": "!=null",
            "data_size_align": "!=null",
            "mtu_idxp": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_chan": {
        "description": "Get the HW channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_chan": {
        "description": "Get the HW channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_e2cchan": {
        "description": "get the HW c-channel of a port",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return_value": "is an unsigned integer"
        }
    }
},
{
    "kprobe:cxgb4_port_e2cchan": {
        "description": "Get the HW c-channel of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_viid": {
        "description": "Get the VI id of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_viid": {
        "description": "Get the VI id of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_port_idx": {
        "description": "Get the index of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_port_idx": {
        "description": "Get the index of a port",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:size = t4_read_reg(adap, MA_EDRAM0_BAR_A);edc0_size = EDRAM0_SIZE_G(size) << 20;size = t4_read_reg(adap, MA_EDRAM1_BAR_A);edc1_size = EDRAM1_SIZE_G(size) << 20;size = t4_read_reg(adap, MA_EXT_MEMORY0_BAR_A);mc0_size = EXT_MEM0_SIZE_G(size) << 20;if (t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F)": {
        "description": "Calculate the sizes of various memory regions based on register values.",
        "pre": {
            "adap": "!=null",
            "size": "!=null",
            "edc0_size": ">= 0",
            "edc1_size": ">= 0",
            "mc0_size": ">= 0",
            "t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A)": "!=null"
        }
    }
},
{
    "kprobe:function_name": {
        "description": "Description of the function",
        "pre": {
            "adap": "!=null",
            "size": "!=null",
            "edc0_size": "!=null",
            "edc1_size": "!=null",
            "mc0_size": "!=null",
            "t4_read_reg(adap, MA_TARGET_MEM_ENABLE_A) & HMA_MUX_F": "!=0"
        }
    }
},
{
    "kretprobe:cxgb4_create_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "dev": "!=null",
            "stid": "stid - adap->tids.sftid_base + adap->tids.nftids",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null",
            "port": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_create_server_filter": {
        "description": "Create a server filter on the cxgb4 network device.",
        "pre": {
            "dev": "!=null",
            "stid": "!=null",
            "sip": "!=null",
            "sport": "!=null",
            "vlan": "!=null",
            "queue": "!=null",
            "port": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_remove_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "dev": "!=null",
            "stid": "-= adap->tids.sftid_base; stid += adap->tids.nftids;",
            "queue": "!=null",
            "ipv6": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_remove_server_filter": {
        "description": "Adjust stid to correct filter index",
        "pre": {
            "stid": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_register_uld": {
        "description": "Register an upper-layer driver",
        "pre": {
            "type": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_register_uld": {
        "description": "Register an upper-layer driver",
        "pre": {
            "type": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_unregister_uld": {
        "description": "Unregister an upper-layer driver.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_unregister_uld": {
        "description": "Unregister an upper-layer driver.",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_reclaim_completed_tx": {
        "description": "Reclaims completed Tx descriptors",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "unmap": "in [true, false]"
        }
    }
},
{
    "kprobe:cxgb4_reclaim_completed_tx": {
        "description": "Reclaims completed Tx descriptors",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "unmap": "in [true, false]"
        }
    }
},
{
    "kretprobe:cxgb4_write_sgl": {
        "description": "Populate a scattergather list for a packet.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "start": ">=0",
            "addr": "!=null",
            "sgl_alignment": "16-byte aligned",
            "sgl_within_tx_descriptor": "within a Tx descriptor with available space",
            "end_greater_than_sgl": "end > sgl"
        }
    }
},
{
    "kprobe:cxgb4_write_sgl": {
        "description": "Populate a scattergather list for a packet.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "sgl_alignment": "16-byte aligned",
            "end": "!=null",
            "start": "unsigned int",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_write_partial_sgl": {
        "description": "Populate SGL for partial packet",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "addr": "!=null",
            "start": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_write_partial_sgl": {
        "description": "Populate SGL for partial packet",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "sgl": "!=null",
            "end": "!=null",
            "addr": "!=null",
            "start": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_ring_tx_db": {
        "description": "Check and potentially ring a Tx queue's doorbell.",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_ring_tx_db": {
        "description": "Check and potentially ring a Tx queue's doorbell.",
        "pre": {
            "adap": "!=null",
            "q": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_inline_tx_skb": {
        "description": "Inline a packet's data into Tx descriptors.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_inline_tx_skb": {
        "description": "Inline a packet's data into Tx descriptors.",
        "pre": {
            "skb": "!=null",
            "q": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_ofld_send": {
        "description": "Sends an offload packet.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_ofld_send": {
        "description": "Sends an offload packet.",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_crypto_send": {
        "description": "Send crypto packet",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_crypto_send": {
        "description": "Send crypto packet",
        "pre": {
            "dev": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_pktgl_to_skb": {
        "description": "Build an sk_buff from a packet gather list.",
        "pre": {
            "gl": "!=null",
            "skb_len": ">=0",
            "pull_len": ">=0"
        }
    }
},
{
    "kprobe:cxgb4_pktgl_to_skb": {
        "description": "Build an sk_buff from a packet gather list",
        "pre": {
            "gl": "!=null",
            "skb_len": ">=0",
            "pull_len": ">=0"
        }
    }
},
{
    "kretprobe:cxgb4_update_dev_clip": {
        "description": "Update the device clip for cxgb4 devices.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_update_dev_clip": {
        "description": "Update the device clip for cxgb4 devices.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_smt_release": {
        "description": "Release SMT entry",
        "pre": {
            "e": "!=null"
        }
    }
},
{
    "kprobe:cxgb4_smt_release": {
        "description": "Release SMT entry",
        "pre": {
            "e": "!=null"
        }
    }
},
{
    "kretprobe:cxgb4_smt_alloc_switching": {
        "description": "Allocates an SMT entry for switch filters.",
        "pre": {
            "dev": "!=null",
            "smac": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
S,
{
    "kretprobe:fman_port_config": {
        "description": "Creates a descriptor for the FM PORT module.",
        "pre": {
            "port": "!=null",
            "params": "!=null"
        }
    }
},
{
    "kprobe:fman_port_config": {
        "description": "Creates a descriptor for the FM PORT module.",
        "pre": {
            "port": "!=null",
            "params": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_use_kg_hash": {
        "description": "Sets the HW KeyGen or the BMI as HW Parser next engine, enabling or bypassing the KeyGen hashing of Rx traffic.",
        "pre": {
            "port": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:fman_port_use_kg_hash": {
        "description": "Sets the HW KeyGen or the BMI as HW Parser next engine, enabling or bypassing the KeyGen hashing of Rx traffic.",
        "pre": {
            "port": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:fman_port_init": {
        "description": "Initializes the FM PORT module by defining the software structure and configuring the hardware registers.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_init": {
        "description": "Initializes the FM PORT module by defining the software structure and configuring the hardware registers.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_cfg_buf_prefix_content": {
        "description": "Configures the buffer prefix content for a FM Port module.",
        "pre": {
            "port": "!=null",
            "buffer_prefix_content": "!=null"
        },
        "post": {
            "return": "in [0, error code]"
        }
    }
},
{
    "kprobe:fman_port_cfg_buf_prefix_content": {
        "description": "Configures the buffer prefix content for the FM Port module.",
        "pre": {
            "port": "!=null",
            "buffer_prefix_content": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_disable": {
        "description": "Gracefully disable an FM port. The port will not start new tasks after all tasks associated with the port are terminated.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_disable": {
        "description": "Gracefully disable an FM port. The port will not start new tasks after all tasks associated with the port are terminated.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_enable": {
        "description": "A runtime routine provided to allow disable/enable of port.",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_port_enable": {
        "description": "A runtime routine provided to allow disable/enable of port.",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_bind": {
        "description": "Bind to a specific FMan Port. Allowed only after the port was created.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:fman_port_bind": {
        "description": "Bind to a specific FMan Port. Allowed only after the port was created.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_get_qman_channel_id": {
        "description": "Get the QMan channel ID for the specific port",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "is an integer"
        }
    }
},
{
    "kprobe:fman_port_get_qman_channel_id": {
        "description": "Get the QMan channel ID for the specific port",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:fman_port_get_device": {
        "description": "Get the 'struct device' associated to the specified FMan port device",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:fman_port_get_device": {
        "description": "Get the 'struct device' associated to the specified FMan port device",
        "pre": {
            "port": "!=null"
        }
    }
},
S,
S,
S,
{
    "fman_sp_build_buffer_struct": {
        "description": "Translate margin and int_context params to FM parameters",
        "pre": {
            "int_context_data_copy": {
                "ext_buf_offset": {
                    "type": "u16",
                    "condition": "(buffer_prefix_content->priv_data_size & (OFFSET_UNITS - 1)) ? ((buffer_prefix_content->priv_data_size + OFFSET_UNITS) & ~(u16)(OFFSET_UNITS - 1)) : buffer_prefix_content->priv_data_size"
                }
            }
        }
    }
},
{
    "kretprobe:keygen_init": {
        "description": "KeyGen initialization: Initializes and enables KeyGen, allocate driver memory, setup registers, clear port bindings, invalidate all schemes",
        "pre": {
            "keygen_regs": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:keygen_init": {
        "description": "KeyGen initialization: Initializes and enables KeyGen, allocate driver memory, setup registers, clear port bindings, invalidate all schemes",
        "pre": {
            "keygen_regs": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:keygen_port_hashing_init": {
        "description": "Initializes a port for Rx Hashing with specified configuration parameters",
        "pre": {
            "keygen": "!=null",
            "hw_port_id": "!=null",
            "hash_base_fqid": "!=null",
            "hash_size": "!=null"
        }
    }
},
{
    "kprobe:keygen_port_hashing_init": {
        "description": "Initializes a port for Rx Hashing with specified configuration parameters",
        "pre": {
            "keygen": "!=null",
            "hw_port_id": "!=null",
            "hash_base_fqid": "!=null",
            "hash_size": "!=null"
        }
    }
},
{
    "kretprobe:fman_register_intr": {
        "description": "Used to register an event handler to be processed by FMan",
        "pre": {
            "fman": "!=null",
            "module": "in [CALLING_MODULE_1, CALLING_MODULE_2, ...]",
            "mod_id": ">=0",
            "intr_type": "in [ERROR, NORMAL]",
            "isr_cb": "!=null",
            "src_arg": "!=null"
        },
        "post": {
            "return_value": "==0"
        }
    }
},
{
    "kprobe:fman_register_intr": {
        "description": "Used to register an event handler to be processed by FMan",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]",
            "isr_cb": "!=null",
            "src_arg": "!=null"
        }
    }
},
{
    "kretprobe:fman_unregister_intr": {
        "description": "Unregister an event handler to be processed by FMan.",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]"
        },
        "post": {
            "return": "in [0, Error code]"
        }
    }
},
{
    "kprobe:fman_unregister_intr": {
        "description": "Unregister an event handler to be processed by FMan.",
        "pre": {
            "fman": "!=null",
            "module": "!=null",
            "mod_id": "!=null",
            "intr_type": "in [error, normal]"
        },
        "post": {
            "return": "in [0, Error code]"
        }
    }
},
{
    "kretprobe:fman_set_port_params": {
        "description": "Set port parameters for FMan device.",
        "pre": {
            "fman": "!=null",
            "port_params": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:fman_set_port_params": {
        "description": "Set port parameters for FMan device.",
        "pre": {
            "fman": "!=null",
            "port_params": "!=null"
        }
    }
},
{
    "kretprobe:fman_reset_mac": {
        "description": "Reset a specific MAC",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null"
        }
    }
},
{
    "kprobe:fman_reset_mac": {
        "description": "Reset a specific MAC",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null"
        }
    }
},
{
    "kretprobe:fman_set_mac_max_frame": {
        "description": "Set maximum frame length of specific MAC in FMan driver",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null",
            "mfl": "!=null"
        }
    }
},
{
    "kprobe:fman_set_mac_max_frame": {
        "description": "Set maximum frame length of specific MAC in FMan driver",
        "pre": {
            "fman": "!=null",
            "mac_id": "!=null",
            "mfl": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_bmi_max_fifo_size": {
        "description": "Get FMan maximum FIFO size",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kprobe:fman_get_bmi_max_fifo_size": {
        "description": "Get FMan maximum FIFO size",
        "pre": {
            "fman": "!=null"
        },
        "post": {
            "return": "is u32"
        }
    }
},
S,
S,
{
    "kretprobe:fman_get_qman_channel_id": {
        "description": "Get QMan channel ID associated to the Port id",
        "pre": {
            "fman": "!=null",
            "port_id": "!=null"
        },
        "post": {
            "return": "is an integer"
        }
    }
},
{
    "kprobe:fman_get_qman_channel_id": {
        "description": "Get QMan channel ID associated to the Port id",
        "pre": {
            "fman": "!=null",
            "port_id": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_mem_region": {
        "description": "Get FMan memory region",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kprobe:fman_get_mem_region": {
        "description": "Get FMan memory region",
        "pre": {
            "fman": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_max_frm": {
        "description": "Return: Max frame length configured in the FM driver",
        "pre": {
            "return_value": "!=null",
            "return_value": ">=0",
            "return_value": "<=65535"
        }
    }
},
{
    "kprobe:fman_get_max_frm": {
        "description": "Return: Max frame length configured in the FM driver",
        "pre": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:fman_get_rx_extra_headroom": {
        "description": "Return: Extra headroom size configured in the FM driver",
        "pre": {
            "return_value": ">=0"
        }
    }
},
{
    "kprobe:fman_get_rx_extra_headroom": {
        "description": "Return: Extra headroom size configured in the FM driver",
        "pre": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:fman_bind": {
        "description": "Bind to a specific FMan device.",
        "pre": {
            "fm_dev": "!=null"
        }
    }
},
{
    "kprobe:fman_bind": {
        "description": "Bind to a specific FMan device.",
        "pre": {
            "fm_dev": "!=null"
        }
    }
},
{
    "kretprobe:tx_credit": {
        "description": "Internal memory allocated for transmit buffering is guaranteed but not reserved. If the total transmit allocation is not used, then the unused portion is not left idle, it can be used for receive buffering but it will be reclaimed, if required, from receive by intelligently dropping already stored receive frames in the internal memory to ensure that the transmit allocation is respected. PaTXMBAR must be set to a value larger than PaTXBCR + 2 * max_frame_size + 32 if frame preemption is not enabled, or to 2 * PaTXBCR + 2 * p_max_frame_size (pMAC maximum frame size) + 2 * np_max_frame_size (eMAC maximum frame size) + 64 if frame preemption is enabled.",
        "pre": {
            "pdev": "!=null",
            "pf_pdev": "!=null",
            "ierb": "!=null",
            "port": ">=0",
            "tx_credit": ">=roundup(1000 + ENETC_MAC_MAXFRM_SIZE / 2, 100)"
        }
    }
},
{
    "kprobe:tx_credit": {
        "description": "Internal memory allocated for transmit buffering is guaranteed but not reserved; i.e. if the total transmit allocation is not used, then the unused portion is not left idle, it can be used for receive buffering but it will be reclaimed, if required, from receive by intelligently dropping already stored receive frames in the internal memory to ensure that the transmit allocation is respected. PaTXMBAR must be set to a value larger than PaTXBCR + 2 * max_frame_size + 32 if frame preemption is not enabled, or to 2 * PaTXBCR + 2 * p_max_frame_size (pMAC maximum frame size) + 2 * np_max_frame_size (eMAC maximum frame size) + 64 if frame preemption is enabled.",
        "pre": {
            "pdev": "struct platform_device",
            "pf_pdev": "struct pci_dev",
            "ierb": "!=null",
            "port": ">=0",
            "tx_credit": ">=roundup(1000 + ENETC_MAC_MAXFRM_SIZE / 2, 100)",
            "rx_credit": "!=null",
            "tx_alloc": "!=null"
        }
    }
},
{
    "kretprobe:comp->flags |= SLF_TOSS;if ( tslots > 0 )": {
        "description": "Set SLF_TOSS flag in comp->flags and check if tslots is greater than 0.",
        "pre": {
            "comp->flags": "& SLF_TOSS != 0",
            "tslots": "> 0"
        }
    }
},
{
    "kprobe:comp->flags |= SLF_TOSS;if ( tslots > 0 )": {
        "description": "Perform a bitwise OR operation between comp->flags and SLF_TOSS, and check if tslots is greater than 0.",
        "pre": {
            "comp->flags": "|= SLF_TOSS",
            "tslots": "> 0"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:if(isize<sizeof(struct iphdr))return isize;ip = (struct iphdr *) icp;if (ip->version != 4 || ip->ihl < 5)return isize;/* Bail if this packet isn't TCP, or is an IP fragment": {
        "description": "Check if the packet is TCP and not an IP fragment",
        "pre": {
            "isize": "< sizeof(struct iphdr)",
            "ip->version": "== 4",
            "ip->ihl": ">= 5"
        }
    }
},
{
    "kprobe:if(isize<sizeof(struct iphdr))return isize;ip = (struct iphdr *) icp;if (ip->version != 4 || ip->ihl < 5)return isize;/* Bail if this packet isn't TCP, or is an IP fragment `": {
        "description": "Helper function for checking packet conditions.",
        "pre": {
            "isize": "< sizeof(struct iphdr)",
            "ip->version": "== 4",
            "ip->ihl": ">= 5"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:can_eth_ioctl_hwts": {
        "description": "Handle hardware timestamping configuration for a network device.",
        "post": {
            "return": {
                "value": "in [-EFAULT, 0, -ERANGE]"
            }
        }
    }
},
{
    "kprobe:can_eth_ioctl_hwts": {
        "description": "Handle hardware timestamping configuration for Ethernet devices.",
        "pre": {
            "netdev": "!=null",
            "ifr": "!=null",
            "cmd": "in [SIOCSHWTSTAMP, SIOCGHWTSTAMP]",
            "ifr->ifr_data": "!=null",
            "sizeof(hwts_cfg)": "==sizeof(struct hwtstamp_config)",
            "copy_from_user(&hwts_cfg, ifr->ifr_data, sizeof(hwts_cfg))": "==0",
            "hwts_cfg.tx_type": "==HWTSTAMP_TX_ON",
            "hwts_cfg.rx_filter": "==HWTSTAMP_FILTER_ALL"
        },
        "post": {
            "return": "in [0, -EFAULT, -ERANGE]"
        }
    }
},
{
    "kretprobe:arc_proto_map": {
        "description": "Set the value of arc_proto_map.",
        "pre": {
            "arc_proto_map": "!=null",
            "arc_proto_map[i]": "!=null for all i in [0, 255]"
        }
    }
},
{
    "kprobe:arc_proto_map": {
        "description": "Set the arc_proto_map to the specified value.",
        "pre": {
            "arc_proto_map": "!=null",
            "arc_proto_map[i]": "!=null for all i in [0, 255]"
        }
    }
},
{
    "kretprobe:arc_proto_map": {
        "description": "Update the value of the entry associated with *key* in *arc_proto_map* with *value*.",
        "pre": {
            "arc_proto_map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "arc_proto_default": "!=null"
        }
    }
},
S,
{
    "kretprobe:snprintf": {
        "description": "Format a string and store it in a buffer.",
        "pre": {
            "hdr": "!=null",
            "sizeof(hdr)": ">=32",
            "dev->name": "!=null",
            "desc": "!=null",
            "skb->data": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kprobe:snprintf": {
        "description": "Format a string and store it in a buffer.",
        "pre": {
            "hdr": "!=null",
            "sizeof(hdr)": ">=6",
            "dev->name": "!=null",
            "desc": "!=null",
            "skb->data": "!=null",
            "skb->len": ">=0"
        }
    }
},
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancel the work synchronization for the reset_work",
        "pre": {
            "lp": "!=null",
            "dev": "!=null"
        }
    },
    "kretprobe:free_netdev": {
        "description": "Free the network device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cancel_work_sync": {
        "description": "Cancel the specified work item synchronously.",
        "pre": {
            "work": "!=null"
        }
    },
    "kprobe:free_netdev": {
        "description": "Free the specified network device.",
        "pre": {
            "dev": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:arcnet_interrupt": {
        "description": "Interrupt handler for ARCnet devices.",
        "pre": {
            "irq": "int",
            "dev_id": "void",
            "dev": "struct net_device",
            "lp": "struct arcnet_local",
            "recbuf": "int",
            "status": "int",
            "diagstatus": "int",
            "didsomething": "int",
            "boguscount": "int",
            "flags": "unsigned long",
            "retval": "int"
        },
        "post": {
            "retval": "in [IRQ_NONE]"
        }
    }
},
{
    "kprobe:if (!netif_running(dev))": {
        "description": "Check if the network interface is not running.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:com20020_check": {
        "description": "Enable P1Mode for backplane mode",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "!=null",
            "ioaddr": "=dev->base_addr",
            "status": "!=null",
            "lp": "!=null",
            "lp->setup": "if lp->clockm != 0 then 0 else lp->clockp << 1",
            "lp->setup2": "(lp->clockm << 4) | 8"
        },
        "post": {
            "comment": "Should we do this for SOHARD cards?"
        }
    }
},
{
    "kprobe:/* Enable P1Mode for backplane mode */": {
        "description": "Enable P1Mode for backplane mode.",
        "pre": {
            "dev": "!=null",
            "dev->base_addr": "!=null",
            "status": "!=null",
            "netdev_priv(dev)": "!=null",
            "arcnet_outb(XTOcfg(3) | RESETcfg, ioaddr, COM20020_REG_W_CONFIG)": "!=null",
            "udelay(5)": "!=null",
            "arcnet_outb(XTOcfg(3), ioaddr, COM20020_REG_W_CONFIG)": "!=null",
            "mdelay(RESETtime)": "!=null",
            "lp->setup": "!=null",
            "lp->clockm": "!=null",
            "lp->clockp": "!=null",
            "lp->setup2": "!=null",
            "CHECK: should we do this for SOHARD cards ?": "!=null"
        }
    }
},
{
    "kretprobe:lp = netdev_priv(dev);lp->hw.owner = THIS_MODULE;lp->hw.command = com20020_command;lp->hw.status = com20020_status;lp->hw.intmask = com20020_setmask;lp->hw.reset = com20020_reset;lp->hw.copy_to_card = com20020_copy_to_card;lp->hw.copy_from_card = com20020_copy_from_card;lp->hw.close = com20020_close;/* FIXME: do this some other way! `": {
        "description": "Initialize the rest of the device structure.",
        "pre": {
            "dev": "!=null",
            "shared": "!=null",
            "lp": "!=null",
            "ioaddr": "!=null"
        }
    }
},
{
    "kprobe:lp = netdev_priv(dev);lp->hw.owner = THIS_MODULE;lp->hw.command = com20020_command;lp->hw.status = com20020_status;lp->hw.intmask = com20020_setmask;lp->hw.reset = com20020_reset;lp->hw.copy_to_card = com20020_copy_to_card;lp->hw.copy_from_card = com20020_copy_from_card;lp->hw.close = com20020_close;/* FIXME: do this some other way! `": {
        "description": "Initialize the rest of the device structure.",
        "pre": {
            "dev": "!=null",
            "shared": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:hdlc_start_xmit": {
        "description": "Call hardware driver directly",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "hdlc": "!=null",
            "hdlc->proto->xmit": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->xmit": "!=null"
        }
    }
},
{
    "kprobe:hdlc_start_xmit": {
        "description": "Call hardware driver directly",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "hdlc->proto->xmit": "!=null",
            "hdlc->xmit": "!=null"
        }
    }
},
{
    "kretprobe:if (hdlc->proto->open)": {
        "description": "Check if the `open` field of the `proto` struct in `hdlc` is true.",
        "pre": {
            "hdlc": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->proto->open": "==true"
        }
    }
},
{
    "kprobe:if (hdlc->proto->open)": {
        "description": "Check if the `open` field of the `proto` struct in `hdlc` is true.",
        "pre": {
            "hdlc": "!=null",
            "hdlc->proto": "!=null",
            "hdlc->proto->open": "==true"
        }
    }
},
{
    "hdlc_ioctl": {
        "description": "Not handled by currently attached protocol (if any)",
        "pre": {
            "dev": "!=null",
            "ifs": "!=null",
            "proto": "!=null"
        },
        "post": {
            "result": "!= -EINVAL"
        }
    }
},
S,
{
    "kretprobe:cavium_mdiobus_write_c22": {
        "description": "Write a value to a register using Clause 22 MDIO protocol.",
        "pre": {
            "bus": "!=null",
            "phy_id": "!=null",
            "regnum": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:smi_cmd.s.phy_adr = phy_id; smi_cmd.s.reg_adr = regnum; oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD); do": {
        "description": "Write data to a register using MDIO protocol",
        "pre": {
            "phy_id": "!=null",
            "regnum": "!=null"
        }
    }
},
{
    "kretprobe:smi_cmd.s.phy_adr = phy_id;smi_cmd.s.reg_adr = devad;oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD);do": {
        "description": "Write a value to a register using the MDIO bus in Clause 45 format.",
        "pre": {
            "bus": "!=null",
            "phy_id": "!=null",
            "devad": "!=null",
            "regnum": "!=null",
            "val": "!=null",
            "p": "!=null",
            "timeout": ">=0",
            "r": ">=0",
            "smi_wr": "!=null",
            "smi_cmd": "!=null"
        }
    }
},
{
    "kprobe:smi_cmd.s.phy_adr = phy_id; smi_cmd.s.reg_adr = devad; oct_mdio_writeq(smi_cmd.u64, p->register_base + SMI_CMD); do": {
        "description": "Write data to a specific register in a PHY device using MDIO protocol.",
        "pre": {
            "phy_id": "!=null",
            "devad": "!=null"
        }
    }
},
{
    "kretprobe:fwnode_mdiobus_phy_device_register": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "mdio": "!=null",
            "phy": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "rc": "== -EPROBE_DEFER || > 0"
        }
    }
},
{
    "kprobe:fwnode_mdiobus_phy_device_register": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "mdio": "!=null",
            "phy": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "rc": "== -EPROBE_DEFER || > 0"
        }
    }
},
{
    "kretprobe:fwnode_mdiobus_register_phy": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle and address.",
        "pre": {
            "bus": "!=null",
            "child": "!=null",
            "addr": "!=null",
            "mii_ts": "null",
            "psec": "null",
            "is_c45": "bool",
            "phy_id": "u32",
            "rc": "int",
            "phy": "!=null",
            "is_acpi_node": "bool"
        }
    }
},
{
    "kprobe:fwnode_mdiobus_register_phy": {
        "description": "Register a PHY device on an MDIO bus with a given child fwnode handle.",
        "pre": {
            "bus": "!=null",
            "child": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__of_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the device tree",
        "pre": {
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__of_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the device tree",
        "pre": {
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:of_mdio_find_device": {
        "description": "Given a device tree node, find the mdio_device",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_mdio_find_device": {
        "description": "Given a device tree node, find the mdio_device",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_find_device": {
        "description": "Give a PHY node, find the phy_device",
        "pre": {
            "phy_np": "!=null"
        },
        "post": {
            "return_value": "!=null"
        }
    }
},
{
    "kprobe:of_phy_find_device": {
        "description": "Give a PHY node, find the phy_device",
        "pre": {
            "phy_np": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_connect": {
        "description": "Connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "phy_np": "!=null",
            "hndlr": "!=null",
            "flags": "!=null",
            "iface": "!=null"
        }
    }
},
{
    "kprobe:of_phy_connect": {
        "description": "Connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "phy_np": "!=null",
            "hndlr": "!=null",
            "flags": "!=null",
            "iface": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_get_and_connect": {
        "description": "Get phy node and connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "hndlr": "!=null"
        }
    }
},
{
    "kprobe:of_phy_get_and_connect": {
        "description": "Get phy node and connect to the phy described in the device tree",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "hndlr": "!=null"
        }
    }
},
{
    "kretprobe:of_phy_is_fixed_link": {
        "description": "Check if the given device node has a fixed link specification.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kprobe:of_phy_is_fixed_link": {
        "description": "Check if the PHY is a fixed link.",
        "pre": {
            "np": "!=null",
            "old_dt_binding": {
                "fixed-link": {
                    "exists": true,
                    "cells": 5
                }
            },
            "new_dt_binding": {
                "Ethernet device": {
                    "sub-node": "fixed-link"
                }
            }
        }
    }
},
{
    "kretprobe:phy_device_free": {
        "description": "Free the resources associated with the phydev.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_device_free": {
        "description": "Free the resources associated with the phydev structure.",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:__acpi_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the ACPI ASL.",
        "pre": {
            "mdio": "!=null",
            "fwnode": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__acpi_mdiobus_register": {
        "description": "Register mii_bus and create PHYs from the ACPI ASL.",
        "pre": {
            "mdio": "!=null",
            "fwnode": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:vmbus_sendpacket_getid": {
        "description": "Send the specified buffer on the given channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": ">=0",
            "requestid": ">=0",
            "trans_id": "!=null",
            "type": "in [negotiate, time packet, ...]",
            "flags": "in [0, VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED]"
        }
    }
},
{
    "kprobe:vmbus_sendpacket_getid": {
        "description": "Send the specified buffer on the given channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": ">=0",
            "requestid": ">=0",
            "trans_id": "!=null",
            "type": "in [negotiate, time packet, ...]",
            "flags": "in [0, VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED]"
        }
    }
},
{
    "kretprobe:__vmbus_recvpacket": {
        "description": "Retrieve the user packet on the specified channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": "!=null",
            "buffer_actual_len": "!=null",
            "requestid": "!=null",
            "raw": "in [true, false]"
        }
    }
},
{
    "kprobe:__vmbus_recvpacket": {
        "description": "Retrieve the user packet on the specified channel",
        "pre": {
            "channel": "!=null",
            "buffer": "!=null",
            "bufferlen": "!=null",
            "buffer_actual_len": "!=null",
            "requestid": "!=null",
            "raw": "in [true, false]"
        }
    }
},
{
    "kretprobe:of_find_all_nodes": {
        "description": "Find all nodes in the device tree starting from the given previous node.",
        "pre": {
            "prev": "!=null",
            "np": "!=null",
            "np->parent": "!=null",
            "np->sibling": "!=null"
        }
    }
},
{
    "kprobe:of_find_all_nodes": {
        "description": "Find all nodes in the device tree starting from the given previous node.",
        "pre": {
            "prev": "!=null",
            "np": "!=null",
            "prev->child": "!=null",
            "np->parent": "!=null",
            "np->sibling": "!=null"
        }
    }
},
{
    "kretprobe:of_n_addr_cells": {
        "description": "Returns the number of address cells for the given device node.",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "OF_ROOT_NODE_ADDR_CELLS_DEFAULT"
        }
    }
},
{
    "kprobe:return OF_ROOT_NODE_ADDR_CELLS_DEFAULT;}int of_n_addr_cells(struct device_node *np)": {
        "description": "This function returns the default value for the number of address cells in the root node.",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:__of_device_is_compatible": {
        "description": "Check if the node matches given constraints",
        "pre": {
            "device": "!=null",
            "compat": "in [null, '']",
            "type": "in [null, '']",
            "name": "in [null, '']"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__of_device_is_compatible": {
        "description": "Check if the node matches given constraints",
        "pre": {
            "device": "!=null",
            "compat": "in [null, '']",
            "type": "in [null, '']",
            "name": "in [null, '']"
        }
    }
},
{
    "kretprobe:of_machine_is_compatible": {
        "description": "Test root of device tree for a given compatible value",
        "pre": {
            "compat": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:of_machine_is_compatible": {
        "description": "Test root of device tree for a given compatible value",
        "pre": {
            "compat": "!=null"
        }
    }
},
{
    "kretprobe:__of_device_is_available": {
        "description": "Check if a device is available for use",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:__of_device_is_available": {
        "description": "Check if a device is available for use.",
        "pre": {
            "device": "!=null",
            "device->status": "in [null, \"okay\", \"ok\"]"
        }
    }
},
{
    "kretprobe:of_device_is_big_endian": {
        "description": "Check if a device has big-endian registers",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:of_device_is_big_endian": {
        "description": "Check if a device has big-endian registers.",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:of_get_parent": {
        "description": "Get a node's parent if any",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_get_parent": {
        "description": "Get a node's parent if any",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_parent": {
        "description": "Iterate to a node's parent",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_parent": {
        "description": "Iterate to a node's parent",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_child": {
        "description": "Iterate through the child nodes of a parent node.",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_child": {
        "description": "Iterate through the child nodes of a parent node.",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_available_child": {
        "description": "Find the next available child node",
        "pre": {
            "node": "!=null",
            "prev": "!=null or ==null"
        }
    }
},
{
    "kprobe:of_get_next_available_child": {
        "description": "Find the next available child node",
        "pre": {
            "node": "!=null",
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_next_cpu_node": {
        "description": "Iterate on cpu nodes",
        "pre": {
            "prev": "!=null"
        }
    }
},
{
    "kprobe:of_get_next_cpu_node": {
        "description": "Iterate on cpu nodes",
        "pre": {
            "prev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_compatible_child": {
        "description": "Find compatible child node",
        "pre": {
            "parent": "!=null",
            "compatible": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_compatible_child": {
        "description": "Find compatible child node",
        "pre": {
            "parent": "!=null",
            "compatible": "!=null"
        }
    }
},
{
    "kretprobe:of_get_child_by_name": {
        "description": "Find the child node by name for a given parent",
        "pre": {
            "node": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_child_by_name": {
        "description": "Find the child node by name for a given parent",
        "pre": {
            "node": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_opts_by_path": {
        "description": "Find a node matching a full OF path",
        "pre": {
            "path": "!=null",
            "opts": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_opts_by_path": {
        "description": "Find a node matching a full OF path",
        "pre": {
            "path": "!=null",
            "opts": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_name": {
        "description": "Find a node by its \"name\" property",
        "pre": {
            "from": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_name": {
        "description": "Find a node by its \"name\" property",
        "pre": {
            "from": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_type": {
        "description": "Find a node by its \"device_type\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_type": {
        "description": "Find a node by its \"device_type\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null"
        }
    }
},
{
    "kretprobe:of_find_compatible_node": {
        "description": "Find a node based on type and one of the tokens in its \"compatible\" property.",
        "pre": {
            "from": "!=null",
            "type": "in [\"device_type\", null]",
            "compatible": "!=null"
        }
    }
},
{
    "kprobe:of_find_compatible_node": {
        "description": "Find a node based on type and one of the tokens in its \"compatible\" property.",
        "pre": {
            "from": "!=null",
            "type": "!=null",
            "compatible": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_with_property": {
        "description": "Find a node which has a property with the given name.",
        "pre": {
            "from": "!=null",
            "prop_name": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_with_property": {
        "description": "Find a node which has a property with the given name.",
        "pre": {
            "from": "!=null",
            "prop_name": "!=null"
        }
    }
},
{
    "kretprobe:of_match_node": {
        "description": "Tell if a device_node has a matching of_match structure",
        "pre": {
            "matches": "!=null",
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_match_node": {
        "description": "Tell if a device_node has a matching of_match structure",
        "pre": {
            "matches": "!=null",
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_find_matching_node_and_match": {
        "description": "Find a node based on an of_device_id match table.",
        "pre": {
            "from": "!=null",
            "matches": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kprobe:of_find_matching_node_and_match": {
        "description": "Find a node based on an of_device_id match table.",
        "pre": {
            "from": "!=null",
            "matches": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:of_find_node_by_phandle": {
        "description": "Find a node given a phandle",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:of_find_node_by_phandle": {
        "description": "Find a node given a phandle",
        "pre": {
            "handle": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:of_parse_phandle_with_args_map": {
        "description": "Find a node pointed by phandle in a list and remap it.",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "stem_name": "!=null",
            "index": ">=0",
            "out_args": "!=null"
        }
    }
},
{
    "kprobe:of_parse_phandle_with_args_map": {
        "description": "Find a node pointed by phandle in a list and remap it.",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "stem_name": "!=null",
            "index": ">=0",
            "out_args": "!=null"
        }
    }
},
{
    "kretprobe:of_count_phandle_with_args": {
        "description": "Find the number of phandles references in a property",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "cells_name": "!=null"
        }
    }
},
{
    "kprobe:of_count_phandle_with_args": {
        "description": "Find the number of phandles references in a property",
        "pre": {
            "np": "!=null",
            "list_name": "!=null",
            "cells_name": "!=null"
        }
    }
},
{
    "kretprobe:of_find_device_by_node": {
        "description": "Find the platform_device associated with a node",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_find_device_by_node": {
        "description": "Find the platform_device associated with a node",
        "pre": {
            "np": "!=null"
        }
    }
},
{
    "kretprobe:of_device_alloc": {
        "description": "Allocate and initialize an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_device_alloc": {
        "description": "Allocate and initialize an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_platform_device_create_pdata": {
        "description": "Alloc, initialize and register an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "platform_data": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_platform_device_create_pdata": {
        "description": "Alloc, initialize and register an of_device",
        "pre": {
            "np": "!=null",
            "bus_id": "!=null",
            "platform_data": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_platform_bus_probe": {
        "description": "Probe the device-tree for platform buses",
        "pre": {
            "root": "!=null",
            "matches": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:of_platform_bus_probe": {
        "description": "Probe the device-tree for platform buses",
        "pre": {
            "root": "!=null",
            "matches": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:of_get_cpu_node": {
        "description": "Get device node associated with the given logical CPU",
        "pre": {
            "cpu": "!=null",
            "thread": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_get_cpu_node": {
        "description": "Get device node associated with the given logical CPU",
        "pre": {
            "cpu": "!=null",
            "thread": "in [null, unsigned int]"
        }
    }
},
{
    "kretprobe:of_cpu_device_node_get": {
        "description": "Get the CPU device_node for a given logical CPU number",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kprobe:of_cpu_device_node_get": {
        "description": "Get the CPU device_node for a given logical CPU number",
        "pre": {
            "cpu": "!=null"
        }
    }
},
{
    "kretprobe:of_cpu_node_to_id": {
        "description": "Get the logical CPU number for a given device_node",
        "pre": {
            "cpu_node": "!=null"
        },
        "post": {
            "return_value": "is an integer",
            "return_value": ">= -ENODEV"
        }
    }
},
{
    "kprobe:of_cpu_node_to_id": {
        "description": "Get the logical CPU number for a given device_node",
        "pre": {
            "cpu_node": "!=null"
        },
        "post": {
            "return": "is_integer"
        }
    }
},
{
    "kretprobe:of_get_cpu_state_node": {
        "description": "Get CPU's idle state node at the given index",
        "pre": {
            "cpu_node": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:of_get_cpu_state_node": {
        "description": "Get CPU's idle state node at the given index",
        "pre": {
            "cpu_node": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:of_graph_is_present": {
        "description": "Check if the device node has a graph port or ports sub-node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_is_present": {
        "description": "Check if the device node has a graph port.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_parse_endpoint": {
        "description": "Parse common endpoint node properties",
        "pre": {
            "node": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:of_graph_parse_endpoint": {
        "description": "Parse common endpoint node properties",
        "pre": {
            "node": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_port_by_id": {
        "description": "Get the port matching a given id",
        "pre": {
            "parent": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_port_by_id": {
        "description": "Get the port matching a given id",
        "pre": {
            "parent": "!=null",
            "id": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_next_endpoint": {
        "description": "Get the next endpoint node",
        "pre": {
            "parent": "!=null",
            "prev": "in [null, !=null]"
        }
    }
},
{
    "kprobe:of_graph_get_next_endpoint": {
        "description": "Get the next endpoint node",
        "pre": {
            "parent": "!=null",
            "prev": "in [null, !=null]"
        }
    }
},
{
    "kretprobe:of_graph_get_endpoint_by_regs": {
        "description": "Get endpoint node of specific identifiers",
        "pre": {
            "parent": "!=null",
            "port_reg": "int",
            "reg": "int"
        }
    }
},
{
    "kprobe:of_graph_get_endpoint_by_regs": {
        "description": "Get endpoint node of specific identifiers",
        "pre": {
            "parent": "!=null",
            "port_reg": "int",
            "reg": "int"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_endpoint": {
        "description": "Get remote endpoint node associated with remote endpoint node linked to @node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_endpoint": {
        "description": "Get remote endpoint node associated with remote endpoint node linked to @node.",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_port_parent": {
        "description": "Get port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_port_parent": {
        "description": "Get port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_port_parent": {
        "description": "Get remote port's parent node",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_port_parent": {
        "description": "Get remote port's parent node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_graph_get_remote_node": {
        "description": "Get remote parent device_node for given portendpoint",
        "pre": {
            "node": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kprobe:of_graph_get_remote_node": {
        "description": "Get remote parent device_node for given portendpoint.",
        "pre": {
            "node": "!=null",
            "port": "!=null",
            "endpoint": "!=null"
        }
    }
},
{
    "kretprobe:of_match_device": {
        "description": "Tell if a struct device matches an of_device_id list",
        "pre": {
            "matches": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_match_device": {
        "description": "Tell if a struct device matches an of_device_id list.",
        "pre": {
            "matches": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_pci_range_to_resource": {
        "description": "Create a resource from an of_pci_range",
        "pre": {
            "range": "!=null",
            "np": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:of_pci_range_to_resource": {
        "description": "Create a resource from an of_pci_range",
        "pre": {
            "range": "!=null",
            "np": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:of_range_to_resource": {
        "description": "Create a resource from a ranges entry",
        "pre": {
            "np": "!=null",
            "index": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [ENOENT, EINVAL]"
        }
    }
},
{
    "kprobe:of_range_to_resource": {
        "description": "Create a resource from a ranges entry",
        "pre": {
            "np": "!=null",
            "index": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [ENOENT, EINVAL]"
        }
    }
},
S,
S,
{
    "kretprobe:of_translate_dma_region": {
        "description": "Translate device tree address and size tuple",
        "pre": {
            "dev": "!=null",
            "prop": "!=null",
            "start": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kprobe:of_translate_dma_region": {
        "description": "Translate device tree address and size tuple",
        "pre": {
            "dev": "!=null",
            "prop": "!=null",
            "start": "!=null",
            "length": "!=null"
        }
    }
},
{
    "kretprobe:parent = of_get_parent(dev);if (parent == NULL)return NULL;bus = of_match_bus(parent);if (strcmp(bus->name, \"pci\") && (bar_no >= 0))": {
        "description": "Get parent & match bus type",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "bar_no": ">=0",
            "size": "!=null",
            "flags": "!=null",
            "prop": "!=null",
            "psize": "!=null",
            "parent": "!=null",
            "bus": "!=null",
            "onesize": "!=null",
            "i": "!=null",
            "na": "!=null",
            "ns": "!=null"
        }
    }
},
{
    "kprobe:parent = of_get_parent": {
        "description": "Get parent & match bus type",
        "pre": {
            "dev": "!=null",
            "index": "!=null",
            "bar_no": "!=null",
            "size": "!=null",
            "flags": "!=null"
        }
    },
    "kprobe:if (parent == NULL)": {
        "description": "Check if parent is NULL",
        "pre": {
            "parent": "==null"
        }
    },
    "kprobe:return NULL;": {
        "description": "Return NULL"
    },
    "kprobe:bus = of_match_bus(parent)": {
        "description": "Match bus type",
        "pre": {
            "parent": "!=null"
        }
    },
    "kprobe:strcmp(bus->name, \"pci\") && (bar_no >= 0)": {
        "description": "Check if bus name is \"pci\" and bar_no is greater than or equal to 0",
        "pre": {
            "bus->name": "==\"pci\"",
            "bar_no": ">=0"
        }
    }
},
{
    "kretprobe:of_property_read_reg": {
        "description": "Retrieve the specified \"reg\" entry index without translating",
        "pre": {
            "np": "!=null",
            "idx": "!=null",
            "addr": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]",
            "addr": "if return == 0, then !=null",
            "size": "if return == 0, then !=null"
        }
    }
},
{
    "kprobe:of_property_read_reg": {
        "description": "Retrieve the specified \"reg\" entry index without translating",
        "pre": {
            "np": "!=null",
            "idx": "!=null",
            "addr": "!=null",
            "size": "!=null"
        }
    }
},
{
    "kretprobe:of_iomap": {
        "description": "Maps the memory mapped IO for a given device_node",
        "pre": {
            "np": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kprobe:of_iomap": {
        "description": "Maps the memory mapped IO for a given device_node",
        "pre": {
            "np": "!=null",
            "index": "!=null"
        }
    }
},
{
    "kretprobe:of_io_request_and_map": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node.",
        "pre": {
            "device": "!=null",
            "index": ">=0",
            "name": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:of_io_request_and_map": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node.",
        "pre": {
            "device": "!=null",
            "index": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:of_node_get": {
        "description": "Increment refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_node_get": {
        "description": "Increment refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:of_node_put": {
        "description": "Decrement refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:of_node_put": {
        "description": "Decrement refcount of a node",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:nubus_get_board_dir": {
        "description": "Get the board directory for a given nubus board.",
        "pre": {
            "dir": "!=null",
            "board.directory": "!=null",
            "dir.ptr": "initialized",
            "dir.base": "initialized",
            "dir.done": "initialized",
            "dir.mask": "initialized"
        },
        "post": {
            "return": {
                "constraints": "in [-1, 0]",
                "description": "0 on success, -1 on failure"
            }
        }
    }
},
{
    "kprobe:nubus_get_board_dir": {
        "description": "Get the board directory for the given nubus board.",
        "pre": {
            "board": "!=null",
            "dir": "!=null",
            "dir->ptr": "!=null",
            "dir->base": "!=null",
            "dir->done": ">=0",
            "dir->mask": ">=0"
        }
    }
},
{
    "kretprobe:nubus_get_subdir": {
        "description": "Set the base variable of ent to the value of nd->ptr.",
        "pre": {
            "nd": "!=null",
            "ent": "!=null",
            "nd->done": "==0",
            "nd->ptr": "!=null"
        },
        "post": {
            "ent->base": "==nd->ptr"
        }
    }
},
{
    "kprobe:ent->base = nd->ptr;/* This moves nd->ptr forward `": {
        "description": "Move nd->ptr forward",
        "pre": {
            "ent": "!=null",
            "nd": "!=null",
            "nd->ptr": "!=null"
        }
    }
},
{
    "kretprobe:pnp_start_dev": {
        "description": "Low-level start of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_start_dev": {
        "description": "Low-level start of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_stop_dev": {
        "description": "Low-level disable of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_stop_dev": {
        "description": "Low-level disable of the PnP device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_activate_dev": {
        "description": "Activates a PnP device for use.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_activate_dev": {
        "description": "Activates a PnP device for use.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_disable_dev": {
        "description": "Disables the device",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_disable_dev": {
        "description": "Disables the device.",
        "pre": {
            "dev": "!=null",
            "dev->protocol": "in [PNP_PROTOCOL_A, PNP_PROTOCOL_B, PNP_PROTOCOL_C]",
            "dev->resources": "can be used by other devices"
        }
    }
},
{
    "kretprobe:pnp_request_card_device": {
        "description": "Searches for a PnP device under the specified card",
        "pre": {
            "clink": "!=null",
            "id": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kprobe:pnp_request_card_device": {
        "description": "Searches for a PnP device under the specified card.",
        "pre": {
            "clink": "!=null",
            "id": "!=null",
            "from": "any"
        }
    }
},
{
    "kretprobe:pnp_add_card_id": {
        "description": "adds an EISA id to the specified card",
        "pre": {
            "card": "!=null",
            "id": "!=null"
        }
    }
},
S,
{
    "kretprobe:pnp_register_card_driver": {
        "description": "Registers a PnP card driver with the PnP Layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pnp_register_card_driver": {
        "description": "Registers a PnP card driver with the PnP Layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pnp_unregister_card_driver": {
        "description": "Unregisters a PnP card driver from the PnP Layer",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pnp_unregister_card_driver": {
        "description": "Unregisters a PnP card driver from the PnP Layer.",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pnp_is_active": {
        "description": "Determines if a device is active based on its current resources",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pnp_is_active": {
        "description": "Determines if a device is active based on its current resources.",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pnp_for_each_dev": {
        "description": "Check for conflicts with other pnp devices",
        "pre": {
            "dev": "!=null",
            "i": "is an integer",
            "tres": "!=res",
            "tres->flags": "& IORESOURCE_IO",
            "tport": "!=null",
            "tend": "!=null",
            "port": "!=null",
            "end": "!=null",
            "ranged_conflict(port, end, tport, tend)": "!=0"
        }
    }
},
{
    "kprobe:pnp_for_each_dev": {
        "description": "Check for conflicts with other PnP devices.",
        "pre": {
            "dev": "!=null",
            "flags": "& IORESOURCE_IO != 0",
            "i": "valid_range",
            "tres": "!= res",
            "tres.flags": "& IORESOURCE_IO != 0",
            "tport": "valid_pointer",
            "tend": "valid_pointer",
            "ranged_conflict(port, end, tport, tend)": "false"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:isapnp_cfg_begin": {
        "description": "Begin ISAPnP configuration.",
        "pre": {
            "csn": ">=1 && <=isapnp_csn_count",
            "logdev": "<=10"
        },
        "post": {
            "return": "-EINVAL"
        }
    }
},
{
    "kprobe:/* we must set RDP to our value again */": {
        "description": "Helper function for setting RDP value.",
        "pre": {
            "csn": ">= 1",
            "csn": "<= isapnp_csn_count",
            "logdev": "<= 10"
        }
    }
},
S,
S,
{
    "kretprobe:isapnp_wait": {
        "description": "Place all PnP cards in wait-for-key state.",
        "pre": {
            "idx": "!=null",
            "val": "!=null",
            "code": "0x6a",
            "msb": "!=null",
            "i": ">=1",
            "msb": "((code & 0x01) ^ ((code & 0x02) >> 1)) << 7",
            "code": "(code >> 1) | msb"
        }
    }
},
{
    "kprobe:isapnp_wait": {
        "description": "place all pnp cards in wait-for-key state",
        "pre": {}
    }
},
S,
S,
{
    "kretprobe:port_bo = t_data->block_offset;}}}EXPORT_SYMBOL(sdw_compute_slave_ports": {
        "description": "This function computes the slave ports for a given master runtime and transport data.",
        "pre": {
            "m_rt": "!=null",
            "t_data": "!=null",
            "s_rt": "!=null",
            "p_rt": "!=null",
            "port_bo": "!=null",
            "sample_int": "!=null",
            "rate": "!=null",
            "bps": "!=null",
            "ch": "!=null",
            "slave_total_ch": "!=null",
            "b_params": "!=null"
        }
    }
},
{
    "kprobe:port_bo = t_data->block_offset;}}}EXPORT_SYMBOL(sdw_compute_slave_ports": {
        "description": "This function computes the slave ports for a given master runtime and transport data.",
        "pre": {
            "m_rt": "!=null",
            "t_data": "!=null",
            "s_rt": "!=null",
            "p_rt": "!=null",
            "port_bo": "!=null",
            "sample_int": "!=null",
            "rate": "!=null",
            "bps": "!=null",
            "ch": "!=null",
            "slave_total_ch": "!=null",
            "b_params": "!=null"
        }
    }
},
S,
{
    "kprobe:sdw_compute_params": {
        "description": "Compute bus, transport and port parameters",
        "pre": {
            "bus": "!=null",
            "transport": "!=null",
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_master_add": {
        "description": "Add a bus Master instance",
        "pre": {
            "bus": "!=null",
            "parent": "!=null",
            "fwnode": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_master_add": {
        "description": "Add a bus Master instance",
        "pre": {
            "bus": "!=null",
            "parent": "!=null",
            "fwnode": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_master_delete": {
        "description": "delete the bus master instance",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_master_delete": {
        "description": "Delete the bus master instance",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_show_ping_status": {
        "description": "Direct report of PING status, to be used by Peripheral drivers",
        "pre": {
            "bus": "!=null",
            "sync_delay": ">=0"
        }
    }
},
{
    "kprobe:sdw_show_ping_status": {
        "description": "Direct report of PING status, to be used by Peripheral drivers",
        "pre": {
            "bus": "!=null",
            "sync_delay": ">=0"
        }
    }
},
{
    "kretprobe:sdw_nread_no_pm": {
        "description": "Read \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sdw_nread_no_pm": {
        "description": "Read \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:sdw_nwrite_no_pm": {
        "description": "Write \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kprobe:sdw_nwrite_no_pm": {
        "description": "Write \"n\" contiguous SDW Slave registers with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "count": "!=null",
            "val": "!=null"
        }
    }
},
{
    "kretprobe:sdw_write_no_pm": {
        "description": "Write a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kprobe:sdw_write_no_pm": {
        "description": "Write a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null",
            "value": "!=null"
        }
    }
},
{
    "kretprobe:sdw_read_no_pm": {
        "description": "Read a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:sdw_read_no_pm": {
        "description": "Read a SDW Slave register with no PM",
        "pre": {
            "slave": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_prep_clk_stop": {
        "description": "Prepare Slave(s) for clock stop",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_prep_clk_stop": {
        "description": "Prepare Slave(s) for clock stop",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_clk_stop": {
        "description": "Stop the bus clock",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_clk_stop": {
        "description": "Stop bus clock",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_bus_exit_clk_stop": {
        "description": "Exit clock stop mode",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_bus_exit_clk_stop": {
        "description": "Exit clock stop mode",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_handle_slave_status": {
        "description": "Handle Slave status",
        "pre": {
            "bus": "!=null",
            "status": "!=null"
        }
    }
},
{
    "kprobe:sdw_handle_slave_status": {
        "description": "Handle Slave status",
        "pre": {
            "bus": "!=null",
            "status": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:sdw_master_read_prop": {
        "description": "Read Master properties",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:sdw_master_read_prop": {
        "description": "Read Master properties",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:sdw_slave_read_prop": {
        "description": "Read Slave properties",
        "pre": {
            "slave": "!=null"
        }
    }
},
{
    "kprobe:sdw_slave_read_prop": {
        "description": "Read Slave properties",
        "pre": {
            "slave": "!=null"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy the contents of the memory pointed to by 'id' to the memory location pointed to by 'slave->id' with a size of 'sizeof(*id)'. Then, assign 'bus->dev' to 'slave->dev.parent' and assign 'fwnode' to 'slave->dev.fwnode'. Finally, check if 'id->unique_id' is equal to 'SDW_IGNORED_UNIQUE_ID'.",
        "pre": {
            "slave->id": "!=null",
            "id": "!=null",
            "sizeof(*id)": "!=null",
            "slave->dev.parent": "bus->dev",
            "slave->dev.fwnode": "fwnode",
            "id->unique_id": "SDW_IGNORED_UNIQUE_ID"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy data from source address to destination address.",
        "pre": {
            "&slave->id": "!=null",
            "id": "!=null",
            "sizeof(*id)": "!=null",
            "slave->dev.parent": "bus->dev",
            "slave->dev.fwnode": "fwnode",
            "id->unique_id": "SDW_IGNORED_UNIQUE_ID"
        }
    }
},
S,
S,
S,
S,
{
    "kretprobe:sdw_prep_deprep_ports": {
        "description": "De-prepare port(s) in the sdw_deprepare_stream function",
        "pre": {
            "m_rt": "!=null",
            "ret": "<0"
        }
    }
},
S,
{
    "kretprobe:sdw_alloc_stream": {
        "description": "Allocate and return stream runtime",
        "pre": {
            "stream_name": "!=null"
        }
    }
},
{
    "kprobe:sdw_alloc_stream": {
        "description": "Allocate and return stream runtime",
        "pre": {
            "stream_name": "!=null"
        }
    }
},
{
    "kretprobe:sdw_startup_stream": {
        "description": "Startup SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kprobe:sdw_startup_stream": {
        "description": "Startup SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_shutdown_stream": {
        "description": "Shutdown SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kprobe:sdw_shutdown_stream": {
        "description": "Shutdown SoundWire stream",
        "pre": {
            "sdw_substream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_add_master": {
        "description": "Allocate and add master runtime to a stream",
        "pre": {
            "bus": "!=null",
            "stream_config": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_add_master": {
        "description": "Allocate and add master runtime to a stream",
        "pre": {
            "bus": "!=null",
            "stream_config": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_remove_master": {
        "description": "Remove master from sdw_stream",
        "pre": {
            "bus": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_remove_master": {
        "description": "Remove master from sdw_stream",
        "pre": {
            "bus": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_stream_add_slave": {
        "description": "Allocate and add masterslave runtime to a stream",
        "pre": {
            "slave": "!=null",
            "stream_config": "!=null",
            "stream": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0"
        }
    }
},
{
    "kprobe:sdw_stream_add_slave": {
        "description": "Allocate and add masterslave runtime to a stream",
        "pre": {
            "slave": "!=null",
            "stream_config": "!=null",
            "stream": "!=null",
            "port_config": "!=null",
            "num_ports": ">=0"
        }
    }
},
{
    "kretprobe:sdw_stream_remove_slave": {
        "description": "Remove slave from sdw_stream",
        "pre": {
            "slave": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kprobe:sdw_stream_remove_slave": {
        "description": "Remove slave from sdw_stream",
        "pre": {
            "slave": "!=null",
            "stream": "!=null"
        }
    }
},
{
    "kretprobe:sdw_cdns_config_update": {
        "pre": {
            "cdns": "!=null"
        },
        "ret": "is int"
    }
},
S,
{
    "kretprobe:sdw_cdns_config_update_set_wait": {
        "description": "Wait until configuration update bit is self-cleared",
        "pre": {
            "cdns": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_config_update_set_wait": {
        "description": "Wait until configuration update bit is self-cleared.",
        "pre": {
            "cdns": "!=null"
        }
    }
},
S,
S,
{
    "kretprobe:cdns_xfer_msg_defer": {
        "description": "Transfer deferred message on the sdw_bus.",
        "pre": {
            "bus": "!=null",
            "cdns": "!=null",
            "defer": "!=null",
            "msg": "!=null",
            "cmd": "int",
            "ret": "int",
            "defer->msg": "msg",
            "defer->msg->len": ">1"
        },
        "post": {
            "ret": "in [-ENOTSUPP, SDW_CMD_FAIL_OTHER]"
        }
    }
},
{
    "kprobe:cdns_xfer_msg_defer": {
        "description": "Transfer a deferred message on the sdw_bus.",
        "pre": {
            "bus": "!=null",
            "cdns": "!=null",
            "defer": "!=null",
            "msg": "!=null",
            "cmd": "int",
            "ret": "int",
            "defer->msg": "msg",
            "defer->msg->len": ">1",
            "ret": "=0",
            "cmd": "=0"
        }
    }
},
{
    "kretprobe:sdw_cdns_irq": {
        "description": "Cadence interrupt handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:sdw_cdns_irq": {
        "description": "Cadence interrupt handler",
        "pre": {
            "irq": "!=null",
            "dev_id": "!=null"
        }
    }
},
