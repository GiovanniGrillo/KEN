[{
    "kretprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap. Shifting right (dividing) means moving bits in the MS -> LS bit direction. Zeros are fed into the vacated MS positions and the LS bits shifted off the bottom are lost.",
        "proto" :"void (*__bitmap_shift_right)(unsigned long *dst, const unsigned long *src, unsigned shift, unsigned nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:__bitmap_shift_right": {
        "description": "Logical right shift of the bits in a bitmap. Shifting right (dividing) means moving bits in the MS -> LS bit direction. Zeros are fed into the vacated MS positions and the LS bits shifted off the bottom are lost.",
        "proto" :"void (*__bitmap_shift_right)(unsigned long *dst, const unsigned long *src, unsigned shift, unsigned nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:__bitmap_shift_left": {
        "description": "__bitmap_shift_left - logical left shift of the bits in a bitmap. Shifting left (multiplying) means moving bits in the LS -> MS direction. Zeros are fed into the vacated LS bit positions and those MS bits shifted off the top are lost.",
        "proto" :"void (*__bitmap_shift_left)(unsigned long *dst, const unsigned long *src, unsigned int shift, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:__bitmap_shift_left": {
        "description": "Logical left shift of the bits in a bitmap. Shifting left (multiplying) means moving bits in the LS -> MS direction. Zeros are fed into the vacated LS bit positions and those MS bits shifted off the top are lost.",
        "proto" :"void (*__bitmap_shift_left)(unsigned long *dst, const unsigned long *src, unsigned int shift, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "shift": ">=0",
            "nbits": ">=0"
        },
    }
},
{
    "kretprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits. Set the n-th bit of @dst iff the n-th bit of @src is set and n is less than @first, or the m-th bit of @src is set for any m such that @first <= n < nbits, and m = n + @cut.",
        "proto" :"void (*bitmap_cut)(unsigned long *dst, const unsigned long *src, unsigned int first, unsigned int cut, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": "in [0, nbits)",
            "cut": "in [0, nbits - first)",
            "nbits": ">0"
        },
    }
},
{
    "kprobe:bitmap_cut": {
        "description": "Remove bit region from bitmap and right shift remaining bits. Set the n-th bit of @dst iff the n-th bit of @src is set and n is less than @first, or the m-th bit of @src is set for any m such that @first <= n < nbits, and m = n + @cut.",
        "proto" :"void (*bitmap_cut)(unsigned long *dst, const unsigned long *src, unsigned int first, unsigned int cut, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "first": ">=0",
            "cut": ">=0",
            "nbits": ">0",
        },
    }
},
{
    "kretprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area. The @align_mask should be one less than a power of 2; the effect is that the bit offset of all zero areas this function finds plus @align_offset is multiple of that power of 2.",
        "proto" :"unsigned long (*bitmap_find_next_zero_area_off)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask, unsigned long align_offset)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": "is one less than a power of 2",
            "align_offset": ">=0"
        },
    }
},
{
    "kprobe:bitmap_find_next_zero_area_off": {
        "description": "Find a contiguous aligned zero area. The @align_mask should be one less than a power of 2; the effect is that the bit offset of all zero areas this function finds plus @align_offset is multiple of that power of 2.",
        "proto" :"unsigned long (*bitmap_find_next_zero_area_off)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, unsigned long align_mask, unsigned long align_offset)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "align_mask": "is power of 2 - 1",
            "align_offset": ">=0"
        },
    }
},
{
    "kretprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap.",
        "proto" :"int bitmap_parse_user(const char __user *ubuf, unsigned int ulen, unsigned long *maskp, int nmaskbits)",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        },
    }
},
{
    "kprobe:bitmap_parse_user": {
        "description": "Convert an ASCII hex string in a user buffer into a bitmap.",
        "proto" :"int (*bitmap_parse_user)(const char __user *ubuf, unsigned int ulen, unsigned long *maskp, int nmaskbits)",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0",
        },
    }
},
{
    "kretprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string. Output format is a comma-separated list of decimal numbers and ranges if list is specified or hex digits grouped into comma-separated sets of 8 digitsset. Returns the number of characters written to buf. It is assumed that @buf is a pointer into a PAGE_SIZE, page-aligned area and that sufficient storage remains at @buf to accommodate the bitmap_print_to_pagebuf() output. Returns the number of characters actually printed to @buf, excluding terminating '\\0'.",
        "proto" :"int (*bitmap_print_to_pagebuf)(bool list, char *buf, const unsigned long *maskp, int nmaskbits)",
        "pre": {
            "list": "is bool",
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": "is int"
        },
    }
},
{
    "kprobe:bitmap_print_to_pagebuf": {
        "description": "Convert bitmap to list or hex format ASCII string. Output format is a comma-separated list of decimal numbers and ranges if list is specified or hex digits grouped into comma-separated sets of 8 digitsset. Returns the number of characters written to buf. It is assumed that @buf is a pointer into a PAGE_SIZE, page-aligned area and that sufficient storage remains at @buf to accommodate the bitmap_print_to_pagebuf() output. Returns the number of characters actually printed to @buf, excluding terminating '\\0'.",
        "proto" :"int (*bitmap_print_to_pagebuf)(bool list, char *buf, const unsigned long *maskp, int nmaskbits)",
        "pre": {
            "list": "is boolean",
            "buf": "!=null, page-aligned, has sufficient storage",
            "maskp": "!=null",
            "nmaskbits": "is integer, >=0"
        }
    }
},
{
    "kretprobe:bitmap_print_bitmask_to_buf": {
        "description": "Prints a bitmap to a buffer. If printing the whole bitmap as list by parts, user must ensure the order of calls of the function such that the offset is incremented linearly. User must also keep bitmap unchanged between the very first and very last call. Otherwise concatenated result may be incorrect, and format may be broken. Returns the number of characters actually printed to @buf.",
        "proto" :"int (*bitmap_print_bitmask_to_buf)(char *buf, const unsigned long *maskp, int nmaskbits, loff_t off, size_t count)",
        "pre": {
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": ">=0",
            "off": ">=0",
            "count": ">=0"
        },
    }
},
{
    "kprobe:bitmap_print_bitmask_to_buf": {
        "description": "Prints a bitmap to a buffer. If printing the whole bitmap as list by parts, user must ensure the order of calls of the function such that the offset is incremented linearly. User must also keep bitmap unchanged between the very first and very last call. Otherwise, concatenated result may be incorrect, and format may be broken. Returns the number of characters actually printed to @buf.",
        "proto" :"int (*bitmap_print_bitmask_to_buf)(char *buf, const unsigned long *maskp, int nmaskbits, loff_t off, size_t count)",
        "pre": {
            "buf": "!=null",
            "maskp": "!=null",
            "nmaskbits": ">=0",
            "off": ">=0",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap. Wrapper for bitmap_parselist(), providing it with user buffer.",
        "proto" :"int (*bitmap_parselist_user)(const char __user *ubuf, unsigned int ulen, unsigned long *maskp, int nmaskbits)",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0"
        },
    }
},
{
    "kprobe:bitmap_parselist_user": {
        "description": "Convert user buffer's list format ASCII string to bitmap.",
        "proto" :"int (*bitmap_parselist_user)(const char __user *ubuf, unsigned int ulen, unsigned long *maskp, int nmaskbits)",
        "pre": {
            "ubuf": "!=null",
            "ulen": ">=0",
            "maskp": "!=null",
            "nmaskbits": ">=0",
        },
    }
},
{
    "kretprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap. Let @old and @new define a mapping of bit positions, such that whatever position is held by the n-th set bit in @old is mapped to the n-th set bit in @new. If either of the @old and @new bitmaps are empty, or if @src and @dst point to the same location, then this routine copies @src to @dst. The positions of unset bits in @old are mapped to themselves (the identify map). Apply the above specified mapping to @src, placing the result in @dst, clearing any bits previously set in @dst.",
        "proto" :"void bitmap_remap(unsigned long *dst, const unsigned long *src, const unsigned long *old, const unsigned long *new, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_remap": {
        "description": "Apply map defined by a pair of bitmaps to another bitmap. Let @old and @new define a mapping of bit positions, such that whatever position is held by the n-th set bit in @old is mapped to the n-th set bit in @new. If either of the @old and @new bitmaps are empty, or if @src and @dst point to the same location, then this routine copies @src to @dst. The positions of unset bits in @old are mapped to themselves (the identify map). Apply the above specified mapping to @src, placing the result in @dst, clearing any bits previously set in @dst.",
        "proto" :"void bitmap_remap(unsigned long *dst, const unsigned long *src, const unsigned long *old, const unsigned long *new, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "old": "!=null",
            "new": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit. The positions of unset bits in @old are mapped to themselves (the identify map). Apply the above specified mapping to bit position @oldbit, returning the new bit position.",
        "proto" :"int bitmap_bitremap(int oldbit, const unsigned long *old, const unsigned long *new, int bits)",
        "pre": {
            "oldbit": ">=0",
            "old": "!=null",
            "new": "!=null",
            "bits": ">0"
        },
    }
},
{
    "kprobe:bitmap_bitremap": {
        "description": "Apply map defined by a pair of bitmaps to a single bit. The positions of unset bits in @old are mapped to themselves (the identify map). Apply the above specified mapping to bit position @oldbit, returning the new bit position.",
        "proto" :"int (*bitmap_bitremap)(int oldbit, const unsigned long *old, const unsigned long *new, int bits)",
        "pre": {
            "oldbit": ">=0",
            "old": "!=null",
            "new": "!=null",
            "bits": ">0",
        },
    }
},
{
    "kretprobe:bitmap_find_free_region": {
        "description": "Find a region of free (zero) bits in a @bitmap of @bits bits and allocate them (set them to one). Only consider regions of length a power (@order) of two, aligned to that power of two, which makes the search algorithm much faster. Return the bit offset in bitmap of the allocated region, or -errno on failure.",
        "proto" :"int bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order)",
        "pre": {
            "bitmap": "!=null",
            "bits": ">0",
            "order": ">=0"
        },
        "post": {
            "return": "in [0, bits-1] or <0"
        }
    }
},
{
    "kprobe:bitmap_find_free_region": {
        "description": "Find a region of free (zero) bits in a @bitmap of @bits bits and allocate them (set them to one). Only consider regions of length a power (@order) of two, aligned to that power of two, which makes the search algorithm much faster. Return the bit offset in bitmap of the allocated region, or -errno on failure.",
        "proto" :"int (*bitmap_find_free_region)(unsigned long *bitmap, unsigned int bits, int order)",
        "pre": {
            "bitmap": "!=null",
            "bits": ">0",
            "order": ">=0"
        },
    }
},
{
    "kretprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region. This is the complement to __bitmap_find_free_region() and releases the found region (by clearing it in the bitmap).",
        "proto" :"void (*bitmap_release_region)(unsigned long *bitmap, unsigned int pos, int order)",
        "pre": {
            "bitmap": "!=null",
            "pos": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kprobe:bitmap_release_region": {
        "description": "Release allocated bitmap region. This is the complement to __bitmap_find_free_region() and releases the found region (by clearing it in the bitmap).",
        "proto" :"void (*bitmap_release_region)(unsigned long *bitmap, unsigned int pos, int order)",
        "pre": {
            "bitmap": "!=null",
            "pos": ">=0",
            "order": ">=0",
        },
    }
},
{
    "kretprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap. Return 0 on success, or %-EBUSY if specified region wasn't free (not all bits were zero).",
        "proto" :"int (*bitmap_allocate_region)(unsigned long *bitmap, unsigned int pos, int order)",
        "pre": {
            "bitmap": "!=null",
            "pos": ">=0",
            "order": ">=0"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:bitmap_allocate_region": {
        "description": "Allocate (set bits in) a specified region of a bitmap. Return 0 on success, or %-EBUSY if specified region wasn't free (not all bits were zero).",
        "proto" :"int (*bitmap_allocate_region)(unsigned long *bitmap, unsigned int pos, int order)",
        "pre": {
            "bitmap": "!=null",
            "pos": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "proto" :"#ifdef __BIG_ENDIAN void bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": ">=0 && nbits % BITS_PER_LONG == 0"
        }
    }
},
{
    "kprobe:bitmap_copy_le": {
        "description": "Copy a bitmap, putting the bits into little-endian order.",
        "proto" :"#ifdef __BIG_ENDIAN void bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "nbits": ">=0 && nbits % BITS_PER_LONG == 0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap. @bitmap: array of unsigned longs, the destination bitmap. @buf: array of u32 (in host byte order), the source bitmap. @nbits: number of bits in @bitmap.",
        "proto" :"void (*bitmap_from_arr32)(unsigned long *bitmap, const u32 *buf, unsigned int nbits)",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr32": {
        "description": "Copy the contents of u32 array of bits to bitmap.",
        "proto" :"void (*bitmap_from_arr32)(unsigned long *bitmap, const u32 *buf, unsigned int nbits)",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits. @buf: array of u32 (in host byte order), the dest bitmap. @bitmap: array of unsigned longs, the source bitmap. @nbits: number of bits in @bitmap.",
        "proto" :"void (*bitmap_to_arr32)(u32 *buf, const unsigned long *bitmap, unsigned int nbits)",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr32": {
        "description": "Copy the contents of bitmap to a u32 array of bits. @buf: array of u32 (in host byte order), the dest bitmap. @bitmap: array of unsigned longs, the source bitmap. @nbits: number of bits in @bitmap.",
        "proto" :"void (*bitmap_to_arr32)(u32 *buf, const unsigned long *bitmap, unsigned int nbits)",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap. @bitmap: array of unsigned longs, the destination bitmap. @buf: array of u64 (in host byte order), the source bitmap. @nbits: number of bits in @bitmap.",
        "proto" :"void (*bitmap_from_arr64)(unsigned long *bitmap, const u64 *buf, unsigned int nbits)",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_from_arr64": {
        "description": "Copy the contents of u64 array of bits to bitmap.",
        "proto": "void (*bitmap_from_arr64)(unsigned long *bitmap, const u64 *buf, unsigned int nbits)",
        "pre": {
            "bitmap": "!=null",
            "buf": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "proto" :"void (*bitmap_to_arr64)(u64 *buf, const unsigned long *bitmap, unsigned int nbits)",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kprobe:bitmap_to_arr64": {
        "description": "Copy the contents of bitmap to a u64 array of bits.",
        "proto" :"void (*bitmap_to_arr64)(u64 *buf, const unsigned long *bitmap, unsigned int nbits)",
        "pre": {
            "buf": "!=null",
            "bitmap": "!=null",
            "nbits": ">=0"
        }
    }
},
{
    "kretprobe:sg_split": {
        "description": "This function splits the input sg list into nb_splits sg lists, which are allocated and stored into out. The @in is split into : - @out[0], which covers bytes [@skip .. @skip + @split_sizes[0] - 1] of @in - @out[1], which covers bytes [@skip + split_sizes[0] .. @skip + @split_sizes[0] + @split_sizes[1] -1] etc ... It will be the caller's duty to kfree() out array members. Returns 0 upon success, or error code",
        "proto" :"int sg_split(struct scatterlist *in, const int in_mapped_nents, const off_t skip, const int nb_splits, const size_t *split_sizes, struct scatterlist **out, int *out_mapped_nents, gfp_t gfp_mask)",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": "!=null || in_mapped_nents==0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:sg_split": {
        "description": "This function splits the input sg list into nb_splits sg lists, which are allocated and stored into out.",
        "proto" :"int sg_split(struct scatterlist *in, const int in_mapped_nents, const off_t skip, const int nb_splits, const size_t *split_sizes, struct scatterlist **out, int *out_mapped_nents, gfp_t gfp_mask)",
        "pre": {
            "in": "!=null",
            "in_mapped_nents": ">=0",
            "skip": ">=0",
            "nb_splits": ">0",
            "split_sizes": "!=null",
            "out": "!=null",
            "out_mapped_nents": "can be null or >=0",
            "gfp_mask": "valid gfp_t value"
        },
    }
},
{
    "kprobe:minmax_running_max": {
        "description": "Find the running maximum of a minmax structure.",
        "proto" :"static struct minmax_sample (*minmax_running_max)(struct minmax *m, u32 win, u32 t, u32 meas)",
        "pre": {
            "m": "!=null",
            "win": "is a positive integer",
            "t": "is a positive integer",
            "meas": "is a positive integer"
        },
    }
},
{
    "kretprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map. @size: Number of objects to be mapped. @flags: Allocation flags e.g. %GFP_KERNEL.",
        "proto" :"struct cpu_rmap *(*alloc_cpu_rmap)(unsigned int size, gfp_t flags)",
        "pre": {
            "size": ">=0",
            "flags": "in [%GFP_KERNEL, %GFP_ATOMIC, %GFP_NOWAIT, %GFP_HIGHUSER, %GFP_IO, %GFP_FS, %GFP_WAIT, %GFP_DMA, %GFP_HIGHUSER_MOVABLE, %GFP_NOIO, %GFP_NOFS, %GFP_USER, %GFP_DMA32, %GFP_HARDWALL, %GFP_HIGHMEM, %GFP_DIRECT_RECLAIM, %GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:alloc_cpu_rmap": {
        "description": "Allocate CPU affinity reverse-map. @size: Number of objects to be mapped. @flags: Allocation flags e.g. %GFP_KERNEL",
        "proto" :"struct cpu_rmap *(*alloc_cpu_rmap)(unsigned int size, gfp_t flags)",
        "pre": {
            "size": ">=0",
            "flags": "in [%GFP_KERNEL, %GFP_NOWAIT, %GFP_ATOMIC, %GFP_NOIO, %GFP_NOFS, %GFP_USER, %GFP_DMA, %GFP_HIGHUSER, %GFP_HIGHUSER_MOVABLE, %GFP_MEMLIGHT, %GFP_HARDWALL, %GFP_THISNODE, %GFP_ACCOUNT, %GFP_NOTRACK, %GFP_NO_KSWAPD, %GFP_OTHER_ACCOUNT, %GFP_WRITE, %GFP_NOWARN, %GFP_RETRY_MAYFAIL, %GFP_NO_GFP_WAIT, %GFP_MEMALLOC_NOIO, %GFP_NORETRY, %GFP_MEMALLOC_NFS, %GFP_KSWAPD_RECLAIM]",
        },
    }
},
{
    "kretprobe:cpu_rmap_put": {
        "description": "Release ref on a cpu_rmap @rmap: reverse-map allocated with alloc_cpu_rmap()",
        "proto" :"int (*cpu_rmap_put)(struct cpu_rmap *rmap)",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_put": {
        "description": "Release ref on a cpu_rmap",
        "proto": "int (*cpu_rmap_put)(struct cpu_rmap *rmap)",
        "pre": {
            "rmap": "!=null"
        }
    }
},
{
    "kretprobe:cpu_rmap_add": {
        "description": "Add object to a rmap. Return index of object or -ENOSPC if no free entry was found.",
        "proto" :"int (*cpu_rmap_add)(struct cpu_rmap *rmap, void *obj)",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
        "post": {
            "return": ">=0 || ==-ENOSPC"
        }
    }
},
{
    "kprobe:cpu_rmap_add": {
        "description": "Add object to a rmap. Return index of object or -ENOSPC if no free entry was found.",
        "proto" :"int cpu_rmap_add(struct cpu_rmap *rmap, void *obj)",
        "pre": {
            "rmap": "!=null",
            "obj": "!=null"
        },
    }
},
{
    "kretprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "proto": "int (*cpu_rmap_update)(struct cpu_rmap *rmap, u16 index, const struct cpumask *affinity)",
        "pre": {
            "rmap": "!=null",
            "index": ">=0",
            "affinity": "!=null"
        }
    }
},
{
    "kprobe:cpu_rmap_update": {
        "description": "Update CPU rmap following a change of object affinity",
        "proto" :"int (*cpu_rmap_update)(struct cpu_rmap *rmap, u16 index, const struct cpumask *affinity)",
        "pre": {
            "rmap": "!=null",
            "index": "is u16",
            "affinity": "!=null"
        }
    }
},
{
    "kretprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs. Must be called in process context, before freeing the IRQs.",
        "proto" :"void (*free_irq_cpu_rmap)(struct cpu_rmap *rmap)",
        "pre": {
            "rmap": "in [allocated with alloc_irq_cpu_map(), %NULL]"
        }
    }
},
{
    "kprobe:free_irq_cpu_rmap": {
        "description": "Free a CPU affinity reverse-map used for IRQs. Must be called in process context, before freeing the IRQs.",
        "proto" :"void (*free_irq_cpu_rmap)(struct cpu_rmap *rmap)",
        "pre": {
            "rmap": "!=null || ==null"
        },
    }
},
{
    "kretprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map",
        "proto": "int (*irq_cpu_rmap_remove)(struct cpu_rmap *rmap, int irq)",
        "pre": {
            "rmap": "!=null",
            "irq": ">=0"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_remove": {
        "description": "Remove an IRQ from a CPU affinity reverse-map",
        "proto" :"int (*irq_cpu_rmap_remove)(struct cpu_rmap *rmap, int irq)",
        "pre": {
            "rmap": "!=null",
            "irq": ">=0",
        },
    }
},
{
    "kretprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map. This adds an IRQ affinity notifier that will update the reverse-map automatically. Must be called in process context, after the IRQ is allocated but before it is bound with request_irq().",
        "proto" :"int (*irq_cpu_rmap_add)(struct cpu_rmap *rmap, int irq)",
        "pre": {
            "rmap": "!=null",
            "irq": ">=0"
        }
    }
},
{
    "kprobe:irq_cpu_rmap_add": {
        "description": "Add an IRQ to a CPU affinity reverse-map. This adds an IRQ affinity notifier that will update the reverse-map automatically. Must be called in process context, after the IRQ is allocated but before it is bound with request_irq().",
        "proto" :"int (*irq_cpu_rmap_add)(struct cpu_rmap *rmap, int irq)",
        "pre": {
            "rmap": "!=null",
            "irq": ">=0"
        }
    }
},
{
    "kretprobe:___ratelimit": {
        "description": "Paired with WRITE_ONCE() in .proc_handler(). Changing two values separately could be inconsistent and some message could be lost. (See: net_ratelimit_state).",
        "proto" :"___ratelimit(struct ratelimit_state *rs, const char *func)",
        "pre": {
            "rs": "!=null",
            "func": "!=null"
        }
    }
},

{
    "kretprobe:string_get_size": {
        "description": "Get the size in the specified units. The function returns a string formatted to 3 significant figures giving the size in the required units. @buf should have room for at least 9 bytes and will always be zero terminated.",
        "proto" :"void (*string_get_size)(u64 size, u64 blk_size, const enum string_size_units units, char *buf, int len)",
        "pre": {
            "size": ">=0",
            "blk_size": ">0",
            "units": "in [STRING_SIZE_UNITS_1000, STRING_SIZE_UNITS_1024]",
            "buf": "!=null",
            "len": ">=9"
        }
    }
},
{
    "kprobe:string_get_size": {
        "description": "Get the size in the specified units. This function returns a string formatted to 3 significant figures giving the size in the required units. @buf should have room for at least 9 bytes and will always be zero terminated.",
        "proto" :"void (*string_get_size)(u64 size, u64 blk_size, const enum string_size_units units, char *buf, int len)",
        "pre": {
            "size": ">=0",
            "blk_size": ">0",
            "units": "in [STRING_SIZE_UNITS_1000, STRING_SIZE_UNITS_1024]",
            "buf": "!=null && len(buf) >= 9",
            "len": ">=9",
        },
    }
},
{
    "kretprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers. On success, @array is allocated and initialized with a sequence of integers extracted from the @from plus an additional element that begins the sequence and specifies the integers count. Caller takes responsibility for freeing @array when it is no longer needed.",
        "proto" :"int (*parse_int_array_user)(const char __user *from, size_t count, int **array)",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT]",
            "array": "!=null"
        }
    }
},
{
    "kprobe:parse_int_array_user": {
        "description": "Split string into a sequence of integers. On success, @array is allocated and initialized with a sequence of integers extracted from the @from plus an additional element that begins the sequence and specifies the integers count. Caller takes responsibility for freeing @array when it is no longer needed.",
        "proto" :"int (*parse_int_array_user)(const char __user *from, size_t count, int **array)",
        "pre": {
            "from": "!=null",
            "count": ">=0",
            "array": "!=null"
        },
    }
},
{
    "kretprobe:string_unescape": {
        "description": "The function unquotes characters in the given string. Because the size of the output will be the same as or less than the size of the input, the transformation may be performed in place. Caller must provide valid source and destination pointers. Be aware that destination buffer will always be NULL-terminated. Source string must be NULL-terminated as well. The supported flags are: UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY.",
        "proto" :"int (*string_unescape)(char *src, char *dst, size_t size, unsigned int flags)",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": "in [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
    }
},
{
    "kprobe:string_unescape": {
        "description": "The function unquotes characters in the given string. Because the size of the output will be the same as or less than the size of the input, the transformation may be performed in place. Caller must provide valid source and destination pointers. Be aware that destination buffer will always be NULL-terminated. Source string must be NULL-terminated as well. The supported flags are: UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY.",
        "proto" :"int (*string_unescape)(char *src, char *dst, size_t size, unsigned int flags)",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "size": ">=0",
            "flags": "in [UNESCAPE_SPACE, UNESCAPE_OCTAL, UNESCAPE_HEX, UNESCAPE_SPECIAL, UNESCAPE_ANY]"
        },
    }
},
{
    "kretprobe:string_escape_mem": {
        "description": "Quote characters in the given memory buffer. The process of escaping byte buffer includes several parts. They are applied in the following sequence. The character is not matched to the one from @only string and thus must go as-is to the output. The character is matched to the printable and ASCII classes, if asked, and in case of match it passes through to the output. The character is matched to the printable or ASCII class, if asked, and in case of match it passes through to the output. The character is checked if it falls into the class given by @flags. %ESCAPE_OCTAL and %ESCAPE_HEX are going last since they cover any character. Note that they actually can't go together, otherwise %ESCAPE_HEX will be ignored. Caller must provide valid source and destination pointers. Be aware that destination buffer will not be NULL-terminated, thus caller have to append it if needs. The supported flags are listed in the helper doc.",
        "proto" :"int string_escape_mem(const char *src, size_t isz, char *dst, size_t osz, unsigned int flags, const char *only)",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": "in [%ESCAPE_SPACE, %ESCAPE_SPECIAL, %ESCAPE_NULL, %ESCAPE_OCTAL, %ESCAPE_ANY, %ESCAPE_NP, %ESCAPE_ANY_NP, %ESCAPE_HEX, %ESCAPE_NA, %ESCAPE_NAP, %ESCAPE_APPEND]",
            "only": "can be null"
        }
    }
},
{
    "kprobe:string_escape_mem": {
        "description": "Quote characters in the given memory buffer. The process of escaping byte buffer includes several parts. They are applied in the following sequence. The character is not matched to the one from @only string and thus must go as-is to the output. The character is matched to the printable and ASCII classes, if asked, and in case of match it passes through to the output. The character is matched to the printable or ASCII class, if asked, and in case of match it passes through to the output. The character is checked if it falls into the class given by @flags. %ESCAPE_OCTAL and %ESCAPE_HEX are going last since they cover any character. Note that they actually can't go together, otherwise %ESCAPE_HEX will be ignored. Caller must provide valid source and destination pointers. Be aware that destination buffer will not be NULL-terminated, thus caller have to append it if needs. The supported flags are listed in the helper doc.",
        "proto" :"int string_escape_mem(const char *src, size_t isz, char *dst, size_t osz, unsigned int flags, const char *only)",
        "pre": {
            "src": "!=null",
            "isz": ">=0",
            "dst": "!=null",
            "osz": ">=0",
            "flags": "in [%ESCAPE_SPACE, %ESCAPE_SPECIAL, %ESCAPE_NULL, %ESCAPE_OCTAL, %ESCAPE_ANY, %ESCAPE_NP, %ESCAPE_ANY_NP, %ESCAPE_HEX, %ESCAPE_NA, %ESCAPE_NAP, %ESCAPE_APPEND]",
            "only": "can be null or non-null"
        }
    }
},
{
    "kretprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer. If the source string is shorter than the destination buffer, zeros the tail of the destination buffer. The behavior is undefined if the string buffers overlap. The destination buffer is always %NUL terminated, unless it's zero-sized. Returns the number of characters copied (not including the trailing %NUL) or -E2BIG if count is 0 or @src was truncated.",
        "proto" :"ssize_t (*strscpy_pad)(char *dest, const char *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">0"
        },
    }
},
{
    "kprobe:strscpy_pad": {
        "description": "Copy a C-string into a sized buffer. If the source string is shorter than the destination buffer, zeros the tail of the destination buffer. The behavior is undefined if the string buffers overlap. The destination buffer is always %NUL terminated, unless it's zero-sized. Returns the number of characters copied (not including the trailing %NUL) or -E2BIG if count is 0 or @src was truncated.",
        "proto" :"ssize_t (*strscpy_pad)(char *dest, const char *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">0",
            "overlap": "dest and src do not overlap"
        },
    }
},
{
    "kretprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str. Returns a pointer to the first non-whitespace character in @str.",
        "proto" :"char *(*skip_spaces)(const char *str)",
        "pre": {
            "str": "!=null"
        },
        "post": {
            "return": "!=null && points to first non-whitespace character in str"
        }
    }
},
{
    "kprobe:skip_spaces": {
        "description": "Removes leading whitespace from @str. Returns a pointer to the first non-whitespace character in @str.",
        "proto" :"char *(*skip_spaces)(const char *str)",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strim": {
        "description": "Removes leading and trailing whitespace from @s. @s: The string to be stripped. Note that the first trailing whitespace is replaced with a %NUL-terminator in the given string @s. Returns a pointer to the first non-whitespace character in @s.",
        "proto" :"char *(*strim)(char *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:strim": {
        "description": "Removes leading and trailing whitespace from @s. @s: The string to be stripped. Note that the first trailing whitespace is replaced with a %NUL-terminator in the given string @s. Returns a pointer to the first non-whitespace character in @s.",
        "proto" :"char *(*strim)(char *s)",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline. This routine returns true iff two strings are equal, treating both NUL and newline-then-NUL as equivalent string terminations. It's geared for use with sysfs input strings, which generally terminate with newlines but are compared against values without newlines.",
        "proto" :"bool (*sysfs_streq)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:sysfs_streq": {
        "description": "Return true if strings are equal, modulo trailing newline. This routine returns true iff two strings are equal, treating both NUL and newline-then-NUL as equivalent string terminations. It's geared for use with sysfs input strings, which generally terminate with newlines but are compared against values without newlines.",
        "proto" :"bool (*sysfs_streq)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:match_string": {
        "description": "Matches given string in an array. This routine will look for a string in an array of strings up to the n-th element in the array or until the first NULL element. Historically the value of -1 for @n, was used to search in arrays that are NULL terminated. However, the function does not make a distinction when finishing the search: either @n elements have been compared OR the first NULL element was found.",
        "proto" :"int (*match_string)(const char * const *array, size_t n, const char *string)",
        "pre": {
            "array": "!=null",
            "n": ">=-1",
            "string": "!=null"
        },
        "post": {
            "return": "in [0, n-1] or ==-EINVAL"
        }
    }
},
{
    "kprobe:match_string": {
        "description": "Matches given string in an array. This routine will look for a string in an array of strings up to the n-th element in the array or until the first NULL element. Historically the value of -1 for @n, was used to search in arrays that are NULL terminated. However, the function does not make a distinction when finishing the search: either @n elements have been compared OR the first NULL element was found. Returns index of a @string in the @array if matches, or %-EINVAL otherwise.",
        "proto" :"int (*match_string)(const char * const *array, size_t n, const char *string)",
        "pre": {
            "array": "!=null",
            "n": ">=-1",
            "string": "!=null"
        },
    }
},
{
    "kretprobe:__sysfs_match_string": {
        "description": "Matches given string in an array. Returns index of @str in the @array or -EINVAL, just like match_string(). Uses sysfs_streq instead of strcmp for matching. This routine will look for a string in an array of strings up to the n-th element in the array or until the first NULL element. Historically the value of -1 for @n, was used to search in arrays that are NULL terminated. However, the function does not make a distinction when finishing the search: either @n elements have been compared OR the first NULL element was found.",
        "proto" :"int (*__sysfs_match_string)(const char * const *array, size_t n, const char *str)",
        "pre": {
            "array": "!=null",
            "n": ">=-1",
            "str": "!=null"
        }
    }
},
{
    "kprobe:__sysfs_match_string": {
        "description": "Matches given string in an array. Returns index of @str in the @array or -EINVAL, just like match_string(). Uses sysfs_streq instead of strcmp for matching. This routine will look for a string in an array of strings up to the n-th element in the array or until the first NULL element. Historically the value of -1 for @n, was used to search in arrays that are NULL terminated. However, the function does not make a distinction when finishing the search: either @n elements have been compared OR the first NULL element was found.",
        "proto" :"int (*__sysfs_match_string)(const char * const *array, size_t n, const char *str)",
        "pre": {
            "array": "!=null",
            "n": ">=-1",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:strreplace": {
        "description": "Replaces each @old character with a @new one in the given string @str. Returns pointer to the string @str itself.",
        "proto" :"char *(*strreplace)(char *str, char old, char new)",
        "pre": {
            "str": "!=null",
            "old": "is a valid character",
            "new": "is a valid character"
        },
        "post": {
            "return": "is a pointer to the string @str with all occurrences of @old replaced by @new"
        }
    }
},
{
    "kprobe:strreplace": {
        "description": "Replaces each @old character with a @new one in the given string @str. Returns pointer to the string @str itself.",
        "proto" :"char *(*strreplace)(char *str, char old, char new)",
        "pre": {
            "str": "!=null",
            "old": "is a valid character",
            "new": "is a valid character"
        }
    }
},
{
    "kretprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding. If space is left in destination, it is filled with the pad character.",
        "proto" :"void (*memcpy_and_pad)(void *dest, size_t dest_len, const void *src, size_t count, int pad)",
        "pre": {
            "dest": "!=null",
            "dest_len": ">0",
            "src": "!=null",
            "count": ">=0 && <=dest_len",
            "pad": "is int"
        },
    }
},
{
    "kprobe:memcpy_and_pad": {
        "description": "Copy one buffer to another with padding. If space is left in destination, it is filled with the padding character.",
        "proto" :"static void (*memcpy_and_pad)(void *dest, size_t dest_len, const void *src, size_t count, int pad)",
        "pre": {
            "dest": "!=null",
            "dest_len": ">0",
            "src": "!=null",
            "count": ">=0 && <=dest_len",
            "pad": "is int"
        },
    }
},
{
    "kretprobe:kstrtoull": {
        "description": "Convert a string to an unsigned long long. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign, but not a minus sign. The number base to use is given as an argument. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.",
        "proto" :"noinline int kstrtoull(const char *s, unsigned int base, unsigned long long *res)",
        "pre": {
            "s": "!=null && (s[0] == '+' || (s[0] >= '0' && s[0] <= '9')) && (s[strlen(s)-1] == '\0' || (s[strlen(s)-1] == '\n' && s[strlen(s)] == '\0'))",
            "base": "in [0, 16]",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoull": {
        "description": "Convert a string to an unsigned long long. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign, but not a minus sign. The base of the string is automatically detected with the conventional semantics. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtoull(). Return code must be checked.",
        "proto" :"noinline int kstrtoull(const char *s, unsigned int base, unsigned long long *res)",
        "pre": {
            "s": "!=null && (s[0] == '+' || (s[0] >= '0' && s[0] <= '9')) && (s[strlen(s)-1] == '\0' || (s[strlen(s)-1] == '\n' && s[strlen(s)] == '\0'))",
            "base": "in [0, 16]",
            "res": "!=null",
        },
    }
},
{
    "kretprobe:kstrtoll": {
        "description": "Convert a string to a long long. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign or a minus sign. The number base to use. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Where to write the result of the conversion on success. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtoll(). Return code must be checked.",
        "proto" :"noinlineint kstrtoll(const char *s, unsigned int base, long long *res)",
        "pre": {
            "s": "!=null && (s[0] in ['-', '+'] || (s[0] == '0' && (s[1] in ['x', 'X'] || s[1] in ['0'-'7'])) || s[0] in ['1'-'9'])",
            "base": "in [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]",
            "res": "!=null"
        },
    }
},
{
    "kprobe:kstrtoll": {
        "description": "Convert a string to a long long. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign or a minus sign. The number base to use. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Where to write the result of the conversion on success. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtoll(). Return code must be checked.",
        "proto" :"noinline int kstrtoll(const char *s, unsigned int base, long long *res)",
        "pre": {
            "s": "!=null && (s[0] in ['-', '+'] || (s[0] == '0' && (s[1] == 'x' || s[1] == 'X' || s[1] in ['0'-'9'])) || s[0] in ['1'-'9'])",
            "base": "in [0, 16]",
            "res": "!=null"
        },
    }
},
{
    "kretprobe:kstrtouint": {
        "description": "Convert a string to an unsigned int. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign, but not a minus sign. The base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.",
        "proto" :"noinlineint kstrtouint(const char *s, unsigned int base, unsigned int *res)",
        "pre": {
            "s": "!=null && regex(^[+]?[0-9a-fA-F]*\\n?$)",
            "base": "in [0, 16]",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtouint": {
        "description": "Convert a string to an unsigned int. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign, but not a minus sign. The number base to use. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Where to write the result of the conversion on success. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtoul(). Return code must be checked.",
        "proto" :"noinlineint kstrtouint(const char *s, unsigned int base, unsigned int *res)",
        "pre": {
            "s": "!=null && regex(^[+]?[0-9a-fA-F]*\\n?$)",
            "base": "in [0, 16]",
            "res": "!=null",
        },
    }
},
{
    "kretprobe:kstrtoint": {
        "description": "Convert a string to an int. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign or a minus sign. The number base to use. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Where to write the result of the conversion on success. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtol(). Return code must be checked.",
        "proto" :"noinlineint kstrtoint(const char *s, unsigned int base, int *res)",
        "pre": {
            "s": "!=null",
            "base": "in [0, 16]",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -ERANGE, -EINVAL]"
        }
    }
},
{
    "kprobe:kstrtoint": {
        "description": "Convert a string to an int. The string must be null-terminated, and may also include a single newline before its terminating null. The first character may also be a plus sign or a minus sign. The number base to use. The maximum supported base is 16. If base is given as 0, then the base of the string is automatically detected with the conventional semantics - If it begins with 0x the number will be parsed as a hexadecimal (case insensitive), if it otherwise begins with 0, it will be parsed as an octal number. Otherwise it will be parsed as a decimal. Where to write the result of the conversion on success. Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error. Preferred over simple_strtol(). Return code must be checked.",
        "proto" :"noinlineint kstrtoint(const char *s, unsigned int base, int *res)",
        "pre": {
            "s": "!=null",
            "base": "in [0, 16]",
            "res": "!=null"
        },
    }
},
{
    "kretprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values. This routine returns 0 iff the first character is one of 'YyTt1NnFf0', or [oO][NnFf] for 'on' and 'off'. Otherwise it will return -EINVAL. Value pointed to by res is updated upon finding a match.",
        "proto" :"noinlineint kstrtobool(const char *s, bool *res)",
        "pre": {
            "s": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]",
            "res": "in [true, false]"
        }
    }
},
{
    "kprobe:kstrtobool": {
        "description": "Convert common user inputs into boolean values. This routine returns 0 iff the first character is one of 'YyTt1NnFf0', or [oO][NnFf] for 'on' and 'off'. Otherwise it will return -EINVAL. Value pointed to by res is updated upon finding a match.",
        "proto" :"noinlineint (*kstrtobool)(const char *s, bool *res)",
        "pre": {
            "s": "!=null",
            "res": "!=null",
            "s[0]": "in ['Y', 'y', 'T', 't', '1', 'N', 'n', 'F', 'f', '0', 'o', 'O', 'n', 'N', 'f', 'F']"
        },
    }
},
{
    "kretprobe:kstrtobool_from_user": {
        "description": "Converts a string in user space to a boolean value. Returns 0 if conversion is successful, and -EFAULT if there was an error copying the string from user space.",
        "proto" :"int kstrtobool_from_user(const char __user *s, size_t count, bool *res)",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        },
        "post": {
            "return": "in [-EFAULT, 0]"
        }
    }
},
{
    "kprobe:kstrtobool_from_user": {
        "description": "Longest string needed to differentiate, newline, terminator",
        "proto" :"kstrtobool_from_user(const char __user *s, size_t count, bool *res)",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign '-'. Radix 0 means autodetection: leading '0x' implies radix 16, leading '0' implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "proto" :"noinlineconst char *_parse_integer_fixup_radix(const char *s, unsigned int *base)",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        },
    }
},
{
    "kprobe:_parse_integer_fixup_radix": {
        "description": "Convert integer string representation to an integer. If an integer doesn't fit into specified type, -E is returned. Integer starts with optional sign. kstrtou () functions do not accept sign '-'. Radix 0 means autodetection: leading '0x' implies radix 16, leading '0' implies radix 8, otherwise radix is 10. Autodetection hints work after optional sign, but not before. If -E is returned, result is not touched.",
        "proto" :"noinlineconst char *(*_parse_integer_fixup_radix)(const char *s, unsigned int *base)",
        "pre": {
            "s": "!=null",
            "base": "!=null"
        },
    }
},
{
    "kretprobe:_find_first_bit": {
        "description": "Finds the first bit set (beginning with the least significant bit) in the memory area pointed to by addr that is not zero.",
        "proto" :"static long (*_find_first_bit)(const unsigned long *addr, unsigned long size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "_find_first_bit": {
        "description": "Finds the first bit set (beginning with the least significant bit) in the given address range.",
        "proto" :"static long (*_find_first_bit)(const unsigned long *addr, unsigned long size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:_find_first_and_bit": {
        "description": "Finds the first bit set in the intersection of two bitmaps.",
        "proto" :"static long (*_find_first_and_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long size)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:_find_first_and_bit": {
        "description": "Find the first set bit in the bitwise AND of two bitmaps.",
        "proto" :"static long (*_find_first_and_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long size)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "size": ">0",
        },
    }
},


{
    "kretprobe:_find_next_bit": {
        "description": "Find the next set bit in a memory region starting from a given bit position.",
        "proto": "unsigned long (*_find_next_bit)(const unsigned long *addr, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr": "!=null",
            "nbits": ">=0",
            "start": "<=nbits"
        },
        "post": {
            "return": ">=start && <=nbits"
        }
    }
},
{
    "kprobe:_find_next_bit": {
        "description": "Find the next set bit in a memory region.",
        "proto" :"static long (*_find_next_bit)(const unsigned long *addr, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits",
        },
    }
},
{
    "kretprobe:_find_next_and_bit": {
        "description": "Find the next set bit in the intersection of two bitmaps starting from a given position.",
        "proto" :"static long (*_find_next_and_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits"
        },
    }
},
{
    "kprobe:_find_next_and_bit": {
        "description": "Find the next set bit in the logical AND of two bitmaps that is set to 1, starting from a certain position.",
        "proto" :"static long (*_find_next_and_bit)(const unsigned long *addr1, const unsigned long *addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits"
        }
    }
},
{
    "kretprobe:_find_next_andnot_bit": {
        "description": "Find the next set bit in a memory region that is not set in another memory region.",
        "proto" :"static long (*_find_next_andnot_bit)(const unsigned long *addr1, const unsigned long *addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits",
        },
    }
},
{
    "kprobe:_find_next_andnot_bit": {
        "description": "Please fill in the correct description here",
        "proto" :"static long (*_find_next_andnot_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "Please fill in the correct precondition here",
            "addr2": "Please fill in the correct precondition here",
            "nbits": "Please fill in the correct precondition here",
            "start": "Please fill in the correct precondition here"
        },
    }
},
{
    "kretprobe:_find_next_or_bit": {
        "description": "Finds the next bit in the bitmaps addr1 or addr2 that is set, starting from bit number 'start'.",
        "proto" :"static long (*_find_next_or_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits",
        },
    }
},
{
    "kprobe:_find_next_or_bit": {
        "description": "Find the next set bit in a memory region.",
        "proto" :"static long (*_find_next_or_bit)(const unsigned long addr1, const unsigned long addr2, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits",
        },
    }
},
{
    "kretprobe:_find_next_zero_bit": {
        "description": "Find the next zero bit in a bit array *addr* starting from the bit *start* up to *nbits*.",
        "proto" :"static long (*_find_next_zero_bit)(const unsigned long *addr, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits"
        }
    }
},
{
    "kprobe:_find_next_zero_bit": {
        "description": "Find the next zero bit in the given address starting from the specified start bit.",
        "proto" :"static long (*_find_next_zero_bit)(const unsigned long addr, unsigned long nbits, unsigned long start)",
        "pre": {
            "addr": "!=null",
            "nbits": ">=0",
            "start": ">=0 && <nbits",
        },
    }
},
{
    "kretprobe:mac_pton": {
        "description": "Converts a string in the format of XX:XX:XX:XX:XX:XX to a byte array.",
        "proto" :"static int (*mac_pton)(const char *s, u8 *mac)",
        "pre": {
            "s": "!=null && strnlen(s, 3 * ETH_ALEN - 1) == 3 * ETH_ALEN - 1",
            "mac": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:mac_pton": {
        "description": "Converts a string in the form of XX:XX:XX:XX:XX:XX to a MAC address.",
        "proto" :"static bool (*mac_pton)(const char *s, u8 *mac)",
        "pre": {
            "s": "!=null",
            "mac": "!=null",
            "maxlen": "==17",
            "i": "in [0, 17]",
            "strnlen(s, maxlen)": "< maxlen"
        },
    }
},
{
    "kretprobe:fault_in_iov_iter_readable": {
        "description": "Fault in one or more iovecs of the given iov_iter, to a maximum length of @size. For each iovec, fault in each page that constitutes the iovec. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()). Always returns 0 for non-userspace iterators.",
        "proto" :"size_t (*fault_in_iov_iter_readable)(const struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kprobe:fault_in_iov_iter_readable": {
        "description": "Fault in one or more iovecs of the given iov_iter, to a maximum length of @size. For each iovec, fault in each page that constitutes the iovec. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()). Always returns 0 for non-userspace iterators.",
        "proto" :"size_t (*fault_in_iov_iter_readable)(const struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_iov_iter_writeable": {
        "description": "Faults in the iterator using get_user_pages(), i.e., without triggering hardware page faults. This is primarily useful when we already know that some or all of the pages in @i aren't in memory. Returns the number of bytes not faulted in, like copy_to_user() and copy_from_user(). Always returns 0 for non-user-space iterators.",
        "proto" :"size_t (*fault_in_iov_iter_writeable)(const struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kprobe:fault_in_iov_iter_writeable": {
        "description": "Faults in the iterator using get_user_pages(), i.e., without triggering hardware page faults. This is primarily useful when we already know that some or all of the pages in @i aren't in memory. Returns the number of bytes not faulted in, like copy_to_user() and copy_from_user(). Always returns 0 for non-user-space iterators.",
        "proto" :"size_t (*fault_in_iov_iter_writeable)(const struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_iovec_advance": {
        "description": "Advance the iterator 'i' by 'size' amount. If 'i' is of type iovec or kvec, the function will iterate over the segments until the size is less than the length of the current segment. The offset and number of segments in 'i' are updated accordingly.",
        "proto" :"static void (*iov_iter_iovec_advance)(struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_iovec_advance": {
        "description": "Advances the iovec iterator by the specified size.",
        "proto" :"static void (*iov_iter_iovec_advance)(struct iov_iter *i, size_t size)",
        "pre": {
            "i": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_revert": {
        "description": "Reverts the iov_iter structure by the specified unroll amount. If unroll is greater than MAX_RW_COUNT, a warning is issued and the function returns. If the iov_iter is discard type, the function returns. If unroll is less than or equal to iov_offset, iov_offset is reduced by unroll and the function returns. If the iov_iter is xarray type or ubuf type, a bug is triggered.",
        "proto" :"void (*iov_iter_revert)(struct iov_iter *i, size_t unroll)",
        "pre": {
            "i": "!=null",
            "unroll": "<= MAX_RW_COUNT"
        },
        "post": {
            "i->count": ">= unroll",
            "i->iov_offset": ">= 0"
        }
    }
},

{
    "kretprobe:iov_iter_xarray": {
        "description": "Set up an IO iterator to either draw data out of the pages attached to an inode or to inject data into those pages. The pages must be prevented from evaporation, either by taking a ref on them or locking them by the caller.",
        "proto" :"void iov_iter_xarray(struct iov_iter *i, unsigned int direction, struct xarray *xarray, loff_t start, size_t count)",
        "pre": {
            "i": "!=null",
            "direction": "is unsigned int",
            "xarray": "!=null",
            "start": "is loff_t",
            "count": "is size_t"
        }
    }
},
{
    "kprobe:iov_iter_xarray": {
        "description": "Initialise an IO iterator to use the pages in an xarray. Set up an IO iterator to either draw data out of the pages attached to an inode or to inject data into those pages. The pages must be prevented from evaporation, either by taking a ref on them or locking them by the caller.",
        "proto" :"void iov_iter_xarray(struct iov_iter *i, unsigned int direction, struct xarray *xarray, loff_t start, size_t count)",
        "pre": {
            "i": "!=null",
            "direction": "is unsigned int",
            "xarray": "!=null",
            "start": "is loff_t",
            "count": "is size_t"
        },
    }
},
{
    "kretprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data. Set up an IO iterator that just discards everything that's written to it. It's only available as a READ iterator.",
        "proto" :"void (*iov_iter_discard)(struct iov_iter *i, unsigned int direction, size_t count)",
        "pre": {
            "i": "!=null",
            "direction": "==READ",
            "count": ">=0"
        }
    }
},
{
    "kprobe:iov_iter_discard": {
        "description": "Initialise an IO iterator that discards data. Set up an IO iterator that just discards everything that's written to it. It's only available as a READ iterator.",
        "proto" :"void iov_iter_discard(struct iov_iter *i, unsigned int direction, size_t count)",
        "pre": {
            "i": "!=null",
            "direction": "==READ",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:iov_iter_alignment": {
        "description": "This function checks the type of iov_iter and calls the corresponding alignment function. If the iov_iter is of type ubuf, it calculates the alignment directly. If the iov_iter is of type iovec or kvec, it calls iov_iter_alignment_iovec. If the iov_iter is of type bvec, it calls iov_iter_alignment_bvec. If the iov_iter is of type xarray, it calculates the alignment directly. If none of these conditions are met, it returns 0.",
        "proto": "unsigned long iov_iter_alignment(const struct iov_iter  i)",
        "pre": {
            "i": "!=null"
        }
    },
    "kretprobe:iov_iter_alignment_iovec": {
        "description": "This function calculates the alignment for an iov_iter of type iovec or kvec.",
        "proto": "unsigned long iov_iter_alignment_iovec(const struct iov_iter  i)",
        "pre": {
            "i": "!=null"
        }
    },
    "kretprobe:iov_iter_alignment_bvec": {
        "description": "This function calculates the alignment for an iov_iter of type bvec.",
        "proto": "unsigned long iov_iter_alignment_bvec(const struct iov_iter  i)",
        "pre": {
            "i": "!=null"
        }
    }
},
{
    "kprobe:iov_iter_alignment": {
        "description": "This function checks the type of iov_iter and calls the appropriate alignment function.",
        "proto": "unsigned long iov_iter_alignment(const struct iov_iter  i)",
        "pre": {
            "i": "!=null"
        },
        "helpers": {
            "iov_iter_alignment_iovec": {
                "description": "This function calculates the alignment for iovec type iov_iter.",
                "proto": "unsigned long iov_iter_alignment_iovec(const struct iov_iter  i)",
                "pre": {
                    "i": "!=null"
                }
            },
            "iov_iter_alignment_bvec": {
                "description": "This function calculates the alignment for bvec type iov_iter.",
                "proto": "unsigned long iov_iter_alignment_bvec(const struct iov_iter  i)",
                "pre": {
                    "i": "!=null"
                }
            }
        }
    }
},

{
    "kprobe:iov_iter_npages": {
        "description": "Calculate the number of pages needed for the iov_iter. If the iov_iter is a user buffer, calculate the number of pages based on the offset and count. If the iov_iter is an iovec or kvec, return the number of pages needed. If the iov_iter is a bio_vec or xarray, return the number of pages needed.",
        "proto" :"int iov_iter_npages(const struct iov_iter *i, int maxpages)",
        "pre": {
            "i": "!=null",
            "maxpages": ">=0",
        },
    }
},
{
    "kretprobe:dup_iter": {
        "description": "Duplicates the iov_iter structure from *old* to *new* with *flags*. If iov_iter is bvec, it duplicates new->bvec. If iov_iter is kvec or iovec, it duplicates new->__iov.",
        "proto" :"static struct iov_iter (*dup_iter)(struct iov_iter new, struct iov_iter old, gfp_t flags)",
        "pre": {
            "new": "!=null",
            "old": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kprobe:dup_iter": {
        "description": "Duplicates the iov_iter structure. If the iov_iter is bvec, it duplicates the bvec. If the iov_iter is kvec or iovec, it duplicates the iovec.",
        "proto" :"static struct iov_iter (*dup_iter)(struct iov_iter new, struct iov_iter old, gfp_t flags)",
        "pre": {
            "new": "!=null",
            "old": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "__import_iovec": {
        "description": "Imports an iovec from user space.",
        "proto": "ssize_t __import_iovec(int type, const struct iovec __user  uvec, unsigned nr_segs, unsigned fast_segs, struct iovec   iovp, struct iov_iter  i, bool compat)",
        "pre": {
            "type": "is integer",
            "uvec": "!=null",
            "nr_segs": "is unsigned integer",
            "fast_segs": "is unsigned integer",
            "iovp": "!=null",
            "i": "!=null",
            "compat": "is boolean"
        },
        "post": {
            "return": "in [0, MAX_RW_COUNT]"
        }
    }
},

{
    "kretprobe:dql_completed": {
        "description": "Can't complete more than what's in queue",
        "proto" :"dql_completed(struct dql *dql, unsigned int count)",
        "pre": {
            "dql": "!=null",
            "count": "<= dql->num_queued"
        },
        "post": {
            "completed": "== dql->num_completed + count",
            "limit": "== dql->limit",
            "ovlimit": "== POSDIFF(num_queued - dql->num_completed, limit)",
            "inprogress": "== num_queued - completed",
            "prev_inprogress": "== dql->prev_num_queued - dql->num_completed",
            "all_prev_completed": "== AFTER_EQ(completed, dql->prev_num_queued)",
            "condition": "== ((ovlimit && !inprogress) || (dql->prev_ovlimit && all_prev_completed))"
        }
    }
},
{
    "kprobe:dql_completed": {
        "description": "Can't complete more than what's in queue",
        "proto" :"dql_completed(struct dql  dql, unsigned int count)",
        "pre": {
            "dql": "!=null",
            "count": ">=0",
            "num_queued": ">=count",
            "limit": ">=0",
            "ovlimit": ">=0",
            "completed": ">=0",
            "inprogress": ">=0",
            "prev_inprogress": ">=0",
            "all_prev_completed": "in [true, false]"
        },
    }
},
{
    "kretprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "proto": "void (*dql_reset)(struct dql *dql)",
        "pre": {
            "dql": "!=null"
        },
        "post": {
            "dql->limit": "==0",
            "dql->num_queued": "==0",
            "dql->num_completed": "==0",
            "dql->last_obj_cnt": "==0",
            "dql->prev_num_queued": "==0",
            "dql->prev_last_obj_cnt": "==0",
            "dql->prev_ovlimit": "==0",
            "dql->lowest_slack": "==UINT_MAX",
            "dql->slack_start_time": "==jiffies"
        }
    }
},
{
    "kprobe:dql_reset": {
        "description": "Reset all dynamic values",
        "proto" :"void dql_reset(struct dql *dql)",
        "pre": {
            "dql": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap. @n: the cpu prior to the place to search. @mask: the cpumask pointer. @start: the start point of the iteration. @wrap: assume @n crossing @start terminates the iteration. Returns >= nr_cpu_ids on completion. Note: the @wrap argument is required for the start condition when we cannot assume @start is set in @mask.",
        "proto" :"unsigned int (*cpumask_next_wrap)(int n, const struct cpumask *mask, int start, bool wrap)",
        "pre": {
            "n": ">=0",
            "mask": "!=null",
            "start": ">=0",
            "wrap": "in [true, false]"
        },
    }
},
{
    "kprobe:cpumask_next_wrap": {
        "description": "Helper to implement for_each_cpu_wrap. Returns >= nr_cpu_ids on completion. The @wrap argument is required for the start condition when we cannot assume @start is set in @mask.",
        "proto" :"unsigned int (*cpumask_next_wrap)(int n, const struct cpumask *mask, int start, bool wrap)",
        "pre": {
            "n": "is an integer",
            "mask": "!=null",
            "start": "is an integer",
            "wrap": "is a boolean",
        },
    }
},
{
    "kretprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node. Only defined when CONFIG_CPUMASK_OFFSTACK=y, otherwise is a nop returning a constant 1 (in <linuxcpumask.h>). Returns TRUE if memory allocation succeeded, FALSE otherwise. In addition, mask will be NULL if this fails.",
        "proto" :"bool (*alloc_cpumask_var_node)(cpumask_var_t *mask, gfp_t flags, int node)",
        "pre": {
            "mask": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_HIGHMEM, GFP_NOIO, GFP_NOFS, GFP_NOWAIT, GFP_THISNODE, GFP_ATOMIC_LOW, GFP_KERNEL_ACCOUNT, GFP_NOWAIT_LOW, GFP_DIRECT_RECLAIM, GFP_WRITE, GFP_HARDWALL, GFP_HIUSER, GFP_DMA_RECLAIM_ACCOUNT, GFP_NOGFP, GFP_NORETRY, GFP_MEMALLOC, GFP_NOMEMALLOC, GFP_ZERO, GFP_HIGH, GFP_IO, GFP_FS, GFP_COLD, GFP_NOWAIT_IO, GFP_NOWAIT_FS, GFP_NOFAIL, GFP_RETRY_MAYFAIL, GFP_NO_ACCOUNT, GFP_NOTRACK, GFP_NO_KSWAPD, GFP_OTHER_NODE, GFP_RECLAIMABLE, GFP_NOTRACK_FALSE_POSITIVE, GFP_TRANSHUGE_LIGHT, GFP_TRANSHUGE, GFP_ATOMIC_HIGH]",
            "node": "in [0, NUMA_NO_NODE]"
        },
        "post": {
            "return": "in [true, false]",
            "mask": "if return == false then mask == null else mask != null"
        }
    }
},
{
    "kprobe:alloc_cpumask_var_node": {
        "description": "Allocate a struct cpumask on a given node. Returns TRUE if memory allocation succeeded, FALSE otherwise. In addition, mask will be NULL if this fails.",
        "proto" :"bool (*alloc_cpumask_var_node)(cpumask_var_t *mask, gfp_t flags, int node)",
        "pre": {
            "mask": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_NOFS, GFP_NOIO, GFP_NOWAIT, GFP_THISNODE, GFP_USER, GFP_HIGHMEM, GFP_MOVABLE_MASK, GFP_RECLAIM_MASK, GFP_CONSTRAINT_MASK, GFP_HARDWALL, GFP_MEMALLOC, GFP_NORETRY, GFP_NO_KSWAPD, GFP_NOWAIT_IO, GFP_NOWAIT_IOFS, GFP_ATOMIC_HIGH, GFP_NOFAIL, GFP_NOGFP]",
            "node": "in [0, NUMA_NO_NODE]"
        },
    }
},
{
    "kretprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask. This is safe on a NULL mask.",
        "proto" :"void (*free_cpumask_var)(cpumask_var_t mask)",
        "pre": {
            "mask": "is cpumask_var_t or null"
        }
    }
},
{
    "kprobe:free_cpumask_var": {
        "description": "Frees memory allocated for a struct cpumask. This is safe on a NULL mask.",
        "proto" :"void (*free_cpumask_var)(cpumask_var_t mask)",
        "pre": {
            "mask": "is cpumask_var_t"
        },
    }
},
{
    "kretprobe:cpumask_local_spread": {
        "description": "Select the i'th cpu based on NUMA distances. Returns online CPU according to a numa aware policy; local cpus are returned first, followed by non-local ones, then it wraps around.",
        "proto" :"unsigned int (*cpumask_local_spread)(unsigned int i, int node)",
        "pre": {
            "i": "in [0, num_online_cpus()-1]",
            "node": "in [0, num_possible_nodes()-1]"
        },
    }
},
{
    "kprobe:cpumask_local_spread": {
        "description": "Returns online CPU according to a numa aware policy; local cpus are returned first, followed by non-local ones, then it wraps around. For those who wants to enumerate all CPUs based on their NUMA distances.",
        "proto" :"unsigned int (*cpumask_local_spread)(unsigned int i, int node)",
        "pre": {
            "i": "in [0, num_online_cpus()-1]",
            "node": "in [0, num_possible_nodes()-1]"
        },
    }
},
{
    "kretprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p. Iterated calls using the same srcp1 and srcp2 will be distributed within their intersection. Returns >= nr_cpu_ids if the intersection is empty.",
        "proto" :"unsigned int (*cpumask_any_and_distribute)(const struct cpumask *src1p, const struct cpumask *src2p)",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        },
        "post": {
            "return": ">= nr_cpu_ids if the intersection of src1p and src2p is empty"
        }
    }
},
{
    "kprobe:cpumask_any_and_distribute": {
        "description": "Return an arbitrary cpu within src1p & src2p. Iterated calls using the same srcp1 and srcp2 will be distributed within their intersection. Returns >= nr_cpu_ids if the intersection is empty.",
        "proto" :"unsigned int (*cpumask_any_and_distribute)(const struct cpumask *src1p, const struct cpumask *src2p)",
        "pre": {
            "src1p": "!=null",
            "src2p": "!=null"
        }
    }
},
{
    "kretprobe:cpumask_any_distribute": {
        "description": "Distribute the cpumask among the CPUs. The first selection will skip 0.",
        "proto": "unsigned int (*cpumask_any_distribute)(const struct cpumask *srcp)",
        "pre": {
            "srcp": "!=null"
        },
        "post": {
            "return": ">=0 && < nr_cpu_ids"
        }
    }
},
{
    "kprobe:cpumask_any_distribute": {
        "description": "NOTE: our first selection will skip 0.",
        "proto" :"cpumask_any_distribute(const struct cpumask  srcp){unsigned int next, prev;}",
        "pre": {
            "srcp": "!=null",
            "next": "your_condition_here",
            "prev": "your_condition_here"
        },
    }
},
{
    "kretprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR. You will get a __iomem address to your device BAR. You can access it using ioread() and iowrite(). These functions hide the details if this is a MMIO or PIO address space and will just do what you expect from them in the correct way. @maxlen specifies the maximum length to map. If you want to get access to the complete BAR from offset to the end, pass %0 here.",
        "proto": "void __iomem *(*pci_iomap_range)(struct pci_dev *dev, int bar, unsigned long offset, unsigned long maxlen)",
        "pre": {
            "dev": "!=null",
            "bar": ">=0",
            "offset": ">=0",
            "maxlen": ">=0"
        }
    }
},
{
    "kprobe:pci_iomap_range": {
        "description": "Create a virtual mapping cookie for a PCI BAR. Using this function you will get a __iomem address to your device BAR. You can access it using ioread() and iowrite(). These functions hide the details if this is a MMIO or PIO address space and will just do what you expect from them in the correct way. @maxlen specifies the maximum length to map. If you want to get access to the complete BAR from offset to the end, pass %0 here.",
        "proto" :"void __iomem *(*pci_iomap_range)(struct pci_dev *dev, int bar, unsigned long offset, unsigned long maxlen)",
        "pre": {
            "dev": "!=null",
            "bar": ">=0",
            "offset": ">=0",
            "maxlen": ">=0"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmaps the IO or MEM mapped by pci_iomap. If the architecture supports ioport mapping (HAS_IOPORT_MAP), the ioport mapping will be fixed to the range [ PCI_IOBASE, PCI_IOBASE+IO_SPACE_LIMIT [, and does not need unmapping with 'ioport_unmap()'. If you have different rules for your architecture, you need to implement your own pci_iounmap() that knows the rules for where and how IO vs MEM get mapped.",
        "proto" :"#if defined(ARCH_WANTS_GENERIC_PCI_IOUNMAP)void pci_iounmap(struct pci_dev *dev, void __iomem *p)",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmaps the IO or memory region that was previously mapped by pci_iomap. If the architecture supports ioport mapping (HAS_IOPORT_MAP), the ioport mapping will be fixed to the range [ PCI_IOBASE, PCI_IOBASE+IO_SPACE_LIMIT [, and does not need unmapping with 'ioport_unmap()'.",
        "proto" :"#if defined(ARCH_WANTS_GENERIC_PCI_IOUNMAP)void pci_iounmap(struct pci_dev *dev, void __iomem *p)",
        "pre": {
            "dev": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object. Either the object is root itself when the private is returned directly, or the parent is root and its private is returned instead. Returns a user private root pointer. All locking must be provided by the caller.",
        "proto" :"const void *(*objagg_obj_root_priv)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        },
    }
},
{
    "kprobe:objagg_obj_root_priv": {
        "description": "Obtains root private for an object. Either the object is root itself when the private is returned directly, or the parent is root and its private is returned instead. Returns a user private root pointer. Note: all locking must be provided by the caller.",
        "proto" :"const void *(*objagg_obj_root_priv)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object. All locking must be provided by the caller. Returns user private delta pointer or NULL in case the passed object is root.",
        "proto" :"const void *(*objagg_obj_delta_priv)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:objagg_obj_delta_priv": {
        "description": "Obtains delta private for an object. All locking must be provided by the caller. Returns user private delta pointer or NULL in case the passed object is root.",
        "proto" :"const void *(*objagg_obj_delta_priv)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_raw": {
        "description": "objagg_obj_get() by 'obj' arg.",
        "proto" :"const void *(*objagg_obj_raw)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kprobe:objagg_obj_raw": {
        "description": "Accessed by 'obj' argument.",
        "proto" :"const void *(*objagg_obj_raw)(const struct objagg_obj *objagg_obj)",
        "pre": {
            "objagg_obj": "!=null"
        }
    }
},
{
    "kretprobe:objagg_obj_root_id_alloc": {
        "description": "Allocates a root id for an objagg_obj. If there are no hints available, the root id is invalid.",
        "proto": "static int (*objagg_obj_root_id_alloc)(struct objagg *objagg, struct objagg_obj *objagg_obj, struct objagg_hints_node *hnode)",
        "pre": {
            "objagg": "!=null",
            "objagg_obj": "!=null",
            "hnode": "can be null"
        },
        "post": {
            "return": "root_id is invalid if objagg->hints == null"
        }
    }
},
{
    "kprobe:objagg_obj_root_id_alloc": {
        "description": "In case there are no hints available, the root id is invalid.",
        "proto": "static int objagg_obj_root_id_alloc(struct objagg  objagg, struct objagg_obj  objagg_obj, struct objagg_hints_node  hnode)",
        "pre": {
            "objagg": "!=null",
            "objagg_obj": "!=null",
            "hnode": "!=null",
            "objagg->hints": "!=null"
        }
    }
},
{
    "kretprobe:objagg_create": {
        "description": "Creates a new objagg instance. User fills-up ops which take care of the specific user object manipulation. Each objagg instance contains multiple trees. Each tree node is represented by 'an object'. Returns a pointer to newly created objagg instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"struct objagg *(*objagg_create)(const struct objagg_ops *ops, struct objagg_hints *objagg_hints, void *priv)",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "can be null",
            "priv": "!=null"
        },
    }
},
{
    "kprobe:objagg_create": {
        "description": "Creates a new objagg instance. The purpose of the library is to provide an infrastructure to aggregate user-specified objects. Library does not care about the type of the object. User fills-up ops which take care of the specific user object manipulation. Returns a pointer to newly created objagg instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"struct objagg *(*objagg_create)(const struct objagg_ops *ops, struct objagg_hints *objagg_hints, void *priv)",
        "pre": {
            "ops": "!=null",
            "objagg_hints": "can be null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance. Note: all locking must be provided by the caller.",
        "proto" :"static void (*objagg_destroy)(struct objagg *objagg)",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kprobe:objagg_destroy": {
        "description": "Destroys a new objagg instance. Note: all locking must be provided by the caller.",
        "proto" :"void (*objagg_destroy)(struct objagg *objagg)",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance. The returned structure contains statistics of all object currently in use, ordered by following rules: 1) Root objects are always on lower indexes than the rest. 2) Objects with higher delta user count are always on lower indexes. 3) In case more objects have the same delta user count, the objects are ordered by user count. Returns a pointer to stats instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"const struct objagg_stats *(*objagg_stats_get)(struct objagg *objagg)",
        "pre": {
            "objagg": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kprobe:objagg_stats_get": {
        "description": "Obtains stats of the objagg instance. All locking must be provided by the caller. The returned structure contains statistics of all object currently in use, ordered by following rules: 1) Root objects are always on lower indexes than the rest. 2) Objects with higher delta user count are always on lower indexes. 3) In case more objects have the same delta user count, the objects are ordered by user count. Returns a pointer to stats instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"const struct objagg_stats *(*objagg_stats_get)(struct objagg *objagg)",
        "pre": {
            "objagg": "!=null"
        }
    }
},
{
    "kretprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance. Note: all locking must be provided by the caller.",
        "proto" :"void (*objagg_stats_put)(const struct objagg_stats *objagg_stats)",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kprobe:objagg_stats_put": {
        "description": "Puts stats of the objagg instance. Note: all locking must be provided by the caller.",
        "proto" :"static void (*objagg_stats_put)(const struct objagg_stats *objagg_stats)",
        "pre": {
            "objagg_stats": "!=null"
        }
    }
},
{
    "kretprobe:objagg_hints_get": {
        "description": "Obtains hints instance. According to the algo type, the existing objects of objagg instance are going to be went-through to assemble an optimal tree. These hints can be later on used for creation of a new objagg instance. There, the future object creations are going to be consulted with these hints in order to find out, where exactly the new object should be put as a root or delta. Returns a pointer to hints instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"struct objagg_hints *(*objagg_hints_get)(struct objagg *objagg, enum objagg_opt_algo_type opt_algo_type)",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "in [OBJAGG_OPT_ALGO_TYPE_FIRST, OBJAGG_OPT_ALGO_TYPE_LAST]"
        }
    }
},
{
    "kprobe:objagg_hints_get": {
        "description": "Obtains hints instance. According to the algo type, the existing objects of objagg instance are going to be went-through to assemble an optimal tree. These hints can be later on used for creation of a new objagg instance. There, the future object creations are going to be consulted with these hints in order to find out, where exactly the new object should be put as a root or delta. Returns a pointer to hints instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"struct objagg_hints *(*objagg_hints_get)(struct objagg *objagg, enum objagg_opt_algo_type opt_algo_type)",
        "pre": {
            "objagg": "!=null",
            "opt_algo_type": "!=null",
            "caller": "provides all locking"
        },
    }
},
{
    "kretprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance @objagg_hints. All locking must be provided by the caller. The returned structure contains statistics of all objects currently in use, ordered by following rules: 1) Root objects are always on lower indexes than the rest. 2) Objects with higher delta user count are always on lower indexes. 3) In case multiple objects have the same delta user count, the objects are ordered by user count. Returns a pointer to stats instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"const struct objagg_stats *(*objagg_hints_stats_get)(struct objagg_hints *objagg_hints)",
        "pre": {
            "objagg_hints": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:objagg_hints_stats_get": {
        "description": "Obtains stats of the hints instance. All locking must be provided by the caller. The returned structure contains statistics of all objects currently in use, ordered by following rules: 1) Root objects are always on lower indexes than the rest. 2) Objects with higher delta user count are always on lower indexes. 3) In case multiple objects have the same delta user count, the objects are ordered by user count. Returns a pointer to stats instance in case of success, otherwise it returns pointer error using ERR_PTR macro.",
        "proto" :"const struct objagg_stats *(*objagg_hints_stats_get)(struct objagg_hints *objagg_hints)",
        "pre": {
            "objagg_hints": "!=null"
        }
    }
},

{
    "kprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[parameter1]": "[constraints]",
            "[parameter2]": "[constraints]",
            "[parameter3]": "[constraints]",
            "[parameter4]": "[constraints]",
        },
    }
},


{
    "kretprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1. No atomic_t counterpart, it attempts a 1 -> 0 transition and returns the success thereof. Like all decrement operations, it provides release memory order and provides a control dependency. It can be used like a try-delete operator; this explicit case is provided and not cmpxchg in generic, because that would allow implementing unsafe operations.",
        "proto" :"bool (*refcount_dec_if_one)(refcount_t *r)",
        "pre": {
            "r": "==1"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_if_one": {
        "description": "Decrement a refcount if it is 1. No atomic_t counterpart, it attempts a 1 -> 0 transition and returns the success thereof. Like all decrement operations, it provides release memory order and provides a control dependency. It can be used like a try-delete operator; this explicit case is provided and not cmpxchg in generic, because that would allow implementing unsafe operations. Return: true if the resulting refcount is 0, false otherwise.",
        "proto" :"bool (*refcount_dec_if_one)(refcount_t *r)",
        "pre": {
            "r": "!=null && ==1"
        },
    }
},
{
    "kretprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1. No atomic_t counterpart, it decrements unless the value is 1, in which case it will return false. Was often done like: atomic_add_unless(&var, -1, 1). Return: true if the decrement operation was successful, false otherwise.",
        "proto" :"bool (*refcount_dec_not_one)(refcount_t *r)",
        "pre": {
            "r": "!=null && >1"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_not_one": {
        "description": "Decrement a refcount if it is not 1. No atomic_t counterpart, it decrements unless the value is 1, in which case it will return false. Was often done like: atomic_add_unless(&var, -1, 1). Return: true if the decrement operation was successful, false otherwise.",
        "proto" :"bool (*refcount_dec_not_one)(refcount_t *r)",
        "pre": {
            "r": "!=null && !=1"
        },
    }
},
{
    "kretprobe:refcount_dec_and_mutex_lock": {
        "description": "Return true and hold mutex if able to decrement refcount to 0, false otherwise. It will WARN on underflow and fail to decrement when saturated at REFCOUNT_SATURATED. Provides release memory ordering, such that prior loads and stores are done before, and provides a control dependency such that free() must come after.",
        "proto" :"bool (*refcount_dec_and_mutex_lock)(refcount_t *r, struct mutex *lock)",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_and_mutex_lock": {
        "description": "Return holding mutex if able to decrement refcount to 0. It will WARN on underflow and fail to decrement when saturated at REFCOUNT_SATURATED. Provides release memory ordering, such that prior loads and stores are done before, and provides a control dependency such that free() must come after.",
        "proto" :"bool (*refcount_dec_and_mutex_lock)(refcount_t *r, struct mutex *lock)",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]",
            "r": ">= 0",
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:refcount_dec_and_lock": {
        "description": "Return true and hold spinlock if able to decrement refcount to 0, false otherwise. It will WARN on underflow and fail to decrement when saturated at REFCOUNT_SATURATED. Provides release memory ordering, such that prior loads and stores are done before, and provides a control dependency such that free() must come after.",
        "proto" :"bool (*refcount_dec_and_lock)(refcount_t *r, spinlock_t *lock)",
        "pre": {
            "r": "!=null",
            "lock": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:refcount_dec_and_lock": {
        "description": "Return true and hold spinlock if able to decrement refcount to 0, false otherwise. It will WARN on underflow and fail to decrement when saturated at REFCOUNT_SATURATED. Provides release memory ordering, such that prior loads and stores are done before, and provides a control dependency such that free() must come after.",
        "proto" :"bool (*refcount_dec_and_lock)(refcount_t *r, spinlock_t *lock)",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "r": "> 0"
        },
    }
},
{
    "kretprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0. Same as refcount_dec_and_lock() above except that the spinlock is acquired with disabled interrupts. Return: true and hold spinlock if able to decrement refcount to 0, false otherwise.",
        "proto" :"bool (*refcount_dec_and_lock_irqsave)(refcount_t *r, spinlock_t *lock, unsigned long *flags)",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        },
    }
},
{
    "kprobe:refcount_dec_and_lock_irqsave": {
        "description": "Return holding spinlock with disabled interrupts if able to decrement refcount to 0. Same as refcount_dec_and_lock() above except that the spinlock is acquired with disabled interrupts. Return: true and hold spinlock if able to decrement refcount to 0, false otherwise.",
        "proto" :"bool (*refcount_dec_and_lock_irqsave)(refcount_t *r, spinlock_t *lock, unsigned long *flags)",
        "pre": {
            "r": "!=null",
            "lock": "!=null",
            "flags": "!=null"
        }
    }
},
{
    "kretprobe:parman_create": {
        "description": "Creates a new parman instance. All locking must be provided by the caller. Each parman instance manages an array area with chunks of entries with the same priority. The goal of parman is to maintain the priority ordering. The caller provides @ops with callbacks parman uses to move the items and resize the array area.",
        "proto" :"struct parman *(*parman_create)(const struct parman_ops *ops, void *priv)",
        "pre": {
            "ops": "!=null",
            "priv": "can be null or !=null"
        },
        "post": {
            "return": "!=null or ==null"
        }
    }
},
{
    "kprobe:parman_create": {
        "description": "Creates a new parman instance. All locking must be provided by the caller. Each parman instance manages an array area with chunks of entries with the same priority. The goal of parman is to maintain the priority ordering. The caller provides @ops with callbacks parman uses to move the items and resize the array area. Returns a pointer to newly created parman instance in case of success, otherwise it returns NULL.",
        "proto" :"struct parman *(*parman_create)(const struct parman_ops *ops, void *priv)",
        "pre": {
            "ops": "!=null",
            "priv": "can be null or !=null"
        },
    }
},
{
    "kretprobe:parman_destroy": {
        "description": "Destroys existing parman instance. Note: all locking must be provided by the caller.",
        "proto" :"void (*parman_destroy)(struct parman *parman)",
        "pre": {
            "parman": "!=null"
        }
    }
},
{
    "kprobe:parman_destroy": {
        "description": "Destroys existing parman instance. Note: all locking must be provided by the caller.",
        "proto" :"void (*parman_destroy)(struct parman *parman)",
        "pre": {
            "parman": "!=null"
        }
    }
},
{
    "kretprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk. Before caller could add an item with certain priority, he has to initialize a priority chunk for it using this function. All locking must be provided by the caller.",
        "proto" :"void parman_prio_init(struct parman *parman, struct parman_prio *prio, unsigned long priority)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": ">=0"
        }
    }
},
{
    "kprobe:parman_prio_init": {
        "description": "Initializes a parman priority chunk. Before caller could add an item with certain priority, he has to initialize a priority chunk for it using this function. All locking must be provided by the caller.",
        "proto" :"void (*parman_prio_init)(struct parman *parman, struct parman_prio *prio, unsigned long priority)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "priority": "is a valid unsigned long value"
        }
    }
},
{
    "kretprobe:parman_prio_fini": {
        "description": "Finalizes use of parman priority chunk. Note: all locking must be provided by the caller.",
        "proto": "void (*parman_prio_fini)(struct parman_prio *prio)",
        "pre": {
            "prio": "!=null"
        }
    }
},
{
    "kprobe:parman_prio_fini": {
        "description": "Finalizes use of parman priority chunk. Note: all locking must be provided by the caller.",
        "proto" :"void (*parman_prio_fini)(struct parman_prio *prio)",
        "pre": {
            "prio": "!=null"
        }
    }
},
{
    "kretprobe:parman_item_add": {
        "description": "Adds item to a array managed by parman instance under the specified priority. Returns 0 in case of success, negative number to indicate an error.",
        "proto" :"int (*parman_item_add)(struct parman *parman, struct parman_prio *prio, struct parman_item *item)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kprobe:parman_item_add": {
        "description": "Adds item to an array managed by parman instance under the specified priority. Returns 0 in case of success, negative number to indicate an error.",
        "proto" :"int (*parman_item_add)(struct parman *parman, struct parman_prio *prio, struct parman_item *item)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        },
    }
},
{
    "kretprobe:parman_item_remove": {
        "description": "Deletes parman item. Note: all locking must be provided by the caller.",
        "proto" :"void (*parman_item_remove)(struct parman *parman, struct parman_prio *prio, struct parman_item *item)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:parman_item_remove": {
        "description": "Deletes parman item. Note: all locking must be provided by the caller.",
        "proto" :"void (*parman_item_remove)(struct parman *parman, struct parman_prio *prio, struct parman_item *item)",
        "pre": {
            "parman": "!=null",
            "prio": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:packing": {
        "description": "Convert numbers (currently u64) between a packed and an unpacked format. Unpacked means laid out in memory in the CPU's native understanding of integers, while packed means anything else that requires translation.",
        "proto" :"int packing(void *pbuf, u64 *uval, int startbit, int endbit, size_t pbuflen, enum packing_op op, u8 quirks)",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">= endbit",
            "endbit": "<= startbit",
            "pbuflen": "> 0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        },
        "post": {
            "return": "in [0, EINVAL, ERANGE]"
        }
    }
},
{
    "kprobe:packing": {
        "description": "Convert numbers (currently u64) between a packed and an unpacked format. Unpacked means laid out in memory in the CPU's native understanding of integers, while packed means anything else that requires translation.",
        "proto" :"int packing(void *pbuf, u64 *uval, int startbit, int endbit, size_t pbuflen, enum packing_op op, u8 quirks)",
        "pre": {
            "pbuf": "!=null",
            "uval": "!=null",
            "startbit": ">= endbit",
            "endbit": "<= startbit",
            "pbuflen": "> 0",
            "op": "in [PACK, UNPACK]",
            "quirks": "in [QUIRK_LITTLE_ENDIAN, QUIRK_LSW32_IS_FIRST, QUIRK_MSB_ON_THE_RIGHT]"
        },
    }
},
{
    "kretprobe:ucs2_strncmp": {
        "description": "Compares two ucs2 strings of a given length. Returns 0 if they are equal, -1 if a < b, and 1 if a > b. If a is null, then b must also be null.",
        "proto" :"int ucs2_strncmp(const ucs2_char_t *a, const ucs2_char_t *b, size_t len)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:ucs2_strncmp": {
        "description": "Compares two ucs2 strings of a given length. Returns 0 if they are equal, -1 if a < b, and 1 if a > b. If a is null, then b must also be null.",
        "proto" :"static int (*ucs2_strncmp)(const ucs2_char_t a, const ucs2_char_t b, size_t len)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0",
            "a == 0": "implies b == 0"
        },
    }
},
{
    "kretprobe:crc32c": {
        "description": "Needs description",
        "proto" :"u32 crc32c(u32 crc, const void *address, unsigned int length)",
        "pre": {
            "crc": "Needs constraints",
            "address": "!=null",
            "length": ">=0",
        },
    }
},
{
    "kprobe:crc32c": {
        "description": "crc32c, but hopefully may be able to use this one are: netsctp (please add all your doco to here if you change to use this one!) <endoflist> Copyright (c) 2004 Cisco Systems, Inc.",
        "proto" :"u32 crc32c(u32 crc, const void *address, unsigned int length)",
        "pre": {
            "crc": "is an unsigned 32-bit integer",
            "address": "!=null",
            "length": "is an unsigned integer"
        },
    }
},
{
    "kretprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their class, as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-types, enforce relative levels by bitpos.",
        "proto" :"int (*param_set_dyndbg_classes)(const char *instr, const struct kernel_param *kp)",
        "pre": {
            "instr": "!=null",
            "kp": "!=null",
            "kp->arg": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:param_set_dyndbg_classes": {
        "description": "Enable/disable prdbgs by their class, as given in the arguments to DECLARE_DYNDBG_CLASSMAP. For LEVEL map-types, enforce relative levels by bitpos.",
        "proto" :"int (*param_set_dyndbg_classes)(const char *instr, const struct kernel_param *kp)",
        "pre": {
            "instr": "!=null",
            "kp": {
                "arg": {
                    "state": {
                        "bitslvl": "is defined",
                        "map": "is defined",
                        "map_type": "in [LEVEL, OTHER_DEFINED_MAP_TYPES]"
                    }
                }
            }
        },
    }
},
{
    "kretprobe:param_get_dyndbg_classes": {
        "description": "Classes reader. Reads last written state, underlying prdbg state may have been altered by direct control. Displays 0x for DISJOINT, 0-N for LEVEL. Returns: #chars written or <0 on error.",
        "proto" :"int (*param_get_dyndbg_classes)(char *buffer, const struct kernel_param *kp)",
        "pre": {
            "buffer": "!=null",
            "kp": "!=null && kp->arg !=null"
        },
        "post": {
            "return": ">=0 || <0"
        }
    }
},
{
    "kprobe:param_get_dyndbg_classes": {
        "description": "Classes reader. Reads last written state, underlying prdbg state may have been altered by direct control. Displays 0x for DISJOINT, 0-N for LEVEL. Returns: #chars written or <0 on error.",
        "proto" :"int (*param_get_dyndbg_classes)(char *buffer, const struct kernel_param *kp)",
        "pre": {
            "buffer": "!=null",
            "kp": "!=null",
            "kp->arg": "has state: bits, map"
        },
    }
},
{
    "kretprobe:ioremap": {
        "description": "Maps a physical address to a virtual address in the kernel's virtual address space.",
        "proto" :"void __iomem *(*ioremap)(phys_addr_t offset, size_t size)",
        "pre": {
            "offset": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Maps a physical address to a virtual address in the kernel's virtual address space.",
        "proto" :"void __iomem *(*ioremap)(phys_addr_t offset, size_t size)",
        "pre": {
            "offset": ">=0",
            "size": ">0",
        },
    }
},

{
    "kprobe:memcpy_toio": {
        "description": "Copy data from a buffer to IO memory.",
        "proto" :"void memcpy_toio(volatile void __iomem *addr, const void *buffer, size_t size)",
        "pre": {
            "addr": "!=null",
            "buffer": "!=null",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically. Allocates an unused ID in the range specified by @nextid and @end. If @end is <= 0, it is treated as one larger than %INT_MAX. This allows callers to use @start + N as @end as long as N is within integer range. The search for an unused ID will start at the last ID allocated and will wrap around to @start if no free IDs are found before reaching @end. The caller should provide their own locking to ensure that two concurrent modifications to the IDR are not possible. Read-only accesses to the IDR may be done under the RCU read lock or may exclude simultaneous writers. Return: The newly allocated ID, -ENOMEM if memory allocation failed, or -ENOSPC if no free IDs could be found.",
        "proto" :"int idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": ">=0",
            "end": ">start",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOLOCKDEP]"
        },
        "post": {
            "return": "in [-ENOMEM, -ENOSPC, start:end]"
        }
    }
},
{
    "kprobe:idr_alloc_cyclic": {
        "description": "Allocate an ID cyclically. Allocates an unused ID in the range specified by @nextid and @end. If @end is <= 0, it is treated as one larger than %INT_MAX. This allows callers to use @start + N as @end as long as N is within integer range. The search for an unused ID will start at the last ID allocated and will wrap around to @start if no free IDs are found before reaching @end. The caller should provide their own locking to ensure that two concurrent modifications to the IDR are not possible. Read-only accesses to the IDR may be done under the RCU read lock or may exclude simultaneous writers. Return: The newly allocated ID, -ENOMEM if memory allocation failed, or -ENOSPC if no free IDs could be found.",
        "proto" :"int idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "start": "is integer",
            "end": "is integer",
            "gfp": "is gfp_t type"
        },
    }
},
{
    "kretprobe:idr_for_each": {
        "description": "Iterate through all stored pointers. The callback function will be called for each entry in @idr, passing the ID, the entry and @data. If @fn returns anything other than %0, the iteration stops and that value is returned from this function. idr_for_each() can be called concurrently with idr_alloc() and idr_remove() if protected by RCU. Newly added entries may not be seen and deleted entries may be seen, but adding and removing entries will not cause other entries to be skipped, nor spurious ones to be seen.",
        "proto" :"int idr_for_each(const struct idr *idr,int (*fn)(int id, void *p, void *data), void *data)",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "can be null or !=null"
        }
    }
},
{
    "kprobe:idr_for_each": {
        "description": "Iterate through all stored pointers. The callback function will be called for each entry in @idr, passing the ID, the entry and @data. If @fn returns anything other than %0, the iteration stops and that value is returned from this function. idr_for_each() can be called concurrently with idr_alloc() and idr_remove() if protected by RCU. Newly added entries may not be seen and deleted entries may be seen, but adding and removing entries will not cause other entries to be skipped, nor spurious ones to be seen.",
        "proto" :"int idr_for_each(const struct idr *idr,int (*fn)(int id, void *p, void *data), void *data)",
        "pre": {
            "idr": "!=null",
            "fn": "!=null",
            "data": "can be null or !=null",
        },
    }
},
{
    "kretprobe:idr_get_next_ul": {
        "description": "Find next populated entry. Returns the next populated entry in the tree with an ID greater than or equal to the value pointed to by @nextid. On exit, @nextid is updated to the ID of the found value. To use in a loop, the value pointed to by nextid must be incremented by the user.",
        "proto" :"void *(*idr_get_next_ul)(struct idr *idr, unsigned long *nextid)",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null"
        }
    }
},
{
    "kprobe:idr_get_next_ul": {
        "description": "Find next populated entry. Returns the next populated entry in the tree with an ID greater than or equal to the value pointed to by @nextid. On exit, @nextid is updated to the ID of the found value. To use in a loop, the value pointed to by nextid must be incremented by the user.",
        "proto" :"void *(*idr_get_next_ul)(struct idr *idr, unsigned long *nextid)",
        "pre": {
            "idr": "!=null",
            "nextid": "!=null"
        }
    }
},
{
    "kretprobe:idr_replace": {
        "description": "Replace the pointer registered with an ID and return the old value. This function can be called under the RCU read lock concurrently with idr_alloc() and idr_remove() (as long as the ID being removed is not the one being replaced!). Returns: the old value on success. %-ENOENT indicates that @id was not found. %-EINVAL indicates that @ptr was not valid.",
        "proto": "void *(*idr_replace)(struct idr *idr, void *ptr, unsigned long id)",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": ">=0"
        }
    }
},
{
    "kprobe:idr_replace": {
        "description": "Replace the pointer registered with an ID and return the old value. This function can be called under the RCU read lock concurrently with idr_alloc() and idr_remove() (as long as the ID being removed is not the one being replaced!). Returns: the old value on success. %-ENOENT indicates that @id was not found. %-EINVAL indicates that @ptr was not valid.",
        "proto" :"void *(*idr_replace)(struct idr *idr, void *ptr, unsigned long id)",
        "pre": {
            "idr": "!=null",
            "ptr": "!=null",
            "id": ">=0"
        },
    }
},
{
    "kretprobe:ida_destroy": {
        "description": "Dispose of an IDA without needing to free the individual IDs in it. It is safe to call any of the IDA functions without synchronisation in your code. IDs are currently limited to the range [0-INT_MAX].",
        "proto" :"void ida_destroy(struct ida *ida)",
        "pre": {
            "ida": "!=null"
        },
    }
},
{
    "kprobe:ida_destroy": {
        "description": "Dispose of an IDA without needing to free the individual IDs in it. It is safe to call any of the IDA functions without synchronisation in your code.",
        "proto" :"static void (*ida_destroy)(struct ida *ida)",
        "pre": {},
        "post": {
            "ida": "disposed"
        }
    }
},
{
    "kretprobe:lockref_get": {
        "description": "Increments reference count unconditionally. This operation is only valid if you already hold a reference to the object, so you know the count cannot be zero.",
        "proto" :"void (*lockref_get)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null && ->count > 0",
        },
    }
},
{
    "kprobe:lockref_get": {
        "description": "Increments reference count unconditionally. This operation is only valid if you already hold a reference to the object, so you know the count cannot be zero.",
        "proto" :"void (*lockref_get)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null && ->count > 0",
        },
    }
},
{
    "kretprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead. Returns 1 if count updated successfully or 0 if count was zero.",
        "proto" :"int (*lockref_get_not_zero)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_zero": {
        "description": "Increments count unless the count is 0 or dead. Returns 1 if count updated successfully or 0 if count was zero.",
        "proto" :"int (*lockref_get_not_zero)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
    }
},
{
    "kretprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement. Returns 1 if count updated successfully or 0 if count would become zero.",
        "proto" :"int (*lockref_put_not_zero)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null",
            "lockref->count": "> 1"
        },
        "post": {
            "return": "in [0, 1]",
            "lockref->count": ">= 0"
        }
    }
},
{
    "kprobe:lockref_put_not_zero": {
        "description": "Decrements count unless count <= 1 before decrement. Returns 1 if count updated successfully or 0 if count would become zero.",
        "proto" :"int (*lockref_put_not_zero)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null && lockref->count > 1"
        },
    }
},
{
    "kretprobe:lockref_put_return": {
        "description": "Decrement reference count if possible. If the lockref was dead or locked, return an error.",
        "proto" :"int (*lockref_put_return)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENOENT]"
        }
    }
},
{
    "kprobe:lockref_put_return": {
        "description": "Decrement reference count if possible. Decrement the reference count and return the new value. If the lockref was dead or locked, return an error.",
        "proto" :"int (*lockref_put_return)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
    }
},
{
    "kretprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement. Returns 1 if count updated successfully or 0 if count <= 1 and lock taken.",
        "proto" :"int (*lockref_put_or_lock)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_put_or_lock": {
        "description": "Decrements count unless count <= 1 before decrement. Returns 1 if count updated successfully or 0 if count <= 1 and lock taken.",
        "proto" :"int (*lockref_put_or_lock)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null",
            "lockref->count": "> 1"
        },
    }
},
{
    "kretprobe:lockref_mark_dead": {
        "description": "Mark lockref as dead",
        "proto": "void (*lockref_mark_dead)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kprobe:lockref_mark_dead": {
        "description": "Mark lockref as dead",
        "proto": "void (*lockref_mark_dead)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead. Returns 1 if count updated successfully or 0 if lockref was dead.",
        "proto" :"int (*lockref_get_not_dead)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lockref_get_not_dead": {
        "description": "Increments count unless the ref is dead. Returns 1 if count updated successfully or 0 if lockref was dead.",
        "proto" :"int (*lockref_get_not_dead)(struct lockref *lockref)",
        "pre": {
            "lockref": "!=null"
        }
    }
},
{
    "kretprobe:crc8_populate_msb": {
        "description": "Fill crc table for given polynomial in reverse bit order.",
        "proto" :"void (*crc8_populate_msb)(u8 table[CRC8_TABLE_SIZE], u8 polynomial)",
        "pre": {
            "table": "!=null",
            "polynomial": "is u8"
        }
    }
},
{
    "kprobe:crc8_populate_msb": {
        "description": "Fill crc table for given polynomial in reverse bit order.",
        "proto" :"void (*crc8_populate_msb)(u8 table[CRC8_TABLE_SIZE], u8 polynomial)",
        "pre": {
            "table": "!=null",
            "polynomial": "is u8"
        }
    }
},
{
    "kretprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "proto" :"void (*crc8_populate_lsb)(u8 table[CRC8_TABLE_SIZE], u8 polynomial)",
        "pre": {
            "table": "!=null",
            "polynomial": "is u8"
        }
    }
},
{
    "kprobe:crc8_populate_lsb": {
        "description": "Fill crc table for given polynomial in regular bit order.",
        "proto" :"void (*crc8_populate_lsb)(u8 table[CRC8_TABLE_SIZE], u8 polynomial)",
        "pre": {
            "table": "!=null",
            "polynomial": "is a valid u8 value"
        }
    }
},

{
    "__ashrdi3": {
        "description": "Performs arithmetic shift right operation on a long long integer.",
        "proto" :"long long (*__ashrdi3)(long long u, word_type b)",
        "pre": {
            "u": "is long long",
            "b": "is word_type"
        },
    }
},
{
    "kretprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject. @kobj: struct kobject to set the name of @fmt: format string used to build the name @vargs: vargs to format the string.",
        "proto" :"int kobject_set_name_vargs(struct kobject *kobj, const char *fmt, va_list vargs)",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject. @kobj: struct kobject to set the name of @fmt: format string used to build the name @vargs: vargs to format the string.",
        "proto" :"int (*kobject_set_name_vargs)(struct kobject *kobj, const char *fmt, va_list vargs)",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        }
    }
},
{
    "kretprobe:kobject_add_internal": {
        "description": "Join kset if set, use it as parent if we do not already have one",
        "proto" :"int kobject_add_internal(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "can be null or not null",
            "kobj->name": "!=null and !=''",
            "kobj->parent": "can be null or not null"
        },
    }
},
{
    "kprobe:kobject_add_internal": {
        "description": "Join kset if set, use it as parent if we do not already have one.",
        "proto" :"int kobject_add_internal(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null",
            "kobj->kset": "!=null",
            "kobj->name": "!=null && !=''",
            "kobj->parent": "can be null, if null use kset as parent"
        },
    }
},
{
    "kretprobe:kobject_del": {
        "description": "Remove a kobject. Send 'remove' if the caller did not do it but sent 'add'.",
        "proto" :"void kobject_del(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null",
            "kobj->state_add_uevent_sent": "==true",
            "kobj->state_remove_uevent_sent": "==false"
        },
    }
},
{
    "kprobe:kobject_del": {
        "description": "Remove a kobject. Send 'remove' if the caller did not do it but sent 'add'.",
        "proto" :"void kobject_del(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null",
            "kobj->state_add_uevent_sent": "==true",
            "kobj->state_remove_uevent_sent": "==false"
        },
    }
},
{
    "kretprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj. @kobj: kobject in question @uid: kernel user ID for sysfs objects @gid: kernel group ID for sysfs objects. Returns initial uidgid pair that should be used when creating sysfs representation of given kobject. Normally used to adjust ownership of objects in a container.",
        "proto" :"void (*kobject_get_ownership)(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kprobe:kobject_get_ownership": {
        "description": "Get sysfs ownership data for @kobj. @kobj: kobject in question @uid: kernel user ID for sysfs objects @gid: kernel group ID for sysfs objects. Returns initial uidgid pair that should be used when creating sysfs representation of given kobject. Normally used to adjust ownership of objects in a container.",
        "proto" :"void kobject_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)",
        "pre": {
            "kobj": "!=null",
            "uid": "!=null",
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject. Be noisy on error issues.",
        "proto" :"static int (*kobject_set_name_vargs)(struct kobject *kobj, const char *fmt, va_list vargs)",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
            "vargs": "!=null"
        },
        "post": {
            "error": "in [-EEXIST, 0, 1]"
        }
    }
},
{
    "kprobe:kobject_set_name_vargs": {
        "description": "Set the name of a kobject. Be noisy on error issues.",
        "proto" :"static int (*kobject_set_name_vargs)(struct kobject *kobj, const char *fmt, va_list vargs)",
        "pre": {
            "kobj": "!=null",
            "fmt": "!=null",
        },
    }
},
{
    "kretprobe:kset_register": {
        "description": "Initialize and add a kset. On error, the kset.kobj.name allocated by kobj_set_name() is freed, it can not be used any more.",
        "proto" :"int (*kset_register)(struct kset *k)",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_register": {
        "description": "Initialize and add a kset. On error, the kset.kobj.name allocated by kobj_set_name() is freed, it can not be used any more.",
        "proto" :"int (*kset_register)(struct kset *k)",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:kset_unregister": {
        "description": "Remove a kset.",
        "proto": "void kset_unregister(struct kset *k)",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kprobe:kset_unregister": {
        "description": "Remove a kset.",
        "proto": "void kset_unregister(struct kset *k)",
        "pre": {
            "k": "!=null"
        }
    }
},
{
    "kretprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value. hex_to_bin() converts one hex digit to its actual value or -1 in case of bad input. This function is used to load cryptographic keys, so it is coded in such a way that there are no conditions or memory accesses that depend on data.",
        "proto" :"int hex_to_bin(unsigned char ch)",
        "pre": {
            "ch": "in ['0'..'9', 'A'..'F', 'a'..'f']"
        },
        "post": {
            "return": "in [-1, 0..15]"
        }
    }
},
{
    "kprobe:hex_to_bin": {
        "description": "Convert a hex digit to its real value. hex_to_bin() converts one hex digit to its actual value or -1 in case of bad input. This function is used to load cryptographic keys, so it is coded in such a way that there are no conditions or memory accesses that depend on data.",
        "proto" :"int (*hex_to_bin)(unsigned char ch)",
        "pre": {
            "ch": "in ['0'-'9', 'A'-'F', 'a'-'f']"
        },
        "post": {
            "return": "in [-1, 0-15]"
        }
    }
},
{
    "kretprobe:hex2bin": {
        "description": "Convert an ascii hexadecimal string to its binary representation. Return 0 on success, -EINVAL in case of bad input.",
        "proto" :"int (*hex2bin)(u8 *dst, const char *src, size_t count)",
        "pre": {
            "dst": "!=null",
            "src": "!=null && is_hex(src)",
            "count": ">=0 && <=strlen(src)/2"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:hex2bin": {
        "description": "Convert an ascii hexadecimal string to its binary representation. Return 0 on success, -EINVAL in case of bad input.",
        "proto" :"int (*hex2bin)(u8 *dst, const char *src, size_t count)",
        "pre": {
            "dst": "!=null",
            "src": "!=null && is_hex(src)",
            "count": ">=0 && <=strlen(src)/2",
        },
    }
},
{
    "kretprobe:bin2hex": {
        "description": "Convert binary data to an ascii hexadecimal string. @dst: ascii hexadecimal result. @src: binary data. @count: binary data length.",
        "proto": "char *(*bin2hex)(char *dst, const void *src, size_t count)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:bin2hex": {
        "description": "Convert binary data to an ascii hexadecimal string",
        "proto" :"char *(*bin2hex)(char *dst, const void *src, size_t count)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory. The function works on one 'line' of output at a time, i.e., 16 or 32 bytes of input data converted to hex + ASCII output. The converted output is always NUL-terminated.",
        "proto" :"int (*hex_dump_to_buffer)(const void *buf, size_t len, int rowsize, int groupsize, char *linebuf, size_t linebuflen, bool ascii)",
        "pre": {
            "buf": "!=null",
            "len": ">0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=len",
            "ascii": "in [true, false]"
        },
    }
},
{
    "kprobe:hex_dump_to_buffer": {
        "description": "Convert a blob of data to 'hex ASCII' in memory. Works on one 'line' of output at a time, i.e., 16 or 32 bytes of input data converted to hex + ASCII output. The converted output is always NUL-terminated.",
        "proto" :"int (*hex_dump_to_buffer)(const void *buf, size_t len, int rowsize, int groupsize, char *linebuf, size_t linebuflen, bool ascii)",
        "pre": {
            "buf": "!=null",
            "len": ">0",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "linebuf": "!=null",
            "linebuflen": ">=len",
            "ascii": "in [true, false]"
        },
    }
},
{
    "kretprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "proto": "void (*print_hex_dump)(const char *level, const char *prefix_str, int prefix_type, int rowsize, int groupsize, const void *buf, size_t len, bool ascii)",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "is bool"
        }
    }
},
{
    "kprobe:print_hex_dump": {
        "description": "Print a text hex dump to syslog for a binary blob of data.",
        "proto" :"void (*print_hex_dump)(const char *level, const char *prefix_str, int prefix_type, int rowsize, int groupsize, const void *buf, size_t len, bool ascii)",
        "pre": {
            "level": "!=null",
            "prefix_str": "!=null",
            "prefix_type": "in [%DUMP_PREFIX_OFFSET, %DUMP_PREFIX_ADDRESS, %DUMP_PREFIX_NONE]",
            "rowsize": "in [16, 32]",
            "groupsize": "in [1, 2, 4, 8]",
            "buf": "!=null",
            "len": ">=0",
            "ascii": "is bool"
        }
    }
},
{
    "kretprobe:siphash_1u64": {
        "description": "Compute 64-bit siphash PRF value of a u64",
        "proto": "u64 siphash_1u64(const u64 first, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_1u64": {
        "description": "Compute 64-bit siphash PRF value of a u64.",
        "proto" :"u64 (*siphash_1u64)(const u64 first, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "proto": "u64 (*siphash_2u64)(const u64 first, const u64 second, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_2u64": {
        "description": "Compute 64-bit siphash PRF value of 2 u64",
        "proto" :"u64 (*siphash_2u64)(const u64 first, const u64 second, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "proto" :"u64 siphash_3u64(const u64 first, const u64 second, const u64 third, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "third": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_3u64": {
        "description": "Compute 64-bit siphash PRF value of 3 u64",
        "proto" :"u64 (*siphash_3u64)(const u64 first, const u64 second, const u64 third, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "third": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64 @first: first u64 @second: second u64 @third: third u64 @forth: forth u64 @key: the siphash key",
        "proto" :"u64 siphash_4u64(const u64 first, const u64 second, const u64 third, const u64 forth, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "third": "is u64",
            "forth": "is u64",
            "key": "!=null"
        }
    }
},
{
    "kprobe:siphash_4u64": {
        "description": "Compute 64-bit siphash PRF value of 4 u64.",
        "proto" :"u64 (*siphash_4u64)(const u64 first, const u64 second, const u64 third, const u64 forth, const siphash_key_t *key)",
        "pre": {
            "first": "is u64",
            "second": "is u64",
            "third": "is u64",
            "forth": "is u64",
            "key": "!=null",
        },
    }
},
{
    "kretprobe:hsiphash_1u32": {
        "description": "Compute 64-bit hsiphash PRF value of a u32",
        "proto" :"u32 (*hsiphash_1u32)(const u32 first, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_1u32": {
        "description": "Compute 64-bit hsiphash PRF value of a u32.",
        "proto" :"u32 (*hsiphash_1u32)(const u32 first, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32.",
        "proto" :"u32 (*hsiphash_2u32)(const u32 first, const u32 second, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_2u32": {
        "description": "Compute 32-bit hsiphash PRF value of 2 u32",
        "proto" :"u32 (*hsiphash_2u32)(const u32 first, const u32 second, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "key": "!=null",
        },
    }
},
{
    "kretprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32",
        "proto" :"u32 (*hsiphash_3u32)(const u32 first, const u32 second, const u32 third, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "third": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_3u32": {
        "description": "Compute 32-bit hsiphash PRF value of 3 u32",
        "proto" :"u32 (*hsiphash_3u32)(const u32 first, const u32 second, const u32 third, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "third": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "proto": "u32 (*hsiphash_4u32)(const u32 first, const u32 second, const u32 third, const u32 forth, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "third": "is u32",
            "forth": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kprobe:hsiphash_4u32": {
        "description": "Compute 32-bit hsiphash PRF value of 4 u32",
        "proto" :"u32 (*hsiphash_4u32)(const u32 first, const u32 second, const u32 third, const u32 forth, const hsiphash_key_t *key)",
        "pre": {
            "first": "is u32",
            "second": "is u32",
            "third": "is u32",
            "forth": "is u32",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:textsearch_register": {
        "description": "This function must be called by textsearch modules to announce their presence. The specified &@ops must have %name set to a unique identifier and the callbacks find(), init(), get_pattern(), and get_pattern_len() must be implemented. Returns 0 or -EEXISTS if another module has already registered with same name.",
        "proto" :"int (*textsearch_register)(struct ts_ops *ops)",
        "pre": {
            "ops": "!=null",
            "ops->name": "unique",
            "ops->find": "implemented",
            "ops->init": "implemented",
            "ops->get_pattern": "implemented",
            "ops->get_pattern_len": "implemented"
        },
    }
},
{
    "kprobe:textsearch_register": {
        "description": "This function must be called by textsearch modules to announce their presence. The specified &@ops must have %name set to a unique identifier and the callbacks find(), init(), get_pattern(), and get_pattern_len() must be implemented. Returns 0 or -EEXISTS if another module has already registered with same name.",
        "proto" :"int (*textsearch_register)(struct ts_ops *ops)",
        "pre": {
            "ops": {
                "condition": "!=null",
                "fields": {
                    "name": "!=null",
                    "find": "!=null",
                    "init": "!=null",
                    "get_pattern": "!=null",
                    "get_pattern_len": "!=null"
                }
            }
        }
    }
},
{
    "kretprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module. This function must be called by textsearch modules to announce their disappearance for examples when the module gets unloaded. The &ops parameter must be the same as the one during the registration.",
        "proto" :"int (*textsearch_unregister)(struct ts_ops *ops)",
        "pre": {
            "ops": "!=null"
        },
        "post": {
            "return": "in [0, -ENOENT]"
        }
    }
},
{
    "kprobe:textsearch_unregister": {
        "description": "Unregister a textsearch module. This function must be called by textsearch modules to announce their disappearance for examples when the module gets unloaded. The &ops parameter must be the same as the one during the registration. Returns 0 on success or -ENOENT if no matching textsearch registration was found.",
        "proto" :"int (*textsearch_unregister)(struct ts_ops *ops)",
        "pre": {
            "ops": "!=null"
        },
        "post": {
            "return": "in [0, -ENOENT]"
        }
    }
},
{
    "kretprobe:textsearch_destroy": {
        "description": "Core notifies the algorithm to destroy algorithm specific allocations.",
        "proto" :"void (*textsearch_destroy)(struct ts_config *conf)",
        "pre": {
            "conf": "!=null"
        }
    }
},
{
    "kprobe:textsearch_destroy": {
        "description": "Core notifies the algorithm to destroy algorithm specific allocations. This function is used after a search has been performed and the configuration is no longer needed.",
        "proto" :"static void (*textsearch_destroy)(struct ts_config *conf)",
        "pre": {
            "conf": "!=null"
        }
    }
},
{
    "kretprobe:glob_match": {
        "description": "Perform shell-style glob matching, returning true (1) if the match succeeds, or false (0) if it fails. Equivalent to !fnmatch(@pat, @str, 0).",
        "proto" :"bool __pure (*glob_match)(char const *pat, char const *str)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:glob_match": {
        "description": "Perform shell-style glob matching, returning true (1) if the match succeeds, or false (0) if it fails. Equivalent to !fnmatch(@pat, @str, 0).",
        "proto" :"bool (*glob_match)(char const *pat, char const *str)",
        "pre": {
            "pat": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C. @crc: seed value for computation. ~0 for Ethernet, sometimes 0 for other uses, or the previous crc32crc32c value if computing incrementally. @p: pointer to buffer over which CRC32CRC32C is run @len: length of buffer @p @tab: little-endian Ethernet table @polynomial: CRC32CRC32c LE polynomial",
        "proto" :"static inline u32 __pure crc32_le_generic(u32 crc, unsigned char const *p, size_t len, const u32 (*tab)[256], u32 polynomial)",
        "pre": {
            "crc": "in [0, ~0]",
            "p": "!=null",
            "len": ">=0",
            "tab": "!=null",
            "polynomial": "is a valid CRC32CRC32c LE polynomial"
        }
    }
},
{
    "kprobe:crc32_le_generic": {
        "description": "Calculate bitwise little-endian Ethernet AUTODIN II CRC32CRC32C. @crc: seed value for computation. ~0 for Ethernet, sometimes 0 for other uses, or the previous crc32crc32c value if computing incrementally. @p: pointer to buffer over which CRC32CRC32C is run @len: length of buffer @p @tab: little-endian Ethernet table @polynomial: CRC32CRC32c LE polynomial",
        "proto" :"static inline u32 __pure crc32_le_generic(u32 crc, unsigned char const *p, size_t len, const u32 (*tab)[256], u32 polynomial)",
        "pre": {
            "crc": "in [0, ~0]",
            "p": "!=null",
            "len": ">=0",
            "tab": "!=null",
            "polynomial": "is a valid CRC32CRC32c LE polynomial"
        }
    }
},
{
    "kretprobe:gf2_multiply": {
        "description": "This multiplies the polynomials x and y modulo the given modulus. This follows the 'little-endian' CRC convention that the lsbit represents the highest power of x, and the msbit represents x^0.",
        "proto" :"static u32 __attribute_const__ gf2_multiply(u32 x, u32 y, u32 modulus)",
        "pre": {
            "x": "is a valid u32 value",
            "y": "is a valid u32 value",
            "modulus": "is a valid u32 value"
        },
    }
},
{
    "kprobe:gf2_multiply": {
        "description": "This multiplies the polynomials x and y modulo the given modulus. This follows the 'little-endian' CRC convention that the lsbit represents the highest power of x, and the msbit represents x^0.",
        "proto" :"static u32 __attribute_const__ gf2_multiply(u32 x, u32 y, u32 modulus)",
        "pre": {
            "x": "is a valid u32 value",
            "y": "is a valid u32 value",
            "modulus": "is a valid u32 value and !=0",
        },
    }
},
{
    "kretprobe:iowrite8": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite8(u8 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite8": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite8)(u8 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite16": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite16(u16 val, void __iomem *addr)",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite16": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite16)(u16 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite16be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite16be(u16 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite16be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite16be(u16 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        },
    }
},
{
    "kretprobe:iowrite32": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite32(u32 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite32": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite32(u32 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite32be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite32be)(u32 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite32be": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite32be)(u32 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite64_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64_lo_hi(u64 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite64_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64_lo_hi(u64 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite64_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64_hi_lo(u64 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite64_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64_hi_lo(u64 val, void __iomem *addr)",
        "pre": {
            "val": "is initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite64be_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64be_lo_hi(u64 val, void __iomem *addr)",
        "pre": {
            "val": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite64be_lo_hi": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite64be_lo_hi(u64 val, void __iomem *addr)",
        "pre": {
            "val": "is initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:iowrite64be_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite64be_hi_lo)(u64 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iowrite64be_hi_lo": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*iowrite64be_hi_lo)(u64 val, void __iomem *addr)",
        "pre": {
            "val": "initialized",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:kmsan_unpoison_memory": {
        "description": "KMSAN must treat values read from devices as initialized.",
        "proto" :"void kmsan_unpoison_memory(void *dst, unsigned long count)",
        "pre": {
            "dst": "!=null",
            "count": ">=0"
        }
    },
    "kretprobe:ioread16_rep": {
        "description": "IO_COND(addr, insb(port,dst,count), mmio_insb(addr, dst, count)); KMSAN must treat values read from devices as initialized.",
        "proto" :"void ioread16_rep(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:kmsan_unpoison_memory": {
        "description": "KMSAN must treat values read from devices as initialized.",
        "proto" :"void kmsan_unpoison_memory(void *dst, unsigned long count)",
        "pre": {
            "dst": "!=null",
            "count": ">=0"
        }
    },
    "kprobe:ioread16_rep": {
        "description": "IO_COND(addr, insb(port,dst,count), mmio_insb(addr, dst, count)); KMSAN must treat values read from devices as initialized.",
        "proto" :"void ioread16_rep(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:ioread32_rep": {
        "description": "Reads values from devices and treats them as initialized.",
        "proto" :"void ioread32_rep(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:kmsan_unpoison_memory": {
        "description": "Treats values read from devices as initialized.",
        "proto" :"void kmsan_unpoison_memory(void *dst, unsigned long count)",
        "pre": {
            "dst": "!=null",
            "count": ">=0"
        }
    },
    "kprobe:ioread32_rep": {
        "description": "Reads values from devices.",
        "proto" :"void ioread32_rep(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:ioread32_rep": {
        "description": "Reads values from devices and treats them as initialized.",
        "proto" :"static void (*ioread32_rep)(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:ioread32_rep": {
        "description": "IO_COND(addr, insl(port,dst,count), mmio_insl(addr, dst, count)); KMSAN must treat values read from devices as initialized.",
        "proto" :"ioread32_rep(const void __iomem  addr, void  dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:iowrite8_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check if the memory is initialized.",
        "proto" :"void (*kmsan_check_memory)(const void *src, unsigned long count)",
        "pre": {
            "src": "!=null",
            "count": ">=0"
        }
    },
    "kprobe:IO_COND": {
        "description": "Conditionally execute one of two functions based on the address.",
        "proto" :"void (*IO_COND)(void __iomem *addr, void (*outsb)(int port, const void *src, unsigned long count), void (*mmio_outsb)(void __iomem *addr, const void *src, unsigned long count))",
        "pre": {
            "addr": "!=null",
            "outsb": "!=null",
            "mmio_outsb": "!=null"
        }
    },
    "kprobe:iowrite16_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void (*iowrite16_rep)(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:iowrite16_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:iowrite16_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void (*iowrite16_rep)(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:iowrite32_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:iowrite32_rep": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "src": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:ioport_map": {
        "description": "Maps the specified port.",
        "proto" :"void __iomem (*ioport_map)(unsigned long port, unsigned int nr)",
        "pre": {
            "port": ">=0",
            "nr": ">=0"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(ioport_map)": {
        "description": "Maps the specified I/O port and returns a pointer to the mapped area.",
        "proto" :"static void __iomem *(*ioport_map)(unsigned long port, unsigned int nr)",
        "pre": {
            "port": "!=null",
            "nr": "!=null"
        },
    },
    "kprobe:EXPORT_SYMBOL(ioport_unmap)": {
        "description": "Unmaps the specified I/O port. Does nothing.",
        "proto" :"static void (*ioport_unmap)(void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        },
    }
},

{
    "kprobe:ioport_unmap": {
        "description": "Unmap the I/O port memory pointed by *addr*. Nothing to do.",
        "proto" :"static void (*ioport_unmap)(void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pci_iounmap": {
        "description": "Unmaps the I/O memory mapped by the given address from the PCI device.",
        "proto" :"void (*pci_iounmap)(struct pci_dev *dev, void __iomem *addr)",
        "pre": {
            "dev": "no specific condition",
            "addr": "no specific condition"
        }
    }
},
{
    "kprobe:pci_iounmap": {
        "description": "Unmaps the IO memory mapped by pci_iomap.",
        "proto" :"void pci_iounmap(struct pci_dev *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:strncpy_from_user": {
        "description": "Copy a NUL terminated string from userspace, to the size of the destination buffer, or until a NUL is seen. The destination buffer is always NUL terminated, unless it's zero-sized. Returns the length of the string (not including the final NUL), or -EFAULT (after clearing the destination buffer) if access to userspace fails. If the string is too long for the destination buffer, truncate it, and return the count argument.",
        "proto" :"long strncpy_from_user(char  dst, const char __user  src, unsigned long count, unsigned long max)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0",
            "max": ">=count"
        },
        "post": {
            "return": "in [-EFAULT, count]"
        }
    }
},
{
    "kprobe:strncpy_from_user": {
        "description": "Copies a NUL-terminated string from userspace to kernel space. It stops after finding a NUL and fills the rest of the buffer with NULs. Returns the length of the string (not including the trailing NUL). If the user string is too long, count is returned. If access to userspace fails, -EFAULT is returned.",
        "proto" :"long strncpy_from_user(char *dst, const char __user *src, unsigned long count, unsigned long max)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "count": ">=0",
            "max": ">=count"
        },
    }
},
{
    "kretprobe:xxh32_reset": {
        "description": "Use a local state for memcpy() to avoid strict-aliasing warnings.",
        "proto" :"void xxh32_reset(struct xxh32_state *statePtr, const uint32_t seed)",
        "pre": {
            "statePtr": "!=null",
            "seed": "is uint32_t"
        }
    }
},
{
    "kprobe:xxh32_reset": {
        "description": "Use a local state for memcpy() to avoid strict-aliasing warnings",
        "proto" :"void xxh32_reset(struct xxh32_state *statePtr, const uint32_t seed)",
        "pre": {
            "statePtr": "!=null",
            "seed": "is uint32_t"
        }
    }
},
{
    "kretprobe:xxh64_reset": {
        "description": "Use a local state for memcpy() to avoid strict-aliasing warnings.",
        "proto" :"void xxh64_reset(struct xxh64_state *statePtr, const uint64_t seed)",
        "pre": {
            "statePtr": "!=null",
            "seed": "is uint64_t"
        }
    }
},
{
    "kprobe:xxh64_reset": {
        "description": "Use a local state for memcpy() to avoid strict-aliasing warnings.",
        "proto" :"void xxh64_reset(struct xxh64_state *statePtr, const uint64_t seed)",
        "pre": {
            "statePtr": "!=null",
            "seed": "is uint64_t"
        }
    }
},
{
    "kretprobe:xxh32_update": {
        "description": "Updates the xxh32_state structure with the input data.",
        "proto": "int (*xxh32_update)(struct xxh32_state *state, const void *input, const size_t len)",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": ">=0"
        },
        "post": {
            "state->total_len_32": "old(state->total_len_32) + len",
            "state->large_len": "old(state->large_len) | (len >= 16) | (state->total_len_32 >= 16)",
            "state->memsize": "old(state->memsize) + len < 16 ? old(state->memsize) + len : old(state->memsize)",
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:xxh32_update": {
        "description": "Updates the xxh32_state structure with the given input and length.",
        "proto": "int (*xxh32_update)(struct xxh32_state *state, const void *input, const size_t len)",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": ">=0",
            "state->memsize": ">=0",
            "state->total_len_32": ">=0",
            "state->large_len": "in [0, 1]"
        },
        "post": {
            "state->memsize": "state->memsize@pre + len",
            "state->total_len_32": "state->total_len_32@pre + len",
            "state->large_len": "(len >= 16) | (state->total_len_32 >= 16)"
        }
    }
},
{
    "kretprobe:xxh32_digest": {
        "description": "Provide a description of the function here.",
        "proto" :"static long (*xxh32_digest)(const struct xxh32_state *state)",
        "pre": {
            "state": "!=null",
            "state->mem32": "!=null",
            "state->memsize": ">=0",
            "state->v1": "is a valid 32-bit integer",
            "state->v2": "is a valid 32-bit integer",
            "state->v3": "is a valid 32-bit integer",
            "state->v4": "is a valid 32-bit integer",
            "state->large_len": "is a valid boolean"
        }
    }
},
{
    "kprobe:xxh32_digest": {
        "description": "This function seems to be a part of the XXHash algorithm, specifically the digest function for the 32-bit version. It processes the remaining bytes after the main loop, and then mixes the 4 intermediate values into the final hash.",
        "proto" :"xxh32_digest(const struct xxh32_state *state)",
        "pre": {
            "state": "!=null",
            "state->mem32": "!=null",
            "state->memsize": ">=0",
            "state->v1": "is a valid 32-bit integer",
            "state->v2": "is a valid 32-bit integer",
            "state->v3": "is a valid 32-bit integer",
            "state->v4": "is a valid 32-bit integer",
            "state->large_len": "is a boolean"
        },
    }
},
{
    "kretprobe:xxh64_update": {
        "description": "Updates the xxh64_state with the given input and length. If the total length of the state and the input is less than 32, it fills in the tmp buffer.",
        "proto" :"static int (*xxh64_update)(struct xxh64_state *state, const void *input, size_t len)",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": ">=0",
            "state->memsize": ">=0",
            "state->total_len": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]",
            "state->memsize": "state->memsize@pre + len",
            "state->total_len": "state->total_len@pre + len"
        }
    }
},
{
    "kprobe:xxh64_update": {
        "description": "Updates the xxh64_state with the given input and length. If the total length of the state and the input is less than 32, it fills in the tmp buffer.",
        "proto" :"xxh64_update(struct xxh64_state *state, const void *input, const size_t len)",
        "pre": {
            "state": "!=null",
            "input": "!=null",
            "len": ">=0",
            "state->memsize": ">=0",
            "state->total_len": ">=0",
            "state->mem64": "!=null"
        },
    }
},
{
    "kretprobe:memweight": {
        "description": "Count the total number of bits set in memory area.",
        "proto": "size_t (*memweight)(const void *ptr, size_t bytes)",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:memweight": {
        "description": "Count the total number of bits set in memory area.",
        "proto": "size_t (*memweight)(const void *ptr, size_t bytes)",
        "pre": {
            "ptr": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "proto" :"static inline int any_tag_set(const struct radix_tree_node *node, unsigned int tag)",
        "pre": {
            "node": "!=null",
            "tag": "is unsigned int"
        }
    }
},
{
    "kprobe:any_tag_set": {
        "description": "Returns 1 if any slot in the node has this tag set. Otherwise returns 0.",
        "proto" :"static inline int any_tag_set(const struct radix_tree_node *node,unsigned int tag)",
        "pre": {
            "node": "!=null",
            "tag": "is a valid unsigned integer"
        }
    }
},
{
    "kretprobe:radix_tree_maybe_preload": {
        "description": "Preloads the radix tree if the gfp_mask allows blocking. If preloading doesn't help anything with this gfp mask, it skips it.",
        "proto" :"int radix_tree_maybe_preload(gfp_t gfp_mask)",
        "pre": {
            "gfp_mask": "!=null"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:radix_tree_maybe_preload": {
        "description": "Preloads the radix tree if the gfp mask allows blocking. If preloading doesn't help anything with this gfp mask, it skips it.",
        "proto" :"int radix_tree_maybe_preload(gfp_t gfp_mask)",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "proto" :"int (*radix_tree_insert)(struct radix_tree_root *root, unsigned long index, void *item)",
        "pre": {
            "root": "!=null",
            "index": "is a valid unsigned long",
            "item": "!=null"
        },
    }
},
{
    "kprobe:radix_tree_insert": {
        "description": "Insert an item into the radix tree at position @index.",
        "proto" :"int (*radix_tree_insert)(struct radix_tree_root *root, unsigned long index, void *item)",
        "pre": {
            "root": "!=null",
            "index": "is a valid unsigned long",
            "item": "!=null"
        },
    }
},
{
    "kretprobe:radix_tree_lookup_slot": {
        "description": "radix_tree_replace_slot, otherwise it must be called exclusive from other writers. Any dereference of the slot must be done using radix_tree_deref_slot.",
        "proto" :"void __rcu **radix_tree_lookup_slot(const struct radix_tree_root *root,unsigned long index)",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:radix_tree_lookup_slot": {
        "description": "This function is used to look up a slot in a radix tree. It must be called exclusive from other writers. Any dereference of the slot must be done using radix_tree_deref_slot.",
        "proto" :"void __rcu **radix_tree_lookup_slot(const struct radix_tree_root *root,unsigned long index)",
        "pre": {
            "root": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root. Until there is more than one item in the tree, no nodes are allocated and @root->xa_head is used as a direct slot instead of pointing to a node, in which case @nodep will be NULL.",
        "proto" :"void *__radix_tree_lookup(const struct radix_tree_root *root, unsigned long index, struct radix_tree_node **nodep, void __rcu ***slotp)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "nodep": "can be null",
            "slotp": "can be null"
        },
    }
},
{
    "__radix_tree_lookup": {
        "description": "Lookup and return the item at position @index in the radix tree @root. Until there is more than one item in the tree, no nodes are allocated and @root->xa_head is used as a direct slot instead of pointing to a node, in which case @nodep will be NULL.",
        "proto" :"void * (*__radix_tree_lookup)(const struct radix_tree_root *root, unsigned long index, struct radix_tree_node **nodep, void __rcu ***slotp)",
        "pre": {
            "root": "!=null",
            "index": "is a valid unsigned long",
            "nodep": "can be null or a valid pointer to a struct radix_tree_node pointer",
            "slotp": "can be null or a valid pointer to a void __rcu pointer pointer"
        },
    }
},
{
    "kretprobe:radix_tree_tag_set": {
        "description": "Set the search tag (which must be < RADIX_TREE_MAX_TAGS) corresponding to @index in the radix tree. From the root all the way down to the leaf node. Returns the address of the tagged item. Setting a tag on a not-present item is a bug.",
        "proto" :"void *(*radix_tree_tag_set)(struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "in [0, RADIX_TREE_MAX_TAGS-1]"
        },
    }
},
{
    "kprobe:radix_tree_tag_set": {
        "description": "Set a tag on a radix tree node. From the root all the way down to the leaf node. Returns the address of the tagged item. Setting a tag on a not-present item is a bug.",
        "proto" :"void *(*radix_tree_tag_set)(struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
    }
},
{
    "kretprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node. If this causes the leaf node to have no tags set then clear the tag in the next-to-leaf node, etc. Returns the address of the tagged item on success, else NULL.",
        "proto" :"void *(*radix_tree_tag_clear)(struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "< RADIX_TREE_MAX_TAGS"
        },
    }
},
{
    "kprobe:radix_tree_tag_clear": {
        "description": "Clear a tag on a radix tree node. If this causes the leaf node to have no tags set then clear the tag in the next-to-leaf node, etc. Returns the address of the tagged item on success, else NULL.",
        "proto" :"void *(*radix_tree_tag_clear)(struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "in [0, RADIX_TREE_MAX_TAGS-1]"
        },
    }
},
{
    "kretprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node. Note that the return value of this function may not be relied on, even if the RCU lock is held, unless tag modification and node deletion are excluded from concurrency.",
        "proto": "int radix_tree_tag_get(const struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "in [0, RADIX_TREE_MAX_TAGS-1]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:radix_tree_tag_get": {
        "description": "Get a tag on a radix tree node. Note that the return value of this function may not be relied on, even if the RCU lock is held, unless tag modification and node deletion are excluded from concurrency.",
        "proto" :"int radix_tree_tag_get(const struct radix_tree_root *root, unsigned long index, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "tag": "in [0, RADIX_TREE_MAX_TAGS-1]"
        },
    }
},
{
    "kretprobe:radix_tree_next_chunk": {
        "description": "Find next chunk of slots for iteration. Returns pointer to chunk first slot, or NULL if iteration is over.",
        "proto": "void __rcu **radix_tree_next_chunk(const struct radix_tree_root *root, struct radix_tree_iter *iter, unsigned flags)",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "in [RADIX_TREE_ITER_TAG_MASK, RADIX_TREE_ITER_TAGGED, RADIX_TREE_ITER_CONTIG]"
        }
    }
},
{
    "kprobe:radix_tree_next_chunk": {
        "description": "Find next chunk of slots for iteration. Returns pointer to chunk first slot, or NULL if iteration is over.",
        "proto" :"void __rcu **(*radix_tree_next_chunk)(const struct radix_tree_root *root, struct radix_tree_iter *iter, unsigned flags)",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "flags": "in [RADIX_TREE_ITER_TAG_MASK, RADIX_TREE_ITER_TAGGED, RADIX_TREE_ITER_CONTIG]"
        }
    }
},
{
    "kretprobe:radix_tree_replace_slot": {
        "description": "radix_tree_gang_lookup_tag_slot(). Caller must hold tree write locked across slot lookup and replacement. NOTE: This cannot be used to switch between non-entries (empty slots), regular entries, and value entries, as that requires accounting inside the radix tree node. When switching from one type of entry or deleting, use __radix_tree_lookup() and __radix_tree_replace() or radix_tree_iter_replace().",
        "proto" :"void radix_tree_replace_slot(struct radix_tree_root *root, void __rcu **slot, void *item)",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_replace_slot": {
        "description": "radix_tree_gang_lookup_tag_slot(). Caller must hold tree write locked across slot lookup and replacement. NOTE: This cannot be used to switch between non-entries (empty slots), regular entries, and value entries, as that requires accounting inside the radix tree node. When switching from one type of entry or deleting, use __radix_tree_lookup() and __radix_tree_replace() or radix_tree_iter_replace().",
        "proto" :"void (*radix_tree_replace_slot)(struct radix_tree_root *root, void __rcu **slot, void *item)",
        "pre": {
            "root": "!=null",
            "slot": "!=null",
            "item": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at the position currently pointed to by the iterator. This may result in the current node being freed; if it is, the iterator is advanced so that it will not reference the freed memory. This function may be called without any locking if there are no other threads which can access this tree.",
        "proto" :"void (*radix_tree_iter_delete)(struct radix_tree_root *root, struct radix_tree_iter *iter, void __rcu **slot)",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kprobe:radix_tree_iter_delete": {
        "description": "Delete the entry at the position currently pointed to by the iterator. This may result in the current node being freed; if it is, the iterator is advanced so that it will not reference the freed memory. This function may be called without any locking if there are no other threads which can access this tree.",
        "proto" :"void radix_tree_iter_delete(struct radix_tree_root *root, struct radix_tree_iter *iter, void __rcu **slot)",
        "pre": {
            "root": "!=null",
            "iter": "!=null",
            "slot": "!=null"
        }
    }
},
{
    "kretprobe:radix_tree_delete_item": {
        "description": "Remove @item at @index from the radix tree rooted at @root. Return: the deleted entry, or %NULL if it was not present or the entry at the given @index was not @item.",
        "proto" :"void *(*radix_tree_delete_item)(struct radix_tree_root *root, unsigned long index, void *item)",
        "pre": {
            "root": "!=null",
            "index": ">=0",
            "item": "!=null"
        },
        "post": {
            "return": "in [item, null]"
        }
    }
},
{
    "kprobe:radix_tree_delete_item": {
        "description": "Remove @item at @index from the radix tree rooted at @root. Return: the deleted entry, or %NULL if it was not present or the entry at the given @index was not @item.",
        "proto" :"void *(*radix_tree_delete_item)(struct radix_tree_root *root, unsigned long index, void *item)",
        "pre": {
            "root": "!=null",
            "index": "is a valid unsigned long",
            "item": "!=null or ==null"
        },
    }
},
{
    "kretprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "proto": "int radix_tree_tagged(const struct radix_tree_root *root, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "tag": "is a valid tag"
        }
    }
},
{
    "kprobe:radix_tree_tagged": {
        "description": "Test whether any items in the tree are tagged.",
        "proto": "int radix_tree_tagged(const struct radix_tree_root *root, unsigned int tag)",
        "pre": {
            "root": "!=null",
            "tag": "is a valid tag"
        }
    }
},
{
    "kretprobe:idr_preload": {
        "description": "Preallocate memory to use for the next call to idr_alloc(). This function returns with preemption disabled. It will be enabled by idr_preload_end().",
        "proto" :"void (*idr_preload)(gfp_t gfp_mask)",
        "pre": {
            "gfp_mask": "!=null"
        }
    }
},
{
    "kprobe:idr_preload": {
        "description": "Preallocate memory to use for the next call to idr_alloc(). This function returns with preemption disabled. It will be enabled by idr_preload_end().",
        "proto" :"void (*idr_preload)(gfp_t gfp_mask)",
        "pre": {
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOTRACK_FREE, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
        },
    }
},
{
    "kretprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR. After this function is called, the IDR is empty, and may be reused or the data structure containing it may be freed. A typical clean-up sequence for objects stored in an idr tree will use idr_for_each() to free all objects, if necessary, then idr_destroy() to free the memory used to keep track of those objects.",
        "proto" :"void (*idr_destroy)(struct idr *idr)",
        "pre": {
            "idr": "!=null"
        }
    }
},
{
    "kprobe:idr_destroy": {
        "description": "Release all internal memory from an IDR. After this function is called, the IDR is empty, and may be reused or the data structure containing it may be freed. A typical clean-up sequence for objects stored in an idr tree will use idr_for_each() to free all objects, if necessary, then idr_destroy() to free the memory used to keep track of those objects.",
        "proto" :"void (*idr_destroy)(struct idr *idr)",
        "pre": {
            "idr": "!=null"
        }
    }
},
{
    "kretprobe:merge": {
        "description": "Returns a list organized in an intermediate format suited to chaining of merge() calls: null-terminated, no reserved or sentinel head node, 'prev' links not maintained.",
        "proto" :"__attribute__((nonnull(2,3,4)))static struct list_head *merge(void *priv, list_cmp_func_t cmp, struct list_head *a, struct list_head *b)",
        "pre": {
            "priv": "can be null",
            "cmp": "!=null",
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:merge": {
        "description": "Returns a list organized in an intermediate format suited to chaining of merge() calls: null-terminated, no reserved or sentinel head node, 'prev' links not maintained.",
        "proto" :"__attribute__((nonnull(2,3,4))) static struct list_head *merge(void *priv, list_cmp_func_t cmp, struct list_head *a, struct list_head *b)",
        "pre": {
            "priv": "can be null",
            "cmp": "!=null",
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:argv_free": {
        "description": "Frees an argv and the strings it points to.",
        "proto": "void (*argv_free)(char **argv)",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kprobe:argv_free": {
        "description": "Frees an argv and the strings it points to.",
        "proto": "void (*argv_free)(char **argv)",
        "pre": {
            "argv": "!=null"
        }
    }
},
{
    "kretprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv. The function takes a local copy of the source string to work on, which may be undergoing concurrent alteration via userspace sysctl activity. Returns NULL on memory allocation failure.",
        "proto" :"char **(*argv_split)(gfp_t gfp, const char *str, int *argcp)",
        "pre": {
            "gfp": "is a valid GFP mask",
            "str": "!=null",
            "argcp": "!=null"
        },
        "post": {
            "return": "!=null || (return == null && gfp == GFP_KERNEL)"
        }
    }
},
{
    "kprobe:argv_split": {
        "description": "Split a string at whitespace, returning an argv. This is performed by strictly splitting on white-space; no quote processing is performed. Multiple whitespace characters are considered to be a single argument separator. The returned array is always NULL-terminated. Returns NULL on memory allocation failure. The source string at `str' may be undergoing concurrent alteration via userspace sysctl activity (at least). The argv_split() implementation attempts to handle this gracefully by taking a local copy to work on.",
        "proto" :"char **(*argv_split)(gfp_t gfp, const char *str, int *argcp)",
        "pre": {
            "gfp": "is a valid GFP mask",
            "str": "!=null",
            "argcp": "!=null"
        },
    }
},
{
    "kretprobe:xa_load": {
        "description": "Load an entry from an XArray. @xa: XArray. @index: index into array. Context: Any context. Takes and releases the RCU lock. Return: The entry at @index in @xa.",
        "proto" :"void *(*xa_load)(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kprobe:xa_load": {
        "description": "Load an entry from an XArray. Takes and releases the RCU lock.",
        "proto" :"void *(*xa_load)(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kretprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked. After this function returns, loading from @index will return %NULL. If the index is part of a multi-index entry, all indices will be erased and none of the entries will be part of a multi-index entry.",
        "proto" :"void *__xa_erase(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": "is a valid index in the xarray"
        },
        "post": {
            "return": "is the entry which used to be at this index or null if the index was not part of the xarray"
        }
    }
},
{
    "kprobe:__xa_erase": {
        "description": "Erase this entry from the XArray while locked. After this function returns, loading from @index will return %NULL. If the index is part of a multi-index entry, all indices will be erased and none of the entries will be part of a multi-index entry.",
        "proto" :"void *(*__xa_erase)(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": "is a valid index in the xarray"
        },
    }
},
{
    "kretprobe:__xa_store": {
        "description": "Store this entry in the XArray. You must already be holding the xa_lock when calling this function. It will drop the lock if needed to allocate memory, and then reacquire it afterwards. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: The old entry at this index or xa_err() if an error happened.",
        "proto" :"void *__xa_store(struct xarray *xa, unsigned long index, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:__xa_store": {
        "description": "Store this entry in the XArray. You must already be holding the xa_lock when calling this function. It will drop the lock if needed to allocate memory, and then reacquire it afterwards. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: The old entry at this index or xa_err() if an error happened.",
        "proto" :"void *(*__xa_store)(struct xarray *xa, unsigned long index, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOIO, __GFP_NORECLAIM, __GFP_COMP_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_WRITE_ACCOUNT, __GFP_RECLAIM_ACCOUNT, __GFP_NOLOCKDEP, __GFP_WARN_ON_FAIL, __GFP_IRG_SAFE, __GFP_MEMBARRIER, __GFP_NAKED_RET, __GFP_NO_GFP_WAIT, __GFP_NO_WARN_ON_FAIL, __GFP_NO_PANIC_ON_OOM, __GFP_HARDWALL, __GFP_BITS_MASK]"
        },
    }
},
{
    "kretprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray. You must already be holding the xa_lock when calling this function. It will drop the lock if needed to allocate memory, and then reacquire it afterwards. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: The old entry at this index or xa_err() if an error happened.",
        "proto" :"void *__xa_cmpxchg(struct xarray *xa, unsigned long index, void *old, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "old": "can be null",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:__xa_cmpxchg": {
        "description": "Store this entry in the XArray. You must already be holding the xa_lock when calling this function. It will drop the lock if needed to allocate memory, and then reacquire it afterwards. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: The old entry at this index or xa_err() if an error happened.",
        "proto" :"void *__xa_cmpxchg(struct xarray *xa, unsigned long index, void *old, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "old": "can be null",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present. Inserting a NULL entry will store a reserved entry (like xa_reserve()) if no entry is present. Inserting will fail if a reserved entry is present, even though loading from this index will return NULL. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 if the store succeeded. -EBUSY if another entry was present. -ENOMEM if memory could not be allocated.",
        "proto" :"int (*__xa_insert)(struct xarray *xa, unsigned long index, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOIO, __GFP_NORECLAIM, __GFP_COMP_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_WRITE_ACCOUNT, __GFP_RECLAIM_ACCOUNT, __GFP_NO_GFP_WAIT, __GFP_PERSISTENT]"
        },
        "post": {
            "return": "in [0, -EBUSY, -ENOMEM]"
        }
    }
},
{
    "kprobe:__xa_insert": {
        "description": "Store this entry in the XArray if no entry is present. Inserting a NULL entry will store a reserved entry (like xa_reserve()) if no entry is present. Inserting will fail if a reserved entry is present, even though loading from this index will return NULL. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 if the store succeeded. -EBUSY if another entry was present. -ENOMEM if memory could not be allocated.",
        "proto" :"int (*__xa_insert)(struct xarray *xa, unsigned long index, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "entry": "can be null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOIO, __GFP_NORECLAIM, __GFP_COMP_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_WRITE_ACCOUNT, __GFP_RECLAIM_ACCOUNT, __GFP_NO_GFP_WAIT, __GFP_NOFS, __GFP_NO_KSWAPD]"
        },
    }
},
{
    "kretprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray. After this function returns, loads from any index between @first and @last, inclusive will return @entry. Storing into an existing multi-index entry updates the entry of every index. The marks associated with @index are unaffected unless @entry is %NULL. Context: Process context. Takes and releases the xa_lock. May sleep if the @gfp flags permit. Return: %NULL on success, xa_err(-EINVAL) if @entry cannot be stored in an XArray, or xa_err(-ENOMEM) if memory allocation failed.",
        "proto": "void *(*xa_store_range)(struct xarray *xa, unsigned long first, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "first": ">=0",
            "last": ">=first",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOLOCK, __GFP_NORECLAIM, __GFP_NOTRACK_FREE, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ACCOUNT]"
        }
    }
},
{
    "kprobe:xa_store_range": {
        "description": "Store this entry at a range of indices in the XArray. After this function returns, loads from any index between @first and @last, inclusive will return @entry. Storing into an existing multi-index entry updates the entry of every index. The marks associated with @index are unaffected unless @entry is %NULL. Context: Process context. Takes and releases the xa_lock. May sleep if the @gfp flags permit. Return: %NULL on success, xa_err(-EINVAL) if @entry cannot be stored in an XArray, or xa_err(-ENOMEM) if memory allocation failed.",
        "proto" :"void *(*xa_store_range)(struct xarray *xa, unsigned long first, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "first": ">=0",
            "last": ">=first",
            "entry": "!=null",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]"
        }
    }
},
{
    "kretprobe:xa_get_order": {
        "description": "Get the order of an entry. @xa: XArray. @index: Index of the entry. Return: A number between 0 and 63 indicating the order of the entry.",
        "proto" :"int (*xa_get_order)(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": ">=0"
        },
        "post": {
            "return": "in [0, 63]"
        }
    }
},
{
    "kprobe:xa_get_order": {
        "description": "Get the order of an entry. @xa: XArray. @index: Index of the entry. Return: A number between 0 and 63 indicating the order of the entry.",
        "proto" :"int xa_get_order(struct xarray *xa, unsigned long index)",
        "pre": {
            "xa": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kretprobe:__xa_alloc": {
        "description": "__xa_alloc() - Find somewhere to store this entry in the XArray. @xa: XArray. @id: Pointer to ID. @limit: Range for allocated ID. @entry: New entry. @gfp: Memory allocation flags. Finds an empty entry in @xa between @limit.min and @limit.max, stores the index into the @id pointer, then stores the entry at that index. A concurrent lookup will not see an uninitialised @id. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 on success, -ENOMEM if memory could not be allocated or -EBUSY if there are no free entries in @limit.",
        "proto": "int __xa_alloc(struct xarray *xa, u32 *id, void *entry, struct xa_limit limit, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": "is struct xa_limit with limit.min and limit.max",
            "gfp": "is gfp_t type"
        },
        "post": {
            "return": "in [0, -ENOMEM, -EBUSY]"
        }
    }
},
{
    "__xa_alloc": {
        "description": "Find somewhere to store this entry in the XArray. Finds an empty entry in @xa between @limit.min and @limit.max, stores the index into the @id pointer, then stores the entry at that index. A concurrent lookup will not see an uninitialised @id. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 on success, -ENOMEM if memory could not be allocated or -EBUSY if there are no free entries in @limit.",
        "proto" :"int __xa_alloc(struct xarray *xa, u32 *id, void *entry, struct xa_limit limit, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": "min <= id <= max",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace with actual gfp flags
        },
    }
},
{
    "kretprobe:__xa_alloc_cyclic": {
        "description": "Finds an empty entry in @xa between @limit.min and @limit.max, stores the index into the @id pointer, then stores the entry at that index. A concurrent lookup will not see an uninitialised @id. The search for an empty entry will start at @next and will wrap around if necessary. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 if the allocation succeeded without wrapping. 1 if the allocation succeeded after wrapping, -ENOMEM if memory could not be allocated or -EBUSY if there are no free entries in @limit.",
        "proto" :"int __xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry, struct xa_limit limit, u32 *next, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": "is struct xa_limit with limit.min and limit.max",
            "next": "!=null",
            "gfp": "is gfp_t type"
        },
        "post": {
            "return": "in [0, 1, -ENOMEM, -EBUSY]"
        }
    }
},
{
    "__xa_alloc_cyclic": {
        "description": "Finds an empty entry in @xa between @limit.min and @limit.max, stores the index into the @id pointer, then stores the entry at that index. A concurrent lookup will not see an uninitialised @id. The search for an empty entry will start at @next and will wrap around if necessary. Context: Any context. Expects xa_lock to be held on entry. May release and reacquire xa_lock if @gfp flags permit. Return: 0 if the allocation succeeded without wrapping. 1 if the allocation succeeded after wrapping, -ENOMEM if memory could not be allocated or -EBUSY if there are no free entries in @limit.",
        "proto" :"int __xa_alloc_cyclic(struct xarray *xa, u32 *id, void *entry, struct xa_limit limit, u32 *next, gfp_t gfp)",
        "pre": {
            "xa": "!=null",
            "id": "!=null",
            "entry": "!=null",
            "limit": "!=null",
            "next": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked. Attempting to set a mark on a %NULL entry does not succeed. Context: Any context. Expects xa_lock to be held on entry.",
        "proto" :"void (*__xa_set_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null"
        },
        "post": {
            "xa_lock": "held"
        }
    }
},
{
    "kprobe:__xa_set_mark": {
        "description": "Set this mark on this entry while locked. Attempting to set a mark on a %NULL entry does not succeed. Context: Any context. Expects xa_lock to be held on entry.",
        "proto" :"void (*__xa_set_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null",
            "index": "is a valid unsigned long",
            "mark": "is a valid xa_mark_t",
            "xa_lock": "is held"
        },
    }
},
{
    "kretprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked. @xa: XArray. @index: Index of entry. @mark: Mark number. Context: Any context. Expects xa_lock to be held on entry.",
        "proto" :"void (*__xa_clear_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "mark": "in [0, XA_MAX_MARK]"
        }
    }
},
{
    "kprobe:__xa_clear_mark": {
        "description": "Clear this mark on this entry while locked.",
        "proto" :"void (*__xa_clear_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null",
            "index": "is a valid index in the xarray",
            "mark": "is a valid mark in the xarray",
        },
    }
},
{
    "kretprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry. This function uses the RCU read lock, so the result may be out of date by the time it returns. If you need the result to be stable, use a lock.",
        "proto" :"bool (*xa_get_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null",
            "index": ">=0",
            "mark": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3, XA_MARK_4]"
        },
    }
},
{
    "kprobe:xa_get_mark": {
        "description": "Inquire whether this mark is set on this entry. This function uses the RCU read lock, so the result may be out of date by the time it returns. If you need the result to be stable, use a lock.",
        "proto" :"bool (*xa_get_mark)(struct xarray *xa, unsigned long index, xa_mark_t mark)",
        "pre": {
            "xa": "!=null",
            "index": "is a valid index in the xarray",
            "mark": "is a valid mark in the xarray"
        },
    }
},
{
    "kretprobe:xa_find": {
        "description": "Search the XArray for an entry. Finds the entry in @xa which matches the @filter, and has the lowest index that is at least @indexp and no more than @max. If an entry is found, @indexp is updated to be the index of the entry. This function is protected by the RCU read lock, so it may not find entries which are being simultaneously added. It will not return an %XA_RETRY_ENTRY; if you need to see retry entries, use xas_find(). Context: Any context. Takes and releases the RCU lock. Return: The entry, if found, otherwise %NULL.",
        "proto" :"void *(*xa_find)(struct xarray *xa, unsigned long *indexp, unsigned long max, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3]"
        }
    }
},
{
    "kprobe:xa_find": {
        "description": "Search the XArray for an entry. Finds the entry in @xa which matches the @filter, and has the lowest index that is at least @indexp and no more than @max. If an entry is found, @indexp is updated to be the index of the entry. This function is protected by the RCU read lock, so it may not find entries which are being simultaneously added. It will not return an %XA_RETRY_ENTRY; if you need to see retry entries, use xas_find(). Context: Any context. Takes and releases the RCU lock. Return: The entry, if found, otherwise %NULL.",
        "proto" :"void *(*xa_find)(struct xarray *xa, unsigned long *indexp, unsigned long max, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">= *indexp",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3]"
        },
    }
},
{
    "kretprobe:xa_find_after": {
        "description": "Search the XArray for a present entry. Finds the entry in @xa which matches the @filter and has the lowest index that is above @indexp and no more than @max. If an entry is found, @indexp is updated to be the index of the entry. This function is protected by the RCU read lock, so it may miss entries which are being simultaneously added. It will not return an %XA_RETRY_ENTRY; if you need to see retry entries, use xas_find(). Context: Any context. Takes and releases the RCU lock. Return: The pointer, if found, otherwise %NULL.",
        "proto" :"void *(*xa_find_after)(struct xarray *xa, unsigned long *indexp, unsigned long max, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3]"
        },
    }
},
{
    "kprobe:xa_find_after": {
        "description": "Search the XArray for a present entry. Finds the entry in @xa which matches the @filter and has the lowest index that is above @indexp and no more than @max. If an entry is found, @indexp is updated to be the index of the entry. This function is protected by the RCU read lock, so it may miss entries which are being simultaneously added. It will not return an %XA_RETRY_ENTRY; if you need to see retry entries, use xas_find(). Context: Any context. Takes and releases the RCU lock. Return: The pointer, if found, otherwise %NULL.",
        "proto" :"void *(*xa_find_after)(struct xarray *xa, unsigned long *indexp, unsigned long max, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "indexp": "!=null",
            "max": ">=0",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3]"
        }
    }
},
{
    "kretprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array. The copied entries will have indices between @start and @max, inclusive. The @filter may be an XArray mark value, in which case entries which are marked with that mark will be copied. It may also be %XA_PRESENT, in which case all entries which are not %NULL will be copied. The entries returned may not represent a snapshot of the XArray at a moment in time. If you need stronger guarantees, holding the xa_lock across calls to this function will prevent concurrent modification. Context: Any context. Takes and releases the RCU lock. Return: The number of entries copied.",
        "proto" :"unsigned int (*xa_extract)(struct xarray *xa, void **dst, unsigned long start, unsigned long max, unsigned int n, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=start",
            "n": ">=0",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3, XA_PRESENT]"
        },
    }
},
{
    "kprobe:xa_extract": {
        "description": "Copy selected entries from the XArray into a normal array. The copied entries will have indices between @start and @max, inclusive. The @filter may be an XArray mark value, in which case entries which are marked with that mark will be copied. It may also be %XA_PRESENT, in which case all entries which are not %NULL will be copied.",
        "proto" :"unsigned int (*xa_extract)(struct xarray *xa, void **dst, unsigned long start, unsigned long max, unsigned int n, xa_mark_t filter)",
        "pre": {
            "xa": "!=null",
            "dst": "!=null",
            "start": ">=0",
            "max": ">=start",
            "n": ">=0",
            "filter": "in [XA_MARK_0, XA_MARK_1, XA_MARK_2, XA_MARK_3, XA_PRESENT]"
        },
    }
},
{
    "kretprobe:xa_destroy": {
        "description": "Free all internal data structures. After calling this function, the XArray is empty and has freed all memory allocated for its internal data structures. You are responsible for freeing the objects referenced by the XArray. Context: Any context. Takes and releases the xa_lock, interrupt-safe.",
        "proto" :"void (*xa_destroy)(struct xarray *xa)",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kprobe:xa_destroy": {
        "description": "Free all internal data structures. After calling this function, the XArray is empty and has freed all memory allocated for its internal data structures. You are responsible for freeing the objects referenced by the XArray.",
        "proto" :"void (*xa_destroy)(struct xarray *xa)",
        "pre": {
            "xa": "!=null"
        }
    }
},
{
    "kretprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator. This is used for pseudo-randomness with no outside seeding. For more random results, use get_random_u32().",
        "proto" :"u32 (*prandom_u32_state)(struct rnd_state *state)",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:prandom_u32_state": {
        "description": "Seeded pseudo-random number generator. This is used for pseudo-randomness with no outside seeding. For more random results, use get_random_u32().",
        "proto" :"u32 (*prandom_u32_state)(struct rnd_state *state)",
        "pre": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes. This is used for pseudo-randomness with no outside seeding. For more random results, use get_random_bytes().",
        "proto" :"void (*prandom_bytes_state)(struct rnd_state *state, void *buf, size_t bytes)",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:prandom_bytes_state": {
        "description": "Get the requested number of pseudo-random bytes. This is used for pseudo-randomness with no outside seeding. For more random results, use get_random_bytes().",
        "proto" :"void (*prandom_bytes_state)(struct rnd_state *state, void *buf, size_t bytes)",
        "pre": {
            "state": "!=null",
            "buf": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kretprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler. Add this irq_poll structure to the pending poll list and trigger the raise of the blk iopoll softirq.",
        "proto" :"void (*irq_poll_sched)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_sched": {
        "description": "Schedule a run of the iopoll handler. Add this irq_poll structure to the pending poll list and trigger the raise of the blk iopoll softirq.",
        "proto" :"void (*irq_poll_sched)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again. This function must be called with interrupts disabled.",
        "proto" :"static void (__irq_poll_complete)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:__irq_poll_complete": {
        "description": "Mark this @iop as un-polled again. This function must be called with interrupts disabled.",
        "proto" :"static void (__irq_poll_complete)(struct irq_poll *iop)",
        "pre": {
            "iop": "your_condition_here"
        }
    }
},
{
    "kretprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "proto" :"void (*irq_poll_disable)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_disable": {
        "description": "Disable io polling and wait for any pending callbacks to have completed.",
        "proto" :"void (*irq_poll_disable)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop. Note that the handler run will not be scheduled, it will only mark it as active.",
        "proto" :"void (*irq_poll_enable)(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_enable": {
        "description": "Enable iopoll on this @iop. Note that the handler run will not be scheduled, it will only mark it as active.",
        "proto" :"void irq_poll_enable(struct irq_poll *iop)",
        "pre": {
            "iop": "!=null"
        }
    }
},
{
    "kretprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "proto" :"void (*irq_poll_init)(struct irq_poll *iop, int weight, irq_poll_fn *poll_fn)",
        "pre": {
            "iop": "!=null",
            "weight": ">=0",
            "poll_fn": "!=null"
        }
    }
},
{
    "kprobe:irq_poll_init": {
        "description": "Initialize and enable this irq_poll structure.",
        "proto" :"void irq_poll_init(struct irq_poll *iop, int weight, irq_poll_fn *poll_fn)",
        "pre": {
            "iop": "!=null",
            "weight": ">=0",
            "poll_fn": "!=null"
        }
    }
},
{
    "kretprobe:get_range": {
        "description": "get_options.",
        "proto" :"static int get_range(char **str, int *pint, int n)",
        "pre": {
            "str": "!=null",
            "pint": "!=null",
            "n": ">=0",
        },
    }
},
{
    "kprobe:get_range": {
        "description": "Retrieves a range of values from a string and stores them in an integer array.",
        "proto" :"static int (*get_range)(char **str, int *pint, int n)",
        "pre": {
            "str": "!=null",
            "pint": "!=null",
            "n": ">0",
        },
    }
},
{
    "kretprobe:memparse": {
        "description": "Parses a string with mem suffixes into a number. The number stored at @ptr is potentially suffixed with K, M, G, T, P, E.",
        "proto" :"unsigned long long (*memparse)(const char *ptr, char **retptr)",
        "pre": {
            "ptr": "!=null",
            "retptr": "!=null"
        },
    }
},
{
    "kprobe:memparse": {
        "description": "Parses a string with mem suffixes into a number. The number stored at @ptr is potentially suffixed with K, M, G, T, P, E.",
        "proto" :"unsigned long long (*memparse)(const char *ptr, char **retptr)",
        "pre": {
            "ptr": "!=null",
            "retptr": "can be null or !=null"
        },
    }
},
{
    "kretprobe:next_arg": {
        "description": "Parse the next argument from the input string *args*, storing the parameter name in *param* and the value in *val*. If the value is quoted, remove the quotes.",
        "proto" :"void next_arg(char *args, char **param, char **val)",
        "pre": {
            "args": "!=null",
            "param": "!=null",
            "val": "!=null"
        },
        "post": {
            "param": "!=null",
            "val": "!=null || ==null if no equals sign in args",
            "args": "!=null && no unbalanced quotes"
        }
    }
},
{
    "kprobe:next_arg": {
        "description": "This function processes the next argument from a string of arguments. It handles quoted arguments and separates the argument into a parameter and a value.",
        "proto" :"next_arg(char  args, char   param, char   val)",
        "pre": {
            "args": "!=null",
            "param": "!=null",
            "val": "can be null or !=null",
        },
    }
},
{
    "kretprobe:generate_random_uuid": {
        "description": "Generate a random UUID and put it in *uuid*. Used to create a Boot ID or a filesystem UUIDGUID, but can be useful for other kernel drivers.",
        "proto" :"static void (*generate_random_uuid)(unsigned char uuid[16])",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kprobe:generate_random_uuid": {
        "description": "Generate a random UUID and put it in the specified location. This interface is used to create a Boot ID or a filesystem UUIDGUID, but can also be useful for other kernel drivers.",
        "proto" :"void (*generate_random_uuid)(unsigned char uuid[16])",
        "pre": {
            "uuid": "!=null"
        }
    }
},
{
    "kretprobe:generate_random_guid": {
        "description": "Generate a random GUID and set its version to 4 for truly random generation.",
        "proto" :"void generate_random_guid(unsigned char guid[16])",
        "pre": {
            "guid": "!=null"
        },
        "post": {
            "guid[7]": "in [0x40, 0x4F]"
        }
    }
},
{
    "kprobe:generate_random_guid": {
        "description": "Generate a random GUID and set its version to 4 for truly random generation.",
        "proto" :"void generate_random_guid(unsigned char guid[16])",
        "pre": {
            "guid": "!=null",
        },
        "post": {
            "guid[7]": "(guid[7] & 0x0F) | 0x40"
        }
    }
},
{
    "kretprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid. It checks if the UUID string is following the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where x is a hex digit.",
        "proto" :"bool (*uuid_is_valid)(const char *uuid)",
        "pre": {
            "uuid": "!=null && is a string of format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where x is a hex digit"
        },
        "post": {
            "return": "is a boolean"
        }
    }
},
{
    "kprobe:uuid_is_valid": {
        "description": "Checks if a UUID string is valid. It checks if the UUID string is following the format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where x is a hex digit.",
        "proto" :"bool (*uuid_is_valid)(const char *uuid)",
        "pre": {
            "uuid": "!=null && is a string of format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx where x is a hex digit"
        }
    }
},
{
    "kretprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list. Usually the next entry will be @sg@ + 1, but if this sg element is part of a chained scatterlist, it could jump to the start of a new scatterlist array.",
        "proto" :"struct scatterlist *(*sg_next)(struct scatterlist *sg)",
        "pre": {
            "sg": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sg_next": {
        "description": "Return the next scatterlist entry in a list. Usually the next entry will be @sg@ + 1, but if this sg element is part of a chained scatterlist, it could jump to the start of a new scatterlist array.",
        "proto" :"struct scatterlist *(*sg_next)(struct scatterlist *sg)",
        "pre": {
            "sg": "!=null && is_valid_sg_entry"
        },
    }
},
{
    "kretprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist. Allows to know how many entries are in sg, taking into account chaining as well.",
        "proto" :"int (*sg_nents)(struct scatterlist *sg)",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kprobe:sg_nents": {
        "description": "Return total count of entries in scatterlist. Allows to know how many entries are in sg, taking into account chaining as well.",
        "proto" :"int sg_nents(struct scatterlist *sg)",
        "pre": {
            "sg": "!=null"
        }
    }
},
{
    "kretprobe:sg_nents_for_len": {
        "description": "Determines the number of entries in sg that are required to meet the supplied length, taking into account chaining as well. Returns the number of sg entries needed, negative error on failure.",
        "proto" :"int (*sg_nents_for_len)(struct scatterlist *sg, u64 len)",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kprobe:sg_nents_for_len": {
        "description": "Return total count of entries in scatterlist needed to satisfy the supplied length. Determines the number of entries in sg that are required to meet the supplied length, taking into account chaining as well. Returns the number of sg entries needed, negative error on failure.",
        "proto" :"int (*sg_nents_for_len)(struct scatterlist *sg, u64 len)",
        "pre": {
            "sg": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list. The pointer passed in need not be the first one, the important bit is that nents denotes the number of entries that exist from sgl.",
        "proto" :"struct scatterlist *(*sg_last)(struct scatterlist *sgl, unsigned int nents)",
        "pre": {
            "sgl": "!=null",
            "nents": ">0"
        },
    }
},
{
    "kprobe:sg_last": {
        "description": "Return the last scatterlist entry in a list. Should only be used casually, it (currently) scans the entire list to get the last entry. Note that the @sgl@ pointer passed in need not be the first one, the important bit is that @nents@ denotes the number of entries that exist from @sgl@.",
        "proto" :"struct scatterlist *(*sg_last)(struct scatterlist *sgl, unsigned int nents)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
        },
    }
},
{
    "kretprobe:sg_init_table": {
        "description": "Initialize SG table. If this is part of a chained sg table, sg_mark_end() should be used only on the last table part.",
        "proto" :"void (*sg_init_table)(struct scatterlist *sgl, unsigned int nents)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0"
        }
    }
},
{
    "kprobe:sg_init_table": {
        "description": "Initialize SG table. If this is part of a chained sg table, sg_mark_end() should be used only on the last table part.",
        "proto" :"void (*sg_init_table)(struct scatterlist *sgl, unsigned int nents)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
        },
    }
},
{
    "kretprobe:sg_init_one": {
        "description": "Initialize a single entry sg list @sg: SG entry @buf: Virtual address for IO @buflen: IO length",
        "proto" :"void (*sg_init_one)(struct scatterlist *sg, const void *buf, unsigned int buflen)",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">0"
        }
    }
},
{
    "kprobe:sg_init_one": {
        "description": "Initialize a single entry sg list. @sg: SG entry. @buf: Virtual address for IO. @buflen: IO length.",
        "proto" :"void (*sg_init_one)(struct scatterlist *sg, const void *buf, unsigned int buflen)",
        "pre": {
            "sg": "!=null",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:__sg_free_table": {
        "description": "__sg_alloc_table(). The @max_ents value must be identical to that previously used with __sg_alloc_table().",
        "proto" :"void (*__sg_free_table)(struct sg_table *table, unsigned int max_ents, unsigned int nents_first_chunk, sg_free_fn *free_fn, unsigned int num_ents)",
        "pre": {
            "table": "!=null",
            "max_ents": "is a positive integer and identical to the value used in __sg_alloc_table",
            "nents_first_chunk": "is a positive integer",
            "free_fn": "!=null",
            "num_ents": "is a positive integer"
        },
    }
},
{
    "kprobe:__sg_free_table": {
        "description": "Free the memory allocated by __sg_alloc_table(). The @max_ents value must be identical to that previously used with __sg_alloc_table().",
        "proto" :"void (*__sg_free_table)(struct sg_table *table, unsigned int max_ents, unsigned int nents_first_chunk, sg_free_fn *free_fn, unsigned int num_ents)",
        "pre": {
            "table": "!=null",
            "max_ents": "is a positive integer and identical to the value used in __sg_alloc_table()",
            "nents_first_chunk": "is a positive integer",
            "free_fn": "!=null",
            "num_ents": "is a positive integer"
        },
    }
},
{
    "kretprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "proto" :"void (*sg_free_append_table)(struct sg_append_table *table)",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kprobe:sg_free_append_table": {
        "description": "Free a previously allocated append sg table.",
        "proto" :"void (*sg_free_append_table)(struct sg_append_table *table)",
        "pre": {
            "table": "!=null"
        }
    }
},
{
    "kretprobe:sg_kmalloc": {
        "description": "Allocate a scatterlist using kmalloc. The function is used by sg_alloc_table()",
        "proto" :"static struct scatterlist *sg_kmalloc(unsigned int nents, gfp_t gfp_mask)",
        "pre": {
            "nents": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kprobe:sg_kmalloc": {
        "description": "sg_alloc_table() is to use these kmallockfree helpers.",
        "proto" :"static struct scatterlist *sg_kmalloc(unsigned int nents, gfp_t gfp_mask)",
        "pre": {
            "nents": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_ZERO, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_HIGH, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages. In the first call it allocate and initialize an sg table from a list of pages, else reuse the scatterlist from sgt_append. Contiguous ranges of the pages are squashed into a single scatterlist entry up to the maximum size specified in @max_segment. A user may provide an offset at a start and a size of valid data in a buffer specified by the page array. The returned sg table is released by sg_free_append_table. If this function returns non-0 (eg failure), the caller must call sg_free_append_table() to cleanup any leftover allocations. In the fist call, sgt_append must by initialized.",
        "proto" :"int sg_alloc_append_table_from_pages(struct sg_append_table *sgt_append,struct page **pages, unsigned int n_pages, unsigned int offset,unsigned long size, unsigned int max_segment,unsigned int left_pages, gfp_t gfp_mask)",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">0",
            "offset": ">=0",
            "size": ">0",
            "max_segment": ">0",
            "left_pages": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace with actual GFP flags
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:sg_alloc_append_table_from_pages": {
        "description": "Allocate and initialize an append sg table from an array of pages. In the first call it allocate and initialize an sg table from a list of pages, else reuse the scatterlist from sgt_append. Contiguous ranges of the pages are squashed into a single scatterlist entry up to the maximum size specified in @max_segment. A user may provide an offset at a start and a size of valid data in a buffer specified by the page array. The returned sg table is released by sg_free_append_table. If this function returns non-0 (eg failure), the caller must call sg_free_append_table() to cleanup any leftover allocations. In the fist call, sgt_append must by initialized.",
        "proto" :"int (*sg_alloc_append_table_from_pages)(struct sg_append_table *sgt_append,struct page **pages, unsigned int n_pages, unsigned int offset,unsigned long size, unsigned int max_segment,unsigned int left_pages, gfp_t gfp_mask)",
        "pre": {
            "sgt_append": "!=null",
            "pages": "!=null",
            "n_pages": ">0",
            "offset": ">=0",
            "size": ">0",
            "max_segment": ">0",
            "left_pages": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_COMP, GFP_NOIO, GFP_NOFS, GFP_NOWAIT, GFP_THISNODE, GFP_MOVABLE_MASK, GFP_RECLAIM_MASK, GFP_TRANSHUGE, GFP_TRANSHUGE_LIGHT, GFP_TRANSHUGE_COMP, GFP_HIGHMEM, GFP_ATOMIC_HIGH, GFP_HARDWALL, GFP_DIRECT_RECLAIM, GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment. Contiguous ranges of the pages are squashed into a single scatterlist node up to the maximum size specified in @max_segment. A user may provide an offset at a start and a size of valid data in a buffer specified by the page array. The returned sg table is released by sg_free_table.",
        "proto" :"int (*sg_alloc_table_from_pages_segment)(struct sg_table *sgt, struct page **pages, unsigned int n_pages, unsigned int offset, unsigned long size, unsigned int max_segment, gfp_t gfp_mask)",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">0",
            "offset": ">=0",
            "size": ">0",
            "max_segment": ">0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:sg_alloc_table_from_pages_segment": {
        "description": "Allocate and initialize an sg table from an array of pages and given maximum segment. Contiguous ranges of the pages are squashed into a single scatterlist node up to the maximum size specified in @max_segment. A user may provide an offset at a start and a size of valid data in a buffer specified by the page array. The returned sg table is released by sg_free_table.",
        "proto" :"int (*sg_alloc_table_from_pages_segment)(struct sg_table *sgt, struct page **pages, unsigned int n_pages, unsigned int offset, unsigned long size, unsigned int max_segment, gfp_t gfp_mask)",
        "pre": {
            "sgt": "!=null",
            "pages": "!=null",
            "n_pages": ">0",
            "offset": ">=0",
            "size": ">0",
            "max_segment": ">0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages. Returns a pointer to an initialized scatterlist or %NULL upon failure.",
        "proto" :"struct scatterlist *(*sgl_alloc_order)(unsigned long long length, unsigned int order, bool chainable, gfp_t gfp, unsigned int *nent_p)",
        "pre": {
            "length": "> 0",
            "order": ">= 0",
            "chainable": "in [true, false]",
            "gfp": ">= 0",
            "nent_p": "!=null"
        },
    }
},
{
    "kprobe:sgl_alloc_order": {
        "description": "Allocate a scatterlist and its pages. Returns a pointer to an initialized scatterlist or %NULL upon failure.",
        "proto" :"struct scatterlist *(*sgl_alloc_order)(unsigned long long length, unsigned int order, bool chainable, gfp_t gfp, unsigned int *nent_p)",
        "pre": {
            "length": "> 0",
            "order": ">= 0",
            "chainable": "in [true, false]",
            "gfp": ">= 0",
            "nent_p": "!=null"
        },
    }
},
{
    "kretprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages. If several scatterlists have been chained and each chain element is freed separately then it's essential to set nents correctly to avoid that a page would get freed twice. All pages in a chained scatterlist can be freed at once by setting @nents to a high number.",
        "proto" :"void (*sgl_free_n_order)(struct scatterlist *sgl, int nents, int order)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0"
        }
    }
},
{
    "kprobe:sgl_free_n_order": {
        "description": "Free a scatterlist and its pages. If several scatterlists have been chained and each chain element is freed separately then it's essential to set nents correctly to avoid that a page would get freed twice. All pages in a chained scatterlist can be freed at once by setting @nents to a high number.",
        "proto" :"void (*sgl_free_n_order)(struct scatterlist *sgl, int nents, int order)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "order": ">=0",
        },
    }
},
{
    "kretprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages. Returns a pointer to an initialized scatterlist or %NULL upon failure.",
        "proto": "struct scatterlist *(*sgl_alloc)(unsigned long long length, gfp_t gfp, unsigned int *nent_p)",
        "pre": {
            "length": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "nent_p": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:sgl_alloc": {
        "description": "Allocate a scatterlist and its pages. Returns a pointer to an initialized scatterlist or %NULL upon failure.",
        "proto" :"struct scatterlist *(*sgl_alloc)(unsigned long long length, gfp_t gfp, unsigned int *nent_p)",
        "pre": {
            "length": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]", // replace with actual flags
            "nent_p": "!=null",
        },
    }
},
{
    "kretprobe:sg_miter_start": {
        "description": "Starts mapping iterator @miter over a sg list @sgl with number of sg entries @nents.",
        "proto" :"void (*sg_miter_start)(struct sg_mapping_iter *miter, struct scatterlist *sgl, unsigned int nents, unsigned int flags)",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:sg_miter_start": {
        "description": "Starts mapping iterator @miter over a sg list @sgl with number of sg entries @nents.",
        "proto" :"void (*sg_miter_start)(struct sg_mapping_iter *miter, struct scatterlist *sgl, unsigned int nents, unsigned int flags)",
        "pre": {
            "miter": "!=null",
            "sgl": "!=null",
            "nents": ">=0",
            "flags": "in [SG_MITER_ATOMIC, SG_MITER_FROM_SG, SG_MITER_TO_SG]"
        },
    }
},
{
    "kretprobe:sg_miter_skip": {
        "description": "sg_miter_next(), this stops @miter. Context: Don't care. Returns: true if @miter contains the valid mapping. false if end of sg list is reached.",
        "proto" :"bool (*sg_miter_skip)(struct sg_mapping_iter *miter, off_t offset)",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        },
    }
},
{
    "kprobe:sg_miter_skip": {
        "description": "Stops @miter. Returns true if @miter contains the valid mapping. Returns false if end of sg list is reached.",
        "proto" :"bool (*sg_miter_skip)(struct sg_mapping_iter *miter, off_t offset)",
        "pre": {
            "miter": "!=null",
            "offset": ">=0"
        },
    }
},
{
    "kretprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping. On successful return, @miter->page, @miter->addr and @miter->length point to the current mapping. Returns true if @miter contains the next mapping. False if end of sg list is reached.",
        "proto" :"bool (*sg_miter_next)(struct sg_mapping_iter *miter)",
        "pre": {
            "miter": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:sg_miter_next": {
        "description": "Proceeds @miter to the next mapping. @miter should have been started using sg_miter_start(). On successful return, @miter->page, @miter->addr and @miter->length point to the current mapping. May sleep if !SG_MITER_ATOMIC. Returns true if @miter contains the next mapping. false if end of sg list is reached.",
        "proto" :"bool (*sg_miter_next)(struct sg_mapping_iter *miter)",
        "pre": {
            "miter": "!=null"
        },
    }
},
{
    "kretprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_buffer)(struct scatterlist *sgl, unsigned int nents, void *buf, size_t buflen, off_t skip, bool to_buffer)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        }
    }
},
{
    "kprobe:sg_copy_buffer": {
        "description": "Copy data between a linear buffer and an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_buffer)(struct scatterlist *sgl, unsigned int nents, void *buf, size_t buflen, off_t skip, bool to_buffer)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
            "to_buffer": "in [true, false]"
        }
    }
},
{
    "kretprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_from_buffer)(struct scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        },
        "post": {
            "return": "<= buflen"
        }
    }
},
{
    "kprobe:sg_copy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_from_buffer)(struct scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
        },
    }
},
{
    "kretprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_to_buffer)(struct scatterlist *sgl, unsigned int nents, void *buf, size_t buflen)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        },
    }
},
{
    "kprobe:sg_copy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_copy_to_buffer)(struct scatterlist *sgl, unsigned int nents, void *buf, size_t buflen)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kretprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_pcopy_from_buffer)(struct scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        }
    }
},
{
    "kprobe:sg_pcopy_from_buffer": {
        "description": "Copy from a linear buffer to an SG list. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_pcopy_from_buffer)(struct scatterlist *sgl, unsigned int nents, const void *buf, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
        },
    }
},
{
    "kretprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_pcopy_to_buffer)(struct scatterlist *sgl, unsigned int nents, void *buf, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0"
        },
    }
},
{
    "kprobe:sg_pcopy_to_buffer": {
        "description": "Copy from an SG list to a linear buffer. Returns the number of copied bytes.",
        "proto" :"size_t (*sg_pcopy_to_buffer)(struct scatterlist *sgl, unsigned int nents,  void *buf, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buf": "!=null",
            "buflen": ">=0",
            "skip": ">=0",
        },
    }
},
{
    "kretprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list. Returns the number of bytes zeroed.",
        "proto" :"size_t (*sg_zero_buffer)(struct scatterlist *sgl, unsigned int nents, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0"
        },
    }
},
{
    "kprobe:sg_zero_buffer": {
        "description": "Zero-out a part of a SG list. Returns the number of bytes zeroed.",
        "proto" :"size_t (*sg_zero_buffer)(struct scatterlist *sgl, unsigned int nents, size_t buflen, off_t skip)",
        "pre": {
            "sgl": "!=null",
            "nents": ">=0",
            "buflen": ">=0",
            "skip": ">=0",
        },
    }
},
{
    "kretprobe:stmp_clear_poll_bit": {
        "description": "Clear and poll SFTRST",
        "proto" :"int (*stmp_clear_poll_bit)(void __iomem *reset_addr, int STMP_MODULE_SFTRST)",
        "pre": {
            "reset_addr": "!=null",
            "STMP_MODULE_SFTRST": "==[constant value]"
        },
    }
},
{
    "kprobe:stmp_reset_block": {
        "description": "clear and poll SFTRST",
        "proto" :"static int (*stmp_reset_block)(void __iomem *reset_addr)",
        "pre": {
            "reset_addr": "!=null",
        },
    }
},
{
    "kretprobe:stack_depot_set_extra_bits": {
        "description": "Don't set extra bits on empty handles.",
        "proto" :"depot_stack_handle_t stack_depot_set_extra_bits(depot_stack_handle_t handle, unsigned int extra_bits)",
        "pre": {
            "handle": "!=null",
            "extra_bits": "is unsigned int"
        },
    }
},
{
    "kprobe:stack_depot_set_extra_bits": {
        "description": "Don't set extra bits on empty handles.",
        "proto" :"depot_stack_handle_t stack_depot_set_extra_bits(depot_stack_handle_t handle, unsigned int extra_bits)",
        "pre": {
            "handle": "!=null",
            "extra_bits": "is unsigned int"
        }
    }
},
{
    "kretprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "proto": "void *(*mtree_load)(struct maple_tree *mt, unsigned long index)",
        "pre": {
            "mt": "!=null",
            "index": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:mtree_load": {
        "description": "Load a value stored in a maple tree",
        "proto": "void *(*mtree_load)(struct maple_tree *mt, unsigned long index)",
        "pre": {
            "mt": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:mtree_store_range": {
        "description": "Store an entry at a given range. @mt: The maple tree @index: The start of the range @last: The end of the range @entry: The entry to store @gfp: The GFP_FLAGS to use for allocations. Return: 0 on success, -EINVAL on invalid request, -ENOMEM if memory could not be allocated.",
        "proto" :"int (*mtree_store_range)(struct maple_tree *mt, unsigned long index, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "index": ">=0",
            "last": ">=index",
            "entry": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_NOFS, GFP_NOIO, GFP_NOWAIT]"
        },
    }
},
{
    "kprobe:mtree_store_range": {
        "description": "Store an entry at a given range. @mt: The maple tree @index: The start of the range @last: The end of the range @entry: The entry to store @gfp: The GFP_FLAGS to use for allocations. Return: 0 on success, -EINVAL on invalid request, -ENOMEM if memory could not be allocated.",
        "proto" :"int (*mtree_store_range)(struct maple_tree *mt, unsigned long index, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "index": "is a valid unsigned long value",
            "last": "is a valid unsigned long value and >= index",
            "entry": "!=null",
            "gfp": "is a valid gfp_t value",
        },
    }
},
{
    "kretprobe:mtree_insert_range": {
        "description": "Insert an entry at a given range if there is no value. Return: 0 on success, -EEXISTS if the range is occupied, -EINVAL on invalid request, -ENOMEM if memory could not be allocated.",
        "proto" :"int mtree_insert_range(struct maple_tree *mt, unsigned long first, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "first": "is a valid unsigned long",
            "last": "is a valid unsigned long and >= first",
            "entry": "!=null",
            "gfp": "is a valid gfp_t"
        },
        "post": {
            "return": "in [0, -EEXISTS, -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:mtree_insert_range": {
        "description": "Insert an entry at a given range if there is no value. Returns 0 on success, -EEXISTS if the range is occupied, -EINVAL on invalid request, -ENOMEM if memory could not be allocated.",
        "proto" :"int (*mtree_insert_range)(struct maple_tree *mt, unsigned long first, unsigned long last, void *entry, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "first": ">=0",
            "last": ">=first",
            "entry": "!=null",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]"
        },
    }
},
{
    "kretprobe:mtree_alloc_range": {
        "description": "This function allocates a range in the maple tree. If there is no memory, it retries. If there is an error, it returns the error. Otherwise, it sets the start pointer to the index and unlocks the tree.",
        "proto" :"int mtree_alloc_range(struct maple_tree *mt, unsigned long *startp, void *entry, unsigned long size, unsigned long min, unsigned long max, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": ">0",
            "min": ">=0",
            "max": ">min",
            "gfp": "is valid gfp_t value"
        },
        "post": {
            "ret": "in [-EINVAL, 0]",
            "startp": "!=null"
        }
    }
},
{
    "kprobe:mtree_alloc_range": {
        "description": "This function allocates a range in a maple tree. If there's no memory, it retries. If there's an error, it returns the error. Otherwise, it sets the start pointer to the index and unlocks the tree.",
        "proto" :"mtree_alloc_range(struct maple_tree  mt, unsigned long  startp,void  entry, unsigned long size, unsigned long min,unsigned long max, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": ">=0",
            "min": ">=0",
            "max": ">=min",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:mtree_alloc_rrange": {
        "description": "Allocates a range in the maple tree. If mas_nomem() releases the lock, causing the allocated area to be unavailable, it tries to allocate a free area again.",
        "proto" :"int mtree_alloc_rrange(struct maple_tree *mt, unsigned long *startp, void *entry, unsigned long size, unsigned long min, unsigned long max, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null",
            "size": "[CONDITION]",
            "min": "[CONDITION]",
            "max": "[CONDITION]",
            "gfp": "[CONDITION]"
        },
    }
},
{
    "kprobe:mtree_alloc_rrange": {
        "description": "Allocates a range in the maple tree. If the allocation fails due to lack of memory, it retries. If the allocated area becomes unavailable due to the lock being released, it tries to allocate a free area again.",
        "proto" :"int mtree_alloc_rrange(struct maple_tree *mt, unsigned long *startp, void *entry, unsigned long size, unsigned long min, unsigned long max, gfp_t gfp)",
        "pre": {
            "mt": "!=null",
            "startp": "!=null",
            "entry": "!=null && !mt_is_reserved(entry)",
            "size": ">=0",
            "min": ">=0",
            "max": ">=min",
            "gfp": "valid gfp_t value",
            "mt": "mt_is_alloc(mt)"
        },
    }
},
{
    "kretprobe:mtree_erase": {
        "description": "Find an index and erase the entire range. Erasing is the same as a walk to an entry then a store of a NULL to that ENTIRE range. In fact, it is implemented as such using the advanced API.",
        "proto" :"void *(*mtree_erase)(struct maple_tree *mt, unsigned long index)",
        "pre": {
            "mt": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kprobe:mtree_erase": {
        "description": "Find an index and erase the entire range. Erasing is the same as a walk to an entry then a store of a NULL to that ENTIRE range. In fact, it is implemented as such using the advanced API.",
        "proto" :"void *(*mtree_erase)(struct maple_tree *mt, unsigned long index)",
        "pre": {
            "mt": "!=null",
            "index": "is a valid index in the maple tree"
        },
    }
},
{
    "kretprobe:mtree_destroy": {
        "description": "Destroy a maple tree. Frees all resources used by the tree. Handles locking.",
        "proto": "void (*mtree_destroy)(struct maple_tree *mt)",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kprobe:mtree_destroy": {
        "description": "Destroy a maple tree. Frees all resources used by the tree. Handles locking.",
        "proto" :"static void (*mtree_destroy)(struct maple_tree *mt)",
        "pre": {
            "mt": "!=null"
        }
    }
},
{
    "kretprobe:mt_find": {
        "description": "Search from the start up until an entry is found. @mt: The maple tree @index: Pointer which contains the start location of the search @max: The maximum value to check. Handles locking. @index will be incremented to one beyond the range. Return: The entry at or after the @index or %NULL",
        "proto" :"void *(*mt_find)(struct maple_tree *mt, unsigned long *index, unsigned long max)",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": ">=0"
        },
    }
},
{
    "kprobe:mt_find": {
        "description": "Search from the start up until an entry is found. @mt: The maple tree @index: Pointer which contains the start location of the search @max: The maximum value to check. Handles locking. @index will be incremented to one beyond the range. Return: The entry at or after the @index or %NULL",
        "proto" :"void *(*mt_find)(struct maple_tree *mt, unsigned long *index, unsigned long max)",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": "is a positive integer"
        },
    }
},
{
    "kretprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found. Handles locking, detects wrapping on index == 0. Returns the entry at or after the @index or %NULL.",
        "proto" :"void *(*mt_find_after)(struct maple_tree *mt, unsigned long *index, unsigned long max)",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": ">=0"
        },
        "post": {
            "return": "in [!=null, null]"
        }
    }
},
{
    "kprobe:mt_find_after": {
        "description": "Search from the start up until an entry is found. Handles locking, detects wrapping on index == 0. Returns the entry at or after the @index or %NULL.",
        "proto" :"void *(*mt_find_after)(struct maple_tree *mt, unsigned long *index, unsigned long max)",
        "pre": {
            "mt": "!=null",
            "index": "!=null",
            "max": ">=0",
        },
    }
},
{
    "kretprobe:errseq_set": {
        "description": "Set a errseq_t for later reporting. This function sets the error in @eseq, and increments the sequence counter if the last sequence was sampled at some point in the past. Any error set will always overwrite an existing error.",
        "proto" :"errseq_t (*errseq_set)(errseq_t *eseq, int err)",
        "pre": {
            "eseq": "!=null",
            "err": "in [-1, -MAX_ERRNO]"
        },
        "post": {
            "return": "is int"
        }
    }
},
{
    "kprobe:errseq_set": {
        "description": "Set a errseq_t for later reporting. This function sets the error in @eseq, and increments the sequence counter if the last sequence was sampled at some point in the past. Any error set will always overwrite an existing error. The return value should not be used as a previously sampled value in later calls as it will not have the SEEN flag set.",
        "proto" :"errseq_t (*errseq_set)(errseq_t *eseq, int err)",
        "pre": {
            "eseq": "!=null",
            "err": "in [-1, -MAX_ERRNO]"
        },
    }
},
{
    "kretprobe:errseq_sample": {
        "description": "Grab current errseq_t value. This function allows callers to initialise their errseq_t variable. If the error has been 'seen', new callers will not see an old error. If there is an unseen error in @eseq, the caller of this function will see it the next time it checks for an error.",
        "proto" :"errseq_t (*errseq_sample)(errseq_t *eseq)",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kprobe:errseq_sample": {
        "description": "Grab current errseq_t value. This function allows callers to initialise their errseq_t variable. If the error has been 'seen', new callers will not see an old error. If there is an unseen error in @eseq, the caller of this function will see it the next time it checks for an error.",
        "proto" :"errseq_t (*errseq_sample)(errseq_t *eseq)",
        "pre": {
            "eseq": "!=null"
        }
    }
},
{
    "kretprobe:errseq_check": {
        "description": "Check if an error has occurred since a particular sample point. Grab the value that eseq points to, and see if it has changed since the given value was sampled. The since value is not advanced, so there is no need to mark the value as seen.",
        "proto" :"int (*errseq_check)(errseq_t *eseq, errseq_t since)",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [0, latest error set in the errseq_t]"
        }
    }
},
{
    "kprobe:errseq_check": {
        "description": "Has an error occurred since a particular sample point? Grab the value that eseq points to, and see if it has changed since the given value was sampled. The since value is not advanced, so there is no need to mark the value as seen. Return: The latest error set in the errseq_t or 0 if it hasn't changed.",
        "proto" :"int (*errseq_check)(errseq_t *eseq, errseq_t since)",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        }
    }
},
{
    "kretprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value. Grab the eseq value, and see whether it matches the value that @since points to. If it does, then just return 0. If it doesn't, then the value has changed. Set the 'seen' flag, and try to swap it into place as the new eseq value. Then, set that value as the new 'since' value, and return whatever the error portion is set to. Note that no locking is provided here for concurrent updates to the 'since' value. The caller must provide that if necessary. Because of this, callers may want to do a lockless errseq_check before taking the lock and calling this. Return: Negative errno if one has been stored, or 0 if no new error has occurred.",
        "proto" :"int (*errseq_check_and_advance)(errseq_t *eseq, errseq_t *since)",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:errseq_check_and_advance": {
        "description": "Check an errseq_t and advance to current value. Grab the eseq value, and see whether it matches the value that @since points to. If it does, then just return 0. If it doesn't, then the value has changed. Set the 'seen' flag, and try to swap it into place as the new eseq value. Then, set that value as the new 'since' value, and return whatever the error portion is set to. Note that no locking is provided here for concurrent updates to the 'since' value. The caller must provide that if necessary. Because of this, callers may want to do a lockless errseq_check before taking the lock and calling this. Return: Negative errno if one has been stored, or 0 if no new error has occurred.",
        "proto" :"int errseq_check_and_advance(errseq_t *eseq, errseq_t *since)",
        "pre": {
            "eseq": "!=null",
            "since": "!=null"
        },
    }
},
{
    "kretprobe:lc_create": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on success, or NULL on (allocation) failure.",
        "proto" :"struct lru_cache *(*lc_create)(const char *name, struct kmem_cache *cache, unsigned max_pending_changes, unsigned e_count, size_t e_size, size_t e_off)",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">0",
            "e_off": ">=0"
        },
    }
},
{
    "kprobe:lc_create": {
        "description": "Returns a pointer to a newly initialized struct lru_cache on success, or NULL on (allocation) failure.",
        "proto" :"struct lru_cache *(*lc_create)(const char *name, struct kmem_cache *cache, unsigned max_pending_changes, unsigned e_count, size_t e_size, size_t e_off)",
        "pre": {
            "name": "!=null",
            "cache": "!=null",
            "max_pending_changes": ">=0",
            "e_count": ">=0",
            "e_size": ">0",
            "e_off": ">=0"
        },
    }
},
{
    "kretprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots. It is roughly the equivalent of re-allocating a fresh lru_cache object, basically a short cut to lc_destroy(lc); lc = lc_create(...);",
        "proto" :"void (*lc_reset)(struct lru_cache *lc)",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_reset": {
        "description": "Does a full reset for @lc and the hash table slots. It is roughly the equivalent of re-allocating a fresh lru_cache object, basically a short cut to lc_destroy(lc); lc = lc_create(...);",
        "proto" :"void lc_reset(struct lru_cache *lc)",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create()",
        "proto": "void (*lc_destroy)(struct lru_cache *lc)",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kprobe:lc_destroy": {
        "description": "Frees memory allocated by lc_create()",
        "proto": "void lc_destroy(struct lru_cache *lc)",
        "pre": {
            "lc": "!=null"
        }
    }
},
{
    "kretprobe:lc_del": {
        "description": "Removes an element from the cache. The element must be unused (refcnt == 0). Moves the element from 'lru' to 'free' list, and sets the element's 'enr' to LC_FREE.",
        "proto" :"void (*lc_del)(struct lru_cache *lc, struct lc_element *e)",
        "pre": {
            "lc": "!=null",
            "e": "!=null && e->refcnt == 0"
        },
    }
},
{
    "kprobe:lc_del": {
        "description": "Removes an element from the cache. The element must be unused (refcnt == 0). Moves the element from 'lru' to 'free' list, sets the element's 'enr' to LC_FREE.",
        "proto": "void lc_del(struct lru_cache *lc, struct lc_element *e)",
        "pre": {
            "lc": "!=null",
            "e": "!=null",
            "e->refcnt": "==0"
        }
    }
},
{
    "kretprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set. Finds an element in the cache, increases its usage count, 'touches' and returns it.",
        "proto" :"struct lc_element *(*lc_try_get)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is unsigned int"
        },
        "post": {
            "return": "in [null, pointer to lc_element]"
        }
    }
},
{
    "kprobe:lc_try_get": {
        "description": "Get element by label, if present; do not change the active set. Finds an element in the cache, increases its usage count, 'touches' and returns it.",
        "proto" :"struct lc_element *(*lc_try_get)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is unsigned int"
        },
        "post": {
            "return": "in [null, pointer to lc_element]"
        }
    }
},
{
    "kretprobe:lc_find": {
        "description": "Finds an element by label, if present in the hash table. Returns the pointer to an element, if the element with the requested label or element number is present in the hash table, or NULL if not found. Does not change the refcnt. Ignores elements that are about to be used, i.e. not yet in the active set, but still pending transaction commit.",
        "proto" :"lc_find(struct lru_cache *lc, unsigned int enr, bool include_changing)",
        "pre": {
            "lc": "!=null",
            "enr": ">=0",
            "include_changing": "in [true, false]"
        }
    }
},
{
    "kprobe:lc_find": {
        "description": "Finds an element by label, if present in the hash table. Returns the pointer to an element, if the element with the requested label or element number is present in the hash table, or NULL if not found. Does not change the refcnt. Ignores elements that are about to be used, i.e. not yet in the active set, but still pending transaction commit.",
        "proto" :"lc_find(struct lru_cache  lc, unsigned int enr,bool include_changing)",
        "pre": {
            "lc": "!=null",
            "enr": "is a valid unsigned int",
            "include_changing": "is a valid boolean",
        },
    }
},
{
    "kretprobe:seq_printf": {
        "description": "Prints the cache statistics to a sequence. The statistics include the name, usage, number of elements, hits, misses, starving, locked, and changed counts.",
        "proto": "int seq_printf(struct seq_file *seq, const char *fmt, ...)",
        "pre": {
            "seq": "!=null",
            "fmt": "!=null"
        }
    },
    "kretprobe:lc_hash_slot": {
        "description": "Returns a pointer to the hash slot in the LRU cache for a given entry number. The 'starving', 'hits', 'misses', 'locked', and 'changed' counts are used to update the cache.",
        "proto": "static struct hlist_head *lc_hash_slot(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": ">=0",
            "lc->starving": ">=0",
            "lc->hits": ">=0",
            "lc->misses": ">=0",
            "lc->locked": ">=0",
            "lc->changed": ">=0"
        }
    }
},
{
    "kprobe:seq_printf": {
        "description": "Prints formatted output to a sequence.",
        "proto": "int seq_printf(struct seq_file *seq, const char *fmt, ...)",
        "pre": {
            "seq": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:lc_put": {
        "description": "Give up refcnt of @e. If refcnt reaches zero, the element is moved to the lru list, and a %LC_STARVING (if set) is cleared. Returns the new (post-decrement) refcnt.",
        "proto" :"unsigned int (*lc_put)(struct lru_cache *lc, struct lc_element *e)",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:lc_put": {
        "description": "Give up refcnt of @e. If refcnt reaches zero, the element is moved to the lru list, and a %LC_STARVING (if set) is cleared. Returns the new (post-decrement) refcnt.",
        "proto" :"unsigned int (*lc_put)(struct lru_cache *lc, struct lc_element *e)",
        "pre": {
            "lc": "!=null",
            "e": "!=null"
        }
    }
},
{
    "kretprobe:lc_get": {
        "description": "lc_committed(lc) and lc_unlock(), to finish the change. NOTE: The user needs to check the lc_number on EACH use, so he recognizes any cache set change.",
        "proto" :"struct lc_element *(*lc_get)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is unsigned int"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:lc_get": {
        "description": "lc_committed(lc) and lc_unlock(), to finish the change. NOTE: The user needs to check the lc_number on EACH use, so he recognizes any cache set change.",
        "proto" :"struct lc_element *(*lc_get)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null && !is_locked",
            "enr": "is_valid_enr",
        },
    }
},
{
    "kretprobe:lc_element_by_index": {
        "description": "@lc: the lru cache to operate on   @i: the index of the element to return",
        "proto" :"struct lc_element *(*lc_element_by_index)(struct lru_cache *lc, unsigned i)",
        "pre": {
            "lc": "!=null",
            "i": ">=0"
        },
    }
},
{
    "kprobe:lc_element_by_index": {
        "description": "Returns the element at the given index in the lru cache.",
        "proto" :"struct lc_element *(*lc_element_by_index)(struct lru_cache *lc, unsigned i)",
        "pre": {
            "lc": "!=null",
            "i": ">=0 && < lc->nr_elements"
        }
    }
},
{
    "kretprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "proto" :"lc_try_lock(struct lru_cache  *lc)",
        "pre": {
            "lc": "!=null"
        },
    }
},
{
    "kprobe:lc_try_lock": {
        "description": "Spin until no-one is inside a PARANOIA_ENTRY()RETURN() section.",
        "proto" :"lc_try_lock(struct lru_cache  lc)",
        "pre": {
            "lc": "!=null"
        },
    }
},
{
    "kretprobe:lc_is_used": {
        "description": "Find element by label. Returns true, if the element with the requested 'label' or element number is present in the hash table, and is used (refcnt > 0). Also finds elements that are not _currently_ used but only 'about to be used', i.e. on the 'to_be_changed' list, pending transaction commit.",
        "proto" :"bool (*lc_is_used)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is a valid unsigned integer"
        },
    }
},
{
    "kprobe:lc_is_used": {
        "description": "Find element by label. Returns true, if the element with the requested 'label' or element number is present in the hash table, and is used (refcnt > 0). Also finds elements that are not _currently_ used but only 'about to be used', i.e. on the 'to_be_changed' list, pending transaction commit.",
        "proto" :"bool (*lc_is_used)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is a valid unsigned integer"
        },
    }
},
{
    "kretprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements. Unlike lc_get this also returns the element for @enr, if it is belonging to a pending transaction, so the return values are like for lc_get(), plus: pointer to an element already on the 'to_be_changed' list. In this case, the cache was already marked %LC_DIRTY. Caller needs to make sure that the pending transaction is completed, before proceeding to actually use this element.",
        "proto" :"struct lc_element *(*lc_get_cumulative)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is a valid unsigned integer"
        },
        "post": {
            "return": "!=null && is a valid pointer to lc_element"
        }
    }
},
{
    "kprobe:lc_get_cumulative": {
        "description": "Like lc_get; also finds to-be-changed elements. Returns the element for @enr, if it is belonging to a pending transaction. The cache was already marked %LC_DIRTY. Caller needs to make sure that the pending transaction is completed, before proceeding to actually use this element.",
        "proto" :"struct lc_element *(*lc_get_cumulative)(struct lru_cache *lc, unsigned int enr)",
        "pre": {
            "lc": "!=null",
            "enr": "is unsigned int"
        },
    }
},
{
    "kretprobe:__do_once_start": {
        "description": "Locks the once_lock and checks if the operation is done. If done, it unlocks the once_lock and returns early in the DO_ONCE() macro.",
        "proto" :"bool (*__do_once_start)(bool done, unsigned long flags)",
        "pre": {
            "done": "is [true, false]",
            "flags": ">= 0"
        },
    }
},
{
    "__do_once_start": {
        "description": "Acquires a lock and checks if a task is done. If the task is done, it releases the lock and returns early in the DO_ONCE() macro.",
        "proto" :"__do_once_start(bool done, unsigned long flags)__acquires(once_lock)",
        "pre": {
            "done": "is bool",
            "flags": "is unsigned long",
        },
    }
},
{
    "kretprobe:__do_once_done": {
        "description": "__do_once_done but return early in the DO_ONCE() macro.",
        "proto" :"void __do_once_done(bool *done, struct static_key_true *once_key, unsigned long *flags, struct module *mod)",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null"
        }
    }
},
{
    "__acquire:__do_once_done": {
        "description": "__do_once_done but return early in the DO_ONCE() macro.",
        "proto" :"void __do_once_done(bool *done, struct static_key_true *once_key, unsigned long *flags, struct module *mod)__releases(once_lock)",
        "pre": {
            "done": "!=null",
            "once_key": "!=null",
            "flags": "!=null",
            "mod": "!=null"
        },
    }
},
{
    "kretprobe:__do_once_sleepable_start": {
        "description": "Acquires a mutex lock and checks if a task is done.",
        "proto" :"static bool (*__do_once_sleepable_start)(bool done)",
        "pre": {
            "done": "in [true, false]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "__do_once_sleepable_start": {
        "description": "Locks the mutex if not done. If done, unlocks the mutex and returns early in the DO_ONCE_SLEEPABLE() macro.",
        "proto" :"__do_once_sleepable_start(bool done)__acquires(once_mutex)",
        "pre": {
            "done": "is [true, false]"
        },
    }
},
{
    "kretprobe:gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmallockfree interface.",
        "proto" :"struct gen_pool *(*gen_pool_create)(int min_alloc_order, int nid)",
        "pre": {
            "min_alloc_order": ">=0",
            "nid": ">=-1"
        },
    }
},
{
    "kprobe:gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmallockfree interface.",
        "proto" :"struct gen_pool *(*gen_pool_create)(int min_alloc_order, int nid)",
        "pre": {
            "min_alloc_order": ">=0",
            "nid": ">=-1",
        },
    }
},
{
    "kretprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the specified pool.",
        "proto" :"int gen_pool_add_owner(struct gen_pool *pool, unsigned long virt, phys_addr_t phys, size_t size, int nid, void *owner)",
        "pre": {
            "pool": "!=null",
            "virt": ">=0",
            "phys": ">=0",
            "size": ">0",
            "nid": ">=-1",
            "owner": "can be null or !=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:gen_pool_add_owner": {
        "description": "Add a new chunk of special memory to the pool.",
        "proto" :"int gen_pool_add_owner(struct gen_pool *pool, unsigned long virt, phys_addr_t phys, size_t size, int nid, void *owner)",
        "pre": {
            "pool": "!=null",
            "virt": ">=0",
            "phys": ">=0",
            "size": ">0",
            "nid": ">=-1",
            "owner": "can be null or !=null"
        },
    }
},
{
    "kretprobe:gen_pool_virt_to_phys": {
        "description": "Returns the physical address of memory from the pool, or -1 on error.",
        "proto" :"phys_addr_t (*gen_pool_virt_to_phys)(struct gen_pool *pool, unsigned long addr)",
        "pre": {
            "pool": "!=null",
            "addr": ">=0"
        },
        "post": {
            "return": ">=0 || ==-1"
        }
    }
},
{
    "kprobe:gen_pool_virt_to_phys": {
        "description": "Return the physical address of memory. Pool to allocate from and starting address of memory are the inputs. Returns the physical address on success, or -1 on error.",
        "proto" :"phys_addr_t (*gen_pool_virt_to_phys)(struct gen_pool *pool, unsigned long addr)",
        "pre": {
            "pool": "!=null",
            "addr": ">=0"
        },
    }
},
{
    "kretprobe:gen_pool_destroy": {
        "description": "Destroy the specified special memory pool. Verifies that there are no outstanding allocations.",
        "proto": "void gen_pool_destroy(struct gen_pool *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_destroy": {
        "description": "Destroy the specified special memory pool. Verifies that there are no outstanding allocations.",
        "proto" :"void (*gen_pool_destroy)(struct gen_pool *pool)",
        "pre": {
            "pool": "!=null && no outstanding allocations"
        }
    }
},
{
    "kretprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate the requested number of bytes from the specified pool. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"unsigned long (*gen_pool_alloc_algo_owner)(struct gen_pool *pool, size_t size, genpool_algo_t algo, void *data, void **owner)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "algo": "!=null",
            "data": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:gen_pool_alloc_algo_owner": {
        "description": "Allocate the requested number of bytes from the specified pool. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"unsigned long (*gen_pool_alloc_algo_owner)(struct gen_pool *pool, size_t size, genpool_algo_t algo, void *data, void **owner)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "algo": "!=null",
            "data": "can be null",
            "owner": "can be null"
        },
    }
},
{
    "kretprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_alloc)(struct gen_pool *pool, size_t size, dma_addr_t *dma)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "!=null || ==null"
        },
    }
},
{
    "kprobe:gen_pool_dma_alloc": {
        "description": "Allocate special memory from the pool for DMA usage. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_alloc)(struct gen_pool *pool, size_t size, dma_addr_t *dma)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null or !=null",
        },
    }
},
{
    "kretprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_alloc_algo)(struct gen_pool *pool, size_t size, dma_addr_t *dma, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "algo": "!=null",
            "data": "can be null"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_algo": {
        "description": "Allocate special memory from the pool for DMA usage with the given pool algorithm.",
        "proto": "void *(*gen_pool_dma_alloc_algo)(struct gen_pool *pool, size_t size, dma_addr_t *dma, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "algo": "!=null",
            "data": "can be null"
        },
    }
},
{
    "kretprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate the requested number bytes from the specified pool, with the given alignment restriction. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *gen_pool_dma_alloc_align(struct gen_pool *pool, size_t size, dma_addr_t *dma, int align)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "align": ">=1"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:gen_pool_dma_alloc_align": {
        "description": "Allocate the requested number bytes from the specified pool, with the given alignment restriction. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_alloc_align)(struct gen_pool *pool, size_t size, dma_addr_t *dma, int align)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "align": ">=1",
        },
    }
},
{
    "kretprobe:gen_pool_dma_zalloc": {
        "description": "Allocate the requested number of zeroed bytes from the specified pool. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_zalloc)(struct gen_pool *pool, size_t size, dma_addr_t *dma)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null or !=null"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc": {
        "description": "Allocate the requested number of zeroed bytes from the specified pool. Uses the pool allocation function (with first-fit algorithm by default). Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_zalloc)(struct gen_pool *pool, size_t size, dma_addr_t *dma)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null or !=null"
        },
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm",
        "proto" :"void *gen_pool_dma_zalloc_algo(struct gen_pool *pool, size_t size, dma_addr_t *dma, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "algo": "!=null",
            "data": "can be null"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_algo": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given pool algorithm",
        "proto" :"void *(*gen_pool_dma_zalloc_algo)(struct gen_pool *pool, size_t size, dma_addr_t *dma, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null",
            "algo": "!=null",
            "data": "can be null"
        },
    }
},
{
    "kretprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate the requested number of zeroed bytes from the specified pool, with the given alignment restriction. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_zalloc_align)(struct gen_pool *pool, size_t size, dma_addr_t *dma, int align)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null or !=null",
            "align": ">=1"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:gen_pool_dma_zalloc_align": {
        "description": "Allocate special zeroed memory from the pool for DMA usage with the given alignment. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void *(*gen_pool_dma_zalloc_align)(struct gen_pool *pool, size_t size, dma_addr_t *dma, int align)",
        "pre": {
            "pool": "!=null",
            "size": ">0",
            "dma": "can be null or !=null",
            "align": ">=1",
        },
    }
},
{
    "kretprobe:gen_pool_free_owner": {
        "description": "Free previously allocated special memory back to the specified pool. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void (*gen_pool_free_owner)(struct gen_pool *pool, unsigned long addr, size_t size, void **owner)",
        "pre": {
            "pool": "!=null",
            "addr": ">=0",
            "size": ">0",
            "owner": "!=null"
        },
    }
},
{
    "kprobe:gen_pool_free_owner": {
        "description": "Free previously allocated special memory back to the specified pool. Can not be used in NMI handler on architectures without NMI-safe cmpxchg implementation.",
        "proto" :"void gen_pool_free_owner(struct gen_pool *pool, unsigned long addr, size_t size, void **owner)",
        "pre": {
            "pool": "!=null",
            "addr": ">=0",
            "size": ">=0",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:gen_pool_for_each_chunk": {
        "description": "Call @func for every chunk of generic memory pool. The @func is called with rcu_read_lock held.",
        "proto" :"void (*gen_pool_for_each_chunk)(struct gen_pool *pool, void (*func)(struct gen_pool *pool, struct gen_pool_chunk *chunk, void *data), void *data)",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "can be null or !=null"
        }
    }
},
{
    "kprobe:gen_pool_for_each_chunk": {
        "description": "Call func for every chunk of generic memory pool. The func is called with rcu_read_lock held.",
        "proto" :"void (*gen_pool_for_each_chunk)(struct gen_pool *pool, void (*func)(struct gen_pool *pool, struct gen_pool_chunk *chunk, void *data), void *data)",
        "pre": {
            "pool": "!=null",
            "func": "!=null",
            "data": "can be null or !=null",
        },
    }
},
{
    "kretprobe:gen_pool_has_addr": {
        "description": "Check if the range of addresses falls within the specified pool. Returns true if the entire range is contained in the pool and false otherwise.",
        "proto" :"bool (*gen_pool_has_addr)(struct gen_pool *pool, unsigned long start, size_t size)",
        "pre": {
            "pool": "!=null",
            "start": ">=0",
            "size": ">0"
        },
    }
},
{
    "kprobe:gen_pool_has_addr": {
        "description": "Check if the range of addresses falls within the specified pool. Returns true if the entire range is contained in the pool and false otherwise.",
        "proto" :"bool (*gen_pool_has_addr)(struct gen_pool *pool, unsigned long start, size_t size)",
        "pre": {
            "pool": "!=null",
            "start": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm for each memory allocation in the pool. If @algo is NULL, use gen_pool_first_fit as default memory allocation function.",
        "proto" :"void gen_pool_set_algo(struct gen_pool *pool, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "algo": "!=null || ==null",
            "data": "any"
        },
    }
},
{
    "kprobe:gen_pool_set_algo": {
        "description": "Set the allocation algorithm. Call @algo for each memory allocation in the pool. If @algo is NULL use gen_pool_first_fit as default memory allocation function.",
        "proto" :"void gen_pool_set_algo(struct gen_pool *pool, genpool_algo_t algo, void *data)",
        "pre": {
            "pool": "!=null",
            "algo": "!=null || ==null",
            "data": "any"
        },
    }
},
{
    "kretprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region. @map: The address to base the search on. @size: The bitmap size in bits. @start: The bitnumber to start searching at. @nr: The number of zeroed bits we're looking for. @data: data for alignment. @pool: pool to get order from. @start_addr: not used in this function.",
        "proto" :"unsigned long (*gen_pool_fixed_alloc)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null or !=null",
            "pool": "!=null",
            "start_addr": "can be any value, not used in this function"
        }
    }
},
{
    "kprobe:gen_pool_fixed_alloc": {
        "description": "Reserve a specific region. @map: The address to base the search on. @size: The bitmap size in bits. @start: The bitnumber to start searching at. @nr: The number of zeroed bits we're looking for. @data: data for alignment. @pool: pool to get order from. @start_addr: not used in this function.",
        "proto" :"unsigned long (*gen_pool_fixed_alloc)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">=0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null or !=null",
            "pool": "!=null",
            "start_addr": "can be any value, not used in this function"
        }
    }
},
{
    "kretprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "proto" :"unsigned long (*gen_pool_first_fit_order_align)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null",
            "pool": "!=null",
            "start_addr": "can be any value"
        },
    }
},
{
    "kprobe:gen_pool_first_fit_order_align": {
        "description": "Find the first available region of memory matching the size requirement. The region will be aligned to the order of the size specified.",
        "proto" :"unsigned long (*gen_pool_first_fit_order_align)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null",
            "pool": "!=null",
            "start_addr": "can be null"
        },
    }
},
{
    "kretprobe:gen_pool_best_fit": {
        "description": "Iterate over the bitmap to find the smallest free region which we can allocate the memory.",
        "proto" :"unsigned long (*gen_pool_best_fit)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null",
            "pool": "!=null",
            "start_addr": "can be null"
        }
    }
},
{
    "kprobe:gen_pool_best_fit": {
        "description": "Find the best fitting region of memory matching the size requirement (no alignment constraint). Iterate over the bitmap to find the smallest free region which we can allocate the memory.",
        "proto" :"unsigned long (*gen_pool_best_fit)(unsigned long *map, unsigned long size, unsigned long start, unsigned int nr, void *data, struct gen_pool *pool, unsigned long start_addr)",
        "pre": {
            "map": "!=null",
            "size": ">0",
            "start": ">=0",
            "nr": ">=0",
            "data": "can be null",
            "pool": "!=null",
            "start_addr": "can be null"
        },
    }
},
{
    "kretprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmallockfree interface. The pool will be automatically destroyed by the device management code.",
        "proto" :"struct gen_pool *(*devm_gen_pool_create)(struct device *dev, int min_alloc_order, int nid, const char *name)",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": "in [0, NUMA_MAX_NODE] or == NUMA_NO_NODE",
            "name": "!=null or ==null"
        },
    }
},
{
    "kprobe:devm_gen_pool_create": {
        "description": "Create a new special memory pool that can be used to manage special purpose memory not managed by the regular kmallockfree interface. The pool will be automatically destroyed by the device management code.",
        "proto" :"struct gen_pool *(*devm_gen_pool_create)(struct device *dev, int min_alloc_order, int nid, const char *name)",
        "pre": {
            "dev": "!=null",
            "min_alloc_order": ">=0",
            "nid": "in [0, NUMA_MAX_NODE] or == NUMA_NO_NODE",
            "name": "!=null or ==null",
        },
    }
},
{
    "kretprobe:match_token": {
        "description": "Find a token (and optional args) in a string. Detects which if any of a set of token strings has been passed to it. Tokens can include up to %MAX_OPT_ARGS instances of basic c-style format identifiers which will be taken into account when matching the tokens, and whose locations will be returned in the @args array.",
        "proto" :"int (*match_token)(char *s, const match_table_t table, substring_t args[])",
        "pre": {
            "s": "!=null",
            "table": "!=null && table is terminated with a &struct match_token whose pattern is set to the NULL pointer",
            "args": "!=null && args is an array of %MAX_OPT_ARGS &substring_t elements"
        }
    }
},
{
    "kprobe:match_token": {
        "description": "Find a token (and optional args) in a string. Detects which if any of a set of token strings has been passed to it. Tokens can include up to %MAX_OPT_ARGS instances of basic c-style format identifiers which will be taken into account when matching the tokens, and whose locations will be returned in the @args array.",
        "proto" :"int (*match_token)(char *s, const match_table_t table, substring_t args[])",
        "pre": {
            "s": "!=null",
            "table": "!=null && table is terminated with a &struct match_token whose pattern is set to the NULL pointer",
            "args": "!=null && args is an array of %MAX_OPT_ARGS &substring_t elements"
        }
    }
},
{
    "kretprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_int)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is integer if return == 0"
        }
    }
},
{
    "kprobe:match_int": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_int)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is integer if return == 0"
        }
    }
},
{
    "kretprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_uint)(substring_t *s, unsigned int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is integer if return == 0"
        }
    }
},
{
    "kprobe:match_uint": {
        "description": "Attempts to parse the &substring_t @s as a decimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_uint)(substring_t *s, unsigned int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is a valid decimal integer representation if return == 0"
        }
    }
},
{
    "kretprobe:match_u64int": {
        "description": "Given a &substring_t and a base, attempts to parse the substring as a number in that base. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"static int match_u64int(substring_t *s, u64 *result, int base)",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "in [2, 36]"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "in [INT_MIN, INT_MAX]"
        }
    }
},
{
    "kprobe:match_u64int": {
        "description": "Given a &substring_t and a base, attempts to parse the substring as a number in that base. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"static int match_u64int(substring_t *s, u64 *result, int base)",
        "pre": {
            "s": "!=null",
            "result": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kretprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_octal)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is an integer"
        }
    }
},
{
    "kprobe:match_octal": {
        "description": "Attempts to parse the &substring_t @s as an octal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_octal)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is an octal integer if return == 0"
        }
    }
},
{
    "kretprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_hex)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is an integer"
        }
    }
},
{
    "kprobe:match_hex": {
        "description": "Attempts to parse the &substring_t @s as a hexadecimal integer. On success, sets @result to the integer represented by the string and returns 0. Returns -EINVAL or -ERANGE on failure.",
        "proto" :"int (*match_hex)(substring_t *s, int *result)",
        "pre": {
            "s": "!=null",
            "result": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ERANGE]",
            "result": "is an integer if return == 0"
        }
    }
},
{
    "kretprobe:match_wildcard": {
        "description": "Parse the string @str to check if matches wildcard pattern @pattern. The pattern may contain two types of wildcards: ' ' - matches zero or more characters '?' - matches one character. If the @str matches the @pattern, return true, else return false.",
        "proto" :"bool (*match_wildcard)(const char *pattern, const char *str)",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:match_wildcard": {
        "description": "Parse the string @str to check if matches wildcard pattern @pattern. The pattern may contain two types of wildcards: ' ' - matches zero or more characters '?' - matches one character. If the @str matches the @pattern, return true, else return false.",
        "proto" :"bool (*match_wildcard)(const char *pattern, const char *str)",
        "pre": {
            "pattern": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:match_strdup": {
        "description": "Allocates and returns a string filled with the contents of the &substring_t @s. The caller is responsible for freeing the returned string with kfree().",
        "proto" :"char *(*match_strdup)(const substring_t *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:match_strdup": {
        "description": "Allocates and returns a string filled with the contents of the &substring_t @s. The caller is responsible for freeing the returned string with kfree().",
        "proto" :"char *(*match_strdup)(const substring_t *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "proto" :"s64 (*__percpu_counter_sum)(struct percpu_counter *fbc)",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:__percpu_counter_sum": {
        "description": "__percpu_counter_sum() just does the right thing when CPUs are being taken offline.",
        "proto" :"s64 (*__percpu_counter_sum)(struct percpu_counter *fbc)",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kretprobe:debug_percpu_counter_activate": {
        "description": "Initializes and activates a percpu_counter object.",
        "proto" :"static inline void debug_percpu_counter_activate(struct percpu_counter *fbc)",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kprobe:debug_percpu_counter_activate": {
        "description": "Initialize and activate a percpu_counter object.",
        "proto" :"static inline void debug_percpu_counter_activate(struct percpu_counter *fbc)",
        "pre": {
            "fbc": "!=null"
        }
    }
},
{
    "kretprobe:__percpu_counter_compare": {
        "description": "Check to see if rough count will be sufficient for comparison",
        "proto": "static long (*__percpu_counter_compare)(struct percpu_counter *fbc, s64 rhs, s32 batch)",
        "pre": {
            "fbc": "!=null",
            "rhs": "is s64",
            "batch": "is s32"
        },
        "post": {
            "return": "abs(percpu_counter_read(fbc) - rhs) > (batch * num_online_cpus())"
        }
    }
},
{
    "kprobe:__percpu_counter_compare": {
        "description": "Check to see if rough count will be sufficient for comparison",
        "proto" :"__percpu_counter_compare(struct percpu_counter  fbc, s64 rhs, s32 batch)",
        "pre": {
            "fbc": "!=null",
            "rhs": "is s64",
            "batch": "is s32",
            "count": "is s64 and = percpu_counter_read(fbc)",
            "num_online_cpus()": "is function and returns positive integer",
            "abs(count - rhs)": "is function and returns positive integer",
            "batch * num_online_cpus()": "is operation and returns positive integer",
            "abs(count - rhs) > (batch * num_online_cpus())": "is condition"
        },
    }
},
{
    "kretprobe:__kfifo_alloc": {
        "description": "Round up to the next power of 2, since our 'let the indices wrap' technique works only in this case.",
        "proto" :"static long (*__kfifo_alloc)(struct __kfifo *fifo, unsigned int size, size_t esize, gfp_t gfp_mask)",
        "pre": {
            "fifo": "!=null",
            "size": ">=2",
            "esize": "!=null",
            "gfp_mask": "!=null"
        },
    }
},
{
    "__kfifo_alloc": {
        "description": "Allocate a new FIFO buffer with the specified size and element size. The size is rounded up to the next power of 2.",
        "proto": "int __kfifo_alloc(struct __kfifo *fifo, unsigned int size, size_t esize, gfp_t gfp_mask)",
        "pre": {
            "fifo": "!=null",
            "size": ">0",
            "esize": ">0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace with actual possible values
        },
    }
},
{
    "kretprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "proto": "int (*strncasecmp)(const char *s1, const char *s2, size_t len)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strncasecmp": {
        "description": "Case insensitive, length-limited string comparison",
        "proto" :"int (*strncasecmp)(const char *s1, const char *s2, size_t len)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copies the string pointed to by src, including the null byte ('\0'), to the buffer pointed to by dest.",
        "proto" :"char* (*strcpy)(char* dest, const char* src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "points to dest"
        }
    }
},
{
    ";return tmp;}EXPORT_SYMBOL(strcpy)": {
        "description": "Copies the string pointed to by src, including the null byte ('\0'), to the buffer pointed to by dest.",
        "proto" :"char* strcpy(char* dest, const char* src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
    }
},
{
    "kretprobe:if ((long)src & (sizeof(long) - 1))": {
        "description": "If src is unaligned, don't cross a page boundary, since we don't know if the next page is mapped.",
        "proto" :"ssize_t strscpy(char  dest, const char  src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0 && <=INT_MAX",
        },
    }
},
{
    "kprobe:strscpy": {
        "description": "Copy a string from source to destination, ensuring that the destination string is null-terminated. If source is unaligned, it does not cross a page boundary as it doesn't know if the next page is mapped.",
        "proto" :"ssize_t strscpy(char *dest, const char *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">0 && <=INT_MAX",
            "src_alignment": "((long)src & (sizeof(long) - 1)) == 0"
        },
    }
},
{
    "kretprobe:stpcpy": {
        "description": "Copy a string from src to dest returning a pointer to the new end of dest, including src's %NUL-terminator. May overrun dest. The return value is a pointer to the new %NUL-terminating character in @dest. This interface is considered unsafe as it doesn't perform bounds checking of the inputs.",
        "proto" :"char *(*stpcpy)(char *__restrict__ dest, const char *__restrict__ src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null && !=dest"
        }
    }
},
{
    "kprobe:stpcpy": {
        "description": "Copy a string from src to dest returning a pointer to the new end of dest, including src's %NUL-terminator. May overrun dest.",
        "proto" :"char *(*stpcpy)(char *__restrict__ dest, const char *__restrict__ src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "dest": "is large enough to receive copy from src",
            "src": "does not overlap with dest"
        },
    }
},
{
    "kretprobe:strlcat": {
        "description": "Concatenates the string pointed to by 'src' to the end of the string pointed to by 'dest'. It will append at most 'count' - strlen(dest) - 1 characters. It will then null-terminate, unless 'count' is 0 or the original 'dest' string was longer than 'count'.",
        "proto" :"size_t (*strlcat)(char *dest, const char *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "> strlen(dest)"
        },
        "post": {
            "return": ">= strlen(dest) + strlen(src)"
        }
    }
},
{
    "kprobe:strlcat": {
        "description": "Concatenates the string pointed to by 'src' to the end of the string pointed to by 'dest'. The 'count' parameter specifies the maximum length for 'dest'.",
        "proto" :"size_t (*strlcat)(char *dest, const char *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": "> strlen(dest)"
        },
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings @cs: One string @ct: Another string",
        "proto" :"int strcmp(const char *cs, const char *ct)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        },
        "post": {
            "return": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings",
        "proto": "int (*strcmp)(const char *cs, const char *ct)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "proto": "int strncmp(const char *cs, const char *ct, size_t count)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:strncmp": {
        "description": "Compare two length-limited strings",
        "proto": "int (*strncmp)(const char *cs, const char *ct, size_t count)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:strchr": {
        "description": "Find the first occurrence of a character in a string. The NUL-terminator is considered part of the string, and can be searched for.",
        "proto" :"char *(*strchr)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "in [0, 255]"
        },
    }
},
{
    "kprobe:strchr": {
        "description": "Find the first occurrence of a character in a string. The NUL-terminator is considered part of the string, and can be searched for.",
        "proto" :"char *(*strchr)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "is an integer in the ASCII range (0-127)"
        }
    }
},
{
    "kretprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string. Returns pointer to first occurrence of 'c' in 's'. If 'c' is not found, then return a pointer to the null byte at the end of 's'.",
        "proto" :"char *(*strchrnul)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "is int"
        },
        "post": {
            "return": "is pointer to first occurrence of 'c' in 's' or pointer to the null byte at the end of 's'"
        }
    }
},
{
    "kprobe:strchrnul": {
        "description": "Find and return a character in a string, or end of string. Returns pointer to first occurrence of 'c' in 's'. If 'c' is not found, then return a pointer to the null byte at the end of 's'.",
        "proto" :"char *(*strchrnul)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "is integer"
        },
    }
},
{
    "kretprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "proto": "char *(*strrchr)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "in [0, 255]"
        }
    }
},
{
    "kprobe:strrchr": {
        "description": "Find the last occurrence of a character in a string",
        "proto": "char *(*strrchr)(const char *s, int c)",
        "pre": {
            "s": "!=null",
            "c": "in [0, 255]"
        }
    }
},
{
    "kretprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string. Returns pointer to the first occurrence of 'c' in s. If c is not found, then return a pointer to the last character of the string.",
        "proto" :"char *(*strnchrnul)(const char *s, size_t count, int c)",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": "is character"
        },
    }
},
{
    "kprobe:strnchrnul": {
        "description": "Find and return a character in a length limited string, or end of string. Returns pointer to the first occurrence of 'c' in s. If c is not found, then return a pointer to the last character of the string.",
        "proto" :"char *(*strnchrnul)(const char *s, size_t count, int c)",
        "pre": {
            "s": "!=null",
            "count": ">=0",
            "c": "is character"
        },
    }
},
{
    "kretprobe:strnlen": {
        "description": "Returns the number of characters in a string, up to a maximum length.",
        "proto" :"size_t strnlen(const char *s, size_t count)",
        "pre": {
            "s": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": "<=count"
        }
    }
},
{
    "kprobe:strnlen": {
        "description": "Returns the number of characters in the string pointed to by 's', excluding the terminating null byte ('\0'), but at most 'count'. In doing so, the function never dereferences a pointer beyond the specified 'count' bytes.",
        "proto" :"size_t strnlen(const char *s, size_t count)",
        "pre": {
            "s": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contain letters in @accept. @s: The string to be searched. @accept: The string to search for.",
        "proto" :"size_t (*strspn)(const char *s, const char *accept)",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kprobe:strspn": {
        "description": "Calculate the length of the initial substring of @s which only contain letters in @accept. @s: The string to be searched. @accept: The string to search for.",
        "proto" :"size_t (*strspn)(const char *s, const char *accept)",
        "pre": {
            "s": "!=null",
            "accept": "!=null"
        }
    }
},
{
    "kretprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject",
        "proto" :"size_t (*strcspn)(const char *s, const char *reject)",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kprobe:strcspn": {
        "description": "Calculate the length of the initial substring of @s which does not contain letters in @reject",
        "proto" :"size_t (*strcspn)(const char *s, const char *reject)",
        "pre": {
            "s": "!=null",
            "reject": "!=null"
        }
    }
},
{
    "kretprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "proto" :"char *(*strpbrk)(const char *cs, const char *ct)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kprobe:strpbrk": {
        "description": "Find the first occurrence of a set of characters",
        "proto" :"char *(*strpbrk)(const char *cs, const char *ct)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:strsep": {
        "description": "Split a string into tokens. strsep() updates @s to point after the token, ready for the next call. It returns empty tokens, too, behaving exactly like the libc function of that name. In fact, it was stolen from glibc2 and de-fancy-fied. Same semantics, slimmer shape. ;)",
        "proto" :"char *(*strsep)(char **s, const char *ct)",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:strsep": {
        "description": "Split a string into tokens. strsep() updates @s to point after the token, ready for the next call. It returns empty tokens, too, behaving exactly like the libc function of that name. In fact, it was stolen from glibc2 and de-fancy-fied. Same semantics, slimmer shape. ;)",
        "proto" :"char *(*strsep)(char **s, const char *ct)",
        "pre": {
            "s": "!=null",
            "ct": "!=null"
        }
    }
},
{
    "kretprobe:memset": {
        "description": "Fill a region of memory with the given value. Do not use memset() to access IO space, use memset_io() instead.",
        "proto" :"void *(*memset)(void *s, int c, size_t count)",
        "pre": {
            "s": "!=null",
            "c": "is int",
            "count": "is size_t && >=0"
        },
    }
},
{
    "kprobe:memset": {
        "description": "Fill a region of memory with the given value. Do not use memset() to access IO space, use memset_io() instead.",
        "proto" :"void *(*memset)(void *s, int c, size_t count)",
        "pre": {
            "s": "!=null",
            "c": "is an integer",
            "count": "is a non-negative integer"
        }
    }
},
{
    "kretprobe:memset16": {
        "description": "Fill a memory area with a uint16_t. Differs from memset() in that it fills with a uint16_t instead of a byte. Remember that @count is the number of uint16_ts to store, not the number of bytes.",
        "proto" :"void *(*memset16)(uint16_t *s, uint16_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "is uint16_t",
            "count": "is size_t"
        }
    }
},
{
    "kprobe:memset16": {
        "description": "Fill a memory area with a uint16_t. Differs from memset() in that it fills with a uint16_t instead of a byte. Remember that @count is the number of uint16_ts to store, not the number of bytes.",
        "proto" :"void *(*memset16)(uint16_t *s, uint16_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "in [0, 65535]", 
            "count": ">=0",
        },
    }
},
{
    "kretprobe:memset32": {
        "description": "Fill a memory area with a uint32_t. Differs from memset() in that it fills with a uint32_t instead of a byte. Remember that @count is the number of uint32_ts to store, not the number of bytes.",
        "proto" :"void *(*memset32)(uint32_t *s, uint32_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "is uint32_t",
            "count": "is size_t"
        }
    }
},
{
    "kprobe:memset32": {
        "description": "Fill a memory area with a uint32_t. Differs from memset() in that it fills with a uint32_t instead of a byte. Remember that @count is the number of uint32_ts to store, not the number of bytes.",
        "proto" :"void *(*memset32)(uint32_t *s, uint32_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "is uint32_t",
            "count": "is size_t"
        }
    }
},
{
    "kretprobe:memset64": {
        "description": "Fill a memory area with a uint64_t. Differs from memset() in that it fills with a uint64_t instead of a byte. Remember that @count is the number of uint64_ts to store, not the number of bytes.",
        "proto" :"void *(*memset64)(uint64_t *s, uint64_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "is uint64_t",
            "count": "is size_t"
        },
    }
},
{
    "kprobe:memset64": {
        "description": "Fill a memory area with a uint64_t. Differs from memset() in that it fills with a uint64_t instead of a byte. Remember that @count is the number of uint64_ts to store, not the number of bytes.",
        "proto" :"void *(*memset64)(uint64_t *s, uint64_t v, size_t count)",
        "pre": {
            "s": "!=null",
            "v": "is uint64_t",
            "count": "is size_t"
        },
    }
},
{
    "kretprobe:memmove": {
        "description": "Copy one area of memory to another. Unlike memcpy(), memmove() copes with overlapping areas.",
        "proto" :"void *(*memmove)(void *dest, const void *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kprobe:memmove": {
        "description": "Copy one area of memory to another. Unlike memcpy(), memmove() copies with overlapping areas.",
        "proto": "void *(*memmove)(void *dest, const void *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "proto": "#undef memcmp__visible int memcmp(const void *cs, const void *ct, size_t count)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "proto" :"#undef memcmp__visible int memcmp(const void *cs, const void *ct, size_t count)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents. The sign or magnitude of a non-zero return value has no particular meaning, and architectures may implement their own more efficient bcmp(). So while this particular implementation is a simple (tail) call to memcmp, do not rely on anything but whether the return value is zero or non-zero.",
        "proto" :"int (*bcmp)(const void *a, const void *b, size_t len)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:bcmp": {
        "description": "Returns 0 if and only if the buffers have identical contents. The sign or magnitude of a non-zero return value has no particular meaning, and architectures may implement their own more efficient bcmp(). So while this particular implementation is a simple (tail) call to memcmp, do not rely on anything but whether the return value is zero or non-zero.",
        "proto" :"int (*bcmp)(const void *a, const void *b, size_t len)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory. @addr: The memory area @c: The byte to search for @size: The size of the area. returns the address of the first occurrence of @c, or 1 byte past the area if @c is not found",
        "proto" :"void *(*memscan)(void *addr, int c, size_t size)",
        "pre": {
            "addr": "!=null",
            "c": "in [0, 255]",
            "size": ">=0"
        },
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory. @addr: The memory area @c: The byte to search for @size: The size of the area. returns the address of the first occurrence of @c, or 1 byte past the area if @c is not found",
        "proto" :"void *(*memscan)(void *addr, int c, size_t size)",
        "pre": {
            "addr": "!=null",
            "c": "is int",
            "size": "is size_t and >=0",
        },
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a %NUL terminated string",
        "proto": "char *(*strstr)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a %NUL terminated string",
        "proto": "char *(*strstr)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "proto": "char *(*strnstr)(const char *s1, const char *s2, size_t len)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:strnstr": {
        "description": "Find the first substring in a length-limited string",
        "proto" :"char *(*strnstr)(const char *s1, const char *s2, size_t len)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory. @s: The memory area @c: The byte to search for @n: The size of the area. returns the address of the first occurrence of @c, or %NULL if @c is not found",
        "proto" :"void *(*memchr)(const void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "is int",
            "n": "is size_t"
        },
        "post": {
            "return": "in [s, s+n] or ==null"
        }
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory. Returns the address of the first occurrence of @c, or %NULL if @c is not found.",
        "proto" :"void *(*memchr)(const void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "is an integer in [0, 255]",
            "n": "is a non-negative integer"
        }
    }
},
{
    "kretprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory. @start: The memory area @c: Find a character other than c @bytes: The size of the area. returns the address of the first character other than @c, or %NULL if the whole buffer contains just @c.",
        "proto" :"void *(*memchr_inv)(const void *start, int c, size_t bytes)",
        "pre": {
            "start": "!=null",
            "c": "is int",
            "bytes": "is size_t && >=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:memchr_inv": {
        "description": "Find an unmatching character in an area of memory. @start: The memory area @c: Find a character other than c @bytes: The size of the area. returns the address of the first character other than @c, or %NULL if the whole buffer contains just @c.",
        "proto" :"void *(*memchr_inv)(const void *start, int c, size_t bytes)",
        "pre": {
            "start": "!=null",
            "c": "is int",
            "bytes": "is size_t && >=0",
        },
    }
},
{
    "kretprobe:check_signature": {
        "description": "Perform a signature comparison with the mmio address io_addr. This address should have been obtained by ioremap. Returns 1 on a match.",
        "proto" :"int (*check_signature)(const volatile void __iomem *io_addr, const unsigned char *signature, int length)",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": ">0"
        },
    }
},
{
    "kprobe:check_signature": {
        "description": "Find BIOS signatures. Perform a signature comparison with the mmio address io_addr. This address should have been obtained by ioremap. Returns 1 on a match.",
        "proto" :"int (*check_signature)(const volatile void __iomem *io_addr, const unsigned char *signature, int length)",
        "pre": {
            "io_addr": "!=null",
            "signature": "!=null",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:bsearch": {
        "description": "Binary search an array of elements. The contents of the array should already be in ascending sorted order under the provided comparison function. The key need not have the same type as the elements in the array, e.g. key could be a string and the comparison function could compare the string with the struct's name field. However, if the key and elements in the array are of the same type, you can use the same comparison function for both sort() and bsearch().",
        "proto" :"void *(*bsearch)(const void *key, const void *base, size_t num, size_t size, cmp_func_t cmp)",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">0",
            "size": ">0",
            "cmp": "!=null"
        }
    }
},
{
    "kprobe:bsearch": {
        "description": "Binary search an array of elements. The contents of the array should already be in ascending sorted order under the provided comparison function. Note that the key need not have the same type as the elements in the array, e.g. key could be a string and the comparison function could compare the string with the struct's name field. However, if the key and elements in the array are of the same type, you can use the same comparison function for both sort() and bsearch().",
        "proto" :"void *(*bsearch)(const void *key, const void *base, size_t num, size_t size, cmp_func_t cmp)",
        "pre": {
            "key": "!=null",
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp": "!=null"
        }
    }
},
{
    "kretprobe:_atomic_dec_and_raw_lock_irqsave": {
        "description": "Subtract 1 from counter unless that drops it to 0 (ie. it was 1)",
        "proto" :"static long (*_atomic_dec_and_raw_lock_irqsave)(atomic_t *atomic, raw_spinlock_t *lock, unsigned long flags)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": ">=0",
            "atomic_value": ">1"
        },
        "post": {
            "return": "in [0, 1]",
            "atomic_value": ">=0"
        }
    }
},
{
    "kprobe:_atomic_dec_and_raw_lock_irqsave": {
        "description": "Subtract 1 from counter unless that drops it to 0 (ie. it was 1)",
        "proto" :"static long (*_atomic_dec_and_raw_lock_irqsave)(atomic_t *atomic, raw_spinlock_t *lock, unsigned long flags)",
        "pre": {
            "atomic": "!=null",
            "lock": "!=null",
            "flags": ">=0",
        },
    }
},
{
    "kretprobe:ip_fast_csum": {
        "description": "ip_compute_csum() optimized for IP headers, which always checksum on 4 octet boundaries.",
        "proto" :"__sum16 (*ip_fast_csum)(const void *iph, unsigned int ihl)",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0 && ihl%4 == 0"
        }
    }
},
{
    "kprobe:ip_fast_csum": {
        "description": "ip_compute_csum() optimized for IP headers, which always checksum on 4 octet boundaries.",
        "proto" :"__sum16 (*ip_fast_csum)(const void *iph, unsigned int ihl)",
        "pre": {
            "iph": "!=null",
            "ihl": ">=0",
        },
    }
},
{
    "kretprobe:csum_partial": {
        "description": "Calculate the checksum by adding in old sum and carry.",
        "proto" :"__wsum csum_partial(const void *buff, int len, __wsum wsum)",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": "is valid __wsum"
        },
    }
},
{
    "kprobe:csum_partial": {
        "description": "Calculate the checksum for a given buffer, add in old sum, and carry.",
        "proto" :"static __wsum (*csum_partial)(const void *buff, int len, __wsum wsum)",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "wsum": "is an unsigned integer"
        },
    }
},
{
    "kretprobe:from64to32": {
        "description": "Add up 32-bit and 32-bit for 32+c bit",
        "proto" :"static inline u32 from64to32(u64 x)",
        "pre": {
            "x": "is 64-bit integer"
        },
        "post": {
            "x": "is 32-bit integer"
        }
    }
},
{
    "kprobe:from64to32": {
        "description": "Add up 32-bit and 32-bit for 32+c bit",
        "proto" :"static inline u32 from64to32(u64 x)",
        "pre": {
            "x": "is u64"
        },
    }
},
{
    "__rb_erase_color": {
        "description": "Loop invariants: - node is black (or NULL on first iteration) - node is not the root (parent is not NULL) - All leaf paths going through parent and node have a black node count that is 1 lower than other leaf paths.",
        "proto" :"void (__rb_erase_color)(struct rb_node *parent, struct rb_root *root, void (*augment_rotate)(struct rb_node *old, struct rb_node *new))",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null"
        },
    }
},
{
    "__rb_erase_color": {
        "description": "Loop invariants: - node is black (or NULL on first iteration) - node is not the root (parent is not NULL) - All leaf paths going through parent and node have a black node count that is 1 lower than other leaf paths.",
        "proto" :"__rb_erase_color(struct rb_node  parent, struct rb_root  root,void ( augment_rotate)(struct rb_node  old, struct rb_node  new))",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
    }
},
{
    "kretprobe:dummy_propagate": {
        "description": "rb_insert_color() and rb_erase() function definitions.",
        "proto" :"static inline void dummy_propagate(struct rb_node *node, struct rb_node *stop)",
        "pre": {
            "node": "!=null",
            "stop": "!=null"
        }
    }
},
{
    "kprobe:dummy_propagate": {
        "description": "rb_insert_color() and rb_erase() function definitions.",
        "proto" :"static inline void dummy_propagate(struct rb_node *node, struct rb_node *stop)",
        "pre": {
            "node": "!=null",
            "stop": "!=null"
        },
    }
},
{
    "kretprobe:____rb_erase_color": {
        "description": "rb_erase() use - we want to be able to inline and eliminate the dummy_rotate callback there",
        "proto" :"static __always_inline void ____rb_erase_color(struct rb_node *parent, struct rb_root *root, void (*augment_rotate)(struct rb_node *old, struct rb_node *new))",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null"
        }
    }
},
{
    "kprobe:____rb_erase_color": {
        "description": "rb_erase() use - we want to be able to inline and eliminate the dummy_rotate callback there",
        "proto" :"static __always_inline void ____rb_erase_color(struct rb_node *parent, struct rb_root *root, void (*augment_rotate)(struct rb_node *old, struct rb_node *new))",
        "pre": {
            "parent": "!=null",
            "root": "!=null",
            "augment_rotate": "!=null"
        },
    }
},
{
    "kretprobe:rb_next": {
        "description": "If we have a right-hand child, go down and then left as far as we can.",
        "proto" :"struct rb_node *(*rb_next)(const struct rb_node *node)",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "either null or a valid pointer to struct rb_node"
        }
    }
},

{
    "kretprobe:rb_prev": {
        "description": "If we have a left-hand child, go down and then right as far as we can.",
        "proto" :"struct rb_node *(*rb_prev)(const struct rb_node *node)",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "either null or a valid pointer to struct rb_node"
        }
    }
},

{
    "kretprobe:rb_replace_node_rcu": {
        "description": "Replace the victim node with the new node in the Red-Black tree.",
        "proto" :"void rb_replace_node_rcu(struct rb_node *victim, struct rb_node *new, struct rb_root *root)",
        "pre": {
            "victim": "!=null",
            "new": "!=null",
            "root": "!=null"
        },
        "post": {
            "new->parent": "==victim->parent",
            "new->color": "==victim->color"
        }
    }
},
{
    "kprobe:rb_replace_node_rcu": {
        "description": "Replace the victim node with the new node in the red-black tree rooted at root. Copy the pointers and color from the victim to the replacement.",
        "proto" :"static void (*rb_replace_node_rcu)(struct rb_node *victim, struct rb_node *new, struct rb_root *root)",
        "pre": {
            "victim": "!=null",
            "new": "!=null",
            "root": "!=null"
        }
    }
},
{
    "kretprobe:rb_next_postorder": {
        "description": "If we're sitting on node, we've already seen our children",
        "proto" :"const struct rb_node (*rb_next_postorder)(const struct rb_node  node)",
        "pre": {
            "node": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rb_next_postorder": {
        "description": "Returns the next node in postorder traversal of a red-black tree. If the node is null, it returns null. If the node has a parent and the node is the left child of the parent, it returns the right child of the parent.",
        "proto" :"const struct rb_node (*rb_next_postorder)(const struct rb_node *node)",
        "pre": {
            "node": "!=null"
        },
    }
},



{
    "kprobe:__nla_validate_parse": {
        "description": "Validates the netlink attribute bitfield32. Returns -EINVAL if the bit selector is invalid.",
        "proto" :"static int validate_nla_bitfield32(const struct nlattr  nla, const u32 valid_flags_mask)",
        "pre": {
            "nla": "!=null",
            "valid_flags_mask": "!=0",
        },
    }
},
{
    "kretprobe:intnla_policy_len": {
        "description": "Determine the max. length of a policy. It is currently used to allocate Netlink buffers roughly the size of the actual message.",
        "proto" :"intnla_policy_len(const struct nla_policy *p, int n)",
        "pre": {
            "p": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:intnla_policy_len": {
        "description": "Determine the max. length of a policy. It is currently used to allocated Netlink buffers roughly the size of the actual message. Returns 0 on success or a negative error code.",
        "proto" :"intnla_policy_len(const struct nla_policy *p, int n)",
        "pre": {
            "p": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:__nla_parse": {
        "description": "Parses a stream of attributes and stores a pointer to each attribute in the tb array accessible via the attribute type. Validation is controlled by the @validate parameter. Returns 0 on success or a negative error code.",
        "proto" :"int __nla_parse(struct nlattr **tb, int maxtype, const struct nlattr *head, int len, const struct nla_policy *policy, unsigned int validate, struct netlink_ext_ack *extack)",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": "in [0, 1]",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:__nla_parse": {
        "description": "Parses a stream of attributes and stores a pointer to each attribute in the tb array accessible via the attribute type. Validation is controlled by the @validate parameter. Returns 0 on success or a negative error code.",
        "proto" :"int (*__nla_parse)(struct nlattr **tb, int maxtype, const struct nlattr *head, int len, const struct nla_policy *policy, unsigned int validate, struct netlink_ext_ack *extack)",
        "pre": {
            "tb": "!=null",
            "maxtype": ">=0",
            "head": "!=null",
            "len": ">=0",
            "policy": "!=null",
            "validate": "in [0, 1]",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:nla_find": {
        "description": "Returns the first attribute in the stream matching the specified type.",
        "proto" :"struct nlattr *(*nla_find)(const struct nlattr *head, int len, int attrtype)",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        },
    }
},
{
    "kprobe:nla_find": {
        "description": "Returns the first attribute in the stream matching the specified type.",
        "proto" :"struct nlattr *(*nla_find)(const struct nlattr *head, int len, int attrtype)",
        "pre": {
            "head": "!=null",
            "len": ">=0",
            "attrtype": ">=0"
        }
    }
},
{
    "kretprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer. Copies at most dstsize - 1 bytes into the destination buffer. Unlike strlcpy the destination buffer is always padded out.",
        "proto": "ssize_t (*nla_strscpy)(char *dst, const struct nlattr *nla, size_t dstsize)",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "in [1, U16_MAX]"
        },
        "post": {
            "return": "in [-E2BIG, nla->nla_len]"
        }
    }
},
{
    "kprobe:nla_strscpy": {
        "description": "Copy string attribute payload into a sized buffer. Copies at most dstsize - 1 bytes into the destination buffer. Unlike strlcpy the destination buffer is always padded out.",
        "proto" :"ssize_t (*nla_strscpy)(char *dst, const struct nlattr *nla, size_t dstsize)",
        "pre": {
            "dst": "!=null",
            "nla": "!=null",
            "dstsize": "in [1, U16_MAX]"
        },
        "post": {
            "return": "in [-E2BIG, nla.length]"
        }
    }
},
{
    "kretprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer. Returns a pointer to the allocated buffer or NULL on error.",
        "proto" :"char *(*nla_strdup)(const struct nlattr *nla, gfp_t flags)",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kprobe:nla_strdup": {
        "description": "Copy string attribute payload into a newly allocated buffer. Returns a pointer to the allocated buffer or NULL on error.",
        "proto" :"char *(*nla_strdup)(const struct nlattr *nla, gfp_t flags)",
        "pre": {
            "nla": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOIO, __GFP_NORECLAIM, __GFP_NOTRACK_FREE, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_NOWAIT, __GFP_NOIO, __GFP_NORECLAIM, __GFP_NOTRACK_FREE]"
        },
    }
},
{
    "kretprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area. The number of bytes copied is limited by the length of the attribute's payload. Returns the number of bytes copied.",
        "proto": "int (*nla_memcpy)(void *dest, const struct nlattr *src, int count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
        "post": {
            "return": "<=count",
            "return": ">=0"
        }
    }
},
{
    "kprobe:nla_memcpy": {
        "description": "Copy a netlink attribute into another memory area. The number of bytes copied is limited by the length of the attribute's payload. Returns the number of bytes copied.",
        "proto" :"int (*nla_memcpy)(void *dest, const struct nlattr *src, int count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0",
            "src->nla_len": "<=count"
        },
    }
},
{
    "kretprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "proto": "int nla_memcmp(const struct nlattr *nla, const void *data, size_t size)",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:nla_memcmp": {
        "description": "Compare an attribute with sized memory area",
        "proto": "int (*nla_memcmp)(const struct nlattr *nla, const void *data, size_t size)",
        "pre": {
            "nla": "!=null",
            "data": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:nla_strcmp": {
        "description": "Compare a string attribute against a string",
        "proto" :"int (*nla_strcmp)(const struct nlattr *nla, const char *str)",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kprobe:nla_strcmp": {
        "description": "Compare a string attribute against a string",
        "proto" :"int (*nla_strcmp)(const struct nlattr *nla, const char *str)",
        "pre": {
            "nla": "!=null",
            "str": "!=null"
        }
    }
},
{
    "kretprobe:__nla_reserve": {
        "description": "Adds a netlink attribute header to a socket buffer and reserves room for the payload but does not copy it. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"struct nlattr * (*__nla_reserve)(struct sk_buff *skb, int attrtype, int attrlen)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0"
        }
    }
},
{
    "kprobe:__nla_reserve": {
        "description": "Adds a netlink attribute header to a socket buffer and reserves room for the payload but does not copy it. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"struct nlattr * (*__nla_reserve)(struct sk_buff *skb, int attrtype, int attrlen)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0"
        },
    }
},
{
    "kretprobe:__nla_reserve_64bit": {
        "description": "Adds a netlink attribute header to a socket buffer and reserves room for the payload but does not copy it. It also ensures that this attribute will have a 64-bit aligned nla_data() area. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"struct nlattr * (*__nla_reserve_64bit)(struct sk_buff *skb, int attrtype, int attrlen, int padattr)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "padattr": ">=0"
        }
    }
},
{
    "kprobe:__nla_reserve_64bit": {
        "description": "Adds a netlink attribute header to a socket buffer and reserves room for the payload but does not copy it. It also ensures that this attribute will have a 64-bit aligned nla_data() area. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"struct nlattr * (*__nla_reserve_64bit)(struct sk_buff *skb, int attrtype, int attrlen, int padattr)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "padattr": ">=0"
        },
    }
},
{
    "kretprobe:__nla_reserve_nohdr": {
        "description": "Reserves room for attribute payload without a header. The caller is responsible to ensure that the skb provides enough tailroom for the payload.",
        "proto" :"void *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0"
        }
    }
},
{
    "kprobe:__nla_reserve_nohdr": {
        "description": "Reserves room for attribute payload without a header. The caller is responsible to ensure that the skb provides enough tailroom for the payload.",
        "proto" :"void *(*__nla_reserve_nohdr)(struct sk_buff *skb, int attrlen)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
        },
    }
},
{
    "kretprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto": "void (*__nla_put)(struct sk_buff *skb, int attrtype, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put": {
        "description": "Add a netlink attribute to a socket buffer. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"void (*__nla_put)(struct sk_buff *skb, int attrtype, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"void (*__nla_put_64bit)(struct sk_buff *skb, int attrtype, int attrlen, const void *data, int padattr)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "data": "!=null",
            "padattr": ">=0"
        }
    }
},
{
    "kprobe:__nla_put_64bit": {
        "description": "Add a netlink attribute to a socket buffer and align it. The caller is responsible to ensure that the skb provides enough tailroom for the attribute header and payload.",
        "proto" :"void (*__nla_put_64bit)(struct sk_buff *skb, int attrtype, int attrlen, const void *data, int padattr)",
        "pre": {
            "skb": "!=null",
            "attrtype": ">=0",
            "attrlen": ">=0",
            "data": "!=null",
            "padattr": ">=0"
        }
    }
},
{
    "kretprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header to a socket buffer. The caller is responsible to ensure that the skb provides enough tailroom for the attribute payload.",
        "proto" :"void (*__nla_put_nohdr)(struct sk_buff *skb, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:__nla_put_nohdr": {
        "description": "Add a netlink attribute without header to a socket buffer. The caller is responsible to ensure that the skb provides enough tailroom for the attribute payload.",
        "proto" :"void (*__nla_put_nohdr)(struct sk_buff *skb, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding to socket buffer. Returns -EMSGSIZE if the tailroom of the skb is insufficient to store the attribute payload.",
        "proto" :"int nla_append(struct sk_buff *skb, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        },
    }
},
{
    "kprobe:nla_append": {
        "description": "Add a netlink attribute without header or padding to socket buffer. Returns -EMSGSIZE if the tailroom of the skb is insufficient to store the attribute payload.",
        "proto" :"int (*nla_append)(struct sk_buff *skb, int attrlen, const void *data)",
        "pre": {
            "skb": "!=null",
            "attrlen": ">=0",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:simple_strtoull": {
        "description": "Convert a string to an unsigned long long. This function has caveats. Please use kstrtoull instead.",
        "proto" :"noinline unsigned long long (*simple_strtoull)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kprobe:simple_strtoull": {
        "description": "Convert a string to an unsigned long long. This function has caveats. Please use kstrtoull instead.",
        "proto" :"noinline unsigned long long (*simple_strtoull)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kretprobe:simple_strtol": {
        "description": "Convert a string to a signed long. This function has caveats. Please use kstrtol instead.",
        "proto" :"long (*simple_strtol)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kprobe:simple_strtol": {
        "description": "Convert a string to a signed long. This function has caveats. Please use kstrtol instead.",
        "proto" :"long (*simple_strtol)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kretprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long. This function has caveats. Please use kstrtoll instead.",
        "proto" :"long long (*simple_strtoll)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        },
    }
},
{
    "kprobe:simple_strtoll": {
        "description": "Convert a string to a signed long long. This function has caveats. Please use kstrtoll instead.",
        "proto" :"long long (*simple_strtoll)(const char *cp, char **endp, unsigned int base)",
        "pre": {
            "cp": "!=null",
            "endp": "!=null",
            "base": "in [2, 36]"
        }
    }
},

{
    "kprobe:scnprintf": {
        "description": "Write formatted output to a string, but no more than size bytes, including the trailing null byte ('\0').",
        "proto" :"int scnprintf(char *buf, size_t size, const char *fmt, ...)",
        "pre": {
            "buf": "!=null",
            "size": ">0",
            "fmt": "!=null"
        }
    },
    "kprobe:vscnprintf": {
        "description": "Write formatted output to a string using a va_list, but no more than size bytes, including the trailing null byte ('\0').",
        "proto" :"int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)",
        "pre": {
            "buf": "!=null",
            "size": ">0",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},


{
    "kretprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "proto": "int vsscanf(const char *buf, const char *fmt, va_list args)",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kprobe:vsscanf": {
        "description": "Unformat a buffer into a list of arguments",
        "proto" :"int (*vsscanf)(const char *buf, const char *fmt, va_list args)",
        "pre": {
            "buf": "!=null",
            "fmt": "!=null",
            "args": "!=null"
        }
    }
},
{
    "kretprobe:strnlen_user": {
        "description": "Returns the length of the string in user memory, not including the trailing '\\0'.",
        "proto" :"unsigned long strnlen_user(const char __user *src, unsigned long count, unsigned long max)",
        "pre": {
            "src": "!=null",
            "count": ">=0",
            "max": ">=count"
        },
    }
},
{
    "kprobe:strnlen_user": {
        "description": "Do everything aligned. But that means that we need to also expand the maximum.",
        "proto" :"strnlen_user(const char __user src, unsigned long count, unsigned long max)",
        "pre": {
            "src": "!=null",
            "count": ">=0",
            "max": ">=count",
        },
    }
},
{
    "kretprobe:sort_r": {
        "description": "Sort an array of elements. This function does a heapsort on the given array. You may provide a swap_func function if you need to do something more than a memory copy (e.g. fix up pointers or auxiliary data), but the built-in swap avoids a slow retpoline and so is significantly faster. Sorting time is O(n log n) both on average and worst-case. While quicksort is slightly faster on average, it suffers from exploitable O(n n) worst-case behavior and extra memory requirements that make it less suitable for kernel use.",
        "proto" :"void (*sort_r)(void *base, size_t num, size_t size, cmp_r_func_t cmp_func, swap_r_func_t swap_func, const void *priv)",
        "pre": {
            "base": "!=null",
            "num": ">0",
            "size": ">0",
            "cmp_func": "!=null",
            "swap_func": "!=null || ==null",
            "priv": "!=null || ==null"
        }
    }
},
{
    "kprobe:sort_r": {
        "description": "Sort an array of elements. This function does a heapsort on the given array. You may provide a swap_func function if you need to do something more than a memory copy (e.g. fix up pointers or auxiliary data), but the built-in swap avoids a slow retpoline and so is significantly faster. Sorting time is O(n log n) both on average and worst-case. While quicksort is slightly faster on average, it suffers from exploitable O(n n) worst-case behavior and extra memory requirements that make it less suitable for kernel use.",
        "proto" :"void (*sort_r)(void *base, size_t num, size_t size, cmp_r_func_t cmp_func, swap_r_func_t swap_func, const void *priv)",
        "pre": {
            "base": "!=null",
            "num": ">=0",
            "size": ">=0",
            "cmp_func": "!=null",
            "swap_func": "!=null || ==null",
            "priv": "!=null || ==null"
        }
    }
},
{
    "kretprobe:is_aligned": {
        "description": "Checks if a pointer and size are okay for word-wide copying. The size must be a multiple of the alignment, and the base address must be if we do not have CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS.",
        "proto" :"bool (*is_aligned)(void *base, size_t size, size_t align)",
        "pre": {
            "base": "!=null",
            "size": ">=0",
            "align": "in [4, 8]"
        },
    }
},
{
    "kprobe:is_aligned": {
        "description": "Checks if the pointer & size are okay for word-wide copying. Returns true if elements can be copied using word loads and stores. The size must be a multiple of the alignment, and the base address must be if we do not have CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS.",
        "proto" :"bool (*is_aligned)(void *base, size_t size, size_t align)",
        "pre": {
            "base": "!=null",
            "size": "is multiple of align",
            "align": "in [4, 8]"
        },
    }
},
{
    "kretprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace. Architectures can override this implementation by implementing its own.",
        "proto" :"asmlinkage __visible void dump_stack_lvl(const char *log_lvl)",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},
{
    "kprobe:dump_stack_lvl": {
        "description": "Dump the current task information and its stack trace. Architectures can override this implementation by implementing its own.",
        "proto" :"asmlinkage __visible void (*dump_stack_lvl)(const char *log_lvl)",
        "pre": {
            "log_lvl": "!=null"
        }
    }
},


{
    "kretprobe:_copy_from_user": {
        "description": "Copy data from user space to kernel space. Ensure that bad access_ok() speculation will not lead to nasty side effects after the copy is finished.",
        "proto" :"unsigned long (*_copy_from_user)(void *to, const void __user *from, unsigned long n)",
        "pre": {
            "to": "!=null",
            "from": "!=null && likely(access_ok(from, n))",
            "n": ">=0"
        },
    }
},
{
    "_copy_from_user": {
        "description": "Copies data from user space into kernel space. Ensures that bad access_ok() speculation will not lead to nasty side effects after the copy is finished.",
        "proto" :"static long (*_copy_from_user)(void *to, const void __user *from, unsigned long n)",
        "pre": {
            "to": "!=null",
            "from": "!=null && likely(access_ok(from, n))",
            "n": ">=0"
        },
    }
},
{
    "kretprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes. This is effectively shorthand for 'memchr_inv(from, 0, size) == NULL' for userspace addresses (and is more efficient because we don't care where the first non-zero byte is).",
        "proto" :"int (*check_zeroed_user)(const void __user *from, size_t size)",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [-EFAULT, 0, 1]"
        }
    }
},
{
    "kprobe:check_zeroed_user": {
        "description": "Check if a userspace buffer only contains zero bytes. This is effectively shorthand for 'memchr_inv(from, 0, size) == NULL' for userspace addresses (and is more efficient because we don't care where the first non-zero byte is).",
        "proto" :"int (*check_zeroed_user)(const void __user *from, size_t size)",
        "pre": {
            "from": "!=null",
            "size": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EFAULT]"
        }
    }
},
{
    "kretprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0"
        }
    }
},
{
    "kprobe:devm_ioremap": {
        "description": "Managed ioremap(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0"
        }
    }
},
{
    "kretprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap_wc)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0"
        }
    }
},
{
    "kprobe:devm_ioremap_wc": {
        "description": "Managed ioremap_wc(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap_wc)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:devm_iounmap": {
        "description": "Managed iounmap(). @addr must have been mapped using devm_ioremap().",
        "proto" :"void devm_iounmap(struct device *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null && previously_mapped_by_devm_ioremap"
        }
    }
},
{
    "kprobe:devm_iounmap": {
        "description": "Managed iounmap(). @addr must have been mapped using devm_ioremap().",
        "proto" :"void devm_iounmap(struct device *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null && previously_mapped_by_devm_ioremap"
        }
    }
},
{
    "kretprobe:devm_ioremap_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap_resource)(struct device *dev, const struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null && resource_type(res) == IORESOURCE_MEM"
        },
        "post": {
            "return": "!=null || ==IOMEM_ERR_PTR(-EINVAL) || ==IOMEM_ERR_PTR(-ENOMEM) || ==IOMEM_ERR_PTR(-EBUSY)"
        }
    }
},
{
    "kprobe:devm_ioremap_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach.",
        "proto" :"void __iomem *(*devm_ioremap_resource)(struct device *dev, const struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null && resource_type(res) == IORESOURCE_MEM"
        },
    }
},
{
    "kretprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device. This is to be used when a device requestsmaps resources described by other device tree nodes (children or otherwise).",
        "proto" :"void __iomem *(*devm_of_iomap)(struct device *dev, struct device_node *node, int index, resource_size_t *size)",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": "can be null or !=null"
        },
        "post": {
            "return": "!=null or ==ERR_PTR() encoded error code"
        }
    }
},
{
    "kprobe:devm_of_iomap": {
        "description": "Requests a resource and maps the memory mapped IO for a given device_node managed by a given device. Checks that a resource is a valid memory region, requests the memory region and ioremaps it. All operations are managed and will be undone on driver detach of the device.",
        "proto" :"void __iomem *(*devm_of_iomap)(struct device *dev, struct device_node *node, int index, resource_size_t *size)",
        "pre": {
            "dev": "!=null",
            "node": "!=null",
            "index": ">=0",
            "size": "can be null"
        },
    }
},
{
    "kretprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioport_map)(struct device *dev, unsigned long port, unsigned int nr)",
        "pre": {
            "dev": "!=null",
            "port": ">=0",
            "nr": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:devm_ioport_map": {
        "description": "Managed ioport_map(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_ioport_map)(struct device *dev, unsigned long port, unsigned int nr)",
        "pre": {
            "dev": "!=null",
            "port": ">=0",
            "nr": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap(). @addr must have been mapped using devm_ioport_map().",
        "proto" :"void devm_ioport_unmap(struct device *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:devm_ioport_unmap": {
        "description": "Managed ioport_unmap(). @addr must have been mapped using devm_ioport_map().",
        "proto" :"void devm_ioport_unmap(struct device *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null && previously_mapped_by_devm_ioport_map"
        }
    }
},
{
    "kretprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table for @pdev. If iomap table doesn't exist and @pdev is managed, it will be allocated. All iomaps recorded in the iomap table are automatically unmapped on driver detach. This function might sleep when the table is first allocated but can be safely called without context and guaranteed to succeed once allocated.",
        "proto" :"void __iomem * const *pcim_iomap_table(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        },
    }
},
{
    "kprobe:pcim_iomap_table": {
        "description": "Access iomap allocation table for @pdev. If iomap table doesn't exist and @pdev is managed, it will be allocated. All iomaps recorded in the iomap table are automatically unmapped on driver detach. This function might sleep when the table is first allocated but can be safely called without context and guaranteed to succeed once allocated.",
        "proto" :"void __iomem * const *pcim_iomap_table(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). @addr must have been mapped using pcim_iomap().",
        "proto" :"void (*pcim_iounmap)(struct pci_dev *pdev, void __iomem *addr)",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:pcim_iounmap": {
        "description": "Managed pci_iounmap(). @addr must have been mapped using pcim_iomap().",
        "proto" :"void pcim_iounmap(struct pci_dev *pdev, void __iomem *addr)",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs. Request and iomap regions specified by @mask.",
        "proto" :"int (*pcim_iomap_regions)(struct pci_dev *pdev, int mask, const char *name)",
        "pre": {
            "pdev": "!=null",
            "mask": "is integer",
            "name": "!=null"
        },
    }
},
{
    "kprobe:pcim_iomap_regions": {
        "description": "Request and iomap PCI BARs for a PCI device specified by @pdev. The regions to request and iomap are specified by @mask.",
        "proto" :"int (*pcim_iomap_regions)(struct pci_dev *pdev, int mask, const char *name)",
        "pre": {
            "pdev": "!=null",
            "mask": ">=0",
            "name": "!=null",
        },
    }
},
{
    "kretprobe:pcim_iomap_regions_request_all": {
        "description": "Request all PCI BARs and iomap regions specified by @mask.",
        "proto" :"int pcim_iomap_regions_request_all(struct pci_dev *pdev, int mask, const char *name)",
        "pre": {
            "pdev": "!=null",
            "mask": "is integer",
            "name": "!=null"
        },
    }
},
{
    "kprobe:pcim_iomap_regions_request_all": {
        "description": "Request all PCI BARs and iomap regions specified by @mask.",
        "proto" :"int (*pcim_iomap_regions_request_all)(struct pci_dev *pdev, int mask, const char *name)",
        "pre": {
            "pdev": "!=null",
            "mask": "is an integer",
            "name": "!=null"
        },
    }
},
{
    "kretprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs. Unmap and release regions specified by @mask.",
        "proto" :"void (*pcim_iounmap_regions)(struct pci_dev *pdev, int mask)",
        "pre": {
            "pdev": "!=null",
            "mask": "is integer"
        }
    }
},
{
    "kprobe:pcim_iounmap_regions": {
        "description": "Unmap and release PCI BARs. Unmap and release regions specified by @mask.",
        "proto" :"void (*pcim_iounmap_regions)(struct pci_dev *pdev, int mask)",
        "pre": {
            "pdev": "!=null",
            "mask": ">=0"
        }
    }
},
{
    "kretprobe:devm_arch_phys_wc_add": {
        "description": "Adds a WC MTRR using arch_phys_wc_add() and sets up a release callback. See arch_phys_wc_add() for more information.",
        "proto" :"int devm_arch_phys_wc_add(struct device *dev, unsigned long base, unsigned long size)",
        "pre": {
            "dev": "!=null",
            "base": ">=0",
            "size": ">0",
        },
    }
},
{
    "kprobe:devm_arch_phys_wc_add": {
        "description": "Adds a WC MTRR using arch_phys_wc_add() and sets up a release callback. See arch_phys_wc_add() for more information.",
        "proto" :"int (*devm_arch_phys_wc_add)(struct device *dev, unsigned long base, unsigned long size)",
        "pre": {
            "dev": "!=null",
            "base": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback. See arch_io_reserve_memtype_wc() for more information.",
        "proto" :"int devm_arch_io_reserve_memtype_wc(struct device *dev, resource_size_t start, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "start": ">=0",
            "size": ">0",
        },
    }
},
{
    "kprobe:devm_arch_io_reserve_memtype_wc": {
        "description": "Reserves a memory range with WC caching using arch_io_reserve_memtype_wc() and sets up a release callback. See arch_io_reserve_memtype_wc() for more information.",
        "proto" :"int (*devm_arch_io_reserve_memtype_wc)(struct device *dev, resource_size_t start, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "start": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter. The caller has already converted the endianness of the input. This function also handles incrementing the block counter in the input matrix.",
        "proto" :"void (*chacha_block_generic)(u32 *state, u8 *stream, int nrounds)",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [12, 20]"
        }
    }
},
{
    "kprobe:chacha_block_generic": {
        "description": "Generate one keystream block and increment block counter. This is the ChaCha core, a function from 64-byte strings to 64-byte strings. The caller has already converted the endianness of the input. This function also handles incrementing the block counter in the input matrix.",
        "proto" :"void (*chacha_block_generic)(u32 *state, u8 *stream, int nrounds)",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [12, 20]"
        }
    }
},
{
    "kretprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha. HChaCha is the ChaCha equivalent of HSalsa and is an intermediate step towards XChaCha. HChaCha skips the final addition of the initial state, and outputs only certain words of the state. It should not be used for streaming directly.",
        "proto" :"void hchacha_block_generic(const u32 *state, u32 *stream, int nrounds)",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [12, 20]"
        }
    }
},
{
    "kprobe:hchacha_block_generic": {
        "description": "Abbreviated ChaCha core, for XChaCha. HChaCha is the ChaCha equivalent of HSalsa and is an intermediate step towards XChaCha. HChaCha skips the final addition of the initial state, and outputs only certain words of the state. It should not be used for streaming directly.",
        "proto" :"void hchacha_block_generic(const u32 *state, u32 *stream, int nrounds)",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": "in [12, 20]"
        },
    }
},
{
    "kretprobe:poly1305_core_setkey": {
        "description": "Set the key for the poly1305 core function.",
        "proto" :"void poly1305_core_setkey(struct poly1305_core_key *key, const u8 raw_key[POLY1305_BLOCK_SIZE])",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "in [0x0, 0xffffffff]",
            "raw_key[3]": "in [0x0, 0xffffffff]",
            "raw_key[6]": "in [0x0, 0xffffffff]",
            "raw_key[9]": "in [0x0, 0xffffffff]",
            "raw_key[12]": "in [0x0, 0xffffffff]"
        },
        "post": {
            "key->key.r[0]": "in [0x0, 0x3ffffff]",
            "key->key.r[1]": "in [0x0, 0x3ffff03]",
            "key->key.r[2]": "in [0x0, 0x3ffc0ff]",
            "key->key.r[3]": "in [0x0, 0x3f03fff]",
            "key->key.r[4]": "in [0x0, 0x00fffff]"
        }
    }
},
{
    "kprobe:poly1305_core_setkey": {
        "description": "Sets the key for the poly1305 core function.",
        "proto" :"static void (*poly1305_core_setkey)(struct poly1305_core_key *key, const u8 raw_key[POLY1305_BLOCK_SIZE])",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key[0]": "in [0x00, 0xff]",
            "raw_key[3]": "in [0x00, 0xff]",
            "raw_key[6]": "in [0x00, 0xff]",
            "raw_key[9]": "in [0x00, 0xff]",
            "raw_key[12]": "in [0x00, 0xff]",
            "key->key.r[0]": "in [0x00, 0x3ffffff]",
            "key->key.r[1]": "in [0x00, 0x3ffff03]",
            "key->key.r[2]": "in [0x00, 0x3ffc0ff]",
            "key->key.r[3]": "in [0x00, 0x3f03fff]",
            "key->key.r[4]": "in [0x00, 0x00fffff]"
        }
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "This function performs the core blocks operation for the Poly1305 algorithm.",
        "proto" :"static void (*poly1305_core_blocks)(struct poly1305_state *state, const struct poly1305_core_key *key, const void *src, unsigned int nblocks, u32 hibit)",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">=0",
            "hibit": "in [0, 1]"
        },
        "post": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">=0",
            "hibit": "in [0, 1]"
        }
    }
},
{
    "kprobe:poly1305_core_blocks": {
        "description": "Performs the core blocks operation for the Poly1305 algorithm.",
        "proto": "void poly1305_core_blocks(struct poly1305_state *state, const struct poly1305_core_key *key, const void *src, unsigned int nblocks, u32 hibit)",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">=0",
            "hibit": "in [0, 1]"
        }
    }
},
{
    "kretprobe:poly1305_core_emit": {
        "description": "Fully carry h",
        "proto" :"poly1305_core_emit(const struct poly1305_state *state, const u32 nonce[4], void *dst)",
        "pre": {
            "state": "!=null",
            "nonce": "!=null",
            "dst": "!=null"
        },
    }
},
{
    "kprobe:poly1305_core_emit": {
        "description": "Fully carry h",
        "proto" :"poly1305_core_emit(const struct poly1305_state *state, const u32 nonce[4], void *dst)",
        "pre": {
            "state": "!=null",
            "nonce": "!=null",
            "dst": "!=null"
        },
        "post": {
            "h0": "in [0, 0x3ffffff]",
            "h1": "in [0, 0x3ffffff]",
            "h2": "in [0, 0x3ffffff]",
            "h3": "in [0, 0x3ffffff]",
            "h4": "in [0, 0x3ffffff]",
            "c": "is a natural number"
        }
    }
},
{
    "kretprobe:__crypto_memneq_generic": {
        "description": "This function compares two memory blocks of a given size and returns true if they are not equal.",
        "proto" :"static long (*__crypto_memneq_generic)(const void *a, const void *b, size_t size)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "size": ">0"
        },
    }
},
{
    "kprobe:__crypto_memneq_generic": {
        "description": "Compares two memory areas of a given size.",
        "proto" :"static long (*__crypto_memneq_generic)(const void *a, const void *b, size_t size)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "size": "> 0",
        },
    }
},
{
    "kretprobe:poly1305_core_setkey": {
        "description": "Sets the key for the poly1305 core.",
        "proto" :"void poly1305_core_setkey(struct poly1305_core_key *key, const u8 raw_key[POLY1305_BLOCK_SIZE])",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null"
        },
    }
},
{
    "kprobe:poly1305_core_setkey": {
        "description": "Sets the key for the poly1305 core.",
        "proto" :"static void (*poly1305_core_setkey)(struct poly1305_core_key *key, const u8 raw_key[POLY1305_BLOCK_SIZE])",
        "pre": {
            "key": "!=null",
            "raw_key": "!=null",
            "raw_key": "size == POLY1305_BLOCK_SIZE"
        },
    }
},
{
    "kretprobe:poly1305_core_blocks": {
        "description": "Performs the core block operations for the Poly1305 algorithm.",
        "proto" :"static void (*poly1305_core_blocks)(struct poly1305_state *state, const struct poly1305_core_key *key, const void *src, unsigned int nblocks, u32 hibit)",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">=0",
            "hibit": "in [0, 1]"
        },
    }
},
{
    "kprobe:poly1305_core_blocks": {
        "description": "This function performs the core blocks operation of the Poly1305 algorithm.",
        "proto" :"static void (*poly1305_core_blocks)(struct poly1305_state *state, const struct poly1305_core_key *key, const void *src, unsigned int nblocks, u32 hibit)",
        "pre": {
            "state": "!=null",
            "key": "!=null",
            "src": "!=null",
            "nblocks": ">=0",
            "hibit": "is a valid u32 value"
        },
    }
},
{
    "kretprobe:poly1305_core_emit": {
        "description": "Fully carry h",
        "proto" :"poly1305_core_emit(const struct poly1305_state *state, const u32 nonce[4], void *dst)",
        "pre": {
            "state": "!=null",
            "nonce": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:poly1305_core_emit": {
        "description": "Fully carry h",
        "proto" :"poly1305_core_emit(const struct poly1305_state  state, const u32 nonce[4],void  dst)",
        "pre": {
            "state": "!=null",
            "nonce": "!=null",
            "dst": "!=null",
            "h0": "your_condition",
            "h1": "your_condition",
            "h2": "your_condition",
            "c": "your_condition",
            "g0": "your_condition",
            "g1": "your_condition",
            "g2": "your_condition",
            "t0": "your_condition",
            "t1": "your_condition"
        },
    }
},
{
    "kretprobe:gf128mul_lle": {
        "description": "The function aims to avoid leaking information about keys through execution time variances. The p array should be aligned to twice the size of its element type, so that every evenodd pair is guaranteed to share a cacheline. This ensures that each be128_xor() call in the loop takes the same amount of time regardless of the value of 'ch', which is derived from function parameter 'b', which is commonly used as a key, e.g., for GHASH.",
        "proto" :"gf128mul_lle(be128  r, const be128  b)",
        "pre": {
            "r": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:gf128mul_lle": {
        "description": "The p array should be aligned to twice the size of its element type, so that every evenodd pair is guaranteed to share a cacheline (assuming a cacheline size of 32 bytes or more, which is by far the most common). This ensures that each be128_xor() call in the loop takes the same amount of time regardless of the value of 'ch', which is derived from function parameter 'b', which is commonly used as a key, e.g., for GHASH. The odd array elements are all set to zero, making each be128_xor() a NOP if its associated bit in 'ch' is not set, and this is equivalent to calling be128_xor() conditionally. This approach aims to avoid leaking information about such keys through execution time variances. Unfortunately, __aligned(16) or higher does not work on x86 for variables on the stack so we need to perform the alignment by hand.",
        "proto" :"gf128mul_lle(be128  r, const be128  b)",
        "pre": {
            "r": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule. Returns: 0 on success, or -EINVAL if @keysize or @authsize contain values that are not permitted by the GCM specification.",
        "proto" :"int aesgcm_expandkey(struct aesgcm_ctx *ctx, const u8 *key, unsigned int keysize, unsigned int authsize)",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": "in [16, 24, 32]",
            "authsize": "in [4, 8, 12, 13, 14, 15, 16]"
        },
    }
},
{
    "kprobe:aesgcm_expandkey": {
        "description": "Expands the AES and GHASH keys for the AES-GCM key schedule. Returns: 0 on success, or -EINVAL if @keysize or @authsize contain values that are not permitted by the GCM specification.",
        "proto" :"int (*aesgcm_expandkey)(struct aesgcm_ctx *ctx, const u8 *key, unsigned int keysize, unsigned int authsize)",
        "pre": {
            "ctx": "!=null",
            "key": "!=null",
            "keysize": "in [16, 24, 32]",
            "authsize": "in [4, 8, 12, 13, 14, 15, 16]"
        },
    }
},

{
    "kprobe:aesgcm_encrypt_block": {
        "description": "In AES-GCM, both the GHASH key derivation and the CTR mode encryption operate on known plaintext, making them susceptible to timing attacks on the encryption key. The AES library already mitigates this risk to some extent by pulling the entire S-box into the caches before doing any substitutions, but this strategy is more effective when running with interrupts disabled.",
        "proto" :"aesgcm_encrypt_block(const struct crypto_aes_ctx  ctx, void  dst, const void  src){unsigned long flags;}",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "flags": "in [local_irq_save, local_irq_restore]"
        },
    }
},
{
    "kretprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data. Returns true on success, or false if the ciphertext failed authentication. On failure, no plaintext will be returned.",
        "proto": "bool __must_check aesgcm_decrypt(const struct aesgcm_ctx *ctx, u8 *dst, const u8 *src, int crypt_len, const u8 *assoc, int assoc_len, const u8 iv[GCM_AES_IV_SIZE], const u8 *authtag)",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null && size==GCM_AES_IV_SIZE",
            "authtag": "!=null"
        }
    }
},
{
    "kprobe:aesgcm_decrypt": {
        "description": "Perform AES-GCM decryption on a block of data. Returns true on success, or false if the ciphertext failed authentication. On failure, no plaintext will be returned.",
        "proto" :"bool __must_check (*aesgcm_decrypt)(const struct aesgcm_ctx *ctx, u8 *dst, const u8 *src, int crypt_len, const u8 *assoc, int assoc_len, const u8 iv[GCM_AES_IV_SIZE], const u8 *authtag)",
        "pre": {
            "ctx": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "crypt_len": ">0",
            "assoc": "!=null",
            "assoc_len": ">=0",
            "iv": "!=null && size==GCM_AES_IV_SIZE",
            "authtag": "!=null"
        }
    }
},


{
    "kretprobe:chacha_crypt_generic": {
        "description": "Aligned to potentially speed up crypto_xor()",
        "proto" :"static long (*chacha_crypt_generic)(u32 state, u8 dst, const u8 src, unsigned int bytes, int nrounds)",
        "pre": {
            "state": "is a valid u32",
            "dst": "is a valid u8",
            "src": "!=null",
            "bytes": "is a valid unsigned int",
            "nrounds": "is a valid int"
        },
    }
},
{
    "kprobe:chacha_crypt_generic": {
        "description": "Aligned to potentially speed up crypto_xor()",
        "proto" :"static long (*chacha_crypt_generic)(u32 state, u8 dst, const u8 src, unsigned int bytes, int nrounds)",
        "pre": {
            "state": "is a valid u32",
            "dst": "is a valid u8",
            "src": "is a valid u8 and !=null",
            "bytes": "is a valid unsigned int",
            "nrounds": "is a valid int",
        },
    }
},
{
    "kretprobe:blake2s_final": {
        "description": "Finalizes the blake2s hashing operation, padding the state buffer, and copying the result into the output buffer.",
        "proto" :"static void (*blake2s_final)(struct blake2s_state *state, u8 *out)",
        "pre": {
            "state": "!=null",
            "out": "!=null"
        }
    }
},
{
    "kprobe:blake2s_final": {
        "description": "Your description here",
        "proto" :"static long (*blake2s_final)(struct blake2s_state *state, u8 *out)",
        "pre": {
            "state": "Your condition here",
            "out": "Your condition here"
        },
    }
},
{
    "kretprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197. The location where the computed key will be stored. The supplied key. The length of the supplied key. Returns 0 on success. The function fails only if an invalid key size (or pointer) is supplied. The expanded key size is 240 bytes (max of 14 rounds with a unique 16 bytes key schedule plus a 16 bytes key which is used before the first round). The decryption key is prepared for the 'Equivalent Inverse Cipher' as described in FIPS-197. The first slot (16 bytes) of each key (enc or dec) is for the initial combination, the second slot for the first round and so on.",
        "proto" :"int aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key, unsigned int key_len)",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": "in [128, 192, 256]"
        },
    }
},
{
    "kprobe:aes_expandkey": {
        "description": "Expands the AES key as described in FIPS-197. The location where the computed key will be stored. The supplied key. The length of the supplied key. Returns 0 on success. The function fails only if an invalid key size (or pointer) is supplied. The expanded key size is 240 bytes (max of 14 rounds with a unique 16 bytes key schedule plus a 16 bytes key which is used before the first round). The decryption key is prepared for the 'Equivalent Inverse Cipher' as described in FIPS-197. The first slot (16 bytes) of each key (enc or dec) is for the initial combination, the second slot for the first round and so on.",
        "proto" :"int aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key, unsigned int key_len)",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": "in [128, 192, 256]"
        },
    }
},
{
    "kretprobe:aes_encrypt": {
        "description": "Encrypt a single AES block. @ctx:Context struct containing the key schedule. @out:Buffer to store the ciphertext. @in:Buffer containing the plaintext.",
        "proto" :"void (*aes_encrypt)(const struct crypto_aes_ctx *ctx, u8 *out, const u8 *in)",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_encrypt": {
        "description": "Encrypt a single AES block. @ctx: Context struct containing the key schedule. @out: Buffer to store the ciphertext. @in: Buffer containing the plaintext.",
        "proto" :"void (*aes_encrypt)(const struct crypto_aes_ctx *ctx, u8 *out, const u8 *in)",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:aes_decrypt": {
        "description": "Decrypt a single AES block. @ctx: Context struct containing the key schedule. @out: Buffer to store the plaintext. @in: Buffer containing the ciphertext.",
        "proto" :"void (*aes_decrypt)(const struct crypto_aes_ctx *ctx, u8 *out, const u8 *in)",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kprobe:aes_decrypt": {
        "description": "Decrypt a single AES block. @ctx: Context struct containing the key schedule. @out: Buffer to store the plaintext. @in: Buffer containing the ciphertext.",
        "proto" :"void (*aes_decrypt)(const struct crypto_aes_ctx *ctx, u8 *out, const u8 *in)",
        "pre": {
            "ctx": "!=null",
            "out": "!=null",
            "in": "!=null"
        }
    }
},
{
    "kretprobe:sha1_transform": {
        "description": "This function executes SHA-1's internal compression function. It updates the 160-bit internal state (@digest) with a single 512-bit data block (@data). Don't use this function. SHA-1 is no longer considered secure. And even if you do have to use SHA-1, this isn't the correct way to hash something with SHA-1 as this doesn't handle padding and finalization. Note: If the hash is security sensitive, the caller should be sure to clear the workspace. This is left to the caller to avoid unnecessary clears between chained hashing operations.",
        "proto": "void (*sha1_transform)(__u32 *digest, const char *data, __u32 *array)",
        "pre": {
            "digest": "!=null",
            "data": "!=null",
            "array": "!=null"
        }
    }
},
{
    "kprobe:sha1_transform": {
        "description": "Single block SHA1 transform (deprecated). This function executes SHA-1's internal compression function. It updates the 160-bit internal state (@digest) with a single 512-bit data block (@data). Note: If the hash is security sensitive, the caller should be sure to clear the workspace. This is left to the caller to avoid unnecessary clears between chained hashing operations.",
        "proto" :"static void (*sha1_transform)(__u32 *digest, const char *data, __u32 *array)",
        "pre": {
            "digest": "!=null",
            "data": "!=null && len(data) == 64", // 512 bits
            "array": "!=null && len(array) == 16", // 16 words
        },
    }
},
{
    "kretprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "proto": "void (*sha1_init)(__u32 *buf)",
        "pre": {
            "buf": "!=null"
        }
    }
},
{
    "kprobe:sha1_init": {
        "description": "Initialize the vectors for a SHA1 digest",
        "proto": "void (*sha1_init)(__u32 *buf)",
        "pre": {
            "buf": "!=null"
        }
    }
},
{
    "kprobe:dim_on_top": {
        "description": "Based on the tune_state of the dim, returns true for DIM_PARKING_ON_TOP and DIM_PARKING_TIRED states, checks for certain conditions for DIM_GOING_RIGHT state, and defaults to DIM_GOING_LEFT.",
        "proto" :"dim_on_top(struct dim  dim)",
        "pre": {
            "dim": "!=null",
            "dim->tune_state": "in [DIM_PARKING_ON_TOP, DIM_PARKING_TIRED, DIM_GOING_RIGHT, DIM_GOING_LEFT]",
            "dim->steps_right": "is integer",
            "dim->steps_left": "is integer"
        },
    }
},
{
    "kretprobe:dim_calc_stats": {
        "description": "dim_calc_stats(struct dim_sample  start, struct dim_sample  end,    struct dim_stats  curr_stats){  u32 holds up to 71 minutes, should be enough",
        "proto" :"static long (*dim_calc_stats)(struct dim_sample *start, struct dim_sample *end, struct dim_stats *curr_stats)",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "curr_stats": "!=null"
        },
    }
},
{
    "kprobe:dim_calc_stats": {
        "description": "Your description here",
        "proto" :"dim_calc_stats(struct dim_sample  start, struct dim_sample  end, struct dim_stats  curr_stats)",
        "pre": {
            "start": "Your condition here",
            "end": "Your condition here",
            "curr_stats": "Your condition here"
        },
    }
},
{
    "kretprobe:rdma_dim_decision": {
        "description": "Description of the function goes here",
        "proto" :"static bool rdma_dim_decision(struct dim_stats *curr_stats, struct dim *dim)",
        "pre": {
            "curr_stats": "!=null",
            "dim": "!=null"
        }
    }
},
{
    "kprobe:rdma_dim_step": {
        "description": "Description of the rdma_dim_step function",
        "proto" :"static int (*rdma_dim_step)(struct dim *dim)",
        "pre": {
            "dim": "!=null"
        }
    }
},
{
    "kretprobe:LZ4_decompress_safe_withPrefix64k": {
        "description": "Decompresses the data from *source* to *dest* with a maximum output size of *maxOutputSize*. The size of the compressed data is *compressedSize*.",
        "proto" :"static int (*LZ4_decompress_safe_withPrefix64k)(const char *source, char *dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        },
    }
},
{
    "kprobe:LZ4_decompress_safe_withPrefix64k": {
        "description": "Decompresses the data from *source* to *dest* using LZ4 algorithm with a 64KB prefix. The size of the compressed data is *compressedSize* and the maximum output size is *maxOutputSize*.",
        "proto" :"static int (*LZ4_decompress_safe_withPrefix64k)(const char *source, char *dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "source": "!=null",
            "dest": "!=null && has at least maxOutputSize bytes allocated",
            "compressedSize": ">=0",
            "maxOutputSize": ">0"
        },
    }
},
{
    "kretprobe:LZ4_decompress_safe_continue": {
        "description": "These decoding functions allow decompression of multiple blocks in 'streaming' mode. Previously decoded blocks must still be available at the memory position where they were decoded. If it's not possible, save the relevant part of decoded data into a safe buffer, and indicate where it stands using LZ4_setStreamDecode()",
        "proto" :"int LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode,const char *source, char *dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        },
    }
},
{
    "kprobe:LZ4_decompress_safe_continue": {
        "description": "These decoding functions allow decompression of multiple blocks in 'streaming' mode. Previously decoded blocks must still be available at the memory position where they were decoded. If it's not possible, save the relevant part of decoded data into a safe buffer, and indicate where it stands using LZ4_setStreamDecode()",
        "proto" :"int LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode,const char *source, char *dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        },
    }
},
{
    "kretprobe:LZ4_decompress_safe_continue": {
        "description": "The first call, no dictionary yet.",
        "proto" :"int LZ4_decompress_safe_continue(LZ4_streamDecode_t  LZ4_streamDecode, const char  source, char  dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        },
    }
},
{
    "kprobe:LZ4_decompress_safe_continue": {
        "description": "The first call, no dictionary yet.",
        "proto" :"int LZ4_decompress_safe_continue(LZ4_streamDecode_t  LZ4_streamDecode,const char  source, char  dest, int compressedSize, int maxOutputSize)",
        "pre": {
            "LZ4_streamDecode": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "compressedSize": ">=0",
            "maxOutputSize": ">=0"
        },
    }
},
{
    "kretprobe:LZ4_compress_HC_extStateHC": {
        "description": "Compresses data using LZ4 algorithm with high compression level. The state must be aligned for pointers (32 or 64 bits).",
        "proto" :"int LZ4_compress_HC_extStateHC(void *state, const char *src, char *dst, int srcSize, int maxDstSize, int compressionLevel)",
        "pre": {
            "state": "!=null && ((size_t)(state)&(sizeof(void  ) - 1)) == 0",
            "src": "!=null",
            "dst": "!=null",
            "srcSize": ">=0",
            "maxDstSize": ">= LZ4_compressBound(srcSize)",
            "compressionLevel": ">=0"
        },
    }
},
{
    "kprobe:LZ4_compress_HC_extStateHC": {
        "description": "Compresses the source buffer into the destination buffer with high compression level. The state must be aligned for pointers (32 or 64 bits).",
        "proto" :"int LZ4_compress_HC_extStateHC(void *state, const char *src, char *dst, int srcSize, int maxDstSize, int compressionLevel)",
        "pre": {
            "state": "aligned for pointers (32 or 64 bits)",
            "src": "!=null",
            "dst": "!=null",
            "srcSize": ">=0",
            "maxDstSize": ">= LZ4_compressBound(srcSize)",
            "compressionLevel": ">=0",
        },
    }
},
{
    "kretprobe:LZ4_saveDict": {
        "description": "Saves a dictionary to a safe buffer. The dictionary size is limited to 64KB.",
        "proto" :"EXPORT_SYMBOL(int LZ4_saveDict(LZ4_stream_t LZ4_dict, char safeBuffer, int dictSize))",
        "pre": {
            "LZ4_dict": "!=null",
            "safeBuffer": "!=null",
            "dictSize": ">=0 && <=64*KB"
        },
    }
},

{
    "kretprobe:LZ4_compress_fast_continue": {
        "description": "Compresses the data from *source* into *dest* using LZ4 algorithm with *acceleration* factor. Uses *LZ4_stream* for maintaining compression context and *maxOutputSize* to limit the output size.",
        "proto" :"int LZ4_compress_fast_continue(LZ4_stream_t LZ4_stream, const char source, char dest, int inputSize, int maxOutputSize, int acceleration)",
        "pre": {
            "LZ4_stream": "!=null",
            "source": "!=null",
            "dest": "!=null",
            "inputSize": ">0",
            "maxOutputSize": ">=inputSize",
            "acceleration": ">=1",
        },
    }
},

{
    "kretprobe:zstd_init_cstream": {
        "description": "Initialize a ZSTD compression stream. If workspace is NULL, return NULL. If cstream is NULL, return NULL. 0 means unknown in linux zstd API but means 0 in new zstd API.",
        "proto" :"zstd_init_cstream(const zstd_parameters parameters, unsigned long long pledged_src_size, void workspace, size_t workspace_size)",
        "pre": {
            "parameters": "!=null",
            "pledged_src_size": "in [0, ZSTD_CONTENTSIZE_UNKNOWN]",
            "workspace": "!=null",
            "workspace_size": ">= minimum required size"
        },
        "post": {
            "return": "in [NULL, valid cstream pointer]"
        }
    }
},

{
    "kretprobe:find_font": {
        "description": "Find a specified font with string name @name. Returns %NULL if no font found, or a pointer to the specified font.",
        "proto" :"const struct font_desc *(*find_font)(const char *name)",
        "pre": {
            "name": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:find_font": {
        "description": "Find a specified font with string name @name. Returns %NULL if no font found, or a pointer to the specified font.",
        "proto" :"const struct font_desc *(*find_font)(const char *name)",
        "pre": {
            "name": "!=null"
        },
    }
},
{
    "kretprobe:get_default_font": {
        "description": "Get the default font for a specified screen size. Dimensions are in pixels. Returns %NULL if no font is found, or a pointer to the chosen font.",
        "proto" :"const struct font_desc *(*get_default_font)(int xres, int yres, u32 font_w, u32 font_h)",
        "pre": {
            "xres": ">=0",
            "yres": ">=0",
            "font_w": "in [1 - 32]",
            "font_h": "in [1 - 32]"
        },
    }
},
{
    "kprobe:get_default_font": {
        "description": "Get the default font for a specified screen size. Dimensions are in pixels. Returns %NULL if no font is found, or a pointer to the chosen font.",
        "proto" :"const struct font_desc *(*get_default_font)(int xres, int yres, u32 font_w, u32 font_h)",
        "pre": {
            "xres": ">=0",
            "yres": ">=0",
            "font_w": "in [1 - 32]",
            "font_h": "in [1 - 32]"
        }
    }
},
{
    "kretprobe:rational_best_approximation": {
        "description": "This function takes a fixed point number (given_numerator/given_denominator) and approximates it as a rational number with the best numerator and best denominator. The maximum values for the best numerator and best denominator are also provided. For more theoretical background, see: https://en.wikipedia.org/wiki/Continued_fraction",
        "proto" :"void rational_best_approximation(unsigned long given_numerator, unsigned long given_denominator, unsigned long max_numerator, unsigned long max_denominator, unsigned long *best_numerator, unsigned long *best_denominator)",
        "pre": {
            "given_numerator": ">=0",
            "given_denominator": ">0",
            "max_numerator": ">=0",
            "max_denominator": ">=0",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},
{
    "kprobe:rational_best_approximation": {
        "description": "This function takes a fixed point number (given_numerator/given_denominator) and approximates it as a rational number with the best numerator and denominator. The maximum values for the numerator and denominator are also provided. The function uses the method of continued fractions for the approximation. For more information, see: https://en.wikipedia.org/wiki/Continued_fraction",
        "proto" :"static void (*rational_best_approximation)(unsigned long given_numerator, unsigned long given_denominator, unsigned long max_numerator, unsigned long max_denominator, unsigned long *best_numerator, unsigned long *best_denominator)",
        "pre": {
            "given_numerator": ">=0",
            "given_denominator": ">0",
            "max_numerator": ">=0",
            "max_denominator": ">0",
            "best_numerator": "!=null",
            "best_denominator": "!=null"
        }
    }
},

{
    "kprobe:reciprocal_value_adv": {
        "description": "This function calculates the reciprocal value of 'd' with a precision of 'prec'. It returns a structure 'R' containing the reciprocal value. Note that 'mlow/mhigh' could overflow u64 when 'l == 32'. This case needs to be handled before calling 'reciprocal_value_adv'.",
        "proto" :"reciprocal_value_adv reciprocal_value_adv(u32 d, u8 prec)",
        "pre": {
            "d": "Your condition here",
            "prec": "Your condition here"
        },
    }
},
{
    "kretprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for given angle theta.",
        "proto" :"struct cordic_iq (*cordic_calc_iq)(s32 theta)",
        "pre": {
            "theta": "in [-360, 360]"
        }
    }
},
{
    "kprobe:cordic_calc_iq": {
        "description": "Calculates the iq coordinate for given angle theta.",
        "proto" :"struct cordic_iq (*cordic_calc_iq)(s32 theta)",
        "pre": {
            "theta": "your_condition_here"
        }
    }
},

{
    "kprobe:__div64_32": {
        "description": "__div64_32() can be overridden by linking arch-specific assembly versions such as archppclibdiv64.S and archshlibdiv64.S or by defining a preprocessor macro in archincludeasmdiv64.h.",
        "proto" :"static long (*__div64_32)(uint64_t *dividend, uint32_t divisor)",
        "pre": {
            "dividend": "!=null",
            "divisor": "!=null && !=0",
        },
    }
},
{
    "kretprobe:div64_u64_rem": {
        "description": "Unsigned 64bit divide with 64bit divisor and remainder. This implementation is a comparable to algorithm used by div64_u64. But this operation, which includes math for calculating the remainder, is kept distinct to avoid slowing down the div64_u64 operation on 32bit systems.",
        "proto" :"#ifndef div64_u64_remu64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)",
        "pre": {
            "dividend": ">=0",
            "divisor": ">0",
            "remainder": "!=null"
        },
    }
},
{
    "kprobe:div64_u64_rem": {
        "description": "Unsigned 64bit divide with 64bit divisor and remainder. This implementation is a comparable to algorithm used by div64_u64. But this operation, which includes math for calculating the remainder, is kept distinct to avoid slowing down the div64_u64 operation on 32bit systems.",
        "proto" :"#ifndef div64_u64_remu64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)",
        "pre": {
            "dividend": "is u64",
            "divisor": "is u64 and !=0",
            "remainder": "!=null"
        }
    }
},
{
    "kretprobe:mul_u64_u64_div_u64": {
        "description": "Multiply two 64-bit unsigned integers a and b, then divide the result by a third 64-bit unsigned integer c. The function checks if the multiplication of a and b can overflow.",
        "proto" :"static u64 (*mul_u64_u64_div_u64)(u64 a, u64 b, u64 c)",
        "pre": {
            "a": ">=0",
            "b": ">=0",
            "c": "!=0",
            "overflow": "if (ilog2(a) + ilog2(b) > 62) == false"
        },
    }
},
{
    "kprobe:mul_u64_u64_div_u64": {
        "description": "Multiply 'a' and 'b', divide the result by 'c', and return the result. Check if the multiplication of 'a' and 'b' can cause an overflow.",
        "proto" :"static u64 (*mul_u64_u64_div_u64)(u64 a, u64 b, u64 c)",
        "pre": {
            "a": ">=0",
            "b": ">=0",
            "c": "!=0",
            "overflow_check": "ilog2(a) + ilog2(b) <= 62"
        },
    }
},
{
    "kretprobe:is_prime_number": {
        "description": "Check if a number is prime.",
        "proto" :"static bool (*is_prime_number)(unsigned long x)",
        "pre": {
            "x": ">=2"
        },
    },
    "kretprobe:slow_next_prime_number": {
        "description": "Find the next prime number.",
        "proto" :"static unsigned long (*slow_next_prime_number)(unsigned long x)",
        "pre": {
            "x": "< ULONG_MAX"
        },
    },
    "kretprobe:clear_multiples": {
        "description": "Clear multiples of a number in a range.",
        "proto" :"static unsigned long (*clear_multiples)(unsigned long x, unsigned long p, unsigned long start, unsigned long end)",
        "pre": {
            "x": ">1",
            "p": "!=null",
            "start": ">=2",
            "end": ">start"
        },
    },
    "kretprobe:expand_to_next_prime": {
        "description": "Expand to the next prime number.",
        "proto" :"static bool (*expand_to_next_prime)(unsigned long x)",
        "pre": {
            "x": ">1"
        },
    }
},
{
    "kprobe:expand_to_next_prime": {
        "description": "This function expands to the next prime number. It uses Bertrand's Postulate (or Chebyshev's theorem) which states that if n > 3, there is always at least one prime p between n and 2n - 2. Equivalently, if n > 1, then there is always at least one prime p such that n < p < 2n.",
        "proto" :"static bool expand_to_next_prime(unsigned long x)",
        "pre": {
            "x": ">=1",
        },
    }
},
{
    "kretprobe:int_sqrt": {
        "description": "Computes the integer square root of x.",
        "proto" :"static unsigned long (*int_sqrt)(unsigned long x)",
        "pre": {
            "x": ">=0"
        },
        "post": {
            "return": ">=0 && return*return <= x && (return+1)*(return+1) > x"
        }
    }
},
{
    "kprobe:int_sqrt": {
        "description": "Computes the integer square root",
        "proto" :"unsigned long (*int_sqrt)(unsigned long x)",
        "pre": {
            "x": ">=0"
        },
    }
},
{
    "kretprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "proto" :"static u32 (*int_sqrt64)(u64 x)",
        "pre": {
            "x": ">=0"
        }
    }
},
{
    "kprobe:int_sqrt64": {
        "description": "Strongly typed int_sqrt function when minimum 64 bit input is expected.",
        "proto" :"static u32 (*int_sqrt64)(u64 x)",
        "pre": {
            "x": ">=0"
        }
    }
},
{
    "kretprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record. Determine of the PCI device associated with this device matches the record data provided. Searches the descriptor TLVs and extracts the relevant descriptor data into a pldm_pci_record_id. This is then compared against the PCI device ID information.",
        "proto" :"bool (*pldmfw_op_pci_match_record)(struct pldmfw *context, struct pldmfw_record *record)",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:pldmfw_op_pci_match_record": {
        "description": "Check if a PCI device matches the record. Determine if the PCI device associated with this device matches the record data provided. Searches the descriptor TLVs and extracts the relevant descriptor data into a pldm_pci_record_id. This is then compared against the PCI device ID information.",
        "proto" :"bool (*pldmfw_op_pci_match_record)(struct pldmfw *context, struct pldmfw_record *record)",
        "pre": {
            "context": "!=null",
            "record": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device. Parse the data for a given firmware file, verifying that it is a valid PLDM formatted image that matches this device. Extract the device record Package Data and Component Tables and send them to the device firmware. Extract and write the flash data for each of the components indicated in the firmware file.",
        "proto" :"int (*pldmfw_flash_image)(struct pldmfw *context, const struct firmware *fw)",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:pldmfw_flash_image": {
        "description": "Write a PLDM-formatted firmware image to the device. Parse the data for a given firmware file, verifying that it is a valid PLDM formatted image that matches this device. Extract the device record Package Data and Component Tables and send them to the device firmware. Extract and write the flash data for each of the components indicated in the firmware file.",
        "proto" :"int (*pldmfw_flash_image)(struct pldmfw *context, const struct firmware *fw)",
        "pre": {
            "context": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kretprobe:dfltcc_can_inflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "proto" :"static int (*dfltcc_can_inflate)(z_streamp strm)",
        "pre": {
            "strm": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:dfltcc_can_inflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "proto" :"static int (*dfltcc_can_inflate)(z_streamp strm)",
        "pre": {
            "strm": "!=null",
        },
    }
},
{
    "kretprobe:dfltcc_can_inflate": {
        "description": "Expand.",
        "proto" :"int (*dfltcc_can_inflate)(z_streamp strm)",
        "pre": {
            "strm": "!=null"
        }
    }
},

{
    "kretprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "proto" :"static long (*dfltcc_can_deflate)(z_streamp strm)",
        "pre": {
            "strm": "!=null"
        },
    }
},
{
    "kprobe:dfltcc_can_deflate": {
        "description": "Check for kernel dfltcc command line parameter",
        "proto" :"z_streamp strm",
        "pre": {
            "strm": "!=null",
        },
    }
},
{
    "kretprobe:dfltcc_reset_deflate_state": {
        "description": "Reset the deflate state and initialize tuning parameters.",
        "proto" :"void dfltcc_reset_deflate_state(z_streamp strm)",
        "pre": {
            "strm": "!=null",
            "strm->state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "zlib_dfltcc_support": "in [ZLIB_DFLTCC_FULL_DEBUG, ...]",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "== DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "== DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": "== DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},
{
    "kprobe:dfltcc_reset_deflate_state": {
        "description": "Initialize tuning parameters",
        "proto" :"void dfltcc_reset_deflate_state(z_streamp strm)",
        "pre": {
            "strm": "!=null",
            "strm->state": "!=null",
            "dfltcc_state": "!=null",
            "dfltcc_state->common": "!=null",
            "dfltcc_state->level_mask": "in [DFLTCC_LEVEL_MASK_DEBUG, DFLTCC_LEVEL_MASK]",
            "dfltcc_state->block_size": "== DFLTCC_BLOCK_SIZE",
            "dfltcc_state->block_threshold": "== DFLTCC_FIRST_FHT_BLOCK_SIZE",
            "dfltcc_state->dht_threshold": "== DFLTCC_DHT_MIN_SAMPLE_SIZE"
        }
    }
},

{
    "kprobe:dfltcc_can_deflate": {
        "description": "Compress.",
        "proto" :"int dfltcc_can_deflate(z_streamp strm)",
        "pre": {
            "strm": "???", // replace ??? with the actual constraints
        },
    }
},
{
    "kretprobe:zlib_deflate": {
        "description": "Exported symbols for the deflate functionality.",
        "proto" :"static long (*zlib_deflate)(void *param1, const void *param2, const void *param3, __u64 flags)",
        "pre": {
            "param1": "!=null",
            "param2": "!=null",
            "param3": "!=null",
            "flags": "in [CONSTRAINT1, CONSTRAINT2, CONSTRAINT3]",
        },
    }
},
{
    "kprobe:zlib_deflate": {
        "description": "Exported symbols for the deflate functionality.",
        "proto" :"int (*zlib_deflate)(struct z_stream_s *stream, int flush)",
        "pre": {
            "stream": "!=null",
            "flush": "in [Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK, Z_TREES]"
        },
    }
},
{
    "kretprobe:crypto_sha256_arm_update": {
        "description": "Update the sha256 hash with new data. Make sure casting to sha256_block_fn() is safe.",
        "proto" :"static long (*crypto_sha256_arm_update)(struct shash_desc *desc, const u8 *data, unsigned int len)",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kprobe:crypto_sha256_arm_update": {
        "description": "Update the sha256 hash with new data. Make sure casting to sha256_block_fn() is safe.",
        "proto" :"static long (*crypto_sha256_arm_update)(struct shash_desc *desc, const u8 *data, unsigned int len)",
        "pre": {
            "desc": "!=null",
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:zynq_cpun_start": {
        "description": "zynq_cpun_start() because it is not in __init section.",
        "proto" :"static int ncores;int zynq_cpun_start(u32 address, int cpu)",
        "pre": {
            "address": "!=null",
            "cpu": ">=0",
        },
    }
},
{
    "kprobe:zynq_cpun_start": {
        "description": "zynq_cpun_start() because it is not in __init section.",
        "proto" :"static int ncores;int zynq_cpun_start(u32 address, int cpu)",
        "pre": {
            "address": "!=null",
            "cpu": "is integer",
        },
    }
},
{
    "kretprobe:pfn_valid": {
        "description": "Checks if the address is less than pageblock_size bytes away from a present memory chunk. If it is, there will still be a memory map entry for it because we round freed memory map to the pageblock boundaries.",
        "proto" :"unsigned long (*pfn_valid)(unsigned long pfn)",
        "pre": {
            "pfn": ">= 0"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pfn_valid": {
        "description": "If address less than pageblock_size bytes away from a present memory chunk there still will be a memory map entry for it because we round freed memory map to the pageblock boundaries.",
        "proto" :"pfn_valid(unsigned long pfn){phys_addr_t addr = __pfn_to_phys(pfn);unsigned long pageblock_size = PAGE_SIZE   pageblock_nr_pages;if (__phys_to_pfn(addr) != pfn)return 0;    If address less than pageblock_size bytes away from a present   memory chunk there still will be a memory map entry for it   because we round freed memory map to the pageblock boundaries.",
        "pre": {
            "pfn": ">=0",
            "addr": ">=0",
            "pageblock_size": ">0",
        },
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "Writeback any data associated with the kernel mapping of this page. This ensures that data in the physical page is mutually coherent with the kernels mapping.",
        "proto" :"void (*flush_dcache_page)(struct address_space *mapping, struct page *page)",
        "pre": {
            "mapping": "!=null",
            "page": "!=null && !PageHighMem(page)"
        }
    }
},

{
    "kretprobe:function_using_empty_zero_page": {
        "description": "A function that uses the global variable empty_zero_page.",
        "proto" :"void (*function_using_empty_zero_page)(struct page *p)",
        "pre": {
            "p": "!=null",
        },
    }
},
{
    "EXPORT_SYMBOL:empty_zero_page": {
        "description": "empty_zero_page is a special page that is used for zero-initialized data and COW.",
        "proto" :"struct page *empty_zero_page",
        "pre": {},
    }
},
{
    "__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto": "unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long)KERNEL_START && x <= (unsigned long)KERNEL_END"
        },
        "post": {
            "return": "is a physical address corresponding to the symbol address x"
        }
    }
},
{
    "__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long)KERNEL_START && x <= (unsigned long)KERNEL_END"
        },
    }
},
{
    "__arm_ioremap_pfn_caller": {
        "description": "High mappings must be supersection aligned",
        "proto" :"__arm_ioremap_pfn_caller(unsigned long pfn, unsigned long offset, size_t size, unsigned int mtype, void *caller)",
        "pre": {
            "pfn": ">= 0x100000",
            "offset": "any",
            "size": "any",
            "mtype": "any",
            "caller": "!=null"
        },
    }
},
{
    "kprobe:__arm_ioremap_pfn_caller": {
        "description": "High mappings must be supersection aligned",
        "proto" :"static long (*__arm_ioremap_pfn_caller)(unsigned long pfn, unsigned long offset, size_t size, unsigned int mtype, void  caller)",
        "pre": {
            "pfn": ">= 0x100000",
            "paddr": "& ~SUPERSECTION_MASK",
            "type": "!=null",
            "size": "page aligned",
        },
    }
},
{
    "kretprobe:find_static_vm_paddr": {
        "description": "Re-map IO memory to kernel address space so that we can access it. This allows a driver to remap an arbitrary region of bus memory into virtual space. One should only use readl, writel, memcpy_toio and so on with such remapped areas.",
        "proto" :"static struct static_vm *(*find_static_vm_paddr)(phys_addr_t paddr, size_t size, unsigned int mtype)",
        "pre": {
            "paddr": "your_condition_here",
            "size": "your_condition_here",
            "mtype": "your_condition_here"
        },
    }
},

{
    "kretprobe:unmap_area_sections": {
        "description": "iounmap and ioremap a region, the other CPUs will not see this change until their next context switch. Meanwhile, (eg) if an interrupt comes in on one of those other CPUs which requires the new ioremap'd region to be referenced, the CPU will reference the _old_ region. Note that get_vm_area_caller() allocates a guard 4K page, so we need to mask the size back to 1MB aligned or we will overflow in the loop below.",
        "proto" :"static void unmap_area_sections(unsigned long virt, unsigned long size)",
        "pre": {
            "virt": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:unmap_area_sections": {
        "description": "iounmap and ioremap a region, the other CPUs will not see this change until their next context switch. Meanwhile, (eg) if an interrupt comes in on one of those other CPUs which requires the new ioremap'd region to be referenced, the CPU will reference the _old_ region. Note that get_vm_area_caller() allocates a guard 4K page, so we need to mask the size back to 1MB aligned or we will overflow in the loop below.",
        "proto" :"static void (*unmap_area_sections)(unsigned long virt, unsigned long size)",
        "pre": {
            "virt": "!=null",
            "size": "is 1MB aligned"
        }
    }
},

{
    "kprobe:setup_mm_for_reboot": {
        "description": "Flushes dcache page(empty_zero_page). We don't need to do anything here for nommu machines.",
        "proto" :"void (*setup_mm_for_reboot)(void)",
        "pre": {
            // Add preconditions here when known
        },
    }
},
{
    "kretprobe:jornada_ssp_reverse": {
        "description": "Reverses input byte. All data received from the mcu needs to be reversed due to its physical location. For example, 01110111 -> 11101110.",
        "proto" :"inline u8 (*jornada_ssp_reverse)(u8 byte)",
        "pre": {
            "byte": "is a valid byte"
        },
        "post": {
            "return": "is the reversed byte of input"
        }
    }
},
{
    "kprobe:jornada_ssp_reverse": {
        "description": "Reverses input byte. We need to reverse all data we receive from the mcu due to its physical location. Returns : 01110111 -> 11101110",
        "proto" :"inline u8 (*jornada_ssp_reverse)(u8 byte)",
        "pre": {
            "byte": "is a valid byte"
        }
    }
},
{
    "kretprobe:jornada_ssp_byte": {
        "description": "Waits for ready ssp bus and sends byte. Waits for fifo buffer to clear and then transmits, if it doesn't then we will timeout after <timeout> rounds. Needs mcu running before its called.",
        "proto" :"int (*jornada_ssp_byte)(u8 byte)",
        "pre": {
            "byte": "in [0, 255]"
        },
        "post": {
            "return": "in [%mcu output, %-ETIMEDOUT]"
        }
    }
},
{
    "kprobe:jornada_ssp_byte": {
        "description": "Waits for ready ssp bus and sends byte. Waits for fifo buffer to clear and then transmits, if it doesn't then we will timeout after <timeout> rounds. Needs mcu running before its called.",
        "proto" :"int (*jornada_ssp_byte)(u8 byte)",
        "pre": {
            "byte": "in [0, 255]"
        },
        "post": {
            "return": "in [-ETIMEDOUT, mcu output]"
        }
    }
},
{
    "kretprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte. Returns jornada_ssp_byte(byte) on success or -ETIMEDOUT on timeout failure.",
        "proto" :"int (*jornada_ssp_inout)(u8 byte)",
        "pre": {
            "byte": "in [0, 255]"
        },
        "post": {
            "return": "in [jornada_ssp_byte(byte), -ETIMEDOUT]"
        }
    }
},
{
    "kprobe:jornada_ssp_inout": {
        "description": "Decide if input is command or trading byte. Returns (jornada_ssp_byte(byte)) on success or %-ETIMEDOUT on timeout failure.",
        "proto" :"int (*jornada_ssp_inout)(u8 byte)",
        "pre": {
            "byte": "is u8"
        }
    }
},
{
    "kretprobe:jornada_ssp_start": {
        "description": "Enable mcu",
        "proto" :"void (*jornada_ssp_start)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:jornada_ssp_start": {
        "description": "Enable mcu",
        "proto" :"static void (*jornada_ssp_start)(void)",
        "pre": {}
    }
},
{
    "kretprobe:jornada_ssp_end": {
        "description": "Disable mcu and turn off lock",
        "proto" :"void (*jornada_ssp_end)(void)",
        "pre": {},
    }
},
{
    "kprobe:jornada_ssp_end": {
        "description": "Disable mcu and turn off lock",
        "proto" :"static void (*jornada_ssp_end)(void)",
        "pre": {}
    }
},
{
    "kretprobe:ssp_write_word": {
        "description": "Wait for a free entry in the SSP transmit FIFO, and write a data word to the SSP port. Wait for the SSP port to start sending the data. The caller is expected to perform the necessary locking.",
        "proto" :"int ssp_write_word(u16 data)",
        "pre": {
            "data": "is 16-bit, MSB justified"
        },
        "post": {
            "return": "in [-ETIMEDOUT, 0]"
        }
    }
},
{
    "kprobe:ssp_write_word": {
        "description": "Wait for a free entry in the SSP transmit FIFO, and write a data word to the SSP port. Wait for the SSP port to start sending the data. The caller is expected to perform the necessary locking.",
        "proto" :"int ssp_write_word(u16 data)",
        "pre": {
            "data": "is 16-bit, MSB justified"
        },
        "post": {
            "return": "in [-ETIMEDOUT, 0]"
        }
    }
},
{
    "kretprobe:ssp_read_word": {
        "description": "Wait for a data word in the SSP receive FIFO, and return the received data. Data is LSB justified. Note: Currently, if data is not expected to be received, this function will wait forever. The caller is expected to perform the necessary locking.",
        "proto" :"int ssp_read_word(u16 *data)",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "in [-ETIMEDOUT, 16-bit data]"
        }
    }
},
{
    "kprobe:ssp_read_word": {
        "description": "Wait for a data word in the SSP receive FIFO, and return the received data. Data is LSB justified. Note: Currently, if data is not expected to be received, this function will wait forever. The caller is expected to perform the necessary locking.",
        "proto" :"int ssp_read_word(u16 *data)",
        "pre": {
            "data": "!=null"
        },
        "post": {
            "return": "in [-ETIMEDOUT, 16-bit data]"
        }
    }
},
{
    "kretprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs. Wait for the SSP to idle, and ensure that the receive FIFO is empty. The caller is expected to perform the necessary locking.",
        "proto" :"int ssp_flush(void)",
        "pre": {},
        "post": {
            "return": "in [-ETIMEDOUT, 0]"
        }
    }
},
{
    "kprobe:ssp_flush": {
        "description": "Flush the transmit and receive FIFOs. Wait for the SSP to idle, and ensure that the receive FIFO is empty. The caller is expected to perform the necessary locking.",
        "proto" :"int (*ssp_flush)(void)",
        "pre": {
        },
        "returns": {
            "ETIMEDOUT": "timeout occurred",
            "0": "success"
        }
    }
},
{
    "kretprobe:ssp_enable": {
        "description": "Turn on the SSP port.",
        "proto": "void (*ssp_enable)(void)",
        "pre": {}
    }
},
{
    "kprobe:ssp_enable": {
        "description": "Turn on the SSP port.",
        "proto" :"void (*ssp_enable)(void)",
        "pre": {
        },
    }
},
{
    "kretprobe:ssp_disable": {
        "description": "Shut down the SSP port. Turn off the SSP port, optionally powering it down.",
        "proto" :"static void (*ssp_disable)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:ssp_disable": {
        "description": "Shut down the SSP port. Turn off the SSP port, optionally powering it down.",
        "proto" :"static void (*ssp_disable)(void)",
        "pre": {}
    }
},
{
    "kretprobe:ssp_save_state": {
        "description": "Save the configured SSP state for suspend.",
        "proto" :"void (*ssp_save_state)(struct ssp_state *ssp)",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kprobe:ssp_save_state": {
        "description": "Save the configured SSP state for suspend.",
        "proto" :"void (*ssp_save_state)(struct ssp_state *ssp)",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kretprobe:ssp_restore_state": {
        "description": "Restore the SSP configuration saved previously by ssp_save_state.",
        "proto": "void (*ssp_restore_state)(struct ssp_state *ssp)",
        "pre": {
            "ssp": "!=null"
        }
    }
},
{
    "kprobe:ssp_restore_state": {
        "description": "Restore the SSP configuration saved previously by ssp_save_state.",
        "proto" :"static void (*ssp_restore_state)(struct ssp_state *ssp)",
        "pre": {
            "ssp": "!=null",
        },
    }
},
{
    "kretprobe:ssp_init": {
        "description": "Setup the SSP port, initialise and claim resources for the SSP port.",
        "proto" :"int (*ssp_init)(void)",
        "post": {
            "return": "in [-ENODEV, -EBUSY, 0]"
        }
    }
},
{
    "kprobe:ssp_init": {
        "description": "Setup the SSP port, initialise and claim resources for the SSP port. Returns: %-ENODEV if the SSP port is unavailable, %-EBUSY if the resources are already in use, %0 on success.",
        "proto" :"int (*ssp_init)(void)",
        "pre": {
        },
    }
},
{
    "kretprobe:ssp_exit": {
        "description": "Undo the effects of ssp_init, release and free resources for the SSP port.",
        "proto" :"void (*ssp_exit)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:ssp_exit": {
        "description": "Undo the effects of ssp_init, release and free resources for the SSP port.",
        "proto" :"static void (*ssp_exit)(void)",
        "pre": {}
    }
},
{
    "kretprobe:ep93xx_pwm_acquire_gpio": {
        "description": "Acquire GPIO for PWM. If pdev->id is 0, err is 0. If pdev->id is 1, request GPIO and set its direction. If any error occurs, return err.",
        "proto" :"int ep93xx_pwm_acquire_gpio(struct platform_device  pdev)",
        "pre": {
            "pdev": "!=null",
            "pdev->id": "in [0, 1]"
        },
        "post": {
            "return": "in [0, err]"
        }
    }
},
{
    "kprobe:ep93xx_pwm_acquire_gpio": {
        "description": "Acquires the GPIO for the PWM. If the id of the platform device is 0, no error occurs. If the id is 1, it requests the GPIO line EGPIO14 and sets its direction to output. If any error occurs during these operations, it returns the error.",
        "proto" :"int ep93xx_pwm_acquire_gpio(struct platform_device  *pdev)",
        "pre": {
            "pdev": "!=null",
            "pdev->id": "in [0, 1]"
        },
    }
},

{
    "kprobe:ep93xx_pwm_release_gpio": {
        "description": "Releases the GPIO line EGPIO[14] if the platform device id is 1.",
        "proto" :"static void (*ep93xx_pwm_release_gpio)(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null",
            "pdev->id": "==1"
        }
    }
},
{
    "kretprobe:ep93xx_keypad_acquire_gpio": {
        "description": "Description of the function",
        "proto" :"static long (*ep93xx_keypad_acquire_gpio)(struct platform_device *pdev, int i)",
        "pre": {
            "pdev": "!=null",
            "i": ">=0 && <=7",
        },
    }
},
{
    "kprobe:ep93xx_keypad_acquire_gpio": {
        "description": "Enable the keypad controller; GPIO ports C and D used for keypad",
        "proto" :"static int (*ep93xx_keypad_acquire_gpio)(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null",
            // Add more conditions here based on your understanding of the function
        },
    }
},
{
    "kretprobe:ep93xx_keypad_release_gpio": {
        "description": "Disable the keypad controller; GPIO ports C and D used for GPIO.",
        "proto" :"void ep93xx_keypad_release_gpio(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:ep93xx_keypad_release_gpio": {
        "description": "Disable the keypad controller; GPIO ports C and D used for GPIO.",
        "proto" :"void ep93xx_keypad_release_gpio(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:ep93xx_i2s_acquire": {
        "description": "This is potentially racy with the clock api for i2s_mclk, sclk and lrclk. Since the i2s driver is the only user of those clocks we rely on it to prevent parallel use of this function and the clock api for the i2s clocks.",
        "proto" :"void ep93xx_i2s_acquire(void)",
        "pre": {
            // Fill in the preconditions here
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:ep93xx_i2s_acquire": {
        "description": "This function is potentially racy with the clock api for i2s_mclk, sclk and lrclk. Since the i2s driver is the only user of those clocks we rely on it to prevent parallel use of this function and the clock api for the i2s clocks.",
        "proto" :"void ep93xx_i2s_acquire(void)",
        "pre": {
            "EP93XX_SYSCON_DEVCFG_I2SONAC97": "!=null",
            "EP93XX_SYSCON_DEVCFG_I2S_MASK": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV": "!=null",
            "EP93XX_I2SCLKDIV_MASK": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_ORIDE": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV_SPOL": "!=null",
            "EP93XX_SYSCON_I2SCLKDIV": "!=null",
        },
    }
},
{
    "kretprobe:ep93xx_ide_acquire_gpio": {
        "description": "Fill in the description here",
        "proto" :"static long (*ep93xx_ide_acquire_gpio)(struct platform_device  pdev)",
        "pre": {
            "pdev": "!=null",
            // Add other conditions here
        },
    }
},
{
    "kprobe:ep93xx_ide_acquire_gpio": {
        "description": "GPIO ports E[7:2], G[7:4] and H used by IDE",
        "proto" :"ep93xx_ide_acquire_gpio(struct platform_device  pdev)",
        "pre": {
            "pdev": "!=null",
            "EP93XX_GPIO_LINE_EGPIO2": "!=null",
            "EP93XX_GPIO_LINE_EGPIO15": "!=null",
            "EP93XX_GPIO_LINE_E": "!=null",
            "EP93XX_GPIO_LINE_G": "!=null",
            "EP93XX_GPIO_LINE_H": "!=null",
            "err": "==0",
            "i": "in [0, 8]"
        },
    }
},

{
    "kprobe:ep93xx_ide_release_gpio": {
        "description": "Free the GPIO ports E[7:2], G[7:4] and H used by GPIO.",
        "proto" :"void ep93xx_ide_release_gpio(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:iowrite16": {
        "description": "Please fill in the description here",
        "proto" :"static void (*iowrite16)(u16 value, void __iomem *addr)",
        "pre": {
            "value": "Please fill in the condition here",
            "addr": "Please fill in the condition here"
        },
    }
},
{
    "kprobe:iowrite16": {
        "description": "Writes a 16 bit value to the specified I/O port.",
        "proto" :"void iowrite16(u16 value, void __iomem *addr)",
        "pre": {
            "value": "in [0x0000, 0xFFFF]",
            "addr": "!=null",
        },
    }
},


{
    "kretprobe:krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "proto" :"void krait_set_l2_indirect_reg(u32 addr, u32 val)",
        "pre": {
            "addr": "!=null",
            "val": "!=null"
        },
    }
},
{
    "kprobe:krait_set_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then write to the window via l2cpdr.",
        "proto" :"void krait_set_l2_indirect_reg(u32 addr, u32 val)",
        "pre": {
            "addr": "is a valid 32-bit address",
            "val": "is a valid 32-bit value"
        }
    }
},
{
    "kretprobe:krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "proto" :"krait_get_l2_indirect_reg(u32 addr){u32 val;unsigned long flags;raw_spin_lock_irqsave(&krait_l2_lock, flags);asm volatile ('mcr p15, 3, %0, c15, c0, 6 @ l2cpselr' : : 'r' (addr));isb();asm volatile ('mrc p15, 3, %0, c15, c0, 7 @ l2cpdr' : '=r' (val));raw_spin_unlock_irqrestore(&krait_l2_lock, flags);return val;}",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:krait_get_l2_indirect_reg": {
        "description": "Select the L2 window by poking l2cpselr, then read from the window via l2cpdr.",
        "proto" :"krait_get_l2_indirect_reg(u32 addr)",
        "pre": {
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:sharpsl_param_info": {
        "description": "Certain hardware parameters determined at the time of device manufacture, typically including LCD parameters are loaded by the bootloader at the address PARAM_BASE. As the kernel will overwrite them, we need to store them early in the boot process, then pass them to the appropriate drivers. Not all devices use all parameters but the format is common to all.",
        "proto" :"struct sharpsl_param_info (*sharpsl_param_info)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency. The chip is being fed with the 3.6864MHz clock.",
        "proto" :"unsigned int (*sa1111_pll_clock)(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        },
        "post": {
            "return": "is a valid frequency in Hz"
        }
    }
},
{
    "kprobe:sa1111_pll_clock": {
        "description": "Return the current PLL clock frequency.",
        "proto" :"unsigned int (*sa1111_pll_clock)(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        },
    }
},
{
    "kretprobe:sa1111_select_audio_mode": {
        "description": "Frob the SKCR to select AC Link mode or I2S mode for the audio block.",
        "proto" :"void (*sa1111_select_audio_mode)(struct sa1111_dev *sadev, int mode)",
        "pre": {
            "sadev": "!=null",
            "mode": "in [%SA1111_AUDIO_ACLINK, %SA1111_AUDIO_I2S]",
        },
    }
},
{
    "kprobe:sa1111_select_audio_mode": {
        "description": "Frob the SKCR to select AC Link mode or I2S mode for the audio block.",
        "proto" :"void (*sa1111_select_audio_mode)(struct sa1111_dev *sadev, int mode)",
        "pre": {
            "sadev": "!=null",
            "mode": "in [%SA1111_AUDIO_ACLINK, %SA1111_AUDIO_I2S]",
        },
    }
},
{
    "kretprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate @sadev: SA1111 SAC function block @rate: sample rate to select",
        "proto" :"int (*sa1111_set_audio_rate)(struct sa1111_dev *sadev, int rate)",
        "pre": {
            "sadev": "!=null",
            "rate": ">0",
        },
    }
},
{
    "kprobe:sa1111_set_audio_rate": {
        "description": "Set the audio sample rate @sadev: SA1111 SAC function block @rate: sample rate to select",
        "proto" :"int (*sa1111_set_audio_rate)(struct sa1111_dev *sadev, int rate)",
        "pre": {
            "sadev": "!=null",
            "rate": ">0",
        },
    }
},
{
    "kretprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate @sadev: SA1111 SAC function block device",
        "proto" :"int sa1111_get_audio_rate(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_get_audio_rate": {
        "description": "Get the audio sample rate @sadev: SA1111 SAC function block device",
        "proto" :"int (*sa1111_get_audio_rate)(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block @sadev: SA1111 function block device to enable",
        "proto" :"int (*sa1111_enable_device)(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_enable_device": {
        "description": "Enable an on-chip SA1111 function block",
        "proto" :"int (*sa1111_enable_device)(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block",
        "proto": "void sa1111_disable_device(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kprobe:sa1111_disable_device": {
        "description": "Disable an on-chip SA1111 function block",
        "proto" :"void sa1111_disable_device(struct sa1111_dev *sadev)",
        "pre": {
            "sadev": "!=null"
        }
    }
},
{
    "kretprobe:sa1111_bus_type": {
        "description": "If the parent device has a DMA mask associated with it, and this child supports DMA, propagate it down to the children.",
        "proto" :"if (info->dma && sachip->dev->dma_mask)",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        },
    }
},
{
    "kprobe:sa1111_bus_type": {
        "description": "If the parent device has a DMA mask associated with it, and this child supports DMA, propagate it down to the children.",
        "proto" :"static long (*sa1111_bus_type)(void *info, void *sachip)",
        "pre": {
            "info->dma": "!=null",
            "sachip->dev->dma_mask": "!=null"
        },
    }
},
{
    "kretprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "proto" :"static void (*pcibios_fixup_bus)(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pcibios_fixup_bus": {
        "description": "Called after each bus is probed, but before its children are examined.",
        "proto" :"void pcibios_fixup_bus(struct pci_bus *bus)",
        "pre": {
            "bus": "your_condition_here"
        }
    }
},
{
    "kretprobe:set_fiq_handler": {
        "description": "Set the FIQ handler and enable local FIQs. Notify irq controller to standard enable FIQs.",
        "proto" :"static void (*set_fiq_handler)(void *dfl_fiq_insn, size_t size)",
        "pre": {
            "dfl_fiq_insn": "!=null",
            "size": ">0",
        },
    }
},
{
    "kprobe:set_fiq_handler": {
        "description": "Sets a FIQ handler, enables local FIQ, and notifies the IRQ controller to enable standard FIQs.",
        "proto" :"void (*set_fiq_handler)(void *handler, size_t handler_size)",
        "pre": {
            "handler": "!=null",
            "handler_size": ">0",
        },
    }
},




{
    "kretprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "proto" :"elf_check_arch(const struct elf32_hdr  x)",
        "pre": {
            "x": "!=null",
            "x->e_machine": "==EM_ARM"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:elf_check_arch": {
        "description": "Make sure it's an ARM executable",
        "proto" :"elf_check_arch(const struct elf32_hdr  x)",
        "pre": {
            "x": {
                "e_machine": "== EM_ARM"
            }
        },
    }
},
{
    "kretprobe:elf_set_personality": {
        "description": "We only support Linux ELF executables, so always set the personality to LINUX.",
        "proto" :"static void (*elf_set_personality)(const struct elf32_hdr *x)",
        "pre": {
            "x": "!=null"
        }
    }
},
{
    "kprobe:elf_set_personality": {
        "description": "We only support Linux ELF executables, so always set the personality to LINUX.",
        "proto" :"static void (*elf_set_personality)(const struct elf32_hdr *x)",
        "pre": {
            "x": "!=null",
            "x->e_flags": "is defined",
            "current->personality": "is defined",
            "PER_MASK": "is defined",
            "PER_LINUX": "is defined"
        },
    }
},
{
    "kretprobe:omap_readl": {
        "description": "Description of the function's behavior",
        "proto" :"static long (*omap_readl)(void *OCPI_PROT)",
        "pre": {
            "OCPI_PROT": "!=null",
        },
    }
},
{
    "kprobe:omap_readl": {
        "description": "Your function description here.",
        "proto" :"static long (*omap_readl)(void *OCPI_PROT)",
        "pre": {
            "OCPI_PROT": "!=null",
        },
    }
},



{
    "kprobe:omap_readb": {
        "description": "This function needs a more detailed description.",
        "proto" :"static u8 (*omap_readb)(u32 pa)",
        "pre": {
            "pa": ">=0"
        }
    }
},


{
    "kretprobe:omap_set_dma_src_burst_mode": {
        "description": "Set the source burst mode for the DMA channel.",
        "proto" :"int omap_set_dma_src_burst_mode(int lch, enum omap_dma_burst_mode burst_mode)",
        "pre": {
            "lch": ">=0",
            "burst_mode": "in [OMAP_DMA_DATA_BURST_DIS, OMAP_DMA_DATA_BURST_4, OMAP_DMA_DATA_BURST_8]"
        },
    }
},
{
    "kprobe:omap_set_dma_src_burst_mode": {
        "description": "Set the source burst mode for the DMA channel.",
        "proto" :"static void (*omap_set_dma_src_burst_mode)(int lch, enum omap_dma_burst_mode burst_mode)",
        "pre": {
            "lch": ">=0",
            "burst_mode": "in [OMAP_DMA_DATA_BURST_DIS, OMAP_DMA_DATA_BURST_4, OMAP_DMA_DATA_BURST_8, OMAP_DMA_DATA_BURST_16]"
        },
    }
},
{
    "kretprobe:omap_set_dma_dest_burst_mode": {
        "description": "Set the DMA destination burst mode.",
        "proto" :"static void (*omap_set_dma_dest_burst_mode)(int lch, enum omap_dma_burst_mode burst_mode)",
        "pre": {
            "lch": ">=0",
            "burst_mode": "in [OMAP_DMA_DATA_BURST_DIS, OMAP_DMA_DATA_BURST_4, OMAP_DMA_DATA_BURST_8, OMAP_DMA_DATA_BURST_16]"
        },
    }
},

{
    "kretprobe:omap_request_dma": {
        "description": "Request a DMA channel. Exit after first free channel found.",
        "proto" :"int omap_request_dma(int dev_id, const char dev_name, void (callback)(int lch, u16 ch_status, void data), void data, int dma_ch_out)",
        "pre": {
            "dev_id": ">=0",
            "dev_name": "!=null",
            "callback": "!=null",
            "data": "can be null",
            "dma_ch_out": ">=0"
        },
    }
},
{
    "kprobe:omap_request_dma": {
        "description": "Request a DMA channel. Exit after first free channel found.",
        "proto" :"static long (*omap_request_dma)(int dev_id, const char dev_name, void (callback)(int lch, u16 ch_status, void data), void data, int dma_ch_out)",
        "pre": {
            "dev_id": ">=0",
            "dev_name": "!=null",
            "callback": "!=null",
            "data": "can be null",
            "dma_ch_out": ">=0",
        },
    }
},

{
    "kprobe:omap_disable_channel_irq": {
        "description": "Disable all DMA interrupts for the channel to make sure the DMA transfer is stopped.",
        "proto" :"void omap_disable_channel_irq(int lch)",
        "pre": {
            "lch": "in [0, MAX_DMA_CHANNELS-1]",
        },
    }
},
{
    "kretprobe:omap_clear_dma": {
        "description": "omap_start_dma(). Any buffers in flight are discarded.",
        "proto" :"static void (*omap_clear_dma)(int lch)",
        "pre": {
            "lch": ">=0"
        }
    }
},
{
    "kprobe:omap_clear_dma": {
        "description": "omap_start_dma(). Any buffers in flight are discarded.",
        "proto" :"static void (*omap_clear_dma)(int lch)",
        "pre": {
            "lch": ">0",
        },
    }
},

{
    "kprobe:omap_stop_dma": {
        "description": "Disable all interrupts on the channel",
        "proto" :"static void (*omap_stop_dma)(int lch)",
        "pre": {
            "lch": ">=0",
        },
    }
},

{
    "kprobe:omap_get_dma_src_pos": {
        "description": "Returns the programmed source start address in case the DMA transfer on the channel has not been started (no data has been transferred so far).",
        "proto" :"dma_addr_t (*omap_get_dma_src_pos)(int lch)",
        "pre": {
            "lch": "is integer",
            "p": "!=null",
            "dma_omap15xx": "is function",
            "IS_DMA_ERRATA(DMA_ERRATA_3_3)": "is macro",
            "CDAC": "is constant"
        }
    }
},
{
    "kretprobe:omap_get_dma_dst_pos": {
        "description": "Get the destination position of the DMA. If the DMA is omap15xx, the offset is read from CPC, otherwise from CDAC. There is an erratum in omap 3.23.3: sometimes 0 is returned if CSACCDAC is read before the DMA controller finished disabling the channel.",
        "proto" :"int omap_get_dma_dst_pos(int lch)",
        "pre": {
            "lch": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:omap_get_dma_dst_pos": {
        "description": "Reads from either CPC or CDAC depending on the result of dma_omap15xx(). Sometimes 0 is returned if CSACCDAC is read before the DMA controller finished disabling the channel.",
        "proto" :"int omap_get_dma_dst_pos(int lch)",
        "pre": {
            "lch": ">=0",
        },
    }
},
{
    "kretprobe:sx1_getkeylight": {
        "description": "Get current keylight intensity.",
        "proto" :"int sx1_getkeylight(u8 * keylight)",
        "pre": {
            "keylight": "!=null"
        }
    }
},
{
    "kprobe:sx1_getkeylight": {
        "description": "Get current keylight intensity.",
        "proto" :"int (*sx1_getkeylight)(u8 * keylight)",
        "pre": {
            "keylight": "!=null"
        }
    }
},
{
    "kretprobe:sx1_setbacklight": {
        "description": "Set LCD backlight intensity.",
        "proto" :"int (*sx1_setbacklight)(u8 backlight)",
        "pre": {
            "backlight": "in [0, 255]"
        }
    }
},
{
    "kprobe:sx1_setbacklight": {
        "description": "Set LCD backlight intensity.",
        "proto" :"int (*sx1_setbacklight)(u8 backlight)",
        "pre": {
            "backlight": "in [0, 255]",
        },
    }
},
{
    "kretprobe:sx1_getbacklight": {
        "description": "Get current LCD backlight intensity.",
        "proto" :"int sx1_getbacklight (u8 * backlight)",
        "pre": {
            "backlight": "!=null"
        },
        "post": {
            "return": "in [0, SOFIA_MAX_LIGHT_VAL]"
        }
    }
},
{
    "kprobe:sx1_getbacklight": {
        "description": "Get current LCD backlight intensity.",
        "proto" :"int (*sx1_getbacklight)(u8 *backlight)",
        "pre": {
            "backlight": "!=null",
        },
    }
},
{
    "kretprobe:sx1_setmmipower": {
        "description": "Set the power state of the MMI. `onoff` parameter is a boolean-like value where 0 means off and 1 means on.",
        "proto" :"int (*sx1_setmmipower)(u8 onoff)",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},
{
    "kprobe:sx1_setmmipower": {
        "description": "Set the power state of a device.",
        "proto" :"int (*sx1_setmmipower)(u8 onoff)",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sx1_setmmipower": {
        "description": "Set USB power onoff.",
        "proto" :"int (*sx1_setmmipower)(u8 onoff)",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},
{
    "kprobe:sx1_setmmipower": {
        "description": "Set USB power onoff.",
        "proto" :"int (*sx1_setmmipower)(u8 onoff)",
        "pre": {
            "onoff": "in [0, 1]"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            "[parameter3]": "[condition3]",
            "[parameter4]": "[condition4]",
        },
    }
},

{
    "kretprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "proto" :"void kernel_neon_end(void)",
        "pre": {},
        "post": {
            "NEONVFP unit": "disabled"
        }
    }
},
{
    "kprobe:kernel_neon_end": {
        "description": "Disable the NEONVFP unit.",
        "proto" :"void kernel_neon_end(void)",
        "pre": {},
    }
},
{
    "kretprobe:ecard_readchunk": {
        "description": "Reads a chunk from the ecard.",
        "proto" :"int ecard_readchunk(struct in_chunk_dir cd, ecard_t ec, int id, int num)",
        "pre": {
            "cd": "!=null",
            "ec": "!=null",
            "id": "is integer",
            "num": "is integer"
        }
    }
},
{
    "kprobe:ecard_readchunk": {
        "description": "Reads a chunk of data from an ecard.",
        "proto": "int ecard_readchunk(struct in_chunk_dir cd, ecard_t ec, int id, int num)",
        "pre": {
            "cd": "!=null",
            "ec": "!=null",
            "id": "is integer",
            "num": "is integer"
        }
    }
},




{
    "kretprobe:ndelay": {
        "description": "This doesn't bother checking for overflow, as it won't happen (it's an hour) of delay.",
        "proto" :"static void (*ndelay)(unsigned long nsecs)",
        "pre": {
            "nsecs": ">=0"
        }
    }
},
{
    "kprobe:ndelay": {
        "description": "This doesn't bother checking for overflow, as it won't happen (it's an hour) of delay.",
        "proto" :"static void (*ndelay)(unsigned long nsecs)",
        "pre": {
            "nsecs": ">=0",
        },
    }
},
{
    "kretprobe:__virt_to_phys": {
        "description": "Boundary checking against the kernel linear mapping space.",
        "proto": "unsigned long (*__virt_to_phys)(unsigned long x)",
        "pre": {
            "x": "is_linear_mapping(x) || is_kernel_mapping(x)"
        }
    }
},
{
    "__virt_to_phys": {
        "description": "Boundary checking against the kernel linear mapping space.",
        "proto" :"unsigned long (*__virt_to_phys)(unsigned long x)",
        "pre": {
            "x": "is_linear_mapping(x) || is_kernel_mapping(x)"
        },
    }
},
{
    "__phys_addr_symbol": {
        "description": "Boundary checking against the kernel image mapping. __pa_symbol should only be used on kernel symbol addresses.",
        "proto": "unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= kernel_start && <= kernel_end"
        },
    }
},
{
    "__phys_addr_symbol": {
        "description": "Boundary checking against the kernel image mapping. __pa_symbol should only be used on kernel symbol addresses.",
        "proto": "unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= kernel_start && <= kernel_end"
        }
    }
},
{
    "kretprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "proto" :"void (*sbi_console_putchar)(int ch)",
        "pre": {
            "ch": "is int"
        },
        "post": {}
    }
},
{
    "kprobe:sbi_console_putchar": {
        "description": "Writes given character to the console device.",
        "proto" :"void (*sbi_console_putchar)(int ch)",
        "pre": {
            "ch": "is an integer"
        }
    }
},
{
    "kretprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device. Returns the value read from console.",
        "proto" :"int (*sbi_console_getchar)(void)",
        "pre": {},
        "post": {
            "return": "is int"
        }
    }
},
{
    "kprobe:sbi_console_getchar": {
        "description": "Reads a byte from console device. Returns the value read from console.",
        "proto" :"int (*sbi_console_getchar)(void)",
        "pre": {
        },
    }
},
{
    "kretprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "proto" :"static void (*sbi_shutdown)(void)",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:sbi_shutdown": {
        "description": "Remove all the harts from executing supervisor code.",
        "proto" :"static void (*sbi_shutdown)(void)",
        "pre": {}
    }
},


{
    "kretprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts. @cpu_mask: A cpu mask containing all the target harts. Return: 0 on success, appropriate linux error code otherwise.",
        "proto" :"int (*sbi_remote_fence_i)(const struct cpumask *cpu_mask)",
        "pre": {
            "cpu_mask": "!=null"
        },
        "post": {
            "return": "in [0, -EPERM, -EINVAL, -ENOSYS, -EOPNOTSUPP]"
        }
    }
},
{
    "kprobe:sbi_remote_fence_i": {
        "description": "Execute FENCE.I instruction on given remote harts. @cpu_mask: A cpu mask containing all the target harts. Return: 0 on success, appropriate linux error code otherwise.",
        "proto" :"int (*sbi_remote_fence_i)(const struct cpumask *cpu_mask)",
        "pre": {
            "cpu_mask": "!=null"
        }
    }
},
{
    "kretprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "proto" :"int (*sbi_remote_sfence_vma)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "in [0, appropriate linux error code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for the specified virtual address range.",
        "proto" :"int (*sbi_remote_sfence_vma)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0"
        },
    }
},
{
    "kretprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "proto" :"int (*sbi_remote_sfence_vma_asid)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long asid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "asid": ">=0"
        },
        "post": {
            "return": "in [0, appropriate linux error code]"
        }
    }
},
{
    "kprobe:sbi_remote_sfence_vma_asid": {
        "description": "Execute SFENCE.VMA instructions on given remote harts for a virtual address range belonging to a specific ASID.",
        "proto" :"int (*sbi_remote_sfence_vma_asid)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long asid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "asid": ">=0"
        },
    }
},
{
    "kretprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "proto" :"int sbi_remote_hfence_gvma_vmid(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long vmid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "vmid": ">=0"
        },
        "post": {
            "return": "in [0, Error]"
        }
    }
},
{
    "kprobe:sbi_remote_hfence_gvma_vmid": {
        "description": "Execute HFENCE.GVMA instructions on given remote harts for a guest physical address range belonging to a specific VMID.",
        "proto" :"int sbi_remote_hfence_gvma_vmid(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long vmid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "vmid": ">=0"
        },
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "proto" :"int (*sbi_remote_hfence_vvma)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0"
        },
    }
},
{
    "kprobe:sbi_remote_hfence_vvma": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for the current guest virtual address range.",
        "proto" :"int (*sbi_remote_hfence_vvma)(const struct cpumask *cpu_mask, unsigned long start, unsigned long size)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "proto" :"int sbi_remote_hfence_vvma_asid(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long asid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "asid": ">=0"
        },
    }
},
{
    "kprobe:sbi_remote_hfence_vvma_asid": {
        "description": "Execute HFENCE.VVMA instructions on given remote harts for current guest virtual address range belonging to a specific ASID.",
        "proto" :"int sbi_remote_hfence_vvma_asid(const struct cpumask *cpu_mask, unsigned long start, unsigned long size, unsigned long asid)",
        "pre": {
            "cpu_mask": "!=null",
            "start": ">=0",
            "size": ">0",
            "asid": ">=0"
        }
    }
},
{
    "kretprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not. Return: 1 or an extension specific nonzero value if yes, 0 otherwise.",
        "proto" :"long (*sbi_probe_extension)(int extid)",
        "pre": {
            "extid": "is integer"
        },
        "post": {
            "return": "in [0, 1] or extension specific nonzero value"
        }
    }
},
{
    "kprobe:sbi_probe_extension": {
        "description": "Check if an SBI extension ID is supported or not.",
        "proto": "long (*sbi_probe_extension)(int extid)",
        "pre": {
            "extid": "is integer"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "Skip ACPI PCI scan and IRQ initialization.",
        "proto" :"void (*EXPORT_SYMBOL(acpi_pci_disabled))(void)",
        "pre": {},
    }
},
{
    "kprobe:EXPORT_SYMBOL(acpi_pci_disabled)": {
        "description": "Skip ACPI PCI scan and IRQ initialization",
        "proto" :"static long (*EXPORT_SYMBOL(acpi_pci_disabled))(void *param1, void *param2, ...)",
        "pre": {
            "param1": "constraint1",
            "param2": "constraint2",
            "...": "..."
        },
    }
},
{
    "kretprobe:__udelay": {
        "description": "Delays the execution for a specified number of microseconds.",
        "proto" :"void EXPORT_SYMBOL(__udelay)(unsigned long usecs)",
        "pre": {
            "usecs": ">=0"
        }
    }
},
{
    "kprobe:__udelay": {
        "description": "Description of the function",
        "proto" :"static long (*__udelay)(unsigned long usecs)",
        "pre": {
            "usecs": "Your condition here",
        },
    }
},
{
    "kretprobe:__ndelay": {
        "description": "Delays a short period of time.",
        "proto" :"void __ndelay(unsigned long nsecs)",
        "pre": {
            "nsecs": ">=0"
        }
    }
},
{
    "kprobe:__ndelay": {
        "description": "Delays the execution for a number of nanoseconds.",
        "proto" :"void __ndelay(unsigned long nsecs)",
        "pre": {
            "nsecs": ">=0",
        },
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "Writeback any data associated with the kernel mapping of this page. This ensures that data in the physical page is mutually coherent with the kernels mapping.",
        "proto": "void (*flush_dcache_page)(struct address_space *mapping, struct page *page)",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "Writeback any data associated with the kernel mapping of this page. This ensures that data in the physical page is mutually coherent with the kernels mapping.",
        "proto" :"void (*flush_dcache_page)(struct address_space *mapping, struct page *page)",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:raw_copy_to_user": {
        "description": "Bail if we try to copy zero bytes",
        "proto" :"1: addi  r6,r6,-1\n""   movi  r2,-1\n""   beq   r6,r2,3f\n"/* Copy byte by byte for small copies and if src^dst != 0 `",
        "pre": {
            "r6": "your_condition_here",
            "r2": "your_condition_here",
            "r3": "your_condition_here",
            "r4": "your_condition_here",
            "r5": "your_condition_here",
            "r7": "your_condition_here"
        },
    }
},
{
    "kprobe:raw_copy_to_user": {
        "description": "Bail if we try to copy zero bytes",
        "proto" :"raw_copy_to_user:\n""   movi  r2,7\n""   mov   r3,r4\n""   bge   r2,r6,1f\n""   xor   r2,r4,r5\n""   andi  r2,r2,3\n""   movi  r7,3\n""   beq   r2,zero,4f\n",
        "pre": {
            "r2": "your_condition_here",
            "r3": "your_condition_here",
            "r4": "your_condition_here",
            "r5": "your_condition_here",
            "r6": "your_condition_here",
            "r7": "your_condition_here",
        },
    }
},
{
    "kretprobe:ioremap": {
        "description": "Maps the given physical address to a virtual address in the kernel's virtual address space. Returns NULL if the size is zero or if there is a wraparound.",
        "proto" :"static void* (*ioremap)(unsigned long phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Map physical memory into the kernel's virtual address space. Don't allow wraparound or zero size.",
        "proto" :"static void* (*ioremap)(unsigned long phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
            "last_addr": "==phys_addr + size - 1",
            "last_addr": ">phys_addr"
        },
    }
},
{
    "kretprobe:iounmap": {
        "description": "iounmap unmaps nearly everything, so be careful it doesn't free currently pointerpage tables anymore but it wasn't used anyway and might be added later.",
        "proto" :"void (*iounmap)(void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "iounmap unmaps nearly everything, so be careful it doesn't free currently pointerpage tables anymore but it wasn't used anyway and might be added later.",
        "proto" :"void (*iounmap)(void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:get_cycles": {
        "description": "Only read timer if it has been initialized",
        "proto" :"static long (*get_cycles)(void *nios2_cs, void *timer)",
        "pre": {
            "nios2_cs": "!=null",
            "timer": "!=null"
        }
    }
},
{
    "kprobe:get_cycles": {
        "description": "Only read timer if it has been initialized",
        "proto" :"static long (*get_cycles)(void)",
        "pre": {
            "nios2_cs.timer.base": "!=null"
        }
    }
},
{
    "kretprobe:__delay": {
        "description": "Start with WFIT. If an interrupt makes us resume early, use a WFET loop to complete the delay.",
        "proto" :"static void (*__delay)(unsigned long cycles)",
        "pre": {
            "cycles": ">=0",
        },
    }
},
{
    "__delay": {
        "description": "Start with WFIT. If an interrupt makes us resume early, use a WFET loop to complete the delay.",
        "proto" :"__delay(unsigned long cycles)",
        "pre": {
            "cycles": ">=0",
        },
    }
},
{
    "kretprobe:aes_ecb_encrypt": {
        "description": "Encrypts the input data in ECB mode using the provided round key.",
        "proto": "asmlinkage void aes_ecb_encrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks)",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    },
    "kretprobe:aes_ecb_decrypt": {
        "description": "Decrypts the input data in ECB mode using the provided round key.",
        "proto": "asmlinkage void aes_ecb_decrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks)",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    },
    "kretprobe:aes_cbc_encrypt": {
        "description": "Encrypts the input data in CBC mode using the provided round key and initialization vector.",
        "proto": "asmlinkage void aes_cbc_encrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks, u8 iv[])",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0",
            "iv": "!=null"
        }
    },
    "kretprobe:aes_cbc_decrypt": {
        "description": "Decrypts the input data in CBC mode using the provided round key and initialization vector.",
        "proto": "asmlinkage void aes_cbc_decrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks, u8 iv[])",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0",
            "iv": "!=null"
        }
    },
    "kretprobe:aes_ctr_encrypt": {
        "description": "Encrypts the input data in CTR mode using the provided round key and counter.",
        "proto": "asmlinkage void aes_ctr_encrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int bytes, u8 ctr[])",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "bytes": ">=0",
            "ctr": "!=null"
        }
    },
    "kretprobe:aes_xctr_encrypt": {
        "description": "Encrypts the input data in XCTR mode using the provided round key, counter, and byte counter.",
        "proto": "asmlinkage void aes_xctr_encrypt(u8 out[], u8 const in[], u32 const rk[], int rounds, int bytes, u8 ctr[], int byte_ctr)",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "bytes": ">=0",
            "ctr": "!=null",
            "byte_ctr": ">=0"
        }
    },
    "kretprobe:aes_mac_update": {
        "description": "Updates the MAC of the input data using the provided round key, block count, digest, and encryption flags.",
        "proto": "asmlinkage int aes_mac_update(u8 const in[], u32 const rk[], int rounds, int blocks, u8 dg[], int enc_before, int enc_after)",
        "pre": {
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0",
            "dg": "!=null",
            "enc_before": "in [0, 1]",
            "enc_after": "in [0, 1]"
        }
    }
},
{
    "kprobe:aes_ecb_encrypt": {
        "description": "Encrypts a block of data using the AES algorithm in ECB mode.",
        "proto" :"asmlinkage void aes_ecb_encrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks)",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    },
    "kprobe:aes_ecb_decrypt": {
        "description": "Decrypts a block of data using the AES algorithm in ECB mode.",
        "proto" :"asmlinkage void aes_ecb_decrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks)",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0"
        }
    },
    "kprobe:aes_cbc_encrypt": {
        "description": "Encrypts a block of data using the AES algorithm in CBC mode.",
        "proto" :"asmlinkage void aes_cbc_encrypt(u8 out[], u8 const in[], u32 const rk[],int rounds, int blocks, u8 iv[])",
        "pre": {
            "out": "!=null",
            "in": "!=null",
            "rk": "!=null",
            "rounds": ">=0",
            "blocks": ">=0",
            "iv": "!=null"
        }
    },
    ...
},
{
    "kretprobe:ce_aes_expandkey": {
        "description": "The AES key schedule round constants",
        "proto" :"static void ce_aes_expandkey(struct crypto_aes_ctx *ctx, const u8 *in_key, unsigned int key_len)",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": ">=0"
        }
    }
},
{
    "kprobe:ce_aes_expandkey": {
        "description": "The AES key schedule round constants",
        "proto" :"static void (*ce_aes_expandkey)(struct crypto_aes_ctx *ctx, const u8 *in_key, unsigned int key_len)",
        "pre": {
            "ctx": "!=null",
            "in_key": "!=null",
            "key_len": "is a positive integer"
        }
    }
},
{
    "kretprobe:vm_get_page_prot": {
        "description": "There are two conditions required for returning a Normal Tagged memory type: (1) the user requested it via PROT_MTE passed to mmap() or mprotect() and (2) the corresponding vma supports MTE. We register (1) as VM_MTE in the vma->vm_flags and (2) as VM_MTE_ALLOWED. Note that the latter can only be set during the mmap() call since mprotect() does not accept MAP_ flags. Checking for VM_MTE only is sufficient since arch_validate_flags() does not permit (VM_MTE & !VM_MTE_ALLOWED).",
        "proto" :"vm_get_page_prot(unsigned long vm_flags){pteval_t prot = pgprot_val(protection_map[vm_flags & (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]);if (vm_flags & VM_ARM64_BTI)prot |= PTE_GP; if (vm_flags & VM_MTE)prot |= PTE_ATTRINDX(MT_NORMAL_TAGGED);return __pgprot(prot);}EXPORT_SYMBOL(vm_get_page_prot)",
        "pre": {
            "vm_flags": "!=null",
        },
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "There are two conditions required for returning a Normal Tagged memory type: (1) the user requested it via PROT_MTE passed to mmap() or mprotect() and (2) the corresponding vma supports MTE. We register (1) as VM_MTE in the vma->vm_flags and (2) as VM_MTE_ALLOWED. Note that the latter can only be set during the mmap() call since mprotect() does not accept MAP_ flags. Checking for VM_MTE only is sufficient since arch_validate_flags() does not permit (VM_MTE & !VM_MTE_ALLOWED).",
        "proto" :"vm_get_page_prot(unsigned long vm_flags){pteval_t prot = pgprot_val(protection_map[vm_flags & (VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]);if (vm_flags & VM_ARM64_BTI)prot |= PTE_GP; if (vm_flags & VM_MTE)prot |= PTE_ATTRINDX(MT_NORMAL_TAGGED);return __pgprot(prot);}",
        "pre": {
            "vm_flags": "in [VM_READ, VM_WRITE, VM_EXEC, VM_SHARED, VM_ARM64_BTI, VM_MTE]"
        }
    }
},


{
    "kretprobe:pfn_is_map_memory": {
        "description": "Avoid false positives for bogus PFNs, see comment in pfn_valid()",
        "proto" :"static long (*pfn_is_map_memory)(unsigned long pfn)",
        "pre": {
            "pfn": "!=null"
        },
    }
},
{
    "kprobe:pfn_is_map_memory": {
        "description": "Avoid false positives for bogus PFNs, see comment in pfn_valid()",
        "proto" :"unsigned long (*pfn_is_map_memory)(unsigned long pfn)",
        "pre": {
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "HugeTLB pages are always fully mapped and only head page will be set PG_dcache_clean (see comments in __sync_icache_dcache()).",
        "proto" :"static long (*flush_dcache_page)(struct page *page)",
        "pre": {
            "page": "!=null"
        },
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "HugeTLB pages are always fully mapped and only head page will be set PG_dcache_clean (see comments in __sync_icache_dcache()).",
        "proto" :"void flush_dcache_page(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:copy_to_user_page": {
        "description": "Copy user data from/to a page which is mapped into a different processes address space.",
        "proto" :"void (*copy_to_user_page)(struct vm_area_struct *vma, struct page *page, unsigned long uaddr, void *dst, const void *src, unsigned long len)",
        "pre": {
            "vma": "!=null",
            "page": "!=null",
            "uaddr": ">=0",
            "dst": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:copy_to_user_page": {
        "description": "Copy user data from/to a page which is mapped into a different processes address space. Really, we want to allow our 'user space' model to handle this.",
        "proto" :"void (*copy_to_user_page)(struct vm_area_struct *vma, struct page *page, unsigned long uaddr, void *dst, const void *src, unsigned long len)",
        "pre": {
            "vma": "!=null",
            "page": "!=null",
            "uaddr": ">=0",
            "dst": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:copy_highpage": {
        "description": "Copies the content of one page to another and applies MTE tagging if the system supports it.",
        "proto" :"void copy_highpage(struct page *to, struct page *from)",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        },
        "post": {
            "to": "has same content as 'from' before call",
            "from": "remains unchanged"
        }
    }
},
{
    "kprobe:copy_highpage": {
        "description": "Copies the content of one page to another. If the system supports MTE and the source page is tagged, the new page is also tagged.",
        "proto" :"static void (*copy_highpage)(struct page *to, struct page *from)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "kto": "page_address(to) != null",
            "kfrom": "page_address(from) != null",
            "system_supports_mte": "boolean",
            "page_mte_tagged(from)": "boolean"
        },
    }
},
{
    "kretprobe:__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long) KERNEL_START && x <= (unsigned long) KERNEL_END"
        },
    }
},
{
    "__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long) KERNEL_START && x <= (unsigned long) KERNEL_END"
        },
    }
},
{
    "kretprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header. We can't use __hyp_get_vectors() because kvm may still be loaded.",
        "proto" :"static long (*arch_hibernation_header_save)(void *addr, unsigned int max_size)",
        "pre": {
            "addr": "!=null",
            "max_size": ">= sizeof(struct arch_hibernate_hdr)"
        },
    }
},
{
    "kprobe:arch_hibernation_header_save": {
        "description": "Save the hibernation header. We can't use __hyp_get_vectors() because kvm may still be loaded.",
        "proto" :"static long (*arch_hibernation_header_save)(void *addr, unsigned int max_size)",
        "pre": {
            "addr": "!=null",
            "max_size": ">=sizeof(struct arch_hibernate_hdr)"
        },
    }
},
{
    "kretprobe:__multi3": {
        "description": "__multi3 calls for mips64r6, so for that specific case only we implement that intrinsic here. See https:gcc.gnu.orgbugzillashow_bug.cgi?id=82981",
        "proto" :"#if defined(CONFIG_64BIT) && defined(CONFIG_CPU_MIPSR6) && (__GNUC__ < 8)/* multiply 64-bit values, low 64-bits returned `",
        "pre": {
            "param1": "constraint1",
            "param2": "constraint2",
            "param3": "constraint3",
            // add more parameters as needed
        },
    }
},
{
    "#if defined(CONFIG_64BIT) && defined(CONFIG_CPU_MIPSR6) && (__GNUC__ < 8)": {
        "description": "__multi3 calls for mips64r6, so for that specific case only we implement that intrinsic here. See https:gcc.gnu.orgbugzillashow_bug.cgi?id=82981",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your condition here",
            "arg2": "Your condition here",
            "arg3": "Your condition here",
            // Add more arguments as needed
        },
    }
},

{
    "kprobe:arch_local_irq_disable": {
        "description": "Disables local interrupts.",
        "proto" :"void arch_local_irq_disable(void)",
        "pre": {}
    }
},

{
    "kprobe:arch_local_irq_save": {
        "description": "Save the current state of the local interrupt and disable it.",
        "proto" :"void arch_local_irq_save(void)",
        "pre": {},
    }
},
{
    "kretprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory. This is called by set_bit() if it cannot find a faster solution.",
        "proto" :"void (*__mips_set_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_set_bit": {
        "description": "Atomically set a bit in memory. This is called by set_bit() if it cannot find a faster solution.",
        "proto" :"static void (*__mips_set_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory. This is called by clear_bit() if it cannot find a faster solution.",
        "proto" :"void (*__mips_clear_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_clear_bit": {
        "description": "Clears a bit in memory. This is called by clear_bit() if it cannot find a faster solution.",
        "proto" :"void (*__mips_clear_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "proto" :"void (*__mips_change_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_change_bit": {
        "description": "Toggle a bit in memory. This is called by change_bit() if it cannot find a faster solution.",
        "proto" :"void (*__mips_change_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": "in [0, sizeof(unsigned long)*8 - 1]",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value. This is called by test_and_set_bit_lock() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_set_bit_lock)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_set_bit_lock": {
        "description": "Set a bit and return its old value. This is called by test_and_set_bit_lock() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_set_bit_lock)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": "is a valid bit index",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value. This is called by test_and_clear_bit() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_clear_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_clear_bit": {
        "description": "Clear a bit and return its old value. This is called by test_and_clear_bit() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_clear_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value. This is called by test_and_change_bit() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_change_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__mips_test_and_change_bit": {
        "description": "Change a bit and return its old value. This is called by test_and_change_bit() if it cannot find a faster solution.",
        "proto" :"int (*__mips_test_and_change_bit)(unsigned long nr, volatile unsigned long *addr)",
        "pre": {
            "nr": ">=0",
            "addr": "!=null"
        }
    }
},




{
    "kretprobe:local_flush_tlb_all": {
        "description": "Save old context and create impossible VPN2 value",
        "proto" :"static long (*local_flush_tlb_all)(unsigned long flags, unsigned long old_ctx, int entry, int ftlbhighset)",
        "pre": {
            "flags": "!=null",
            "old_ctx": "!=null",
            "entry": "!=null",
            "ftlbhighset": "!=null",
        },
    }
},
{
    "kprobe:local_flush_tlb_all": {
        "description": "Save old context and create impossible VPN2 value",
        "proto" :"void local_flush_tlb_all(void)",
        "pre": {
            "flags": "!=null",
            "old_ctx": "!=null",
            "entry": "!=null",
            "ftlbhighset": "!=null"
        },
    }
},
{
    "kretprobe:has_transparent_hugepage": {
        "description": "Checks if the system has transparent hugepage support. The first call comes during __init.",
        "proto" :"static unsigned int (*has_transparent_hugepage)(void)",
        "pre": {},
        "post": {
            "return": "== PM_HUGE_MASK"
        }
    }
},
{
    "kprobe:has_transparent_hugepage": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "constraint1",
            "param2": "constraint2",
            "param3": "constraint3",
            ...
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[constraints]",
            "[param2]": "[constraints]",
            "[param3]": "[constraints]",
            "[param4]": "[constraints]",
        },
    }
},

{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "constraints for arg1",
            "arg2": "constraints for arg2",
            "arg3": "constraints for arg3",
            "arg4": "constraints for arg4",
        },
    }
},
{
    "kretprobe:__flush_dcache_page": {
        "description": "This function is used to flush the data cache page. It checks if the page is in high memory, maps it if it is, and flushes the data cache page. If the page is still in high memory after the flush, it unmaps it.",
        "proto" :"void __flush_dcache_page(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:__flush_dcache_page": {
        "description": "Flushes the data cache page. If the page is in high memory, it is temporarily mapped into the kernel's address space. If the page is not mapped, it is marked as dirty.",
        "proto" :"void __flush_dcache_page(struct page *page)",
        "pre": {
            "page": "!=null"
        },
    }
},
{
    "kretprobe:__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long)_text && x <= (unsigned long)_end"
        },
    }
},
{
    "__phys_addr_symbol": {
        "description": "This is bounds checking against the kernel image only. __pa_symbol should only be used on kernel symbol addresses.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= (unsigned long)_text && x <= (unsigned long)_end"
        },
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space. ioremap_prot gives the caller control over cache coherency attributes (CCA).",
        "proto" :"void __iomem *(*ioremap_prot)(phys_addr_t phys_addr, unsigned long size, unsigned long prot_val)",
        "pre": {
            "phys_addr": "!=null",
            "size": ">0",
            "prot_val": "in [IOMEM_PROT_READ, IOMEM_PROT_WRITE, IOMEM_PROT_NONE]"
        },
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Map bus memory into CPU space. ioremap_prot gives the caller control over cache coherency attributes (CCA).",
        "proto" :"void __iomem *(*ioremap_prot)(phys_addr_t phys_addr, unsigned long size, unsigned long prot_val)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
            "prot_val": ">=0"
        }
    }
},
{
    "kretprobe:bcm47xx_board_get_nvram": {
        "description": "Description of the function",
        "proto" :"static long (*bcm47xx_board_get_nvram)(void)",
        "pre": {
            "buf1": "!=null",
            "buf2": "!=null",
            "buf3": "!=null",
            "e1": "!=null",
            "e2": "!=null",
            "e3": "!=null"
        },
    }
},
{
    "kprobe:bcm47xx_board_get_nvram": {
        "description": "Your description here",
        "proto" :"Your prototype here",
        "pre": {
            "buf1": "Your condition here",
            "buf2": "Your condition here",
            "buf3": "Your condition here",
            "e1": "Your condition here",
            "e2": "Your condition here",
            "e3": "Your condition here"
        },
    }
},


{
    "kretprobe:octeon_is_simulation": {
        "description": "Return non-zero if we are currently running in the Octeon simulator. Return: non-0 if running in the Octeon simulator, 0 otherwise",
        "proto" :"int (*octeon_is_simulation)(void)",
        "post": {
            "return": "in [0, non-0]"
        }
    }
},
{
    "kprobe:octeon_is_simulation": {
        "description": "Return non-zero if we are currently running in the Octeon simulator. Return: non-0 if running in the Octeon simulator, 0 otherwise.",
        "proto" :"int (*octeon_is_simulation)(void)",
        "pre": {}
    }
},
{
    "kretprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon. Return: Clock rate in HZ",
        "proto" :"uint64_t (*octeon_get_clock_rate)(void)",
        "pre": {},
        "post": {
            "return": "> 0"
        }
    }
},
{
    "kprobe:octeon_get_clock_rate": {
        "description": "Get the clock rate of Octeon. Returns the clock rate in HZ.",
        "proto" :"static uint64_t (*octeon_get_clock_rate)(void)",
        "pre": {},
    }
},
{
    "kretprobe:key_alloc_serial": {
        "description": "Propose a random serial number and look for a hole for it in the serial number tree.",
        "proto" :"key_alloc_serial(struct key key, struct rb_node parent, struct rb_node p, struct key xkey)",
        "pre": {
            "key": "!=null",
            "parent": "!=null",
            "p": "!=null",
            "xkey": "!=null"
        },
    }
},


{
    "kprobe:octeon_ndelay_factor": {
        "description": "__ndelay we divide by 2^16, so the factor is multiplied by the same amount.",
        "proto" :"octeon_ndelay_factor = (octeon_udelay_factor * 0x10000ull) / 1000ull;preset_lpj = octeon_get_clock_rate() / HZ;if (current_cpu_type() == CPU_CAVIUM_OCTEON2)",
        "pre": {
            "octeon_udelay_factor": "!=null",
            "octeon_get_clock_rate": "!=null",
            "HZ": "!=null",
            "CPU_CAVIUM_OCTEON2": "!=null"
        },
    }
},
{
    "kretprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass. We scale the wait by the clock ratio, and then wait for the corresponding number of core clocks.",
        "proto" :"void (*octeon_io_clk_delay)(unsigned long count)",
        "pre": {
            "count": ">=0"
        }
    }
},
{
    "kprobe:octeon_io_clk_delay": {
        "description": "Wait for a given number of io clock cycles to pass. We scale the wait by the clock ratio, and then wait for the corresponding number of core clocks.",
        "proto" :"void (*octeon_io_clk_delay)(unsigned long count)",
        "pre": {
            "count": ">=0"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[constraints]",
            "[param2]": "[constraints]",
            "[param3]": "[constraints]",
            "[param4]": "[constraints]",
        },
    }
},

{
    "kretprobe:_wrmsr": {
        "description": "_wrmsr() to access the registers PCI_MSR_ADDR, PCI_MSR_DATA_LO, PCI_MSR_DATA_HI, which is bigger than PCI_MSR_CTRL, so, it will not go this branch, but the others. so, no calling dead loop here.",
        "proto" :"if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))",
        "pre": {
            "device": "== PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        },
    }
},
{
    "kprobe:_wrmsr": {
        "description": "_wrmsr() to access the registers PCI_MSR_ADDR, PCI_MSR_DATA_LO, PCI_MSR_DATA_HI, which is bigger than PCI_MSR_CTRL, so, it will not go this branch, but the others. so, no calling dead loop here.",
        "proto" :"if ((PCI_IDSEL_CS5536 == device) && (reg < PCI_MSR_CTRL))",
        "pre": {
            "device": "== PCI_IDSEL_CS5536",
            "reg": "< PCI_MSR_CTRL"
        }
    }
},
{
    "kretprobe:yeeloong_report_lid_status": {
        "description": "Implemented in yeeloong_laptop.c",
        "proto" :"void (*yeeloong_report_lid_status)(int status)",
        "pre": {
            "status": ">=0",
        },
    }
},

{
    "kretprobe:outb": {
        "description": "Writes a byte to a port.",
        "proto" :"void outb(unsigned char value, unsigned short int port)",
        "pre": {
            "value": "is a byte",
            "port": "is a valid port number"
        }
    }
},
{
    "kprobe:outb": {
        "description": "Sends the specified data to the specified I/O port.",
        "proto" :"void outb(unsigned short port, unsigned char value)",
        "pre": {
            "port": "in [0x0B, PIC_MASTER_ISR]",
            "value": "any"
        },
    }
},

{
    "EXPORT_SYMBOL:loongson_uart_base": {
        "description": "ioremapped",
        "proto" :"unsigned long _loongson_uart_base",
        "pre": {
            "_loongson_uart_base": "is ioremapped"
        },
    }
},


{
    "kretprobe:vpe_alloc": {
        "description": "Find a vpe",
        "proto" :"static long (*vpe_alloc)(void *vpe, int max_vpes)",
        "pre": {
            "vpe": "!=null",
            "max_vpes": ">0",
        },
    }
},


{
    "kprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[arg1]": "[Constraint1]",
            "[arg2]": "[Constraint2]",
            "[arg3]": "[Constraint3]",
            "[arg4]": "[Constraint4]",
        },
    }
},


{
    "kretprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical to logical",
        "proto" :"static long (*EXPORT_SYMBOL(__cpu_number_map))(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_number_map)": {
        "description": "Map physical to logical",
        "proto" :"static long (*EXPORT_SYMBOL(__cpu_number_map))(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical to physical",
        "proto" :"static long (*EXPORT_SYMBOL(__cpu_logical_map))(int index)",
        "pre": {
            "index": "in [0, NR_CPUS-1]"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(__cpu_logical_map)": {
        "description": "Map logical to physical",
        "proto" :"static long (*EXPORT_SYMBOL(__cpu_logical_map))(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:flush_tlb_page": {
        "description": "Flushes the Translation Lookaside Buffer (TLB) for a specific page in a specific virtual memory area (vma).",
        "proto" :"void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)",
        "pre": {
            "vma": "!=null",
            "page": ">=0"
        }
    },
    "kretprobe:flush_tlb_page_ipi": {
        "description": "Flushes the TLB for a specific page in a specific vma on all other CPUs.",
        "proto" :"void flush_tlb_page_ipi(void *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:flush_tlb_page": {
        "description": "Your function description here",
        "proto" :"static long (*flush_tlb_page)(struct vm_area_struct *vma, unsigned long page)",
        "pre": {
            "vma": "!=null",
            "page": "!=null"
        },
    }
},
{
    "kretprobe:mips_elf_read_implies_exec": {
        "description": "Set READ_IMPLIES_EXEC only on non-NX systems that do not request a specific state via PT_GNU_STACK.",
        "proto" :"static long (*mips_elf_read_implies_exec)(void *elf_ex, int exstack)",
        "pre": {
            "elf_ex": "!=null",
            "exstack": "in [EXSTACK_DEFAULT, EXSTACK_OTHER_VALUES]"
        },
    }
},
{
    "kprobe:mips_elf_read_implies_exec": {
        "description": "Set READ_IMPLIES_EXEC only on non-NX systems that do not request a specific state via PT_GNU_STACK.",
        "proto" :"static long (*mips_elf_read_implies_exec)(void *elf_ex, int exstack)",
        "pre": {
            "elf_ex": "!=null",
            "exstack": "in [EXSTACK_DEFAULT, ...]",
        },
    }
},
{
    "kretprobe:request_au1000_dma": {
        "description": "Request a DMA channel for a device.",
        "proto": "int request_au1000_dma(int dev_id, const char dev_str, irq_handler_t irqhandler, unsigned long irqflags, void irq_dev_id)",
        "pre": {
            "dev_id": "in [0, DMA_NUM_DEV + DMA_NUM_DEV_BANK2) if ALCHEMY_CPU_AU1100, else in [0, DMA_NUM_DEV)",
            "dev_str": "!=null",
            "irqhandler": "can be null",
            "irqflags": "unsigned long",
            "irq_dev_id": "can be null"
        },
        "post": {
            "chan->io": "!=null",
            "chan->dev_id": "=dev_id",
            "chan->dev_str": "=dev_str",
            "chan->fifo_addr": "=dev->fifo_addr",
            "chan->mode": "=dev->dma_mode"
        }
    }
},
{
    "kprobe:request_au1000_dma": {
        "description": "Initialize a DMA channel.",
        "proto" :"int request_au1000_dma(int dev_id, const char dev_str, irq_handler_t irqhandler, unsigned long irqflags, void irq_dev_id)",
        "pre": {
            "dev_id": ">= 0 && < DMA_NUM_DEV",
            "dev_str": "!=null",
            "irqhandler": "can be null",
            "irqflags": "unsigned long",
            "irq_dev_id": "!=null",
        },
    }
},
{
    "kretprobe:au1xxx_dbdma_chan_alloc": {
        "description": "We do the initialization on the first channel allocation. We have to wait because of the interrupt handler initialization which can't be done successfully during board set up.",
        "proto" :"au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid, void (*callback)(int, void *), void *callparam)",
        "pre": {
            "srcid": "!=null",
            "destid": "!=null",
            "callback": "!=null",
            "callparam": "!=null"
        },
    }
},
{
    "kprobe:au1xxx_dbdma_chan_alloc": {
        "description": "We do the initialization on the first channel allocation. We have to wait because of the interrupt handler initialization which can't be done successfully during board set up.",
        "proto" :"au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid, void ( callback)(int, void  ), void  callparam)",
        "pre": {
            "srcid": "!=null",
            "destid": "!=null",
            "callback": "!=null",
            "callparam": "!=null"
        },
    }
},
{
    "kretprobe:au1xxx_dbdma_set_devwidth": {
        "description": "Set the device width for the source and destination devices associated with the channel identified by *chanid* to *bits*.",
        "proto" :"static long (*au1xxx_dbdma_set_devwidth)(u32 chanid, int bits)",
        "pre": {
            "chanid": ">=0",
            "bits": ">=0"
        },
    }
},
{
    "kprobe:au1xxx_dbdma_set_devwidth": {
        "description": "Set the device width for the specified channel.",
        "proto" :"static long (*au1xxx_dbdma_set_devwidth)(u32 chanid, int bits)",
        "pre": {
            "chanid": "!=null",
            "bits": ">=0",
        },
    }
},
{
    "kretprobe:au1xxx_dbdma_ring_alloc": {
        "description": "Allocates a ring buffer for the specified channel and number of entries.",
        "proto" :"static long (*au1xxx_dbdma_ring_alloc)(u32 chanid, int entries)",
        "pre": {
            "chanid": "in range of the table",
            "entries": ">= 0",
        },
    }
},
{
    "kprobe:au1xxx_dbdma_ring_alloc": {
        "description": "Your function description here",
        "proto" :"static long (*au1xxx_dbdma_ring_alloc)(u32 chanid, int entries)",
        "pre": {
            "chanid": "Your condition here",
            "entries": "Your condition here"
        },
    }
},
{
    "kretprobe:au1xxx_dbdma_put_source": {
        "description": "I guess we could check this to be within the range of the table......",
        "proto" :"au1xxx_dbdma_put_source(u32 chanid, dma_addr_t buf, int nbytes, u32 flags)",
        "pre": {
            "chanid": "!=null",
            "buf": "!=null",
            "nbytes": ">=0",
            "flags": "in [FLAG1, FLAG2, FLAG3]",
        },
    }
},

{
    "kretprobe:au1xxx_dbdma_put_dest": {
        "description": "This function puts a destination buffer into the DMA channel's descriptor ring.",
        "proto": "au1xxx_dbdma_put_dest(u32 chanid, dma_addr_t buf, int nbytes, u32 flags)",
        "pre": {
            "chanid": "!=null",
            "buf": "!=null",
            "nbytes": ">0",
            "flags": "in [FLAG1, FLAG2, FLAG3]" // replace with actual flag values
        }
    }
},

{
    "kretprobe:au1xxx_dbdma_start": {
        "description": "Starts the DBDMA channel with the given channel ID.",
        "proto" :"static long (*au1xxx_dbdma_start)(u32 chanid)",
        "pre": {
            "chanid": "!=null"
        },
    }
},

{
    "kretprobe:au1xxx_dbdma_reset": {
        "description": "Description of the function goes here.",
        "proto" :"static long (*au1xxx_dbdma_reset)(u32 chanid)",
        "pre": {
            "chanid": "Your condition goes here",
        },
    }
},
{
    "kprobe:au1xxx_dbdma_reset": {
        "description": "Run through the descriptors and reset the valid indicator.",
        "proto" :"au1xxx_dbdma_reset(u32 chanid)",
        "pre": {
            "chanid": "!=null",
        },
    }
},
{
    "kretprobe:bcm63xx_set_cs_base": {
        "description": "Set the base and size for a given chip select (cs).",
        "proto" :"static long (*bcm63xx_set_cs_base)(unsigned int cs, u32 base, unsigned int size)",
        "pre": {
            "cs": "is_valid_cs(cs)",
            "base": "is a valid u32 value",
            "size": ">= 8 * 1024 && <= 256 * 1024 * 1024 && == roundup_pow_of_two(size)"
        },
        "post": {
            "return": "in [-EINVAL, base & MPI_CSBASE_BASE_MASK]"
        }
    }
},
{
    "kprobe:bcm63xx_set_cs_base": {
        "description": "Set the base and size for a given chip select (cs).",
        "proto" :"static long (*bcm63xx_set_cs_base)(unsigned int cs, u32 base, unsigned int size)",
        "pre": {
            "cs": "is_valid_cs(cs)",
            "base": "is a valid u32 value",
            "size": ">= 8 * 1024 && <= 256 * 1024 * 1024 && == roundup_pow_of_two(size)"
        },
    }
},

{
    "kprobe:bcm63xx_set_cs_param": {
        "description": "This function sets the parameters for the cs. It checks if the cs is valid, if not it returns -EINVAL. If the cs is valid, it locks the bcm63xx_cs_lock, reads the MPI_CSCTL_REG(cs) into val, clears several masks from val, sets val to the parameters, writes val back to MPI_CSCTL_REG(cs), unlocks the bcm63xx_cs_lock, and returns 0. None of these fields apply to pcmcia.",
        "proto" :"static long (*bcm63xx_set_cs_param)(unsigned int cs, u32 params)",
        "pre": {
            "cs": "is_valid_cs(cs)",
            "params": "any value",
            "flags": "any value",
            "val": "any value"
        },
    }
},
{
    "kretprobe:enet_misc_set": {
        "description": "Ethernet MAC 'misc' clock: dma clocks and main clock on 6348",
        "proto" :"static void enet_misc_set(struct clk *clk, int enable)",
        "pre": {
            "clk": "!=null",
            "enable": "in [0, 1]"
        }
    }
},
{
    "kprobe:enet_misc_set": {
        "description": "Sets the Ethernet MAC 'misc' clock: dma clocks and main clock on 6348.",
        "proto" :"static void (*enet_misc_set)(struct clk *clk, int enable)",
        "pre": {
            "clk": "!=null",
            "enable": "in [0, 1]"
        }
    }
},
{
    "kretprobe:vdma_alloc": {
        "description": "one could leave page #0 unused and return the more usual NULL pointer as logical address.",
        "proto" :"static void* (*vdma_alloc)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},


{
    "kprobe:vdma_enable": {
        "description": "Check error conditions first",
        "proto" :"static void (*vdma_enable)(int channel)",
        "pre": {
            "channel": ">=0"
        },
        "post": {
            "status": "in [0x400, 0x200]"
        }
    }
},
{
    "kretprobe:vdma_disable": {
        "description": "Disables a DMA channel and ensures that the current DMA acknowledge cycle is completed.",
        "proto" :"void vdma_disable(int channel)",
        "pre": {
            "channel": ">=0"
        },
        "post": {
            "return": "void"
        }
    }
},
{
    "kprobe:vdma_disable": {
        "description": "Disables a DMA channel and reads a remote bus register to ensure that the current DMA acknowledge cycle is completed.",
        "proto" :"vdma_disable(int channel)",
        "pre": {
            "channel": ">=0",
        },
    }
},
{
    "kretprobe:r4030_write_reg32": {
        "description": "This function writes to a specific register in the R4030 chipset.",
        "proto" :"static long (*r4030_write_reg32)(int JAZZ_R4030_CHNL_MODE, int channel)",
        "pre": {
            "JAZZ_R4030_CHNL_MODE": "in [valid range of modes]",
            "channel": "in [valid range of channels]",
        },
    }
},
{
    "kprobe:r4030_write_reg32": {
        "description": "Write a 32-bit value to a specific register.",
        "proto" :"static void (*r4030_write_reg32)(int address, int value)",
        "pre": {
            "address": ">=0",
            "value": "is int",
        },
    }
},


{
    "kretprobe:ip22_nvram_read": {
        "description": "IP22 (Indigo2 aka FullHouse) stores env variables into 93CS56 Microwire Bus EEPROM 2048 Bit (128x16).",
        "proto" :"static long (*ip22_nvram_read)(int reg)",
        "pre": {
            "reg": ">=0"
        }
    }
},
{
    "kprobe:ip22_nvram_read": {
        "description": "IP22 (Indigo2 aka FullHouse) stores env variables into 93CS56 Microwire Bus EEPROM 2048 Bit (128x16).",
        "proto" :"static long (*ip22_nvram_read)(int reg)",
        "pre": {
            "reg": "is an integer"
        }
    }
},
{
    "kretprobe:copy_user_highpage": {
        "description": "Copy the content of one page to another. If the source page has multiple aliases and is clean, use a coherent mapping to copy. If the destination page aliases with the virtual address or the virtual memory area is executable, flush and purge the region. Make sure this page is cleared on other CPU's too before using it.",
        "proto": "void copy_user_highpage(struct page *to, struct page *from, unsigned long vaddr, struct vm_area_struct *vma)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "is valid virtual address",
            "vma": "!=null"
        }
    }
},
{
    "kprobe:copy_user_highpage": {
        "description": "Copies a high memory page from one location to another, handling potential aliasing issues and ensuring the page is cleared on other CPUs before use.",
        "proto" :"static void (*copy_user_highpage)(struct page *to, struct page *from, unsigned long vaddr, struct vm_area_struct *vma)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "is valid virtual address",
            "vma": "!=null",
        },
    }
},


{
    "__ioremap_caller": {
        "description": "Maps the physical address to virtual address space. Returns NULL if size is zero or if there is a wraparound.",
        "proto": "void __iomem *(__ioremap_caller)(phys_addr_t phys_addr, unsigned long size, pgprot_t pgprot, void *caller)",
        "pre": {
            "phys_addr": "!=null",
            "size": ">0",
            "pgprot": "!=null",
            "caller": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:__ioremap_29bit": {
        "description": "iounmap() do not need to do anything but place the address in the proper segment. This is true for P1 and P2 addresses, as well as some P3 ones. However, most of the P3 addresses and newer cores using extended addressing need to map through page tables, so the ioremap() implementation becomes a bit more complicated.",
        "proto" :"#ifdef CONFIG_29BITstatic void __iomem *__ioremap_29bit(phys_addr_t offset, unsigned long size, pgprot_t prot)",
        "pre": {
            "offset": "[Your condition here]",
            "size": "[Your condition here]",
            "prot": "[Your condition here]"
        }
    }
},
{
    "kprobe:__ioremap_29bit": {
        "description": "iounmap() do not need to do anything but place the address in the proper segment. This is true for P1 and P2 addresses, as well as some P3 ones. However, most of the P3 addresses and newer cores using extended addressing need to map through page tables, so the ioremap() implementation becomes a bit more complicated.",
        "proto" :"#ifdef CONFIG_29BITstatic void __iomem *__ioremap_29bit(phys_addr_t offset, unsigned long size, pgprot_t prot)",
        "pre": {
            "offset": ">=0",
            "size": ">0",
            "prot": "!=null",
        },
    }
},
{
    "kretprobe:list_for_each_entry": {
        "description": "Look for each DMAC's range to determine who the owner of the channel is.",
        "proto" :"void list_for_each_entry(struct dma_info *info, struct list_head *head, struct list_head *member)",
        "pre": {
            "info": "!=null",
            "head": "!=null",
            "member": "!=null"
        }
    }
},
{
    "kprobe:get_dma_info": {
        "description": "Look for each DMAC's range to determine who the owner of the channel is.",
        "proto" :"unsigned int (*get_dma_info)(unsigned int chan)",
        "pre": {
            "chan": "your_condition_here",
        },
        "list_for_each_entry": {
            "description": "Iterates over list of given type, safe against removal of list entry.",
            "proto" :"void (*list_for_each_entry)(struct dma_info *info, struct list_head *list, member)",
            "pre": {
                "info": "your_condition_here",
                "list": "your_condition_here",
                "member": "your_condition_here",
            }
        }
    }
},
{
    "kretprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities. Search all channels of all DMA controllers to find a channel which matches the requested capabilities. The result is the channel number if a match is found, or %-ENODEV if no match is found. Note that not all DMA controllers export capabilities, in which case they can never be allocated using this API, and so request_dma() must be used specifying the channel number.",
        "proto" :"int (*request_dma_bycap)(const char **dmac, const char **caps, const char *dev_id)",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        },
        "post": {
            "return": "in [channel number, -ENODEV]"
        }
    }
},
{
    "kprobe:request_dma_bycap": {
        "description": "Allocate a DMA channel based on its capabilities. Search all channels of all DMA controllers to find a channel which matches the requested capabilities. The result is the channel number if a match is found, or %-ENODEV if no match is found. Note that not all DMA controllers export capabilities, in which case they can never be allocated using this API, and so request_dma() must be used specifying the channel number.",
        "proto" :"int (*request_dma_bycap)(const char **dmac, const char **caps, const char *dev_id)",
        "pre": {
            "dmac": "!=null",
            "caps": "!=null",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:register_dmac": {
        "description": "Registers a DMA handler with a specific number of channels. If the channels are pre-configured, they should not be touched.",
        "proto": "void register_dmac(struct dma_info *info)",
        "pre": {
            "info": "!=null",
            "info->flags": "in [DMAC_CHANNELS_CONFIGURED, ~DMAC_CHANNELS_CONFIGURED]",
            "info->channels": "!=null when info->flags & DMAC_CHANNELS_CONFIGURED"
        },
        "post": {
            "return": "is a valid pointer or an error code"
        }
    }
},
{
    "kprobe:register_dmac": {
        "description": "Register a DMA handler with a specific number of channels. Don't touch pre-configured channels.",
        "proto" :"static long (*register_dmac)(struct dma_info *info)",
        "pre": {
            "info": "!=null",
            "info->flags": "in [DMAC_CHANNELS_CONFIGURED, ...]",
            "info->channels": "!=null when info->flags & DMAC_CHANNELS_CONFIGURED != 0",
            "info->name": "!=null",
            "info->nr_channels": ">=0",
            "info->pdev": "can be null"
        },
    }
},
{
    "kretprobe:pcibios_scanbus": {
        "description": "The PCI controller list.",
        "proto" :"static void pcibios_scanbus(struct pci_channel *hose)",
        "pre": {
            "hose": "!=null"
        },
    }
},
{
    "kprobe:pcibios_scanbus": {
        "description": "The PCI controller list.",
        "proto" :"static void pcibios_scanbus(struct pci_channel *hose)",
        "pre": {
            "hose": "!=null",
        },
    }
},




{
    "kretprobe:arch_local_save_flags": {
        "description": "This function saves the local flags.",
        "proto" :"static long (*arch_local_save_flags)(void)",
        "pre": {},
        "post": {
            "return": "in [0, ULONG_MAX]"
        }
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "input1": "Your input1 condition here",
            "input2": "Your input2 condition here",
            "input3": "Your input3 condition here",
            "flags": "Your flags condition here",
        },
    }
},
{
    "kretprobe:memcpy_fromio": {
        "description": "Would it be worthwhile doing byte and long transfers first to try and get aligned?",
        "proto" :"void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Copies 'count' bytes from 'from' to 'to'. It tries to do byte and long transfers first to get aligned.",
        "proto" :"void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:sq_flush_range": {
        "description": "Flushes the store queue cache from @start to @start + @len in a linear fashion.",
        "proto" :"static void (*sq_flush_range)(unsigned long start, unsigned int len)",
        "pre": {
            "start": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:sq_flush_range": {
        "description": "Flushes the store queue cache from @start to @start + @len in a linear fashion.",
        "proto" :"void (*sq_flush_range)(unsigned long start, unsigned int len)",
        "pre": {
            "start": ">=0",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:sq_remap": {
        "description": "Remaps the physical address @phys through the next available store queue address of @size length. @name is logged at boot time as well as through the sysfs interface.",
        "proto" :"sq_remap(struct sq_mapping  map, pgprot_t prot)",
        "pre": {
            "map": "!=null",
            "map->size": ">0",
            "map->sq_addr": ">=SQ_ADDRMAX",
            "map->addr": "!=null",
            "prot": "!=null"
        },
        "post": {
            "return": "in [-ENOMEM, -EAGAIN, 0]"
        }
    }
},
{
    "kprobe:sq_remap": {
        "description": "Remaps the physical address @phys through the next available store queue address of @size length. @name is logged at boot time as well as through the sysfs interface.",
        "proto" :"sq_remap(struct sq_mapping  map, pgprot_t prot)",
        "pre": {
            "map": "!=null",
            "map->size": ">0",
            "map->sq_addr": ">=SQ_ADDRMAX",
            "map->addr": "!=null",
            "prot": "!=null"
        },
    }
},
{
    "kretprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation. Unmaps the store queue allocation @map that was previously created by sq_remap(). Also frees up the pte that was previously inserted into the kernel page table and discards the UTLB translation.",
        "proto" :"void (*sq_unmap)(unsigned long vaddr)",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kprobe:sq_unmap": {
        "description": "Unmap a Store Queue allocation. Unmaps the store queue allocation @map that was previously created by sq_remap(). Also frees up the pte that was previously inserted into the kernel page table and discards the UTLB translation.",
        "proto" :"void (*sq_unmap)(unsigned long vaddr)",
        "pre": {
            "vaddr": "!=null"
        }
    }
},
{
    "kretprobe:kasan_map_memory": {
        "description": "Map all of the required address space and the host machine will allocate physical memory as necessary.",
        "proto" :"void (*kasan_map_memory)(void *KASAN_SHADOW_START, size_t KASAN_SHADOW_SIZE)",
        "pre": {
            "KASAN_SHADOW_START": "!=null",
            "KASAN_SHADOW_SIZE": ">0",
        },
    }
},
{
    "kprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[argument1]": "[constraint1]",
            "[argument2]": "[constraint2]",
            "[argument3]": "[constraint3]",
            "[argument4]": "[constraint4]",
        },
    }
},
{
    "kretprobe:free_irq_by_fd": {
        "description": "Free the IRQ associated with the given file descriptor. Use um_free_irq() or deactivate_fd() instead.",
        "proto" :"void (*free_irq_by_fd)(int fd)",
        "pre": {
            "fd": ">=0"
        }
    }
},
{
    "kprobe:free_irq_by_fd": {
        "description": "Free the IRQ associated with the file descriptor *fd*.",
        "proto" :"static void (*free_irq_by_fd)(int fd)",
        "pre": {
            "fd": ">=0",
        },
    }
},
{
    "kretprobe:setup_physmem": {
        "description": "Setup physical memory for UML. Creates an unlinked temporary file of size (len + highmem) and memory maps it on the last executable image address (uml_reserved). The memory mapped memory of the temporary file is used as backing memory of all user space processeskernel tasks.",
        "proto" :"void __init (*setup_physmem)(unsigned long start, unsigned long reserve_end, unsigned long len, unsigned long long highmem)",
        "pre": {
            "start": ">=0",
            "reserve_end": ">start",
            "len": ">0",
            "highmem": ">=0"
        }
    }
},
{
    "kprobe:setup_physmem": {
        "description": "Setup physical memory for UML. Creates an unlinked temporary file of size (len + highmem) and memory maps it on the last executable image address (uml_reserved). The offset is needed as the length of the total physical memory (len + highmem) includes the size of the memory used be the executable image, but the mapped-to address is the last address of the executable image (uml_reserved == end address of executable image). The memory mapped memory of the temporary file is used as backing memory of all user space processeskernel tasks.",
        "proto" :"void __init setup_physmem(unsigned long start, unsigned long reserve_end, unsigned long len, unsigned long long highmem)",
        "pre": {
            "start": "",
            "reserve_end": "",
            "len": "",
            "highmem": ""
        }
    }
},
{
    "kretprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "proto" :"int (*arch_futex_atomic_op_inuser)(int op, u32 oparg, int *oval, u32 __user *uaddr)",
        "pre": {
            "op": "is an integer",
            "oparg": "is a u32",
            "oval": "!=null",
            "uaddr": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN, -ENOSYS]"
        }
    }
},
{
    "kprobe:arch_futex_atomic_op_inuser": {
        "description": "Atomic arithmetic operation with constant argument and comparison of the previous futex value with another constant.",
        "proto" :"int (*arch_futex_atomic_op_inuser)(int op, u32 oparg, int *oval, u32 __user *uaddr)",
        "pre": {
            "op": "is an integer",
            "oparg": "is a u32",
            "oval": "!=null",
            "uaddr": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN, -ENOSYS]"
        }
    }
},
{
    "kretprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval. @uval:pointer to store content of @uaddr @uaddr:pointer to user space address @oldval:old value @newval:new value to store to @uaddr Return: 0 - On success -EFAULT - User access resulted in a page fault -EAGAIN - Atomic operation was unable to complete due to contention",
        "proto" :"int futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newval)",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "is a valid u32 value",
            "newval": "is a valid u32 value"
        },
        "post": {
            "return": "in [0, -EFAULT, -EAGAIN]"
        }
    }
},
{
    "kprobe:futex_atomic_cmpxchg_inatomic": {
        "description": "Compare and exchange the content of the uaddr with newval if the current value is oldval. @uval:pointer to store content of @uaddr @uaddr:pointer to user space address @oldval:old value @newval:new value to store to @uaddr Return: 0 - On success -EFAULT - User access resulted in a page fault -EAGAIN - Atomic operation was unable to complete due to contention",
        "proto" :"int futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newval)",
        "pre": {
            "uval": "!=null",
            "uaddr": "!=null",
            "oldval": "is u32",
            "newval": "is u32"
        },
    }
},
{
    "kretprobe:__raw_readsw": {
        "description": "Read words a short at a time from source address to data address for a number of shorts to read.",
        "proto" :"void (*__raw_readsw)(const void __iomem *addr, void *data, int len)",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__raw_readsw": {
        "description": "Read words a short at a time from source address to data address for a number of shorts to read.",
        "proto" :"void (*__raw_readsw)(const void __iomem *addr, void *data, int len)",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:__raw_writesw": {
        "description": "Read words a short at a time from a source address to a data address for a certain number of shorts.",
        "proto" :"void (*__raw_writesw)(void __iomem *addr, const void *data, int len)",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kprobe:__raw_writesw": {
        "description": "Read words a short at a time",
        "proto" :"void (*__raw_writesw)(void __iomem *addr, const void *data, int len)",
        "pre": {
            "addr": "!=null",
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:csum_tcpudp_nofold": {
        "description": "Your description of the function here",
        "proto" :"csum_tcpudp_nofold(__be32 saddr, __be32 daddr,  __u32 len, __u8 proto, __wsum sum)",
        "pre": {
            "saddr": "Your condition here",
            "daddr": "Your condition here",
            "len": "Your condition here",
            "proto": "Your condition here",
            "sum": "Your condition here"
        },
    }
},
{
    "kprobe:csum_tcpudp_nofold": {
        "description": "Computes the checksum for TCP/UDP over IPv4. This helper is only safe to call in the context of the kprobe.",
        "proto" :"static __wsum (*csum_tcpudp_nofold)(__be32 saddr, __be32 daddr,  __u32 len, __u8 proto, __wsum sum)",
        "pre": {
            "saddr": "!=null",
            "daddr": "!=null",
            "len": ">=0",
            "proto": "in [IPPROTO_TCP, IPPROTO_UDP]",
            "sum": ">=0",
        },
    }
},
{
    "kretprobe:iowrite32_rep": {
        "description": "Writes a block of 32-bit integers to the specified port. If the source address is not 32-bit aligned, it writes the integers one by one.",
        "proto" :"void iowrite32_rep(void __iomem *port, const void *src, unsigned long count)",
        "pre": {
            "port": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
    }
},

{
    "kretprobe:pci_iounmap": {
        "description": "Unmaps the I/O memory space previously mapped by pci_iomap.",
        "proto" :"void pci_iounmap(struct pci_dev *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:EXPORT_SYMBOL(pci_iounmap)": {
        "description": "Unmap the I/O memory region associated with *addr* from the PCI device *dev*. This function does nothing.",
        "proto" :"void pci_iounmap(struct pci_dev *dev, void __iomem *addr)",
        "pre": {
            "dev": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:__prom_getchild": {
        "description": "prom_getchild that does not alter return values.",
        "proto" :"static phandle (*__prom_getchild)(phandle node)",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:__prom_getchild": {
        "description": "prom_getchild that does not alter return values.",
        "proto" :"static phandle (*__prom_getchild)(phandle node)",
        "pre": {
            "node": "!=null",
        },
    }
},
{
    "kretprobe:__prom_getsibling": {
        "description": "prom_getsibling that does not alter return values.",
        "proto" :"static phandle __prom_getsibling(phandle node)",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kprobe:__prom_getsibling": {
        "description": "prom_getsibling that does not alter return values.",
        "proto" :"static phandle (*__prom_getsibling)(phandle node)",
        "pre": {
            "node": "!=null"
        }
    }
},
{
    "kretprobe:prom_getproperty": {
        "description": "Get the property of a node.",
        "proto" :"int prom_getproperty(phandle node, const char prop, char buffer, int bufsize)",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": "> 0",
        },
        "post": {
            "return": "in [-1, bufsize]"
        }
    }
},
{
    "kprobe:prom_getproperty": {
        "description": "Get the property of a node. If the length of the property is greater than bufsize, or if the length is 0 or -1, return -1. Otherwise, get the property.",
        "proto" :"int prom_getproperty(phandle node, const char prop, char buffer, int bufsize)",
        "pre": {
            "node": "!=null",
            "prop": "!=null",
            "buffer": "!=null",
            "bufsize": "> 0",
        },
    }
},
{
    "kretprobe:prom_searchsiblings": {
        "description": "Description of the function",
        "proto" :"static long (*prom_searchsiblings)(phandle node_start, const char nodename)",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null"
        },
    }
},
{
    "kprobe:prom_searchsiblings": {
        "description": "Searches siblings of a node and returns the node if the nodename matches with the promlib_buf.",
        "proto" :"phandle (*prom_searchsiblings)(phandle node_start, const char nodename)",
        "pre": {
            "node_start": "!=null",
            "nodename": "!=null"
        },
    }
},
{
    "kretprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "proto": "char *(*prom_nextprop)(phandle node, char *oprop, char *buffer)",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        }
    }
},
{
    "kprobe:prom_nextprop": {
        "description": "Return the property type string after property type 'oprop' at node 'node'. Returns empty string if no more property types for this node.",
        "proto" :"char *(*prom_nextprop)(phandle node, char *oprop, char *buffer)",
        "pre": {
            "node": "!=null",
            "oprop": "!=null",
            "buffer": "!=null"
        },
    }
},
{
    "kretprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1 here",
            "param2": "Your condition for param2 here",
            "param3": "Your condition for param3 here",
            "param4": "Your condition for param4 here",
        },
    }
},
{
    "kprobe:prom_finddevice": {
        "description": "Find a device in the prom tree based on its name. The path '...' is legal.",
        "proto" :"static phandle (*prom_finddevice)(char *name)",
        "pre": {
            "name": "!=null && is a valid device name",
        },
    }
},
{
    "kretprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'. Buffer should be at least 32B in length.",
        "proto" :"char *(*prom_firstprop)(phandle node, char *buffer)",
        "pre": {
            "node": "!=null",
            "buffer": "!=null && sizeof(buffer) >= 32"
        }
    }
},
{
    "kprobe:prom_firstprop": {
        "description": "Return the first property type for node 'node'. Buffer should be at least 32B in length.",
        "proto" :"char *(*prom_firstprop)(phandle node, char *buffer)",
        "pre": {
            "node": "!=null",
            "buffer": "!=null && sizeof(buffer) >= 32"
        }
    }
},
{
    "kretprobe:clear_dcache_dirty_cpu": {
        "description": "Clears the dcache dirty cpu for a given page and cpu.",
        "proto" :"static inline void clear_dcache_dirty_cpu(struct page *page, unsigned long cpu)",
        "pre": {
            "page": "!=null",
            "cpu": ">=0"
        }
    }
},
{
    "kprobe:clear_dcache_dirty_cpu": {
        "description": "Clears the dcache dirty cpu for a given page and cpu.",
        "proto" :"static inline void clear_dcache_dirty_cpu(struct page *page, unsigned long cpu)",
        "pre": {
            "page": "!=null",
            "cpu": ">=0"
        },
    }
},


{
    "kretprobe:__flush_dcache_range": {
        "description": "Flushes the data cache for a range of addresses from *start* to *end*.",
        "proto" :"void (__flush_dcache_range)(unsigned long start, unsigned long end)",
        "pre": {
            "start": "is an unsigned long",
            "end": "is an unsigned long and >= start"
        },
        "post": {
            "return": "void"
        }
    }
},
{
    "__flush_dcache_range": {
        "description": "Flushes the data cache for a range of memory addresses.",
        "proto" :"void __flush_dcache_range(unsigned long start, unsigned long end)",
        "pre": {
            "start": "is valid memory address",
            "end": "is valid memory address and >= start",
        },
    }
},
{
    "kretprobe:addr_to_mblock": {
        "description": "Description of the function goes here.",
        "proto" :"static struct mdesc_mblock * __init addr_to_mblock(unsigned long addr)",
        "pre": {
            "addr": "!=null",
        },
    }
},
{
    "kprobe:addr_to_mblock": {
        "description": "RA-to-PA",
        "proto" :"static struct mdesc_mblock * __init addr_to_mblock(unsigned long addr)",
        "pre": {
            "addr": ">=0",
        },
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:flushi": {
        "description": "Flush instruction cache for the given address.",
        "proto" :"void flushi(void *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:__kernel_map_pages": {
        "description": "PAGE_KERNEL, use_huge);}printk(\"Allocated %ld bytes for kernel page tables.\n\", mem_alloced);kvmap_linear_patch[0] = 0x01000000; nop",
        "proto" :"void __kernel_map_pages(struct page *page, int numpages, int enable)",
        "pre": {
            "page": "!=null",
            "numpages": ">=0",
            "enable": "in [0, 1]",
        },
    }
},
{
    "kretprobe:if_tlb_type_is_hypervisor": {
        "description": "Replace with the description of the function",
        "proto" :"Replace with the prototype of the function",
        "pre": {
            "tlb_type": "== hypervisor",
        },
    }
},
{
    "kprobe:hypervisor_tlb_lock": {
        "description": "Locks the TLBs via Hypervisor or OBP.",
        "proto" :"static long (*hypervisor_tlb_lock)(unsigned long vaddr, unsigned long pte, unsigned long mmu)",
        "pre": {
            "vaddr": "!=null",
            "pte": "!=null",
            "mmu": "!=null"
        },
    }
},

{
    "kprobe:reduce_memory": {
        "description": "Reduce memory to a certain limit. The limit is specified by limit_ram. Reserved regions, including vmlinux and initrd, are excluded from the reduction.",
        "proto" :"static void __init reduce_memory(phys_addr_t limit_ram)",
        "pre": {
            "limit_ram": ">=0",
        },
    }
},
{
    "kretprobe:copy_user_highpage": {
        "description": "Copy user highpage from one page to another. If this page has ADI enabled, copy over any ADI tags as well.",
        "proto" :"void copy_user_highpage(struct page *to, struct page *from, unsigned long vaddr, struct vm_area_struct *vma)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "is valid virtual address",
            "vma": "!=null && (vma->vm_flags & VM_SPARC_ADI) is valid"
        },
    }
},
{
    "kprobe:copy_user_highpage": {
        "description": "This function copies a user page from one location to another. If the page has ADI enabled, it also copies over any ADI tags.",
        "proto" :"void copy_user_highpage(struct page *to, struct page *from, unsigned long vaddr, struct vm_area_struct *vma)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "vaddr": "is valid virtual address",
            "vma": "!=null && vma->vm_flags & VM_SPARC_ADI is valid"
        },
    }
},
{
    "kretprobe:copy_highpage": {
        "description": "If this platform is ADI enabled, copy any ADI tags as well.",
        "proto" :"static void (*copy_highpage)(struct page *to, struct page *from)",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        },
        "post": {
            "return": "is void"
        }
    }
},
{
    "kprobe:copy_highpage": {
        "description": "Copy the content of one page to another. If the platform is ADI enabled, copy any ADI tags as well.",
        "proto" :"static void (*copy_highpage)(struct page *to, struct page *from)",
        "pre": {
            "to": "!=null",
            "from": "!=null"
        }
    }
},
{
    "kretprobe:vio_vdev_node": {
        "description": "Find the VDEV node in MD. This must be done dynamically since the node value can change if the MD is updated. NOTE: the MD must be locked, using mdesc_grab(), when calling this routine",
        "proto" :"u64 (*vio_vdev_node)(struct mdesc_handle *hp, struct vio_dev *vdev)",
        "pre": {
            "hp": "!=null",
            "vdev": "!=null"
        },
    }
},
{
    "kprobe:vio_vdev_node": {
        "description": "Find the node in the current MD which matches the given vio_dev. This must be done dynamically since the node value can change if the MD is updated. NOTE: the MD must be locked, using mdesc_grab(), when calling this routine.",
        "proto" :"u64 (*vio_vdev_node)(struct mdesc_handle *hp, struct vio_dev *vdev)",
        "pre": {
            "hp": "!=null",
            "vdev": "!=null"
        }
    }
},
{
    "kretprobe:sbus_set_sbus64": {
        "description": "This function sets the sbus64 for a given device and bursts.",
        "proto" :"sbus_set_sbus64(struct device  dev, int bursts)",
        "pre": {
            "dev": "!=null",
            "bursts": ">=0"
        },
        "post": {
            "val": ">=0"
        }
    }
},
{
    "kprobe:sbus_set_sbus64": {
        "description": "This function sets the sbus64 for a device. It reads the 'reg' property from the device's of_node, determines the slot based on the 'which_io' field of the 'reg' property, and then sets the sbus64 based on the slot and the 'bursts' argument.",
        "proto" :"void sbus_set_sbus64(struct device *dev, int bursts)",
        "pre": {
            "dev": "!=null",
            "bursts": "is integer"
        }
    }
},


{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},

{
    "kretprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "proto" :"static long (*vio_validate_sid)(struct vio_driver_state *vio, struct vio_msg_tag *tp)",
        "pre": {
            "vio": "!=null",
            "tp": "!=null",
            "tp->type": "==VIO_TYPE_CTRL",
            "tp->stype": "==VIO_SUBTYPE_INFO",
            "tp->stype_env": "==VIO_VER_INFO"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:vio_validate_sid": {
        "description": "Always let VERSION+INFO packets through unchecked, they define the new SID.",
        "proto" :"static long (*vio_validate_sid)(struct vio_driver_state *vio, struct vio_msg_tag *tp)",
        "pre": {
            "vio": "!=null",
            "tp": {
                "type": "==VIO_TYPE_CTRL",
                "stype": "==VIO_SUBTYPE_INFO",
                "stype_env": "==VIO_VER_INFO"
            }
        },
    }
},
{
    "kretprobe:send_version": {
        "description": "Send version information",
        "proto" :"static int (*send_version)(struct vio_driver_state *vio, u16 major, u16 minor)",
        "pre": {
            "vio": "!=null",
            "major": ">=0",
            "minor": ">=0"
        },
    }
},
{
    "kprobe:send_version": {
        "description": "Send version information",
        "proto" :"static int (*send_version)(struct vio_driver_state *vio, u16 major, u16 minor)",
        "pre": {
            "vio": "!=null",
            "major": ">=0",
            "minor": ">=0"
        },
    }
},




{
    "kretprobe:sparc_floppy_request_irq": {
        "description": "Request an IRQ for the floppy, save it for later use in the floppy interrupt handler.",
        "proto" :"int (*sparc_floppy_request_irq)(unsigned int irq, irq_handler_t irq_handler)",
        "pre": {
            "irq": ">=0",
            "irq_handler": "!=null"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:sparc_floppy_request_irq": {
        "description": "Request an IRQ for the floppy, save it for later use in the floppy interrupt handler.",
        "proto" :"int (*sparc_floppy_request_irq)(unsigned int irq, irq_handler_t irq_handler)",
        "pre": {
            "irq": ">=0",
            "irq_handler": "!=null"
        },
    }
},


{
    "kretprobe:__ldc_channel_exists": {
        "description": "Check if a channel with a certain ID exists in the ldc_channel_list. Needs to run under a mutex to ensure atomicity when adding and removing from the ldc_channel_list.",
        "proto" :"static int __ldc_channel_exists(unsigned long id)",
        "pre": {
            "id": ">=0",
        },
    }
},
{
    "kprobe:__ldc_channel_exists": {
        "description": "Check if a channel with the given ID exists. This function needs to run under a mutex to ensure atomicity of addition and removal from the ldc_channel_list.",
        "proto" :"static int __ldc_channel_exists(unsigned long id)",
        "pre": {
            "id": ">=0",
        },
    }
},
{
    "kretprobe:ldc_bind": {
        "description": "Bind the LDC channel, enable the interrupts, register the queues, and set the state of the channel.",
        "proto" :"int ldc_bind(struct ldc_channel *lp)",
        "pre": {
            "lp": "!=null",
            "lp->state": "==LDC_STATE_INIT",
            "lp->cfg.rx_irq": ">=0",
            "lp->cfg.tx_irq": ">=0",
            "lp->id": ">=0",
            "lp->tx_ra": ">=0",
            "lp->tx_num_entries": ">=0",
            "lp->rx_ra": ">=0",
            "lp->rx_num_entries": ">=0",
            "lp->cfg.mode": "in [LDC_MODE_RAW, ...]" // replace ... with other possible modes
        },
    }
},
{
    "kprobe:ldc_bind": {
        "description": "This function binds the ldc_channel, enables the IRQs, configures the tx and rx queues, and sets the state of the channel. If the mode is RAW, the handshake is completed.",
        "proto" :"ldc_bind(struct ldc_channel *lp)",
        "pre": {
            "lp": "!=null",
            "lp->state": "==LDC_STATE_INIT",
            "lp->cfg.rx_irq": "!=null",
            "lp->cfg.tx_irq": "!=null",
            "lp->id": "!=null",
            "lp->tx_ra": "!=null",
            "lp->tx_num_entries": "!=null",
            "lp->rx_ra": "!=null",
            "lp->rx_num_entries": "!=null",
            "lp->cfg.mode": "in [LDC_MODE_RAW, ...]" // other modes need to be specified
        },
    }
},

{
    "kprobe:ldc_bind": {
        "description": "Bind a channel to a specific address.",
        "proto" :"int ldc_bind(struct ldc_channel *lp)",
        "pre": {
            "lp": "!=null",
        },
    }
},
{
    "kretprobe:sun4v_ldc_rx_get_state": {
        "description": "Get the state of the LDC channel.",
        "proto" :"static long (*sun4v_ldc_rx_get_state)(struct ldc_channel *lp, unsigned long *rx_head, unsigned long *rx_tail, unsigned long *chan_state)",
        "pre": {
            "lp": "!=null",
            "rx_head": "!=null",
            "rx_tail": "!=null",
            "chan_state": "!=null"
        },
    }
},



{
    "kretprobe:ldc_read": {
        "description": "Paths do all of the control frame and state management. Just trigger the callback.",
        "proto" :"if (lp->hs_state == LDC_HS_COMPLETE)",
        "pre": {
            "lp": "!=null",
            "hs_state": "in [LDC_HS_COMPLETE, ...]" // other possible states need to be filled here
        },
    }
},
{
    "kprobe:ldc_read": {
        "description": "Paths do all of the control frame and state management. Just trigger the callback.",
        "proto" :"static long (*ldc_read)(void *lp)",
        "pre": {
            "lp": "!=null",
            "lp->hs_state": "is integer",
            "LDC_HS_COMPLETE": "is constant integer"
        },
        "post": {
            "lp->hs_state": "== LDC_HS_COMPLETE"
        }
    }
},
{
    "kretprobe:ldc_copy": {
        "description": "It is caller policy what to do about short copies. For example, a networking driver can declare the packet a runt and drop it.",
        "proto" :"ldc_copy(struct ldc_channel *lp, int copy_dir, void *buf, unsigned int len, unsigned long offset, struct ldc_trans_cookie *cookies, int ncookies)",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": ">=0",
            "offset": ">=0",
            "cookies": "!=null",
            "ncookies": ">=0"
        }
    }
},
{
    "kprobe:ldc_copy": {
        "description": "Copy data between user and kernel space. It is caller policy what to do about short copies. For example, a networking driver can declare the packet a runt and drop it.",
        "proto" :"ldc_copy(struct ldc_channel *lp, int copy_dir, void *buf, unsigned int len, unsigned long offset, struct ldc_trans_cookie *cookies, int ncookies)",
        "pre": {
            "lp": "!=null",
            "copy_dir": "in [LDC_COPY_IN, LDC_COPY_OUT]",
            "buf": "!=null",
            "len": ">=0",
            "offset": ">=0",
            "cookies": "!=null",
            "ncookies": ">=0"
        }
    }
},

{
    "kprobe:set_auxio": {
        "description": "This function sets the AUXIO register on the machine.",
        "proto" :"void set_auxio(unsigned char bits_on, unsigned char bits_off)",
        "pre": {
            "bits_on": "is an unsigned char",
            "bits_off": "is an unsigned char"
        },
    }
},
{
    "kretprobe:get_fb_unmapped_area": {
        "description": "Get the first unmapped area of the process.",
        "proto" :"static long (*get_fb_unmapped_area)(struct file *filp, unsigned long orig_addr, unsigned long len, unsigned long pgoff, unsigned long flags)",
        "pre": {
            "filp": "!=null",
            "orig_addr": ">=0",
            "len": ">=0",
            "pgoff": ">=0",
            "flags": "in [MAP_FIXED, MAP_SHARED, MAP_PRIVATE, MAP_ANONYMOUS, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_NORESERVE, MAP_LOCKED, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK, MAP_HUGETLB]"
        }
    }
},
{
    "kprobe:get_fb_unmapped_area": {
        "description": "Get the first unmapped area of the specified size in the process's virtual memory layout.",
        "proto" :"static long (*get_fb_unmapped_area)(struct file *filp, unsigned long orig_addr, unsigned long len, unsigned long pgoff, unsigned long flags)",
        "pre": {
            "filp": "!=null",
            "orig_addr": ">=0",
            "len": ">=0",
            "pgoff": ">=0",
            "flags": "in [MAP_FIXED, MAP_SHARED, MAP_PRIVATE, MAP_ANONYMOUS, MAP_HUGETLB]",
        },
    }
},
{
    "kretprobe:_map_to_cpu": {
        "description": "Maps the given index to a CPU. The function iterates over the possible CPUs until it finds an online one that is greater than or equal to the end index, which is the input index modulo the number of online CPUs. If such a CPU is found, its index is returned. The function assumes that the number of online CPUs is less than or equal to the number of possible CPUs.",
        "proto" :"static int (*_map_to_cpu)(unsigned int index)",
        "pre": {
            "index": ">= 0"
        },
        "post": {
            "return": "in [0, num_possible_cpus() - 1]"
        }
    }
},
{
    "kprobe:map_to_cpu": {
        "description": "Maps the given index to a CPU. The function iterates over the possible CPUs until it finds an online one that is greater or equal to the end value, which is the index modulo the number of online CPUs. If such a CPU is found, its index is returned.",
        "proto" :"static int (*map_to_cpu)(unsigned int index)",
        "pre": {
            "index": ">=0"
        }
    }
},
{
    "kretprobe:pci_set_master": {
        "description": "Sets the device as a bus master.",
        "proto" :"static void (*pci_set_master)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
    },
    "kretprobe:pci_domain_nr": {
        "description": "Returns the domain number for the bus.",
        "proto" :"int (*pci_domain_nr)(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        },
    }
},



{
    "kretprobe:mdesc_get_node_info": {
        "description": "Find the get_info op for the given node name.",
        "proto" :"mdesc_get_node_info(struct mdesc_handle  hp, u64 node, const char  node_name, union md_node_info  node_info)",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        },
    }
},
{
    "kprobe:mdesc_get_node_info": {
        "description": "Find the get_info op for the given node name.",
        "proto" :"mdesc_get_node_info(struct mdesc_handle  hp, u64 node, const char  node_name, union md_node_info  node_info)",
        "pre": {
            "hp": "!=null",
            "node": "!=MDESC_NODE_NULL",
            "node_name": "!=null",
            "node_info": "!=null"
        },
    }
},
{
    "kretprobe:get_vdev_port_node_info": {
        "description": "Virtual device nodes are distinguished by: 1. 'id' property 2. 'name' property 3. parent node 'cfg-handle' property",
        "proto": "static int get_vdev_port_node_info(struct mdesc_handle md, u64 node, union md_node_info node_info)",
        "pre": {
            "md": "!=null",
            "node": "!=null",
            "node_info": "!=null"
        },
        "post": {
            "return": "in [-1, 0]",
            "node_info->vdev_port.id": "!=null",
            "node_info->vdev_port.name": "!=null",
            "node_info->vdev_port.parent_cfg_hdl": "!=null"
        }
    }
},
{
    "kprobe:get_vdev_port_node_info": {
        "description": "Virtual device nodes are distinguished by: 1. 'id' property 2. 'name' property 3. parent node 'cfg-handle' property",
        "proto" :"static int (*get_vdev_port_node_info)(struct mdesc_handle md, u64 node, union md_node_info node_info)",
        "pre": {
            "md": "!=null",
            "node": "!=null",
            "node_info": "!=null",
            "idp": "!=null",
            "name": "!=null",
            "parent_cfg_hdlp": "!=null"
        },
    }
},
{
    "kretprobe:idprom_read": {
        "description": "Reads the idprom into kernel addresses.",
        "proto" :"int idprom_read(struct idprom *idprom)",
        "pre": {
            "idprom": "!=null",
        },
    }
},

{
    "kretprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum. @src: source address @dst: destination address @len: number of bytes to be copied. @sum: initial sum that is added into the result (32bit unfolded) Returns an 32bit unfolded checksum of the buffer.",
        "proto" :"static long (*__wsumcsum_partial_copy_nocheck)(const void *src, void *dst, int len)",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:__wsumcsum_partial_copy_nocheck": {
        "description": "Copy and checksum. @src: source address @dst: destination address @len: number of bytes to be copied. @sum: initial sum that is added into the result (32bit unfolded) Returns an 32bit unfolded checksum of the buffer.",
        "proto" :"static long (*__wsumcsum_partial_copy_nocheck)(const void *src, void *dst, int len)",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:__delay": {
        "description": "__delay function must _NOT_ be inlined as its execution time depends wildly on alignment on many x86 processors. The additional jump magic is needed to get the timing stable on all the CPU's we have to worry about.",
        "proto" :"static void delay_loop(u64 __loops)",
        "pre": {
            "__loops": ">=0",
        },
    }
},
{
    "kprobe:__delay": {
        "description": "__delay function must _NOT_ be inlined as its execution time depends wildly on alignment on many x86 processors. The additional jump magic is needed to get the timing stable on all the CPU's we have to worry about.",
        "proto" :"static void delay_loop(u64 __loops)",
        "pre": {
            "__loops": ">=0",
        },
    }
},
{
    "kretprobe:strstr": {
        "description": "Finds the first occurrence of the substring *ct* in the string *cs*. Returns a pointer to the beginning of the substring, or NULL if the substring is not found.",
        "proto" :"char* (*strstr)(const char *cs, const char *ct)",
        "pre": {
            "cs": "!=null",
            "ct": "!=null"
        },
    }
},
{
    "kprobe:strstr": {
        "description": "Returns a pointer to the first occurrence of needle in haystack, or NULL if needle is not part of haystack.",
        "proto" :"char* (*strstr)(const char *haystack, const char *needle)",
        "pre": {
            "haystack": "!=null",
            "needle": "!=null"
        },
    }
},
{
    "kretprobe:memcpy_fromio": {
        "description": "Copy data from IO memory space to normal memory space. Align any unaligned source IO.",
        "proto" :"void memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0"
        },
        "post": {
            "to": "contains copied data from 'from' of size 'n'",
            "from": "unaltered",
            "n": "unaligned source IO is aligned"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Copy n bytes from IO memory area 'from' to 'to'. If n is zero, do nothing. Align any unaligned source IO.",
        "proto" :"void memcpy_fromio(void *to, const volatile void __iomem *from, size_t n)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
            "from_alignment": "1 & (unsigned long)from == 0"
        },
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"void (*kmsan_check_memory)(const void *from, size_t n)",
        "pre": {
            "from": "!=null",
            "n": ">0"
        },
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Make sure uninitialized memory isn't copied to devices.",
        "proto" :"static void (*kmsan_check_memory)(const void *from, size_t n)",
        "pre": {
            "from": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memset_io": {
        "description": "Sets the first 'c' bytes of the block of memory pointed by 'a' to the specified value 'b'.",
        "proto" :"void (*memset_io)(volatile void __iomem *a, int b, size_t c)",
        "pre": {
            "a": "!=null",
            "b": "is int",
            "c": "is size_t"
        },
    }
},
{
    "kprobe:memset_io": {
        "description": "Sets the memory pointed by *a* with the value *b* for *c* times.",
        "proto" :"static void (*memset_io)(volatile void __iomem *a, int b, size_t c)",
        "pre": {
            "a": "!=null",
            "b": "is int",
            "c": "is size_t"
        },
    }
},
{
    "kretprobe:clear_user": {
        "description": "Zero a block of memory in user space. Return: number of bytes that could not be cleared. On success, this will be zero.",
        "proto" :"unsigned long (*clear_user)(void __user *to, unsigned long n)",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "in [0, n]"
        }
    }
},
{
    "kprobe:clear_user": {
        "description": "Zero a block of memory in user space.",
        "proto" :"unsigned long (*clear_user)(void __user *to, unsigned long n)",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "in [0, n]"
        }
    }
},
{
    "kretprobe:__clear_user": {
        "description": "Zero a block of memory in user space, with less checking. Caller must check the specified block with access_ok() before calling this function. Returns number of bytes that could not be cleared. On success, this will be zero.",
        "proto": "unsigned long (*__clear_user)(void __user *to, unsigned long n)",
        "pre": {
            "to": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "in [0, n]"
        }
    }
},
{
    "kprobe:__clear_user": {
        "description": "Zero a block of memory in user space, with less checking. Caller must check the specified block with access_ok() before calling this function. Returns number of bytes that could not be cleared. On success, this will be zero.",
        "proto" :"unsigned long (*__clear_user)(void __user *to, unsigned long n)",
        "pre": {
            "to": "!=null && access_ok(to)",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:csum_partial": {
        "description": "This function calculates the partial checksum, starting with an initial 'sum'. 'len == 40' is a hot case due to IPv6 headers, but annotating it likely() has noticeable negative affect on codegen for all other cases with minimal performance benefit here.",
        "proto" :"static __wsum (*csum_partial)(const void *buff, int len, __wsum sum)",
        "pre": {
            "buff": "!=null",
            "len": "in [0, 40]",
            "sum": "is a valid __wsum value"
        },
        "post": {
            "return": "is a valid __wsum value"
        }
    }
},
{
    "kprobe:csum_partial": {
        "description": "This function calculates the checksum of the buffer *buff* with length *len* and initial sum *sum*. The case where *len* equals 40 is a hot case due to IPv6 headers.",
        "proto": "csum_partial(const void *buff, int len, __wsum sum)",
        "pre": {
            "buff": "!=null",
            "len": "is an integer",
            "sum": "is a __wsum type",
            "len == 40": "is a special case due to IPv6 headers"
        }
    }
},
{
    "kretprobe:xen_alloc_p2m_entry": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here",
            "param4": "Your condition here",
        },
    }
},
{
    "kprobe:xen_alloc_p2m_entry": {
        "description": "Allocate a new PMD level if it is missing or is an identity pte. The function takes a page frame number (pfn) as input and returns a pointer to the allocated pmd (ptep). If the allocation fails, it returns -ENOMEM.",
        "proto" :"unsigned long (*xen_alloc_p2m_entry)(unsigned long pfn)",
        "pre": {
            "pfn": "< MAX_P2M_PFN",
        },
        "post": {
            "ptep": "!=null || ==-ENOMEM",
        }
    }
},
{
    "kretprobe:blake2s_compress_ssse3": {
        "description": "Compresses the blake2s state with ssse3.",
        "proto" :"void blake2s_compress_ssse3(struct blake2s_state state, const u8 block, const size_t nblocks, const u32 inc)",
        "pre": {
            "state": "!=null",
            "block": "!=null",
            "nblocks": ">=0",
            "inc": ">=0"
        }
    },
    "kretprobe:blake2s_compress_avx512": {
        "description": "Compresses the blake2s state with avx512.",
        "proto" :"void blake2s_compress_avx512(struct blake2s_state state, const u8 block, const size_t nblocks, const u32 inc)",
        "pre": {
            "state": "!=null",
            "block": "!=null",
            "nblocks": ">=0",
            "inc": ">=0"
        }
    }
},
{
    "kprobe:blake2s_compress_ssse3": {
        "description": "Compresses the blake2s state using SSSE3 instructions.",
        "proto" :"void (*blake2s_compress_ssse3)(struct blake2s_state state, const u8 block, const size_t nblocks, const u32 inc)",
        "pre": {
            "state": "!=null",
            "block": "!=null",
            "nblocks": ">=0",
            "inc": ">=0"
        }
    },
    "kprobe:blake2s_compress_avx512": {
        "description": "Compresses the blake2s state using AVX512 instructions.",
        "proto" :"void (*blake2s_compress_avx512)(struct blake2s_state state, const u8 block, const size_t nblocks, const u32 inc)",
        "pre": {
            "state": "!=null",
            "block": "!=null",
            "nblocks": ">=0",
            "inc": ">=0"
        }
    }
},
{
    "kretprobe:get_ibs_caps": {
        "description": "Check IBS cpuid feature flags",
        "proto" :"static int (*get_ibs_caps)(void)",
        "pre": {},
        "post": {
            "return": "in [0, IBS_CAPS_DEFAULT]"
        }
    }
},
{
    "kprobe:get_ibs_caps": {
        "description": "Check IBS cpuid feature flags",
        "proto" :"static u32 (*get_ibs_caps)(void)",
        "pre": {
            "X86_FEATURE_IBS": "!=null",
        },
    }
},
{
    "kretprobe:setup_node_to_cpumask_map": {
        "description": "cpumask_of_node() is not valid until after this is done. (Use CONFIG_DEBUG_PER_CPU_MAPS to check this.)",
        "proto" :"void __init (*setup_node_to_cpumask_map)(void)",
        "pre": {},
    }
},
{
    "kprobe:setup_node_to_cpumask_map": {
        "description": "cpumask_of_node() is not valid until after this is done. (Use CONFIG_DEBUG_PER_CPU_MAPS to check this.)",
        "proto" :"void __init (*setup_node_to_cpumask_map)(void)",
        "pre": {
            // Here should be the preconditions for the function, but no specific conditions are provided in the helper doc.
        },
    }
},


{
    "kretprobe:register_kmmio_probe": {
        "description": "Registers a kmmio_probe. The function saves the local interrupt flags, locks the kmmio_lock, checks if a kmmio_probe already exists at the address, and if not, adds the new probe to the list and sets a page fault for each page in the range. It then unlocks the kmmio_lock and restores the local interrupt flags.",
        "proto" :"register_kmmio_probe(struct kmmio_probe  p){unsigned long flags;int ret = 0;unsigned long size = 0;unsigned long addr = p->addr & PAGE_MASK;const unsigned long size_lim = p->len + (p->addr & ~PAGE_MASK);unsigned int l;pte_t  pte;local_irq_save(flags);arch_spin_lock(&kmmio_lock);if (get_kmmio_probe(addr)) {ret = -EEXIST;goto out;}pte = lookup_address(addr, &l);if (!pte) {ret = -EINVAL;goto out;}kmmio_count++;list_add_rcu(&p->list, &kmmio_probes);while (size < size_lim) {if (add_kmmio_fault_page(addr + size))pr_err(\"Unable to set page fault.\\n\");size += page_level_size(l);}out:arch_spin_unlock(&kmmio_lock);local_irq_restore(flags); return ret;}",
        "pre": {
            "p": "!=null",
            "p->addr": ">=0",
            "p->len": ">=0"
        }
    }
},
{
    "kprobe:register_kmmio_probe": {
        "description": "Registers a kmmio_probe. If the probe already exists, returns -EEXIST. If the address lookup fails, returns -EINVAL. Increments kmmio_count and adds the probe to the kmmio_probes list. Attempts to add a fault page for each page in the range of the probe. Unlocks kmmio_lock and restores local interrupts.",
        "proto" :"register_kmmio_probe(struct kmmio_probe  p){unsigned long flags;int ret = 0;unsigned long size = 0;unsigned long addr = p->addr & PAGE_MASK;const unsigned long size_lim = p->len + (p->addr & ~PAGE_MASK);unsigned int l;pte_t  pte;local_irq_save(flags);arch_spin_lock(&kmmio_lock);if (get_kmmio_probe(addr)) {ret = -EEXIST;goto out;}pte = lookup_address(addr, &l);if (!pte) {ret = -EINVAL;goto out;}kmmio_count++;list_add_rcu(&p->list, &kmmio_probes);while (size < size_lim) {if (add_kmmio_fault_page(addr + size))pr_err(\"Unable to set page fault.\\n\");size += page_level_size(l);}out:arch_spin_unlock(&kmmio_lock);local_irq_restore(flags);}",
        "pre": {
            "p": "!=null",
            "p->addr": ">=0",
            "p->len": ">=0",
            "flags": "is saved",
            "ret": "==0",
            "size": "==0",
            "addr": "==p->addr & PAGE_MASK",
            "size_lim": "==p->len + (p->addr & ~PAGE_MASK)",
            "l": "is defined",
            "pte": "is defined",
            "kmmio_lock": "is locked"
        }
    }
},
{
    "kretprobe:unregister_kmmio_probe": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here",
            "param4": "Your condition here",
        },
    }
},
{
    "kprobe:unregister_kmmio_probe": {
        "description": "Unregister a kmmio probe.",
        "proto" :"unregister_kmmio_probe(struct kmmio_probe  p)",
        "pre": {
            "p": "!=null",
            "p->addr": "valid address",
            "p->len": ">=0",
        },
    }
},

{
    "kprobe:vm_get_page_prot": {
        "description": "Take the 4 protection key bits out of the vma->vm_flags value and turn them in to the bits that we can put in to a pte. Only override these if Protection Keys are available (which is only on 64-bit).",
        "proto" :"vm_get_page_prot(unsigned long vm_flags)",
        "pre": {
            "vm_flags": "your_condition_here"
        }
    }
},
{
    "kretprobe:__virt_addr_valid": {
        "description": "Use the carry flag to determine if x was < __START_KERNEL_map.",
        "proto": "static long (*__virt_addr_valid)(unsigned long x)",
        "pre": {
            "x": ">= __START_KERNEL_map"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:__virt_addr_valid": {
        "description": "Use the carry flag to determine if x was < __START_KERNEL_map.",
        "proto" :"static long (*__virt_addr_valid)(unsigned long x)",
        "pre": {
            "x": ">= __START_KERNEL_map",
        },
        "post": {
            "result": "in [0, 1]"
        }
    }
},
{
    "__phys_addr_symbol": {
        "description": "Check upper bounds since lower bounds will trigger carry.",
        "proto" :"unsigned long (__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= __START_KERNEL_map && < KERNEL_IMAGE_SIZE"
        },
    }
},
{
    "__phys_addr_symbol": {
        "description": "Calculates the physical address from the given virtual address 'x'. Checks only upper bounds since lower bounds will trigger carry.",
        "proto" :"unsigned long (*__phys_addr_symbol)(unsigned long x)",
        "pre": {
            "x": ">= __START_KERNEL_map && < (__START_KERNEL_map + KERNEL_IMAGE_SIZE)"
        },
    }
},


{
    "kretprobe:ioremap_uc": {
        "description": "Map bus memory into CPU space as strongly uncachable. The returned address is not guaranteed to be usable directly as a virtual address. This version of ioremap ensures that the memory is marked with a strong preference as completely uncachable on the CPU when possible. For non-PAT systems this ends up setting page-attribute flags PCD=1, PWT=1. For PAT systems this will set the PAT entry for the pages as strong UC. This call will honor existing caching rules from things like the PCI bus. Note that there are other caches and buffers on many busses. In particular driver authors should read up on PCI writes. It's useful if some control registers are in such an area and write combining or read caching is not desirable. Must be freed with iounmap.",
        "proto" :"enum page_cache_mode pcm = _PAGE_CACHE_MODE_UC_MINUS;return __ioremap_caller(phys_addr, size, pcm,__builtin_return_address(0), false);",
        "pre": {
            "phys_addr": "your_condition_here",
            "size": "your_condition_here",
            "pcm": "your_condition_here"
        }
    }
},
{
    "kprobe:ioremap_uc": {
        "description": "Map bus memory into CPU space as strongly uncachable. The returned address is not guaranteed to be usable directly as a virtual address. This version of ioremap ensures that the memory is marked with a strong preference as completely uncachable on the CPU when possible. For non-PAT systems this ends up setting page-attribute flags PCD=1, PWT=1. For PAT systems this will set the PAT entry for the pages as strong UC. This call will honor existing caching rules from things like the PCI bus. Note that there are other caches and buffers on many busses. In particular driver authors should read up on PCI writes. It's useful if some control registers are in such an area and write combining or read caching is not desirable. Must be freed with iounmap.",
        "proto" :"enum page_cache_mode pcm = _PAGE_CACHE_MODE_UC_MINUS;return __ioremap_caller(phys_addr, size, pcm,__builtin_return_address(0), false);",
        "pre": {
            "phys_addr": "your_condition_here",
            "size": "your_condition_here",
            "pcm": "your_condition_here",
            "__builtin_return_address(0)": "your_condition_here",
            "false": "your_condition_here"
        },
    }
},
{
    "kretprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through. This version of ioremap ensures that the memory is marked write through. Write through stores data into memory while keeping the cache up-to-date. Must be freed with iounmap.",
        "proto" :"void __iomem *(*ioremap_wt)(resource_size_t phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap_wt": {
        "description": "Map memory into CPU space write through. This version of ioremap ensures that the memory is marked write through. Write through stores data into memory while keeping the cache up-to-date. Must be freed with iounmap.",
        "proto" :"void __iomem *(*ioremap_wt)(resource_size_t phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:ioremap": {
        "description": "Maps the given physical address to the virtual address space.",
        "proto": "void __iomem *(*ioremap)(resource_size_t phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Maps the given physical address to the virtual address space.",
        "proto" :"void __iomem *(*ioremap)(resource_size_t phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:fix_addr": {
        "description": "This code will fix the top bit if needed and is a no-op otherwise.",
        "proto" :"static inline unsigned long fix_addr(unsigned long addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:fix_addr": {
        "description": "This code will fix the top bit if needed and is a no-op otherwise.",
        "proto" :"static inline unsigned long fix_addr(unsigned long addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:set_memory_wb": {
        "description": "Set the WB cache mode, which is hard wired to all cache attribute bits being 0.",
        "proto" :"int set_memory_wb(unsigned long addr, int numpages)",
        "pre": {
            "addr": "!=null",
            "numpages": ">=0"
        },
    }
},
{
    "kprobe:set_memory_wb": {
        "description": "WB cache mode is hard wired to all cache attribute bits being 0",
        "proto" :"int set_memory_wb(unsigned long addr, int numpages)",
        "pre": {
            "addr": "your_condition_here",
            "numpages": "your_condition_here"
        },
    }
},

{
    "kprobe:set_pages_array_wb": {
        "description": "WB cache mode is hard wired to all cache attribute bits being 0",
        "proto" :"int set_pages_array_wb(struct page *pages, int numpages)",
        "pre": {
            "pages": "!=null",
            "numpages": ">=0"
        },
    }
},
{
    "kretprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it. If there is a CPU register the modification of which by the boot kernel might affect the operations of the restored target kernel, then its contents must be saved by this function.",
        "proto" :"static void (*__save_processor_state)(struct saved_context *ctxt)",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kprobe:__save_processor_state": {
        "description": "Save CPU registers before creating a hibernation image and before restoring the memory state from it. If there is a CPU register the modification of which by the boot kernel might affect the operations of the restored target kernel, then its contents must be saved by this function.",
        "proto" :"static void (*__save_processor_state)(struct saved_context *ctxt)",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state() @ctxt: Structure to load the registers contents from. The asm code that gets us here will have restored a usable GDT, although it will be pointing to the wrong alias.",
        "proto" :"static void notrace (__restore_processor_state)(struct saved_context *ctxt)",
        "pre": {
            "ctxt": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:__restore_processor_state": {
        "description": "Restore the contents of CPU registers saved by __save_processor_state(). The asm code that gets us here will have restored a usable GDT, although it will be pointing to the wrong alias.",
        "proto" :"static void notrace (*__restore_processor_state)(struct saved_context *ctxt)",
        "pre": {
            "ctxt": "!=null"
        }
    }
},
{
    "kretprobe:scx200_probe": {
        "description": "Read the current values driven on the GPIO signals",
        "proto" :"static int scx200_probe(struct pci_dev *pdev, const struct pci_device_id *ent)",
        "pre": {
            "pdev": "!=null",
            "ent": "!=null"
        }
    }
},
{
    "kprobe:bpf_probe_read": {
        "description": "Reads size bytes from src into dst.",
        "proto" :"static long (*bpf_probe_read)(void *dst, int size, const void *src)",
        "pre": {
            "dst": "!=null",
            "size": ">=0",
            "src": "!=null"
        },
    }
},
{
    "kretprobe:iosf_mbi_modify": {
        "description": "Access to the GFX unit is handled by GPU code",
        "proto" :"static int (*iosf_mbi_modify)(u8 port, u8 opcode, u32 offset, u32 mdr, u32 mask)",
        "pre": {
            "port": "== BT_MBI_UNIT_GFX",
            "opcode": "!=null",
            "offset": "!=null",
            "mdr": "!=null",
            "mask": "!=null"
        },
    }
},
{
    "kprobe:iosf_mbi_modify": {
        "description": "Access to the GFX unit is handled by GPU code",
        "proto" :"iosf_mbi_modify(u8 port, u8 opcode, u32 offset, u32 mdr, u32 mask){u32 mcr, mcrx;u32 value;unsigned long flags;int ret;}",
        "pre": {
            "port": "== BT_MBI_UNIT_GFX",
            "opcode": "can be any u8 value",
            "offset": "can be any u32 value",
            "mdr": "can be any u32 value",
            "mask": "can be any u32 value",
            "mcr": "can be any u32 value",
            "mcrx": "can be any u32 value",
            "value": "can be any u32 value",
            "flags": "can be any unsigned long value",
            "ret": "can be any int value"
        }
    }
},
{
    "kretprobe:iosf_mbi_available": {
        "description": "Mbi isn't hot-pluggable. No remove routine is provided",
        "proto" :"static long (*iosf_mbi_available)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iosf_mbi_available": {
        "description": "Mbi isn't hot-pluggable. No remove routine is provided",
        "proto" :"static long (*iosf_mbi_available)(void)",
        "pre": {},
    }
},
{
    "kretprobe:iosf_mbi_punit_acquire": {
        "description": "Wait for any I2C PMIC accesses from in kernel drivers to finish.",
        "proto" :"static void (*iosf_mbi_punit_acquire)(void)",
        "pre": {
            "iosf_mbi_pmic_access_mutex": "unlocked",
            "iosf_mbi_pmic_i2c_access_count": "== 0"
        },
        "post": {
            "iosf_mbi_pmic_access_mutex": "locked",
            "iosf_mbi_pmic_i2c_access_count": "== 0"
        }
    }
},
{
    "kprobe:iosf_mbi_punit_acquire": {
        "description": "Wait for any I2C PMIC accesses from in kernel drivers to finish.",
        "proto" :"static void (*iosf_mbi_punit_acquire)(void)",
        "pre": {
            "iosf_mbi_pmic_access_mutex": "unlocked",
            "iosf_mbi_pmic_i2c_access_count": "== 0"
        },
    }
},
{
    "kretprobe:cpu_latency_qos_update_request": {
        "description": "PLACEHOLDER_DESCRIPTION",
        "proto" :"static long (*cpu_latency_qos_update_request)(void *iosf_mbi_pm_qos, __u64 value)",
        "pre": {
            "iosf_mbi_pm_qos": "PLACEHOLDER_CONDITION",
            "value": "PLACEHOLDER_CONDITION"
        }
    }
},
{
    "kprobe:cpu_latency_qos_update_request": {
        "description": "Description of the function goes here",
        "proto" :"static long (*cpu_latency_qos_update_request)(void *iosf_mbi_pm_qos, int value)",
        "pre": {
            "iosf_mbi_pm_qos": "!=null",
            "value": "is integer",
        },
    }
},
{
    "kretprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering",
        "proto" :"int iosf_mbi_register_pmic_bus_access_notifier(struct notifier_block *nb)",
        "pre": {
            "nb": "!=null"
        },
        "post": {
            "ret": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:iosf_mbi_register_pmic_bus_access_notifier": {
        "description": "Wait for the bus to go inactive before registering",
        "proto" :"int (*iosf_mbi_register_pmic_bus_access_notifier)(struct notifier_block *nb)",
        "pre": {
            "nb": "!=null",
        },
    }
},
{
    "kretprobe:iosf_mbi_punit_acquire": {
        "description": "Acquires the punit",
        "proto" :"static long (*iosf_mbi_punit_acquire)(void)",
        "pre": {},
        "post": {
            "ret": ">=0"
        }
    }
},
{
    "kprobe:iosf_mbi_punit_acquire": {
        "description": "Description of the function",
        "proto" :"void iosf_mbi_punit_acquire(void *punit)",
        "pre": {
            "punit": "!=null"
        },
    }
},
{
    "kretprobe:__delay": {
        "description": "Delays execution for a specified number of loops.",
        "proto" :"static void (*__delay)(unsigned long loops)",
        "pre": {
            "loops": ">=0"
        }
    }
},
{
    "kprobe:__delay": {
        "description": "Delays the execution of the program by a certain number of loops.",
        "proto" :"static void (*__delay)(unsigned long loops)",
        "pre": {
            "loops": "> 0"
        }
    }
},
{
    "kretprobe:pcibios_align_resource": {
        "description": "Aligns the resource for the PCI device. If the resource is I/O, it skips the ISA I/O resource alignment. If the resource is memory, it reserves the low 1MB range for ISA cards.",
        "proto": "resource_size_t (*pcibios_align_resource)(void *data, const struct resource *res, resource_size_t size, resource_size_t align)",
        "pre": {
            "data": "!=null",
            "res": "!=null",
            "size": ">=0",
            "align": ">=0"
        }
    }
},
{
    "kprobe:pcibios_align_resource": {
        "description": "Aligns the resource for the PCI device. If the resource is I/O, it aligns it to the next 0x3ff boundary if it's not already aligned. If the resource is memory, it reserves the low 1MB range for ISA cards.",
        "proto": "resource_size_t (*pcibios_align_resource)(void *data, const struct resource *res, resource_size_t size, resource_size_t align)",
        "pre": {
            "data": "!=null",
            "res": "!=null",
            "size": ">=0",
            "align": ">=0",
            "res->flags": "in [IORESOURCE_IO, IORESOURCE_MEM]"
        }
    }
},
{
    "kretprobe:paravirt_patch_call": {
        "description": "If there's no function, patch it with paravirt_BUG()",
        "proto" :"static unsigned (*paravirt_patch_call)(insn_buff, paravirt_BUG, addr, len)",
        "pre": {
            "insn_buff": "!=null",
            "paravirt_BUG": "!=null",
            "addr": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kprobe:paravirt_patch_call": {
        "description": "If there's no function, patch it with paravirt_BUG()",
        "proto" :"static unsigned (*paravirt_patch_call)(void *insn_buff, void *paravirt_BUG, void *addr, __u64 len)",
        "pre": {
            "insn_buff": "!=null",
            "paravirt_BUG": "!=null",
            "addr": "!=null",
            "len": ">=0",
        },
    }
},

{
    "kprobe:outb_pic": {
        "description": "This function works on a wide range of PC hardware.",
        "proto" :"static void (*outb_pic)(unsigned long flags, int auto_eoi)",
        "pre": {
            "flags": "!=null",
            "auto_eoi": "in [0, 1]",
        },
    }
},
{
    "kretprobe:__register_nmi_handler": {
        "description": "Indicate if there are multiple registrations on the internal NMI handler call chains (SERR and IO_CHECK).",
        "proto" :"int __register_nmi_handler(unsigned int type, struct nmiaction *action)",
        "pre": {
            "type": "in [NMI_SERR, NMI_IO_CHECK]",
            "action": "!=null",
            "action->handler": "!=null",
            "list_empty(&action->list)": "==false"
        },
    }
},
{
    "__register_nmi_handler": {
        "description": "Indicate if there are multiple registrations on the internal NMI handler call chains (SERR and IO_CHECK).",
        "proto" :"__register_nmi_handler(unsigned int type, struct nmiaction action)",
        "pre": {
            "type": "in [NMI_SERR, NMI_IO_CHECK]",
            "action": "!=null",
            "action->handler": "!=null",
            "action->list": "is_empty"
        },
    }
},
{
    "kretprobe:profile_pc": {
        "description": "Return address is either directly at stack pointer or above a saved flags. Eflags has bits 22-31 zero, kernel addresses don't.",
        "proto" :"profile_pc(struct pt_regs  regs)",
        "pre": {
            "regs": "!=null"
        },
    }
},
{
    "kprobe:profile_pc": {
        "description": "Return address is either directly at stack pointer or above a saved flags. Eflags has bits 22-31 zero, kernel addresses don't.",
        "proto" :"profile_pc(struct pt_regs  regs)",
        "pre": {
            "regs": "!=null",
            "pc": "derived from instruction_pointer(regs)",
            "sp": "derived from regs->sp",
            "bp": "derived from regs->bp",
            "user_mode(regs)": "boolean",
            "in_lock_functions(pc)": "boolean"
        },
    }
},
{
    "kretprobe:EXPORT_SYMBOL(cpu_khz)": {
        "description": "TSC clocks usec, not used here",
        "proto" :"static long (*cpu_khz)(void *clock, __u64 usec)",
        "pre": {
            "clock": "!=null",
            "usec": ">0",
        },
    }
},

{
    "kretprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC. PTM requires all timestamps to be in units of nanoseconds. When user software requests a cross-timestamp, this function converts system timestamp to TSC. This is valid when CPU feature flag X86_FEATURE_TSC_KNOWN_FREQ is set indicating the tsc_khz is derived from CPUID[15H]. Drivers should check that this flag is set before conversion to TSC is attempted.",
        "proto" :"struct system_counterval_t (*convert_art_ns_to_tsc)(u64 art_ns)",
        "pre": {
            "art_ns": ">=0",
        },
        "post": {
            "return": {
                "cycles": ">=0",
                "cs": "!=null"
            }
        }
    }
},
{
    "kprobe:convert_art_ns_to_tsc": {
        "description": "Convert ART in nanoseconds to TSC. PTM requires all timestamps to be in units of nanoseconds. When user software requests a cross-timestamp, this function converts system timestamp to TSC. This is valid when CPU feature flag X86_FEATURE_TSC_KNOWN_FREQ is set indicating the tsc_khz is derived from CPUID[15H]. Drivers should check that this flag is set before conversion to TSC is attempted.",
        "proto" :"struct system_counterval_t (*convert_art_ns_to_tsc)(u64 art_ns)",
        "pre": {
            "art_ns": ">=0",
        },
        "post": {
            "return": {
                "cycles": ">=0",
                "cs": "!=null"
            }
        }
    }
},
{
    "kretprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id. Returns logical package id or -1 if not found.",
        "proto" :"int (*topology_phys_to_logical_pkg)(unsigned int phys_pkg)",
        "pre": {
            "phys_pkg": ">=0"
        },
        "post": {
            "return": ">=-1"
        }
    }
},
{
    "kprobe:topology_phys_to_logical_pkg": {
        "description": "Map a physical package id to a logical package id. Returns logical package id or -1 if not found.",
        "proto" :"int (*topology_phys_to_logical_pkg)(unsigned int phys_pkg)",
        "pre": {
            "phys_pkg": ">=0"
        },
    }
},


{
    "kretprobe:native_io_delay": {
        "description": "native_io_delay to be a constant.",
        "proto" :"void (*native_io_delay)(void)",
        "pre": {}
    }
},
{
    "kprobe:native_io_delay": {
        "description": "native_io_delay to be a constant.",
        "proto" :"void native_io_delay(void)",
        "pre": {}
    }
},
{
    "kretprobe:IO_APIC_get_PCI_irq_vector": {
        "description": "Your function description here",
        "proto" :"int IO_APIC_get_PCI_irq_vector(int bus, int slot, int pin)",
        "pre": {
            "bus": "Your condition here",
            "slot": "Your condition here",
            "pin": "Your condition here"
        },
    }
},
{
    "kprobe:IO_APIC_get_PCI_irq_vector": {
        "description": "Description of the function",
        "proto" :"int IO_APIC_get_PCI_irq_vector(int bus, int slot, int pin)",
        "pre": {
            "bus": "constraint",
            "slot": "constraint",
            "pin": "constraint"
        },
    }
},
{
    "kretprobe:uv_undefined": {
        "description": "Cause a machine fault if the undefined MMR error occurs.",
        "proto" :"unsigned long uv_undefined(char *str)",
        "pre": {
            "str": "!=null"
        },
        "post": {
            "return": "in [0, ~0ul]"
        }
    }
},
{
    "kprobe:uv_undefined": {
        "description": "Cause a machine fault if the undefined MMR error occurs.",
        "proto" :"unsigned long uv_undefined(char str)",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:native_write_cr0": {
        "description": "Writes the value of *val* to the CR0 register. If the WP bit is missing, it sets the missing bits and warns.",
        "proto" :"static void (*native_write_cr0)(unsigned long val)",
        "pre": {
            "val": "is a valid unsigned long value"
        },
    }
},
{
    "kprobe:native_write_cr0": {
        "description": "Writes a value to the CR0 register. If the WP bit is missing, it sets the missing bits and warns.",
        "proto" :"void native_write_cr0(unsigned long val)",
        "pre": {
            "val": "is an unsigned long"
        },
    }
},
{
    "kretprobe:reserve_perfctr_nmi": {
        "description": "Reserve a performance counter for non-maskable interrupts (NMI).",
        "proto" :"unsigned int reserve_perfctr_nmi(unsigned int msr)",
        "pre": {
            "msr": "!=null",
            "counter": "in [0, NMI_MAX_COUNTER_BITS]",
            "perfctr_nmi_owner": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:reserve_perfctr_nmi": {
        "description": "Reserves a performance counter for non-maskable interrupts (NMI).",
        "proto" :"unsigned int (*reserve_perfctr_nmi)(unsigned int msr)",
        "pre": {
            "msr": ">=0",
            "counter": ">=0 && <=NMI_MAX_COUNTER_BITS",
        },
    }
},
{
    "kretprobe:release_perfctr_nmi": {
        "description": "Release the NMI performance counter",
        "proto" :"static void (*release_perfctr_nmi)(unsigned int msr)",
        "pre": {
            "msr": ">=0"
        }
    }
},
{
    "kprobe:release_perfctr_nmi": {
        "description": "Release the NMI performance counter.",
        "proto" :"static void (*release_perfctr_nmi)(unsigned int msr)",
        "pre": {
            "msr": ">=0",
        },
    }
},
{
    "kretprobe:reserve_evntsel_nmi": {
        "description": "Register not managed by the allocator?",
        "proto" :"unsigned int reserve_evntsel_nmi(unsigned int msr)",
        "pre": {
            "msr": "!=null",
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:reserve_evntsel_nmi": {
        "description": "Reserves an event select register (evntsel) for non-maskable interrupts (NMI).",
        "proto" :"unsigned int (*reserve_evntsel_nmi)(unsigned int msr)",
        "pre": {
            "msr": ">=0",
            "counter": "in [0, NMI_MAX_COUNTER_BITS]",
            "evntsel_nmi_owner": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:release_evntsel_nmi": {
        "description": "Your function description here",
        "proto" :"static long (*release_evntsel_nmi)(unsigned int msr)",
        "pre": {
            "msr": "Your condition here"
        }
    }
},
{
    "kprobe:release_evntsel_nmi": {
        "description": "Release the event select non-maskable interrupt (NMI) associated with a specific model-specific register (MSR).",
        "proto" :"static void (*release_evntsel_nmi)(unsigned int msr)",
        "pre": {
            "msr": ">=0",
        },
    }
},
{
    "kretprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids. Return the entry if the current CPU matches the entries in the passed x86_cpu_id match table. Otherwise NULL.",
        "proto" :"const struct x86_cpu_id *(*x86_match_cpu)(const struct x86_cpu_id *match)",
        "pre": {
            "match": "!=null"
        },
        "post": {
            "return": "in [valid x86_cpu_id pointer, null]"
        }
    }
},
{
    "kprobe:x86_match_cpu": {
        "description": "Match current CPU against an array of x86_cpu_ids. Return the entry if the current CPU matches the entries in the passed x86_cpu_id match table. Otherwise NULL.",
        "proto" :"const struct x86_cpu_id *(*x86_match_cpu)(const struct x86_cpu_id *match)",
        "pre": {
            "match": "!=null"
        },
    }
},
{
    "kretprobe:MTRR_TO_PHYS_WC_OFFSET": {
        "description": "arch_phys_wc_add returns an MTRR register index plus this offset.",
        "proto" :"#define MTRR_TO_PHYS_WC_OFFSET 1000u32 num_var_ranges;unsigned int mtrr_usage_table[MTRR_MAX_VAR_RANGES];DEFINE_MUTEX(mtrr_mutex);const struct mtrr_ops *mtrr_if;/*  Returns non-zero if we have the write-combining memory type  */",
        "pre": {
            "num_var_ranges": "your_condition_here",
            "mtrr_usage_table": "your_condition_here",
            "mtrr_mutex": "your_condition_here",
            "mtrr_if": "your_condition_here"
        },
    }
},
{
    "kprobe:MTRR_TO_PHYS_WC_OFFSET": {
        "description": "arch_phys_wc_add returns an MTRR register index plus this offset.",
        "proto" :"#define MTRR_TO_PHYS_WC_OFFSET 1000u32 num_var_ranges;unsigned int mtrr_usage_table[MTRR_MAX_VAR_RANGES];DEFINE_MUTEX(mtrr_mutex);const struct mtrr_ops *mtrr_if;/*  Returns non-zero if we have the write-combining memory type  `",
        "pre": {
            "num_var_ranges": "your_condition_here",
            "mtrr_usage_table": "your_condition_here",
            "mtrr_mutex": "your_condition_here",
            "mtrr_if": "your_condition_here"
        },
    }
},
{
    "kretprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add. This cleans up after mtrr_add_wc_if_needed. The API guarantees that mtrr_del_wc_if_needed(error code) and mtrr_del_wc_if_needed(0) do nothing.",
        "proto" :"void (*arch_phys_wc_del)(int handle)",
        "pre": {
            "handle": "is int"
        }
    }
},
{
    "kprobe:arch_phys_wc_del": {
        "description": "Undoes arch_phys_wc_add. This cleans up after mtrr_add_wc_if_needed. The API guarantees that mtrr_del_wc_if_needed(error code) and mtrr_del_wc_if_needed(0) do nothing.",
        "proto" :"void (*arch_phys_wc_del)(int handle)",
        "pre": {
            "handle": "is an integer"
        }
    }
},
{
    "kretprobe:irq_fpu_usable": {
        "description": "In kernel FPU usage already active?",
        "proto" :"irq_fpu_usable(void){if (WARN_ON_ONCE(in_nmi()))return false;}",
        "pre": {
            // Fill in the specific conditions here
        },
    }
},
{
    "kprobe:irq_fpu_usable": {
        "description": "In kernel FPU usage already active?",
        "proto" :"irq_fpu_usable(void){if (WARN_ON_ONCE(in_nmi()))return false;}",
        "pre": {
            "in_nmi": "==false",
            "in_kernel_fpu": "==false"
        },
    }
},
{
    "kretprobe:acpi_processor_power_init_bm_check": {
        "description": "Initializes the bus master (bm) check in the ACPI processor flags. If the number of online CPUs is 1, bm_check is set to 1. Otherwise, if the CPU vendor is Intel, bm_check remains 0 as all MP CPUs that support C3 share cache and caches should not be flushed by software while entering C3 type state.",
        "proto" :"void acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags, unsigned int cpu)",
        "pre": {
            "flags": "!=null",
            "cpu": "is a valid CPU identifier"
        },
        "post": {
            "flags->bm_check": "in [0, 1]"
        }
    }
},
{
    "kprobe:acpi_processor_power_init_bm_check": {
        "description": "Today all MP CPUs that support C3 share cache. And caches should not be flushed by software while entering C3 type state.",
        "proto" :"acpi_processor_power_init_bm_check(struct acpi_processor_flags  flags,unsigned int cpu)",
        "pre": {
            "flags": "!=null",
            "cpu": "is a valid cpu identifier",
        },
    }
},
{
    "kretprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy. It is based on demo code originally Copyright 2001 by Intel Corp, taken from http:www.embedded.comshowArticle.jhtml?articleID=19205567. Attempts were made, unsuccessfully, to contact the original author of this code (Michael Morrow, Intel). Below is the original copyright notice. This software has been developed by Intel Corporation. Intel specifically disclaims all warranties, express or implied, and all liability, including consequential and other indirect damages, for the use of this program, including liability for infringement of any proprietary rights, and including the warranties of merchantability and fitness for a particular purpose. Intel does not assume any responsibility for and errors which may appear in this program not any responsibility to update it.",
        "proto" :"void *memcpy(void *v_dst, const void *v_src, __kernel_size_t c)",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0"
        }
    }
},
{
    "kprobe:memcpy": {
        "description": "This is generic C code to do efficient, alignment-aware memcpy.",
        "proto" :"void *memcpy(void *v_dst, const void *v_src, __kernel_size_t c)",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0",
        },
    }
},
{
    "kretprobe:memmove": {
        "description": "Copies *c* bytes from the object pointed to by *v_src* to the object pointed to by *v_dst*. This operation is performed as if the *c* bytes from the object pointed to by *v_src* are first copied into a temporary array of *c* bytes that does not overlap the objects pointed to by *v_dst* and *v_src*, and then the *c* bytes from the temporary array are copied into the object pointed to by *v_dst*.",
        "proto" :"void *memmove(void *v_dst, const void *v_src, __kernel_size_t c)",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0"
        },
    }
},
{
    "kprobe:memmove": {
        "description": "Copies n bytes from memory area src to memory area dest. Overlapping memory areas are handled correctly.",
        "proto" :"void *memmove(void *v_dst, const void *v_src, __kernel_size_t c)",
        "pre": {
            "v_dst": "!=null",
            "v_src": "!=null",
            "c": ">=0",
        },
    }
},
{
    "kretprobe:memset": {
        "description": "Sets the first *n* bytes of the block of memory pointed by *v_src* to the specified value *c*.",
        "proto" :"void *(*memset)(void *v_src, int c, __kernel_size_t n)",
        "pre": {
            "v_src": "!=null",
            "c": "is int",
            "n": "is __kernel_size_t"
        },
    }
},
{
    "kprobe:memset": {
        "description": "Sets the first n bytes of the block of memory pointed by v_src to the specified value c.",
        "proto" :"void *memset(void *v_src, int c, __kernel_size_t n)",
        "pre": {
            "v_src": "!=null",
            "c": "is integer",
            "n": ">=0",
        },
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "If we have a mapping but the page is not mapped to user-space yet, we simply mark this page dirty and defer flushing the caches until update_mmu().",
        "proto" :"static void (*flush_dcache_page)(struct page *page)",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "mapping_mapped(mapping)": "==false"
        },
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "If we have a mapping but the page is not mapped to user-space yet, we simply mark this page dirty and defer flushing the caches until update_mmu().",
        "proto" :"static void (*flush_dcache_page)(struct page *page)",
        "pre": {
            "page": "!=null",
            "mapping": "!=null",
            "mapping_mapped(mapping)": "==false"
        }
    }
},
{
    "kretprobe:local_flush_cache_page": {
        "description": "Note that we have to use the 'alias' address to avoid multi-hit",
        "proto" :"void local_flush_cache_page(struct vm_area_struct *vma, unsigned long address, unsigned long pfn)",
        "pre": {
            "vma": "!=null",
            "address": "is valid address",
            "pfn": "is valid page frame number"
        }
    }
},
{
    "kprobe:local_flush_cache_page": {
        "description": "Note that we have to use the 'alias' address to avoid multi-hit",
        "proto" :"void local_flush_cache_page(struct vm_area_struct *vma, unsigned long address, unsigned long pfn)",
        "pre": {
            "vma": "!=null",
            "address": "is valid address",
            "pfn": "is valid pfn",
        },
    }
},
{
    "kretprobe:ccount_freq": {
        "description": "Description of the function",
        "proto" :"static long (*ccount_freq)(void *param1, __u64 param2)",
        "pre": {
            "param1": "!=null",
            "param2": "in [range]",
        },
    }
},


{
    "kprobe:xtensa_backtrace_user": {
        "description": "This function looks through the register window for the previous PCs in the call trace and on the stack.",
        "proto" :"xtensa_backtrace_user(struct pt_regs  regs, unsigned int depth,   int ( ufn)(struct stackframe  frame, void  data),   void  data)",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "ufn": "!=null",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:xtensa_backtrace_kernel": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "proto" :"xtensa_backtrace_kernel(struct pt_regs  regs, unsigned int depth, int ( kfn)(struct stackframe  frame, void  data), int ( ufn)(struct stackframe  frame, void  data), void  data)",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "can be null or not null"
        }
    }
},
{
    "kprobe:spill_registers": {
        "description": "Read the stack frames one by one and create the PC from the a0 and a1 registers saved there.",
        "proto" :"void (*spill_registers)()",
        "pre": {
            "regs": "!=null",
            "depth": ">=0",
            "kfn": "!=null",
            "ufn": "!=null",
            "data": "!=null",
            "pc": ">=0",
            "sp_start": ">=0",
            "sp_end": ">=0",
            "a0": ">=0",
            "a1": ">=0"
        },
    }
},
{
    "kretprobe:return_address": {
        "description": "Returns the return address from the caller of this function, not from this function itself.",
        "proto" :"unsigned long (*return_address)(unsigned level)",
        "pre": {
            "level": ">=0"
        },
    }
},
{
    "kprobe:return_address": {
        "description": "Returns the return address from the caller of this function, not from this function itself.",
        "proto" :"unsigned long (*return_address)(unsigned level)",
        "pre": {
            "level": ">=0"
        }
    }
},
{
    "kretprobe:memcpy": {
        "description": "Copy *count* bytes from *src* to *dest*.",
        "proto" :"void *(*memcpy)(void *dest, const void *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kprobe:memcpy": {
        "description": "Copy 'count' bytes from 'src' to 'dest'.",
        "proto" :"void memcpy(void *dest, const void *src, size_t count)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kretprobe:memset": {
        "description": "Sets the first 'count' bytes of the block of memory pointed by 's' to the specified value 'c'.",
        "proto" :"void *(*memset)(void *s, int c, size_t count)",
        "pre": {
            "s": "!=null",
            "c": "is int",
            "count": ">= MIN_THRESHOLD"
        },
    }
},
{
    "kprobe:memset": {
        "description": "Sets the first 'count' bytes of the block of memory pointed by 's' to the specified value 'c'.",
        "proto" :"void *(*memset)(void *s, int c, size_t count)",
        "pre": {
            "s": "!=null",
            "c": "is int",
            "count": ">= MIN_THRESHOLD"
        },
    }
},
{
    "kretprobe:raw_copy_to_user": {
        "description": "Copies data from a user provided buffer to another buffer.",
        "proto" :"static long (*raw_copy_to_user)(void *to, const void *from, unsigned long n)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:raw_copy_to_user": {
        "description": "Copies data from kernel space to user space.",
        "proto" :"static long (*raw_copy_to_user)(void *to, const void *from, unsigned long n)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "n": ">=0",
        },
    }
},
{
    "kretprobe:make_jbsr": {
        "description": "_mcount  nop32  nop32     If the (callee - current_pc) is less then 64MB, we'll use bsr:  pushlr  bsr_mcount  nop32  nop32   else we'll use (movih + ori + jsr):  pushlr  movihr26, ...  orir26, ...  jsrr26     (r26 is our reserved link-reg)",
        "proto" :"static inline void make_jbsr(unsigned long callee, unsigned long pc, uint16_t *call, bool nolr)",
        "pre": {
            "callee": "your_condition_here",
            "pc": "your_condition_here",
            "call": "your_condition_here",
            "nolr": "your_condition_here"
        }
    }
},
{
    "kprobe:make_jbsr": {
        "description": "_mcount  nop32  nop32     If the (callee - current_pc) is less then 64MB, we'll use bsr:  pushlr  bsr_mcount  nop32  nop32   else we'll use (movih + ori + jsr):  pushlr  movihr26, ...  orir26, ...  jsrr26     (r26 is our reserved link-reg)",
        "proto" :"static inline void make_jbsr(unsigned long callee, unsigned long pc, uint16_t *call, bool nolr)",
        "pre": {
            "callee": "your_condition_here",
            "pc": "your_condition_here",
            "call": "your_condition_here",
            "nolr": "your_condition_here"
        },
    }
},
{
    "kretprobe:csum_partial": {
        "description": "Compute the partial checksum of a data buffer *buff* of length *len*, adding in the old sum *sum* and carry.",
        "proto" :"static unsigned long (*csum_partial)(const void *buff, int len, __wsum sum)",
        "pre": {
            "buff": "!=null",
            "len": ">=0",
            "sum": "is __wsum"
        },
    }
},

{
    "kretprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "proto" :"void *(*zero_page_memmap_ptr)(void *map, __u64 flags)",
        "pre": {
            "map": "!=null",
            "flags": "in [range]",
        },
    }
},
{
    "kprobe:EXPORT_SYMBOL(zero_page_memmap_ptr)": {
        "description": "map entry for zero page",
        "proto" :"static long (*EXPORT_SYMBOL(zero_page_memmap_ptr))(void *map)",
        "pre": {
            "map": "!=null"
        }
    }
},
{
    "kretprobe:flush_tlb_range": {
        "description": "This function flushes the Translation Lookaside Buffer (TLB) for a range of addresses within a virtual memory area (vma). It is used when the page table entries have been modified and the changes need to be made visible to the hardware.",
        "proto" :"void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
        "pre": {
            "vma": "!=null",
            "start": "<=end",
            "end": ">=start"
        }
    }
},
{
    "kprobe:flush_tlb_range": {
        "description": "This function is used to flush the Translation Lookaside Buffer (TLB) for a range of addresses within a specific virtual memory area (vma).",
        "proto" :"void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
        "pre": {
            "vma": "!=null",
            "start": "<=end",
            "end": ">=start",
        },
    }
},
{
    "kretprobe:early_ioremap": {
        "description": "Maps the physical address to virtual address with the same attribute as the rest of the kernel. If the attribute is EFI_MEMORY_WB, it returns the virtual address. Otherwise, it returns the uncached address.",
        "proto": "void __iomem  (*early_ioremap)(unsigned long phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:ioremap": {
        "description": "Maps the physical address to virtual address. If the attribute is EFI_MEMORY_WB, it returns the virtual address. Otherwise, it returns the uncached address.",
        "proto": "void __iomem  (*ioremap)(unsigned long phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    },
    "kretprobe:ioremap_uc": {
        "description": "Maps the physical address to uncached address.",
        "proto": "void __iomem  (*ioremap_uc)(unsigned long phys_addr)",
        "pre": {
            "phys_addr": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:early_ioremap": {
        "description": "Maps the physical address to virtual address with appropriate attributes.",
        "proto" :"void __iomem (*early_ioremap)(unsigned long phys_addr, unsigned long size)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
        },
    }
},


{
    "kretprobe:acpi_map_cpu2node": {
        "description": "This function maps a CPU to a node. It is used for systems that don't have a full SRAT table for possible CPUs.",
        "proto" :"static int (*acpi_map_cpu2node)(acpi_handle handle, int cpu, int physid)",
        "pre": {
            "handle": "!=null",
            "cpu": "is a valid CPU identifier",
            "physid": "is a valid physical ID",
        },
    }
},
{
    "kprobe:acpi_map_cpu2node": {
        "description": "Maps a CPU to a node. This is for systems which don't have full SRAT table for possible CPUs.",
        "proto" :"static int (*acpi_map_cpu2node)(acpi_handle handle, int cpu, int physid)",
        "pre": {
            "handle": "!=null",
            "cpu": ">=0",
            "physid": ">=0"
        },
    }
},
{
    "kretprobe:acpi_unmap_cpu": {
        "description": "Unmaps a CPU, sets the corresponding sapicid to -1, and sets the CPU as not present. NUMA specific cleanups are also performed if CONFIG_ACPI_NUMA is defined.",
        "proto" :"static void (*acpi_unmap_cpu)(int cpu)",
        "pre": {
            "cpu": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:acpi_unmap_cpu": {
        "description": "Unmaps a CPU, sets the corresponding sapicid to -1, and sets the CPU as not present. If CONFIG_ACPI_NUMA is defined, performs NUMA specific cleanups.",
        "proto" :"static void (*acpi_unmap_cpu)(int cpu)",
        "pre": {
            "cpu": ">=0"
        }
    }
},
{
    "kretprobe:acpi_register_ioapic": {
        "description": "Register an IOAPIC with ACPI.",
        "proto" :"int acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)",
        "pre": {
            "handle": "!=null",
            "phys_addr": ">=0",
            "gsi_base": ">=0"
        },
    }
},



{
    "kretprobe:ia64_itc_udelay": {
        "description": "Delays execution for a certain number of microseconds. Assumes that the ITC values are synchronized across all CPUs.",
        "proto" :"static void (*ia64_itc_udelay)(unsigned long usecs)",
        "pre": {
            "usecs": ">0"
        }
    }
},
{
    "kprobe:ia64_itc_udelay": {
        "description": "udelay assumes that if preemption is allowed and the thread migrates to another CPU, that the ITC values are synchronized across all CPUs.",
        "proto" :"static void (*ia64_itc_udelay)(unsigned long usecs)",
        "pre": {
            "usecs": ">=0",
        },
    }
},
{
    "kretprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable",
        "proto" :"EXPORT_SYMBOL(arch_register_cpu(int num))",
        "pre": {
            "num": "is an integer"
        },
        "post": {
            "return": "is a boolean"
        }
    }
},
{
    "kprobe:arch_register_cpu": {
        "description": "If CPEI can be re-targeted or if this is not CPEI target, then it is hotpluggable",
        "proto" :"static long (*arch_register_cpu)(int num)",
        "pre": {
            "num": "is an integer"
        }
    }
},






{
    "kretprobe:unw_access_gr": {
        "description": "Accesses the general register of the unw_frame_info structure. If regnum is 0 and write is not set, it always returns 0.",
        "proto" :"static long (*unw_access_gr)(struct unw_frame_info *info, int regnum, unsigned long *val, char *nat, int write)",
        "pre": {
            "info": "!=null",
            "regnum": "in [0, 127]",
            "val": "!=null",
            "nat": "!=null",
            "write": "in [0, 1]"
        },
    }
},
{
    "kprobe:unw_access_gr": {
        "description": "Accesses the general register. If regnum is 0 and write is not set, val is always 0.",
        "proto" :"static long (*unw_access_gr)(struct unw_frame_info *info, int regnum, unsigned long *val, char nat, int write)",
        "pre": {
            "info": "!=null",
            "regnum": "in [0, 127]",
            "val": "!=null",
            "write": "in [0, 1]"
        },
    }
},
{
    "kretprobe:unw_access_br": {
        "description": "Description of the function",
        "proto" :"static long (*unw_access_br)(struct unw_frame_info *info, int regnum, unsigned long *val, int write)",
        "pre": {
            "info": "!=null",
            "regnum": "in [0, 6, 7]",
            "val": "!=null",
            "write": "in [0, 1]"
        },
    }
},
{
    "kprobe:unw_access_br": {
        "description": "Accesses the specified register in the unw_frame_info structure.",
        "proto" :"unw_access_br(struct unw_frame_info *info, int regnum, unsigned long *val, int write)",
        "pre": {
            "info": "!=null",
            "regnum": "in [0, 6, 7]",
            "val": "!=null",
            "write": "in [0, 1]"
        },
    }
},
{
    "kretprobe:unw_unwind": {
        "description": "Unwind the frame information, validate the return IP pointer.",
        "proto" :"unw_unwind (struct unw_frame_info  info)",
        "pre": {
            "info": "!=null",
            "info->ip": "!=null",
            "info->sp": "!=null",
            "info->bsp": "!=null",
            "info->rp_loc": "!=null"
        },
    }
},

{
    "kretprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node. If not enough contiguous uncached pages are available on the requested node, roundrobin starting with the next higher node.",
        "proto" :"unsigned long (*uncached_alloc_page)(int starting_nid, int n_pages)",
        "pre": {
            "starting_nid": "in [-1, INT_MAX]",
            "n_pages": "> 0"
        }
    }
},
{
    "kprobe:uncached_alloc_page": {
        "description": "Allocate the specified number of contiguous uncached pages on the requested node. If not enough contiguous uncached pages are available on the requested node, roundrobin starting with the next higher node.",
        "proto" :"unsigned long (*uncached_alloc_page)(int starting_nid, int n_pages)",
        "pre": {
            "starting_nid": "in [-1, NUMA_NODES-1]",
            "n_pages": "> 0"
        },
    }
},
{
    "kretprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "proto" :"void (*uncached_free_page)(unsigned long uc_addr, int n_pages)",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">0"
        }
    }
},
{
    "kprobe:uncached_free_page": {
        "description": "Free the specified number of uncached pages.",
        "proto" :"void (*uncached_free_page)(unsigned long uc_addr, int n_pages)",
        "pre": {
            "uc_addr": "!=null",
            "n_pages": ">0",
        },
    }
},




{
    "kretprobe:FIXUP_MEMADDR_VGA": {
        "description": "Description of the function",
        "proto" :"static long (*FIXUP_MEMADDR_VGA)(unsigned long addr)",
        "pre": {
            "addr": "Your condition here"
        },
    }
},
{
    "kprobe:FIXUP_MEMADDR_VGA": {
        "description": "Description of the function's behavior",
        "proto" :"static long (*FIXUP_MEMADDR_VGA)(unsigned long addr)",
        "pre": {
            "addr": "Constraints on addr",
        },
    }
},
{
    "kretprobe:marvel_ioread8": {
        "description": "Reads an 8-bit value from the specified I/O port. If the port is a keyboard port, it returns 0. If the port is a RTC port, it performs a RTC I/O operation. If the port is a valid I/O address, it reads an 8-bit value from the address. Otherwise, it catches other legacy addresses that would normally fail on MARVEL, because there really is nothing there...",
        "proto" :"const void __iomem  xaddr",
        "pre": {
            "xaddr": "!=null"
        },
    }
},
{
    "kprobe:marvel_iowrite8": {
        "description": "Writes a byte to the specified I/O address. The behavior depends on the type of the address.",
        "proto" :"void marvel_iowrite8(u8 b, void __iomem *xaddr)",
        "pre": {
            "b": "is a byte",
            "xaddr": "!=null && (is a valid I/O address || is a legacy address)"
        },
    }
},


{
    "kretprobe:irongate_iounmap": {
        "description": "kseg map, nothing to do",
        "proto" :"void irongate_iounmap(volatile void __iomem *xaddr)",
        "pre": {
            "xaddr": "!=null"
        },
        "post": {
            "return": "is void"
        }
    }
},
{
    "kprobe:irongate_iounmap": {
        "description": "Unmaps the given address. If the address is in the kseg map, it does nothing.",
        "proto" :"void irongate_iounmap(volatile void __iomem *xaddr)",
        "pre": {
            "xaddr": "!=null"
        }
    }
},

{
    "kprobe:dump_elf_thread": {
        "description": "Dump the state of an ELF thread. The switch stack follows right below pt_regs.",
        "proto": "void dump_elf_thread(elf_greg_t *dest, struct pt_regs *pt, struct thread_info *ti)",
        "pre": {
            "dest": "!=null",
            "pt": "!=null",
            "ti": "!=null"
        }
    }
},
{
    "kretprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "proto" :"static long (*EXPORT_SYMBOL(smp_num_cpus))()",
        "pre": {
            // Here you should add the preconditions for the function parameters
        },
    }
},
{
    "kprobe:EXPORT_SYMBOL(smp_num_cpus)": {
        "description": "Number that came online.",
        "proto" :"static long (*EXPORT_SYMBOL(smp_num_cpus))()",
        "pre": {},
    }
},
{
    "kretprobe:smp_imb": {
        "description": "Must wait for other processors to flush their icache before continuing.",
        "proto" :"void (*smp_imb)(void)",
        "pre": {},
        "post": {
            "return": "is void"
        }
    }
},
{
    "kprobe:smp_imb": {
        "description": "Must wait other processors to flush their icache before continue.",
        "proto" :"void smp_imb(void)",
        "pre": {},
    }
},
{
    "kretprobe:flush_tlb_range": {
        "description": "On the Alpha we always flush the whole user tlb.",
        "proto" :"void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
        "pre": {
            "vma": "!=null",
            "start": "is an unsigned long value",
            "end": "is an unsigned long value and >= start"
        }
    }
},
{
    "kprobe:flush_tlb_range": {
        "description": "On the Alpha we always flush the whole user tlb.",
        "proto" :"static void (*flush_tlb_range)(struct vm_area_struct *vma, unsigned long start, unsigned long end)",
        "pre": {
            "vma": "!=null",
            "start": "is an unsigned long",
            "end": "is an unsigned long and >= start",
        },
    }
},
{
    "kretprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "proto" :"static void (*memcpy_fromio)(void *to, const volatile void __iomem *from, long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=8",
            "alignment": "((u64)to & 7) == ((u64)from & 7)"
        }
    }
},
{
    "kprobe:memcpy_fromio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "proto" :"static void (*memcpy_fromio)(void *to, const volatile void __iomem *from, long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=8",
            "alignment": "((u64)to & 7) == ((u64)from & 7)"
        },
    }
},
{
    "kretprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "proto" :"static void (*memcpy_toio)(volatile void __iomem *to, const void *from, long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">0",
        },
    }
},
{
    "kprobe:memcpy_toio": {
        "description": "Optimize co-aligned transfers. Everything else gets handled a byte at a time.",
        "proto" :"void (*memcpy_toio)(volatile void __iomem *to, const void *from, long count)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:_memset_c_io": {
        "description": "Handle any initial odd byte",
        "proto" :"static void (*_memset_c_io)(volatile void __iomem  to, unsigned long c, long count)",
        "pre": {
            "to": "!=null",
            "c": ">=0",
            "count": ">0 && ((u64)to & 1)"
        }
    }
},
{
    "kprobe:_memset_c_io": {
        "description": "Handle any initial odd byte",
        "proto" :"static void (*_memset_c_io)(volatile void __iomem *to, unsigned long c, long count)",
        "pre": {
            "to": "!=null",
            "c": ">=0",
            "count": ">0 && ((u64)to & 1)"
        }
    }
},
{
    "kretprobe:scr_memcpyw": {
        "description": "Copies 'count' words from 's' to 'd'. Both 's' and 'd' can be either memory or I/O.",
        "proto" :"static void scr_memcpyw(u16 d, const u16 s, unsigned int count)",
        "pre": {
            "d": "!=null",
            "s": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kprobe:scr_memcpyw": {
        "description": "Copies count words from the source address 's' to the destination address 'd'.",
        "proto" :"static void (*scr_memcpyw)(u16 d, const u16 s, unsigned int count)",
        "pre": {
            "d": "!=null",
            "s": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:readb_relaxed": {
        "description": "Reads a byte from a given memory address. The function must be ordered with respect to other _relaxed functions, but not necessarily with other memory accesses.",
        "proto" :"u8 (*readb_relaxed)(const volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:readb_relaxed": {
        "description": "Reads a byte from a given memory address. The _relaxed functions must be ordered w.r.t. each other, but they don't have to be ordered w.r.t. other memory accesses.",
        "proto" :"u8 (*readb_relaxed)(const volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},

{
    "kprobe:titan_ioremap": {
        "description": "Description of the function goes here",
        "proto" :"titan_ioremap(unsigned long addr, unsigned long size)",
        "pre": {
            "addr": "Condition for addr goes here",
            "size": "Condition for size goes here",
        },
    }
},


{
    "kretprobe:PFN_DOWN": {
        "description": "This function is used to calculate the Page Frame Number (PFN) for a given memory address.",
        "proto" :"static unsigned long (*PFN_DOWN)(unsigned long x)",
        "pre": {
            "x": ">= 0"
        },
    },
    "kretprobe:pfn_valid": {
        "description": "Handles the hole in the memory map.",
        "proto" :"int (*pfn_valid)(unsigned long pfn)",
        "pre": {
            "pfn": ">= 0"
        },
    }
},
{
    "kprobe:PFN_DOWN": {
        "description": "This function is used to calculate the Page Frame Number (PFN) for a given memory address. It is used in the calculation of min_high_pfn and max_high_pfn.",
        "proto" :"static unsigned long (*PFN_DOWN)(unsigned long x)",
        "pre": {
            "x": ">= 0",
        },
    },
    "kprobe:pfn_valid": {
        "description": "This function handles the hole in the memory map. It is used to ensure that the calculated PFNs do not fall into these holes.",
        "proto" :"int (*pfn_valid)(unsigned long pfn)",
        "pre": {
            "pfn": ">= 0",
        },
    }
},
{
    "kretprobe:flush_dcache_page": {
        "description": "Your function description here",
        "proto" :"static void (*flush_dcache_page)(struct page *page, struct address_space *mapping)",
        "pre": {
            "page": "!=null",
            "mapping": "!=null"
        },
    }
},
{
    "kprobe:flush_dcache_page": {
        "description": "Clears the PG_dc_clean bit of the page flags if the cache is not vipt aliasing. Does not handle anonymous pages.",
        "proto" :"static void (*flush_dcache_page)(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},


{
    "kretprobe:flush_icache_range": {
        "description": "Flushes the instruction cache in the range of addresses from *kstart* to *kend*. It can't handle user virtual addresses. It doesn't care if this was kernel virtual or physical address.",
        "proto" :"void (*flush_icache_range)(unsigned long kstart, unsigned long kend)",
        "pre": {
            "kstart": "< TASK_SIZE",
            "kend": ">= kstart"
        },
        "post": {
            "tot_sz": "<= PAGE_SIZE"
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Flushes the instruction cache in the range of addresses from *kstart* to *kend*. It can't handle user virtual addresses. It doesn't care if this was kernel virtual or physical address.",
        "proto" :"static void (*flush_icache_range)(unsigned long kstart, unsigned long kend)",
        "pre": {
            "kstart": "< TASK_SIZE",
            "kend": ">= kstart"
        },
    }
},
{
    "kretprobe:ioremap": {
        "description": "Maps the given physical address to the virtual address space. Don't allow wraparound or zero size.",
        "proto" :"static void* (*ioremap)(phys_addr_t paddr, unsigned long size)",
        "pre": {
            "paddr": ">=0",
            "size": ">0",
            "end": ">=paddr"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap": {
        "description": "Map a physical address to a virtual address in the kernel's virtual address space.",
        "proto" :"static void* (*ioremap)(phys_addr_t paddr, unsigned long size)",
        "pre": {
            "paddr": ">=0",
            "size": ">0",
            "end": ">=paddr"
        },
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "ioremap with access flags. Cache semantics wise it is same as ioremap - 'forced' uncached. However unlike vanilla ioremap which bypasses ARC MMU for addresses in ARC hardware uncached region, this one still goes thru the MMU as caller might need finer access control (RWX)",
        "proto" :"void __iomem *(*ioremap_prot)(phys_addr_t paddr, unsigned long size, unsigned long flags)",
        "pre": {
            "paddr": "!=null",
            "size": ">0",
            "flags": "in [PAGE_KERNEL, PAGE_KERNEL_RO, PAGE_KERNEL_EXEC, PAGE_KERNEL_NOCACHE, PAGE_KERNEL_IO, PAGE_KERNEL_ROX, PAGE_KERNEL_IOX]"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "ioremap with access flags. Cache semantics wise it is same as ioremap - 'forced' uncached. However unlike vanilla ioremap which bypasses ARC MMU for addresses in ARC hardware uncached region, this one still goes thru the MMU as caller might need finer access control (RWX)",
        "proto" :"void __iomem *(*ioremap_prot)(phys_addr_t paddr, unsigned long size, unsigned long flags)",
        "pre": {
            "paddr": "!=null",
            "size": ">0",
            "flags": "in [PAGE_KERNEL]"
        },
    }
},
{
    "kretprobe:iounmap": {
        "description": "Weird double cast to handle phys_addr_t > 32 bits",
        "proto" :"void (*iounmap)(const volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "Weird double cast to handle phys_addr_t > 32 bits",
        "proto" :"void (*iounmap)(const volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:#ifdef CONFIG_ARC_COMPACT_IRQ_LEVELS/* Complex version for 2 IRQ levels": {
        "description": "Enable interrupts with varying behavior depending on the context.",
        "proto" :"static long (*arch_local_irq_enable)(void)",
        "pre": {
            // Fill in the preconditions here
        },
    }
},

{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[condition]",
            "[param2]": "[condition]",
            "[param3]": "[condition]",
            "[param4]": "[condition]",
        },
    }
},

{
    "kretprobe:ioread8_rep": {
        "description": "Reads 8-bit values from the specified I/O memory address to the destination buffer for a specified count.",
        "proto" :"void (*ioread8_rep)(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kprobe:ioread8_rep": {
        "description": "Reads 8-bit values from a given I/O memory address into a destination buffer for a specified count.",
        "proto" :"void ioread8_rep(const void __iomem *addr, void *dst, unsigned long count)",
        "pre": {
            "addr": "!=null",
            "dst": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:ioport_map": {
        "description": "Maps a given port number to an I/O memory region and returns a pointer to that region.",
        "proto" :"void __iomem *(*ioport_map)(unsigned long port, unsigned int nr)",
        "pre": {
            "port": ">=0",
            "nr": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioport_map": {
        "description": "Maps a given port number to an I/O memory region and returns a pointer to that region.",
        "proto" :"void __iomem *(*ioport_map)(unsigned long port, unsigned int nr)",
        "pre": {
            "port": ">=0",
            "nr": ">=0"
        },
    }
},
{
    "kretprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at DST. DST must be at least short aligned. This is used by the IDE driver to read disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the inw() breaks things.",
        "proto" :"void insw (unsigned long port, void *dst, unsigned long count)",
        "pre": {
            "port": "is valid port",
            "dst": "!=null && is short aligned",
            "count": ">=0",
        },
    }
},
{
    "kprobe:insw": {
        "description": "Read COUNT 16-bit words from port PORT into memory starting at DST. DST must be at least short aligned. This is used by the IDE driver to read disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the inw() breaks things.",
        "proto" :"void insw (unsigned long port, void *dst, unsigned long count)",
        "pre": {
            "port": "is a valid port number",
            "dst": "!=null and is at least short aligned",
            "count": "is a non-negative integer",
        },
    }
},

{
    "kprobe:outsw": {
        "description": "Outputs a string of words from the specified buffer src to the port.",
        "proto" :"void outsw(unsigned long port, const void *src, unsigned long count)",
        "pre": {
            "port": "is a valid port number",
            "src": "!=null",
            "count": ">=0",
        },
    }
},

{
    "kprobe:outsl": {
        "description": "Outputs a string of long words to a specified port from memory, starting at 'src'.",
        "proto" :"static void (*outsl)(unsigned long port, const void *src, unsigned long count)",
        "pre": {
            "port": "is valid port number",
            "src": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:outsw": {
        "description": "Like insw but in the opposite direction. This is used by the IDE driver to write disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the outw() breaks things.",
        "proto" :"void outsw (unsigned long port, const void *src, unsigned long count)",
        "pre": {
            "port": ">=0",
            "src": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:outsw": {
        "description": "Like insw but in the opposite direction. This is used by the IDE driver to write disk sectors. Performance is important, but the interfaces seems to be slow: just using the inlined version of the outw() breaks things.",
        "proto" :"void outsw (unsigned long port, const void *src, unsigned long count)",
        "pre": {
            "port": ">=0",
            "src": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:ioremap": {
        "description": "Maps the physical memory into kernel's virtual address space",
        "proto" :"void __iomem *(*ioremap)(phys_addr_t offset, unsigned long size)",
        "pre": {
            "offset": ">=0",
            "size": ">0",
        },
    }
},

{
    "kretprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device @driver: the PA-RISC driver to try",
        "proto" :"int (*register_parisc_driver)(struct parisc_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:register_parisc_driver": {
        "description": "Register this driver if it can handle a device",
        "proto" :"int (*register_parisc_driver)(struct parisc_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "proto" :"int (*unregister_parisc_driver)(struct parisc_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:unregister_parisc_driver": {
        "description": "Unregister this driver from the list of drivers",
        "proto" :"int (*unregister_parisc_driver)(struct parisc_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices. This function fills in the output array with a human-readable path to a PA device. This string is compatible with that used by PDC, and may be printed on the outside of the box.",
        "proto" :"char *(*print_pa_hwpath)(struct parisc_device *dev, char *output)",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pa_hwpath": {
        "description": "Returns hardware path for PA devices. This function fills in the output array with a human-readable path to a PA device. This string is compatible with that used by PDC, and may be printed on the outside of the box.",
        "proto" :"char *(*print_pa_hwpath)(struct parisc_device *dev, char *output)",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device. This function fills in the hardware_path structure with the route to the specified PCI device. This structure is suitable for passing to PDC calls.",
        "proto" :"void (*get_pci_node_path)(struct pci_dev *pdev, struct hardware_path *path)",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:get_pci_node_path": {
        "description": "Determines the hardware path for a PCI device. This function fills in the hardware_path structure with the route to the specified PCI device. This structure is suitable for passing to PDC calls.",
        "proto" :"void (*get_pci_node_path)(struct pci_dev *pdev, struct hardware_path *path)",
        "pre": {
            "pdev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices. This function fills in the output array with a human-readable path to a PCI device. This string is compatible with that used by PDC, and may be printed on the outside of the box.",
        "proto" :"char *(*print_pci_hwpath)(struct pci_dev *dev, char *output)",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kprobe:print_pci_hwpath": {
        "description": "Returns hardware path for PCI devices. This function fills in the output array with a human-readable path to a PCI device. This string is compatible with that used by PDC, and may be printed on the outside of the box.",
        "proto" :"char *(*print_pci_hwpath)(struct pci_dev *dev, char *output)",
        "pre": {
            "dev": "!=null",
            "output": "!=null"
        }
    }
},
{
    "kretprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path. The target device, NULL if not found.",
        "proto" :"struct device *(*hwpath_to_device)(struct hardware_path *modpath)",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:hwpath_to_device": {
        "description": "Finds the generic device corresponding to a given hardware path. Returns the target device, NULL if not found.",
        "proto" :"struct device *(*hwpath_to_device)(struct hardware_path *modpath)",
        "pre": {
            "modpath": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "proto" :"void (*device_to_hwpath)(struct device *dev, struct hardware_path *path)",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},
{
    "kprobe:device_to_hwpath": {
        "description": "Populates the hwpath corresponding to the given device.",
        "proto" :"void (*device_to_hwpath)(struct device *dev, struct hardware_path *path)",
        "pre": {
            "dev": "!=null",
            "path": "!=null"
        }
    }
},


{
    "kretprobe:pdc_iodc_read": {
        "description": "This PDC call reads from the IODC of the module specified by the hpa argument.",
        "proto" :"int (*pdc_iodc_read)(unsigned long *actcnt, unsigned long hpa, unsigned int index,  void *iodc_data, unsigned int iodc_data_size)",
        "pre": {
            "actcnt": "!=null",
            "hpa": ">=0",
            "index": ">=0",
            "iodc_data": "!=null",
            "iodc_data_size": ">0"
        }
    }
},
{
    "kprobe:pdc_iodc_read": {
        "description": "This PDC call reads from the IODC of the module specified by the hpa argument.",
        "proto" :"int (*pdc_iodc_read)(unsigned long *actcnt, unsigned long hpa, unsigned int index,  void *iodc_data, unsigned int iodc_data_size)",
        "pre": {
            "actcnt": "!=null",
            "hpa": ">=0",
            "index": ">=0",
            "iodc_data": "!=null",
            "iodc_data_size": ">0",
        },
    }
},
{
    "kretprobe:pdc_lan_station_id": {
        "description": "Get the LAN station address when it is not directly available from the LAN hardware.",
        "proto" :"int (*pdc_lan_station_id)(char *lan_addr, unsigned long hpa)",
        "pre": {
            "lan_addr": "!=null",
            "hpa": ">=0"
        }
    }
},
{
    "kprobe:pdc_lan_station_id": {
        "description": "Get the LAN address when it is not directly available from the LAN hardware.",
        "proto" :"int (*pdc_lan_station_id)(char *lan_addr, unsigned long hpa)",
        "pre": {
            "lan_addr": "!=null",
            "hpa": ">=0"
        }
    }
},
{
    "kretprobe:pdc_stable_read": {
        "description": "This PDC call reads from the Stable Storage address supplied in staddr and copies count bytes to the memory address memaddr. The call will fail if staddr+count > PDC_STABLE size.",
        "proto" :"int pdc_stable_read(unsigned long staddr, void *memaddr, unsigned long count)",
        "pre": {
            "staddr": ">=0",
            "memaddr": "!=null",
            "count": ">=0 && %4 == 0",
        },
        "post": {
            "return": "<=0 if staddr+count > PDC_STABLE size, otherwise >=0"
        }
    }
},
{
    "kprobe:pdc_stable_read": {
        "description": "Read data from Stable Storage. This PDC call reads from the Stable Storage address supplied in staddr and copies count bytes to the memory address memaddr. The call will fail if staddr+count > PDC_STABLE size.",
        "proto" :"int pdc_stable_read(unsigned long staddr, void *memaddr, unsigned long count)",
        "pre": {
            "staddr": ">=0",
            "memaddr": "!=null",
            "count": ">=0 and is multiple of 4",
            "staddr + count": "<= PDC_STABLE size"
        },
    }
},
{
    "kretprobe:pdc_stable_write": {
        "description": "This PDC call reads count bytes from the supplied memaddr address, and copies count bytes to the Stable Storage address staddr. The call will fail if staddr+count > PDC_STABLE size.",
        "proto" :"int pdc_stable_write(unsigned long staddr, void *memaddr, unsigned long count)",
        "pre": {
            "staddr": ">=0",
            "memaddr": "!=null",
            "count": ">=0 && %4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        }
    }
},
{
    "kprobe:pdc_stable_write": {
        "description": "Write data to Stable Storage. This PDC call reads count bytes from the supplied memaddr address, and copies count bytes to the Stable Storage address staddr. The call will fail if staddr+count > PDC_STABLE size.",
        "proto" :"int (*pdc_stable_write)(unsigned long staddr, void *memaddr, unsigned long count)",
        "pre": {
            "staddr": ">=0",
            "memaddr": "!=null",
            "count": ">=0 and %4 == 0",
            "staddr + count": "<= PDC_STABLE size"
        },
    }
},
{
    "kretprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes. @size: pointer where the size will be stored. This PDC call returns the number of bytes in the processor's Stable Storage, which is the number of contiguous bytes implemented in Stable Storage starting from staddr=0. size in an unsigned 64-bit integer which is a multiple of four.",
        "proto" :"int (*pdc_stable_get_size)(unsigned long *size)",
        "pre": {
            "size": "!=null"
        },
    }
},
{
    "kprobe:pdc_stable_get_size": {
        "description": "Get Stable Storage size in bytes. @size: pointer where the size will be stored. This PDC call returns the number of bytes in the processor's Stable Storage, which is the number of contiguous bytes implemented in Stable Storage starting from staddr=0. size in an unsigned 64-bit integer which is a multiple of four.",
        "proto" :"int (*pdc_stable_get_size)(unsigned long *size)",
        "pre": {
            "size": "!=null"
        }
    }
},
{
    "kretprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "proto" :"int (*pdc_stable_verify_contents)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:pdc_stable_verify_contents": {
        "description": "Checks that Stable Storage contents are valid. This PDC call is meant to be used to check the integrity of the current contents of Stable Storage.",
        "proto" :"int (*pdc_stable_verify_contents)(void)",
        "pre": {}
    }
},
{
    "kretprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator. This PDC call will erase all contents of Stable Storage. Use with care!",
        "proto" :"int pdc_stable_initialize(void)",
        "pre": {
        },
    }
},
{
    "kprobe:pdc_stable_initialize": {
        "description": "Sets Stable Storage contents to zero and initialize the validity indicator. This PDC call will erase all contents of Stable Storage. Use with care!",
        "proto" :"int (*pdc_stable_initialize)(void)",
        "pre": {}
    }
},
{
    "kretprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD). Needed since HPUX never used BIOS or symbios card NVRAM. Most ncrsym cards won't have an entry and just use whatever capabilities of the card are (eg Ultra, LVD). But there are several cases where it's useful: o set SCSI id for Multi-initiator clusters, o cable too long (ie SE scsi 10Mhz won't support 6m length), o bus width exported is less than what the interface chip supports.",
        "proto" :"int (*pdc_get_initiator)(struct hardware_path *hwpath, struct pdc_initiator *initiator)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        }
    }
},
{
    "kprobe:pdc_get_initiator": {
        "description": "Get the SCSI Interface Card params (SCSI ID, SDTR, SE or LVD). Needed since HPUX never used BIOS or symbios card NVRAM. Most ncrsym cards won't have an entry and just use whatever capabilities of the card are (eg Ultra, LVD). But there are several cases where it's useful: o set SCSI id for Multi-initiator clusters, o cable too long (ie SE scsi 10Mhz won't support 6m length), o bus width exported is less than what the interface chip supports.",
        "proto" :"int (*pdc_get_initiator)(struct hardware_path *hwpath, struct pdc_initiator *initiator)",
        "pre": {
            "hwpath": "!=null",
            "initiator": "!=null"
        },
    }
},
{
    "kretprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "proto" :"int (*pdc_tod_read)(struct pdc_tod *tod)",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kprobe:pdc_tod_read": {
        "description": "Read the Time-Of-Day clock.",
        "proto" :"int (*pdc_tod_read)(struct pdc_tod *tod)",
        "pre": {
            "tod": "!=null"
        }
    }
},
{
    "kretprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock. @sec: The number of seconds since epoch. @usec: The number of micro seconds. Set the Time-Of-Day clock.",
        "proto" :"int (*pdc_tod_set)(unsigned long sec, unsigned long usec)",
        "pre": {
            "sec": ">=0",
            "usec": ">=0 && <=999999"
        }
    }
},
{
    "kprobe:pdc_tod_set": {
        "description": "Set the Time-Of-Day clock.",
        "proto" :"int (*pdc_tod_set)(unsigned long sec, unsigned long usec)",
        "pre": {
            "sec": ">=0",
            "usec": "in [0, 999999]"
        }
    }
},


{
    "kretprobe:invalidate_kernel_vmap_range": {
        "description": "Ensure DMA is complete",
        "proto" :"static long (*invalidate_kernel_vmap_range)(void *vaddr, int size)",
        "pre": {
            "vaddr": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kprobe:asm_syncdma": {
        "description": "Ensure DMA is complete",
        "proto" :"void asm_syncdma(void *vaddr, int size)",
        "pre": {
            "vaddr": "!=null",
            "size": ">=0",
            "CONFIG_SMP": "in [ENABLED, DISABLED]",
            "arch_irqs_disabled": "in [TRUE, FALSE]",
            "parisc_cache_flush_threshold": "is a positive integer"
        },
    }
},


{
    "kretprobe:fb_is_primary_device": {
        "description": "Checks if the framebuffer driver is the default built-in one. If no built-in graphics card found, allows any fb driver as default.",
        "proto" :"static bool (*fb_is_primary_device)(struct fb_info *info)",
        "pre": {
            "info": "!=null"
        },
        "post": "return == true"
    }
},
{
    "kprobe:fb_is_primary_device": {
        "description": "Checks if the framebuffer device is the primary device. If no built-in graphics card found, allows any framebuffer driver as default.",
        "proto" :"static bool (*fb_is_primary_device)(struct fb_info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:__delay": {
        "description": "Loop 'loops' times. Callers must not assume a specific amount of time passes before this function returns.",
        "proto" :"void __delay(unsigned long loops)",
        "pre": {
            "loops": ">=0"
        }
    }
},
{
    "__delay": {
        "description": "Loop 'loops' times. Callers must not assume a specific amount of time passes before this function returns.",
        "proto" :"void __delay(unsigned long loops)",
        "pre": {
            "loops": "is a positive integer"
        }
    }
},
{
    "kretprobe:arch_spin_trylock_retry": {
        "description": "Try to get the lock if it is free.",
        "proto" :"static int (*arch_spin_trylock_retry)(arch_spinlock_t *lp)",
        "pre": {
            "lp": "!=null"
        },
        "post": {
            "owner": "==0"
        }
    }
},
{
    "kprobe:arch_spin_trylock_retry": {
        "description": "Try to get the lock if it is free.",
        "proto" :"arch_spin_trylock_retry(arch_spinlock_t  lp)",
        "pre": {
            "lp": "!=null",
            "lp->lock": "!=null",
            "owner": "==null",
            "count": ">0"
        },
    }
},

{
    "kprobe:__atomic_add_const": {
        "description": "Decrements the value of rw->cnts by 1. This is used to put the reader into the wait queue.",
        "proto" :"void __atomic_add_const(int value, int *rw->cnts)",
        "pre": {
            "value": "== -1",
            "rw->cnts": "!=null",
        },
    }
},
{
    "kretprobe:arch_write_lock_wait": {
        "description": "Add this CPU to the write waiters",
        "proto" :"arch_write_lock_wait(arch_rwlock_t  rw)",
        "pre": {
            "rw": "!=null",
            // Add other conditions here based on your understanding of the function
        },
    }
},
{
    "kprobe:__atomic_add": {
        "description": "Add this CPU to the write waiters",
        "proto" :"static long (*__atomic_add)(int value, int *ptr)",
        "pre": {
            "value": "0x20000",
            "ptr": "&rw->cnts",
        },
    }
},

{
    "kprobe:find_next_bit_inv": {
        "description": "Find the next bit in a bit array 'addr' of size 'size' starting at bit 'offset'.",
        "proto" :"unsigned long find_next_bit_inv(const unsigned long addr, unsigned long size, unsigned long offset)",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "offset": ">=0 && < size",
        },
    }
},
{
    "kretprobe:strlen": {
        "description": "Find the length of a string @s: The string to be sized returns the length of @s",
        "proto" :"#ifdef __HAVE_ARCH_STRLENsize_t strlen(const char *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:strlen": {
        "description": "Find the length of a string",
        "proto" :"#ifdef __HAVE_ARCH_STRLENsize_t strlen(const char *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:strnlen": {
        "description": "Find the length of a length-limited string. Returns the minimum of the length of @s and @n.",
        "proto" :"size_t strnlen(const char *s, size_t n)",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:strnlen": {
        "description": "Find the length of a length-limited string. Returns the minimum of the length of @s and @n.",
        "proto" :"size_t strnlen(const char *s, size_t n)",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:strcpy": {
        "description": "Copy a %NUL terminated string from @src to @dest. Returns a pointer to @dest.",
        "proto" :"char *(*strcpy)(char *dest, const char *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null && is_string(src) && strlen(src) < sizeof(dest)"
        },
        "post": {
            "return": "== dest"
        }
    }
},
{
    "kprobe:strcpy": {
        "description": "Copy a %NUL terminated string from @src to @dest. Returns a pointer to @dest.",
        "proto" :"#ifdef __HAVE_ARCH_STRCPYchar *strcpy(char *dest, const char *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null && is_string(src) && strlen(src) < sizeof(dest)"
        }
    }
},
{
    "kretprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string from @src to @dest. The maximum number of bytes to copy is @n. The result is not %NUL-terminated if the source exceeds @n bytes.",
        "proto" :"char *(*strncpy)(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:strncpy": {
        "description": "Copy a length-limited, %NUL-terminated string. The result is not %NUL-terminated if the source exceeds @n bytes.",
        "proto" :"char *(*strncpy)(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kretprobe:strcat": {
        "description": "Append one %NUL-terminated string to another. @dest: The string to be appended to. @src: The string to append to it. Returns a pointer to @dest.",
        "proto" :"char *(*strcat)(char *dest, const char *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "return": "== dest"
        }
    }
},
{
    "kprobe:strcat": {
        "description": "Append one %NUL-terminated string to another. @dest: The string to be appended to. @src: The string to append to it. Returns a pointer to @dest.",
        "proto" :"char *(*strcat)(char *dest, const char *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another. @dest: The string to be appended to. @src: The string to append to it. @n: The size of the destination buffer.",
        "proto" :"size_t strlcat(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">0"
        },
    }
},
{
    "kprobe:strlcat": {
        "description": "Append a length-limited, %NUL-terminated string to another",
        "proto" :"size_t (*strlcat)(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": "> 0"
        }
    }
},
{
    "kretprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another. Returns a pointer to @dest. Note that in contrast to strncpy, strncat ensures the result is terminated.",
        "proto" :"char *(*strncat)(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
        "post": {
            "return": "==dest"
        }
    }
},
{
    "kprobe:strncat": {
        "description": "Append a length-limited, %NUL-terminated string to another. Returns a pointer to @dest. Note that in contrast to strncpy, strncat ensures the result is terminated.",
        "proto" :"char *(*strncat)(char *dest, const char *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kretprobe:strcmp": {
        "description": "Compare two strings. Returns 0 if @s1 and @s2 are equal, < 0 if @s1 is less than @s2, > 0 if @s1 is greater than @s2.",
        "proto" :"#ifdef __HAVE_ARCH_STRCMPint strcmp(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
        "post": {
            "return": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:strcmp": {
        "description": "Compare two strings. Returns 0 if @s1 and @s2 are equal, < 0 if @s1 is less than @s2, > 0 if @s1 is greater than @s2",
        "proto" :"int strcmp(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:strstr": {
        "description": "Find the first substring in a %NUL terminated string",
        "proto" :"char *(*strstr)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        },
    }
},
{
    "kprobe:strstr": {
        "description": "Find the first substring in a %NUL terminated string",
        "proto" :"char *(*strstr)(const char *s1, const char *s2)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null"
        }
    }
},
{
    "kretprobe:memchr": {
        "description": "Find a character in an area of memory. Returns the address of the first occurrence of @c, or %NULL if @c is not found.",
        "proto" :"#ifdef __HAVE_ARCH_MEMCHRvoid *memchr(const void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "is integer",
            "n": "is non-negative integer"
        },
    }
},
{
    "kprobe:memchr": {
        "description": "Find a character in an area of memory. Returns the address of the first occurrence of @c, or %NULL if @c is not found.",
        "proto" :"#ifdef __HAVE_ARCH_MEMCHRvoid *memchr(const void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "is an integer",
            "n": "is a non-negative integer"
        }
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare two areas of memory",
        "proto": "#ifdef __HAVE_ARCH_MEMCMPint memcmp(const void *s1, const void *s2, size_t n)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kprobe:memcmp": {
        "description": "Compare two areas of memory",
        "proto" :"#ifdef __HAVE_ARCH_MEMCMPint memcmp(const void *s1, const void *s2, size_t n)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:memscan": {
        "description": "Find a character in an area of memory. @s: The memory area @c: The byte to search for @n: The size of the area. returns the address of the first occurrence of @c, or 1 byte past the area if @c is not found",
        "proto" :"#ifdef __HAVE_ARCH_MEMSCANvoid *memscan(void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "in [0, 255]",
            "n": ">=0"
        }
    }
},
{
    "kprobe:memscan": {
        "description": "Find a character in an area of memory. Returns the address of the first occurrence of @c, or 1 byte past the area if @c is not found.",
        "proto" :"#ifdef __HAVE_ARCH_MEMSCANvoid *memscan(void *s, int c, size_t n)",
        "pre": {
            "s": "!=null",
            "c": "is int",
            "n": "is size_t and >=0",
        },
    }
},
{
    "kretprobe:_copy_from_user_key": {
        "description": "Description of the function",
        "proto" :"static long (*_copy_from_user_key)(void  to, const void __user  from, unsigned long size, unsigned long key)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "size": ">=0",
            "key": ">=0",
        },
    }
},



{
    "kretprobe:hchacha_block_arch": {
        "description": "TODO: implement hchacha_block_arch() in assembly",
        "proto" :"hchacha_block_arch(const u32  state, u32  stream, int nrounds)",
        "pre": {
            "state": "!=null",
            "stream": "!=null",
            "nrounds": ">=0",
        },
    }
},
{
    "kprobe:hchacha_block_generic": {
        "description": "TODO: implement hchacha_block_arch() in assembly",
        "proto" :"hchacha_block_arch(const u32  state, u32  stream, int nrounds)",
        "pre": {
            "state": "constraints for state",
            "stream": "constraints for stream",
            "nrounds": "constraints for nrounds",
        },
    }
},
{
    "kretprobe:chacha_crypt_arch": {
        "description": "s390 chacha20 implementation has 20 rounds hard-coded, it cannot handle a block of data or less, but otherwise it can handle data of arbitrary size.",
        "proto" :"void chacha_crypt_arch(u32 state, u8 dst, const u8 src, unsigned int bytes, int nrounds)",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": "> CHACHA_BLOCK_SIZE",
            "nrounds": "== 20",
            "MACHINE_HAS_VX": "== true"
        },
    }
},
{
    "kprobe:chacha_crypt_arch": {
        "description": "s390 chacha20 implementation has 20 rounds hard-coded, it cannot handle a block of data or less, but otherwise it can handle data of arbitrary size.",
        "proto" :"chacha_crypt_arch(u32 state, u8 dst, const u8 src, unsigned int bytes, int nrounds)",
        "pre": {
            "state": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "bytes": "<= CHACHA_BLOCK_SIZE",
            "nrounds": "== 20",
            "MACHINE_HAS_VX": "== true"
        },
    }
},
{
    "kretprobe:ptep_reset_dat_prot": {
        "description": "PTE is not invalidated by RDP, only _PAGE_PROTECT is cleared. That means it is still valid and active, and must not be changed according to the architecture. But writing a new value that only differs in SW bits is allowed.",
        "proto" :"void ptep_reset_dat_prot(struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t new)",
        "pre": {
            "mm": "!=null",
            "addr": "is valid memory address",
            "ptep": "!=null",
            "new": "is valid pte_t object",
        },
    }
},
{
    "kprobe:ptep_reset_dat_prot": {
        "description": "PTE is not invalidated by RDP, only _PAGE_PROTECT is cleared. That means it is still valid and active, and must not be changed according to the architecture. But writing a new value that only differs in SW bits is allowed.",
        "proto" :"void ptep_reset_dat_prot(struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t new)",
        "pre": {
            "mm": "!=null",
            "addr": "is valid memory address",
            "ptep": "!=null",
            "new": "only differs in SW bits from the value in *ptep"
        },
    }
},
{
    "kretprobe:reset_guest_reference_bit": {
        "description": "If we don't have a PTE table and if there is no huge page mapped, the storage key is 0 and there is nothing for us to do.",
        "proto" :"static long (*reset_guest_reference_bit)(struct mm_struct  mm, unsigned long addr)",
        "pre": {
            "mm": "your_condition_here",
            "addr": "your_condition_here"
        },
    }
},
{
    "kprobe:reset_guest_reference_bit": {
        "description": "If we don't have a PTE table and if there is no huge page mapped, the storage key is 0 and there is nothing for us to do.",
        "proto" :"static long (*reset_guest_reference_bit)(struct mm_struct  mm, unsigned long addr)",
        "pre": {
            "mm": "your_condition_here",
            "addr": "your_condition_here"
        },
    }
},
{
    "kretprobe:cond_set_guest_storage_key": {
        "description": "Drop the pgste lock between getting and setting the key.",
        "proto" :"cond_set_guest_storage_key(struct mm_struct  mm, unsigned long addr, unsigned char key, unsigned char  oldkey, bool nq, bool mr, bool mc)",
        "pre": {
            "mm": "!=null",
            "addr": "is valid memory address",
            "key": "is valid unsigned char",
            "oldkey": "is valid unsigned char",
            "nq": "is boolean",
            "mr": "is boolean",
            "mc": "is boolean"
        }
    }
},

{
    "kretprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit. Returns < 0 in case of error, otherwise the cc to be reported to the guest.",
        "proto" :"int reset_guest_reference_bit(struct mm_struct *mm, unsigned long addr)",
        "pre": {
            "mm": "!=null",
            "addr": "is valid virtual memory address"
        },
    }
},
{
    "kprobe:reset_guest_reference_bit": {
        "description": "Reset a guest reference bit (rrbe), returning the reference and changed bit. Returns < 0 in case of error, otherwise the cc to be reported to the guest.",
        "proto" :"int reset_guest_reference_bit(struct mm_struct *mm, unsigned long addr)",
        "pre": {
            "mm": "!=null",
            "addr": "is valid memory address"
        }
    }
},
{
    "kretprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE. The memory context must have PGSTEs, no check is performed here! The host virtual address of the page whose PGSTE is to be processed. The specific action to perform, see the ESSA_SET_ macros. The PTE will be saved there if the pointer is not NULL. The old PGSTE will be saved there if the pointer is not NULL. Return: 1 if the page is to be added to the CBRL, otherwise 0, or < 0 in case of error. -EINVAL is returned for invalid values of orc, -EFAULT for invalid addresses.",
        "proto" :"int pgste_perform_essa(struct mm_struct *mm, unsigned long hva, int orc, unsigned long *oldpte, unsigned long *oldpgste)",
        "pre": {
            "mm": "!=null",
            "hva": "is valid host virtual address",
            "orc": "in ESSA_SET_ macros",
            "oldpte": "can be null",
            "oldpgste": "can be null"
        },
        "post": {
            "return": "in [1, 0, <0] where 1 means the page is to be added to the CBRL, 0 means otherwise, and <0 means error. -EINVAL is returned for invalid values of orc, -EFAULT for invalid addresses."
        }
    }
},
{
    "kprobe:pgste_perform_essa": {
        "description": "Perform ESSA actions on the PGSTE. @mm: the memory context. It must have PGSTEs, no check is performed here! @hva: the host virtual address of the page whose PGSTE is to be processed @orc: the specific action to perform, see the ESSA_SET_ macros. @oldpte: the PTE will be saved there if the pointer is not NULL. @oldpgste: the old PGSTE will be saved there if the pointer is not NULL. Return: 1 if the page is to be added to the CBRL, otherwise 0, or < 0 in case of error. -EINVAL is returned for invalid values of orc, -EFAULT for invalid addresses.",
        "proto" :"int (*pgste_perform_essa)(struct mm_struct *mm, unsigned long hva, int orc, unsigned long *oldpte, unsigned long *oldpgste)",
        "pre": {
            "mm": "!=null",
            "hva": ">=0",
            "orc": "in [ESSA_SET_ macros]",
            "oldpte": "can be null",
            "oldpgste": "can be null"
        },
    }
},
{
    "kretprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits. @mm: the memory context. It must have PGSTEs, no check is performed here! @hva: the host virtual address of the page whose PGSTE is to be processed @bits: a bitmask representing the bits that will be touched @value: the values of the bits to be written. Only the bits in the mask will be written. Return: 0 on success, < 0 in case of error.",
        "proto" :"int (*set_pgste_bits)(struct mm_struct *mm, unsigned long hva, unsigned long bits, unsigned long value)",
        "pre": {
            "mm": "!=null",
            "hva": ">=0",
            "bits": ">=0",
            "value": ">=0"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:set_pgste_bits": {
        "description": "Set specific PGSTE bits. @mm: the memory context. It must have PGSTEs, no check is performed here! @hva: the host virtual address of the page whose PGSTE is to be processed @bits: a bitmask representing the bits that will be touched @value: the values of the bits to be written. Only the bits in the mask will be written. Return: 0 on success, < 0 in case of error.",
        "proto" :"int (*set_pgste_bits)(struct mm_struct *mm, unsigned long hva, unsigned long bits, unsigned long value)",
        "pre": {
            "mm": "!=null",
            "hva": ">=0",
            "bits": ">=0",
            "value": ">=0"
        }
    }
},
{
    "kretprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address. @mm: the memory context. It must have PGSTEs, no check is performed here! @hva: the host virtual address of the page whose PGSTE is to be processed @pgstep: will be written with the current PGSTE for the given address. Return: 0 on success, < 0 in case of error.",
        "proto" :"int (*get_pgste)(struct mm_struct *mm, unsigned long hva, unsigned long *pgstep)",
        "pre": {
            "mm": "!=null",
            "hva": ">=0",
            "pgstep": "!=null"
        },
    }
},
{
    "kprobe:get_pgste": {
        "description": "Get the current PGSTE for the given address. @mm: the memory context. It must have PGSTEs, no check is performed here! @hva: the host virtual address of the page whose PGSTE is to be processed @pgstep: will be written with the current PGSTE for the given address. Return: 0 on success, < 0 in case of error.",
        "proto" :"int (*get_pgste)(struct mm_struct *mm, unsigned long hva, unsigned long *pgstep)",
        "pre": {
            "mm": "!=null",
            "hva": ">=0",
            "pgstep": "!=null"
        }
    }
},
{
    "kretprobe:__segment_load": {
        "description": "Must return either an error code < 0, or the segment type code >= 0",
        "proto" :"static int __segment_load(char *name, int do_nonshared, unsigned long *addr, unsigned long *end)",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is int",
            "addr": "!=null",
            "end": "!=null"
        },
        "post": {
            "return": "<0 || >=0"
        }
    }
},
{
    "kprobe:__segment_load": {
        "description": "Must return either an error code < 0, or the segment type code >= 0",
        "proto" :"static int __segment_load(char *name, int do_nonshared, unsigned long *addr, unsigned long *end)",
        "pre": {
            "name": "!=null",
            "do_nonshared": "is int",
            "addr": "!=null",
            "end": "!=null"
        },
    }
},
{
    "kretprobe:voidsegment_save": {
        "description": "Save segment content permanently.",
        "proto" :"void (*voidsegment_save)(char *name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:segment_unload": {
        "description": "Unload a segment by its name, release its resources, remove its mapping, delete it from the list, and save the segment content permanently.",
        "proto": "void segment_unload(char name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:segment_warning": {
        "description": "Prints appropriate error message for segment_load() segment_type() return code.",
        "proto": "void segment_warning(int rc, char *seg_name)",
        "pre": {
            "rc": "is integer",
            "seg_name": "!=null"
        }
    }
},
{
    "kprobe:segment_warning": {
        "description": "Description of the function",
        "proto" :"void (*segment_warning)(int rc, char *seg_name)",
        "pre": {
            "rc": "> 0",
            "seg_name": "!=null"
        },
    }
},
{
    "kretprobe:segment_type": {
        "description": "Initialize diag input parameters",
        "proto" :"static long (*segment_type)(struct dcss_segment *seg)",
        "pre": {
            "seg": "!=null"
        },
    }
},
{
    "kprobe:segment_type": {
        "description": "Initialize diag input parameters",
        "proto" :"segment_type(struct dcss_segment *seg)",
        "pre": {
            "seg": "!=null",
        },
    }
},

{
    "kprobe:voidsegment_unload": {
        "description": "Decrease the use count of a DCSS segment and remove it from the address space if nobody is using it any longer.",
        "proto" :"void (*voidsegment_unload)(char *name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:pci_iomap_range_fh": {
        "description": "Detect overrun",
        "proto" :"static void __iomem *(*pci_iomap_range_fh)(struct pci_dev *pdev, int bar, unsigned long offset, unsigned long max)",
        "pre": {
            "pdev": "!=null",
            "bar": "is integer",
            "offset": "is unsigned long",
            "max": "is unsigned long"
        },
    }
},
{
    "kprobe:pci_iomap_range_fh": {
        "description": "Detect overrun",
        "proto" :"static void __iomem *(*pci_iomap_range_fh)(struct pci_dev *pdev, int bar, unsigned long offset, unsigned long max)",
        "pre": {
            "pdev": "!=null",
            "bar": "is valid bar index",
            "offset": "is valid offset",
            "max": "is valid max value",
        },
    }
},


{
    "kretprobe:pci_iounmap_fh": {
        "description": "Detect underrun",
        "proto" :"void pci_iounmap_fh(struct pci_dev *pdev, void __iomem *addr)",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        },
        "post": {
            "zpci_iomap_start[idx].count": ">=0"
        }
    }
},
{
    "kprobe:pci_iounmap_fh": {
        "description": "Detect underrun",
        "proto" :"pci_iounmap_fh(struct pci_dev  pdev, void __iomem  addr)",
        "pre": {
            "pdev": "!=null",
            "addr": "!=null"
        },
    }
},
{
    "kretprobe:stsi": {
        "description": "Store system information. Returns the current configuration level if function code 0 was specified. Otherwise returns 0 on success or a negative value on error.",
        "proto" :"int stsi(void *sysinfo, int fc, int sel1, int sel2)",
        "pre": {
            "sysinfo": "!=null",
            "fc": "is integer",
            "sel1": "is integer",
            "sel2": "is integer"
        },
    }
},
{
    "kprobe:stsi": {
        "description": "Store system information. Returns the current configuration level if function code 0 was specified. Otherwise returns 0 on success or a negative value on error.",
        "proto" :"int stsi(void *sysinfo, int fc, int sel1, int sel2)",
        "pre": {
            "sysinfo": "!=null",
            "fc": "is integer",
            "sel1": "is integer",
            "sel2": "is integer"
        },
    }
},
{
    "kretprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "proto": "int cpu_have_feature(unsigned int num)",
        "pre": {
            "num": ">=0"
        }
    }
},
{
    "kprobe:cpu_have_feature": {
        "description": "Test CPU features on module initialization",
        "proto" :"int (*cpu_have_feature)(unsigned int num)",
        "pre": {
            "num": "in [0, MAX_CPU_FEATURE]"
        }
    }
},
{
    "kretprobe:add_virt_timer": {
        "description": "Add a oneshot virtual CPU timer",
        "proto" :"void (*add_virt_timer)(struct vtimer_list *timer)",
        "pre": {
            "timer": "!=null"
        }
    }
},
{
    "kprobe:add_virt_timer": {
        "description": "add a oneshot virtual CPU timer",
        "proto" :"void (*add_virt_timer)(struct vtimer_list *timer)",
        "pre": {
            "timer": "!=null"
        }
    }
},
{
    "kretprobe:debug_register_mode": {
        "description": "Creates and initializes debug area. Allocates memory for a debug log. Must not be called within an interrupt handler.",
        "proto" :"debug_info_t *(*debug_register_mode)(const char *name, int pages_per_area, int nr_areas, int buf_size, umode_t mode, uid_t uid, gid_t gid)",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">0",
            "nr_areas": ">0",
            "buf_size": ">0",
            "mode": "in [S_IRWXUGO]",
            "uid": "==0",
            "gid": "==0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:debug_register_mode": {
        "description": "Creates and initializes debug area. Allocates memory for a debug log. Must not be called within an interrupt handler.",
        "proto" :"debug_info_t *(*debug_register_mode)(const char *name, int pages_per_area, int nr_areas, int buf_size, umode_t mode, uid_t uid, gid_t gid)",
        "pre": {
            "name": "!=null",
            "pages_per_area": ">0",
            "nr_areas": ">0",
            "buf_size": ">0",
            "mode": "in [S_IRWXUGO]",
            "uid": "==0",
            "gid": "==0"
        },
    }
},
{
    "kretprobe:debug_register": {
        "description": "Create root directory",
        "proto" :"static void (*debug_register)(debug_info_t id)",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:debug_register": {
        "description": "Create root directory",
        "proto" :"static debug_info_t (*debug_register)(debug_info_t id)",
        "pre": {
            "id": "!=null"
        },
    }
},
{
    "kretprobe:debug_unregister": {
        "description": "Give back debug area.",
        "proto": "void (*debug_unregister)(debug_info_t *id)",
        "pre": {
            "id": "!=null"
        },
        "post": {}
    }
},
{
    "kprobe:debug_unregister": {
        "description": "Give back debug area.",
        "proto": "void (*debug_unregister)(debug_info_t *id)",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "proto": "void (*debug_set_level)(debug_info_t *id, int new_level)",
        "pre": {
            "id": "!=null",
            "new_level": ">=0"
        }
    }
},
{
    "kprobe:debug_set_level": {
        "description": "Sets new actual debug level if new_level is valid.",
        "proto": "void (*debug_set_level)(debug_info_t *id, int new_level)",
        "pre": {
            "id": "!=null",
            "new_level": "is integer"
        }
    }
},
{
    "kretprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed. Currently used in case of a kernel oops.",
        "proto" :"static void (*debug_stop_all)(void)",
        "pre": {},
        "post": {}
    }
},
{
    "kprobe:debug_stop_all": {
        "description": "Stops the debug feature if stopping is allowed. Currently used in case of a kernel oops.",
        "proto" :"static void (*debug_stop_all)(void)",
        "pre": {},
    }
},
{
    "kretprobe:debug_event_common": {
        "description": "Write debug entry with given size.",
        "proto": "debug_entry_t *(*debug_event_common)(debug_info_t *id, int level, const void *buf, int len)",
        "pre": {
            "id": "!=null",
            "level": ">=0",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:debug_event_common": {
        "description": "Write debug entry with given size.",
        "proto" :"debug_entry_t *(*debug_event_common)(debug_info_t *id, int level, const void *buf, int len)",
        "pre": {
            "id": "!=null",
            "level": ">=0",
            "buf": "!=null",
            "len": ">0",
        },
    }
},
{
    "kretprobe:debug_exception_common": {
        "description": "Write debug entry with given size and switch to next debug area.",
        "proto" :"debug_entry_t *(*debug_exception_common)(debug_info_t *id, int level, const void *buf, int len)",
        "pre": {
            "id": "!=null",
            "level": ">=0",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:debug_exception_common": {
        "description": "Write debug entry with given size and switch to next debug area.",
        "proto" :"debug_entry_t *(*debug_exception_common)(debug_info_t *id, int level, const void *buf, int len)",
        "pre": {
            "id": "!=null",
            "level": ">0",
            "buf": "!=null",
            "len": ">0 and <= sizeof(buf)"
        }
    }
},
{
    "kretprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs dir entry.",
        "proto": "int (*debug_unregister_view)(debug_info_t *id, struct debug_view *view)",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:debug_unregister_view": {
        "description": "Unregisters debug view and removes debugfs dir entry.",
        "proto" :"int (*debug_unregister_view)(debug_info_t *id, struct debug_view *view)",
        "pre": {
            "id": "!=null",
            "view": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},


{
    "kretprobe:get_phys_clock": {
        "description": "This function gets the physical clock. It reads the clock_sync_word, gets the time of day clock minus the lpar_offset, and checks if the time is in sync.",
        "proto" :"unsigned long get_phys_clock(unsigned long clock)",
        "pre": {
            "clock": "!=null"
        },
        "post": {
            "return": "in [0, -EOPNOTSUPP, -EACCES, -EAGAIN]"
        }
    }
},
{
    "kprobe:get_phys_clock": {
        "description": "Get the physical clock value. Success: time is in sync.",
        "proto" :"unsigned long get_phys_clock(unsigned long clock)",
        "pre": {
            "clock": "is an unsigned long integer"
        }
    }
},
{
    "kretprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd - __cpcmd is unlocked and therefore not SMP-safe",
        "proto" :"int __cpcmd(const char *cmd, char *response, int rlen, int *response_code)",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null"
        }
    }
},
{
    "kprobe:__cpcmd": {
        "description": "__cpcmd has some restrictions over cpcmd - __cpcmd is unlocked and therefore not SMP-safe",
        "proto" :"int __cpcmd(const char *cmd, char *response, int rlen, int *response_code)",
        "pre": {
            "cmd": "!=null",
            "response": "!=null",
            "rlen": ">=0",
            "response_code": "!=null",
        },
    }
},
{
    "kretprobe:__kernel_fpu_begin": {
        "description": "Limit the save to the FPU vector registers already in use by the previous context.",
        "proto" :"static void (*__kernel_fpu_begin)(struct kernel_fpu *state, u32 flags)",
        "pre": {
            "state": "!=null",
            "flags": "in [KERNEL_FPC, ...]" // Please replace ... with other possible flag values
        },
    }
},
{
    "kprobe:__kernel_fpu_begin": {
        "description": "Limit the save to the FPU vector registers already in use by the previous context",
        "proto" :"static void (*__kernel_fpu_begin)(struct kernel_fpu *state, u32 flags)",
        "pre": {
            "state": "!=null",
            "flags": "in [KERNEL_FPC, ...]", // Please replace ... with other possible flag values
        },
    }
},
{
    "__kernel_fpu_end": {
        "description": "Limit the restore to the FPU vector registers of the previous context that have been overwritten by the current context.",
        "proto" :"void __kernel_fpu_end(struct kernel_fpu *state, u32 flags)",
        "pre": {
            "state": "!=null",
            "flags": "in [KERNEL_FPC, ...]" // Please replace ... with other possible flag values
        },
    }
},
{
    "__kernel_fpu_end": {
        "description": "Limit the restore to the FPU vector registers of the previous context that have been overwritten by the current context.",
        "proto" :"void __kernel_fpu_end(struct kernel_fpu *state, u32 flags)",
        "pre": {
            "state": "!=null",
            "flags": "is a valid flag value",
        },
    }
},





{
    "kprobe:_ebc_toupper": {
        "description": "EBCDIC 037500 conversion table from lower to upper case",
        "proto" :"__u8 _ebc_toupper[256] = { ... }",
        "pre": {},
        "post": {
            "_ebc_toupper": "is an array of 256 __u8 elements"
        }
    }
},
{
    "kretprobe:diag14": {
        "description": "Input spool file manipulation",
        "proto" :"int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode)",
        "pre": {
            "rx": "??",
            "ry1": "??",
            "subcode": "??"
        }
    }
},
{
    "kprobe:diag14": {
        "description": "Diagnose 14: Input spool file manipulation",
        "proto" :"int diag14(unsigned long rx, unsigned long ry1, unsigned long subcode)",
        "pre": {
            "rx": "constraint not provided",
            "ry1": "constraint not provided",
            "subcode": "constraint not provided"
        },
    }
},
{
    "kretprobe:__bootdata_preserved": {
        "description": "uv_info contains both host and guest information but it's currently only expected to be used within modules if it's the KVM module or for any PV guest module. The kernel itself will write these values once in uv_query_info() and then make some of them readable via a sysfs interface.",
        "proto" :"struct uv_info __bootdata_preserved(uv_info);EXPORT_SYMBOL(uv_info)",
        "pre": {
            "uv_info": "your_condition_here"
        }
    }
},
{
    "kprobe:__bootdata_preserved": {
        "description": "uv_info contains both host and guest information but it's currently only expected to be used within modules if it's the KVM module or for any PV guest module. The kernel itself will write these values once in uv_query_info() and then make some of them readable via a sysfs interface.",
        "proto" :"struct uv_info __bootdata_preserved(uv_info);EXPORT_SYMBOL(uv_info)",
        "pre": {
            "uv_info": "[constraints on uv_info]",
        },
    }
},
{
    "__ashrdi3": {
        "description": "Performs arithmetic shift right operation on a DItype value.",
        "proto" :"DItype (__ashrdi3)(DItype u, word_type b)",
        "pre": {
            "u": "is DItype",
            "b": "is word_type"
        },
        "post": {
            "return": "is DItype"
        }
    }
},
{
    "__ashrdi3": {
        "description": "Performs arithmetic shift right operation on a double integer type.",
        "proto" :"DItype (*__ashrdi3)(DItype u, word_type b)",
        "pre": {
            "u": "is DItype",
            "b": "is word_type",
        },
    }
},
{
    "kretprobe:csum_partial_copy_from_user": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1",
            "param2": "Your condition for param2",
            "param3": "Your condition for param3",
            // Add more parameters as needed
        },
    }
},
{
    "kprobe:csum_partial_copy_from_user": {
        "description": "Computes a partial checksum, e.g. for TCP/UDP fragments.",
        "proto" :"int csum_partial_copy_from_user(const void *src, void *dst, int len, int sum, int *csum_err)",
        "pre": {
            "src": "!=null",
            "dst": "!=null",
            "len": ">0",
            "sum": "is integer",
            "csum_err": "!=null",
        },
    }
},
{
    "kretprobe:bpf_map_lookup_elem": {
        "description": "Look up an element in *map* by *key*.",
        "proto" :"static void *(*bpf_map_lookup_elem)(void *map, const void *key)",
        "pre": {
            "map": "!=null",
            "key": "!=null"
        },
    }
},

{
    "kretprobe:cache_clear": {
        "description": "Clear any cache entries for the area in question, without writing back dirty entries first. This is useful if the data will be overwritten anyway, e.g. by DMA to memory. The range is defined by a physical address.",
        "proto" :"void (*cache_clear)(unsigned long paddr, int len)",
        "pre": {
            "paddr": ">=0",
            "len": ">0",
        },
    }
},
{
    "kprobe:cache_clear": {
        "description": "Clear any cache entries for the area in question, without writing back dirty entries first. This is useful if the data will be overwritten anyway, e.g. by DMA to memory. The range is defined by a _physical_ address.",
        "proto" :"void (*cache_clear)(unsigned long paddr, int len)",
        "pre": {
            "paddr": ">=0",
            "len": ">0",
        },
    }
},
{
    "kretprobe:cache_push": {
        "description": "Write back any dirty cache data in the given area, and invalidate the range in the instruction cache. It needs not (but may) invalidate those entries also in the data cache. The range is defined by a physical address.",
        "proto" :"void (*cache_push)(unsigned long paddr, int len)",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
        },
    }
},
{
    "kprobe:cache_push": {
        "description": "Write back any dirty cache data in the given area, and invalidate the range in the instruction cache. It needs not (but may) invalidate those entries also in the data cache. The range is defined by a _physical_ address.",
        "proto" :"void (*cache_push)(unsigned long paddr, int len)",
        "pre": {
            "paddr": "!=null",
            "len": ">0",
        },
    }
},


{
    "kretprobe:__ioremap": {
        "description": "Don't allow mappings that wrap.",
        "proto" :"static long (*__ioremap)(unsigned long physaddr, unsigned long size, int cacheflag)",
        "pre": {
            "physaddr": ">= 0",
            "size": "> 0",
            "cacheflag": ">= 0",
        },
    }
},
{
    "kprobe:__ioremap": {
        "description": "Don't allow mappings that wrap.",
        "proto" :"__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)",
        "pre": {
            "physaddr": ">=0",
            "size": ">0",
            "cacheflag": ">=0",
        },
    }
},

{
    "kprobe:bpf_map_delete_elem": {
        "description": "Delete the entry associated to *key* in *map*.",
        "proto" :"static long (*bpf_map_delete_elem)(void *map, const void *key)",
        "pre": {
            "map": "!=null",
            "key": "!=null"
        }
    }
},
{
    "kretprobe:sun3_ioremap": {
        "description": "Maps the physical memory into the kernel's virtual address space.",
        "proto" :"static void* (*sun3_ioremap)(unsigned long phys, unsigned long size, unsigned long type)",
        "pre": {
            "phys": ">=0",
            "size": ">=0",
            "type": "in [VM_IOREMAP, VM_ALLOC, VM_MAP, VM_USERMAP, VM_DMA_COHERENT]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sun3_ioremap": {
        "description": "Maps the physical memory into the kernel's virtual address space.",
        "proto" :"static void *(*sun3_ioremap)(unsigned long phys, unsigned long size, unsigned long type)",
        "pre": {
            "phys": ">=0",
            "size": ">=0",
            "type": "in [VM_IOREMAP, VM_ALLOC, VM_MAP, VM_USERMAP, VM_DMA_COHERENT]"
        },
    }
},
{
    "kretprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success. This function is primarily used to check addresses on the VME bus.",
        "proto" :"int (*sun3_map_test)(unsigned long addr, char *val)",
        "pre": {
            "addr": ">=0",
            "val": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:sun3_map_test": {
        "description": "Reads a byte from addr, storing to val, trapping the potential read fault. Returns 0 if the access faulted, 1 on success. This function is primarily used to check addresses on the VME bus.",
        "proto" :"int (*sun3_map_test)(unsigned long addr, char *val)",
        "pre": {
            "addr": ">=0",
            "val": "!=null"
        },
    }
},
{
    "kretprobe:hwreg_write": {
        "description": "Your function description here",
        "proto" :"volatile void  regp, unsigned short val",
        "pre": {
            "regp": "Your condition here",
            "val": "Your condition here"
        },
    }
},


{
    "kprobe:EXPORT_SYMBOL(amiga_audio_min_period)": {
        "description": "Default for pre-OCS",
        "proto" :"static long (*amiga_audio_min_period)(int period)",
        "pre": {
            "period": ">=124",
        },
    }
},
{
    "kretprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'. Returns !0 if lock was acquired; otherwise 0.",
        "proto" :"int (*stdma_try_lock)(irq_handler_t handler, void *data)",
        "pre": {
            "handler": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "in [0, !0]"
        }
    }
},
{
    "kprobe:stdma_try_lock": {
        "description": "Attempt to acquire ST DMA interrupt 'lock'. Returns !0 if lock was acquired; otherwise 0.",
        "proto" :"int (*stdma_try_lock)(irq_handler_t handler, void *data)",
        "pre": {
            "handler": "!=null",
            "data": "can be null or !=null"
        },
    }
},




{
    "kretprobe:stdma_is_locked_by": {
        "description": "Allow lock holder to check whether it needs to release. Returns !0 if locked for the given handler; 0 otherwise.",
        "proto" :"int (*stdma_is_locked_by)(irq_handler_t handler)",
        "pre": {
            "handler": "!=null"
        },
        "post": {
            "return": "in [0, !0]"
        }
    }
},
{
    "kprobe:stdma_is_locked_by": {
        "description": "Allow lock holder to check whether it needs to release. Returns !0 if locked for the given handler; 0 otherwise.",
        "proto" :"int (*stdma_is_locked_by)(irq_handler_t handler)",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kretprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked. Returned status is only valid if ints are disabled while calling and as long as they remain disabled. If called with ints enabled, status can change only from locked to unlocked, because ints may not lock the ST-DMA.",
        "proto" :"int (*stdma_islocked)(void)",
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:stdma_islocked": {
        "description": "Check if the ST-DMA is currently locked. Returned status is only valid if ints are disabled while calling and as long as they remain disabled. If called with ints enabled, status can change only from locked to unlocked, because ints may not lock the ST-DMA.",
        "proto" :"int (*stdma_islocked)(void)",
        "pre": {},
        "post": {
            "return": "in [0, 1]"
        }
    }
},




{
    "kretprobe:atari_input_mouse_interrupt_hook": {
        "description": "Hook for mouse inputdev driver",
        "proto" :"void (*atari_input_mouse_interrupt_hook) (char *)",
        "pre": {
            "char": "!=null"
        }
    }
},
{
    "kprobe:atari_input_mouse_interrupt_hook": {
        "description": "Hook for mouse inputdev driver",
        "proto" :"void (*atari_input_mouse_interrupt_hook) (char *)",
        "pre": {
            "char": "!=null"
        },
    },
    "kprobe:atari_input_keyboard_interrupt_hook": {
        "description": "Hook for keyboard inputdev driver",
        "proto" :"void (*atari_input_keyboard_interrupt_hook) (unsigned char, char)",
        "pre": {
            "unsigned char": "!=null",
            "char": "!=null"
        },
    }
},
{
    "kretprobe:atari_stram_alloc": {
        "description": "Allocate a certain size of memory in Atari ST RAM. The size is rounded up to the nearest page size.",
        "proto" :"unsigned long (*atari_stram_alloc)(unsigned long size, const char *owner)",
        "pre": {
            "size": ">0",
            "owner": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:atari_stram_alloc": {
        "description": "Allocate a specific size of memory in Atari ST RAM. The size is rounded up to the nearest page size.",
        "proto" :"unsigned long (*atari_stram_alloc)(unsigned long size, const char *owner)",
        "pre": {
            "size": ">0",
            "owner": "!=null"
        },
    }
},



{
    "kprobe:bpf_map_delete_elem": {
        "description": "Delete the entry associated to *key* in *map*.",
        "proto" :"static long (*bpf_map_delete_elem)(void *map, const void *key)",
        "pre": {
            "map": "!=null",
            "key": "!=null"
        },
    }
},
{
    "kretprobe:__mcfgpio_direction_output": {
        "description": "Set the direction of the specified GPIO to output and set its value.",
        "proto" :"static void (*__mcfgpio_direction_output)(unsigned gpio, int value)",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START",
            "value": "any integer"
        },
    }
},
{
    "__mcfgpio_direction_output": {
        "description": "Set the direction of the specified GPIO to output and set its value.",
        "proto" :"void __mcfgpio_direction_output(unsigned gpio, int value)",
        "pre": {
            "gpio": "< MCFGPIO_SCR_START",
            "value": "in [0, 1]"
        },
    }
},




{
    "kretprobe:queued_spin_lock_slowpath": {
        "description": "This looks funny, but it induces the compiler to inline both sides of the branch rather than share code as when the condition is passed as the paravirt argument to the functions.",
        "proto" :"static bool (*queued_spin_lock_slowpath)(struct qspinlock *lock)",
        "pre": {
            "lock": "!=null",
        },
    }
},
{
    "kprobe:queued_spin_lock_slowpath": {
        "description": "This looks funny, but it induces the compiler to inline both sides of the branch rather than share code as when the condition is passed as the paravirt argument to the functions.",
        "proto" :"static void (*queued_spin_lock_slowpath)(struct qspinlock *lock)",
        "pre": {
            "lock": "!=null",
        },
    }
},
{
    "kretprobe:crash_shutdown_register": {
        "description": "Insert handle at first empty entry",
        "proto" :"static long (*crash_shutdown_register)(crash_shutdown_t handler)",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kprobe:crash_shutdown_register": {
        "description": "Insert handle at first empty entry",
        "proto" :"static int (*crash_shutdown_register)(crash_shutdown_t handler)",
        "pre": {
            "handler": "!=null",
        },
    }
},
{
    "kretprobe:crash_shutdown_unregister": {
        "description": "Unregister a crash shutdown handler. If the handler is not found, print an error message and return 1. Otherwise, shift the handles down.",
        "proto" :"static unsigned int (*crash_shutdown_unregister)(crash_shutdown_t handler)",
        "pre": {
            "handler": "!=null"
        },
        "post": {
            "rc": "in [0, 1]"
        }
    }
},
{
    "kprobe:crash_shutdown_unregister": {
        "description": "Unregister a crash shutdown handler.",
        "proto" :"static long (*crash_shutdown_unregister)(crash_shutdown_t handler)",
        "pre": {
            "handler": "!=null && is_valid_crash_handler"
        },
    }
},
{
    "kretprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "proto" :"void (*flush_icache_range)(unsigned long start, unsigned long stop)",
        "pre": {
            "start": ">=0",
            "stop": ">start"
        }
    }
},
{
    "kprobe:flush_icache_range": {
        "description": "Write any modified data cache blocks out to memory and invalidate the corresponding blocks in the instruction cache. Generic code will call this after writing memory, before executing from it.",
        "proto" :"void (*flush_icache_range)(unsigned long start, unsigned long stop)",
        "pre": {
            "start": "!=null",
            "stop": "!=null && > start"
        },
    }
},
{
    "kretprobe:clear_user_page": {
        "description": "Clears a page in memory. This is required by some versions of glibc (ld.so assumes zero filled pages are icache clean) - Anton",
        "proto" :"void clear_user_page(void *page, unsigned long vaddr, struct page *pg)",
        "pre": {
            "page": "!=null",
            "vaddr": "is valid virtual address",
            "pg": "!=null"
        }
    }
},
{
    "kprobe:clear_user_page": {
        "description": "Clears a page in memory. This is required by some versions of glibc (ld.so assumes zero filled pages are icache clean) - Anton",
        "proto" :"static void (*clear_user_page)(void *page, unsigned long vaddr, struct page *pg)",
        "pre": {
            "page": "!=null",
            "vaddr": "is valid virtual address",
            "pg": "!=null"
        }
    }
},
{
    "kretprobe:__node_distance": {
        "description": "Calculate the distance between two nodes based on the affinity form and distance lookup table.",
        "proto" :"int __node_distance(int a, int b)",
        "pre": {
            "a": ">=0",
            "b": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "__node_distance": {
        "description": "Calculate the distance between two nodes based on the affinity form and distance lookup table. Double the distance for each NUMA level.",
        "proto" :"int __node_distance(int a, int b)",
        "pre": {
            "a": "is an integer",
            "b": "is an integer"
        },
    }
},
{
    "kretprobe:of_node_to_nid": {
        "description": "Walk the device tree upwards, looking for an associativity id.",
        "proto" :"int (*of_node_to_nid)(struct device_node *device)",
        "pre": {
            "device": "!=null"
        },
        "post": {
            "return": "in [NUMA_NO_NODE, nid]"
        }
    }
},
{
    "kprobe:of_node_to_nid": {
        "description": "Walk the device tree upwards, looking for an associativity id.",
        "proto" :"int (*of_node_to_nid)(struct device_node *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:iounmap": {
        "description": "If mapped by BATs then there is nothing to do. Calling vfree() generates a benign warning.",
        "proto" :"void iounmap(volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null"
        },
        "post": {
            "return": "==void"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "If mapped by BATs then there is nothing to do. Calling vfree() generates a benign warning.",
        "proto" :"EXPORT_SYMBOL(void iounmap(volatile void __iomem *addr))",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "Maps the physical address *addr* of size *size* with protection flags *flags*. The returned virtual address is writeable if and only if the _PAGE_RW is set in *flags*.",
        "proto" :"static void* (*ioremap_prot)(phys_addr_t addr, unsigned long size, unsigned long flags)",
        "pre": {
            "addr": ">=0",
            "size": ">0",
            "flags": "in [_PAGE_RW, _PAGE_USER, _PAGE_PWT, _PAGE_PCD, _PAGE_ACCESSED, _PAGE_DIRTY, _PAGE_PSE, _PAGE_GLOBAL, _PAGE_NX]"
        },
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Maps a physical address to a kernel virtual address and sets the page table entries for the range to the specified flags. The flags should indicate that a writeable page is also dirty.",
        "proto": "static void *(*ioremap_prot)(phys_addr_t addr, unsigned long size, unsigned long flags)",
        "pre": {
            "addr": ">=0",
            "size": ">0",
            "flags": "in [_PAGE_USER, _PAGE_EXEC, _PAGE_RW, _PAGE_DIRTY]"
        }
    }
},


{
    "kretprobe:vm_get_page_prot": {
        "description": "Radix supports execute-only, but protection_map maps X -> RX",
        "proto" :"unsigned long (*vm_get_page_prot)(unsigned long vm_flags)",
        "pre": {
            "vm_flags": "in [VM_READ, VM_WRITE, VM_EXEC, VM_SHARED, VM_MAYREAD, VM_MAYWRITE, VM_MAYEXEC, VM_MAYSHARE, VM_GROWSDOWN, VM_UFFD_MISSING, VM_UFFD_WP, VM_PFNMAP, VM_DENYWRITE, VM_UFFD_MISSING, VM_LOCKED, VM_IO, VM_SEQ_READ, VM_RAND_READ, VM_DONTCOPY, VM_DONTEXPAND, VM_LOCKONFAULT, VM_ACCOUNT, VM_NORESERVE, VM_HUGETLB, VM_ARCH_1, VM_WIPEONFORK, VM_DONTDUMP, VM_SOFTDIRTY, VM_MIXEDMAP, VM_HUGEPAGE, VM_NOHUGEPAGE, VM_MERGEABLE, VM_UFFD_WP, VM_NONLINEAR, VM_INSERTPAGE, VM_ALWAYSDUMP, VM_HUGETLB, VM_NO_THP, VM_READ, VM_WRITE, VM_EXEC, VM_SHARED]"
        },
        "post": {
            "return": "in [PTE_NONE, PTE_READ, PTE_WRITE, PTE_EXEC, PTE_DIRTY, PTE_SOFTDIRTY, PTE_FILE, PTE_SWAP, PTE_SPECIAL, PTE_WRITE, PTE_PRESENT]"
        }
    }
},
{
    "kprobe:vm_get_page_prot": {
        "description": "Radix supports execute-only, but protection_map maps X -> RX",
        "proto" :"unsigned long (*vm_get_page_prot)(unsigned long vm_flags)",
        "pre": {
            "vm_flags": "in [VM_ACCESS_FLAGS, VM_EXEC, ...]",
        },
        "post": {
            "if": {
                "condition": "(radix_enabled() && ((vm_flags & VM_ACCESS_FLAGS) == VM_EXEC))",
                "true": "return value is in [expected range/values]",
                "false": "return value is in [expected range/values]"
            }
        }
    }
},


{
    "kretprobe:radix__flush_tlb_mm": {
        "description": "Order loads of mm_cpumask (in flush_type_needed) vs previous stores to clear ptes before the invalidate. See barrier in switch_mm_irqs_off",
        "proto" :"void radix__flush_tlb_mm(struct mm_struct *mm)",
        "pre": {
            "mm": "!=null",
            "mm->context.id": "!=MMU_NO_CONTEXT"
        },
        "post": {
            "return": "is void"
        }
    }
},
{
    "kprobe:radix__flush_tlb_mm": {
        "description": "Order loads of mm_cpumask (in flush_type_needed) vs previous stores to clear ptes before the invalidate. See barrier in switch_mm_irqs_off",
        "proto" :"void radix__flush_tlb_mm(struct mm_struct *mm)",
        "pre": {
            "mm": "!=null",
            "mm->context.id": "!=MMU_NO_CONTEXT"
        }
    }
},



{
    "kprobe:radix__flush_tlb_range": {
        "description": "Flushes the TLB range.",
        "proto" :"static void (*radix__flush_tlb_range)(struct mm_struct *mm, unsigned long start, unsigned long end)",
        "pre": {
            "mm": "!=null",
            "start": ">=0",
            "end": ">start",
        },
    }
},

{
    "kprobe:isync();}EXPORT_SYMBOL(switch_mmu_context)": {
        "description": "Switches the memory management unit context from 'prev' to 'next' for the task 'tsk'.",
        "proto" :"switch_mmu_context(struct mm_struct  prev, struct mm_struct  next, struct task_struct  tsk)",
        "pre": {
            "prev": "!=null",
            "next": "!=null && next->context.id >= 0",
            "tsk": "!=null",
            "next->context.sr0": "!=null",
            "next->pgd": "!=null",
            "MMU_FTR_HPTE_TABLE": "is defined"
        },
    }
},
{
    "kretprobe:hash__flush_tlb_mm": {
        "description": "It is safe to iterate the vmas when called from dup_mmap, holding mmap_lock. It would also be safe from unmap_region or exit_mmap, but not from vmtruncate on SMP - but it seems dup_mmap is the only SMP case which gets here.",
        "proto" :"void hash__flush_tlb_mm(struct mm_struct *mm)",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kprobe:hash__flush_tlb_mm": {
        "description": "It is safe to iterate the vmas when called from dup_mmap, holding mmap_lock. It would also be safe from unmap_region or exit_mmap, but not from vmtruncate on SMP - but it seems dup_mmap is the only SMP case which gets here.",
        "proto" :"void hash__flush_tlb_mm(struct mm_struct *mm)",
        "pre": {
            "mm": "!=null"
        }
    }
},
{
    "kretprobe:cpm_setbrg": {
        "description": "This is good enough to get SMCs running.....",
        "proto" :"static long (*cpm_setbrg)(uint brg, uint rate)",
        "pre": {
            "brg": ">=0",
            "rate": ">=0"
        },
    }
},
{
    "kprobe:cpm_setbrg": {
        "description": "This is good enough to get SMCs running.....",
        "proto" :"cpm_setbrg(uint brg, uint rate)",
        "pre": {
            "brg": ">=0",
            "rate": ">=0"
        },
    }
},
{
    "kretprobe:ps3_irq_plug_destroy": {
        "description": "ps3_sb_event_receive_port_setup().",
        "proto" :"int (*ps3_irq_plug_destroy)(unsigned int virq)",
        "pre": {
            "virq": ">=0"
        }
    }
},
{
    "kprobe:ps3_irq_plug_destroy": {
        "description": "ps3_sb_event_receive_port_setup()",
        "proto" :"int (*ps3_irq_plug_destroy)(unsigned int virq)",
        "pre": {
            "virq": ">=0"
        }
    }
},
{
    "kretprobe:ps3_sb_event_receive_port_destroy": {
        "description": "This function should go in system-bus.c",
        "proto" :"int ps3_sb_event_receive_port_destroy(struct ps3_system_bus_device *dev, unsigned int virq)",
        "pre": {
            "dev": "!=null",
            "virq": "!=null",
            // Add more conditions here based on your understanding of the function
        },
    }
},
{
    "kprobe:ps3_sb_event_receive_port_destroy": {
        "description": "This should go in system-bus.c",
        "proto" :"int result;DBG(\" -> %s:%d: interrupt_id %u, virq %u\\n\", __func__, __LINE__,dev->interrupt_id, virq);result = lv1_disconnect_interrupt_event_receive_port(dev->bus_id,dev->dev_id, virq_to_hw(virq), dev->interrupt_id);if (result)FAIL(\"%s:%d: lv1_disconnect_interrupt_event_receive_port\"\" failed: %s\\n\", __func__, __LINE__,ps3_result(result));result = ps3_event_receive_port_destroy(virq);BUG_ON(result);/* * ps3_event_receive_port_destroy() destroys the IRQ plug, * so don't call ps3_irq_plug_destroy() here. `",
        "pre": {
            "dev": "!=null",
            "virq": "is a valid unsigned integer",
            "dev->interrupt_id": "is a valid unsigned integer",
            "dev->bus_id": "is a valid unsigned integer",
            "dev->dev_id": "is a valid unsigned integer",
            "virq_to_hw(virq)": "is a valid function call",
            "ps3_result(result)": "is a valid function call",
            "ps3_event_receive_port_destroy(virq)": "is a valid function call"
        },
    }
},
{
    "kretprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a linux physical address to lpar address.",
        "proto" :"unsigned long (*ps3_mm_phys_to_lpar)(unsigned long phys_addr)",
        "pre": {
            "phys_addr": ">=0"
        }
    }
},
{
    "kprobe:ps3_mm_phys_to_lpar": {
        "description": "Translate a linux physical address to lpar address.",
        "proto" :"unsigned long (*ps3_mm_phys_to_lpar)(unsigned long phys_addr)",
        "pre": {
            "phys_addr": ">=0"
        }
    }
},
{
    "kretprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes. Increases in entitlement will be used to fulfill the spare entitlement and the rest is given to the excess pool. Decreases, if they are possible, come from the excess pool and from unused device entitlement.",
        "proto" :"int (*vio_cmo_entitlement_update)(size_t new_entitlement)",
        "pre": {
            "new_entitlement": ">=0"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:vio_cmo_entitlement_update": {
        "description": "Manage system entitlement changes. Increases in entitlement will be used to fulfill the spare entitlement and the rest is given to the excess pool. Decreases, if they are possible, come from the excess pool and from unused device entitlement.",
        "proto" :"int (*vio_cmo_entitlement_update)(size_t new_entitlement)",
        "pre": {
            "new_entitlement": ">=0"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kretprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device. For use by devices to request a change to their entitlement at runtime or through sysfs. The desired entitlement level is changed and a balancing of system resources is scheduled to run in the future.",
        "proto" :"void (*vio_cmo_set_dev_desired)(struct vio_dev *viodev, size_t desired)",
        "pre": {
            "viodev": "!=null",
            "desired": ">=0"
        }
    }
},
{
    "kprobe:vio_cmo_set_dev_desired": {
        "description": "Set desired entitlement for a device. For use by devices to request a change to their entitlement at runtime or through sysfs. The desired entitlement level is changed and a balancing of system resources is scheduled to run in the future.",
        "proto" :"void (*vio_cmo_set_dev_desired)(struct vio_dev *viodev, size_t desired)",
        "pre": {
            "viodev": "!=null",
            "desired": ">=0"
        }
    }
},
{
    "kretprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation. Calls the hypervisor to synchronously perform the PFO operation described in @op. In the case of a busy response from the hypervisor, the operation will be re-submitted indefinitely unless a non-zero timeout is specified or an error occurs. The timeout places a limit on when to stop re-submitting a operation, the total time can be exceeded if an operation is in progress. If op->hcall_ret is not NULL, this will be set to the return from the last h_cop_op call or it will be 0 if an error not involving the h_call was encountered.",
        "proto" :"int vio_h_cop_sync(struct vio_dev *vdev, struct vio_pfo_op *op)",
        "pre": {
            "vdev": "!=null",
            "op": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCES, -EPERM]"
        }
    }
},
{
    "kprobe:vio_h_cop_sync": {
        "description": "Perform a synchronous PFO co-processor operation. Calls the hypervisor to synchronously perform the PFO operation described in @op. In the case of a busy response from the hypervisor, the operation will be re-submitted indefinitely unless a non-zero timeout is specified or an error occurs.",
        "proto" :"int (*vio_h_cop_sync)(struct vio_dev *vdev, struct vio_pfo_op *op)",
        "pre": {
            "vdev": "!=null",
            "op": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -E2BIG, -EBUSY, -EACCES, -EPERM]"
        }
    }
},
{
    "__vio_register_driver": {
        "description": "Register a vio driver with the system. vio_bus_type is only initialised for pseries. If not machine_is(pseries), return -ENODEV.",
        "proto": "int __vio_register_driver(struct vio_driver *viodrv, struct module *owner, const char *mod_name)",
        "pre": {
            "viodrv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, 0]"
        }
    }
},
{
    "kprobe:__vio_register_driver": {
        "description": "vio_bus_type is only initialised for pseries. If not machine_is(pseries), return -ENODEV. pr_debug logs the driver registering. Fills in 'struct driver' fields.",
        "proto" :"static long (*__vio_register_driver)(struct vio_driver *viodrv, struct module *owner, const char *mod_name)",
        "pre": {
            "viodrv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null",
            "machine_is(pseries)": "==true"
        },
    }
},
{
    "kretprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "proto": "void vio_unregister_driver(struct vio_driver *viodrv)",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kprobe:vio_unregister_driver": {
        "description": "Remove registration of vio driver.",
        "proto": "void (*vio_unregister_driver)(struct vio_driver *viodrv)",
        "pre": {
            "viodrv": "!=null"
        }
    }
},
{
    "kretprobe:vio_register_device_node": {
        "description": "Register a new vio device. Creates and initializes a vio_dev structure from the data in of_node and adds it to the list of virtual devices. Returns a pointer to the created vio_dev or NULL if node has NULL device_type or compatible fields.",
        "proto" :"struct vio_dev *(*vio_register_device_node)(struct device_node *of_node)",
        "pre": {
            "of_node": "!=null"
        },
        "post": {
            "return": "!=null || (of_node->device_type == null || of_node->compatible == null)"
        }
    }
},
{
    "kprobe:vio_register_device_node": {
        "description": "Register a new vio device. Creates and initializes a vio_dev structure from the data in of_node and adds it to the list of virtual devices. Returns a pointer to the created vio_dev or NULL if node has NULL device_type or compatible fields.",
        "proto" :"struct vio_dev *(*vio_register_device_node)(struct device_node *of_node)",
        "pre": {
            "of_node": {
                "device_type": "!=null",
                "compatible": "!=null"
            }
        },
    }
},
{
    "kretprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device. Calls prom.c's of_get_property() to return the value of the attribute specified by @which.",
        "proto" :"const void *(*vio_get_attribute)(struct vio_dev *vdev, char *which, int *length)",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null"
        },
    }
},
{
    "kprobe:vio_get_attribute": {
        "description": "Get attribute for virtual device. Calls prom.c's of_get_property() to return the value of the attribute specified by @which.",
        "proto" :"const void *(*vio_get_attribute)(struct vio_dev *vdev, char *which, int *length)",
        "pre": {
            "vdev": "!=null",
            "which": "!=null",
            "length": "!=null || ==null",
        },
    }
},
{
    "kretprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev. Takes a reference to the embedded struct device which needs to be dropped after use.",
        "proto" :"struct vio_dev *(*vio_find_node)(struct device_node *vnode)",
        "pre": {
            "vnode": "!=null"
        },
    }
},
{
    "kprobe:vio_find_node": {
        "description": "Find an already-registered vio_dev. Takes a reference to the embedded struct device which needs to be dropped after use.",
        "proto" :"struct vio_dev *(*vio_find_node)(struct device_node *vnode)",
        "pre": {
            "vnode": "!=null"
        }
    }
},
{
    "kretprobe:ibmebus_register_driver": {
        "description": "If the driver uses devices that ibmebus doesn't know, add them",
        "proto" :"static long (*ibmebus_register_driver)(struct platform_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:ibmebus_register_driver": {
        "description": "If the driver uses devices that ibmebus doesn't know, add them.",
        "proto" :"static long (*ibmebus_register_driver)(struct platform_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},


{
    "kretprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter. The vtermno or unit_address of the adapter from which to fetch the data. The character buffer into which to put the character data fetched from firmware. The count parameter is not used.",
        "proto" :"int hvc_get_chars(uint32_t vtermno, char *buf, int count)",
        "pre": {
            "vtermno": ">=0",
            "buf": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kprobe:hvc_get_chars": {
        "description": "Retrieve characters from firmware for denoted vterm adapter.",
        "proto" :"int hvc_get_chars(uint32_t vtermno, char *buf, int count)",
        "pre": {
            "vtermno": ">=0",
            "buf": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter. The vtermno or unit_address of the adapter from which the data originated. The character buffer that contains the character data to send to firmware. Must be at least 16 bytes, even if count is less than 16. Send this number of characters.",
        "proto" :"int hvc_put_chars(uint32_t vtermno, const char *buf, int count)",
        "pre": {
            "vtermno": ">=0",
            "buf": "!=null && len(buf) >= 16",
            "count": ">=0 && <= len(buf)"
        }
    }
},
{
    "kprobe:hvc_put_chars": {
        "description": "Send characters to firmware for denoted vterm adapter",
        "proto" :"int (*hvc_put_chars)(uint32_t vtermno, const char *buf, int count)",
        "pre": {
            "vtermno": "is a valid vtermno",
            "buf": "!=null && length >= 16",
            "count": ">= 0 && <= length of buf"
        },
    }
},
{
    "kretprobe:h_get_mpp": {
        "description": "H_GET_MPP hcall returns info in 7 parms",
        "proto" :"int h_get_mpp(struct hvcall_mpp_data *mpp_data)",
        "pre": {
            "mpp_data": "!=null"
        }
    }
},
{
    "kprobe:h_get_mpp": {
        "description": "H_GET_MPP hcall returns info in 7 parms",
        "proto" :"int (*h_get_mpp)(struct hvcall_mpp_data *mpp_data)",
        "pre": {
            "mpp_data": "!=null"
        }
    }
},
{
    "kretprobe:of_read_drc_info_cell": {
        "description": "Get drc-type:encode-string",
        "proto" :"static long (*of_read_drc_info_cell)(struct property *prop, const __be32 *curval, struct of_drc_info *data)",
        "pre": {
            "prop": "!=null",
            "curval": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:of_read_drc_info_cell": {
        "description": "Reads drc information from a cell.",
        "proto" :"static long (*of_read_drc_info_cell)(struct property *prop, const __be32 *curval, struct of_drc_info *data)",
        "pre": {
            "prop": "!=null",
            "curval": "!=null",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:hvcs_free_partner_info": {
        "description": "Free the partner info list that was returned by calling hvcs_get_partner_info().",
        "proto" :"int (*hvcs_free_partner_info)(struct list_head *head)",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kprobe:hvcs_free_partner_info": {
        "description": "This function is used to free the partner info list that was returned by calling hvcs_get_partner_info().",
        "proto" :"int hvcs_free_partner_info(struct list_head *head)",
        "pre": {
            "head": "!=null"
        }
    }
},
{
    "kretprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty. If this function is called once and -EINVAL is returned it may indicate that the partner info needs to be refreshed for the target unit address at which point the caller must invoke hvcs_get_partner_info() and then call this function again. If, for a second time, -EINVAL is returned then it indicates that there is probably already a partner connection registered to a different vty-server adapter. It is also possible that a second -EINVAL may indicate that one of the parms is not valid, for instance if the link was removed between the vty-server adapter and the vty adapter that you are trying to open. Don't shoot the messenger. Firmware implemented it this way.",
        "proto" :"int hvcs_register_connection( uint32_t unit_address, uint32_t p_partition_ID, uint32_t p_unit_address)",
        "pre": {
            "unit_address": ">=0",
            "p_partition_ID": ">=0",
            "p_unit_address": ">=0"
        },
    }
},
{
    "kprobe:hvcs_register_connection": {
        "description": "Establish a connection between this vty-server and a vty. If this function is called once and -EINVAL is returned it may indicate that the partner info needs to be refreshed for the target unit address at which point the caller must invoke hvcs_get_partner_info() and then call this function again. If, for a second time, -EINVAL is returned then it indicates that there is probably already a partner connection registered to a different vty-server adapter. It is also possible that a second -EINVAL may indicate that one of the parms is not valid, for instance if the link was removed between the vty-server adapter and the vty adapter that you are trying to open. Don't shoot the messenger. Firmware implemented it this way.",
        "proto" :"int hvcs_register_connection( uint32_t unit_address, uint32_t p_partition_ID, uint32_t p_unit_address)",
        "pre": {
            "unit_address": ">=0",
            "p_partition_ID": ">=0",
            "p_unit_address": ">=0"
        }
    }
},
{
    "kretprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty. If -EBUSY is returned continue to call this function until 0 is returned.",
        "proto" :"int hvcs_free_connection(uint32_t unit_address)",
        "pre": {
            "unit_address": ">=0"
        },
    }
},
{
    "kprobe:hvcs_free_connection": {
        "description": "Free the connection between a vty-server and vty. If -EBUSY is returned continue to call this function until 0 is returned.",
        "proto" :"int hvcs_free_connection(uint32_t unit_address)",
        "pre": {
            "unit_address": ">=0"
        },
    }
},

{
    "kprobe:pnv_cxl_alloc_hwirq_ranges": {
        "description": "Allocate hardware interrupt ranges for the specified device.",
        "proto" :"static long (*pnv_cxl_alloc_hwirq_ranges)(struct cxl_irq_ranges *irqs, struct pci_dev *dev, int num)",
        "pre": {
            "irqs": "!=null",
            "dev": "!=null",
            "num": ">=0",
        },
    }
},
{
    "kretprobe:pnv_cxl_ioda_msi_setup": {
        "description": "Assign XIVE to PE",
        "proto" :"static int (*pnv_cxl_ioda_msi_setup)(struct pci_dev *dev, unsigned int hwirq, unsigned int virq)",
        "pre": {
            "dev": "!=null",
            "hwirq": ">=0",
            "virq": ">=0"
        },
        "post": {
            "rc": "in [0, -ENODEV]"
        }
    }
},

{
    "kretprobe:of_find_compatible_node": {
        "description": "Find a node that is compatible with the given description.",
        "proto" :"struct device_node *(*of_find_compatible_node)(struct device_node *from, const char *type, const char *compatible)",
        "pre": {
            "from": "==null",
            "type": "==null",
            "compatible": "==\"ibm,opal-event\""
        },
    }
},
{
    "kprobe:of_find_compatible_node": {
        "description": "Finds a device node that is compatible with the provided string.",
        "proto" :"struct device_node *(*of_find_compatible_node)(struct device_node *from, const char *type, const char *compatible)",
        "pre": {
            "from": "==null",
            "type": "==null",
            "compatible": "==\"ibm,opal-event\"",
        },
    }
},
{
    "kretprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number @irq: irq of timer.",
        "proto" :"struct mpc52xx_gpt_priv *(*mpc52xx_gpt_from_irq)(int irq)",
        "pre": {
            "irq": ">=0"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_from_irq": {
        "description": "Return the GPT device associated with an IRQ number @irq: irq of timer.",
        "proto" :"struct mpc52xx_gpt_priv *(*mpc52xx_gpt_from_irq)(int irq)",
        "pre": {
            "irq": "is integer"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer. An interrupt will be generated every time the timer fires.",
        "proto" :"int (*mpc52xx_gpt_start_timer)(struct mpc52xx_gpt_priv *gpt, u64 period, int continuous)",
        "pre": {
            "gpt": "!=null",
            "period": ">=0 && <= 130000000000",
            "continuous": "in [0, 1]"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_start_timer": {
        "description": "Set and enable the GPT timer. An interrupt will be generated every time the timer fires.",
        "proto" :"int (*mpc52xx_gpt_start_timer)(struct mpc52xx_gpt_priv *gpt, u64 period, int continuous)",
        "pre": {
            "gpt": "!=null",
            "period": ">=0 && <= 130000000000",
            "continuous": "in [0, 1]",
        },
    }
},
{
    "kretprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt. Returns an error if attempting to stop a wdt.",
        "proto" :"int (*mpc52xx_gpt_stop_timer)(struct mpc52xx_gpt_priv *gpt)",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_stop_timer": {
        "description": "Stop a gpt. Returns an error if attempting to stop a wdt.",
        "proto" :"int (*mpc52xx_gpt_stop_timer)(struct mpc52xx_gpt_priv *gpt)",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period. Returns the timer period in ns.",
        "proto" :"u64 (*mpc52xx_gpt_timer_period)(struct mpc52xx_gpt_priv *gpt)",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kprobe:mpc52xx_gpt_timer_period": {
        "description": "Read the timer period. Returns the timer period in ns.",
        "proto" :"u64 (*mpc52xx_gpt_timer_period)(struct mpc52xx_gpt_priv *gpt)",
        "pre": {
            "gpt": "!=null"
        }
    }
},
{
    "kretprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports. @psc_id: id of psc port; must be 1,2,3 or 6. @clkdiv: clock divider value to put into CDM PSC register.",
        "proto" :"int (*mpc52xx_set_psc_clkdiv)(int psc_id, int clkdiv)",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "is integer"
        }
    }
},
{
    "kprobe:mpc52xx_set_psc_clkdiv": {
        "description": "Set clock divider in the CDM for PSC ports",
        "proto" :"int (*mpc52xx_set_psc_clkdiv)(int psc_id, int clkdiv)",
        "pre": {
            "psc_id": "in [1, 2, 3, 6]",
            "clkdiv": "is an integer"
        }
    }
},
{
    "kretprobe:mpc5200_psc_ac97_gpio_reset": {
        "description": "mpc5200_psc_ac97_gpio_reset() function description here",
        "proto" :"static long (*mpc5200_psc_ac97_gpio_reset)(void *gpio_lock, struct mpc52xx_gpio __iomem *simple_gpio, struct mpc52xx_gpio_wkup __iomem *wkup_gpio)",
        "pre": {
            "gpio_lock": "!=null",
            "simple_gpio": "!=null",
            "wkup_gpio": "!=null"
        },
    }
},
{
    "kprobe:mpc5200_psc_ac97_gpio_reset": {
        "description": "Reset the GPIO",
        "proto" :"static long (*mpc5200_psc_ac97_gpio_reset)(void *gpio_lock, struct mpc52xx_gpio __iomem *simple_gpio, struct mpc52xx_gpio_wkup __iomem *wkup_gpio)",
        "pre": {
            "gpio_lock": "!=null",
            "simple_gpio": "!=null",
            "wkup_gpio": "!=null"
        },
    }
},
{
    "kretprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_iob_reg)(unsigned int reg)",
        "pre": {
            "reg": ">=0"
        }
    }
},
{
    "kprobe:pasemi_read_iob_reg": {
        "description": "Read IOB register @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_iob_reg)(unsigned int reg)",
        "pre": {
            "reg": ">=0"
        }
    }
},
{
    "kretprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register. @reg: Register to write to (offset into PCI CFG space). @val: Value to write.",
        "proto" :"void (*pasemi_write_iob_reg)(unsigned int reg, unsigned int val)",
        "pre": {
            "reg": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:pasemi_write_iob_reg": {
        "description": "Write IOB register @reg: Register to write to (offset into PCI CFG space) @val: Value to write",
        "proto" :"static void (*pasemi_write_iob_reg)(unsigned int reg, unsigned int val)",
        "pre": {
            "reg": "in [0, UINT_MAX]",
            "val": "in [0, UINT_MAX]"
        }
    }
},
{
    "kretprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register @intf: MAC interface @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_mac_reg)(int intf, unsigned int reg)",
        "pre": {
            "intf": ">=0",
            "reg": ">=0"
        }
    }
},
{
    "kprobe:pasemi_read_mac_reg": {
        "description": "Read MAC register @intf: MAC interface @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_mac_reg)(int intf, unsigned int reg)",
        "pre": {
            "intf": "!=null",
            "reg": "valid offset into PCI CFG space"
        }
    }
},
{
    "kretprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register @intf: MAC interface @reg: Register to write to (offset into PCI CFG space) @val: Value to write",
        "proto" :"void (*pasemi_write_mac_reg)(int intf, unsigned int reg, unsigned int val)",
        "pre": {
            "intf": ">=0",
            "reg": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:pasemi_write_mac_reg": {
        "description": "Write MAC register @intf: MAC interface @reg: Register to write to (offset into PCI CFG space) @val: Value to write",
        "proto" :"void (*pasemi_write_mac_reg)(int intf, unsigned int reg, unsigned int val)",
        "pre": {
            "intf": ">=0",
            "reg": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kretprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_dma_reg)(unsigned int reg)",
        "pre": {
            "reg": ">=0"
        }
    }
},
{
    "kprobe:pasemi_read_dma_reg": {
        "description": "Read DMA register @reg: Register to read (offset into PCI CFG space)",
        "proto" :"unsigned int (*pasemi_read_dma_reg)(unsigned int reg)",
        "pre": {
            "reg": ">=0"
        },
    }
},
{
    "kretprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register @reg: Register to write to (offset into PCI CFG space) @val: Value to write",
        "proto" :"static void (*pasemi_write_dma_reg)(unsigned int reg, unsigned int val)",
        "pre": {
            "reg": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:pasemi_write_dma_reg": {
        "description": "Write DMA register @reg: Register to write to (offset into PCI CFG space) @val: Value to write",
        "proto" :"static void (*pasemi_write_dma_reg)(unsigned int reg, unsigned int val)",
        "pre": {
            "reg": "is a valid offset into PCI CFG space",
            "val": "is a valid value to write into the register"
        },
    }
},
{
    "kretprobe:pasemi_dma_alloc_chan": {
        "description": "pasemi_dma_alloc_chan allocates a DMA channel for use by a client. The type argument specifies whether it's a RX or TX channel, and in the case of TX channels which group it needs to belong to (if any). Returns a pointer to the total structure allocated on success, NULL on failure.",
        "proto" :"void *(*pasemi_dma_alloc_chan)(enum pasemi_dmachan_type type, int total_size, int offset)",
        "pre": {
            "type": "in [RX, TX]",
            "total_size": "> 0",
            "offset": ">= 0"
        },
    }
},
{
    "kprobe:pasemi_dma_alloc_chan": {
        "description": "pasemi_dma_alloc_chan allocates a DMA channel for use by a client. The type argument specifies whether it's a RX or TX channel, and in the case of TX channels which group it needs to belong to (if any). Returns a pointer to the total structure allocated on success, NULL on failure.",
        "proto" :"void *(*pasemi_dma_alloc_chan)(enum pasemi_dmachan_type type, int total_size, int offset)",
        "pre": {
            "type": "in [RX, TX]",
            "total_size": "> 0",
            "offset": ">= 0",
        },
    }
},
{
    "kretprobe:pasemi_dma_free_chan": {
        "description": "Frees a previously allocated channel. It will also deallocate any descriptor ring associated with the channel, if allocated.",
        "proto" :"void (*pasemi_dma_free_chan)(struct pasemi_dmachan *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_chan": {
        "description": "Frees a previously allocated channel. It will also deallocate any descriptor ring associated with the channel, if allocated.",
        "proto" :"void (*pasemi_dma_free_chan)(struct pasemi_dmachan *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate a descriptor ring for a channel. Returns 0 on success, errno on failure. The passed in struct pasemi_dmachan is updated with the virtual and DMA addresses of the ring.",
        "proto" :"int (*pasemi_dma_alloc_ring)(struct pasemi_dmachan *chan, int ring_size)",
        "pre": {
            "chan": "!=null",
            "ring_size": ">0"
        },
        "post": {
            "return": "in [0, errno]"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_ring": {
        "description": "Allocate a descriptor ring for a channel. Returns 0 on success, errno on failure. The passed in struct pasemi_dmachan is updated with the virtual and DMA addresses of the ring.",
        "proto" :"int (*pasemi_dma_alloc_ring)(struct pasemi_dmachan *chan, int ring_size)",
        "pre": {
            "chan": "!=null",
            "ring_size": ">0"
        },
    }
},
{
    "kretprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel with optional additional arguments.",
        "proto" :"void (*pasemi_dma_start_chan)(const struct pasemi_dmachan *chan, const u32 cmdsta)",
        "pre": {
            "chan": "!=null",
            "cmdsta": "is a valid u32 value"
        }
    }
},
{
    "kprobe:pasemi_dma_start_chan": {
        "description": "Start a DMA channel with optional additional arguments.",
        "proto" :"void (*pasemi_dma_start_chan)(const struct pasemi_dmachan *chan, const u32 cmdsta)",
        "pre": {
            "chan": "!=null",
            "cmdsta": "is a valid u32 value"
        }
    }
},
{
    "kretprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel. This is done by setting the ST bit in the CMDSTA register and waiting on the ACT (active) bit to clear, then finally disabling the whole channel. This function will only try for a short while for the channel to stop, if it doesn't it will return failure. Returns 1 on success, 0 on failure.",
        "proto" :"#define MAX_RETRIES 5000 int (*pasemi_dma_stop_chan)(const struct pasemi_dmachan *chan)",
        "pre": {
            "chan": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pasemi_dma_stop_chan": {
        "description": "Stop a DMA channel. This is done by setting the ST bit in the CMDSTA register and waiting on the ACT (active) bit to clear, then finally disabling the whole channel. This function will only try for a short while for the channel to stop, if it doesn't it will return failure. Returns 1 on success, 0 on failure.",
        "proto" :"#define MAX_RETRIES 5000int (*pasemi_dma_stop_chan)(const struct pasemi_dmachan *chan)",
        "pre": {
            "chan": "!=null"
        },
    }
},
{
    "kretprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to be used by the DMA engine for readwrite, similar to dma_alloc_coherent(). Returns the virtual address of the buffer, or NULL in case of failure.",
        "proto" :"void *(*pasemi_dma_alloc_buf)(struct pasemi_dmachan *chan, int size, dma_addr_t *handle)",
        "pre": {
            "chan": "!=null",
            "size": ">0",
            "handle": "!=null"
        },
    }
},
{
    "kprobe:pasemi_dma_alloc_buf": {
        "description": "Allocate a buffer to be used by the DMA engine for readwrite, similar to dma_alloc_coherent(). Returns the virtual address of the buffer, or NULL in case of failure.",
        "proto" :"void *(*pasemi_dma_alloc_buf)(struct pasemi_dmachan *chan, int size, dma_addr_t *handle)",
        "pre": {
            "chan": "!=null",
            "size": ">0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_buf": {
        "description": "Frees a previously allocated buffer used for DMA. @chan: Channel the buffer was allocated for. @size: Size of buffer in bytes. @handle: DMA handle.",
        "proto" :"void (*pasemi_dma_free_buf)(struct pasemi_dmachan *chan, int size, dma_addr_t *handle)",
        "pre": {
            "chan": "!=null",
            "size": ">0",
            "handle": "!=null"
        }
    }
},
{
    "kprobe:pasemi_dma_free_buf": {
        "description": "Frees a previously allocated buffer used for DMA.",
        "proto" :"void (*pasemi_dma_free_buf)(struct pasemi_dmachan *chan, int size, dma_addr_t *handle)",
        "pre": {
            "chan": "!=null",
            "size": ">0",
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization. Returns allocated flag (0-63), < 0 on error.",
        "proto" :"int (*pasemi_dma_alloc_flag)(void)",
        "post": {
            "return": "in [0, 63] or < 0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_flag": {
        "description": "Allocate a flag (event) for channel synchronization. Allocates a flag for use with channel synchronization (event descriptors). Returns allocated flag (0-63), < 0 on error.",
        "proto" :"int (*pasemi_dma_alloc_flag)(void)",
        "pre": {},
    }
},
{
    "kretprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event). Frees up a flag so it can be reused for other purposes.",
        "proto" :"static void (*pasemi_dma_free_flag)(int flag)",
        "pre": {
            "flag": ">=0"
        }
    }
},
{
    "kprobe:pasemi_dma_free_flag": {
        "description": "Deallocates a flag (event). Frees up a flag so it can be reused for other purposes.",
        "proto" :"static void (*pasemi_dma_free_flag)(int flag)",
        "pre": {
            "flag": "is a valid flag number"
        }
    }
},
{
    "kretprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1. Sets the flag provided to 1.",
        "proto": "void (*pasemi_dma_set_flag)(int flag)",
        "pre": {
            "flag": "is integer"
        }
    }
},
{
    "kprobe:pasemi_dma_set_flag": {
        "description": "Sets a flag (event) to 1. Sets the flag provided to 1.",
        "proto" :"static void (*pasemi_dma_set_flag)(int flag)",
        "pre": {
            "flag": "is integer"
        }
    }
},
{
    "kretprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0. Sets the flag provided to 0.",
        "proto": "void (*pasemi_dma_clear_flag)(int flag)",
        "pre": {
            "flag": ">=0"
        }
    }
},
{
    "kprobe:pasemi_dma_clear_flag": {
        "description": "Sets a flag (event) to 0. Sets the flag provided to 0.",
        "proto" :"static void (*pasemi_dma_clear_flag)(int flag)",
        "pre": {
            "flag": "is an integer"
        }
    }
},
{
    "kretprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine to use for cryptochecksum offload. Returns allocated engine (0-8), < 0 on error.",
        "proto" :"int pasemi_dma_alloc_fun(void)",
        "pre": {},
        "post": {
            "return": "in [0, 8] or < 0"
        }
    }
},
{
    "kprobe:pasemi_dma_alloc_fun": {
        "description": "Allocate a function engine. Allocates a function engine to use for cryptochecksum offload. Returns allocated engine (0-8), < 0 on error.",
        "proto" :"int (*pasemi_dma_alloc_fun)(void)",
        "pre": {},
        "post": {
            "return": "in [0, 1, 2, 3, 4, 5, 6, 7, 8] or < 0"
        }
    }
},
{
    "kretprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine. Frees up a function engine so it can be used for other purposes.",
        "proto" :"void (*pasemi_dma_free_fun)(int fun)",
        "pre": {
            "fun": "is a valid engine number"
        }
    }
},
{
    "kprobe:pasemi_dma_free_fun": {
        "description": "Deallocates a function engine. Frees up a function engine so it can be used for other purposes.",
        "proto": "void (*pasemi_dma_free_fun)(int fun)",
        "pre": {
            "fun": ">=0"
        }
    }
},
{
    "kretprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library. This function initializes the DMA library. It must be called before any other function in the library. Returns 0 on success, errno on failure.",
        "proto" :"int pasemi_dma_init(void)",
        "pre": {
        },
    }
},
{
    "kprobe:pasemi_dma_init": {
        "description": "Initialize the PA Semi DMA library. This function initializes the DMA library. It must be called before any other function in the library. Returns 0 on success, errno on failure.",
        "proto" :"int (*pasemi_dma_init)(void)",
        "pre": {}
    }
},
{
    "kretprobe:function_name": {
        "description": "This function does something",
        "proto" :"void function_name(type1 arg1, type2 arg2)",
        "pre": {
            "arg1": "condition1",
            "arg2": "condition2"
        },
    }
},
{
    "},[WARP_RED_LED] = ": {
        "description": "A struct of type gpio_led representing the red LED.",
        "proto": "struct gpio_led",
        "pre": {
            "name": "!=null",
            "default_state": "in [LEDS_DEFSTATE_KEEP]",
            "gpiod": "!=null"
        }
    }
},
{
    "kretprobe:mpc512x_cs_config": {
        "description": "Perform chip select configuration for devices on LocalPlus Bus. Intended to dynamically reconfigure the chip select parameters for configurable devices on the bus.",
        "proto" :"int (*mpc512x_cs_config)(unsigned int cs, u32 val)",
        "pre": {
            "cs": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:mpc512x_cs_config": {
        "description": "Perform chip select configuration for devices on LocalPlus Bus. Intended to dynamically reconfigure the chip select parameters for configurable devices on the bus.",
        "proto" :"int (*mpc512x_cs_config)(unsigned int cs, u32 val)",
        "pre": {
            "cs": ">=0",
            "val": "is a valid chip select configuration value"
        }
    }
},
{
    "kretprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "Check whether a transfer is in progress",
        "proto" :"static int (*mpc512x_lpbfifo_submit_locked)(struct mpc512x_lpbfifo_request *req)",
        "pre": {
            "req": "!=null",
            "lpbfifo.regs": "!=null"
        },
        "post": {
            "ret": "in [-ENODEV, 0, -EBUSY]"
        }
    }
},
{
    "kprobe:mpc512x_lpbfifo_submit_locked": {
        "description": "Check whether a transfer is in progress",
        "proto" :"static int (*mpc512x_lpbfifo_submit_locked)(struct mpc512x_lpbfifo_request *req)",
        "pre": {
            "req": "!=null",
            "lpbfifo.regs": "!=null"
        },
    }
},
{
    "kretprobe:mpic_start_timer": {
        "description": "Start hardware timer @handle: the timer to be started. It will do ->fn(->dev) callback from the hardware interrupt at the 'time64_t' point in the future.",
        "proto" :"void (*mpic_start_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_start_timer": {
        "description": "Start hardware timer @handle: the timer to be started. It will do ->fn(->dev) callback from the hardware interrupt at the 'time64_t' point in the future.",
        "proto" :"void (*mpic_start_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_stop_timer": {
        "description": "Stop the hardware timer. The timer periodically generates an interrupt unless the user stops the timer.",
        "proto": "void (*mpic_stop_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_stop_timer": {
        "description": "Stop a hardware timer that periodically generates an interrupt.",
        "proto": "void (*mpic_stop_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "proto": "void mpic_get_remain_time(struct mpic_timer *handle, time64_t *time)",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:mpic_get_remain_time": {
        "description": "Query timer remaining time.",
        "proto" :"void (*mpic_get_remain_time)(struct mpic_timer *handle, time64_t *time)",
        "pre": {
            "handle": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:mpic_free_timer": {
        "description": "Free the hardware timer. Note: cannot be used in interrupt context.",
        "proto" :"void (*mpic_free_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kprobe:mpic_free_timer": {
        "description": "Free the hardware timer.",
        "proto" :"void (*mpic_free_timer)(struct mpic_timer *handle)",
        "pre": {
            "handle": "!=null"
        }
    }
},
{
    "kretprobe:mpic_request_timer": {
        "description": "Get a hardware timer. This executes the 'request_irq', returning NULL else 'handle' on success.",
        "proto": "struct mpic_timer *(*mpic_request_timer)(irq_handler_t fn, void *dev, time64_t time)",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": ">=0"
        }
    }
},
{
    "kprobe:mpic_request_timer": {
        "description": "Get a hardware timer. This executes the 'request_irq', returning NULL else 'handle' on success.",
        "proto" :"struct mpic_timer *(*mpic_request_timer)(irq_handler_t fn, void *dev, time64_t time)",
        "pre": {
            "fn": "!=null",
            "dev": "!=null",
            "time": ">=0",
        },
    }
},
{
    "kretprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node. Returns bus frequency (IPS on MPC512x, IPB on MPC52xx), or 0 if the bus frequency cannot be found.",
        "proto" :"unsigned long (*mpc5xxx_fwnode_get_bus_frequency)(struct fwnode_handle *fwnode)",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:mpc5xxx_fwnode_get_bus_frequency": {
        "description": "Find the bus frequency for a firmware node. Returns bus frequency (IPS on MPC512x, IPB on MPC52xx), or 0 if the bus frequency cannot be found.",
        "proto" :"unsigned long (*mpc5xxx_fwnode_get_bus_frequency)(struct fwnode_handle *fwnode)",
        "pre": {
            "fwnode": "!=null"
        },
    }
},
{
    "kretprobe:gtm_put_timer16": {
        "description": "This function releases GTM timer so others may request it.",
        "proto" :"void (*gtm_put_timer16)(struct gtm_timer *tmr)",
        "pre": {
            "tmr": "!=null"
        }
    }
},
{
    "kprobe:gtm_put_timer16": {
        "description": "This function releases GTM timer so others may request it.",
        "proto" :"void (*gtm_put_timer16)(struct gtm_timer *tmr)",
        "pre": {
            "tmr": "!=null"
        }
    }
},
{
    "kretprobe:gtm_set_timer16": {
        "description": "(re)set 16 bit timer with arbitrary precision. @tmr:pointer to the gtm_timer structure obtained from gtm_get_timer. @usec:timer interval in microseconds. @reload:if set, the timer will reset upon expiry rather than continue running free. Context:any. This function (re)sets the GTM timer so that it counts up to the requested interval value, and fires the interrupt when the value is reached. This function will reduce the precision of the timer as needed in order for the requested timeout to fit in a 16-bit register.",
        "proto" :"int gtm_set_timer16(struct gtm_timer *tmr, unsigned long usec, bool reload)",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},
{
    "kprobe:gtm_set_timer16": {
        "description": "(re)set 16 bit timer with arbitrary precision. This function (re)sets the GTM timer so that it counts up to the requested interval value, and fires the interrupt when the value is reached. This function will reduce the precision of the timer as needed in order for the requested timeout to fit in a 16-bit register.",
        "proto" :"int gtm_set_timer16(struct gtm_timer *tmr, unsigned long usec, bool reload)",
        "pre": {
            "tmr": "!=null",
            "usec": ">=0",
            "reload": "in [true, false]"
        }
    }
},
{
    "kretprobe:gtm_set_exact_timer16": {
        "description": "Set a timer with µSec precision. If 'reload' is true, the timer will be reset after it expires.",
        "proto" :"static int (*gtm_set_exact_timer16)(struct gtm_timer *tmr, u16 usec, bool reload)",
        "pre": {
            "tmr": "!=null",
            "usec": "is positive integer",
            "reload": "is boolean",
        },
    }
},
{
    "kprobe:gtm_set_exact_timer16": {
        "description": "Set an exact timer with a frequency enough for µSec precision.",
        "proto" :"static int (*gtm_set_exact_timer16)(struct gtm_timer *tmr, u16 usec, bool reload)",
        "pre": {
            "tmr": "!=null",
            "usec": "is a 16-bit unsigned integer",
            "reload": "is a boolean"
        },
    }
},
{
    "kretprobe:gtm_set_ref_timer16": {
        "description": "This is a back-end for the exported functions, it's used to reset single timer in reference mode.",
        "proto" :"static int gtm_set_ref_timer16(struct gtm_timer *tmr, int frequency, int reference_value, bool free_run)",
        "pre": {
            "tmr": "!=null",
            "frequency": ">=0",
            "reference_value": ">=0",
            "free_run": "in [true, false]"
        },
    }
},
{
    "kprobe:gtm_set_ref_timer16": {
        "description": "This is back-end for the exported functions, it's used to reset single timer in reference mode.",
        "proto" :"static int gtm_set_ref_timer16(struct gtm_timer *tmr, int frequency, int reference_value, bool free_run)",
        "pre": {
            "tmr": "!=null",
            "frequency": ">=0",
            "reference_value": ">=0",
            "free_run": "in [true, false]"
        },
    }
},
{
    "kretprobe:gtm_ack_timer16": {
        "description": "This function is used to acknowledge timer interrupt event, use it inside the interrupt handler.",
        "proto" :"void (*gtm_ack_timer16)(struct gtm_timer *tmr, u16 events)",
        "pre": {
            "tmr": "!=null",
            "events": "is a valid events mask"
        }
    }
},
{
    "kprobe:gtm_ack_timer16": {
        "description": "This function is used to acknowledge timer interrupt event, use it inside the interrupt handler.",
        "proto" :"void (*gtm_ack_timer16)(struct gtm_timer *tmr, u16 events)",
        "pre": {
            "tmr": "!=null",
            "events": "is a valid events mask"
        },
    }
},
{
    "kretprobe:__cpm2_setbrg": {
        "description": "This is good enough to get SMCs running.....",
        "proto" :"__cpm2_setbrg(uint brg, uint rate, uint clk, int div16, int src)",
        "pre": {
            "brg": "<4",
            "rate": "!=null",
            "clk": "!=null",
            "div16": "!=null",
            "src": "!=null"
        },
    }
},
{
    "__cpm2_setbrg": {
        "description": "This is good enough to get SMCs running.....",
        "proto" :"__cpm2_setbrg(uint brg, uint rate, uint clk, int div16, int src)",
        "pre": {
            "brg": "< 4",
            "rate": "constraint not provided",
            "clk": "constraint not provided",
            "div16": "constraint not provided",
            "src": "constraint not provided"
        },
    }
},
{
    "kretprobe:fsl_lbc_addr": {
        "description": "Converts a base address of lbc into the right format for the BR register. If the SOC has eLBC then it returns 32bit physical address else it converts a 34bit local bus physical address to correct format of 32bit address for BR register (Example: MPC8641).",
        "proto" :"u32 (*fsl_lbc_addr)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kprobe:fsl_lbc_addr": {
        "description": "This function converts a base address of lbc into the right format for the BR register. If the SOC has eLBC then it returns 32bit physical address else it converts a 34bit local bus physical address to correct format of 32bit address for BR register (Example: MPC8641).",
        "proto" :"u32 (*fsl_lbc_addr)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:fsl_lbc_find": {
        "description": "This function walks LBC banks comparing 'Base address' field of the BR registers with the supplied addr_base argument. When bases match this function returns bank number (starting with 0), otherwise it returns appropriate errno value.",
        "proto" :"int (*fsl_lbc_find)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        },
        "post": {
            "return": "in [0, errno]"
        }
    }
},
{
    "kprobe:fsl_lbc_find": {
        "description": "This function walks LBC banks comparing 'Base address' field of the BR registers with the supplied addr_base argument. When bases match this function returns bank number (starting with 0), otherwise it returns appropriate errno value.",
        "proto" :"int (*fsl_lbc_find)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address. This function fills fsl_upm structure so you can use it with the rest of UPM API. On success this function returns 0, otherwise it returns appropriate errno value.",
        "proto" :"int (*fsl_upm_find)(phys_addr_t addr_base, struct fsl_upm *upm)",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        },
    }
},
{
    "kprobe:fsl_upm_find": {
        "description": "Find pre-programmed UPM via base address. This function fills fsl_upm structure so you can use it with the rest of UPM API. On success this function returns 0, otherwise it returns appropriate errno value.",
        "proto" :"int (*fsl_upm_find)(phys_addr_t addr_base, struct fsl_upm *upm)",
        "pre": {
            "addr_base": "!=null",
            "upm": "!=null"
        }
    }
},
{
    "kretprobe:fsl_upm_run_pattern": {
        "description": "This function triggers dummy write to the memory specified by the io_base, thus UPM pattern actually executed. Note that mar usage depends on the pre-programmed AMX bits in the UPM RAM.",
        "proto" :"int fsl_upm_run_pattern(struct fsl_upm *upm, void __iomem *io_base, u32 mar)",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "is a valid u32 value"
        },
    }
},
{
    "kprobe:fsl_upm_run_pattern": {
        "description": "This function triggers dummy write to the memory specified by the io_base, thus UPM pattern actually executed. Note that mar usage depends on the pre-programmed AMX bits in the UPM RAM.",
        "proto" :"int (*fsl_upm_run_pattern)(struct fsl_upm *upm, void __iomem *io_base, u32 mar)",
        "pre": {
            "upm": "!=null",
            "io_base": "!=null",
            "mar": "is a valid MAR register content"
        },
    }
},
{
    "kretprobe:get_brgfreq": {
        "description": "Get the clock frequency from a device node compatible with 'fsl,cpm-brg'. If the node is found, the clock frequency is read from it and returned. If the node is not found, the function returns -1.",
        "proto" :"static u32 (*get_brgfreq)(void)",
        "pre": {},
        "post": {
            "return": "in [-1, 0, UINT_MAX]"
        }
    }
},
{
    "kprobe:get_brgfreq": {
        "description": "Legacy device binding -- will go away when no users are left.",
        "proto" :"static u32 (*get_brgfreq)(void)",
        "pre": {
            "brgfreq": "!= -1",
            "node": "!=null",
        },
        "post": {
            "brgfreq": "!= -1",
            "node": "==null",
        }
    }
},


{
    "kretprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "NULL if no ISA bus",
        "proto" :"Unknown",
        "pre": {
            "Unknown": "Unknown",
        },
    }
},
{
    "kprobe:EXPORT_SYMBOL(isa_io_base)": {
        "description": "NULL if no ISA bus",
        "proto" :"unknown",
        "pre": {
            "unknown": "unknown",
        },
    }
},


{
    "kretprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE. If there is no passed through device in PE, the EEH errors detected on the PE will be reported and handled as usual.",
        "proto" :"void (*eeh_dev_release)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:eeh_dev_release": {
        "description": "Decrease count of pass through devices for PE. If there is no passed through device in PE, the EEH errors detected on the PE will be reported and handled as usual.",
        "proto" :"void (*eeh_dev_release)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},


{
    "kretprobe:check_legacy_ioport": {
        "description": "Checks the legacy ioport based on the base_port value.",
        "proto" :"static int (*check_legacy_ioport)(unsigned long base_port)",
        "pre": {
            "base_port": "in [I8042_DATA_REG]"
        },
        "post": {
            "ret": "in [-ENODEV, 0]"
        }
    }
},

{
    "kretprobe:pci_domain_nr": {
        "description": "We need to be sure to not use the same PHB number twice.",
        "proto" :"static long (*pci_domain_nr)(struct device_node *dn)",
        "pre": {
            "dn": "!=null"
        },
        "post": {
            "ret": ">=0",
            "prop": ">=0",
            "phb_id": ">=0",
            "phb_bitmap": "!=null"
        }
    }
},
{
    "kprobe:pci_domain_nr": {
        "description": "We need to be sure to not use the same PHB number twice.",
        "proto" :"static long (*pci_domain_nr)(void *dn)",
        "pre": {
            "dn": "!=null"
        },
    },
    "kprobe:of_property_read_u64": {
        "description": "Reads a u64 property from a device node.",
        "proto" :"static int (*of_property_read_u64)(const struct device_node *np, const char *propname, __u64 *out_value)",
        "pre": {
            "np": "!=null",
            "propname": "=='ibm,opal-phbid'",
            "out_value": "!=null"
        },
    },
    "kprobe:of_alias_get_id": {
        "description": "Retrieves an alias id.",
        "proto" :"static int (*of_alias_get_id)(struct device_node *np, const char *stem)",
        "pre": {
            "np": "!=null",
            "stem": "=='pci'"
        },
    },
    "kprobe:of_property_read_u32_index": {
        "description": "Reads a u32 property from a device node at a given index.",
        "proto" :"static int (*of_property_read_u32_index)(const struct device_node *np, const char *propname, int index, u32 *out_value)",
        "pre": {
            "np": "!=null",
            "propname": "=='reg'",
            "index": "==1",
            "out_value": "!=null"
        },
    }
},
{
    "kretprobe:pcibios_bus_add_device": {
        "description": "Setup bus DMA mappings",
        "proto" :"void pcibios_bus_add_device(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_to_host": {
        "description": "Converts a PCI bus to a host bus.",
        "proto": "struct pci_host_bridge *(*pci_bus_to_host)(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    },
    "kprobe:pcibios_bus_add_device": {
        "description": "Adds a device to the PCI bus.",
        "proto": "void (*pcibios_bus_add_device)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:read_dscr": {
        "description": "Fetch the cpu specific DSCR default value. This function returns the per cpu DSCR default value for any cpu which is contained in it's PACA structure.",
        "proto" :"static unsigned long dscr_default;/** * read_dscr() - Fetch the cpu specific DSCR default * @val:Returned cpu specific DSCR default value",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kprobe:read_dscr": {
        "description": "Fetch the cpu specific DSCR default value. This function returns the per cpu DSCR default value for any cpu which is contained in it's PACA structure. This is the system wide DSCR register default value. Any change to this default value through the sysfs interface will update all per cpu DSCR default values across the system stored in their respective PACA structures.",
        "proto" :"static unsigned long (*read_dscr)(unsigned long *val)",
        "pre": {
            "val": "!=null"
        }
    }
},
{
    "kretprobe:btext_update_display": {
        "description": "Check if it's the same frame buffer (within 256MB)",
        "proto" :"static long (*btext_update_display)(unsigned long phys, int width, int height, int depth, int pitch)",
        "pre": {
            "phys": "!=null",
            "width": ">=0",
            "height": ">=0",
            "depth": ">=0",
            "pitch": ">=0"
        },
    }
},
{
    "kprobe:btext_update_display": {
        "description": "Check if it's the same frame buffer (within 256MB)",
        "proto" :"static long (*btext_update_display)(unsigned long phys, int width, int height, int depth, int pitch)",
        "pre": {
            "phys": "!=null",
            "width": ">=0",
            "height": ">=0",
            "depth": ">=0",
            "pitch": ">=0"
        }
    }
},



{
    "__delay": {
        "description": "TB is in error state and isn't ticking anymore. HMI handler was unable to recover from TB error. Return immediately, so that kernel won't get stuck here.",
        "proto" :"void __delay(unsigned long loops)",
        "pre": {
            "loops": ">=0",
        },
    }
},
{
    "kretprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows, with interrupts disabled.",
        "proto" :"void (*timer_interrupt)(int decrementer)",
        "pre": {
            "decrementer": "> 0",
        },
    }
},
{
    "kprobe:DEFINE_INTERRUPT_HANDLER_ASYNC(timer_interrupt)": {
        "description": "Gets called when the decrementer overflows, with interrupts disabled.",
        "proto" :"void (*timer_interrupt)(void *decrementer)",
        "pre": {
            "decrementer": "!=null"
        },
    }
},
{
    "kretprobe:enable_kernel_fp": {
        "description": "Checks if a thread has already been reclaimed then the checkpointed registers are on the CPU but have definitely been saved by the reclaim code. Don't need to and cannot giveup as this would save to the 'live' structure not the checkpointed structure.",
        "proto" :"static void (*enable_kernel_fp)(void)",
        "pre": {
            "current->thread.regs": "!=null",
            "current->thread.regs->msr & MSR_FP": "==true",
            "MSR_TM_ACTIVE(cpumsr)": "==false",
            "MSR_TM_ACTIVE(current->thread.regs->msr)": "==true"
        },
    }
},
{
    "kprobe:enable_kernel_fp": {
        "description": "Checks if a thread has already been reclaimed then the checkpointed registers are on the CPU but have definitely been saved by the reclaim code. Don't need to and cannot giveup as this would save to the 'live' structure not the checkpointed structure.",
        "proto" :"static void (*enable_kernel_fp)(void)",
        "pre": {
            "current->thread.regs": "!=null",
            "current->thread.regs->msr & MSR_FP": "==true",
            "MSR_TM_ACTIVE(cpumsr)": "==false",
            "MSR_TM_ACTIVE(current->thread.regs->msr)": "==true"
        },
    }
},
{
    "kretprobe:enable_kernel_altivec": {
        "description": "If a thread has already been reclaimed then the checkpointed registers are on the CPU but have definitely been saved by the reclaim code. Don't need to and cannot giveup as this would save to the 'live' structure not the checkpointed structure.",
        "proto" :"void enable_kernel_altivec(void)",
        "pre": {
            "cpumsr": "!=null",
            "current->thread.regs": "!=null",
            "current->thread.regs->msr": "& MSR_VEC"
        },
    }
},
{
    "kprobe:enable_kernel_altivec": {
        "description": "Checks if a thread has already been reclaimed then the checkpointed registers are on the CPU but have definitely been saved by the reclaim code. Don't need to and cannot giveup as this would save to the 'live' structure not the checkpointed structure.",
        "proto" :"void enable_kernel_altivec(void)",
        "pre": {
            "cpumsr": "!=null",
            "current->thread.regs": "!=null",
            "current->thread.regs->msr": "& MSR_VEC",
            "MSR_TM_ACTIVE(cpumsr)": "!=true",
            "MSR_TM_ACTIVE(current->thread.regs->msr)": "==true"
        },
    }
},
{
    "kretprobe:enable_kernel_vsx": {
        "description": "Checks if a thread has already been reclaimed and if the checkpointed registers are on the CPU.",
        "proto" :"static void (*enable_kernel_vsx)(void)",
        "pre": {
            "current->thread.regs": "!=null",
            "current->thread.regs->msr": "in [MSR_VSX, MSR_VEC, MSR_FP]"
        },
        "post": {
            "cpumsr": "MSR_FP|MSR_VEC|MSR_VSX",
            "reclaim": "done",
            "checkpointed_registers": "on CPU"
        }
    }
},
{
    "kprobe:enable_kernel_vsx": {
        "description": "If a thread has already been reclaimed then the checkpointed registers are on the CPU but have definitely been saved by the reclaim code. Don't need to and cannot giveup as this would save to the 'live' structure not the checkpointed structure.",
        "proto" :"void enable_kernel_vsx(void)",
        "pre": {
            "cpumsr": "!=null",
            "current->thread.regs": "!=null",
            "current->thread.regs->msr": "in [MSR_VSX, MSR_VEC, MSR_FP]"
        },
    }
},
{
    "kretprobe:start_thread": {
        "description": "Starts a new thread with the given register state, start address, and stack pointer.",
        "proto" :"void start_thread(struct pt_regs *regs, unsigned long start, unsigned long sp)",
        "pre": {
            "regs": "!=null",
            "start": "is valid memory address",
            "sp": "is valid memory address"
        },
    }
},
{
    "kprobe:start_thread": {
        "description": "Starts a new thread with the given register state, start address, and stack pointer.",
        "proto" :"void start_thread(struct pt_regs *regs, unsigned long start, unsigned long sp)",
        "pre": {
            "regs": "!=null",
            "start": "is valid memory address",
            "sp": "is valid memory address"
        },
    }
},
{
    "kretprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device. This looks for a property 'ibm,chip-id' in the node or any of its parents and returns its content, or -1 if it cannot be found.",
        "proto" :"int (*of_get_ibm_chip_id)(struct device_node *np)",
        "pre": {
            "np": "!=null"
        },
        "post": {
            "return": "in [-1, 0, INT_MAX]"
        }
    }
},
{
    "kprobe:of_get_ibm_chip_id": {
        "description": "Returns the IBM 'chip-id' of a device. This looks for a property 'ibm,chip-id' in the node or any of its parents and returns its content, or -1 if it cannot be found.",
        "proto" :"int (*of_get_ibm_chip_id)(struct device_node *np)",
        "pre": {
            "np": "!=null"
        },
    }
},
{
    "kretprobe:cpu_to_chip_id": {
        "description": "Return the value of the ibm,chip-id property corresponding to the given logical cpu number. If the chip-id can not be found, returns -1.",
        "proto" :"int cpu_to_chip_id(int cpu)",
        "pre": {
            "cpu": ">=0"
        },
        "post": {
            "return": ">=-1"
        }
    }
},
{
    "kprobe:cpu_to_chip_id": {
        "description": "Return the value of the ibm,chip-id property corresponding to the given logical cpu number. If the chip-id can not be found, returns -1.",
        "proto" :"int cpu_to_chip_id(int cpu)",
        "pre": {
            "cpu": "is a logical cpu number"
        },
        "post": {
            "return": "is the chip-id corresponding to the given logical cpu number or -1 if the chip-id cannot be found"
        }
    }
},
{
    "kretprobe:pci_device_from_OF_node": {
        "description": "Check if it might have a chance to be a PCI device",
        "proto" :"static long (*pci_device_from_OF_node)(struct device_node *node, u8 *bus, u8 *devfn)",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, 0]"
        }
    }
},
{
    "kprobe:pci_device_from_OF_node": {
        "description": "Check if it might have a chance to be a PCI device",
        "proto" :"static long (*pci_device_from_OF_node)(struct device_node *node, u8 *bus, u8 *devfn)",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": "!=null"
        },
    }
},
{
    "kretprobe:arch_local_irq_restore": {
        "description": "Restore the interrupt state previously saved by local_irq_save",
        "proto" :"void arch_local_irq_restore(unsigned long flags)",
        "pre": {
            "flags": ">=0",
        },
    }
},
{
    "kprobe:__replay_soft_interrupts;irq_exit;...": {
        "description": "arch_local_irq_restore",
        "proto" :"static inline __no_kcsan void replay_soft_interrupts_irqrestore(void)",
        "pre": {
            // Here you should specify the preconditions for your function.
            // Since your function does not seem to have any arguments, there might not be any preconditions.
        },
    }
},
{
    "kretprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bus, create a pci_dev. @node: device tree node pointer. @bus: bus the device is sitting on. @devfn: PCI function number, extracted from device tree by caller.",
        "proto" :"struct pci_dev *(*of_create_pci_dev)(struct device_node *node, struct pci_bus *bus, int devfn)",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": ">=0"
        },
    }
},
{
    "kprobe:of_create_pci_dev": {
        "description": "Given a device tree node on a pci bus, create a pci_dev. @node: device tree node pointer. @bus: bus the device is sitting on. @devfn: PCI function number, extracted from device tree by caller.",
        "proto" :"struct pci_dev *(*of_create_pci_dev)(struct device_node *node, struct pci_bus *bus, int devfn)",
        "pre": {
            "node": "!=null",
            "bus": "!=null",
            "devfn": ">=0"
        },
    }
},
{
    "kretprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes. This routine is called for each PCI bridge that it finds, and this routine in turn calls of_scan_bus() recursively to scan for more child devices.",
        "proto" :"void (*of_scan_pci_bridge)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_scan_pci_bridge": {
        "description": "Set up a PCI bridge and scan for child nodes. of_scan_bus() calls this routine for each PCI bridge that it finds, and this routine in turn call of_scan_bus() recursively to scan for more child devices.",
        "proto" :"void (*of_scan_pci_bridge)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Get page shift, work out hash and AVPN etc.",
        "proto" :"static long (*kvmppc_hv_find_lock_hpte)(struct kvm  kvm, gva_t eaddr, unsigned long slb_v, unsigned long valid)",
        "pre": {
            "kvm": "!=null",
            "eaddr": "is valid gva_t",
            "slb_v": "is valid unsigned long",
            "valid": "is valid unsigned long"
        },
    }
},
{
    "kprobe:kvmppc_hv_find_lock_hpte": {
        "description": "Your description here",
        "proto" :"static long (*kvmppc_hv_find_lock_hpte)(struct kvm  kvm, gva_t eaddr, unsigned long slb_v, unsigned long valid)",
        "pre": {
            "kvm": "Your condition here",
            "eaddr": "Your condition here",
            "slb_v": "Your condition here",
            "valid": "Your condition here"
        },
    }
},

{
    "kprobe:memcpy": {
        "description": "Copies n bytes from memory area src to memory area dest. The memory areas must not overlap.",
        "proto" :"void* (*memcpy)(void* dest, const void* src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0",
        },
    }
},

{
    "kprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[arg1]": "[Constraint]",
            "[arg2]": "[Constraint]",
            "[arg3]": "[Constraint]",
            "[arg4]": "[Constraint]",
        },
    }
},
{
    "kretprobe:iounmap": {
        "description": "If the page is from the fixmap pool then we just clear out the fixmap mapping.",
        "proto" :"void iounmap(volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null && (unsigned long)addr > FIXADDR_START"
        }
    }
},
{
    "kprobe:iounmap": {
        "description": "If the page is from the fixmap pool then we just clear out the fixmap mapping.",
        "proto" :"static void (*iounmap)(volatile void __iomem *addr)",
        "pre": {
            "addr": "!=null && (unsigned long)addr > FIXADDR_START"
        }
    }
},
{
    "kretprobe:default_power_off": {
        "description": "pm_power_off has not been set by a power management driver, in this case we can assume we are on a simulator. On OpenRISC simulators l.nop 1 will trigger the simulator exit.",
        "proto" :"static void default_power_off(void)",
        "pre": {
        },
    }
},
{
    "kprobe:default_power_off": {
        "description": "pm_power_off has not been set by a power management driver, in this case we can assume we are on a simulator. On OpenRISC simulators l.nop 1 will trigger the simulator exit.",
        "proto" :"static void (*default_power_off)(void)",
        "pre": {}
    }
},
{
    "kretprobe:__pollwait": {
        "description": "poll_wait() is an inline-function defined in <linuxpoll.h>, as all selectpoll functions have to call it to add an entry to the poll table.",
        "proto" :"static void __pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)",
        "pre": {
            "filp": "!=null",
            "wait_address": "!=null",
            "p": "!=null"
        }
    },
    "kretprobe:poll_initwait": {
        "description": "poll_freewait() make all the work.",
        "proto" :"void poll_initwait(struct poll_wqueues *pwq)",
        "pre": {
            "pwq": "!=null"
        }
    }
},
{
    "kprobe:__pollwait": {
        "description": "poll_wait() is an inline-function defined in <linuxpoll.h>, as all selectpoll functions have to call it to add an entry to the poll table.",
        "proto" :"static void __pollwait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p)",
        "pre": {
            "filp": "your_condition_here",
            "wait_address": "your_condition_here",
            "p": "your_condition_here"
        },
    },
    "kprobe:poll_initwait": {
        "description": "poll_freewait() make all the work.",
        "proto" :"void poll_initwait(struct poll_wqueues *pwq)",
        "pre": {
            "pwq": "your_condition_here"
        },
    }
},


{
    "kretprobe:function_name": {
        "description": "Your function description here.",
        "proto" :"int (*function_name)(type1 arg1, type2 arg2, type3 arg3)",
        "pre": {
            "arg1": "your condition here",
            "arg2": "your condition here",
            "arg3": "your condition here"
        },
    }
},

{
    "kretprobe:fast_dput": {
        "description": "dput(), and return whether that was successful. If unsuccessful, we return false, having already taken the dentry lock. The caller needs to hold the RCU read lock, so that the dentry is guaranteed to stay around even if the refcount goes down to zero!",
        "proto" :"static inline bool (*fast_dput)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        },
    }
},
{
    "kprobe:fast_dput": {
        "description": "dput(), and return whether that was successful. If unsuccessful, we return false, having already taken the dentry lock. The caller needs to hold the RCU read lock, so that the dentry is guaranteed to stay around even if the refcount goes down to zero!",
        "proto" :"static inline bool (*fast_dput)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null",
            "caller": "holds RCU read lock"
        },
    }
},
{
    "kretprobe:dget_parent": {
        "description": "Do optimistic parent lookup without any locking.",
        "proto" :"dget_parent(struct dentry  dentry){int gotref;struct dentry  ret;unsigned seq;}",
        "pre": {
            "dentry": "!=null",
            "gotref": "your_condition_here",
            "ret": "your_condition_here",
            "seq": "your_condition_here"
        },
    }
},
{
    "kprobe:dget_parent": {
        "description": "Do optimistic parent lookup without any locking.",
        "proto" :"dget_parent(struct dentry  dentry){int gotref;struct dentry  ret;unsigned seq;}",
        "pre": {
            "dentry": "!=null",
            "gotref": "your_condition_here",
            "ret": "your_condition_here",
            "seq": "your_condition_here"
        },
    }
},
{
    "kretprobe:d_find_any_alias": {
        "description": "Find any alias for a given inode. If any aliases exist for the given inode, take and return a reference for one of them. If no aliases exist, return NULL.",
        "proto" :"struct dentry *(*d_find_any_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:d_find_any_alias": {
        "description": "Find any alias for a given inode. If any aliases exist for the given inode, take and return a reference for one of them. If no aliases exist, return %NULL.",
        "proto" :"struct dentry *(*d_find_any_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:d_find_alias": {
        "description": "Grab a hashed alias of inode. If inode has a hashed alias, or is a directory and has any alias, acquire the reference to alias and return it. Otherwise return NULL.",
        "proto" :"struct dentry *(*d_find_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:d_find_alias": {
        "description": "Grab a hashed alias of inode. If inode has a hashed alias, or is a directory and has any alias, acquire the reference to alias and return it. Otherwise return NULL.",
        "proto" :"struct dentry *(*d_find_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
    }
},
{
    "kretprobe:shrink_dcache_sb": {
        "description": "Shrink the dcache for the specified super block. This is used to free the dcache before unmounting a file system.",
        "proto" :"void (*shrink_dcache_sb)(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_sb": {
        "description": "Shrink the dcache for the specified super block. This is used to free the dcache before unmounting a file system.",
        "proto" :"void (*shrink_dcache_sb)(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace. Return true if the parent or its subdirectories contain a mount point in the current namespace.",
        "proto" :"int (*path_has_submounts)(const struct path *parent)",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:path_has_submounts": {
        "description": "Check for mounts over a dentry in the current namespace. Return true if the parent or its subdirectories contain a mount point in the current namespace.",
        "proto" :"int (*path_has_submounts)(const struct path *parent)",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "proto": "void (*shrink_dcache_parent)(struct dentry *parent)",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kprobe:shrink_dcache_parent": {
        "description": "Prune the dcache to remove unused children of the parent dentry.",
        "proto" :"void (*shrink_dcache_parent)(struct dentry *parent)",
        "pre": {
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:d_set_mounted": {
        "description": "d_invalidate() and d_set_mounted() must succeed. For this reason take rename_lock and d_lock on dentry and ancestors.",
        "proto" :"int (*d_set_mounted)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        },
    }
},
{
    "kprobe:d_set_mounted": {
        "description": "d_invalidate() and d_set_mounted() must succeed. For this reason take rename_lock and d_lock on dentry and ancestors.",
        "proto" :"int (*d_set_mounted)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:__d_alloc": {
        "description": "Allocates a dentry. It returns %NULL if there is insufficient memory available. On a success the dentry is returned. The name passed in is copied and the copy passed in may be reused after this call.",
        "proto" :"static struct dentry *(__d_alloc)(struct super_block *sb, const struct qstr *name)",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:__d_alloc": {
        "description": "Allocates a dentry. It returns %NULL if there is insufficient memory available. On a success the dentry is returned. The name passed in is copied and the copy passed in may be reused after this call.",
        "proto" :"static struct dentry *(__d_alloc)(struct super_block *sb, const struct qstr *name)",
        "pre": {
            "sb": "!=null",
            "name": "!=null"
        },
    }
},
{
    "kretprobe:d_alloc": {
        "description": "Allocates a dentry. It returns %NULL if there is insufficient memory available. On a success the dentry is returned. The name passed in is copied and the copy passed in may be reused after this call.",
        "proto" :"struct dentry *(*d_alloc)(struct dentry *parent, const struct qstr *name)",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:d_alloc": {
        "description": "Allocates a dentry. It returns %NULL if there is insufficient memory available. On a success the dentry is returned. The name passed in is copied and the copy passed in may be reused after this call.",
        "proto" :"struct dentry *(*d_alloc)(struct dentry *parent, const struct qstr *name)",
        "pre": {
            "parent": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer. This flag may be recorded on the medium.",
        "proto": "void (*d_set_fallthru)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:d_set_fallthru": {
        "description": "Mark a dentry as falling through to a lower layer. This flag may be recorded on the medium.",
        "proto" :"static void (*d_set_fallthru)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:d_instantiate": {
        "description": "Fill in inode information in the entry. This turns negative dentries into productive full members of society. This assumes that the inode count has been incremented (or otherwise set) by the caller to indicate that it is now in use by the dcache.",
        "proto" :"void d_instantiate(struct dentry *dentry, struct inode *inode)",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null"
        },
    }
},
{
    "kprobe:d_instantiate": {
        "description": "Decrement negative dentry count if it was in the LRU list.",
        "proto" :"d_instantiate(struct dentry  dentry, struct inode  inode)",
        "pre": {
            "dentry": "your_condition_here",
            "inode": "your_condition_here"
        },
    }
},
{
    "kretprobe:d_instantiate_anon": {
        "description": "Attach a disconnected dentry",
        "proto" :"static struct dentry (*d_instantiate_anon)(struct dentry *dentry, struct inode *inode, bool disconnected)",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "is [true, false]"
        },
    }
},
{
    "kprobe:d_instantiate_anon": {
        "description": "Attach a disconnected dentry",
        "proto" :"void d_instantiate_anon(struct dentry *dentry, struct inode *inode, bool disconnected)",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "disconnected": "in [true, false]"
        },
    }
},
{
    "kretprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode. The returned dentry may be anonymous, or may have a full name (if the inode was already in the cache). When called on a directory inode, we must ensure that the inode only ever has one dentry. If a dentry is found, that is returned instead of allocating a new one. On successful return, the reference to the inode has been transferred to the dentry. In case of an error the reference on the inode is released. To make it easier to use in export operations a %NULL or IS_ERR inode may be passed in and the error will be propagated to the return value, with a %NULL @inode replaced by ERR_PTR(-ESTALE).",
        "proto": "struct dentry *(*d_obtain_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:d_obtain_alias": {
        "description": "Find or allocate a DISCONNECTED dentry for a given inode. The returned dentry may be anonymous, or may have a full name (if the inode was already in the cache). When called on a directory inode, we must ensure that the inode only ever has one dentry. If a dentry is found, that is returned instead of allocating a new one. On successful return, the reference to the inode has been transferred to the dentry. In case of an error the reference on the inode is released. To make it easier to use in export operations a %NULL or IS_ERR inode may be passed in and the error will be propagated to the return value, with a %NULL @inode replaced by ERR_PTR(-ESTALE).",
        "proto" :"struct dentry *(*d_obtain_alias)(struct inode *inode)",
        "pre": {
            "inode": "!=null && !IS_ERR(inode)"
        }
    }
},
{
    "kretprobe:__d_drop": {
        "description": "d_obtain_root, which are always IS_ROOT",
        "proto" :"void __d_drop(struct dentry *dentry)",
        "pre": {
            "dentry": "IS_ROOT"
        }
    }
},
{
    "kprobe:__d_drop": {
        "description": "Description of the function goes here",
        "proto" :"void __d_drop(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null",
        },
    }
},
{
    "kretprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name. This is to avoid filling the dcache with case-insensitive names to the same inode, only the actual correct case is stored in the dcache for case-insensitive filesystems. For a case-insensitive lookup match and if the case-exact dentry already exists in the dcache, use it and return it. If no entry exists with the exact case name, allocate new dentry with the exact case, and return the spliced entry.",
        "proto" :"struct dentry *(*d_add_ci)(struct dentry *dentry, struct inode *inode, struct qstr *name)",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null && is case-exact"
        }
    }
},
{
    "kprobe:d_add_ci": {
        "description": "Lookup or allocate new dentry with case-exact name. This is to avoid filling the dcache with case-insensitive names to the same inode, only the actual correct case is stored in the dcache for case-insensitive filesystems. For a case-insensitive lookup match and if the case-exact dentry already exists in the dcache, use it and return it. If no entry exists with the exact case name, allocate new dentry with the exact case, and return the spliced entry.",
        "proto" :"struct dentry *(*d_add_ci)(struct dentry *dentry, struct inode *inode, struct qstr *name)",
        "pre": {
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name. Returns true if names are same, or false.",
        "proto" :"bool (*d_same_name)(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)",
        "pre": {
            "dentry": "!=null",
            "parent": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:d_same_name": {
        "description": "Compare dentry name with case-exact name. Returns true if names are same, or false.",
        "proto" :"bool (*d_same_name)(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)",
        "pre": {
            "dentry": "!=null",
            "parent": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:d_drop": {
        "description": "d_drop will just make the cache lookup fail. d_drop() is used mainly for stuff that wants to invalidate a dentry for some reason (NFS timeouts or autofs deletes).",
        "proto" :"void (*d_drop)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:d_drop": {
        "description": "d_drop will just make the cache lookup fail. It is used mainly for stuff that wants to invalidate a dentry for some reason (NFS timeouts or autofs deletes). __d_drop requires dentry->d_lock. ___d_drop doesn't mark dentry as 'unhashed' (dentry->d_hash.pprev will be LIST_POISON2, not NULL).",
        "proto" :"void (*d_drop)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:d_rehash": {
        "description": "Adds a dentry to the hash according to its name.",
        "proto" :"void (*d_rehash)(struct dentry * entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:d_rehash": {
        "description": "Adds a dentry to the hash according to its name.",
        "proto" :"void d_rehash(struct dentry * entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias. If an unhashed dentry with the same name, parent and desired inode already exists, hash and return it. Otherwise, return NULL. Parent directory should be locked.",
        "proto": "struct dentry *(*d_exact_alias)(struct dentry *entry, struct inode *inode)",
        "pre": {
            "entry": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [hashed dentry, NULL]"
        }
    }
},
{
    "kprobe:d_exact_alias": {
        "description": "Find and hash an exact unhashed alias. If an unhashed dentry with the same nameparent and desired inode already exists, hash and return it. Otherwise, return NULL. Parent directory should be locked.",
        "proto" :"struct dentry *(*d_exact_alias)(struct dentry *entry, struct inode *inode)",
        "pre": {
            "entry": "!=null",
            "inode": "!=null"
        }
    }
},


{
    "kretprobe:is_subdir": {
        "description": "Returns true if new_dentry is a subdirectory of the parent (at any depth). Returns false otherwise. Caller must ensure that 'new_dentry' is pinned before calling is_subdir()",
        "proto" :"bool (*is_subdir)(struct dentry *new_dentry, struct dentry *old_dentry)",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:is_subdir": {
        "description": "Returns true if new_dentry is a subdirectory of the parent (at any depth). Returns false otherwise. Caller must ensure that 'new_dentry' is pinned before calling is_subdir()",
        "proto" :"bool (*is_subdir)(struct dentry *new_dentry, struct dentry *old_dentry)",
        "pre": {
            "new_dentry": "!=null",
            "old_dentry": "!=null"
        }
    }
},
{
    "kretprobe:d_path": {
        "description": "This function is used to generate a textual path for the given directory entry 'dentry' and mount 'mnt'. It places the path in the buffer pointed to by 'p'.",
        "proto" :"d_path(const struct dentry  dentry, const struct mount  mnt,  const struct path  root, struct prepend_buffer  p)",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "root": "!=null",
            "p": "!=null"
        },
    }
},
{
    "kprobe:d_path": {
        "description": "This function is used to get the path of a file or directory. It traverses the dentry and mount structures until it reaches the root.",
        "proto" :"d_path(const struct dentry  dentry, const struct mount  mnt,  const struct path  root, struct prepend_buffer  p)",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "root": "!=null",
            "p": "!=null"
        },
    }
},
{
    "kretprobe:simple_setattr": {
        "description": "simple_setattr is a simple ->setattr implementation without a proper implementation of size changes. It can either be used for in-memory filesystems or special files on simple regular filesystems. Anything that needs to change on-disk or wire state on size changes needs its own setattr method.",
        "proto" :"int (*simple_setattr)(struct mnt_idmap *idmap, struct dentry *dentry, struct iattr *iattr)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        },
        "post": {
            "return": "in [0, -error]"
        }
    }
},
{
    "kprobe:simple_setattr": {
        "description": "simple_setattr is a simple ->setattr implementation without a proper implementation of size changes. It can either be used for in-memory filesystems or special files on simple regular filesystems. Anything that needs to change on-disk or wire state on size changes needs its own setattr method.",
        "proto" :"int (*simple_setattr)(struct mnt_idmap *idmap, struct dentry *dentry, struct iattr *iattr)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "iattr": "!=null"
        },
    }
},
{
    "kretprobe:simple_fill_super": {
        "description": "Fills the super block structure and creates a new inode.",
        "proto" :"static long (*simple_fill_super)(struct super_block *s, unsigned long magic, const struct tree_descr *files)",
        "pre": {
            "s->s_blocksize": "== PAGE_SIZE",
            "s->s_magic": "== magic",
            "s->s_time_gran": "== 1",
            "inode": "!=null",
            "root": "!=null",
            "files": "!=null && files->name[0] != 1"
        },
    }
},

{
    "kretprobe:simple_read_from_buffer": {
        "description": "The simple_read_from_buffer() function reads up to @count bytes from the buffer @from at offset @ppos into the user space address starting at @to. On success, the number of bytes read is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*simple_read_from_buffer)(void __user *to, size_t count, loff_t *ppos, const void *from, size_t available)",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        },
    }
},
{
    "kprobe:simple_read_from_buffer": {
        "description": "The simple_read_from_buffer() function reads up to @count bytes from the buffer @from at offset @ppos into the user space address starting at @to. On success, the number of bytes read is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*simple_read_from_buffer)(void __user *to, size_t count, loff_t *ppos, const void *from, size_t available)",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        },
    }
},
{
    "kretprobe:simple_write_to_buffer": {
        "description": "The simple_write_to_buffer() function reads up to @count bytes from the user space address starting at @from into the buffer @to at offset @ppos. On success, the number of bytes written is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*simple_write_to_buffer)(void *to, size_t available, loff_t *ppos, const void __user *from, size_t count)",
        "pre": {
            "to": "!=null",
            "available": ">0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kprobe:simple_write_to_buffer": {
        "description": "The simple_write_to_buffer() function reads up to @count bytes from the user space address starting at @from into the buffer @to at offset @ppos. On success, the number of bytes written is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*simple_write_to_buffer)(void *to, size_t available, loff_t *ppos, const void __user *from, size_t count)",
        "pre": {
            "to": "!=null",
            "available": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "count": ">=0"
        },
    }
},
{
    "kretprobe:memory_read_from_buffer": {
        "description": "The memory_read_from_buffer() function reads up to @count bytes from the buffer @from at offset @ppos into the kernel space address starting at @to. On success, the number of bytes read is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*memory_read_from_buffer)(void *to, size_t count, loff_t *ppos, const void *from, size_t available)",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        },
        "post": {
            "return": "in [-1, count]"
        }
    }
},
{
    "kprobe:memory_read_from_buffer": {
        "description": "The memory_read_from_buffer() function reads up to @count bytes from the buffer @from at offset @ppos into the kernel space address starting at @to. On success, the number of bytes read is returned and the offset @ppos is advanced by this number, or negative value is returned on error.",
        "proto" :"ssize_t (*memory_read_from_buffer)(void *to, size_t count, loff_t *ppos, const void *from, size_t available)",
        "pre": {
            "to": "!=null",
            "count": ">=0",
            "ppos": "!=null",
            "from": "!=null",
            "available": ">=0"
        },
    }
},
{
    "kretprobe:simple_transaction_set": {
        "description": "The barrier ensures that ar->size will really remain zero until ar->data is ready for reading.",
        "proto" :"static void (*simple_transaction_set)(struct file *file, size_t n)",
        "pre": {
            "file": "!=null",
            "n": "<= SIMPLE_TRANSACTION_LIMIT"
        },
    }
},
{
    "kprobe:simple_transaction_set": {
        "description": "The barrier ensures that ar->size will really remain zero until ar->data is ready for reading.",
        "proto" :"static void (*simple_transaction_set)(struct file *file, size_t n)",
        "pre": {
            "file": "!=null",
            "n": "<= SIMPLE_TRANSACTION_LIMIT"
        }
    }
},
{
    "kretprobe:simple_transaction_get": {
        "description": "Get a simple transaction. If the size is greater than SIMPLE_TRANSACTION_LIMIT - 1, return ERR_PTR(-EFBIG). If ar is null, return ERR_PTR(-ENOMEM). Only one write is allowed per open.",
        "proto" :"struct simple_transaction_argresp (*simple_transaction_get)(struct file *file, const char __user *buf, size_t size)",
        "pre": {
            "file": "!=null",
            "file->private_data": "!=null",
            "buf": "!=null",
            "size": "<= SIMPLE_TRANSACTION_LIMIT - 1"
        },
    }
},
{
    "kprobe:simple_transaction_get": {
        "description": "This function gets a simple transaction. It checks if the size is greater than SIMPLE_TRANSACTION_LIMIT - 1, and if so, returns an error. It also checks if the file's private_data is not null.",
        "proto" :"static struct simple_transaction_argresp (*simple_transaction_get)(struct file *file, const char __user *buf, size_t size)",
        "pre": {
            "file": "!=null",
            "file->private_data": "!=null",
            "buf": "!=null",
            "size": "< SIMPLE_TRANSACTION_LIMIT"
        },
    }
},
{
    "kretprobe:__generic_file_fsync": {
        "description": "This is a generic implementation of the fsync method for simple filesystems which track all non-inode metadata in the buffers list hanging off the address_space structure.",
        "proto" :"int (__generic_file_fsync)(struct file *file, loff_t start, loff_t end, int datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:__generic_file_fsync": {
        "description": "This is a generic implementation of the fsync method for simple filesystems which track all non-inode metadata in the buffers list hanging off the address_space structure.",
        "proto" :"int (*__generic_file_fsync)(struct file *file, loff_t start, loff_t end, int datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:generic_check_addressable": {
        "description": "Check addressability of file system. Determine whether a file system with @num_blocks blocks (and a block size of 2 @blocksize_bits) is addressable by the sector_t and page cache of the system. Return 0 if so and -EFBIG otherwise.",
        "proto" :"int (*generic_check_addressable)(unsigned blocksize_bits, u64 num_blocks)",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        },
        "post": {
            "return": "in [0, -EFBIG]"
        }
    }
},
{
    "kprobe:generic_check_addressable": {
        "description": "Check addressability of file system. Determine whether a file system with @num_blocks blocks (and a block size of 2 @blocksize_bits) is addressable by the sector_t and page cache of the system. Return 0 if so and -EFBIG otherwise.",
        "proto" :"int (*generic_check_addressable)(unsigned blocksize_bits, u64 num_blocks)",
        "pre": {
            "blocksize_bits": ">=0",
            "num_blocks": ">=0"
        }
    }
},


{
    "kretprobe:alloc_anon_inode": {
        "description": "Mark the inode dirty from the very beginning, that way it will never be moved to the dirty list because mark_inode_dirty() will think that it already _is_ on the dirty list.",
        "proto" :"struct inode *(*alloc_anon_inode)(struct super_block *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "inode->i_state": "== I_DIRTY",
            "inode->i_mode": "== S_IRUSR | S_IWUSR",
            "inode->i_uid": "== current_fsuid()",
            "inode->i_gid": "== current_fsgid()",
            "inode->i_flags": "contains S_PRIVATE",
            "inode->i_atime": "== inode->i_mtime == inode->i_ctime == current_time(inode)",
            "return": "!=null"
        }
    }
},
{
    "kprobe:alloc_anon_inode": {
        "description": "Allocates an anonymous inode and marks it as dirty from the very beginning. This ensures that it will never be moved to the dirty list because mark_inode_dirty() will think that it already _is_ on the dirty list.",
        "proto" :"struct inode *(*alloc_anon_inode)(struct super_block *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "inode->i_state": "== I_DIRTY",
            "inode->i_mode": "== S_IRUSR | S_IWUSR",
            "inode->i_uid": "== current_fsuid()",
            "inode->i_gid": "== current_fsgid()",
            "inode->i_flags": "contains S_PRIVATE",
            "inode->i_atime": "== inode->i_mtime == inode->i_ctime == current_time(inode)",
            "return": "!=null"
        }
    }
},
{
    "kretprobe:intsimple_nosetlease": {
        "description": "Generic helper for filesystems that do not wish to allow leases to be set. All arguments are ignored and it just returns -EINVAL.",
        "proto" :"static long (*intsimple_nosetlease)(struct file *filp, long arg, struct file_lock **flp,  void **priv)",
        "pre": {
            "filp": "ignored",
            "arg": "ignored",
            "flp": "ignored",
            "priv": "ignored"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kprobe:intsimple_nosetlease": {
        "description": "Generic helper for filesystems that do not wish to allow leases to be set. All arguments are ignored and it just returns -EINVAL.",
        "proto" :"static long (*intsimple_nosetlease)(struct file *filp, long arg, struct file_lock **flp,  void **priv)",
        "pre": {
            "filp": "ignored",
            "arg": "ignored",
            "flp": "ignored",
            "priv": "ignored"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kretprobe:simple_get_link": {
        "description": "Generic helper for filesystems to use for symlink inodes where a pointer to the symlink target is stored in ->i_link. This isn't normally called, since as an optimization the path lookup code uses any non-NULL ->i_link directly, without calling ->get_link(). But ->get_link() still must be set, to mark the inode_operations as being for a symlink.",
        "proto" :"const char *(*simple_get_link)(struct dentry *dentry, struct inode *inode, struct delayed_call *done)",
        "pre": {
            "dentry": "not used",
            "inode": "!=null",
            "done": "not used"
        },
    }
},
{
    "kprobe:simple_get_link": {
        "description": "Generic helper for filesystems to use for symlink inodes where a pointer to the symlink target is stored in ->i_link. This isn't normally called, since as an optimization the path lookup code uses any non-NULL ->i_link directly, without calling ->get_link(). But ->get_link() still must be set, to mark the inode_operations as being for a symlink.",
        "proto" :"const char *(*simple_get_link)(struct dentry *dentry, struct inode *inode, struct delayed_call *done)",
        "pre": {
            "dentry": "not used",
            "inode": "!=null",
            "done": "not used"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry. Casefolded directories need d_hash and d_compare set, so that the dentries contained in them are handled case-insensitively. Encryption works differently in that the only dentry operation it needs is d_revalidate, which it only needs on dentries that have the no-key name flag. To maximize compatibility with overlayfs and to avoid taking an unnecessary performance hit, we use custom dentry_operations for each possible combination rather than always installing all operations.",
        "proto" :"void (*generic_set_encrypted_ci_d_ops)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:generic_set_encrypted_ci_d_ops": {
        "description": "Helper for setting d_ops for given dentry. Casefolded directories need d_hash and d_compare set, so that the dentries contained in them are handled case-insensitively. Note that these operations are needed on the parent directory rather than on the dentries in it, and while the casefolding flag can be toggled on and off on an empty directory, dentry_operations can't be changed later. As a result, if the filesystem has casefolding support enabled at all, we have to give all dentries the casefolding operations even if their inode doesn't have the casefolding flag currently (and thus the casefolding ops would be no-ops for now). Encryption works differently in that the only dentry operation it needs is d_revalidate, which it only needs on dentries that have the no-key name flag. The no-key flag can't be set 'later', so we don't have to worry about that. Finally, to maximize compatibility with overlayfs (which isn't compatible with certain dentry operations) and to avoid taking an unnecessary performance hit, we use custom dentry_operations for each possible combination rather than always installing all operations.",
        "proto" :"void (*generic_set_encrypted_ci_d_ops)(struct dentry *dentry)",
        "pre": {
            "dentry": "!=null"
        }
    }
},
{
    "kretprobe:inode_maybe_inc_iversion": {
        "description": "Every time the inode is modified, the i_version field must be seen to have changed by any observer. If 'force' is set or the QUERIED flag is set, then ensure that we increment the value, and clear the queried flag. In the common case where neither is set, then we can return 'false' without updating i_version. If this function returns false, and no other metadata has changed, then we can avoid logging the metadata.",
        "proto" :"bool (*inode_maybe_inc_iversion)(struct inode *inode, bool force)",
        "pre": {
            "inode": "!=null",
            "force": "in [true, false]"
        },
    }
},
{
    "kprobe:inode_maybe_inc_iversion": {
        "description": "Every time the inode is modified, the i_version field must be seen to have changed by any observer. If 'force' is set or the QUERIED flag is set, then ensure that we increment the value, and clear the queried flag. In the common case where neither is set, then we can return 'false' without updating i_version. If this function returns false, and no other metadata has changed, then we can avoid logging the metadata.",
        "proto" :"bool (*inode_maybe_inc_iversion)(struct inode *inode, bool force)",
        "pre": {
            "inode": "!=null",
            "force": "is boolean"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[param1 conditions]",
            "[param2]": "[param2 conditions]",
            "[param3]": "[param3 conditions]",
            "[param4]": "[param4 conditions]",
        },
    }
},

{
    "kretprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table.",
        "proto": "int lookup_constant(const struct constant_table *tbl, const char *name, int not_found)",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "is int"
        },
        "post": {
            "return": "in tbl or == not_found"
        }
    }
},
{
    "kprobe:lookup_constant": {
        "description": "Look up a constant by name in an ordered table. If the name is not found, return the value of not_found.",
        "proto" :"int (*lookup_constant)(const struct constant_table *tbl, const char *name, int not_found)",
        "pre": {
            "tbl": "!=null",
            "name": "!=null",
            "not_found": "is int"
        },
    }
},
{
    "kretprobe:__fs_parse": {
        "description": "Description of the function",
        "proto" :"__fs_parse(struct p_log  log, const struct fs_parameter_spec  desc, struct fs_parameter  param, struct fs_parse_result  result)",
        "pre": {
            "log": "!=null",
            "desc": "!=null",
            "param": "!=null",
            "result": "!=null"
        },
    }
},
{
    "kprobe:__fs_parse": {
        "description": "Parses a filesystem parameter, checks if it's deprecated, and tries to convert the given type into the desired type.",
        "proto" :"__fs_parse(struct p_log  log, const struct fs_parameter_spec  desc, struct fs_parameter  param, struct fs_parse_result  result)",
        "pre": {
            "log": "!=null",
            "desc": "!=null",
            "param": "!=null",
            "result": "!=null",
            "p": "is_flag(p)"
        },
    }
},
{
    "kretprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter. The filesystem context to log errors through. The parameter. T if want a blockdev. Pathwalk flags passed to filename_lookup(). The result of the lookup.",
        "proto" :"int fs_lookup_param(struct fs_context *fc, struct fs_parameter *param, bool want_bdev, unsigned int flags, struct path *_path)",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "unsigned int",
            "_path": "!=null"
        }
    }
},
{
    "kprobe:fs_lookup_param": {
        "description": "Look up a path referred to by a parameter. The filesystem context to log errors through. The parameter. T if want a blockdev. Pathwalk flags passed to filename_lookup(). The result of the lookup.",
        "proto" :"int (*fs_lookup_param)(struct fs_context *fc, struct fs_parameter *param, bool want_bdev, unsigned int flags, struct path *_path)",
        "pre": {
            "fc": "!=null",
            "param": "!=null",
            "want_bdev": "in [true, false]",
            "flags": "unsigned int",
            "_path": "!=null"
        }
    }
},
{
    "kretprobe:__vfs_setxattr": {
        "description": "Sets an extended attribute of the named attribute to the value. If the attribute already exists, the value is replaced.",
        "proto" :"long (*__vfs_setxattr)(struct mnt_idmap *idmap, struct dentry *dentry, struct inode *inode, const char *name, const void *value, size_t size, int flags)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null",
            "size": ">=0",
            "flags": "in [XATTR_CREATE, XATTR_REPLACE]"
        },
    }
},
{
    "__vfs_setxattr": {
        "description": "Sets an extended attribute of the named attribute to the value. If the attribute already exists, the value is replaced. If the value is an empty string, the attribute is removed.",
        "proto" :"int (*__vfs_setxattr)(struct mnt_idmap *idmap, struct dentry *dentry, struct inode *inode, const char *name, const void *value, size_t size, int flags)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "inode": "!=null",
            "name": "!=null",
            "value": "!=null or (size == 0 and value == '')",
            "size": ">=0",
            "flags": "in [XATTR_CREATE, XATTR_REPLACE]"
        },
    }
},
{
    "kretprobe:generic_listxattr": {
        "description": "Run through a dentry's xattr list() operations. Combine the results of the list() operation from every xattr_handler in the xattr_handler stack. Note that this will not include the entries for POSIX ACLs.",
        "proto" :"ssize_t (*generic_listxattr)(struct dentry *dentry, char *buffer, size_t buffer_size)",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buffer_size": ">=0"
        },
    }
},
{
    "kprobe:generic_listxattr": {
        "description": "Run through a dentry's xattr list() operations. Combine the results of the list() operation from every xattr_handler in the xattr_handler stack. Note that this will not include the entries for POSIX ACLs.",
        "proto" :"ssize_t (*generic_listxattr)(struct dentry *dentry, char *buffer, size_t buffer_size)",
        "pre": {
            "dentry": "!=null",
            "buffer": "can be null",
            "buffer_size": ">=0",
        },
    }
},
{
    "kretprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix. The get and set xattr handler operations are called with the remainder of the attribute name after skipping the handler's prefix: for example, 'foo' is passed to the get operation of a handler with prefix 'user.' to get attribute 'user.foo'. The full name is still 'there' in the name though. Note: the list xattr handler operation when called from the vfs is passed a NULL name; some file systems use this operation internally, with varying semantics.",
        "proto" :"const char *(*xattr_full_name)(const struct xattr_handler *handler, const char *name)",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kprobe:xattr_full_name": {
        "description": "Compute full attribute name from suffix. The get and set xattr handler operations are called with the remainder of the attribute name after skipping the handler's prefix. For example, 'foo' is passed to the get operation of a handler with prefix 'user.' to get attribute 'user.foo'. The full name is still 'there' in the name though. Note: the list xattr handler operation when called from the vfs is passed a NULL name; some file systems use this operation internally, with varying semantics.",
        "proto" :"const char *(*xattr_full_name)(const struct xattr_handler *handler, const char *name)",
        "pre": {
            "handler": "!=null",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:unregister_filesystem": {
        "description": "We can access the fields of list element if:  1) spinlock is held or  2) we hold the reference to the module.  The latter can be guaranteed by call of try_module_get(); if it  returned 0 we must skip the element, otherwise we got the reference.  Once the reference is obtained we can drop the spinlock.",
        "proto" :"unregister_filesystem()",
        "pre": {
            "spinlock": "held",
            "module_reference": "held"
        },
    }
},
{
    "kprobe:unregister_filesystem": {
        "description": "We can access the fields of list element if:  1) spinlock is held or  2) we hold the reference to the module.  The latter can be guaranteed by call of try_module_get(); if it  returned 0 we must skip the element, otherwise we got the reference.  Once the reference is obtained we can drop the spinlock.",
        "proto" :"static int (*unregister_filesystem)(struct file_system_type *fs)",
        "pre": {
            "fs": "!=null",
            "spinlock": "held || reference to module held",
            "try_module_get()": "!=0"
        },
    }
},
{
    "kretprobe:vfs_setpos": {
        "description": "Update the file offset for lseek if the given offset is valid and not equal to the current file offset. Return the specified offset on success and -EINVAL on invalid offset.",
        "proto" :"loff_t (*vfs_setpos)(struct file *file, loff_t offset, loff_t maxsize)",
        "pre": {
            "file": "!=null",
            "offset": ">=0 && !=file->f_pos",
            "maxsize": ">=0 && >=offset"
        },
        "post": {
            "return": "in [-EINVAL, offset]"
        }
    }
},
{
    "kprobe:loff_t vfs_setpos": {
        "description": "This is a low-level filesystem helper for updating the file offset to the value specified by @offset if the given offset is valid and it is not equal to the current file offset.",
        "proto" :"loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)",
        "pre": {
            "file": "!=null",
            "offset": "is a valid file offset and != current file offset",
            "maxsize": "is the maximum file size",
        },
    }
},
{
    "kretprobe:generic_file_llseek_size": {
        "description": "This is a variant of generic_file_llseek that allows passing in a custom maximum file size and a custom EOF position, for e.g. hashed directories. SEEK_SET and SEEK_END are unsynchronized (but atomic on 64bit platforms) SEEK_CUR is synchronized against other SEEK_CURs, but not readwrites. readwrites behave like SEEK_SET against seeks.",
        "proto" :"loff_t (*generic_file_llseek_size)(struct file *file, loff_t offset, int whence,loff_t maxsize, loff_t eof)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        },
    }
},
{
    "kprobe:generic_file_llseek_size": {
        "description": "Generic llseek implementation for regular files that allows passing in a custom maximum file size and a custom EOF position, for e.g. hashed directories. SEEK_SET and SEEK_END are unsynchronized (but atomic on 64bit platforms) SEEK_CUR is synchronized against other SEEK_CURs, but not readwrites. readwrites behave like SEEK_SET against seeks.",
        "proto" :"loff_t (*generic_file_llseek_size)(struct file *file, loff_t offset, int whence, loff_t maxsize, loff_t eof)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "maxsize": ">=0",
            "eof": ">=0"
        },
    }
},
{
    "kretprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek. @size: size of the file.",
        "proto": "loff_t (*fixed_size_llseek)(struct file *file, loff_t offset, int whence, loff_t size)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fixed_size_llseek": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek. @size: size of the file.",
        "proto" :"loff_t (*fixed_size_llseek)(struct file *file, loff_t offset, int whence, loff_t size)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek.",
        "proto" :"loff_t (*no_seek_end_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kprobe:no_seek_end_llseek": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek.",
        "proto" :"loff_t (*no_seek_end_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kretprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek. @size: maximal offset allowed.",
        "proto" :"loff_t (*no_seek_end_llseek_size)(struct file *file, loff_t offset, int whence, loff_t size)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": ">=0"
        }
    }
},
{
    "kprobe:no_seek_end_llseek_size": {
        "description": "llseek implementation for fixed-sized devices. @file: file structure to seek on. @offset: file offset to seek to. @whence: type of seek. @size: maximal offset allowed.",
        "proto" :"loff_t (*no_seek_end_llseek_size)(struct file *file, loff_t offset, int whence, loff_t size)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation. This is an implementation of ->llseek useable for the rare special case when userspace expects the seek to succeed but the (device) file is actually not able to perform the seek. In this case you use noop_llseek() instead of falling back to the default implementation of ->llseek.",
        "proto" :"loff_t (*noop_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        }
    }
},
{
    "kprobe:noop_llseek": {
        "description": "No Operation Performed llseek implementation. This is an implementation of ->llseek useable for the rare special case when userspace expects the seek to succeed but the (device) file is actually not able to perform the seek. In this case you use noop_llseek() instead of falling back to the default implementation of ->llseek.",
        "proto" :"loff_t (*noop_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END]"
        },
    }
},
{
    "kretprobe:default_llseek": {
        "description": "Move the read/write file offset. The new file offset shall be the sum of offset and a reference point specified by whence.",
        "proto" :"loff_t (*default_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_SET, SEEK_CUR, SEEK_END, SEEK_DATA, SEEK_HOLE]"
        },
        "post": {
            "offset": "<= inode->i_size"
        }
    }
},
{
    "kprobe:default_llseek": {
        "description": "Move the read/write file offset. The new file offset is obtained by adding offset to the position specified by whence. If whence is set to SEEK_END, offset is added to the file size (inode->i_size).",
        "proto" :"static loff_t (*default_llseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [SEEK_END, SEEK_CUR, SEEK_DATA]",
            "inode": "file_inode(file) !=null",
            "inode->i_size": ">=0"
        },
        "post": {
            "offset": "if (whence == SEEK_END) offset >= inode->i_size"
        }
    }
},
{
    "kretprobe:rw_verify_area": {
        "description": "Verifies the read/write area. If the count is less than 0, it returns -EINVAL. If the position is less than 0 and the file does not have unsigned offsets, it returns -EINVAL. If the count is greater than or equal to the negative of the position, both values are in 0..LLONG_MAX.",
        "proto" :"int rw_verify_area(int read_write, struct file  file, const loff_t  ppos, size_t count)",
        "pre": {
            "read_write": "is int",
            "file": "!=null",
            "ppos": "is loff_t",
            "count": "is size_t"
        },
        "post": {
            "return": "in [-EINVAL, -EOVERFLOW, 0..LLONG_MAX]"
        }
    }
},
{
    "kprobe:rw_verify_area": {
        "description": "Verifies the read/write area. If the count is less than 0, returns -EINVAL. If ppos is not null, checks the position. If the position is less than 0 and the file does not have unsigned offsets, returns -EINVAL. If the count is greater or equal to the negative position, both values are in 0..LLONG_MAX.",
        "proto" :"int rw_verify_area(int read_write, struct file  file, const loff_t  ppos, size_t count)",
        "pre": {
            "read_write": "is int",
            "file": "!=null",
            "ppos": "is loff_t",
            "count": "is size_t and >= 0",
        },
    }
},
{
    "kretprobe:kernel_read": {
        "description": "Reads data from a file. Fails if ->read_iter and ->read are both wired up as that implies very convoluted semantics.",
        "proto" :"ssize_t (*kernel_read)(struct file *file, void *buf, size_t count, loff_t *pos)",
        "pre": {
            "file": "!=null && (file->f_mode & FMODE_READ) && !(file->f_mode & FMODE_CAN_READ) && !(file->f_op->read_iter && file->f_op->read)",
            "buf": "!=null",
            "count": ">=0 && <=MAX_RW_COUNT",
            "pos": "!=null"
        },
        "post": {
            "ret": ">=0"
        }
    }
},
{
    "kprobe:kernel_read": {
        "description": "Reads data from a file. Fails if ->read_iter and ->read are both wired up as that implies very convoluted semantics.",
        "proto" :"ssize_t (*kernel_read)(struct file *file, void *buf, size_t count, loff_t *pos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "pos": "!=null",
            "file->f_mode": "in [FMODE_READ, FMODE_CAN_READ]",
            "file->f_op->read_iter": "!=null || file->f_op->read !=null"
        },
    }
},


{
    "kretprobe:generic_copy_file_range": {
        "description": "This is a generic filesystem helper to copy data from one file to another. It has no constraints on the source or destination file owners - the files can belong to different superblocks and different filesystem types. Short copies are allowed. This should be called from the @file_out filesystem, as per the ->copy_file_range() method. Returns the number of bytes copied or a negative error indicating the failure.",
        "proto": "ssize_t (*generic_copy_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, size_t len, unsigned int flags)",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:generic_copy_file_range": {
        "description": "This is a generic filesystem helper to copy data from one file to another. It has no constraints on the source or destination file owners - the files can belong to different superblocks and different filesystem types. Short copies are allowed. This should be called from the @file_out filesystem, as per the ->copy_file_range() method. Returns the number of bytes copied or a negative error indicating the failure.",
        "proto" :"ssize_t (*generic_copy_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, size_t len, unsigned int flags)",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": ">=0",
        },
    }
},
{
    "kretprobe:vfs_copy_file_range": {
        "description": "Copy a range of file from one file to another. Cloning is supported by more file systems, so we implement copy on same sb using clone, but for filesystems where both clone and copy are supported (e.g. nfs,cifs), we only call the copy method.",
        "proto" :"ssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, size_t len, unsigned int flags)",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null && file_out->f_op->copy_file_range !=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": "in [COPY_FILE_SPLICE, ~COPY_FILE_SPLICE]"
        },
    }
},
{
    "kprobe:vfs_copy_file_range": {
        "description": "Copy a range of file from one file to another. Cloning is supported by more file systems, so we implement copy on same sb using clone, but for filesystems where both clone and copy are supported (e.g. nfs,cifs), we only call the copy method.",
        "proto" :"ssize_t (*vfs_copy_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, size_t len, unsigned int flags)",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null && file_out->f_op->copy_file_range !=null",
            "pos_out": ">=0",
            "len": ">=0",
            "flags": "in [COPY_FILE_SPLICE, ~COPY_FILE_SPLICE]"
        },
    }
},
{
    "kretprobe:generic_write_checks_count": {
        "description": "generic_write_checks(), but takes size of write instead of iter.",
        "proto" :"int (*generic_write_checks_count)(struct kiocb *iocb, loff_t *count)",
        "pre": {
            "iocb": "!=null",
            "count": ">=0"
        }
    }
},
{
    "kprobe:generic_write_checks_count": {
        "description": "generic_write_checks(), but takes size of write instead of iter.",
        "proto" :"int (*generic_write_checks_count)(struct kiocb *iocb, loff_t *count)",
        "pre": {
            "iocb": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kretprobe:sync_mapping_buffers": {
        "description": "Starts IO against the buffers at mapping->private_list, and waits upon that IO. This is a convenience function for fsync(). @mapping is a file or directory which needs those buffers to be written for a successful fsync().",
        "proto" :"int (*sync_mapping_buffers)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:sync_mapping_buffers": {
        "description": "Write out & wait upon a mapping's 'associated' buffers. Starts IO against the buffers at mapping->private_list, and waits upon that IO. This is a convenience function for fsync(). @mapping is a file or directory which needs those buffers to be written for a successful fsync().",
        "proto" :"int (*sync_mapping_buffers)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:generic_buffers_fsync_noflush": {
        "description": "This is a generic implementation of the fsync method for simple filesystems which track all non-inode metadata in the buffers list hanging off the address_space structure.",
        "proto" :"int (*generic_buffers_fsync_noflush)(struct file *file, loff_t start, loff_t end, bool datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [true, false]"
        }
    }
},
{
    "kprobe:generic_buffers_fsync_noflush": {
        "description": "This is a generic implementation of the fsync method for simple filesystems which track all non-inode metadata in the buffers list hanging off the address_space structure.",
        "proto" :"int (*generic_buffers_fsync_noflush)(struct file *file, loff_t start, loff_t end, bool datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [true, false]"
        },
    }
},
{
    "kretprobe:mark_buffer_dirty_inode": {
        "description": "Mark the buffer as dirty in the inode's address_space.",
        "proto" :"void mark_buffer_dirty_inode(struct address_space *mapping, struct buffer_head *bh)",
        "pre": {
            "mapping": "!=null",
            "bh": "!=null"
        },
    }
},

{
    "kretprobe:block_dirty_folio": {
        "description": "Lock out page's memcg migration to keep PageDirty synchronized with per-memcg dirty page counters.",
        "proto" :"block_dirty_folio(struct address_space *mapping, struct folio *folio)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        },
        "post": {
            "newly_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:block_dirty_folio": {
        "description": "Lock out page's memcg migration to keep PageDirty synchronized with per-memcg dirty page counters.",
        "proto" :"block_dirty_folio(struct address_space  mapping, struct folio  folio)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:__find_get_block_slow": {
        "description": "try_to_free_buffers with the blockdev mapping's private_lock. Hack idea: for the blockdev mapping, private_lock contention may be quite high. This code could TryLock the page, and if that succeeds, there is no need to take private_lock.",
        "proto" :"static struct buffer_head *(__find_get_block_slow)(struct block_device *bdev, sector_t block)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0"
        }
    }
},
{
    "kprobe:__find_get_block_slow": {
        "description": "try_to_free_buffers with the blockdev mapping's private_lock. Hack idea: for the blockdev mapping, private_lock contention may be quite high. This code could TryLock the page, and if that succeeds, there is no need to take private_lock.",
        "proto" :"static struct buffer_head *(__find_get_block_slow)(struct block_device *bdev, sector_t block)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0"
        }
    }
},
{
    "kretprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "proto" :"struct buffer_head *(__getblk_gfp)(struct block_device *bdev, sector_t block, unsigned size, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "size": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_USER, GFP_HIGHUSER, GFP_NOFS, GFP_NOIO, GFP_FS, GFP_HARDWALL, GFP_HIGHUSER_MOVABLE, GFP_NOACCOUNT, GFP_NOWAIT, GFP_DMA, GFP_NORETRY, GFP_MEMALLOC, GFP_HIGHUSER_NORETRY, GFP_NO_KSWAPD, GFP_ATOMIC_LOW, GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:__getblk_gfp": {
        "description": "__getblk_gfp() will locate (and, if necessary, create) the buffer_head which corresponds to the passed block_device, block and size. The returned buffer has its reference count incremented. __getblk_gfp() will lock up the machine if grow_dev_page's try_to_free_buffers() attempt is failing. FIXME, perhaps?",
        "proto" :"struct buffer_head *(__getblk_gfp)(struct block_device *bdev, sector_t block, unsigned size, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "size": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // Please replace with actual gfp_t flags
        },
    }
},
{
    "kretprobe:__bread_gfp": {
        "description": "Reads a specified block, and returns buffer head that contains it. The page cache can be allocated from non-movable area not to prevent page migration if you set gfp to zero. It returns NULL if the block was unreadable.",
        "proto" :"struct buffer_head * (*__bread_gfp)(struct block_device *bdev, sector_t block, unsigned size, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "size": ">0",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_ZERO, __GFP_NOWARN, __GFP_RETRY_MAYFAIL, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_KSWAPD_RECLAIM]"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:__bread_gfp": {
        "description": "Reads a specified block, and returns buffer head that contains it. The page cache can be allocated from non-movable area not to prevent page migration if you set gfp to zero. It returns NULL if the block was unreadable.",
        "proto" :"struct buffer_head * (*__bread_gfp)(struct block_device *bdev, sector_t block, unsigned size, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "size": ">0",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_ZERO, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_KMEMCG, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
        },
    }
},
{
    "kretprobe:set_bh_page": {
        "description": "Sets the page and offset for a buffer head. Catches illegal uses and preserves the offset.",
        "proto" :"void set_bh_page(struct buffer_head *bh, struct page *page, unsigned long offset)",
        "pre": {
            "bh": "!=null",
            "page": "!=null",
            "offset": "< PAGE_SIZE"
        }
    }
},
{
    "kprobe:set_bh_page": {
        "description": "This function sets the page for the buffer head and checks if the offset is within the page size. If the page is in high memory, it catches illegal uses and preserves the offset.",
        "proto" :"void set_bh_page(struct buffer_head *bh, struct page *page, unsigned long offset)",
        "pre": {
            "bh": "!=null",
            "page": "!=null",
            "offset": "< PAGE_SIZE"
        }
    }
},
{
    "kretprobe:no_grow:if (head)": {
        "description": "Description of the function's behavior",
        "proto" :"static long (*no_grow)(void *head)",
        "pre": {
            "head": "!=null"
        },
    }
},

{
    "kretprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio. block_invalidate_folio() is called when all or part of the folio has been invalidated by a truncate operation. block_invalidate_folio() does not have to release all buffers, but it must ensure that no dirty buffer is left outside @offset and that no IO is underway against any of the blocks which are outside the truncation point. Because the caller is about to free (and possibly reuse) those blocks on-disk.",
        "proto" :"void (*block_invalidate_folio)(struct folio *folio, size_t offset, size_t length)",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kprobe:block_invalidate_folio": {
        "description": "Invalidate part or all of a buffer-backed folio. It is called when all or part of the folio has been invalidated by a truncate operation. It does not have to release all buffers, but it must ensure that no dirty buffer is left outside @offset and that no IO is underway against any of the blocks which are outside the truncation point. Because the caller is about to free (and possibly reuse) those blocks on-disk.",
        "proto" :"void (*block_invalidate_folio)(struct folio *folio, size_t offset, size_t length)",
        "pre": {
            "folio": "!=null",
            "offset": ">=0",
            "length": ">=0"
        }
    }
},
{
    "kretprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device. We are taking a range of blocks for data and we don't want writeback of any buffer-cache aliases starting from return from this function and until the moment when something will explicitly mark the buffer dirty. We don't even need to mark it not-uptodate - nobody can expect anything from a newly allocated buffer anyway. We used to use unmap_buffer() for such invalidation, but that was wrong. We definitely don't want to mark the alias unmapped, for example - it would confuse anyone who might pick it with bread() afterwards. Note that bforget() doesn't lock the buffer. So there can be writeout IO going on against recently-freed buffers. We don't wait on that IO in bforget() - it's more efficient to wait on the IO only if we really need to. That happens here.",
        "proto" :"void (*clean_bdev_aliases)(struct block_device *bdev, sector_t block, sector_t len)",
        "pre": {
            "bdev": "!=null",
            "block": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:clean_bdev_aliases": {
        "description": "Clean a range of buffers in block device. We are taking a range of blocks for data and we don't want writeback of any buffer-cache aliases starting from return from this function and until the moment when something will explicitly mark the buffer dirty. We don't even need to mark it not-uptodate - nobody can expect anything from a newly allocated buffer anyway. We used to use unmap_buffer() for such invalidation, but that was wrong. We definitely don't want to mark the alias unmapped, for example - it would confuse anyone who might pick it with bread() afterwards. Also.. Note that bforget() doesn't lock the buffer. So there can be writeout IO going on against recently-freed buffers. We don't wait on that IO in bforget() - it's more efficient to wait on the IO only if we really need to. That happens here.",
        "proto" :"void (*clean_bdev_aliases)(struct block_device *bdev, sector_t block, sector_t len)",
        "pre": {
            "bdev": "!=null",
            "block": "!=null",
            "len": "!=null"
        }
    }
},

{
    "kprobe:__block_write_full_folio": {
        "description": "This function creates buffers for a folio, handles any dirty buffers and maps them to disk addresses. It also handles any aliases from the underlying blockdev's mapping.",
        "proto" :"__block_write_full_folio(struct inode  inode, struct folio  folio,get_block_t  get_block, struct writeback_control  wbc,bh_end_io_t  handler)",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "get_block": "!=null",
            "wbc": "!=null",
            "handler": "!=null"
        },
    }
},

{
    "kprobe:block_write_begin_int": {
        "description": "Starts the process of writing len bytes to a file at pos from the page in the page cache that folio represents.",
        "proto" :"block_write_begin_int(struct folio  folio, loff_t pos, unsigned len,get_block_t  get_block, const struct iomap  iomap)",
        "pre": {
            "folio": "!=null",
            "pos": ">=0",
            "len": "<=PAGE_SIZE",
            "get_block": "!=null",
            "iomap": "!=null"
        },
    }
},
{
    "kretprobe:block_write_end": {
        "description": "Handles the end of a write to a block device. If a short write occurs to a non-uptodate folio, it is treated as a zero-length write, forcing the caller to redo the whole thing.",
        "proto" :"static long (*block_write_end)(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)",
        "pre": {
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "copied": ">=0",
            "page": "!=null",
            "fsdata": "!=null"
        },
    }
},
{
    "kprobe:block_write_end": {
        "description": "Handles the end of a write to a block device. If a short write occurs to a non-uptodate folio, it is treated as a zero-length write, forcing the caller to redo the whole thing.",
        "proto" :"static long (*block_write_end)(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)",
        "pre": {
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "copied": ">=0",
            "page": "!=null",
            "fsdata": "!=null"
        },
    }
},
{
    "kretprobe:generic_write_end": {
        "description": "Ends a write to the generic block layer. Updates the file size if necessary.",
        "proto": "static int (*generic_write_end)(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)",
        "pre": {
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "copied": ">=0",
            "page": "!=null",
            "fsdata": "can be null or !=null"
        },
        "post": {
            "pos_plus_copied": {
                "condition": "pos + copied > mapping->host->i_size",
                "description": "If the position plus the number of bytes copied is greater than the file size, the file size needs to be updated."
            }
        }
    }
},
{
    "kprobe:generic_write_end": {
        "description": "This function writes to a file. It updates the i_size while still holding the page lock to prevent page writeout from zeroing beyond i_size.",
        "proto": "static long (*generic_write_end)(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned copied, struct page *page, void *fsdata)",
        "pre": {
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "copied": ">=0",
            "page": "!=null",
            "fsdata": "!=null",
            "mapping->host": "!=null",
            "pos + copied": "<= mapping->host->i_size"
        }
    }
},
{
    "kretprobe:block_is_partially_uptodate": {
        "description": "block_is_partially_uptodate checks whether buffers within a folio are uptodate or not. Returns true if all buffers which correspond to the specified part of the folio are uptodate.",
        "proto" :"bool (*block_is_partially_uptodate)(struct folio *folio, size_t from, size_t count)",
        "pre": {
            "folio": "!=null",
            "from": ">=0",
            "count": ">=0"
        },
    }
},
{
    "kprobe:block_is_partially_uptodate": {
        "description": "block_is_partially_uptodate checks whether buffers within a folio are uptodate or not. Returns true if all buffers which correspond to the specified part of the folio are uptodate.",
        "proto" :"bool (*block_is_partially_uptodate)(struct folio *folio, size_t from, size_t count)",
        "pre": {
            "folio": "!=null",
            "from": ">=0",
            "count": ">=0"
        }
    }
},
{
    "kretprobe:end_buffer_async_read_io": {
        "description": "Handles pages which come unlocked at the end of IO.",
        "proto" :"static void (*end_buffer_async_read_io)(struct buffer_head *bh, int uptodate)",
        "pre": {
            "bh": "!=null",
            "uptodate": "is int"
        }
    }
},
{
    "kprobe:end_buffer_async_read_io": {
        "description": "block_read_full_folio() - pages which come unlocked at the end of IO.",
        "proto" :"static void (*end_buffer_async_read_io)(struct buffer_head *bh, int uptodate)",
        "pre": {
            "bh": "!=null",
            "uptodate": "is an integer"
        }
    }
},
{
    "kretprobe:block_commit_write": {
        "description": "This function takes care of the basic task of block allocation and bringing partial write blocks uptodate first. The filesystem needs to handle block truncation upon failure.",
        "proto" :"block_commit_write(struct inode  inode, struct folio  folio, size_t from, size_t to)",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "from": ">=0",
            "to": ">=from",
        },
    }
},
{
    "kprobe:block_commit_write": {
        "description": "This function takes care of the basic task of block allocation and bringing partial write blocks uptodate first. The filesystem needs to handle block truncation upon failure.",
        "proto" :"block_commit_write(struct inode  inode, struct folio  folio, size_t from, size_t to)",
        "pre": {
            "inode": "!=null",
            "folio": "!=null",
            "from": ">=0",
            "to": ">=from",
        },
    }
},
{
    "kretprobe:block_page_mkwrite": {
        "description": "block_page_mkwrite() is not allowed to change the file size as it gets called from a page fault handler when a page is first dirtied. Hence we must be careful to check for EOF conditions here. We set the page up correctly for a written page which means we get ENOSPC checking when writing into holes and correct delalloc and unwritten extent mapping on filesystems that support these features. We are not allowed to take the i_mutex here so we have to play games to protect against truncate races as the page could now be beyond EOF. Because truncate writes the inode size before removing pages, once we have the page lock we can determine safely if the page is beyond EOF. If it is not beyond EOF, then the page is guaranteed safe against truncation until we unlock the page. Direct callers of this function should protect against filesystem freezing using sb_start_pagefault() - sb_end_pagefault() functions.",
        "proto" :"int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf, get_block_t get_block)",
        "pre": {
            "vma": "!=null",
            "vmf": "!=null",
            "get_block": "!=null"
        },
    }
},
{
    "kprobe:block_page_mkwrite": {
        "description": "This function is called from a page fault handler when a page is first dirtied. It sets up the page correctly for a written page, checks for EOF conditions, and protects against truncate races and filesystem freezing.",
        "proto" :"int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf, get_block_t get_block)",
        "pre": {
            "vma": "!=null",
            "vmf": "!=null",
            "get_block": "!=null"
        },
    }
},

{
    "kprobe:block_truncate_page": {
        "description": "Truncates a page block from a specific address space mapping, starting from a specific offset, using a specific get_block function.",
        "proto": "int (*block_truncate_page)(struct address_space *mapping, loff_t from, get_block_t *get_block)",
        "pre": {
            "mapping": "!=null",
            "from": ">=0",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:end_buffer_async_write": {
        "description": "Pages which are unlocked during IO, and which have PageWriteback cleared upon IO completion.",
        "proto" :"void (*end_buffer_async_write)(struct buffer_head *bh, int uptodate)",
        "pre": {
            "bh": "!=null",
            "uptodate": "is int"
        }
    }
},
{
    "kprobe:end_buffer_async_write": {
        "description": "Handles pages which are unlocked during IO, and which have PageWriteback cleared upon IO completion.",
        "proto" :"static void (*end_buffer_async_write)(struct buffer_head *bh, int uptodate)",
        "pre": {
            "bh": "!=null",
            "uptodate": "in [0, 1]"
        }
    }
},
{
    "kretprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers. If all the buffers are unlocked and clean then the folio_test_dirty information is stale. If any of the buffers are locked, it is assumed they are locked for IO.",
        "proto" :"void buffer_check_dirty_writeback(struct folio *folio, bool *dirty, bool *writeback)",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        },
    }
},
{
    "kprobe:buffer_check_dirty_writeback": {
        "description": "Returns if the folio has dirty or writeback buffers. If all the buffers are unlocked and clean then the folio_test_dirty information is stale. If any of the buffers are locked, it is assumed they are locked for IO.",
        "proto" :"void buffer_check_dirty_writeback(struct folio *folio, bool *dirty, bool *writeback)",
        "pre": {
            "folio": "!=null",
            "dirty": "!=null",
            "writeback": "!=null"
        },
    }
},
{
    "kretprobe:osync_buffers_list": {
        "description": "Write_dirty_buffer as you dirty the buffers, and then use osync_inode_buffers to wait for completion. Any other dirty buffers which are not yet queued for write will not be flushed to disk by the osync.",
        "proto" :"static int osync_buffers_list(spinlock_t *lock, struct list_head *list)",
        "pre": {
            "lock": "!=null",
            "list": "!=null && list->next != null && list->prev != null"
        },
    }
},
{
    "kprobe:osync_buffers_list": {
        "description": "As you dirty the buffers, and then use osync_inode_buffers to wait for completion. Any other dirty buffers which are not yet queued for write will not be flushed to disk by the osync.",
        "proto" :"static int osync_buffers_list(spinlock_t *lock, struct list_head *list)",
        "pre": {
            "lock": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:sync_dirty_buffer": {
        "description": "The bh should be mapped, but it might not be if the device was hot-removed. Not much we can do but fail the IO.",
        "proto" :"sync_dirty_buffer(struct buffer_head *bh, blk_opf_t op_flags)",
        "pre": {
            "bh": "!=null",
            "op_flags": "in [your_possible_values_here]"
        },
        "post": {
            "return": "your_return_value_conditions_here"
        }
    }
},
{
    "kprobe:sync_dirty_buffer": {
        "description": "The bh should be mapped, but it might not be if the device was hot-removed. Not much we can do but fail the IO.",
        "proto" :"sync_dirty_buffer(struct buffer_head  bh, blk_opf_t op_flags)",
        "pre": {
            "bh": "!=null",
            "op_flags": "!=null",
            "buffer_mapped(bh)": "==true"
        },
    }
},
{
    "kretprobe:folio_set_bh": {
        "description": "Link the buffer to its folio",
        "proto" :"static long (*folio_set_bh)(type bh, type folio, type offset, type old_memcg, type head)",
        "pre": {
            "bh": "!=null",
            "folio": "!=null",
            "offset": "!=null",
            "old_memcg": "!=null",
            "head": "!=null"
        },
    }
},
{
    "kprobe:folio_set_bh": {
        "description": "Link the buffer to its folio",
        "proto" :"static long (*folio_set_bh)(void *bh, void *folio, __u64 offset, void *head, __u64 gfp, __u64 size, __s64 b_blocknr)",
        "pre": {
            "bh": "!=null",
            "folio": "!=null",
            "offset": ">=0",
            "head": "!=null",
            "gfp": ">=0",
            "size": ">=0",
            "b_blocknr": "<0",
        },
    }
},
{
    "kretprobe:folio_init_buffers": {
        "description": "Initialise the state of a blockdev folio's buffers.",
        "proto" :"static sector_t folio_init_buffers(struct folio *folio, struct block_device *bdev, sector_t block, int size)",
        "pre": {
            "folio": "!=null",
            "bdev": "!=null",
            "block": ">=0",
            "size": ">0"
        }
    }
},
{
    "kprobe:folio_init_buffers": {
        "description": "Initialise the state of a blockdev folio's buffers.",
        "proto" :"static sector_t folio_init_buffers(struct folio *folio, struct block_device *bdev, sector_t block, int size)",
        "pre": {
            "folio": "!=null",
            "bdev": "!=null",
            "block": ">0",
            "size": "in [min_size, max_size]",
        },
    }
},
{
    "kretprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate. Return true if the buffer is up-to-date and false, with the buffer locked, if not.",
        "proto" :"int (*bh_uptodate_or_lock)(struct buffer_head *bh)",
        "pre": {
            "bh": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:bh_uptodate_or_lock": {
        "description": "Test whether the buffer is uptodate. Return true if the buffer is up-to-date and false, with the buffer locked, if not.",
        "proto" :"int (*bh_uptodate_or_lock)(struct buffer_head *bh)",
        "pre": {
            "bh": "!=null"
        }
    }
},
{
    "kretprobe:__bh_read": {
        "description": "Submit read for a locked buffer @bh: struct buffer_head @op_flags: appending REQ_OP_ flags besides REQ_OP_READ @wait: wait until reading finish Returns zero on success or don't wait, and -EIO on error.",
        "proto" :"int (*__bh_read)(struct buffer_head *bh, blk_opf_t op_flags, bool wait)",
        "pre": {
            "bh": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_READ_PREFETCH, REQ_OP_POLL]",
            "wait": "in [true, false]"
        },
    }
},
{
    "kprobe:__bh_read": {
        "description": "__bh_read - Submit read for a locked buffer @bh: struct buffer_head @op_flags: appending REQ_OP_ flags besides REQ_OP_READ @wait: wait until reading finish Returns zero on success or don't wait, and -EIO on error.",
        "proto" :"int (*__bh_read)(struct buffer_head *bh, blk_opf_t op_flags, bool wait)",
        "pre": {
            "bh": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_SAME, REQ_OP_POLL]",
            "wait": "in [true, false]"
        },
    }
},
{
    "kretprobe:__bh_read_batch": {
        "description": "__bh_read_batch - Submit read for a batch of unlocked buffers. @nr: entry number of the buffer batch. @bhs: a batch of struct buffer_head. @op_flags: appending REQ_OP_ flags besides REQ_OP_READ. @force_lock: force to get a lock on the buffer if set, otherwise drops any buffer that cannot lock. Returns zero on success or don't wait, and -EIO on error.",
        "proto" :"void __bh_read_batch(int nr, struct buffer_head *bhs[], blk_opf_t op_flags, bool force_lock)",
        "pre": {
            "nr": ">=0",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_SAME, REQ_OP_POLL]",
            "force_lock": "is bool"
        },
    }
},
{
    "kprobe:__bh_read_batch": {
        "description": "__bh_read_batch - Submit read for a batch of unlocked buffers. @nr: entry number of the buffer batch. @bhs: a batch of struct buffer_head. @op_flags: appending REQ_OP_ flags besides REQ_OP_READ. @force_lock: force to get a lock on the buffer if set, otherwise drops any buffer that cannot lock. Returns zero on success or don't wait, and -EIO on error.",
        "proto" :"void (*__bh_read_batch)(int nr, struct buffer_head *bhs[], blk_opf_t op_flags, bool force_lock)",
        "pre": {
            "nr": ">=0",
            "bhs": "!=null",
            "op_flags": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_SAME, REQ_OP_POLL]",
            "force_lock": "is boolean"
        },
    }
},
{
    "kretprobe:pipe_lock_nested": {
        "description": "pipe_lock_nested() nests non-pipe inode locks (for writing to a file). If pipe->files is not null, it locks the mutex with a given subclass.",
        "proto" :"void (*pipe_lock_nested)(struct pipe_inode_info *pipe, int subclass)",
        "pre": {
            "pipe": "!=null",
            "subclass": "is an integer"
        }
    }
},
{
    "kprobe:pipe_lock_nested": {
        "description": "pipe_lock_nested() nests non-pipe inode locks (for writing to a file). If pipe->files is not null, it locks the mutex associated with the pipe.",
        "proto" :"void (*pipe_lock_nested)(struct pipe_inode_info *pipe, int subclass)",
        "pre": {
            "pipe": "!=null",
            "subclass": "is an integer"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_try_steal": {
        "description": "This function attempts to steal the &struct page attached to @buf. If successful, this function returns 0 and returns with the page locked. The caller may then reuse the page for whatever he wishes; the typical use is insertion into a different file page cache.",
        "proto" :"bool (*generic_pipe_buf_try_steal)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        },
    }
},
{
    "kprobe:generic_pipe_buf_try_steal": {
        "description": "This function attempts to steal the &struct page attached to @buf. If successful, this function returns 0 and returns with the page locked. The caller may then reuse the page for whatever he wishes; the typical use is insertion into a different file page cache.",
        "proto" :"bool (*generic_pipe_buf_try_steal)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_get": {
        "description": "This function grabs an extra reference to @buf. It's used in the tee() system call, when we duplicate the buffers in one pipe into another.",
        "proto" :"bool (*generic_pipe_buf_get)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_get": {
        "description": "This function grabs an extra reference to @buf. It's used in the tee() system call, when we duplicate the buffers in one pipe into another.",
        "proto" :"bool (*generic_pipe_buf_get)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "proto" :"void (*generic_pipe_buf_release)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:generic_pipe_buf_release": {
        "description": "This function releases a reference to @buf.",
        "proto" :"void (*generic_pipe_buf_release)(struct pipe_inode_info *pipe, struct pipe_buffer *buf)",
        "pre": {
            "pipe": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:sync_filesystem": {
        "description": "Check if the filesystem is read-only and sync if it is not.",
        "proto" :"static int (*sync_filesystem)(struct super_block *sb)",
        "pre": {
            "sb": "!=null",
            "sb->s_umount": "is_locked"
        },
        "post": {
            "return": "in [0, -EROFS]"
        }
    }
},

{
    "kretprobe:vfs_fsync_range": {
        "description": "Write back data in range @start..@end and metadata for @file to disk. If @datasync is set only metadata needed to access modified file data is written.",
        "proto" :"int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},
{
    "kprobe:vfs_fsync_range": {
        "description": "Helper to sync a range of data & metadata to disk. Write back data in range @start..@end and metadata for @file to disk. If @datasync is set only metadata needed to access modified file data is written.",
        "proto" :"int vfs_fsync_range(struct file *file, loff_t start, loff_t end, int datasync)",
        "pre": {
            "file": "!=null",
            "start": ">=0",
            "end": ">=start",
            "datasync": "in [0, 1]"
        }
    }
},

{
    "kprobe:smp_mb;mapping_tagged;inode_state": {
        "description": "__mark_inode_dirty(). This allows __mark_inode_dirty() to test i_state without grabbing i_lock - either they see the I_DIRTY bits cleared or we see the dirtied inode. I_DIRTY_PAGES is always cleared together above even if @mapping still has dirty pages. The flag is reinstated after smp_mb() if necessary. This guarantees that either __mark_inode_dirty() sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.",
        "proto" :"static void (*smp_mb;mapping_tagged;inode_state)(void *mapping, int PAGECACHE_TAG_DIRTY, struct inode *inode, int I_DIRTY_PAGES, int I_PINNING_FSCACHE_WB)",
        "pre": {
            "mapping": "your condition here",
            "PAGECACHE_TAG_DIRTY": "your condition here",
            "inode": "your condition here",
            "I_DIRTY_PAGES": "your condition here",
            "I_PINNING_FSCACHE_WB": "your condition here"
        },
    }
},
{
    "kretprobe:writeback_inodes_sb_nr": {
        "description": "Start writeback on some inodes on this super_block. No guarantees are made on how many (if any) will be written, and this function does not wait for IO completion of submitted IO.",
        "proto" :"void writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr, enum wb_reason reason)",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_BACKGROUND, WB_REASON_VMSCAN, WB_REASON_PERIODIC, WB_REASON_LAPTOP_TIMER, WB_REASON_FREE_MORE_MEM, WB_REASON_FS_FREE_SPACE, WB_REASON_FORKER_THREAD, WB_REASON_INODE_CGROUP, WB_REASON_WRITEBACK, WB_REASON_WB_SYNC_ALL, WB_REASON_SYNC, WB_REASON_SYNCFS, WB_REASON_FS_SYNC, WB_REASON_FSYNC, WB_REASON_SB_DIRTY, WB_REASON_BDI_DIRTY, WB_REASON_REMOVE_SB, WB_REASON_TRY_TO_FREE_PAGES, WB_REASON_MEM_CGROUP_RECLAIM, WB_REASON_SOFTDIRTY, WB_REASON_MEM_CGROUP_PROTECTION, WB_REASON_FS_DSYNC, WB_REASON_FORCED_BG_RECLAIM, WB_REASON_DEFAULT]"
        }
    }
},
{
    "kprobe:writeback_inodes_sb_nr": {
        "description": "Start writeback on some inodes on this super_block. No guarantees are made on how many (if any) will be written, and this function does not wait for IO completion of submitted IO.",
        "proto" :"void (*writeback_inodes_sb_nr)(struct super_block *sb, unsigned long nr, enum wb_reason reason)",
        "pre": {
            "sb": "!=null",
            "nr": ">=0",
            "reason": "in [WB_REASON_SYNC, WB_REASON_PERIODIC, WB_REASON_IDLE, WB_REASON_FREE_MORE_MEM, WB_REASON_FS_FREE_SPACE, WB_REASON_BACKGROUND, WB_REASON_VMSCAN, WB_REASON_WRITEBACK, WB_REASON_FORCED_BG_RECLAIM, WB_REASON_FORKER_THREAD, WB_REASON_INODE_CGROUP, WB_REASON_MEMORY_RECLAIM]"
        },
    }
},
{
    "kretprobe:try_to_writeback_inodes_sb": {
        "description": "Invoke __writeback_inodes_sb_nr if no writeback is currently underway.",
        "proto" :"void (*try_to_writeback_inodes_sb)(struct super_block *sb, enum wb_reason reason)",
        "pre": {
            "sb": "!=null",
            "reason": "is a valid enum wb_reason"
        }
    }
},
{
    "kprobe:try_to_writeback_inodes_sb": {
        "description": "Invoke __writeback_inodes_sb_nr if no writeback is currently underway.",
        "proto" :"void (*try_to_writeback_inodes_sb)(struct super_block *sb, enum wb_reason reason)",
        "pre": {
            "sb": "!=null",
            "reason": "in [WB_REASON_SYNC, WB_REASON_PERIODIC, WB_REASON_IDLE, WB_REASON_FREE_MORE_MEM, WB_REASON_FS_FREE_SPACE, WB_REASON_BACKGROUND, WB_REASON_FORCED_BG, WB_REASON_FORCED]"
        }
    }
},
{
    "kretprobe:down_read": {
        "description": "Synchronize. sync_inodes_sb() is being issued, sync_inodes_sb() might miss it.",
        "proto" :"void down_read(struct rw_semaphore *sem)",
        "pre": {
            "sem": "!=null"
        }
    }
},

{
    "kretprobe:write_inode_now": {
        "description": "Write an inode to disk. This function commits an inode to disk immediately if it is dirty. This is primarily needed by knfsd. The caller must either have a ref on the inode or must have set I_WILL_FREE.",
        "proto" :"int (*write_inode_now)(struct inode *inode, int sync)",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kprobe:write_inode_now": {
        "description": "Write an inode to disk. This function commits an inode to disk immediately if it is dirty. This is primarily needed by knfsd. The caller must either have a ref on the inode or must have set I_WILL_FREE.",
        "proto" :"int (*write_inode_now)(struct inode *inode, int sync)",
        "pre": {
            "inode": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion. Note: only writes the actual inode, no associated data or other metadata.",
        "proto" :"int (*sync_inode_metadata)(struct inode *inode, int wait)",
        "pre": {
            "inode": "!=null",
            "wait": "in [0, 1]"
        },
    }
},
{
    "kprobe:sync_inode_metadata": {
        "description": "Write an inode to disk and adjust its dirty state after completion. Note: only writes the actual inode, no associated data or other metadata.",
        "proto" :"int (*sync_inode_metadata)(struct inode *inode, int wait)",
        "pre": {
            "inode": "!=null",
            "wait": "in [0, 1]",
        },
    }
},
{
    "kretprobe:function_name": {
        "description": "Your function description here.",
        "proto" :"int (*function_name)(type1 param1, type2 param2, type3 param3)",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here"
        },
    }
},
{
    "kprobe:fd_install": {
        "description": "fd_install() have seen resize_in_progress or have finished their rcu_read_lock_sched() section.",
        "proto" :"static int (*fd_install)(struct files_struct *files, unsigned int fd, struct file *file)",
        "pre": {
            "files": "!=null",
            "fd": ">=0",
            "file": "!=null",
            "resize_in_progress": "==false || rcu_read_lock_sched() == true",
        },
    }
},
{
    "kretprobe:fget_files_rcu": {
        "description": "This function is used to get a file pointer in a lockless manner under RCU. It may race with the file being closed. If the file ref already went down to zero, and get_file_rcu() fails, it tries again.",
        "proto" :"struct file *(*fget_files_rcu)(struct files_struct *files, unsigned int fd, fmode_t mask)",
        "pre": {
            "files": "!=null",
            "fd": "in [0, fdt->max_fds)",
            "mask": "is fmode_t"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:fget_files_rcu": {
        "description": "This function retrieves a file pointer in a lockless manner under RCU. It may race with the file being closed. If the file ref already went down to zero, and get_file_rcu() fails, it tries again.",
        "proto" :"fget_files_rcu(struct files_struct *files, unsigned int fd, fmode_t mask)",
        "pre": {
            "files": "!=null",
            "fd": "in [0, fdt->max_fds)",
            "mask": "is fmode_t"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:task_lookup_next_fd_rcu": {
        "description": "Must be called with rcu_read_lock held",
        "proto" :"struct files_struct *task_lookup_next_fd_rcu(struct task_struct *task, unsigned int *ret_fd)",
        "pre": {
            "task": "!=null",
            "ret_fd": "!=null"
        }
    }
},
{
    "kprobe:task_lookup_next_fd_rcu": {
        "description": "Must be called with rcu_read_lock held",
        "proto" :"static struct files_struct *(*task_lookup_next_fd_rcu)(struct task_struct *task, unsigned int *ret_fd)",
        "pre": {
            "task": "!=null",
            "ret_fd": "!=null"
        }
    }
},
{
    "kretprobe:vfs_parse_fs_param_source": {
        "description": "This is a simple helper for filesystems to verify that the 'source' they accept is sane. Returns 0 on success, -ENOPARAM if this is not 'source' parameter, and -EINVAL otherwise. In the event of failure, supplementary error information is logged.",
        "proto" :"int (*vfs_parse_fs_param_source)(struct fs_context *fc, struct fs_parameter *param)",
        "pre": {
            "fc": "!=null",
            "param": "!=null"
        },
        "post": {
            "return": "in [0, -ENOPARAM, -EINVAL]"
        }
    }
},
{
    "kprobe:vfs_parse_fs_param_source": {
        "description": "This is a simple helper for filesystems to verify that the 'source' they accept is sane. Returns 0 on success, -ENOPARAM if this is not 'source' parameter, and -EINVAL otherwise. In the event of failure, supplementary error information is logged.",
        "proto" :"int (*vfs_parse_fs_param_source)(struct fs_context *fc, struct fs_parameter *param)",
        "pre": {
            "fc": "your precondition here",
            "param": "your precondition here"
        },
    }
},
{
    "kretprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "proto" :"int vfs_parse_fs_string(struct fs_context *fc, const char *key, const char *value, size_t v_size)",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">=0"
        }
    }
},
{
    "kprobe:vfs_parse_fs_string": {
        "description": "Convenience function to just parse a string.",
        "proto" :"int (*vfs_parse_fs_string)(struct fs_context *fc, const char *key, const char *value, size_t v_size)",
        "pre": {
            "fc": "!=null",
            "key": "!=null",
            "value": "!=null",
            "v_size": ">0",
        },
    }
},
{
    "kretprobe:generic_parse_monolithic": {
        "description": "Parse a blob of data that's in key[=val][,key[=val]] form. This can be called from the ->monolithic_mount_data() fs_context operation. Returns 0 on success or the error returned by the ->parse_option() fs_context operation on failure.",
        "proto" :"int (*generic_parse_monolithic)(struct fs_context *fc, void *data)",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:generic_parse_monolithic": {
        "description": "Parse a blob of data that's in key[=val][,key[=val]] form. This can be called from the ->monolithic_mount_data() fs_context operation. Returns 0 on success or the error returned by the ->parse_option() fs_context operation on failure.",
        "proto" :"int (*generic_parse_monolithic)(struct fs_context *fc, void *data)",
        "pre": {
            "fc": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicate the fs_context object *src_fc* and return the new object. If an error occurs, return an error pointer.",
        "proto" :"static struct fs_context *(*vfs_dup_fs_context)(struct fs_context *src_fc)",
        "pre": {
            "src_fc": "!=null",
            // Add any other preconditions here
        },
        "post": {
            "ret": "< 0 if error, otherwise pointer to new fs_context object",
            // Add any other postconditions here
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicates the fs_context structure. If the original fs_context has a ->dup operation, it will be called. If not, the function will return an error. The function also increases the reference count for several fields in the fs_context structure.",
        "proto" :"struct fs_context *vfs_dup_fs_context(struct fs_context *src_fc)",
        "pre": {
            "src_fc": "!=null",
            "src_fc->ops->dup": "!=null",
            "fc": "!=null",
            "fc->fs_type": "!=null",
            "fc->net_ns": "!=null",
            "fc->user_ns": "!=null",
            "fc->cred": "!=null",
            "fc->log.log": "!=null"
        },
    }
},
{
    "kretprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "proto": "void logfc(struct fc_log *log, const char *prefix, char level, const char *fmt, ...)",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "is a valid log level",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:logfc": {
        "description": "Log a message to a filesystem context",
        "proto": "void (*logfc)(struct fc_log *log, const char *prefix, char level, const char *fmt, ...)",
        "pre": {
            "log": "!=null",
            "prefix": "!=null",
            "level": "in ['DEBUG', 'INFO', 'WARN', 'ERROR']",
            "fmt": "!=null"
        }
    }
},
{
    "kretprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "proto" :"struct fs_context *(*vfs_dup_fs_context)(struct fs_context *src_fc)",
        "pre": {
            "src_fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_dup_fs_context": {
        "description": "Duplicate a filesystem context.",
        "proto" :"struct fs_context *(*vfs_dup_fs_context)(struct fs_context *src_fc)",
        "pre": {
            "src_fc": "!=null"
        }
    }
},
{
    "kretprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before filling in the uid and gid fields. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"void (*generic_fillattr)(struct mnt_idmap *idmap, struct inode *inode, struct kstat *stat)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fillattr": {
        "description": "Fill in the basic attributes from the inode struct. This is the default if no getattr inode operation is supplied. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before filling in the uid and gid fields. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"void generic_fillattr(struct mnt_idmap *idmap, struct inode *inode, struct kstat *stat)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kretprobe:generic_fill_statx_attr": {
        "description": "Fill in the STATX_ATTR_ flags in the kstat structure for properties of the inode that are published on i_flags and enforced by the VFS.",
        "proto" :"void (*generic_fill_statx_attr)(struct inode *inode, struct kstat *stat)",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        }
    }
},
{
    "kprobe:generic_fill_statx_attr": {
        "description": "Fill in the STATX_ATTR_ flags in the kstat structure for properties of the inode that are published on i_flags and enforced by the VFS.",
        "proto" :"void (*generic_fill_statx_attr)(struct inode *inode, struct kstat *stat)",
        "pre": {
            "inode": "!=null",
            "stat": "!=null"
        },
    }
},
{
    "kretprobe:vfs_getattr_nosec": {
        "description": "Get attributes without calling security_inode_getattr. Currently the only caller other than vfs_getattr is internal to the filehandle lookup code, which uses only the inode number and returns no attributes to any user. Any other code probably wants vfs_getattr.",
        "proto" :"int vfs_getattr_nosec(const struct path *path, struct kstat *stat, u32 request_mask, unsigned int query_flags)",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "in [STATX_TYPE, STATX_MODE, STATX_NLINK, STATX_UID, STATX_GID, STATX_ATIME, STATX_MTIME, STATX_CTIME, STATX_INO, STATX_SIZE, STATX_BLOCKS, STATX_BASIC_STATS, STATX_BTIME, STATX_ALL]",
            "query_flags": "in [AT_STATX_SYNC_AS_STAT, AT_STATX_FORCE_SYNC, AT_STATX_DONT_SYNC]"
        }
    }
},
{
    "kprobe:vfs_getattr_nosec": {
        "description": "Get attributes without calling security_inode_getattr. Currently the only caller other than vfs_getattr is internal to the filehandle lookup code, which uses only the inode number and returns no attributes to any user. Any other code probably wants vfs_getattr.",
        "proto" :"int vfs_getattr_nosec(const struct path *path, struct kstat *stat, u32 request_mask, unsigned int query_flags)",
        "pre": {
            "path": "!=null",
            "stat": "!=null",
            "request_mask": "in [STATX_TYPE, STATX_MODE, STATX_NLINK, STATX_UID, STATX_GID, STATX_ATIME, STATX_MTIME, STATX_CTIME, STATX_INO, STATX_SIZE, STATX_BLOCKS, STATX_BASIC_STATS, STATX_BTIME, STATX_ALL]",
            "query_flags": "in [AT_STATX_SYNC_TYPE]"
        },
    }
},
{
    "kretprobe:inode_set_bytes": {
        "description": "Caller is here responsible for sufficient locking (ie. inode->i_lock)",
        "proto" :"static void (*inode_set_bytes)(struct inode *inode, loff_t bytes)",
        "pre": {
            "inode": "!=null",
            "bytes": ">=0"
        }
    }
},
{
    "kprobe:inode_set_bytes": {
        "description": "Caller is here responsible for sufficient locking (ie. inode->i_lock)",
        "proto" :"static void (*inode_set_bytes)(struct inode *inode, loff_t bytes)",
        "pre": {
            "inode": "!=null",
            "bytes": ">=0",
            "inode->i_lock": "is locked"
        }
    }
},
{
    "kretprobe:alloc_empty_file": {
        "description": "Allocates and initializes a new file structure.",
        "proto" :"struct file *(*alloc_empty_file)(int flags, const struct cred *cred)",
        "pre": {
            "flags": ">=0",
            "cred": "!=null",
        },
    }
},
{
    "kprobe:alloc_empty_file": {
        "description": "fput() time.",
        "proto" :"struct file *(*alloc_empty_file)(int flags, const struct cred *cred)",
        "pre": {
            "flags": ">=0",
            "cred": "!=null",
        },
    }
},
{
    "kretprobe:inode_init_always": {
        "description": "Perform inode structure initialisation. These are initializations that need to be done on every inode allocation as the fields are not initialised by slab allocation.",
        "proto" :"int (*inode_init_always)(struct super_block *sb, struct inode *inode)",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        },
    }
},
{
    "kprobe:inode_init_always": {
        "description": "Perform inode structure initialisation. These are initializations that need to be done on every inode allocation as the fields are not initialised by slab allocation.",
        "proto" :"int (*inode_init_always)(struct super_block *sb, struct inode *inode)",
        "pre": {
            "sb": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:drop_nlink": {
        "description": "Directly drop an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. In cases where we are attempting to track writes to the filesystem, a decrement to zero means an imminent write when the file is truncated and actually unlinked on the filesystem.",
        "proto" :"void (*drop_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:drop_nlink": {
        "description": "Directly drop an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. In cases where we are attempting to track writes to the filesystem, a decrement to zero means an imminent write when the file is truncated and actually unlinked on the filesystem.",
        "proto" :"void (*drop_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:clear_nlink": {
        "description": "Directly zero an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. See drop_nlink() for why we care about i_nlink hitting zero.",
        "proto" :"void (*clear_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:clear_nlink": {
        "description": "Directly zero an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. See drop_nlink() for why we care about i_nlink hitting zero.",
        "proto" :"void (*clear_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:set_nlink": {
        "description": "Directly set an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink.",
        "proto" :"void (*set_nlink)(struct inode *inode, unsigned int nlink)",
        "pre": {
            "inode": "!=null",
            "nlink": ">0"
        }
    }
},
{
    "kprobe:set_nlink": {
        "description": "Directly set an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink.",
        "proto" :"static void (*set_nlink)(struct inode *inode, unsigned int nlink)",
        "pre": {
            "inode": "!=null",
            "nlink": ">0",
        },
    }
},
{
    "kretprobe:inc_nlink": {
        "description": "Directly increment an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. Currently, it is only here for parity with dec_nlink().",
        "proto" :"void (*inc_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inc_nlink": {
        "description": "Directly increment an inode's link count. This is a low-level filesystem helper to replace any direct filesystem manipulation of i_nlink. Currently, it is only here for parity with dec_nlink().",
        "proto" :"static void (*inc_nlink)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:__insert_inode_hash": {
        "description": "Hash an inode and add it to the inode hash for this superblock.",
        "proto" :"void (*__insert_inode_hash)(struct inode *inode, unsigned long hashval)",
        "pre": {
            "inode": "!=null",
            "hashval": "is an unsigned long"
        }
    }
},
{
    "kprobe:__insert_inode_hash": {
        "description": "Add an inode to the inode hash for this superblock.",
        "proto" :"static void (*__insert_inode_hash)(struct inode *inode, unsigned long hashval)",
        "pre": {
            "inode": "!=null",
            "hashval": "is an unsigned long"
        },
    }
},
{
    "kretprobe:__remove_inode_hash": {
        "description": "Remove an inode from the superblock.",
        "proto" :"void (*__remove_inode_hash)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:__remove_inode_hash": {
        "description": "Remove an inode from the superblock.",
        "proto" :"static void (*__remove_inode_hash)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:clear_inode": {
        "description": "We have to cycle the i_pages lock here because reclaim can be in the process of removing the last page (in __filemap_remove_folio()) and we must not free the mapping under it.",
        "proto" :"void clear_inode(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
    }
},
{
    "kprobe:clear_inode": {
        "description": "We have to cycle the i_pages lock here because reclaim can be in the process of removing the last page (in __filemap_remove_folio()) and we must not free the mapping under it.",
        "proto" :"static void (*clear_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null",
        },
    }
},
{
    "kretprobe:get_next_ino": {
        "description": "get_next_ino should not provide a 0 inode number.",
        "proto" :"static unsigned int (*get_next_ino)(void)",
        "pre": {},
        "post": {
            "return": "> 0"
        }
    }
},
{
    "kprobe:get_next_ino": {
        "description": "get_next_ino should not provide a 0 inode number.",
        "proto" :"static unsigned int (*get_next_ino)(void)",
        "pre": {},
        "post": {
            "return": "!=0"
        }
    }
},
{
    "kretprobe:new_inode_pseudo": {
        "description": "Allocates a new inode for given superblock. Inode won't be chained in superblock's inodes list. This means: - fs can't be unmount - quotas, fsnotify, writeback can't work.",
        "proto" :"struct inode *(*new_inode_pseudo)(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:new_inode_pseudo": {
        "description": "Allocates a new inode for given superblock. Inode won't be chained in superblock's s_inodes list. This means: - fs can't be unmount - quotas, fsnotify, writeback can't work.",
        "proto" :"struct inode *(*new_inode_pseudo)(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:lockdep_annotate_inode_mutex_key": {
        "description": "Set new key only if filesystem hasn't already changed it.",
        "proto" :"static void (*lockdep_annotate_inode_mutex_key)(struct inode *inode)",
        "pre": {
            "inode": "!=null",
            "inode->i_mode": "in [S_IFDIR, S_IFREG, S_IFLNK, S_IFBLK, S_IFCHR, S_IFIFO, S_IFSOCK]",
            "inode->i_sb->s_type": "!=null"
        },
    }
},
{
    "kprobe:lockdep_annotate_inode_mutex_key": {
        "description": "Set new key only if filesystem hasn't already changed it.",
        "proto" :"static void (*lockdep_annotate_inode_mutex_key)(struct inode *inode)",
        "pre": {
            "inode": "!=null",
            "inode->i_mode": "in [S_IFDIR, S_IFREG, S_IFLNK, S_IFBLK, S_IFCHR, S_IFIFO, S_IFSOCK]",
            "inode->i_sb->s_type": "!=null",
        },
    }
},
{
    "kretprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters. Called when the inode is fully initialised to clear the new state of the inode and wake up anyone waiting for the inode to finish initialisation.",
        "proto" :"void (*unlock_new_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:unlock_new_inode": {
        "description": "Clear the I_NEW state and wake up any waiters. Called when the inode is fully initialised to clear the new state of the inode and wake up anyone waiting for the inode to finish initialisation.",
        "proto" :"void (*unlock_new_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects. Lock any non-NULL argument. Passed objects must not be directories. Zero, one or two objects may be locked by this function.",
        "proto" :"void (*lock_two_nondirectories)(struct inode *inode1, struct inode *inode2)",
        "pre": {
            "inode1": "!=null && !is_directory(inode1)",
            "inode2": "!=null && !is_directory(inode2)"
        }
    }
},
{
    "kprobe:lock_two_nondirectories": {
        "description": "Take two i_mutexes on non-directory objects. Lock any non-NULL argument. Passed objects must not be directories. Zero, one or two objects may be locked by this function.",
        "proto" :"void (*lock_two_nondirectories)(struct inode *inode1, struct inode *inode2)",
        "pre": {
            "inode1": "!=null && !is_directory(inode1)",
            "inode2": "!=null && !is_directory(inode2)"
        }
    }
},
{
    "kretprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "proto" :"static void (*unlock_two_nondirectories)(struct inode *inode1, struct inode *inode2)",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kprobe:unlock_two_nondirectories": {
        "description": "Release locks from lock_two_nondirectories()",
        "proto" :"static void (*unlock_two_nondirectories)(struct inode *inode1, struct inode *inode2)",
        "pre": {
            "inode1": "!=null",
            "inode2": "!=null"
        }
    }
},
{
    "kretprobe:inode_insert5": {
        "description": "iget5_locked() for callers that don't want to fail on memory allocation of inode. If the inode is not in cache, insert the pre-allocated inode to cache and return it locked, hashed, and with the I_NEW flag set. The file system gets to fill it in before unlocking it via unlock_new_inode(). Note both @test and @set are called with the inode_hash_lock held, so can't sleep.",
        "proto" :"struct inode *(*inode_insert5)(struct inode *inode, unsigned long hashval, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *data)",
        "pre": {
            "inode": "!=null",
            "hashval": "is unsigned long",
            "test": "!=null",
            "set": "!=null",
            "data": "can be null or !=null"
        }
    }
},
{
    "kprobe:inode_insert5": {
        "description": "iget5_locked() for callers that don't want to fail on memory allocation of inode. If the inode is not in cache, insert the pre-allocated inode to cache and return it locked, hashed, and with the I_NEW flag set. The file system gets to fill it in before unlocking it via unlock_new_inode(). Note both @test and @set are called with the inode_hash_lock held, so can't sleep.",
        "proto" :"struct inode *(*inode_insert5)(struct inode *inode, unsigned long hashval, int (*test)(struct inode *, void *), int (*set)(struct inode *, void *), void *data)",
        "pre": {
            "inode": "!=null",
            "hashval": "is an unsigned long",
            "test": "!=null && is a function",
            "set": "!=null && is a function",
            "data": "can be any value"
        }
    }
},
{
    "kretprobe:find_inode_fast": {
        "description": "iget_locked for details.",
        "proto" :"static struct inode *(*find_inode_fast)(struct super_block *sb, struct hlist_head *head, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "head": "!=null",
            "ino": ">=0",
        },
    }
},
{
    "kprobe:find_inode_fast": {
        "description": "iget_locked for details.",
        "proto" :"static struct inode *(*find_inode_fast)(struct super_block *sb, struct hlist_head *head, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "head": "!=null",
            "ino": "!=0",
        },
    }
},
{
    "kretprobe:iunique_lock": {
        "description": "Locks the inode_hash_lock",
        "proto" :"static void (*iunique_lock)(DEFINE_SPINLOCK(inode_hash_lock))",
        "pre": {
            "inode_hash_lock": "!=null",
        },
    }
},
{
    "kprobe:iunique_lock": {
        "description": "Locks the inode_hash_lock.",
        "proto" :"static void (*iunique_lock)(DEFINE_SPINLOCK(inode_hash_lock))",
        "pre": {
            "inode_hash_lock": "!=null",
        },
    }
},
{
    "kretprobe:igrab": {
        "description": "Increments the reference count of *inode* if it is not being freed. Otherwise, sets *inode* to NULL.",
        "proto": "struct inode* (*igrab)(struct inode* inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:igrab": {
        "description": "Increments the reference count of *inode* if it is not being freed.",
        "proto": "struct inode* (*igrab)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:ilookup5_nowait": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache. If the inode is in the cache, the inode is returned with an incremented reference count. Note: I_NEW is not waited upon so you have to be very careful what you do with the returned inode. You probably should be using ilookup5() instead. Note2: @test is called with the inode_hash_lock held, so can't sleep.",
        "proto" :"struct inode *(*ilookup5_nowait)(struct super_block *sb, unsigned long hashval,int (*test)(struct inode *, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": ">=0",
            "test": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ilookup5_nowait": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache. If the inode is in the cache, the inode is returned with an incremented reference count. Note: I_NEW is not waited upon so you have to be very careful what you do with the returned inode. You probably should be using ilookup5() instead. Note2: @test is called with the inode_hash_lock held, so can't sleep.",
        "proto" :"struct inode *(*ilookup5_nowait)(struct super_block *sb, unsigned long hashval, int (*test)(struct inode *, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": "is a valid unsigned long",
            "test": "!=null and is a valid function pointer",
            "data": "can be null or non-null"
        },
    }
},
{
    "kretprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system. If the inode is not in cache, allocate a new inode and return it locked, hashed, and with the I_NEW flag set.",
        "proto" :"struct inode *(*iget_locked)(struct super_block *sb, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "ino": "is a valid inode number"
        },
        "post": {
            "return": "!=null && (return->i_state == I_NEW || inode number is in cache)"
        }
    }
},
{
    "kprobe:iget_locked": {
        "description": "Obtain an inode from a mounted file system. Search for the inode specified by @ino in the inode cache and if present return it with an increased reference count. This is for file systems where the inode number is sufficient for unique identification of an inode. If the inode is not in cache, allocate a new inode and return it locked, hashed, and with the I_NEW flag set. The file system gets to fill it in before unlocking it via unlock_new_inode().",
        "proto" :"struct inode *(*iget_locked)(struct super_block *sb, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "ino": "is a valid inode number"
        },
    }
},
{
    "kretprobe:find_inode_nowait": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache, where the helper function @match will return 0 if the inode does not match, 1 if the inode does match, and -1 if the search should be stopped. The @match function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized, and incrementing the reference count before returning 1. It also must not sleep, since it is called with the inode_hash_lock spinlock held. This is a even more generalized version of ilookup5() when the function must never block --- find_inode() can block in __wait_on_freeing_inode() --- or when the caller can not increment the reference count because the resulting iput() might cause an inode eviction. The tradeoff is that the @match funtion must be very carefully implemented.",
        "proto" :"struct inode *(*find_inode_nowait)(struct super_block *sb, unsigned long hashval, int (*match)(struct inode *, unsigned long, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": "is a valid hash value",
            "match": "!=null and is a valid function that returns 0 if the inode does not match, 1 if the inode does match, and -1 if the search should be stopped",
            "data": "can be null or non-null"
        }
    }
},
{
    "kprobe:find_inode_nowait": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache, where the helper function @match will return 0 if the inode does not match, 1 if the inode does match, and -1 if the search should be stopped. The @match function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized, and incrementing the reference count before returning 1. It also must not sleep, since it is called with the inode_hash_lock spinlock held. This is a even more generalized version of ilookup5() when the function must never block --- find_inode() can block in __wait_on_freeing_inode() --- or when the caller can not increment the reference count because the resulting iput() might cause an inode eviction. The tradeoff is that the @match funtion must be very carefully implemented.",
        "proto" :"struct inode *(*find_inode_nowait)(struct super_block *sb, unsigned long hashval, int (*match)(struct inode *, unsigned long, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": "is a valid hash value",
            "match": "!=null and is a valid function that returns -1, 0, or 1",
            "data": "can be null or non-null"
        },
    }
},
{
    "kretprobe:find_inode_rcu": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache, where the helper function @test will return 0 if the inode does not match and 1 if it does. The @test function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized. If successful, this will return the inode for which the @test function returned 1 and NULL otherwise. The @test function is not permitted to take a ref on any inode presented. It is also not permitted to sleep. The caller must hold the RCU read lock.",
        "proto" :"struct inode *(*find_inode_rcu)(struct super_block *sb, unsigned long hashval, int (*test)(struct inode *, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": "is unsigned long",
            "test": "!=null && is function",
            "data": "!=null"
        },
    }
},
{
    "kprobe:find_inode_rcu": {
        "description": "Search for the inode specified by @hashval and @data in the inode cache, where the helper function @test will return 0 if the inode does not match and 1 if it does. The @test function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized. If successful, this will return the inode for which the @test function returned 1 and NULL otherwise. The @test function is not permitted to take a ref on any inode presented. It is also not permitted to sleep. The caller must hold the RCU read lock.",
        "proto" :"struct inode *(*find_inode_rcu)(struct super_block *sb, unsigned long hashval, int (*test)(struct inode *, void *), void *data)",
        "pre": {
            "sb": "!=null",
            "hashval": "is unsigned long",
            "test": "!=null",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache. Search for the inode specified by @hashval and @data in the inode cache, where the helper function @test will return 0 if the inode does not match and 1 if it does. The @test function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized. If successful, this will return the inode for which the @test function returned 1 and NULL otherwise. The @test function is not permitted to take a ref on any inode presented. It is also not permitted to sleep. The caller must hold the RCU read lock.",
        "proto" :"struct inode *(*find_inode_by_ino_rcu)(struct super_block *sb, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "ino": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:find_inode_by_ino_rcu": {
        "description": "Find an inode in the inode cache. Search for the inode specified by @hashval and @data in the inode cache, where the helper function @test will return 0 if the inode does not match and 1 if it does. The @test function must be responsible for taking the i_lock spin_lock and checking i_state for an inode being freed or being initialized. If successful, this will return the inode for which the @test function returned 1 and NULL otherwise. The @test function is not permitted to take a ref on any inode presented. It is also not permitted to sleep. The caller must hold the RCU read lock.",
        "proto" :"struct inode *(*find_inode_by_ino_rcu)(struct super_block *sb, unsigned long ino)",
        "pre": {
            "sb": "!=null",
            "ino": "is valid inode number",
            "caller": "holds RCU read lock"
        },
    }
},
{
    "kretprobe:inode_lru_isolate": {
        "description": "iput_final(). When we encounter such an inode, clear the flag and move it to the back of the LRU so it gets another pass through the LRU before it gets reclaimed. This is necessary because of the fact we are doing lazy LRU updates to minimise lock contention so the LRU does not have strict ordering. Hence we don't want to reclaim inodes with this flag set because they are the inodes that are out of order.",
        "proto" :"static enum lru_status inode_lru_isolate(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)",
        "pre": {
            "item": "!=null",
            "lru": "!=null",
            "lru_lock": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:inode_lru_isolate": {
        "description": "iput_final(). When we encounter such an inode, clear the flag and move it to the back of the LRU so it gets another pass through the LRU before it gets reclaimed. This is necessary because of the fact we are doing lazy LRU updates to minimise lock contention so the LRU does not have strict ordering. Hence we don't want to reclaim inodes with this flag set because they are the inodes that are out of order.",
        "proto" :"static enum lru_status inode_lru_isolate(struct list_head *item,struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)",
        "pre": {
            "item": "!=null",
            "lru": "!=null",
            "lru_lock": "!=null",
            "arg": "!=null"
        },
    }
},
{
    "kretprobe:bmap": {
        "description": "Find a block number in a file. Replaces the value in `block` with the block number on the device holding corresponding to the requested block number in the file. Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a hole, returns 0 and `block` is also set to 0.",
        "proto" :"int (*bmap)(struct inode *inode, sector_t *block)",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "block": ">=0"
        }
    }
},
{
    "kprobe:bmap": {
        "description": "Find a block number in a file. Replaces the value in `block` with the block number on the device holding corresponding to the requested block number in the file. Returns -EINVAL in case of error, 0 otherwise. If mapping falls into a hole, returns 0 and `block` is also set to 0.",
        "proto" :"int (*bmap)(struct inode *inode, sector_t *block)",
        "pre": {
            "inode": "!=null",
            "block": "!=null"
        },
    }
},
{
    "kretprobe:touch_atime": {
        "description": "Updates the access time of the file if necessary.",
        "proto" :"static void (*touch_atime)(const struct path *path)",
        "pre": {
            "path": "!=null",
            // Add more conditions here
        },
    }
},
{
    "kprobe:touch_atime": {
        "description": "Updates the access time of a file. If the file system is unable to update the inode, the function will ignore the return value. This function may fail on file systems that have the ability to make parts of the fs read only, e.g. subvolumes in Btrfs.",
        "proto" :"void touch_atime(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:file_remove_privs": {
        "description": "Remove special file privileges (suid, capabilities) from a file when it is modified by a write or truncation.",
        "proto" :"int (*file_remove_privs)(struct file *file)",
        "pre": {
            "file": "!=null"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:file_remove_privs": {
        "description": "Remove special file privileges (suid, capabilities) when file is modified by a write or truncation.",
        "proto" :"int (*file_remove_privs)(struct file *file)",
        "pre": {
            "file": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kretprobe:file_update_time": {
        "description": "Try to update time settings",
        "proto" :"static int (*file_update_time)(struct file *file, struct timespec64 *now, int sync_mode)",
        "pre": {
            "file": "!=null",
            "now": "!=null",
            "sync_mode": "in [SYNC_MODE_1, SYNC_MODE_2, SYNC_MODE_3]",
        },
    }
},
{
    "kprobe:file_update_time": {
        "description": "Try to update time settings",
        "proto" :"file_update_time(struct file  file, struct timespec64  now,int sync_mode)",
        "pre": {
            "file": "!=null",
            "now": "!=null",
            "sync_mode": "in [your specific conditions]",
        },
    }
},
{
    "kretprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file. When file has been modified ensure that special file privileges are removed and time settings are updated. If IOCB_NOWAIT is set, special file privileges will not be removed and time settings will not be updated. It will return -EAGAIN. Caller must hold the file's inode lock.",
        "proto": "static int file_modified_flags(struct file *file, int flags)",
        "pre": {
            "file": "!=null",
            "flags": "in [IOCB_NOWAIT, IOCB_DIRECT]",
        },
        "post": {
            "return": "in [0, -EAGAIN, -errno]"
        }
    }
},
{
    "kprobe:file_modified_flags": {
        "description": "Handle mandated vfs changes when modifying a file. When file has been modified ensure that special file privileges are removed and time settings are updated. If IOCB_NOWAIT is set, special file privileges will not be removed and time settings will not be updated. It will return -EAGAIN. Context: Caller must hold the file's inode lock.",
        "proto": "static int (*file_modified_flags)(struct file *file, int flags)",
        "pre": {
            "file": "!=null",
            "flags": "in [IOCB_NOWAIT, ...]"
        },
        "post": {
            "return": "in [0, -EAGAIN, ...]"
        }
    }
},
{
    "kretprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device. The function sets the file operations and device based on the mode.",
        "proto" :"void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)",
        "pre": {
            "inode": "!=null",
            "mode": "in [S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK]",
            "rdev": "is valid device"
        },
    }
},
{
    "kprobe:init_special_inode": {
        "description": "Initialize a special inode with the given mode and device. The function sets the file operations and device based on the mode.",
        "proto" :"static void (*init_special_inode)(struct inode *inode, umode_t mode, dev_t rdev)",
        "pre": {
            "inode": "!=null",
            "mode": "in [S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK]",
            "rdev": "is valid device"
        },
    }
},
{
    "kretprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards. If the inode has been created through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions and initializing i_uid and i_gid. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"void inode_init_owner(struct mnt_idmap *idmap, struct inode *inode, const struct inode *dir, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "is umode_t"
        }
    }
},
{
    "kprobe:inode_init_owner": {
        "description": "Init uid,gid,mode for new inode according to posix standards. If the inode has been created through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions and initializing i_uid and i_gid. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"void inode_init_owner(struct mnt_idmap *idmap, struct inode *inode, const struct inode *dir, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "dir": "!=null",
            "mode": "in [S_IRWXU, S_IRWXG, S_IRWXO]"
        }
    }
},
{
    "kretprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode. Return true if current either has CAP_FOWNER in a namespace with the inode owner uid mapped, or owns the file. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"bool (*inode_owner_or_capable)(struct mnt_idmap *idmap, const struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_owner_or_capable": {
        "description": "Check current task permissions to inode. Return true if current either has CAP_FOWNER in a namespace with the inode owner uid mapped, or owns the file. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"bool (*inode_owner_or_capable)(struct mnt_idmap *idmap, const struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_dio_wait": {
        "description": "Waits for all pending direct IO requests to finish so that we can proceed with a truncate or equivalent operation. Must be called under a lock that serializes taking new references to i_dio_count, usually by inode->i_mutex.",
        "proto" :"void (*inode_dio_wait)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:inode_dio_wait": {
        "description": "Waits for all pending direct IO requests to finish so that we can proceed with a truncate or equivalent operation. Must be called under a lock that serializes taking new references to i_dio_count, usually by inode->i_mutex.",
        "proto" :"void inode_dio_wait(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:inode_set_flags": {
        "description": "Atomically set some inode flags. The caller should be holding i_mutex, or else be sure that they have exclusive access to the inode structure. The reason for the cmpxchg() loop is that there is at least one code path which doesn't today so we use cmpxchg() out of an abundance of caution.",
        "proto" :"void (*inode_set_flags)(struct inode *inode, unsigned int flags, unsigned int mask)",
        "pre": {
            "inode": "!=null",
            "flags": "in [0, UINT_MAX]",
            "mask": "in [0, UINT_MAX]"
        }
    }
},
{
    "kprobe:inode_set_flags": {
        "description": "Atomically set some inode flags. The caller should be holding i_mutex, or else be sure that they have exclusive access to the inode structure. The reason for the cmpxchg() loop is that there is at least one code path which doesn't today so we use cmpxchg() out of an abundance of caution. In the long run, i_mutex is overkill, and we should probably look at using the i_lock spinlock to protect i_flags, and then make sure it is so documented in includelinuxfs.h and that all code follows the locking convention.",
        "proto" :"void inode_set_flags(struct inode *inode, unsigned int flags, unsigned int mask)",
        "pre": {
            "inode": "!=null",
            "flags": "is unsigned int",
            "mask": "is unsigned int"
        }
    }
},
{
    "kretprobe:timestamp_truncate": {
        "description": "Truncate a timespec to the granularity supported by the fs containing the inode. Always rounds down. gran must not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).",
        "proto" :"struct timespec64 (*timestamp_truncate)(struct timespec64 t, struct inode *inode)",
        "pre": {
            "t": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "<=t && >=0 && <NSEC_PER_SEC"
        }
    }
},
{
    "kprobe:timestamp_truncate": {
        "description": "Truncate a timespec to the granularity supported by the fs containing the inode. Always rounds down. gran must not be 0 nor greater than a second (NSEC_PER_SEC, or 10^9 ns).",
        "proto" :"struct timespec64 (*timestamp_truncate)(struct timespec64 t, struct inode *inode)",
        "pre": {
            "t": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:current_time": {
        "description": "Get the current time.",
        "proto" :"static struct timespec64 (*current_time)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},

{
    "kretprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories. If the @mode of the new file has both the S_ISGID and S_IXGRP bit raised and @dir has the S_ISGID bit raised ensure that the caller is either in the group of the parent directory or they have CAP_FSETID in their user namespace and are privileged over the parent directory. In all other cases, strip the S_ISGID bit from @mode.",
        "proto" :"umode_t (*mode_strip_sgid)(struct mnt_idmap *idmap, const struct inode *dir, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "in [S_ISGID, S_IXGRP, S_ISGID | S_IXGRP]"
        },
    }
},
{
    "kprobe:mode_strip_sgid": {
        "description": "Handle the sgid bit for non-directories. If the mode of the new file has both the S_ISGID and S_IXGRP bit raised and dir has the S_ISGID bit raised ensure that the caller is either in the group of the parent directory or they have CAP_FSETID in their user namespace and are privileged over the parent directory. In all other cases, strip the S_ISGID bit from mode.",
        "proto" :"umode_t (*mode_strip_sgid)(struct mnt_idmap *idmap, const struct inode *dir, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "mode": "in [S_ISGID, S_IXGRP, CAP_FSETID]",
        },
    }
},


{
    "kretprobe:if_cprm_to_skip": {
        "description": "Description of the function goes here",
        "proto" :"Function prototype goes here",
        "pre": {
            "cprm": "!=null",
            "to_skip": "!=null",
        },
    }
},

{
    "kretprobe:vfs_ioctl": {
        "description": "Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise returns -ENOTTY. Returns 0 on success, -errno on error.",
        "proto" :"long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
        "pre": {
            "filp": "!=null",
            "cmd": "is a valid ioctl command",
            "arg": "is a valid argument for the ioctl command"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:vfs_ioctl": {
        "description": "Call filesystem specific ioctl methods. Invokes filesystem specific ->unlocked_ioctl, if one exists; otherwise returns -ENOTTY. Returns 0 on success, -errno on error.",
        "proto" :"long vfs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)",
        "pre": {
            "filp": "!=null",
            "cmd": "is a valid ioctl command",
            "arg": "is a valid argument for the ioctl command"
        },
    }
},
{
    "kretprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function. Called from file system ->fiemap callback. Will populate extent info as passed in via arguments and copy to user memory. On success, extent count on fieinfo is incremented. Returns 0 on success, -errno on error, 1 if this was the last extent that will fit in user array.",
        "proto" :"int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical, u64 phys, u64 len, u32 flags)",
        "pre": {
            "fieinfo": "!=null",
            "logical": ">=0",
            "phys": ">=0",
            "len": ">=0",
            "flags": "in [SET_UNKNOWN_FLAGS(FIEMAP_EXTENT_DELALLOC), SET_NO_UNMOUNTED_IO_FLAGS(FIEMAP_EXTENT_DATA_ENCRYPTED), SET_NOT_ALIGNED_FLAGS(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)]",
        },
    }
},
{
    "kprobe:fiemap_fill_next_extent": {
        "description": "Fiemap helper function. Called from file system ->fiemap callback. Will populate extent info as passed in via arguments and copy to user memory. On success, extent count on fieinfo is incremented. Returns 0 on success, -errno on error, 1 if this was the last extent that will fit in user array.",
        "proto" :"int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical, u64 phys, u64 len, u32 flags)",
        "pre": {
            "fieinfo": "!=null",
            "logical": ">=0",
            "phys": ">=0",
            "len": ">=0",
            "flags": "in [FIEMAP_EXTENT_DELALLOC, FIEMAP_EXTENT_DATA_ENCRYPTED, FIEMAP_EXTENT_DATA_TAIL, FIEMAP_EXTENT_DATA_INLINE]"
        },
    }
},
{
    "kretprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap. This function must be called from each ->fiemap instance to validate the fiemap request against the file system parameters.",
        "proto" :"int fiemap_prep(struct inode *inode, struct fiemap_extent_info *fieinfo, u64 start, u64 *len, u32 supported_flags)",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": ">=0",
            "len": "!=null && *len >= 0",
            "supported_flags": "in [FIEMAP_FLAG_SYNC, FIEMAP_FLAG_XATTR, FIEMAP_FLAG_CACHE, FIEMAP_FLAG_FS_IOC_FIEMAP]"
        },
    }
},
{
    "kprobe:fiemap_prep": {
        "description": "Check validity of requested flags for fiemap. This function must be called from each ->fiemap instance to validate the fiemap request against the file system parameters.",
        "proto" :"int (*fiemap_prep)(struct inode *inode, struct fiemap_extent_info *fieinfo, u64 start, u64 *len, u32 supported_flags)",
        "pre": {
            "inode": "!=null",
            "fieinfo": "!=null",
            "start": ">=0",
            "len": "!=null && *len >= 0",
            "supported_flags": "in [FIEMAP_FLAG_SYNC, FIEMAP_FLAG_XATTR, FIEMAP_FLAG_CACHE, FIEMAP_FLAG_FS_EOF]"
        },
    }
},
{
    "kretprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags. Set ->fsx_xflags, ->fsx_valid and ->flags (translated xflags). All other fields are zeroed.",
        "proto" :"void (*fileattr_fill_xflags)(struct fileattr *fa, u32 xflags)",
        "pre": {
            "fa": "!=null",
            "xflags": "in [FS_XFLAG_]"
        }
    }
},
{
    "kprobe:fileattr_fill_xflags": {
        "description": "Initialize fileattr with xflags. Set ->fsx_xflags, ->fsx_valid and ->flags (translated xflags). All other fields are zeroed.",
        "proto" :"void (*fileattr_fill_xflags)(struct fileattr *fa, u32 xflags)",
        "pre": {
            "fa": "!=null",
            "xflags": "in [FS_XFLAG_...]"
        }
    }
},
{
    "kretprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags. Set ->flags, ->flags_valid and ->fsx_xflags (translated flags). All other fields are zeroed.",
        "proto": "void (*fileattr_fill_flags)(struct fileattr *fa, u32 flags)",
        "pre": {
            "fa": "!=null",
            "flags": "in [FS_ _FL flags]"
        }
    }
},
{
    "kprobe:fileattr_fill_flags": {
        "description": "Initialize fileattr with flags, set ->flags, ->flags_valid and ->fsx_xflags (translated flags). All other fields are zeroed.",
        "proto" :"static void (*fileattr_fill_flags)(struct fileattr *fa, u32 flags)",
        "pre": {
            "fa": "!=null",
            "flags": "in [FS_ _FL flags]"
        }
    }
},
{
    "kretprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes. Call i_op->fileattr_get() callback, if exists.",
        "proto" :"int vfs_fileattr_get(struct dentry *dentry, struct fileattr *fa)",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:vfs_fileattr_get": {
        "description": "Retrieve miscellaneous file attributes. Call i_op->fileattr_get() callback, if exists.",
        "proto" :"int (*vfs_fileattr_get)(struct dentry *dentry, struct fileattr *fa)",
        "pre": {
            "dentry": "!=null",
            "fa": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kretprobe:copy_fsxattr_to_user": {
        "description": "copy fsxattr to userspace. @fa:fileattr pointer @ufa:fsxattr user pointer. Return: 0 on success, or -EFAULT on failure.",
        "proto" :"int (*copy_fsxattr_to_user)(const struct fileattr *fa, struct fsxattr __user *ufa)",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT]"
        }
    }
},
{
    "kprobe:copy_fsxattr_to_user": {
        "description": "Copy fsxattr to userspace. Return: 0 on success, or -EFAULT on failure.",
        "proto" :"int (*copy_fsxattr_to_user)(const struct fileattr *fa, struct fsxattr __user *ufa)",
        "pre": {
            "fa": "!=null",
            "ufa": "!=null"
        },
    }
},
{
    "kretprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes. After verifying permissions, call i_op->fileattr_set() callback, if exists. Verifying attributes involves retrieving current attributes with i_op->fileattr_get(), this also allows initializing attributes that have not been set by the caller to current values. Inode lock is held thoughout to prevent racing with another instance.",
        "proto" :"int (*vfs_fileattr_set)(struct mnt_idmap *idmap, struct dentry *dentry, struct fileattr *fa)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kprobe:vfs_fileattr_set": {
        "description": "Change miscellaneous file attributes. After verifying permissions, call i_op->fileattr_set() callback, if exists. Verifying attributes involves retrieving current attributes with i_op->fileattr_get(), this also allows initializing attributes that have not been set by the caller to current values. Inode lock is held thoughout to prevent racing with another instance.",
        "proto" :"int (*vfs_fileattr_set)(struct mnt_idmap *idmap, struct dentry *dentry, struct fileattr *fa)",
        "pre": {
            "idmap": "!=null",
            "dentry": "!=null",
            "fa": "!=null"
        },
        "post": {
            "return": "in [0, negative error]"
        }
    }
},
{
    "kretprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation. This function either ignores the argument or passes a pointer to a compatible data type. It must be used only with ioctl functions that either ignore the argument or pass a pointer to a compatible data type. If any ioctl command handled by fops->unlocked_ioctl passes a plain integer instead of a pointer, or any of the passed data types is incompatible between 32-bit and 64-bit architectures, a proper handler is required instead of compat_ptr_ioctl.",
        "proto" :"long (*compat_ptr_ioctl)(struct file *file, unsigned int cmd, unsigned long arg)",
        "pre": {
            "file": "!=null",
            "cmd": "is a valid ioctl command",
            "arg": "is either ignored or a pointer to a compatible data type"
        }
    }
},
{
    "kprobe:compat_ptr_ioctl": {
        "description": "Generic implementation of .compat_ioctl file operation. This function is used to handle ioctl commands and should only be used with ioctl functions that either ignore the argument or pass a pointer to a compatible data type.",
        "proto" :"long (*compat_ptr_ioctl)(struct file *file, unsigned int cmd, unsigned long arg)",
        "pre": {
            "file": "!=null",
            "cmd": "is an unsigned integer",
            "arg": "is an unsigned long or a pointer to a compatible data type"
        },
    }
},
{
    "kretprobe:generic_remap_file_range_prep": {
        "description": "Don't touch certain kinds of inodes",
        "proto": "int generic_remap_file_range_prep(struct file file_in, loff_t pos_in, struct file file_out, loff_t pos_out, loff_t len, unsigned int remap_flags, const struct iomap_ops dax_read_ops)",
        "pre": {
            "file_in": "!=null",
            "pos_in": ">=0",
            "file_out": "!=null",
            "pos_out": ">=0",
            "len": ">=0",
            "remap_flags": "is unsigned int",
            "dax_read_ops": "!=null"
        },
        "post": {
            "return": "in [-EPERM, -ETXTBSY]"
        }
    }
},

{
    "kretprobe:vfs_dedupe_file_range_one": {
        "description": "This function is used to deduplicate a range of a file. It checks various conditions and if any of them are not met, it returns an error code.",
        "proto" :"static long (*vfs_dedupe_file_range_one)(struct file src_file, loff_t src_pos, struct file dst_file, loff_t dst_pos, loff_t len, unsigned int remap_flags)",
        "pre": {
            "src_file": "!=null",
            "src_pos": ">=0",
            "dst_file": "!=null",
            "dst_pos": ">=0",
            "len": ">=0",
            "remap_flags": "in [REMAP_FILE_DEDUP, REMAP_FILE_CAN_SHORTEN]"
        },
    }
},
{
    "kprobe:vfs_dedupe_file_range_one": {
        "description": "This function is used to deduplicate a range of a file. It verifies the source and destination areas, checks if file deduplication is allowed, checks if the source and destination files are on the same file system, checks if the destination file is a directory, checks if the remap_file_range operation is supported, and checks if the length is zero.",
        "proto" :"vfs_dedupe_file_range_one(struct file  src_file, loff_t src_pos, struct file  dst_file, loff_t dst_pos, loff_t len, unsigned int remap_flags)",
        "pre": {
            "src_file": "!=null",
            "src_pos": ">=0",
            "dst_file": "!=null",
            "dst_pos": ">=0",
            "len": ">=0",
            "remap_flags": "in [REMAP_FILE_DEDUP, REMAP_FILE_CAN_SHORTEN]"
        },
    }
},
{
    "kretprobe:vfs_dedupe_file_range_compare": {
        "description": "This function is used to compare the data of two files in the specified range. It returns true if the data is the same, false otherwise.",
        "proto" :"int vfs_dedupe_file_range_compare(struct file *src, loff_t srcoff, struct file *dest, loff_t dstoff, loff_t len, bool *is_same)",
        "pre": {
            "src": "!=null",
            "srcoff": ">=0",
            "dest": "!=null",
            "dstoff": ">=0",
            "len": ">0",
            "is_same": "!=null"
        },
        "post": {
            "src_folio": "!=null && folio_test_uptodate(src_folio)",
            "dst_folio": "!=null && folio_test_uptodate(dst_folio)",
            "src_folio->mapping": "==src->f_mapping",
            "dst_folio->mapping": "==dest->f_mapping"
        }
    }
},
{
    "kprobe:vfs_dedupe_file_range_compare": {
        "description": "This function is used to compare the data in two files to check if they are the same. It locks both folios and checks if they're still mapped to the file data we're interested in.",
        "proto" :"vfs_dedupe_file_range_compare(struct file  src, loff_t srcoff, struct file  dest, loff_t dstoff, loff_t len, bool  is_same)",
        "pre": {
            "src": "!=null",
            "srcoff": ">=0",
            "dest": "!=null",
            "dstoff": ">=0",
            "len": ">=0",
            "is_same": "is boolean",
            "src_folio": "!=null && folio_test_uptodate(src_folio)",
            "dst_folio": "!=null && folio_test_uptodate(dst_folio)",
            "src_folio->mapping": "==src->f_mapping",
            "dst_folio->mapping": "==dest->f_mapping"
        },
    }
},
{
    "kretprobe:locks_alloc_lock": {
        "description": "Allocate an empty lock structure.",
        "proto" :"struct file_lock *(*locks_alloc_lock)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:locks_alloc_lock": {
        "description": "Allocate an empty lock structure.",
        "proto" :"struct file_lock *(*locks_alloc_lock)(void)",
        "pre": {},
        "post": {
            "return": "!=null",
            "return->fl_link": "is initialized",
            "return->fl_list": "is initialized",
            "return->fl_blocked_requests": "is initialized",
            "return->fl_blocked_member": "is initialized",
            "return->fl_wait": "is initialized"
        }
    }
},
{
    "kretprobe:locks_copy_lock": {
        "description": "\"new\" must be a freshly-initialized lock",
        "proto" :"static void (*locks_copy_lock)(struct file_lock *new, struct file_lock *fl)",
        "pre": {
            "new": "is freshly-initialized",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:locks_copy_lock": {
        "description": "Copy the lock from 'fl' to 'new'. 'new' must be a freshly-initialized lock.",
        "proto" :"static void (*locks_copy_lock)(struct file_lock *new, struct file_lock *fl)",
        "pre": {
            "new": "freshly-initialized",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:locks_delete_block": {
        "description": "Stop waiting for a file lock. Lockd/nfsd need to disconnect the lock while working on it.",
        "proto" :"void locks_delete_block(struct file_lock *waiter)",
        "pre": {
            "waiter": "!=null"
        }
    }
},

{
    "kretprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file. We merge adjacent & overlapping locks whenever possible. POSIX locks are sorted by owner task, then by starting address. Note that if called with an FL_EXISTS argument, the caller may determine whether or not a lock was successfully freed by testing the return value for -ENOENT.",
        "proto" :"int posix_lock_file(struct file *filp, struct file_lock *fl, struct file_lock *conflock)",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        },
    }
},
{
    "kprobe:posix_lock_file": {
        "description": "Apply a POSIX-style lock to a file. We merge adjacent & overlapping locks whenever possible. POSIX locks are sorted by owner task, then by starting address. Note that if called with an FL_EXISTS argument, the caller may determine whether or not a lock was successfully freed by testing the return value for -ENOENT.",
        "proto" :"int (*posix_lock_file)(struct file *filp, struct file_lock *fl, struct file_lock *conflock)",
        "pre": {
            "filp": "!=null",
            "fl": "!=null",
            "conflock": "!=null"
        },
    }
},
{
    "kretprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "proto": "static int lease_init(struct file *filp, long type, struct file_lock *fl)",
        "pre": {
            "filp": "!=null",
            "type": "is a valid lease type",
            "fl": "!=null"
        }
    }
},
{
    "kprobe:lease_init": {
        "description": "Initialize a lease, use the default lock manager operations",
        "proto" :"static int lease_init(struct file *filp, long type, struct file_lock *fl)",
        "pre": {
            "filp": "!=null",
            "type": "/* fill in the specific constraints for 'type' here */",
            "fl": "!=null"
        },
    }
},
{
    "kretprobe:__break_lease": {
        "description": "Revoke all outstanding leases on file. Leases are broken on a call to open() or truncate(). This function can sleep unless you specified %O_NONBLOCK to your open().",
        "proto" :"int (*__break_lease)(struct inode *inode, unsigned int mode, unsigned int type)",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        },
    }
},
{
    "kprobe:__break_lease": {
        "description": "Revoke all outstanding leases on file. Leases are broken on a call to open() or truncate(). This function can sleep unless you specified %O_NONBLOCK to your open().",
        "proto" :"int (*__break_lease)(struct inode *inode, unsigned int mode, unsigned int type)",
        "pre": {
            "inode": "!=null",
            "mode": "in [O_RDONLY, O_WRONLY, O_RDWR]",
            "type": "in [FL_LEASE, FL_DELEG]"
        },
    }
},
{
    "kretprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease. This is to force NFS clients to flush their caches for files with exclusive leases. The justification is that if someone has an exclusive lease, then they could be modifying it.",
        "proto": "void lease_get_mtime(struct inode *inode, struct timespec64 *time)",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kprobe:lease_get_mtime": {
        "description": "Update modified time of an inode with exclusive lease. This is to force NFS clients to flush their caches for files with exclusive leases. The justification is that if someone has an exclusive lease, then they could be modifying it.",
        "proto" :"static void (*lease_get_mtime)(struct inode *inode, struct timespec64 *time)",
        "pre": {
            "inode": "!=null",
            "time": "!=null"
        }
    }
},
{
    "kretprobe:generic_setlease": {
        "description": "Sets a lease on an open file @filp:file pointer @arg:type of lease to obtain @flp:input - file_lock to use, output - file_lock inserted @priv:private data for lm_setup (may be NULL if lm_setup doesn't require it). The (input) flp->fl_lmops->lm_break function is required by break_lease().",
        "proto" :"int (*generic_setlease)(struct file *filp, long arg, struct file_lock **flp, void **priv)",
        "pre": {
            "filp": "!=null",
            "arg": "is a valid lease type",
            "flp": "!=null && flp->fl_lmops->lm_break is a valid function",
            "priv": "can be null or valid private data"
        },
    }
},
{
    "kprobe:generic_setlease": {
        "description": "Sets a lease on an open file. The (input) flp->fl_lmops->lm_break function is required by break_lease().",
        "proto" :"int (*generic_setlease)(struct file *filp, long arg, struct file_lock **flp, void **priv)",
        "pre": {
            "filp": "!=null",
            "arg": "is a valid lease type",
            "flp": "!=null && flp->fl_lmops->lm_break !=null",
            "priv": "can be null or valid data for lm_setup"
        },
    }
},
{
    "kretprobe:locks_lock_inode_wait": {
        "description": "Apply a POSIX or FLOCK style lock request to an inode.",
        "proto" :"int (*locks_lock_inode_wait)(struct inode *inode, struct file_lock *fl)",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        },
    }
},
{
    "kprobe:locks_lock_inode_wait": {
        "description": "Apply a POSIX or FLOCK style lock request to an inode.",
        "proto" :"int (*locks_lock_inode_wait)(struct inode *inode, struct file_lock *fl)",
        "pre": {
            "inode": "!=null",
            "fl": "!=null"
        }
    }
},
{
    "kretprobe:locks_remove_posix": {
        "description": "If there are no locks held on this file, we don't need to call posix_lock_file(). Another process could be setting a lock on this file at the same time, but we wouldn't remove that lock anyway.",
        "proto" :"void locks_remove_posix(struct file *filp, fl_owner_t owner)",
        "pre": {
            "filp": "!=null",
            "owner": "!=null"
        },
    }
},
{
    "kprobe:locks_remove_posix": {
        "description": "If there are no locks held on this file, we don't need to call posix_lock_file(). Another process could be setting a lock on this file at the same time, but we wouldn't remove that lock anyway.",
        "proto" :"static long (*locks_remove_posix)(struct file  filp, fl_owner_t owner)",
        "pre": {
            "filp": "!=null",
            "owner": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:finish_open": {
        "description": "This can be used to finish opening a file passed to i_op->atomic_open(). If the open callback is set to NULL, then the standard f_op->open() filesystem callback is substituted. NB: the dentry reference is _not_ consumed. If, for example, the dentry is the return value of d_splice_alias(), then the caller needs to perform dput() on it after finish_open(). Returns zero on success or -errno if the open failed.",
        "proto" :"int finish_open(struct file *file, struct dentry *dentry, int (*open)(struct inode *, struct file *))",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null || ==null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:finish_open": {
        "description": "Finish opening a file. If the open callback is set to NULL, then the standard f_op->open() filesystem callback is substituted. The dentry reference is _not_ consumed. If, for example, the dentry is the return value of d_splice_alias(), then the caller needs to perform dput() on it after finish_open(). Returns zero on success or -errno if the open failed.",
        "proto" :"int (*finish_open)(struct file *file, struct dentry *dentry, int (*open)(struct inode *, struct file *))",
        "pre": {
            "file": "!=null",
            "dentry": "!=null",
            "open": "!=null || ==null"
        },
    }
},
{
    "kretprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file. This can be used to set the result of a successful lookup in ->atomic_open(). Unlike finish_open() this function does consume the dentry reference and the caller need not dput() it.",
        "proto" :"int (*finish_no_open)(struct file *file, struct dentry *dentry)",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:finish_no_open": {
        "description": "Finish ->atomic_open() without opening the file. This can be used to set the result of a successful lookup in ->atomic_open(). Unlike finish_open() this function does consume the dentry reference and the caller need not dput() it. Returns '0' which must be the return value of ->atomic_open() after having called this function.",
        "proto" :"int (*finish_no_open)(struct file *file, struct dentry *dentry)",
        "pre": {
            "file": "!=null",
            "dentry": "!=null"
        }
    }
},

{
    "kprobe:dentry_open": {
        "description": "Your description here",
        "proto" :"dentry_open(struct file  f,  struct inode  inode,  int ( open)(struct inode  , struct file  ))",
        "pre": {
            "f": "Your condition here",
            "inode": "Your condition here",
            "open": "Your condition here"
        },
    }
},
{
    "kretprobe:dentry_create": {
        "description": "Create and open a file. Caller must hold the parent directory's lock, and have prepared a negative dentry, placed in @path->dentry, for the new file. Caller sets @path->mnt to the vfsmount of the filesystem where the new file is to be created. The parent directory and the negative dentry must reside on the same filesystem instance. On success, returns a 'struct file'. Otherwise a ERR_PTR is returned.",
        "proto" :"struct file *(*dentry_create)(const struct path *path, int flags, umode_t mode, const struct cred *cred)",
        "pre": {
            "path": "!=null",
            "flags": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE, __O_TMPFILE]",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:dentry_create": {
        "description": "Create and open a file. Caller must hold the parent directory's lock, and have prepared a negative dentry, placed in @path->dentry, for the new file. Caller sets @path->mnt to the vfsmount of the filesystem where the new file is to be created. The parent directory and the negative dentry must reside on the same filesystem instance. On success, returns a 'struct file'. Otherwise a ERR_PTR is returned.",
        "proto" :"struct file *(*dentry_create)(const struct path *path, int flags, umode_t mode, const struct cred *cred)",
        "pre": {
            "path": "!=null",
            "flags": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE, __O_TMPFILE]",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]",
            "cred": "!=null"
        }
    }
},
{
    "kretprobe:filp_open": {
        "description": "Open file and return file pointer. This is the helper to open a file from kernelspace if you really have to. But in generally you should not do this, so please move along, nothing to see here.",
        "proto" :"struct file *(*filp_open)(const char *filename, int flags, umode_t mode)",
        "pre": {
            "filename": "!=null",
            "flags": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE, __FMODE_EXEC]",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]"
        }
    }
},
{
    "kprobe:filp_open": {
        "description": "Open file and return file pointer. This is the helper to open a file from kernelspace if you really have to. But in generally you should not do this, so please move along, nothing to see here.",
        "proto" :"struct file *(*filp_open)(const char *filename, int flags, umode_t mode)",
        "pre": {
            "filename": "!=null",
            "flags": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE, __O_TMPFILE, O_NDELAY]",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]"
        },
    }
},
{
    "kretprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors. Such file descriptors are not seekable and don't have notion of position (file.f_pos is always 0 and ppos passed to .read().write() is always NULL). Contrary to file descriptors of other regular files, .read() and .write() can run simultaneously. stream_open never fails and is marked to return int so that it could be directly used as file_operations.open.",
        "proto" :"int (*stream_open)(struct inode *inode, struct file *filp)",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        },
    }
},
{
    "kprobe:stream_open": {
        "description": "Used by subsystems that want stream-like file descriptors. Such file descriptors are not seekable and don't have notion of position (file.f_pos is always 0 and ppos passed to .read().write() is always NULL). Contrary to file descriptors of other regular files, .read() and .write() can run simultaneously. stream_open never fails and is marked to return int so that it could be directly used as file_operations.open.",
        "proto" :"int (*stream_open)(struct inode *inode, struct file *filp)",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        },
    }
},
{
    "kretprobe:get_cached_acl": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "inode": "Your condition here",
            "type": "Your condition here"
        },
    }
},
{
    "kprobe:get_cached_acl": {
        "description": "Get the Access Control List (ACL) for a given inode and type. If the ACL is not cached, it checks if the inode has a POSIX ACL. If it doesn't, it returns NULL. If the ACL is being read, it sets a sentinel. If the ACL is not being read, it calls `get_inode_acl` to fetch the ACL.",
        "proto" :"static struct posix_acl *(*get_cached_acl)(struct inode *inode, int type)",
        "pre": {
            "inode": "!=null",
            "type": "in [ACL_TYPE_ACCESS, ACL_TYPE_DEFAULT]"
        },
    }
},
{
    "kretprobe:posix_acl_equiv_mode": {
        "description": "A null ACL can always be presented as mode bits.",
        "proto" :"static long (*posix_acl_equiv_mode)(const struct posix_acl *acl, umode_t *mode_p)",
        "pre": {
            "acl": "!=null",
            "mode_p": "!=null"
        },
    }
},
{
    "kprobe:posix_acl_equiv_mode": {
        "description": "A null ACL can always be presented as mode bits.",
        "proto" :"posix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)",
        "pre": {
            "acl": "!=null",
            "mode_p": "!=null"
        }
    }
},
{
    "kretprobe:posix_acl_chmod_masq": {
        "description": "Change the access control list (ACL) permissions.",
        "proto": "static int (*posix_acl_chmod_masq)(struct posix_acl *acl, umode_t mode)",
        "pre": {
            "acl": "!=null",
            "mode": "in [S_IRWXU, S_IRWXG, S_IRWXO]"
        },
    }
},
{
    "kprobe:FOREACH_ACL_ENTRY": {
        "description": "Description of the function",
        "proto" :"static long (*FOREACH_ACL_ENTRY)(struct posix_acl_entry  pa, struct posix_acl  acl, struct posix_acl_entry  pe)",
        "pre": {
            "pa": "Constraint for pa",
            "acl": "Constraint for acl",
            "pe": "Constraint for pe"
        },
    }
},
{
    "kretprobe:posix_acl_update_mode": {
        "description": "Update the file mode when setting an ACL: compute the new file permission bits based on the ACL. In addition, if the ACL is equivalent to the new file mode, set @acl to NULL to indicate that no ACL should be set. As with chmod, clear the setgid bit if the caller is not in the owning group or capable of CAP_FSETID (see inode_change_ok). If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap. Called from set_acl inode operations.",
        "proto": "int posix_acl_update_mode(struct mnt_idmap *idmap,  struct inode *inode, umode_t *mode_p,  struct posix_acl **acl)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        }
    }
},
{
    "kprobe:posix_acl_update_mode": {
        "description": "Update the file mode when setting an ACL: compute the new file permission bits based on the ACL. In addition, if the ACL is equivalent to the new file mode, set @acl to NULL to indicate that no ACL should be set. As with chmod, clear the setgid bit if the caller is not in the owning group or capable of CAP_FSETID (see inode_change_ok). If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap. Called from set_acl inode operations.",
        "proto" :"int posix_acl_update_mode(struct mnt_idmap *idmap,  struct inode *inode, umode_t *mode_p,  struct posix_acl **acl)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mode_p": "!=null",
            "acl": "!=null"
        },
    }
},
{
    "kretprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe. This function allocates a bunch of pages sufficient to hold the requested amount of data (but limited by the remaining pipe capacity), passes it to the file's ->read_iter() to read into and then splices the used pages into the pipe.",
        "proto": "ssize_t (*copy_splice_read)(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
        "post": {
            "return": "in [-EAGAIN, 0, len]"
        }
    }
},
{
    "kprobe:copy_splice_read": {
        "description": "Copy data from a file and splice the copy into a pipe. This function allocates a bunch of pages sufficient to hold the requested amount of data (but limited by the remaining pipe capacity), passes it to the file's ->read_iter() to read into and then splices the used pages into the pipe.",
        "proto" :"ssize_t (*copy_splice_read)(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
    }
},
{
    "kretprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "proto" :"static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd, splice_actor *actor)",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_from_pipe_feed": {
        "description": "__splice_from_pipe() when locking is required around copying the pipe buffers to the destination.",
        "proto" :"static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd, splice_actor *actor)",
        "pre": {
            "pipe": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file. Will either move or copy pages (determined by flags options) from the given pipe inode to the given file. This one is ->write_iter-based.",
        "proto" :"ssize_t (*iter_file_splice_write)(struct pipe_inode_info *pipe, struct file *out, loff_t *ppos, size_t len, unsigned int flags)",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        }
    }
},
{
    "kprobe:iter_file_splice_write": {
        "description": "Splice data from a pipe to a file. Will either move or copy pages (determined by @flags options) from the given pipe inode to the given file. This one is ->write_iter-based.",
        "proto" :"ssize_t (*iter_file_splice_write)(struct pipe_inode_info *pipe, struct file *out, loff_t *ppos, size_t len, unsigned int flags)",
        "pre": {
            "pipe": "!=null",
            "out": "!=null",
            "ppos": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
    }
},
{
    "kretprobe:splice_direct_to_actor": {
        "description": "This is a special case helper to splice directly between two points, without requiring an explicit pipe. Internally an allocated pipe is cached in the process, and reused during the lifetime of that process.",
        "proto" :"ssize_t (*splice_direct_to_actor)(struct file *in, struct splice_desc *sd, splice_direct_actor *actor)",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kprobe:splice_direct_to_actor": {
        "description": "This is a special case helper to splice directly between two points, without requiring an explicit pipe. Internally an allocated pipe is cached in the process, and reused during the lifetime of that process.",
        "proto" :"ssize_t (*splice_direct_to_actor)(struct file *in, struct splice_desc *sd, splice_direct_actor *actor)",
        "pre": {
            "in": "!=null",
            "sd": "!=null",
            "actor": "!=null"
        }
    }
},
{
    "kretprobe:do_splice_direct": {
        "description": "Splices data directly between two files. For use by do_sendfile(). splice can easily emulate sendfile, but doing it in the application would incur an extra system call (splice in + splice out, as compared to just sendfile()). So this helper can splice directly through a process-private pipe.",
        "proto" :"long do_splice_direct(struct file *in, loff_t *ppos, struct file *out, loff_t *opos, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        }
    }
},
{
    "kprobe:do_splice_direct": {
        "description": "Splices data directly between two files. For use by do_sendfile(). splice can easily emulate sendfile, but doing it in the application would incur an extra system call (splice in + splice out, as compared to just sendfile()). So this helper can splice directly through a process-private pipe.",
        "proto" :"long (*do_splice_direct)(struct file *in, loff_t *ppos, struct file *out, loff_t *opos, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "out": "!=null",
            "opos": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
    }
},
{
    "kretprobe:__blockdev_direct_IO": {
        "description": "Direct I/O to/from a block device.",
        "proto" :"__blockdev_direct_IO(struct kiocb  iocb, struct inode  inode,struct block_device  bdev, struct iov_iter  iter,get_block_t get_block, dio_iodone_t end_io,int flags)",
        "pre": {
            "iocb": "!=null",
            "inode": "!=null",
            "bdev": "!=null",
            "iter": "!=null",
            "get_block": "!=null",
            "end_io": "!=null",
            "flags": ">=0",
        },
    }
},

{
    "kretprobe:copy_string_kernel": {
        "description": "Copy a string from user memory into kernel memory, with a maximum length of MAX_ARG_STRLEN. The string is null-terminated.",
        "proto" :"int (*copy_string_kernel)(const char *arg, struct linux_binprm *bprm)",
        "pre": {
            "arg": "!=null",
            "bprm": "!=null"
        },
        "post": {
            "return": "in [-EFAULT, -E2BIG, len]"
        }
    }
},
{
    "kprobe:copy_string_kernel": {
        "description": "Copies a string from user space into kernel space. The string is limited by MAX_ARG_STRLEN and includes a terminating NUL.",
        "proto" :"int (*copy_string_kernel)(const char *arg, struct linux_binprm *bprm)",
        "pre": {
            "arg": "!=null",
            "bprm": "!=null",
            "bprm->p": ">=0",
            "len": "in [0, MAX_ARG_STRLEN]"
        },
    }
},
{
    "kretprobe:bprm_mm_init": {
        "description": "setup_arg_pages().",
        "proto" :"static int (*bprm_mm_init)(struct linux_binprm *bprm)",
        "pre": {
            "bprm": "your_condition_here"
        }
    }
},

{
    "kretprobe:open_execat": {
        "description": "Open a file with execution permissions. Checks for various conditions to ensure safe execution.",
        "proto" :"int open_execat(int fd, struct filename name, int flags)",
        "pre": {
            "fd": ">=0",
            "name": "!=null",
            "flags": "in [AT_SYMLINK_NOFOLLOW, AT_EMPTY_PATH]"
        },
    }
},
{
    "kprobe:open_execat": {
        "description": "Open a file with execution permissions, checking for various conditions.",
        "proto": "int open_execat(int fd, struct filename name, int flags)",
        "pre": {
            "fd": ">=0",
            "name": "!=null",
            "flags": "in [AT_SYMLINK_NOFOLLOW, AT_EMPTY_PATH]"
        },
        "post": {
            "return": "in [-EINVAL, file descriptor]"
        }
    }
},
{
    "kretprobe:begin_new_exec": {
        "description": "Once we are committed compute the creds",
        "proto" :"static int (*begin_new_exec)(struct linux_binprm *bprm)",
        "pre": {
            "bprm": "!=null"
        }
    }
},


{
    "kprobe:acct_arg_size": {
        "description": "Release all of the old mmap stuff",
        "proto" :"static long (*acct_arg_size)(void *bprm, int arg)",
        "pre": {
            "bprm": "!=null",
            "arg": "in [0, 1]"
        },
    }
},


{
    "kretprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "proto" :"static void (*finalize_exec)(struct linux_binprm *bprm)",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kprobe:finalize_exec": {
        "description": "Store any stack rlimit changes before starting thread.",
        "proto" :"static void (*finalize_exec)(struct linux_binprm *bprm)",
        "pre": {
            "bprm": "!=null"
        }
    }
},
{
    "kretprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "proto" :"static long (*bprm_change_interp)(const char *interp, struct linux_binprm *bprm)",
        "pre": {
            "interp": "!=null",
            "bprm": {
                "interp": "!=null",
                "filename": "!=null"
            }
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:bprm_change_interp": {
        "description": "If a binfmt changed the interp, free it first.",
        "proto" :"static long (*bprm_change_interp)(const char *interp, struct linux_binprm *bprm)",
        "pre": {
            "interp": "!=null",
            "bprm": {
                "interp": "!=null",
                "filename": "!=null"
            }
        },
        "post": {
            "bprm": {
                "interp": "==kstrdup(interp, GFP_KERNEL)"
            }
        }
    }
},
{
    "kretprobe:register_chrdev_region": {
        "description": "Register a range of device numbers.",
        "proto": "int register_chrdev_region(dev_t from, unsigned count, const char *name)",
        "pre": {
            "from": "!=null && is a valid dev_t value",
            "count": ">=0",
            "name": "!=null && is a valid string"
        },
        "post": {
            "return": "in [0, negative error codes]"
        }
    }
},
{
    "kprobe:register_chrdev_region": {
        "description": "Register a range of device numbers. Return value is zero on success, a negative error code on failure.",
        "proto" :"int (*register_chrdev_region)(dev_t from, unsigned count, const char *name)",
        "pre": {
            "from": "!=null",
            "count": ">0",
            "name": "!=null"
        },
    }
},
{
    "kretprobe:alloc_chrdev_region": {
        "description": "Allocates a range of char device numbers. The major number will be chosen dynamically, and returned (along with the first minor number) in @dev. Returns zero or a negative error code.",
        "proto" :"int (*alloc_chrdev_region)(dev_t *dev, unsigned baseminor, unsigned count, const char *name)",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">0",
            "name": "!=null && !=''"
        },
    }
},
{
    "kprobe:alloc_chrdev_region": {
        "description": "Allocates a range of char device numbers. The major number will be chosen dynamically, and returned (along with the first minor number) in @dev. Returns zero or a negative error code.",
        "proto" :"int (*alloc_chrdev_region)(dev_t *dev, unsigned baseminor, unsigned count, const char *name)",
        "pre": {
            "dev": "!=null",
            "baseminor": ">=0",
            "count": ">0",
            "name": "!=null && !=''",
        },
    }
},
{
    "kretprobe:cdev_init": {
        "description": "Initializes @cdev, remembering @fops, making it ready to add to the system with cdev_add().",
        "proto" :"void (*cdev_init)(struct cdev *cdev, const struct file_operations *fops)",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kprobe:cdev_init": {
        "description": "Initializes a cdev structure, remembering fops, making it ready to add to the system with cdev_add().",
        "proto" :"void (*cdev_init)(struct cdev *cdev, const struct file_operations *fops)",
        "pre": {
            "cdev": "!=null",
            "fops": "!=null"
        }
    }
},
{
    "kretprobe:unregister_chrdev_region": {
        "description": "Unregister a range of device numbers.",
        "proto" :"void unregister_chrdev_region(dev_t from, unsigned count)",
        "pre": {
            "from": ">=0",
            "count": ">0",
        },
    }
},
{
    "kprobe:unregister_chrdev_region": {
        "description": "This function will unregister a range of @count device numbers, starting with @from. The caller should normally be the one who allocated those numbers in the first place.",
        "proto" :"void unregister_chrdev_region(dev_t from, unsigned count)",
        "pre": {
            "from": ">=0",
            "count": ">0",
        },
    }
},
{
    "kretprobe:chrdev_open": {
        "description": "Called every time a character special file is opened.",
        "proto" :"static int chrdev_open(struct inode *inode, struct file *filp)",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:chrdev_open": {
        "description": "Called every time a character special file is opened.",
        "proto" :"static int (*chrdev_open)(struct inode *inode, struct file *filp)",
        "pre": {
            "inode": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:cdev_set_parent": {
        "description": "Sets a parent kobject which will be referenced appropriately so the parent is not freed before the cdev. This should be called before cdev_add.",
        "proto" :"void (*cdev_set_parent)(struct cdev *p, struct kobject *kobj)",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:cdev_set_parent": {
        "description": "Set the parent kobject for a char device. The parent kobject will be referenced appropriately so the parent is not freed before the cdev. This should be called before cdev_add.",
        "proto" :"void (*cdev_set_parent)(struct cdev *p, struct kobject *kobj)",
        "pre": {
            "p": "!=null",
            "kobj": "!=null"
        }
    }
},
{
    "kretprobe:cdev_device_add": {
        "description": "Adds a char device and its corresponding struct device, linking @dev: the device structure @cdev: the cdev structure. cdev_device_add() adds the char device represented by @cdev to the system, just as cdev_add does. It then adds @dev to the system using device_add. The dev_t for the char device will be taken from the struct device which needs to be initialized first. This helper function correctly takes a reference to the parent device so the parent will not get released until all references to the cdev are released. This helper uses dev->devt for the device number. If it is not set it will not add the cdev and it will be equivalent to device_add. This function should be used whenever the struct cdev and the struct device are members of the same structure whose lifetime is managed by the struct device. NOTE: Callers must assume that userspace was able to open the cdev and can call cdev fops callbacks at any time, even if this function fails.",
        "proto" :"int cdev_device_add(struct cdev *cdev, struct device *dev)",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null && dev->devt is set"
        },
    }
},
{
    "kprobe:cdev_device_add": {
        "description": "Add a char device and its corresponding struct device, linking @dev: the device structure @cdev: the cdev structure. cdev_device_add() adds the char device represented by @cdev to the system, just as cdev_add does. It then adds @dev to the system using device_add. The dev_t for the char device will be taken from the struct device which needs to be initialized first. This helper function correctly takes a reference to the parent device so the parent will not get released until all references to the cdev are released. This helper uses dev->devt for the device number. If it is not set it will not add the cdev and it will be equivalent to device_add. This function should be used whenever the struct cdev and the struct device are members of the same structure whose lifetime is managed by the struct device. NOTE: Callers must assume that userspace was able to open the cdev and can call cdev fops callbacks at any time, even if this function fails.",
        "proto" :"int (*cdev_device_add)(struct cdev *cdev, struct device *dev)",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null && dev->devt is initialized"
        },
    }
},
{
    "kretprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add. cdev_device_del is a helper function to call cdev_del and device_del. It should be used whenever cdev_device_add is used. If dev->devt is not set it will not remove the cdev and will be equivalent to device_del. NOTE: This guarantees that associated sysfs callbacks are not running or runnable, however any cdevs already open will remain and their fops will still be callable even after this function returns.",
        "proto" :"void (*cdev_device_del)(struct cdev *cdev, struct device *dev)",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:cdev_device_del": {
        "description": "Inverse of cdev_device_add. Calls cdev_del and device_del. If dev->devt is not set, it will not remove the cdev and will be equivalent to device_del. Guarantees that associated sysfs callbacks are not running or runnable, however any cdevs already open will remain and their fops will still be callable even after this function returns.",
        "proto" :"void (*cdev_device_del)(struct cdev *cdev, struct device *dev)",
        "pre": {
            "cdev": "!=null",
            "dev": "!=null && dev->devt is set"
        }
    }
},
{
    "kretprobe:make_bad_inode": {
        "description": "Mark an inode as 'bad' due to an I/O error. Returns a set of stubs which will return EIO errors as required.",
        "proto" :"static void (*make_bad_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
        "post": {
            "return": "in [EIO]"
        }
    }
},
{
    "kprobe:make_bad_inode": {
        "description": "Mark an inode bad due to an I/O error. When an inode cannot be read due to a media or remote network failure this function makes the inode 'bad' and causes I/O operations on it to fail from this point on.",
        "proto" :"void (*make_bad_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
    }
},
{
    "kretprobe:is_bad_inode": {
        "description": "Returns true if the inode in question has been marked as bad.",
        "proto" :"bool (*is_bad_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        },
    }
},
{
    "kprobe:is_bad_inode": {
        "description": "Returns true if the inode in question has been marked as bad.",
        "proto" :"bool (*is_bad_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it.",
        "proto" :"static void (*iget_failed)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:iget_failed": {
        "description": "Mark an under-construction inode as dead and release it",
        "proto" :"void (*iget_failed)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:map_buffer_to_folio": {
        "description": "The fs supplied get_block might return an up to date buffer. This is used to map that buffer into the page, which allows read_folio to avoid triggering a duplicate call to get_block. The idea is to avoid adding buffers to pages that don't already have them. So when the buffer is up to date and the page size == block size, this marks the page up to date instead of adding new buffers.",
        "proto" :"static void map_buffer_to_folio(struct folio *folio, struct buffer_head *bh, int page_block)",
        "pre": {
            "folio": "!=null",
            "bh": "!=null",
            "page_block": ">=0"
        }
    }
},
{
    "kprobe:map_buffer_to_folio": {
        "description": "The fs supplied get_block might return an up to date buffer. This is used to map that buffer into the page, which allows read_folio to avoid triggering a duplicate call to get_block. The idea is to avoid adding buffers to pages that don't already have them. So when the buffer is up to date and the page size == block size, this marks the page up to date instead of adding new buffers.",
        "proto" :"static void (*map_buffer_to_folio)(struct folio *folio, struct buffer_head *bh, int page_block)",
        "pre": {
            "folio": "!=null",
            "bh": "!=null",
            "page_block": "is integer"
        }
    }
},
{
    "kretprobe:mpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space & writepage() all of them. Subtract the number of written pages from @wbc->nr_to_write. This is a library function, which implements the writepages() address_space_operation.",
        "proto" :"int (*mpage_writepages)(struct address_space *mapping, struct writeback_control *wbc, get_block_t get_block)",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        },
    }
},
{
    "kprobe:mpage_writepages": {
        "description": "Walk the list of dirty pages of the given address space & writepage() all of them. Subtract the number of written pages from @wbc->nr_to_write. This is a library function, which implements the writepages() address_space_operation.",
        "proto" :"int (*mpage_writepages)(struct address_space *mapping, struct writeback_control *wbc, get_block_t get_block)",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null",
            "get_block": "!=null"
        }
    }
},
{
    "kretprobe:setattr_should_drop_sgid": {
        "description": "Return: ATTR_KILL_SGID if setgid bit needs to be removed, 0 otherwise.",
        "proto" :"int (*setattr_should_drop_sgid)(struct mnt_idmap *idmap, const struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [0, ATTR_KILL_SGID]"
        }
    }
},
{
    "kprobe:setattr_should_drop_sgid": {
        "description": "Return: ATTR_KILL_SGID if setgid bit needs to be removed, 0 otherwise.",
        "proto" :"int (*setattr_should_drop_sgid)(struct mnt_idmap *idmap, const struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:setattr_should_drop_suidgid": {
        "description": "This function determines whether the set{g,u}id bits need to be removed. If the setuid bit needs to be removed ATTR_KILL_SUID is returned. If the setgid bit needs to be removed ATTR_KILL_SGID is returned. If both set{g,u}id bits need to be removed the corresponding mask of both flags is returned.",
        "proto" :"int setattr_should_drop_suidgid(struct mnt_idmap *idmap,struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [0, ATTR_KILL_SUID, ATTR_KILL_SGID, ATTR_KILL_SUID | ATTR_KILL_SGID]"
        }
    }
},
{
    "kprobe:setattr_should_drop_suidgid": {
        "description": "This function determines whether the set{g,u}id bits need to be removed. If the setuid bit needs to be removed ATTR_KILL_SUID is returned. If the setgid bit needs to be removed ATTR_KILL_SGID is returned. If both set{g,u}id bits need to be removed the corresponding mask of both flags is returned.",
        "proto" :"int (*setattr_should_drop_suidgid)(struct mnt_idmap *idmap, struct inode *inode)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null"
        },
        "post": {
            "return": "in [0, ATTR_KILL_SUID, ATTR_KILL_SGID, ATTR_KILL_SUID | ATTR_KILL_SGID]"
        }
    }
},
{
    "kretprobe:chown_check": {
        "description": "Check if a caller can change the owner. If force is set, do it anyway.",
        "proto" :"if (ia_valid & ATTR_FORCE)goto kill_priv;/* Make sure a caller can chown. */",
        "pre": {
            "ia_valid": "!=null",
            "ATTR_FORCE": "in ia_valid"
        },
    }
},
{
    "kprobe:check_attr_force": {
        "description": "Check if the ATTR_FORCE flag is set in ia_valid. If set, proceed with operation regardless of other conditions.",
        "proto" :"static int (*check_attr_force)(int ia_valid)",
        "pre": {
            "ia_valid": "is integer"
        },
    }
},
{
    "kretprobe:may_setattr": {
        "description": "Check if utimes(2) and friends are called with times == NULL (or both times are UTIME_NOW), then we need to check for write permission.",
        "proto" :"int may_setattr(struct mnt_idmap idmap, struct inode inode, unsigned int ia_valid)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "ia_valid": "in [ATTR_MODE, ATTR_UID, ATTR_GID, ATTR_TIMES_SET]"
        },
        "post": {
            "return": "in [-EPERM, 0]"
        }
    }
},
{
    "kprobe:if (ia_valid & ATTR_TOUCH)": {
        "description": "[description]",
        "proto" :"[prototype]",
        "pre": {
            "[argument1]": "[precondition1]",
            "[argument2]": "[precondition2]",
            "[argument3]": "[precondition3]",
            "[argument4]": "[precondition4]",
        },
    }
},
{
    "kretprobe:notify_change": {
        "description": "Modify attributes of a filesystem object. If notify_change discovers a delegation in need of breaking, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int notify_change(struct mnt_idmap *idmap, struct dentry *dentry,  struct iattr *attr, struct inode **delegated_inode)",
        "pre": {
            "idmap": "!=null || ==nop_mnt_idmap",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null || ==null"
        },
    }
},
{
    "kprobe:notify_change": {
        "description": "Modify attributes of a filesystem object. If notify_change discovers a delegation in need of breaking, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int notify_change(struct mnt_idmap *idmap, struct dentry *dentry,  struct iattr *attr, struct inode **delegated_inode)",
        "pre": {
            "idmap": "!=null || ==nop_mnt_idmap",
            "dentry": "!=null",
            "attr": "!=null",
            "delegated_inode": "!=null || ==null"
        },
    }
},
{
    "kretprobe:if_unlikely_len_equals_embedded_name_max": {
        "description": "Uh-oh. We have a name that's approaching PATH_MAX. Allocate a separate struct filename so we can dedicate the entire names_cache allocation for the pathname, and re-do the copy from userland.",
        "proto" :"if (unlikely(len == EMBEDDED_NAME_MAX))",
        "pre": {
            "len": "== EMBEDDED_NAME_MAX"
        }
    }
},

{
    "kretprobe:generic_permission": {
        "description": "Used to check for readwriteexecute permissions on a file. We use 'fsuid' for this, letting us set arbitrary permissions for filesystem access without changing the 'normal' uids which are used for other things. generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk request cannot be satisfied (eg. requires blocking or too much complexity). It would then be called again in ref-walk mode. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int (*generic_permission)(struct mnt_idmap *idmap, struct inode *inode, int mask)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC, %MAY_NOT_BLOCK]"
        },
    }
},
{
    "kprobe:generic_permission": {
        "description": "Used to check for readwriteexecute permissions on a file. We use 'fsuid' for this, letting us set arbitrary permissions for filesystem access without changing the 'normal' uids which are used for other things. generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk request cannot be satisfied (eg. requires blocking or too much complexity). It would then be called again in ref-walk mode. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int (*generic_permission)(struct mnt_idmap *idmap, struct inode *inode, int mask)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC, %MAY_NOT_BLOCK]"
        }
    }
},
{
    "kretprobe:do_inode_permission": {
        "description": "UNIX permission checking. We _really_ want to just do 'generic_permission()' without even looking at the inode->i_op values. So we keep a cache flag in inode->i_opflags, that says 'this has not special permission function, use the fast case'.",
        "proto": "static inline int do_inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...]"
        }
    }
},
{
    "kprobe:do_inode_permission": {
        "description": "UNIX permission checking. We _really_ want to just do 'generic_permission()' without even looking at the inode->i_op values. So we keep a cache flag in inode->i_opflags, that says 'this has not special permission function, use the fast case'.",
        "proto" :"static inline int do_inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)",
        "pre": {
            "idmap": "!=null",
            "inode": "!=null",
            "mask": "in [%MAY_READ, %MAY_WRITE, %MAY_EXEC, ...]",
        },
    }
},
{
    "kretprobe:path_get": {
        "description": "Given a path, increment the reference count to the dentry and the vfsmount.",
        "proto": "void (*path_get)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_get": {
        "description": "Given a path, increment the reference count to the dentry and the vfsmount.",
        "proto" :"static void (*path_get)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:path_put": {
        "description": "Given a path, decrement the reference count to the dentry and the vfsmount.",
        "proto": "void (*path_put)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_put": {
        "description": "Given a path, decrement the reference count to the dentry and the vfsmount.",
        "proto": "void (*path_put)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount. Given a path, find the mountpoint of its source file system. Replace @path with the path of the mountpoint in the parent mount. Up is towards . Return 1 if we went up a level and 0 if we were already at the root.",
        "proto" :"int (*follow_up)(struct path *path)",
        "pre": {
            "path": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:follow_up": {
        "description": "Find the mountpoint of path's vfsmount. Given a path, find the mountpoint of its source file system. Replace @path with the path of the mountpoint in the parent mount. Up is towards . Return 1 if we went up a level and 0 if we were already at the root.",
        "proto" :"int (*follow_up)(struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:lookup_one_qstr_excl": {
        "description": "Don't create child dentry for a dead directory.",
        "proto" :"lookup_one_qstr_excl(const struct qstr name, struct dentry base, unsigned int flags)",
        "pre": {
            "name": "Your condition here",
            "base": "Your condition here",
            "flags": "Your condition here"
        },
    }
},
{
    "kprobe:lookup_one_qstr_excl": {
        "description": "Don't create child dentry for a dead directory.",
        "proto" :"lookup_one_qstr_excl(const struct qstr  name,    struct dentry  base,    unsigned int flags)",
        "pre": {
            "name": "your_condition_here",
            "base": "your_condition_here",
            "flags": "your_condition_here",
        },
    }
},
{
    "kretprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair",
        "proto" :"int vfs_path_parent_lookup(struct filename *filename, unsigned int flags, struct path *parent, struct qstr *last, int *type, const struct path *root)",
        "pre": {
            "filename": "!=null",
            "flags": "unsigned int",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        },
    }
},
{
    "kprobe:vfs_path_parent_lookup": {
        "description": "Lookup a parent path relative to a dentry-vfsmount pair.",
        "proto" :"int vfs_path_parent_lookup(struct filename *filename, unsigned int flags, struct path *parent, struct qstr *last, int *type, const struct path *root)",
        "pre": {
            "filename": "!=null",
            "flags": "unsigned int",
            "parent": "!=null",
            "last": "!=null",
            "type": "!=null",
            "root": "!=null"
        },
    }
},
{
    "kretprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair",
        "proto": "int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt, const char *name, unsigned int flags, struct path *path)",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kprobe:vfs_path_lookup": {
        "description": "Lookup a file path relative to a dentry-vfsmount pair",
        "proto" :"int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt, const char *name, unsigned int flags, struct path *path)",
        "pre": {
            "dentry": "!=null",
            "mnt": "!=null",
            "name": "!=null",
            "flags": "unsigned int",
            "path": "!=null"
        }
    }
},
{
    "kretprobe:try_lookup_one_len": {
        "description": "Look up a dentry by name in the dcache, returning NULL if it does not currently exist. The function does not try to create a dentry. Note that this routine is purely a helper for filesystem usage and should not be called by generic code. The caller must hold base->i_mutex.",
        "proto" :"struct dentry *(*try_lookup_one_len)(const char *name, struct dentry *base, int len)",
        "pre": {
            "name": "!=null",
            "base": "!=null && base->i_mutex is held",
            "len": ">=0"
        },
    }
},
{
    "kprobe:try_lookup_one_len": {
        "description": "Look up a dentry by name in the dcache, returning NULL if it does not currently exist. The function does not try to create a dentry. This routine is purely a helper for filesystem usage and should not be called by generic code. The caller must hold base->i_mutex.",
        "proto" :"struct dentry *(*try_lookup_one_len)(const char *name, struct dentry *base, int len)",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This routine is purely a helper for filesystem usage and should not be called by generic code. Unlike lookup_one_len, it should be called without the parent i_mutex held, and will take the i_mutex itself if necessary.",
        "proto" :"struct dentry *(*lookup_one_unlocked)(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)",
        "pre": {
            "idmap": "!=null",
            "name": "!=null && is_string(name)",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This routine is purely a helper for filesystem usage and should not be called by generic code. Unlike lookup_one_len, it should be called without the parent i_mutex held, and will take the i_mutex itself if necessary.",
        "proto" :"struct dentry *(*lookup_one_unlocked)(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)",
        "pre": {
            "idmap": "!=null",
            "name": "!=null && is_string(name)",
            "base": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns known positive or ERR_PTR(). This is what most of the users want. Note that pinned negative with unlocked parent _can_ become positive at any time, so callers of lookup_one_unlocked() need to be very careful; pinned positives have >d_inode stable, so this one avoids such problems. Note that this routine is purely a helper for filesystem usage and should not be called by generic code. The helper should be called without i_mutex held.",
        "proto" :"struct dentry *(*lookup_one_positive_unlocked)(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)",
        "pre": {
            "idmap": "!=null",
            "name": "!=null && is_string(name)",
            "base": "!=null",
            "len": "is_integer(len) && len >= 0"
        },
    }
},
{
    "kprobe:lookup_one_positive_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This helper will yield ERR_PTR(-ENOENT) on negatives. The helper returns known positive or ERR_PTR(). This is what most of the users want. Note that pinned negative with unlocked parent _can_ become positive at any time, so callers of lookup_one_unlocked() need to be very careful; pinned positives have >d_inode stable, so this one avoids such problems. Note that this routine is purely a helper for filesystem usage and should not be called by generic code. The helper should be called without i_mutex held.",
        "proto" :"struct dentry *(*lookup_one_positive_unlocked)(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)",
        "pre": {
            "idmap": "!=null",
            "name": "!=null",
            "base": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This routine is purely a helper for filesystem usage and should not be called by generic code. Unlike lookup_one_len, it should be called without the parent i_mutex held, and will take the i_mutex itself if necessary.",
        "proto" :"struct dentry *(*lookup_one_len_unlocked)(const char *name, struct dentry *base, int len)",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:lookup_one_len_unlocked": {
        "description": "Filesystem helper to lookup single pathname component. This routine is purely a helper for filesystem usage and should not be called by generic code. Unlike lookup_one_len, it should be called without the parent i_mutex held, and will take the i_mutex itself if necessary.",
        "proto" :"struct dentry *(*lookup_one_len_unlocked)(const char *name, struct dentry *base, int len)",
        "pre": {
            "name": "!=null",
            "base": "!=null",
            "len": ">=0"
        }
    }
},

{
    "kprobe:inode_lock_nested": {
        "description": "Locks the inode with a specific subclass.",
        "proto" :"static void (*inode_lock_nested)(struct inode *inode, unsigned subclass)",
        "pre": {
            "inode": "!=null",
            "subclass": "==I_MUTEX_PARENT",
        },
    }
},
{
    "kretprobe:vfs_create": {
        "description": "Create a new file. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, bool want_excl)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]",
            "want_excl": "in [true, false]"
        }
    }
},
{
    "kprobe:vfs_create": {
        "description": "Create a new file. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, bool want_excl)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]",
            "want_excl": "in [true, false]"
        }
    }
},
{
    "kretprobe:kernel_tmpfile_open": {
        "description": "Create and open a temporary file for kernel internal use. The file is not accounted in nr_files, hence this is only for kernel internal use, and must not be installed into file tables or such.",
        "proto" :"struct file *(*kernel_tmpfile_open)(struct mnt_idmap *idmap, const struct path *parentpath, umode_t mode, int open_flag, const struct cred *cred)",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "in [S_IRWXU, S_IRWXG, S_IRWXO]",
            "open_flag": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE]",
            "cred": "!=null"
        }
    }
},
{
    "kprobe:kernel_tmpfile_open": {
        "description": "Create and open a temporary file for kernel internal use. The file is not accounted in nr_files, hence this is only for kernel internal use, and must not be installed into file tables or such.",
        "proto" :"struct file *(*kernel_tmpfile_open)(struct mnt_idmap *idmap, const struct path *parentpath, umode_t mode, int open_flag, const struct cred *cred)",
        "pre": {
            "idmap": "!=null",
            "parentpath": "!=null",
            "mode": "in [S_IRWXU, S_IRWXG, S_IRWXO]",
            "open_flag": "in [O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_NOCTTY, O_TRUNC, O_APPEND, O_NONBLOCK, O_DSYNC, O_ASYNC, O_DIRECT, O_LARGEFILE, O_DIRECTORY, O_NOFOLLOW, O_NOATIME, O_CLOEXEC, O_SYNC, O_PATH, O_TMPFILE, O_NDELAY]",
            "cred": "!=null",
        },
    }
},

{
    "kprobe:vfs_mknod": {
        "description": "vfs_mknod() POV we just have a negative dentry - all is fine. Let's be bastards - you had on the end, you've been asking for (non-existent) directory. -ENOENT for you.",
        "proto" :"static long (*vfs_mknod)(int create_flags)",
        "pre": {
            "create_flags": "==0",
        },
    }
},
{
    "kretprobe:vfs_mkdir": {
        "description": "Create a directory. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "in [S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH]"
        }
    }
},
{
    "kprobe:vfs_mkdir": {
        "description": "Create a directory. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "mode": "is umode_t"
        },
    }
},
{
    "kretprobe:vfs_rmdir": {
        "description": "Remove a directory. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        }
    }
},
{
    "kprobe:vfs_rmdir": {
        "description": "Remove a directory. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null"
        },
    }
},
{
    "kretprobe:vfs_unlink": {
        "description": "Unlink a filesystem object. If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation on that inode and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions.",
        "proto" :"int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null && dir->i_mutex is held",
            "dentry": "!=null",
            "delegated_inode": "can be null, if not null, should be a valid pointer"
        },
        "post": {
            "return": "in [-EWOULDBLOCK, 0] // -EWOULDBLOCK if inode is delegated, 0 if successful"
        }
    }
},
{
    "kprobe:vfs_unlink": {
        "description": "Unlink a filesystem object. If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation on that inode and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null && holds dir->i_mutex",
            "dentry": "!=null",
            "delegated_inode": "can be null, if not, !=null && returns victim inode if inode is delegated"
        },
    }
},
{
    "kretprobe:vfs_symlink": {
        "description": "Create a symlink. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, const char *oldname)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null && is_string(oldname)"
        },
    }
},
{
    "kprobe:vfs_symlink": {
        "description": "Create a symlink. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, const char *oldname)",
        "pre": {
            "idmap": "!=null",
            "dir": "!=null",
            "dentry": "!=null",
            "oldname": "!=null"
        },
    }
},
{
    "kretprobe:vfs_link": {
        "description": "Create a new link. If vfs_link discovers a delegation on the to-be-linked file in need of breaking, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "can be null or !=null"
        },
    }
},
{
    "kprobe:vfs_link": {
        "description": "Create a new link. If vfs_link discovers a delegation on the to-be-linked file in need of breaking, it will return -EWOULDBLOCK and return a reference to the inode in delegated_inode. The caller should then break the delegation and retry. If the inode has been found through an idmapped mount the idmap of the vfsmount must be passed through @idmap. This function will then take care to map the inode according to @idmap before checking permissions. On non-idmapped mounts or if permission checking is to be performed on the raw inode simply pass @nop_mnt_idmap.",
        "proto" :"int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)",
        "pre": {
            "old_dentry": "!=null",
            "idmap": "!=null",
            "dir": "!=null",
            "new_dentry": "!=null",
            "delegated_inode": "can be null or !=null"
        },
    }
},


{
    "kretprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer. Does not touch atime. That's up to the caller if necessary. Does not call security hook.",
        "proto" :"int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        }
    }
},
{
    "kprobe:vfs_readlink": {
        "description": "Copy symlink body into userspace buffer. Does not touch atime. That's up to the caller if necessary. Does not call security hook.",
        "proto" :"int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)",
        "pre": {
            "dentry": "!=null",
            "buffer": "!=null",
            "buflen": ">=0",
        },
    }
},
{
    "kretprobe:vfs_get_link": {
        "description": "Calls security hook and i_op->get_link() on the supplied inode. It does not touch atime. That's up to the caller if necessary. Does not work on 'special' symlinks like proc$$fdN",
        "proto" :"const char *(*vfs_get_link)(struct dentry *dentry, struct delayed_call *done)",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kprobe:vfs_get_link": {
        "description": "Get symlink body. Calls security hook and i_op->get_link() on the supplied inode. It does not touch atime. That's up to the caller if necessary. Does not work on 'special' symlinks like proc$$fdN.",
        "proto" :"const char *(*vfs_get_link)(struct dentry *dentry, struct delayed_call *done)",
        "pre": {
            "dentry": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_create": {
        "description": "Creates entry in @cache with key @key and value @value. The function returns -EBUSY if entry with the same key and value already exists in cache. Otherwise 0 is returned.",
        "proto" :"int (*mb_cache_entry_create)(struct mb_cache *cache, gfp_t mask, u32 key, u64 value, bool reusable)",
        "pre": {
            "cache": "!=null",
            "mask": "is a valid gfp_t mask",
            "key": "is a valid u32 key",
            "value": "is a valid u64 value",
            "reusable": "is a boolean"
        },
    }
},
{
    "kprobe:mb_cache_entry_create": {
        "description": "Creates entry in @cache with key @key and value @value. The function returns -EBUSY if entry with the same key and value already exists in cache. Otherwise 0 is returned.",
        "proto" :"int (*mb_cache_entry_create)(struct mb_cache *cache, gfp_t mask, u32 key, u64 value, bool reusable)",
        "pre": {
            "cache": "!=null",
            "mask": "is gfp_t",
            "key": "is u32",
            "value": "is u64",
            "reusable": "is bool",
        },
    }
},
{
    "kretprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "proto" :"void (*mb_cache_entry_wait_unused)(struct mb_cache_entry *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_wait_unused": {
        "description": "Wait to be the last user of the entry.",
        "proto" :"void (*mb_cache_entry_wait_unused)(struct mb_cache_entry *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_first": {
        "description": "Search in @cache for a reusable entry with key @key. Grabs reference to the first reusable entry found and returns the entry.",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_find_first)(struct mb_cache *cache, u32 key)",
        "pre": {
            "cache": "!=null",
            "key": "is a valid u32 value"
        },
    }
},
{
    "kprobe:mb_cache_entry_find_first": {
        "description": "Search in @cache for a reusable entry with key @key. Grabs reference to the first reusable entry found and returns the entry.",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_find_first)(struct mb_cache *cache, u32 key)",
        "pre": {
            "cache": "!=null",
            "key": "is u32"
        }
    }
},
{
    "kretprobe:mb_cache_entry_find_next": {
        "description": "Finds next reusable entry in the hash chain which has the same key as @entry. If @entry is unhashed (which can happen when deletion of entry races with the search), finds the first reusable entry in the hash chain. The function drops reference to @entry and returns with a reference to the found entry.",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_find_next)(struct mb_cache *cache, struct mb_cache_entry *entry)",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        },
    }
},
{
    "kprobe:mb_cache_entry_find_next": {
        "description": "Finds next reusable entry in the hash chain which has the same key as @entry. If @entry is unhashed (which can happen when deletion of entry races with the search), finds the first reusable entry in the hash chain. The function drops reference to @entry and returns with a reference to the found entry.",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_find_next)(struct mb_cache *cache, struct mb_cache_entry *entry)",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key) @cache - cache we work with @key - key @value - value",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_get)(struct mb_cache *cache, u32 key, u64 value)",
        "pre": {
            "cache": "!=null",
            "key": "!=null",
            "value": "!=null"
        },
    }
},
{
    "kprobe:mb_cache_entry_get": {
        "description": "Get a cache entry by value (and key)",
        "proto" :"struct mb_cache_entry *(*mb_cache_entry_get)(struct mb_cache *cache, u32 key, u64 value)",
        "pre": {
            "cache": "!=null",
            "key": "is u32",
            "value": "is u64",
        },
    }
},


{
    "kretprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "proto" :"void (*mb_cache_entry_touch)(struct mb_cache *cache, struct mb_cache_entry *entry)",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_entry_touch": {
        "description": "Marks entry as used to give hit higher chances of surviving in cache.",
        "proto" :"void (*mb_cache_entry_touch)(struct mb_cache *cache, struct mb_cache_entry *entry)",
        "pre": {
            "cache": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "proto" :"struct mb_cache *(*mb_cache_create)(int bucket_bits)",
        "pre": {
            "bucket_bits": ">=0"
        },
    }
},
{
    "kprobe:mb_cache_create": {
        "description": "Create cache for keys with 2^bucket_bits hash entries.",
        "proto" :"struct mb_cache *(*mb_cache_create)(int bucket_bits)",
        "pre": {
            "bucket_bits": ">=0",
        },
    }
},
{
    "kretprobe:mb_cache_destroy": {
        "description": "Free all entries in cache and cache itself. Caller must make sure nobody (except shrinker) can reach @cache when calling this.",
        "proto" :"void (*mb_cache_destroy)(struct mb_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:mb_cache_destroy": {
        "description": "Free all entries in cache and cache itself. Caller must make sure nobody (except shrinker) can reach @cache when calling this.",
        "proto" :"void (*mb_cache_destroy)(struct mb_cache *cache)",
        "pre": {
            "cache": "!=null && is_unreachable_except_shrinker"
        }
    }
},
{
    "kretprobe:seq_open": {
        "description": "Initialize sequential file @file, associating it with a sequence described by @op. @op->start() sets the iterator up and returns the first element of sequence. @op->stop() shuts it down. @op->next() returns the next element of sequence. @op->show() prints element into the buffer. In case of error ->start() and ->next() return ERR_PTR(error). In the end of sequence they return %NULL. ->show() returns 0 in case of success and negative number in case of error. Returning SEQ_SKIP means 'discard this element and move on'. Note: seq_open() will allocate a struct seq_file and store its pointer in @file->private_data. This pointer should not be modified.",
        "proto": "int seq_open(struct file *file, const struct seq_operations *op)",
        "pre": {
            "file": "!=null",
            "op": "!=null"
        }
    }
},
{
    "kprobe:seq_open": {
        "description": "Initialize sequential file @file, associating it with a sequence described by @op. @op->start() sets the iterator up and returns the first element of sequence. @op->stop() shuts it down. @op->next() returns the next element of sequence. @op->show() prints element into the buffer. In case of error ->start() and ->next() return ERR_PTR(error). In the end of sequence they return %NULL. ->show() returns 0 in case of success and negative number in case of error. Returning SEQ_SKIP means 'discard this element and move on'. Note: seq_open() will allocate a struct seq_file and store its pointer in @file->private_data. This pointer should not be modified.",
        "proto": "int seq_open(struct file *file, const struct seq_operations *op)",
        "pre": {
            "file": "!=null",
            "op": "!=null && op->start !=null && op->stop !=null && op->next !=null && op->show !=null"
        }
    }
},
{
    "kretprobe:seq_read": {
        "description": "read() method for sequential files. @file: the file to read from @buf: the buffer to read to @size: the maximum number of bytes to read @ppos: the current position in the file Ready-made ->f_op->read()",
        "proto" :"ssize_t (*seq_read)(struct file *file, char __user *buf, size_t size, loff_t *ppos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "ppos": ">=0"
        },
    }
},
{
    "kprobe:seq_read": {
        "description": "read() method for sequential files. @file: the file to read from @buf: the buffer to read to @size: the maximum number of bytes to read @ppos: the current position in the file Ready-made ->f_op->read()",
        "proto" :"ssize_t (*seq_read)(struct file *file, char __user *buf, size_t size, loff_t *ppos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "ppos": "!=null",
        },
    }
},
{
    "kretprobe:seq_read_iter": {
        "description": "Ready-made ->f_op->read_iter()",
        "proto" :"ssize_t (*seq_read_iter)(struct kiocb *iocb, struct iov_iter *iter)",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kprobe:seq_read_iter": {
        "description": "Ready-made ->f_op->read_iter()",
        "proto" :"ssize_t (*seq_read_iter)(struct kiocb *iocb, struct iov_iter *iter)",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null"
        }
    }
},
{
    "kretprobe:seq_lseek": {
        "description": "llseek() method for sequential files. @file: the file in question @offset: new position @whence: 0 for absolute, 1 for relative position Ready-made ->f_op->llseek()",
        "proto" :"loff_t (*seq_lseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [0, 1]"
        }
    }
},
{
    "kprobe:seq_lseek": {
        "description": "llseek() method for sequential files. @file: the file in question @offset: new position @whence: 0 for absolute, 1 for relative position Ready-made ->f_op->llseek()",
        "proto" :"loff_t (*seq_lseek)(struct file *file, loff_t offset, int whence)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "whence": "in [0, 1]",
        },
    }
},
{
    "kretprobe:seq_release": {
        "description": "Free the structures associated with sequential file. Can be used as ->f_op->release() if you don't have private data to destroy.",
        "proto" :"int (*seq_release)(struct inode *inode, struct file *file)",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        }
    }
},
{
    "kprobe:seq_release": {
        "description": "Free the structures associated with sequential file. Can be used as ->f_op->release() if you don't have private data to destroy.",
        "proto" :"int (*seq_release)(struct inode *inode, struct file *file)",
        "pre": {
            "inode": "!=null",
            "file": "!=null"
        },
    }
},
{
    "kretprobe:seq_escape_mem": {
        "description": "Puts data into buffer, replacing each occurrence of character from given class (defined by @flags and @esc) with printable escaped sequence. Use seq_has_overflowed() to check for errors.",
        "proto" :"void seq_escape_mem(struct seq_file *m, const char *src, size_t len, unsigned int flags, const char *esc)",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_escape_mem": {
        "description": "Puts data into buffer, replacing each occurrence of character from given class (defined by @flags and @esc) with printable escaped sequence. Use seq_has_overflowed() to check for errors.",
        "proto" :"void (*seq_escape_mem)(struct seq_file *m, const char *src, size_t len, unsigned int flags, const char *esc)",
        "pre": {
            "m": "!=null",
            "src": "!=null",
            "len": ">=0",
            "flags": ">=0",
            "esc": "!=null",
        },
    }
},
{
    "kretprobe:mangle_path": {
        "description": "Copy the path from @p to @s, replacing each occurrence of character from @esc with usual octal escape. Returns pointer past last written character in @s, or NULL in case of failure.",
        "proto" :"char *(*mangle_path)(char *s, const char *p, const char *esc)",
        "pre": {
            "s": "!=null",
            "p": "!=null",
            "esc": "!=null"
        },
    }
},
{
    "kprobe:mangle_path": {
        "description": "Mangle and copy path to buffer beginning. Copy the path from @p to @s, replacing each occurrence of character from @esc with usual octal escape. Returns pointer past last written character in @s, or NULL in case of failure.",
        "proto" :"char *(*mangle_path)(char *s, const char *p, const char *esc)",
        "pre": {
            "s": "!=null",
            "p": "!=null && is within buffer s",
            "esc": "!=null && is set of characters that need escaping"
        },
    }
},
{
    "kretprobe:seq_path": {
        "description": "Return the absolute path of 'path', as represented by the dentry mnt pair in the path parameter.",
        "proto" :"int seq_path(struct seq_file *m, const struct path *path, const char *esc)",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        },
    }
},
{
    "kprobe:seq_path": {
        "description": "Return the absolute path of 'path', as represented by the dentry mnt pair in the path parameter.",
        "proto" :"int (*seq_path)(struct seq_file *m, const struct path *path, const char *esc)",
        "pre": {
            "m": "!=null",
            "path": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_file_path": {
        "description": "seq_file interface to print a pathname of a file. Returns the absolute path to the file.",
        "proto" :"int seq_file_path(struct seq_file *m, struct file *file, const char *esc)",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kprobe:seq_file_path": {
        "description": "seq_file interface to print a pathname of a file. Returns the absolute path to the file.",
        "proto" :"int (*seq_file_path)(struct seq_file *m, struct file *file, const char *esc)",
        "pre": {
            "m": "!=null",
            "file": "!=null",
            "esc": "!=null"
        }
    }
},
{
    "kretprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf(). Only 'unsigned long long' is supported. This routine will put strlen(delimiter) + number into seq_filed. This routine is very quick when you show lots of numbers. In usual cases, it will be better to use seq_printf(). It's easier to read.",
        "proto" :"void (*seq_put_decimal_ull_width)(struct seq_file *m, const char *delimiter, unsigned long long num, unsigned int width)",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "is a non-negative integer",
            "width": "is a non-negative integer"
        }
    }
},
{
    "kprobe:seq_put_decimal_ull_width": {
        "description": "A helper routine for putting decimal numbers without rich format of printf(). Only 'unsigned long long' is supported. This routine will put strlen(delimiter) + number into seq_filed. This routine is very quick when you show lots of numbers. In usual cases, it will be better to use seq_printf(). It's easier to read.",
        "proto" :"void (*seq_put_decimal_ull_width)(struct seq_file *m, const char *delimiter, unsigned long long num, unsigned int width)",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "is an unsigned long long",
            "width": "is an unsigned int"
        },
    }
},
{
    "kretprobe:seq_put_decimal_ll": {
        "description": "Writes a decimal number to a sequence file. If the sequence file's count plus 3 is greater than or equal to its size, it will write at least 2 bytes.",
        "proto" :"static long (*seq_put_decimal_ll)(struct seq_file *m, const char *delimiter, long long num)",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "is a valid long long integer"
        },
    }
},
{
    "kprobe:seq_put_decimal_ll": {
        "description": "Writes a decimal representation of 'num' to the 'seq_file' 'm'. If 'm->count + 3' is greater than or equal to 'm->size', only 2 bytes will be written.",
        "proto" :"int seq_put_decimal_ll(struct seq_file *m, const char *delimiter, long long num)",
        "pre": {
            "m": "!=null",
            "delimiter": "!=null",
            "num": "is a valid long long integer"
        },
    }
},
{
    "kretprobe:seq_write": {
        "description": "Write arbitrary data to buffer. Return 0 on success, non-zero otherwise.",
        "proto": "int (*seq_write)(struct seq_file *seq, const void *data, size_t len)",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:seq_write": {
        "description": "Write arbitrary data to buffer. Return 0 on success, non-zero otherwise.",
        "proto" :"int (*seq_write)(struct seq_file *seq, const void *data, size_t len)",
        "pre": {
            "seq": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:seq_pad": {
        "description": "Write padding spaces to buffer @m. Append byte @c after padding if non-zero.",
        "proto": "void (*seq_pad)(struct seq_file *m, char c)",
        "pre": {
            "m": "!=null",
            "c": "in [0x00, 0xFF]"
        }
    }
},
{
    "kprobe:seq_pad": {
        "description": "Write padding spaces to buffer. Append a byte after padding if non-zero.",
        "proto": "void (*seq_pad)(struct seq_file *m, char c)",
        "pre": {
            "m": "!=null",
            "c": "in [0x00, 0xFF]"
        }
    }
},
{
    "kretprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist. Called at seq_file->op->start().",
        "proto" :"struct hlist_node *(*seq_hlist_start)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start": {
        "description": "Start an iteration of a hlist. Called at seq_file->op->start().",
        "proto" :"struct hlist_node *(*seq_hlist_start)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist. Call this function if you want to print a header at the top of the output.",
        "proto" :"struct hlist_node *(*seq_hlist_start_head)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_head": {
        "description": "Start an iteration of a hlist. Called at seq_file->op->start(). Call this function if you want to print a header at the top of the output.",
        "proto" :"struct hlist_node *(*seq_hlist_start_head)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0",
        },
    }
},
{
    "kretprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist. Called at seq_file->op->next().",
        "proto" :"struct hlist_node *(*seq_hlist_next)(void *v, struct hlist_head *head, loff_t *ppos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        },
    }
},
{
    "kprobe:seq_hlist_next": {
        "description": "Move to the next position of the hlist. Called at seq_file->op->next().",
        "proto" :"struct hlist_node *(*seq_hlist_next)(void *v, struct hlist_head *head, loff_t *ppos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_start_rcu)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_rcu": {
        "description": "Start an iteration of a hlist protected by RCU. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_start_rcu)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU. Call this function if you want to print a header at the top of the output. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_start_head_rcu)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_head_rcu": {
        "description": "Start an iteration of a hlist protected by RCU. Called at seq_file->op->start(). Call this function if you want to print a header at the top of the output. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_start_head_rcu)(struct hlist_head *head, loff_t pos)",
        "pre": {
            "head": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kretprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_next_rcu)(void *v, struct hlist_head *head, loff_t *ppos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        },
    }
},
{
    "kprobe:seq_hlist_next_rcu": {
        "description": "Move to the next position of the hlist protected by RCU. This list-traversal primitive may safely run concurrently with the _rcu list-mutation primitives such as hlist_add_head_rcu() as long as the traversal is guarded by rcu_read_lock().",
        "proto" :"struct hlist_node *(*seq_hlist_next_rcu)(void *v, struct hlist_head *head, loff_t *ppos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "ppos": "!=null"
        },
    }
},
{
    "kretprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array. Called at seq_file->op->start().",
        "proto" :"struct hlist_node *(*seq_hlist_start_percpu)(struct hlist_head __percpu *head, int *cpu, loff_t pos)",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0"
        }
    }
},
{
    "kprobe:seq_hlist_start_percpu": {
        "description": "Start an iteration of a percpu hlist array. Called at seq_file->op->start().",
        "proto" :"struct hlist_node *(*seq_hlist_start_percpu)(struct hlist_head __percpu *head, int *cpu, loff_t pos)",
        "pre": {
            "head": "!=null",
            "cpu": "!=null",
            "pos": ">=0",
        },
    }
},
{
    "kretprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array. Called at seq_file->op->next().",
        "proto" :"struct hlist_node *(*seq_hlist_next_percpu)(void *v, struct hlist_head __percpu *head, int *cpu, loff_t *pos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        }
    }
},
{
    "kprobe:seq_hlist_next_percpu": {
        "description": "Move to the next position of the percpu hlist array. Called at seq_file->op->next().",
        "proto" :"struct hlist_node *(*seq_hlist_next_percpu)(void *v, struct hlist_head __percpu *head, int *cpu, loff_t *pos)",
        "pre": {
            "v": "!=null",
            "head": "!=null",
            "cpu": "!=null",
            "pos": "!=null"
        },
    }
},
{
    "kretprobe:f_setown": {
        "description": "Description of the function",
        "proto" :"static long (*f_setown)(struct file *filp, unsigned long arg, int force)",
        "pre": {
            "filp": "!=null",
            "arg": "is a valid unsigned long",
            "force": "is a valid int"
        },
    }
},
{
    "kprobe:f_setown": {
        "description": "Sets the file owner and modifies it.",
        "proto" :"int f_setown(struct file  filp, unsigned long arg, int force)",
        "pre": {
            "filp": "!=null",
            "arg": "is ulong",
            "force": "is int",
        },
    }
},
{
    "kretprobe:fasync_helper": {
        "description": "fasync_helper() is used by almost all character device drivers to set up the fasync queue, and for regular files by the file lease code. It returns negative on error, 0 if it did no changes and positive if it added/deleted the entry.",
        "proto" :"int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)",
        "pre": {
            "fd": ">=0",
            "filp": "!=null",
            "on": "in [0, 1]",
            "fapp": "!=null",
        },
    }
},
{
    "kprobe:fasync_helper": {
        "description": "Used by almost all character device drivers to set up the fasync queue, and for regular files by the file lease code. It returns negative on error, 0 if it did no changes and positive if it added or deleted the entry.",
        "proto" :"int (*fasync_helper)(int fd, struct file * filp, int on, struct fasync_struct **fapp)",
        "pre": {
            "fd": ">=0",
            "filp": "!=null",
            "on": "in [0, 1]",
            "fapp": "!=null",
        },
    }
},
{
    "kretprobe:kill_fasync_rcu": {
        "description": "Send SIGURG to processes which have not set a queued signum: SIGURG has its own default signalling mechanism.",
        "proto" :"void kill_fasync_rcu(struct fasync_struct *fa, int sig, int band)",
        "pre": {
            "fa": "!=null",
            "sig": "in [SIGURG, ...]",
            "band": "is integer"
        },
    }
},
{
    "kprobe:kill_fasync_rcu": {
        "description": "This function is used to send signals to processes. It checks if the magic number in fasync_struct is correct, and if the file exists, it sends a signal to the process. It does not send SIGURG to processes which have not set a queued signum.",
        "proto" :"void kill_fasync_rcu(struct fasync_struct *fa, int sig, int band)",
        "pre": {
            "fa": "!=null",
            "sig": "in [SIGURG, ...]",
            "band": "is integer",
        },
    }
},
{
    "kretprobe:deactivate_locked_super": {
        "description": "Drop an active reference to superblock @s, converting it into a temporary one if there is no other active references left. In that case we tell fs driver to shut it down and drop the temporary reference we had just acquired. Caller holds exclusive lock on superblock; that lock is released.",
        "proto" :"void (*deactivate_locked_super)(struct super_block *s)",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_locked_super": {
        "description": "Drop an active reference to superblock, converting it into a temporary one if there is no other active references left. In that case we tell fs driver to shut it down and drop the temporary reference we had just acquired. Caller holds exclusive lock on superblock; that lock is released.",
        "proto" :"void (*deactivate_locked_super)(struct super_block *s)",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:deactivate_super": {
        "description": "Drop an active reference to superblock. Variant of deactivate_locked_super(), except that superblock is not locked by caller. If we are going to drop the final active reference, lock will be acquired prior to that.",
        "proto" :"void (*deactivate_super)(struct super_block *s)",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kprobe:deactivate_super": {
        "description": "Drop an active reference to superblock. Variant of deactivate_locked_super(), except that superblock is not locked by caller. If we are going to drop the final active reference, lock will be acquired prior to that.",
        "proto" :"void deactivate_super(struct super_block *s)",
        "pre": {
            "s": "!=null"
        }
    }
},
{
    "kretprobe:retire_super": {
        "description": "generic_shutdown_super(). The function can not be called concurrently with generic_shutdown_super(). It is safe to call the function multiple times, subsequent calls have no effect. The marker will affect the re-use only for block-device-based superblocks. Other superblocks will still get marked if this function is used, but that will not affect their reusability.",
        "proto" :"void retire_super(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:retire_super": {
        "description": "generic_shutdown_super(). The function can not be called concurrently with generic_shutdown_super(). It is safe to call the function multiple times, subsequent calls have no effect. The marker will affect the re-use only for block-device-based superblocks. Other superblocks will still get marked if this function is used, but that will not affect their reusability.",
        "proto" :"void retire_super(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:sget_fc": {
        "description": "Find or create a superblock using the parameters stored in the filesystem context and the two callback functions. If an extant superblock is matched, then that will be returned with an elevated reference count that the caller must transfer or discard. If no match is made, a new superblock will be allocated and basic initialisation will be performed (s_type, s_fs_info and s_id will be set and the set() callback will be invoked), the superblock will be published and it will be returned in a partially constructed state with SB_BORN and SB_ACTIVE as yet unset.",
        "proto" :"struct super_block *sget_fc(struct fs_context *fc, int (*test)(struct super_block *, struct fs_context *), int (*set)(struct super_block *, struct fs_context *))",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kprobe:sget_fc": {
        "description": "Find or create a superblock using the parameters stored in the filesystem context and the two callback functions. If an extant superblock is matched, then that will be returned with an elevated reference count that the caller must transfer or discard. If no match is made, a new superblock will be allocated and basic initialisation will be performed (s_type, s_fs_info and s_id will be set and the set() callback will be invoked), the superblock will be published and it will be returned in a partially constructed state with SB_BORN and SB_ACTIVE as yet unset.",
        "proto" :"struct super_block *sget_fc(struct fs_context *fc, int (*test)(struct super_block *, struct fs_context *), int (*set)(struct super_block *, struct fs_context *))",
        "pre": {
            "fc": "!=null",
            "test": "!=null",
            "set": "!=null"
        }
    }
},
{
    "kretprobe:down_write_nested": {
        "description": "Acquires a write lock on the s_umount field of the superblock structure. This function is annotated to be in a different subclass to avoid deadlocks.",
        "proto" :"void down_write_nested(struct rw_semaphore *sem, int subclass)",
        "pre": {
            "sem": "!=null",
            "subclass": "==SINGLE_DEPTH_NESTING"
        },
    }
},
{
    "kprobe:down_write_nested": {
        "description": "Acquires a write lock on the s_umount field of the superblock structure. This is annotated to be in a different subclass to avoid deadlocks.",
        "proto" :"static void (*down_write_nested)(struct rw_semaphore *sem, int subclass)",
        "pre": {
            "sem": "!=null",
            "subclass": "==SINGLE_DEPTH_NESTING"
        },
    }
},
{
    "kretprobe:iterate_supers_type": {
        "description": "Scans the superblock list and calls given function, passing it locked superblock and given argument.",
        "proto" :"void (*iterate_supers_type)(struct file_system_type *type, void (*f)(struct super_block *, void *), void *arg)",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:iterate_supers_type": {
        "description": "Scans the superblock list and calls given function, passing it locked superblock and given argument.",
        "proto" :"void (*iterate_supers_type)(struct file_system_type *type, void (*f)(struct super_block *, void *), void *arg)",
        "pre": {
            "type": "!=null",
            "f": "!=null",
            "arg": "can be null or !=null",
        },
    }
},
{
    "kretprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one. Filesystems which don't use real block devices can call this function to allocate a virtual block device. Frequently called while holding sb_lock.",
        "proto" :"int (*get_anon_bdev)(dev_t *p)",
        "pre": {
            "p": "!=null"
        },
        "post": {
            "return": "in [0, -EMFILE, -ENOMEM]"
        }
    }
},
{
    "kprobe:get_anon_bdev": {
        "description": "Allocate a block device for filesystems which don't have one. Filesystems which don't use real block devices can call this function to allocate a virtual block device. Frequently called while holding sb_lock.",
        "proto" :"int (*get_anon_bdev)(dev_t *p)",
        "pre": {
            "p": "!=null"
        },
        "post": {
            "return": "in [0, -EMFILE, -ENOMEM]"
        }
    }
},
{
    "kretprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device. @fc: The filesystem context holding the parameters. @fill_super: Helper to initialise a new superblock.",
        "proto" :"int (*get_tree_bdev)(struct fs_context *fc, int (*fill_super)(struct super_block *, struct fs_context *))",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "kprobe:get_tree_bdev": {
        "description": "Get a superblock based on a single block device. The filesystem context holding the parameters. Helper to initialise a new superblock.",
        "proto" :"int (*get_tree_bdev)(struct fs_context *fc, int (*fill_super)(struct super_block *, struct fs_context *))",
        "pre": {
            "fc": "!=null",
            "fill_super": "!=null"
        }
    }
},
{
    "kretprobe:mount_bdev": {
        "description": "Mount a block device by path, with specified file system type, flags, and fill_super function.",
        "proto": "static long (*mount_bdev)(struct file_system_type fs_type, int flags, const char dev_name, void data, int (*fill_super)(struct super_block, void, int))",
        "pre": {
            "fs_type": "!=null",
            "flags": "in [MS_RDONLY, MS_SYNCHRONOUS, MS_MANDLOCK, MS_DIRSYNC, MS_NOATIME, MS_NODIRATIME, MS_BIND, MS_MOVE, MS_REC, MS_VERBOSE, MS_SILENT, MS_POSIXACL, MS_UNBINDABLE, MS_PRIVATE, MS_SLAVE, MS_SHARED, MS_RELATIME, MS_KERNMOUNT, MS_I_VERSION, MS_STRICTATIME, MS_LAZYTIME, MS_SUBMOUNT, MS_NOREMOTELOCK, MS_NOSEC, MS_BORN, MS_ACTIVE, MS_NOUSER]",
            "dev_name": "!=null",
            "data": "can be null",
            "fill_super": "!=null"
        }
    }
},
{
    "kprobe:mount_bdev": {
        "description": "Mounts a block device by path, opens it in a specific mode, and associates it with a file system type.",
        "proto" :"mount_bdev(struct file_system_type  fs_type,int flags, const char  dev_name, void  data,int ( fill_super)(struct super_block  , void  , int))",
        "pre": {
            "fs_type": "!=null",
            "flags": "in [sb_open_mode]",
            "dev_name": "!=null",
            "data": "!=null",
            "fill_super": "!=null"
        },
    }
},
{
    "kretprobe:mount_single": {
        "description": "Mounts a single filesystem. The second mount should be rejected if the parameters are not compatible.",
        "proto" :"static int (*mount_single)(struct super_block *s, void *p)",
        "pre": {
            "s": "!=null",
            "p": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:vfs_get_tree": {
        "description": "The filesystem is invoked to get or create a superblock which can then later be used for mounting. The filesystem places a pointer to the root to be used for mounting in @fc->root.",
        "proto" :"int vfs_get_tree(struct fs_context *fc)",
        "pre": {
            "fc": "!=null"
        },
    }
},
{
    "kprobe:vfs_get_tree": {
        "description": "The filesystem is invoked to get or create a superblock which can then later be used for mounting. The filesystem places a pointer to the root to be used for mounting in @fc->root.",
        "proto" :"int (*vfs_get_tree)(struct fs_context *fc)",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kretprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state. Syncs the super to make sure the filesystem is consistent and calls the fs's freeze_fs. Subsequent calls to this without first thawing the fs will return -EBUSY. During this function, sb->s_writers.frozen goes through these values: SB_UNFROZEN, SB_FREEZE_WRITE, SB_FREEZE_PAGEFAULT, SB_FREEZE_FS, SB_FREEZE_COMPLETE. sb->s_writers.frozen is protected by sb->s_umount.",
        "proto": "int freeze_super(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kprobe:freeze_super": {
        "description": "Lock the filesystem and force it into a consistent state. Syncs the super to make sure the filesystem is consistent and calls the fs's freeze_fs. Subsequent calls to this without first thawing the fs will return -EBUSY.",
        "proto" :"int (*freeze_super)(struct super_block *sb)",
        "pre": {
            "sb": "!=null"
        }
    }
},
{
    "kretprobe:super_cache_scan": {
        "description": "Scans the cache and shrinks it according to the provided control.",
        "proto" :"static unsigned long super_cache_scan(struct shrinker *shrink, struct shrink_control *sc)",
        "pre": {
            "shrink": "!=null",
            "sc": "!=null"
        }
    }
},

{
    "kretprobe:__mnt_want_write_file": {
        "description": "mnt_drop_write_file.",
        "proto" :"int (*__mnt_want_write_file)(struct file *file)",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kprobe:__mnt_want_write_file": {
        "description": "mnt_drop_write_file.",
        "proto" :"int (*__mnt_want_write_file)(struct file *file)",
        "pre": {
            "file": "!=null"
        }
    }
},
{
    "kretprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock. The configuration context with the superblock attached. Create a mount to an already configured superblock. If necessary, the caller should invoke vfs_get_tree() before calling this. Note that this does not attach the mount to anything.",
        "proto" :"struct vfsmount *(*vfs_create_mount)(struct fs_context *fc)",
        "pre": {
            "fc": "!=null"
        }
    }
},
{
    "kprobe:vfs_create_mount": {
        "description": "Create a mount for a configured superblock. The configuration context with the superblock attached. Create a mount to an already configured superblock. If necessary, the caller should invoke vfs_get_tree() before calling this. Note that this does not attach the mount to anything.",
        "proto" :"struct vfsmount *(*vfs_create_mount)(struct fs_context *fc)",
        "pre": {
            "fc": "!=null"
        }
    }
},


{
    "kretprobe:mntget": {
        "description": "Provide a description here",
        "proto" :"Provide the function prototype here",
        "pre": {
            "param1": "Provide condition for param1 here",
            "param2": "Provide condition for param2 here",
            "param3": "Provide condition for param3 here",
            "param4": "Provide condition for param4 here",
        },
    }
},
{
    "kprobe:mnt_set_mountpoint_beneath": {
        "description": "mntget",
        "proto" :"void mnt_set_mountpoint_beneath(struct mount *new_parent, struct mount *top_mnt, struct mountpoint *new_mp)",
        "pre": {
            "new_parent": "!=null",
            "top_mnt": "!=null",
            "new_mp": "!=null"
        },
    }
},
{
    "kretprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace.",
        "proto" :"bool (*path_is_mountpoint)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:path_is_mountpoint": {
        "description": "Check if path is a mount in the current namespace. d_mountpoint() can only be used reliably to establish if a dentry is not mounted in any namespace and that common case is handled inline. d_mountpoint() isn't aware of the possibility there may be multiple mounts using a given dentry in a different namespace. This function checks if the passed in path is a mountpoint rather than the dentry alone.",
        "proto" :"bool (*path_is_mountpoint)(const struct path *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kretprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy. This is called to check if a tree of mounts has any open files, pwds, chroots or sub mounts that are busy.",
        "proto" :"int (*may_umount_tree)(struct vfsmount *m)",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kprobe:may_umount_tree": {
        "description": "Check if a mount tree is busy. This is called to check if a tree of mounts has any open files, pwds, chroots or sub mounts that are busy.",
        "proto" :"int may_umount_tree(struct vfsmount *m)",
        "pre": {
            "m": "!=null"
        }
    }
},
{
    "kretprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list. @mnt: The mount to list. @expiry_list: The list to add the mount to.",
        "proto" :"void (*mnt_set_expiry)(struct vfsmount *mnt, struct list_head *expiry_list)",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        }
    }
},
{
    "kprobe:mnt_set_expiry": {
        "description": "Put a mount on an expiration list. @mnt: The mount to list. @expiry_list: The list to add the mount to.",
        "proto" :"void (*mnt_set_expiry)(struct vfsmount *mnt, struct list_head *expiry_list)",
        "pre": {
            "mnt": "!=null",
            "expiry_list": "!=null"
        },
    }
},
{
    "kretprobe:mount_subtree": {
        "description": "Your description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here",
            "param4": "Your condition here",
        },
    }
},
{
    "kprobe:mount_subtree": {
        "description": "Trade a vfsmount reference for active sb one.",
        "proto" :"mount_subtree(struct vfsmount  m, const char  name)",
        "pre": {
            "m": "!=null",
            "name": "!=null",
            // Add other conditions here
        },
    }
},
{
    "kretprobe:kern_unmount": {
        "description": "Unmount a given file system.",
        "proto" :"int (*kern_unmount)(struct vfsmount *mnt)",
        "pre": {
            "mnt": "!=null"
        }
    }
},
{
    "kprobe:kern_unmount": {
        "description": "Unmount a kernel file system.",
        "proto" :"int (*kern_unmount)(struct super_block *sb)",
        "pre": {
            "sb": "!=null",
        },
    }
},
{
    "kretprobe:fscache_end_volume_access": {
        "description": "Unpin a cache volume after we've accessed it. The datafile @cookie and the @why indicator are merely provided for tracing purposes.",
        "proto" :"void fscache_end_volume_access(struct fscache_volume *volume, struct fscache_cookie *cookie, enum fscache_access_trace why)",
        "pre": {
            "volume": "!=null",
            "cookie": "!=null || ==null",
            "why": "in [fscache_access_unlive]"
        }
    }
},
{
    "kprobe:fscache_end_volume_access": {
        "description": "Unpin a cache volume after we've accessed it. The datafile @cookie and the @why indicator are merely provided for tracing purposes.",
        "proto" :"void (*fscache_end_volume_access)(struct fscache_volume *volume, struct fscache_cookie *cookie, enum fscache_access_trace why)",
        "pre": {
            "volume": "!=null",
            "cookie": "can be null",
            "why": "is an enum value of fscache_access_trace",
        },
    }
},
{
    "kretprobe:fscache_withdraw_volume": {
        "description": "Withdraw a cache volume from service, waiting for all accesses to complete before returning.",
        "proto" :"void (*fscache_withdraw_volume)(struct fscache_volume *volume)",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_volume": {
        "description": "Withdraw a cache volume from service, waiting for all accesses to complete before returning.",
        "proto" :"void (*fscache_withdraw_volume)(struct fscache_volume *volume)",
        "pre": {
            "volume": "!=null"
        }
    }
},
{
    "kretprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access. Unpin a cache cookie after we've accessed it and bring a deferred relinquishment or withdrawal state into effect. The @why indicator is provided for tracing purposes.",
        "proto" :"void (*fscache_end_cookie_access)(struct fscache_cookie *cookie, enum fscache_access_trace why)",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_ACCESS_START, FSCACHE_ACCESS_CONTINUE, FSCACHE_ACCESS_END]"
        }
    }
},
{
    "kprobe:fscache_end_cookie_access": {
        "description": "Unpin a cache at the end of an access. Unpin a cache cookie after we've accessed it and bring a deferred relinquishment or withdrawal state into effect. The @why indicator is provided for tracing purposes.",
        "proto" :"void (*fscache_end_cookie_access)(struct fscache_cookie *cookie, enum fscache_access_trace why)",
        "pre": {
            "cookie": "!=null",
            "why": "in [FSCACHE_TRACE_ACCESS_START, FSCACHE_TRACE_ACCESS_END, FSCACHE_TRACE_ACCESS_DEFERRED, FSCACHE_TRACE_ACCESS_WITHDRAWN]"
        }
    }
},
{
    "kretprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup. Note that some part of the metadata path in the cache doesn't exist and so we can release any waiting readers in the certain knowledge that there's nothing for them to actually read. This function uses no locking and must only be called from the state machine.",
        "proto" :"void (*fscache_cookie_lookup_negative)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_cookie_lookup_negative": {
        "description": "Note negative lookup. Note that some part of the metadata path in the cache doesn't exist and so we can release any waiting readers in the certain knowledge that there's nothing for them to actually read. This function uses no locking and must only be called from the state machine.",
        "proto" :"void (*fscache_cookie_lookup_negative)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation. Tell fscache that invalidation is sufficiently complete that IO can be allowed again.",
        "proto" :"void (*fscache_resume_after_invalidation)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_resume_after_invalidation": {
        "description": "Allow IO to resume after invalidation. Tell fscache that invalidation is sufficiently complete that IO can be allowed again.",
        "proto" :"void (*fscache_resume_after_invalidation)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kretprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie. Tell fscache that caching on a cookie needs to be stopped due to some sort of failure. This function uses no locking and must only be called from the state machine.",
        "proto" :"void (*fscache_caching_failed)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_caching_failed": {
        "description": "Report that a failure stopped caching on a cookie. Tell fscache that caching on a cookie needs to be stopped due to some sort of failure. This function uses no locking and must only be called from the state machine.",
        "proto" :"void (*fscache_caching_failed)(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null",
        },
    }
},
{
    "__fscache_use_cookie": {
        "description": "Your function description here",
        "proto" :"static long (*__fscache_use_cookie)(struct fscache_cookie *cookie, bool will_modify)",
        "pre": {
            "cookie": "!=null",
            "will_modify": "is boolean"
        },
    }
},

{
    "kretprobe:__fscache_unuse_cookie": {
        "description": "Subtract 1 from counter unless that drops it to 0 (ie. it was 1)",
        "proto" :"void __fscache_unuse_cookie(struct fscache_cookie *cookie, const void *aux_data, const loff_t object_size)",
        "pre": {
            "cookie": "!=null",
            "cookie->n_active": ">=1",
            "aux_data": "can be null",
            "object_size": "can be any integer"
        },
        "post": {
            "c": "!=1"
        }
    }
},
{
    "kprobe:__fscache_unuse_cookie": {
        "description": "Subtract 1 from counter unless that drops it to 0 (ie. it was 1)",
        "proto" :"void __fscache_unuse_cookie(struct fscache_cookie *cookie, const void *aux_data, const loff_t object_size)",
        "pre": {
            "cookie": "!=null",
            "aux_data": "can be null",
            "object_size": "can be null",
            "cookie->n_active": ">=1"
        },
    }
},
{
    "kretprobe:fscache_begin_lookup": {
        "description": "Begin the process of looking up a cookie. We offload the actual process to a worker thread.",
        "proto" :"static bool (*fscache_begin_lookup)(struct fscache_cookie *cookie, bool will_modify)",
        "pre": {
            "cookie": "!=null",
            "will_modify": "in [true, false]"
        }
    }
},
{
    "kprobe:fscache_begin_lookup": {
        "description": "Begin the process of looking up a cookie. We offload the actual process to a worker thread.",
        "proto" :"static bool (*fscache_begin_lookup)(struct fscache_cookie *cookie, bool will_modify)",
        "pre": {
            "cookie": "!=null",
            "will_modify": "in [true, false]"
        },
    }
},
{
    "kretprobe:fscache_init_access_gate": {
        "description": "Initialise the access gate on a cookie by setting a flag to prevent the state machine from being queued when the access counter transitions to 0. We're only interested in this when we withdraw caching services from the cookie.",
        "proto" :"static void fscache_init_access_gate(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "!=null"
        }
    }
},
{
    "kprobe:fscache_init_access_gate": {
        "description": "Initialise the access gate on a cookie by setting a flag to prevent the state machine from being queued when the access counter transitions to 0. We're only interested in this when we withdraw caching services from the cookie.",
        "proto" :"static void fscache_init_access_gate(struct fscache_cookie *cookie)",
        "pre": {
            "cookie": "your_condition_here"
        }
    }
},
{
    "kretprobe:__fscache_invalidate": {
        "description": "Invalidates a fscache cookie.",
        "proto" :"void __fscache_invalidate(struct fscache_cookie *cookie, const void *aux_data, loff_t new_size, unsigned int flags)",
        "pre": {
            "cookie": "!=null",
            "aux_data": "!=null",
            "new_size": ">=0",
            "flags": "in [FSCACHE_INVAL_DIO_WRITE, FSCACHE_COOKIE_DISABLED, FSCACHE_COOKIE_NO_DATA_TO_READ, FSCACHE_COOKIE_RELINQUISHED]"
        }
    }
},
{
    "kprobe:__fscache_invalidate": {
        "description": "Invalidates a fscache cookie.",
        "proto" :"void __fscache_invalidate(struct fscache_cookie *cookie, const void *aux_data, loff_t new_size, unsigned int flags)",
        "pre": {
            "cookie": "!=null",
            "flags": "in [FSCACHE_INVAL_DIO_WRITE, ...]",
        },
    }
},
{
    "kretprobe:fscache_wait_for_operation": {
        "description": "Wait for an object become accessible. See if the target cache object is at the specified minimum state of accessibility yet, and if not, wait for it.",
        "proto" :"bool (*fscache_wait_for_operation)(struct netfs_cache_resources *cres, enum fscache_want_state want_state)",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_INITIAL, FSCACHE_WANT_CREATE, FSCACHE_WANT_READ, FSCACHE_WANT_UPDATE, FSCACHE_WANT_DELETE]"
        }
    }
},
{
    "kprobe:fscache_wait_for_operation": {
        "description": "Wait for an object become accessible. See if the target cache object is at the specified minimum state of accessibility yet, and if not, wait for it.",
        "proto" :"bool (*fscache_wait_for_operation)(struct netfs_cache_resources *cres, enum fscache_want_state want_state)",
        "pre": {
            "cres": "!=null",
            "want_state": "in [FSCACHE_WANT_INITIAL, FSCACHE_WANT_CREATE, FSCACHE_WANT_READ, FSCACHE_WANT_UPDATE, FSCACHE_WANT_DELETE]"
        },
    }
},
{
    "kretprobe:fscache_dirty_folio": {
        "description": "Set the dirty flag on a folio and pin an in-use cache object in memory so that writeback can later write to it. This is intended to be called from the filesystem's ->dirty_folio() method.",
        "proto" :"bool (*fscache_dirty_folio)(struct address_space *mapping, struct folio *folio, struct fscache_cookie *cookie)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:fscache_dirty_folio": {
        "description": "Mark folio dirty and pin a cache object for writeback. Set the dirty flag on a folio and pin an in-use cache object in memory so that writeback can later write to it. This is intended to be called from the filesystem's ->dirty_folio() method.",
        "proto" :"bool (*fscache_dirty_folio)(struct address_space *mapping, struct folio *folio, struct fscache_cookie *cookie)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "cookie": "!=null"
        },
    }
},
{
    "kretprobe:__fscache_write_to_cache": {
        "description": "Writes data to the cache.",
        "proto" :"static long (*__fscache_write_to_cache)(struct fscache_cookie  cookie, struct address_space  mapping, loff_t start, size_t len, loff_t i_size, netfs_io_terminated_t term_func, void  term_func_priv, bool cond)",
        "pre": {
            "cookie": "!=null",
            "mapping": "!=null",
            "start": ">=0",
            "len": ">=0",
            "i_size": ">=0",
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "cond": "in [true, false]"
        }
    }
},
{
    "kprobe:__fscache_write_to_cache": {
        "description": "Writes data to the cache.",
        "proto" :"static void (*__fscache_write_to_cache)(struct fscache_cookie  cookie, struct address_space  mapping, loff_t start, size_t len, loff_t i_size, netfs_io_terminated_t term_func, void  term_func_priv, bool cond)",
        "pre": {
            "cookie": "!=null",
            "mapping": "!=null",
            "start": ">=0",
            "len": ">=0",
            "i_size": ">=0",
            "term_func": "!=null",
            "term_func_priv": "!=null",
            "cond": "in [true, false]"
        }
    }
},
{
    "__fscache_resize_cookie": {
        "description": "Resize the fscache cookie. This operation cannot be deferred as it needs to be done inside the netfs's inode lock so that it's serialised with respect to writes.",
        "proto" :"__fscache_resize_cookie(struct fscache_cookie  cookie, loff_t new_size)",
        "pre": {
            "cookie": "!=null",
            "new_size": ">=0"
        },
    }
},

{
    "kretprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie. Get a cookie to represent an actual cache. If a name is given and there is a nameless cache record available, this will acquire that and set its name, directing all the volumes using it to this cache. The cache will be switched over to the preparing state if not currently in use, otherwise -EBUSY will be returned.",
        "proto" :"struct fscache_cache *(*fscache_acquire_cache)(const char *name)",
        "pre": {
            "name": "!=null"
        },
    }
},
{
    "kprobe:fscache_acquire_cache": {
        "description": "Acquire a cache-level cookie. Get a cookie to represent an actual cache. If a name is given and there is a nameless cache record available, this will acquire that and set its name, directing all the volumes using it to this cache. The cache will be switched over to the preparing state if not currently in use, otherwise -EBUSY will be returned.",
        "proto" :"struct fscache_cache *(*fscache_acquire_cache)(const char *name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie. Reset the state of a cache and release the caller's reference on a cache cookie.",
        "proto" :"void (*fscache_relinquish_cache)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_relinquish_cache": {
        "description": "Reset cache state and release cookie. Reset the state of a cache and release the caller's reference on a cache cookie.",
        "proto" :"void (*fscache_relinquish_cache)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_add_cache": {
        "description": "Add a cache to the system, making it available for netfs's to use.",
        "proto" :"int fscache_add_cache(struct fscache_cache *cache, const struct fscache_cache_ops *ops, void *cache_priv)",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "!=null"
        }
    }
},
{
    "kprobe:fscache_add_cache": {
        "description": "Add a cache to the system, making it available for netfs's to use.",
        "proto" :"int (*fscache_add_cache)(struct fscache_cache *cache, const struct fscache_cache_ops *ops, void *cache_priv)",
        "pre": {
            "cache": "!=null",
            "ops": "!=null",
            "cache_priv": "can be null or !=null",
        },
    }
},
{
    "kretprobe:fscache_io_error": {
        "description": "Note a cache IO error and report it into the kernel log. The cache should no longer be used for anything after an IO error occurred.",
        "proto" :"void (*fscache_io_error)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_io_error": {
        "description": "Note a cache IO error. Note that an IO error occurred in a cache and that it should no longer be used for anything. This also reports the error into the kernel log. See Documentationfilesystemscachingbackend-api.rst for a complete description.",
        "proto" :"void (*fscache_io_error)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscache_withdraw_cache": {
        "description": "Begin the process of withdrawing a cache from service. This stops new cache-level and volume-level accesses from taking place and waits for currently ongoing cache-level accesses to end.",
        "proto" :"void (*fscache_withdraw_cache)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kprobe:fscache_withdraw_cache": {
        "description": "Begin the process of withdrawing a cache from service. This stops new cache-level and volume-level accesses from taking place and waits for currently ongoing cache-level accesses to end.",
        "proto" :"void (*fscache_withdraw_cache)(struct fscache_cache *cache)",
        "pre": {
            "cache": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a 'read' bio following successful completion of the underlying disk read. The bio must be reading a whole number of blocks of an encrypted file directly into the page cache. If the bio is reading the ciphertext into bounce pages instead of the page cache, then this function isn't applicable. This function may sleep, so it must be called from a workqueue rather than from the bio's bi_end_io callback.",
        "proto" :"bool (*fscrypt_decrypt_bio)(struct bio *bio)",
        "pre": {
            "bio": "!=null && is_reading_whole_number_of_blocks && is_reading_into_page_cache"
        },
        "post": {
            "return": "in [true, false]",
            "bio->bi_status": "if return == false then error else unchanged"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_bio": {
        "description": "Decrypt the contents of a 'read' bio following successful completion of the underlying disk read. The bio must be reading a whole number of blocks of an encrypted file directly into the page cache. If the bio is reading the ciphertext into bounce pages instead of the page cache (for example, because the file is also compressed, so decompression is required after decryption), then this function isn't applicable. This function may sleep, so it must be called from a workqueue rather than from the bio's bi_end_io callback.",
        "proto" :"bool (*fscrypt_decrypt_bio)(struct bio *bio)",
        "pre": {
            "bio": "!=null && is_reading_whole_number_of_blocks && is_reading_directly_into_page_cache"
        },
        "post": {
            "return": "in [true, false]",
            "bio->bi_status": "!=null on failure"
        }
    }
},
{
    "kretprobe:fscrypt_zeroout_range_inline_crypt": {
        "description": "This function is used to zero out a range in an inline crypt.",
        "proto" :"fscrypt_zeroout_range_inline_crypt(const struct inode  inode, pgoff_t lblk, sector_t pblk, unsigned int len)",
        "pre": {
            "inode": "!=null",
            "lblk": ">=0",
            "pblk": ">=0",
            "len": ">0",
        },
    }
},

{
    "kretprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data. Filesystems must call this when the inode is being evicted. An RCU grace period need not have elapsed yet.",
        "proto" :"void (*fscrypt_put_encryption_info)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_put_encryption_info": {
        "description": "Free most of an inode's fscrypt data. Filesystems must call this when the inode is being evicted. An RCU grace period need not have elapsed yet.",
        "proto" :"void (*fscrypt_put_encryption_info)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_free_inode": {
        "description": "Free the inode's cached decrypted symlink target, if any. Filesystems must call this after an RCU grace period, just before they free the inode.",
        "proto" :"void (*fscrypt_free_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_free_inode": {
        "description": "Free an inode's fscrypt data requiring RCU delay. Filesystems must call this after an RCU grace period, just before they free the inode.",
        "proto" :"static void (*fscrypt_free_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_ioctl_set_policy": {
        "description": "Your function description here",
        "proto" :"fscrypt_ioctl_set_policy(struct file  filp, const void __user  arg)",
        "pre": {
            "filp": "Your condition here",
            "arg": "Your condition here"
        }
    }
},
{
    "kprobe:fscrypt_ioctl_set_policy": {
        "description": "Sets the encryption policy for a file or directory.",
        "proto" :"static long (*fscrypt_ioctl_set_policy)(struct file *filp, const void __user *arg)",
        "pre": {
            "filp": "!=null",
            "arg": "!=null"
        },
    }
},
{
    "kretprobe:fscrypt_has_permitted_context": {
        "description": "Checks if a file's encryption policy is permitted within its directory. Filesystems must call this before permitting access to an inode in a situation where the parent directory is encrypted and before any operation that involves linking an inode into an encrypted directory. It enforces the constraint that within a given encrypted directory tree, all files use the same encryption policy.",
        "proto" :"int fscrypt_has_permitted_context(struct inode *parent, struct inode *child)",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:fscrypt_has_permitted_context": {
        "description": "Checks if a file's encryption policy is permitted within its directory. Filesystems must call this before permitting access to an inode in a situation where the parent directory is encrypted and before any operation that involves linking an inode into an encrypted directory. It enforces the constraint that within a given encrypted directory tree, all files use the same encryption policy.",
        "proto" :"int (*fscrypt_has_permitted_context)(struct inode *parent, struct inode *child)",
        "pre": {
            "parent": "!=null",
            "child": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fname_decrypt": {
        "description": "Decrypts the filename. Return: 0 on success, -errno on failure.",
        "proto": "static int fname_decrypt(const struct inode *inode, const struct fscrypt_str *iname, struct fscrypt_str *oname)",
        "pre": {
            "inode": "!=null",
            "iname": "!=null",
            "oname": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:fname_decrypt": {
        "description": "Decrypts the filename. Returns 0 on success, -errno on failure.",
        "proto" :"static int (*fname_decrypt)(const struct inode *inode, const struct fscrypt_str *iname, struct fscrypt_str *oname)",
        "pre": {
            "inode": "!=null",
            "iname": "!=null",
            "oname": "!=null"
        },
    }
},
{
    "kretprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer that was allocated by fscrypt_fname_alloc_buffer().",
        "proto" :"void (*fscrypt_fname_free_buffer)(struct fscrypt_str *crypto_str)",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_fname_free_buffer": {
        "description": "Free a buffer that was allocated by fscrypt_fname_alloc_buffer().",
        "proto" :"void (*fscrypt_fname_free_buffer)(struct fscrypt_str *crypto_str)",
        "pre": {
            "crypto_str": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form. If the key is available, we'll decrypt the disk name. Otherwise, we'll encode it for presentation in fscrypt_nokey_name format.",
        "proto" :"int (*fscrypt_fname_disk_to_usr)(const struct inode *inode, u32 hash, u32 minor_hash, const struct fscrypt_str *iname, struct fscrypt_str *oname)",
        "pre": {
            "inode": "!=null",
            "hash": ">=0",
            "minor_hash": ">=0",
            "iname": "!=null",
            "oname": "!=null"
        },
    }
},
{
    "kprobe:fscrypt_fname_disk_to_usr": {
        "description": "Convert an encrypted filename to user-presentable form. If the key is available, we'll decrypt the disk name. Otherwise, we'll encode it for presentation in fscrypt_nokey_name format.",
        "proto" :"int (*fscrypt_fname_disk_to_usr)(const struct inode *inode, u32 hash, u32 minor_hash, const struct fscrypt_str *iname, struct fscrypt_str *oname)",
        "pre": {
            "inode": "!=null",
            "hash": ">=0",
            "minor_hash": ">=0",
            "iname": "!=null",
            "oname": "!=null"
        },
    }
},
{
    "kretprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory. Given a user-provided filename @iname, this function sets @fname->disk_name to the name that would be stored in the on-disk directory entry, if possible. If the directory is unencrypted this is simply @iname. Else, if we have the directory's encryption key, then @iname is the plaintext, so we encrypt it to get the disk_name. Else, for keyless @lookup operations, @iname should be a no-key name, so we decode it to get the struct fscrypt_nokey_name. Non-@lookup operations will be impossible in this case, so we fail them with ENOKEY. If successful, fscrypt_free_filename() must be called later to clean up.",
        "proto" :"int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname)",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:fscrypt_setup_filename": {
        "description": "Prepare to search a possibly encrypted directory. Given a user-provided filename @iname, this function sets @fname->disk_name to the name that would be stored in the on-disk directory entry, if possible. If the directory is unencrypted this is simply @iname. Else, if we have the directory's encryption key, then @iname is the plaintext, so we encrypt it to get the disk_name. Else, for keyless @lookup operations, @iname should be a no-key name, so we decode it to get the struct fscrypt_nokey_name. Non-@lookup operations will be impossible in this case, so we fail them with ENOKEY. If successful, fscrypt_free_filename() must be called later to clean up.",
        "proto" :"int (*fscrypt_setup_filename)(struct inode *dir, const struct qstr *iname, int lookup, struct fscrypt_name *fname)",
        "pre": {
            "dir": "!=null",
            "iname": "!=null",
            "lookup": "in [0, 1]",
            "fname": "!=null"
        },
    }
},
{
    "kretprobe:fscrypt_free_bounce_page": {
        "description": "Free the bounce page allocated by fscrypt_encrypt_pagecache_blocks(), or by fscrypt_alloc_bounce_page() directly.",
        "proto" :"void (*fscrypt_free_bounce_page)(struct page *bounce_page)",
        "pre": {
            "bounce_page": "!=null"
        }
    }
},
{
    "kprobe:fscrypt_free_bounce_page": {
        "description": "Free the bounce page allocated by fscrypt_encrypt_pagecache_blocks(), or by fscrypt_alloc_bounce_page() directly.",
        "proto" :"void (*fscrypt_free_bounce_page)(struct page *bounce_page)",
        "pre": {
            "bounce_page": "!=null"
        }
    }
},
{
    "kretprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a filesystem block in-place. The inode and lblk_num must be specified, as they can't be determined from page. Return: 0 on success; -errno on failure",
        "proto" :"int fscrypt_encrypt_block_inplace(const struct inode *inode, struct page *page, unsigned int len, unsigned int offs, u64 lblk_num, gfp_t gfp_flags)",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": "is multiple of FSCRYPT_CONTENTS_ALIGNMENT",
            "offs": ">=0",
            "lblk_num": ">=0",
            "gfp_flags": "valid memory allocation flags"
        }
    }
},
{
    "kprobe:fscrypt_encrypt_block_inplace": {
        "description": "Encrypt a possibly-compressed filesystem block that is located in an arbitrary page, not necessarily in the original pagecache page. The @inode and @lblk_num must be specified, as they can't be determined from @page.",
        "proto" :"int (*fscrypt_encrypt_block_inplace)(const struct inode *inode, struct page *page, unsigned int len, unsigned int offs, u64 lblk_num, gfp_t gfp_flags)",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": ">=0 && % FSCRYPT_CONTENTS_ALIGNMENT == 0",
            "offs": ">=0",
            "lblk_num": ">=0",
            "gfp_flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio. The specified block(s) are decrypted in-place within the pagecache folio, which must still be locked and not uptodate. This is for use by the filesystem's ->readahead() method.",
        "proto" :"int (*fscrypt_decrypt_pagecache_blocks)(struct folio *folio, size_t len, size_t offs)",
        "pre": {
            "folio": "!=null",
            "len": ">0 && len % filesystem_block_size == 0",
            "offs": ">=0 && offs % filesystem_block_size == 0"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_pagecache_blocks": {
        "description": "Decrypt filesystem blocks in a pagecache folio. The specified block(s) are decrypted in-place within the pagecache folio, which must still be locked and not uptodate. This is for use by the filesystem's ->readahead() method.",
        "proto" :"int (*fscrypt_decrypt_pagecache_blocks)(struct folio *folio, size_t len, size_t offs)",
        "pre": {
            "folio": "!=null",
            "len": ">0 && len % filesystem_block_size == 0",
            "offs": ">=0 && offs % filesystem_block_size == 0"
        },
    }
},
{
    "kretprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a possibly-compressed filesystem block that is located in an arbitrary page, not necessarily in the original pagecache page. The @inode and @lblk_num must be specified, as they can't be determined from @page.",
        "proto" :"int fscrypt_decrypt_block_inplace(const struct inode *inode, struct page *page, unsigned int len, unsigned int offs, u64 lblk_num)",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": ">= FSCRYPT_CONTENTS_ALIGNMENT && len % FSCRYPT_CONTENTS_ALIGNMENT == 0",
            "offs": ">= 0",
            "lblk_num": ">= 0"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:fscrypt_decrypt_block_inplace": {
        "description": "Decrypt a filesystem block in-place. The inode and lblk_num must be specified, as they can't be determined from page.",
        "proto" :"int (*fscrypt_decrypt_block_inplace)(const struct inode *inode, struct page *page, unsigned int len, unsigned int offs, u64 lblk_num)",
        "pre": {
            "inode": "!=null",
            "page": "!=null",
            "len": ">=0 && % FSCRYPT_CONTENTS_ALIGNMENT == 0",
            "offs": ">=0",
            "lblk_num": ">=0",
        },
    }
},
{
    "kretprobe:fuse_fill_super_submount": {
        "description": "Initialize superblock, making @mp_fi its root",
        "proto" :"static long (*fuse_fill_super_submount)(void *sb, void *mp_fi)",
        "pre": {
            "sb": "!=null",
            "mp_fi": "!=null"
        },
    }
},
{
    "kprobe:fuse_fill_super_submount": {
        "description": "Initialize superblock, making @mp_fi its root",
        "proto" :"static long (*fuse_fill_super_submount)(void *sb, const void *mp_fi)",
        "pre": {
            "sb": "!=null",
            "mp_fi": "!=null"
        },
    }
},
{
    "kretprobe:o2hb_arm_timeout": {
        "description": "Fence if the number of failed regions >= half the number of quorum regions",
        "proto" :"static void (*o2hb_arm_timeout)(struct o2hb_region *reg)",
        "pre": {
            "reg": "!=null",
        },
        "post": {
            "failed": "<= quorum/2",
        }
    }
},

{
    "kretprobe:configfs_depend_prep": {
        "description": "This function does a depth-first search of the dentry hierarchy looking for an object. It ignores items tagged as dropping and items in the middle of attachment. If the target is not found, -ENOENT is returned. This function is recursive and requires all config_items to be unique.",
        "proto" :"/* function prototype here */",
        "pre": {
            /* preconditions here */
        },
    }
},
{
    "kprobe:configfs_depend_prep": {
        "description": "This function does a depth-first search of the dentry hierarchy looking for our object. It ignores items tagged as dropping since they are virtually dead, as well as items in the middle of attachment since they virtually do not exist yet. This completes the locking out of racing mkdir() and rmdir().",
        "proto" :"/* * configfs_depend_prep() * * Only subdirectories count here.  Files (CONFIGFS_NOT_PINNED) are * attributes.  This is similar but not the same to configfs_detach_prep(). * Note that configfs_detach_prep() expects the parent to be locked when it * is called, but we lock the parent *inside* configfs_depend_prep().  We * do that so we can unlock it if we find nothing. * * Here we do a depth-first search of the dentry hierarchy looking for * our object. * We deliberately ignore items tagged as dropping since they are virtually * dead, as well as items in the middle of attachment since they virtually * do not exist yet. This completes the locking out of racing mkdir() and * rmdir(). * Note: subdirectories in the middle of attachment start with s_type = * CONFIGFS_DIR|CONFIGFS_USET_CREATING set by create_dir().  When * CONFIGFS_USET_CREATING is set, we ignore the item.  The actual set of * s_type is in configfs_new_dirent(), which has configfs_dirent_lock. * * If the target is not found, -ENOENT is bubbled up. * * This adds a requirement that all config_items be unique! * * This is recursive.  There isn't * much on the stack, though, so folks that need this function - be careful * about your stack!  Patches will be accepted to make it iterative. */",
        "pre": {
            // Fill in the preconditions here
        },
    }
},
{
    "kretprobe:configfs_depend_item_unlocked": {
        "description": "Disallow this function for configfs root",
        "proto": "int configfs_depend_item_unlocked(struct configfs_subsystem *caller_subsys, struct config_item *target)",
        "pre": {
            "caller_subsys": "!=null",
            "target": "!=null"
        },
        "post": {
            "return": "in [-ENOENT, -EINVAL]"
        }
    }
},
{
    "configfs_depend_item_unlocked": {
        "description": "Disallow this function for configfs root",
        "proto" :"configfs_depend_item_unlocked(struct configfs_subsystem  caller_subsys,  struct config_item  target)",
        "pre": {
            "caller_subsys": "!=null",
            "target": "!=null"
        },
    }
},
{
    "kretprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups, links groups, creates dentry for the child and attaches it to the parent dentry.",
        "proto" :"int configfs_register_group(struct config_group *parent_group, struct config_group *group)",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        },
        "post": {
            "return": "in [0, negative errno code]"
        }
    }
},
{
    "kprobe:configfs_register_group": {
        "description": "Creates a parent-child relation between two groups, links groups, creates dentry for the child and attaches it to the parent dentry.",
        "proto" :"int (*configfs_register_group)(struct config_group *parent_group, struct config_group *group)",
        "pre": {
            "parent_group": "!=null",
            "group": "!=null"
        },
        "post": {
            "return": "in [0, negative errno code]"
        }
    }
},
{
    "kretprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent group. Undoes configfs_register_group()",
        "proto" :"void (*configfs_unregister_group)(struct config_group *group)",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_group": {
        "description": "Unregisters a child group from its parent. Undoes configfs_register_group()",
        "proto" :"void (*configfs_unregister_group)(struct config_group *group)",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kretprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group with its parent. We need kzalloc'ed memory because child's default_group is initially empty.",
        "proto" :"struct config_group *(*configfs_register_default_group)(struct config_group *parent_group, const char *name, const struct config_item_type *item_type)",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        },
        "post": {
            "return": "!=ERR_PTR"
        }
    }
},
{
    "kprobe:configfs_register_default_group": {
        "description": "Allocates and registers a child group. The child's default_group is initially empty. Returns allocated config group or ERR_PTR() on error.",
        "proto" :"struct config_group *(*configfs_register_default_group)(struct config_group *parent_group, const char *name, const struct config_item_type *item_type)",
        "pre": {
            "parent_group": "!=null",
            "name": "!=null",
            "item_type": "!=null"
        }
    }
},
{
    "kretprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group @group:the group to act on",
        "proto" :"void (*configfs_unregister_default_group)(struct config_group *group)",
        "pre": {
            "group": "!=null"
        }
    }
},
{
    "kprobe:configfs_unregister_default_group": {
        "description": "Unregisters and frees a child group",
        "proto" :"void (*configfs_unregister_default_group)(struct config_group *group)",
        "pre": {
            "group": "!=null",
        },
    }
},
{
    "kretprobe:config_item_set_name": {
        "description": "Set the name of an item @item:item. @fmt: The vsnprintf()'s format string. If strlen(name) >= CONFIGFS_ITEM_NAME_LEN, then use a dynamically allocated string that @item->ci_name points to. Otherwise, use the static @item->ci_namebuf array.",
        "proto" :"int (*config_item_set_name)(struct config_item *item, const char *fmt, ...)",
        "pre": {
            "item": "!=null",
            "fmt": "!=null",
            "item->ci_name": "!=null",
            "item->ci_namebuf": "!=null",
            "strlen(name)": "< CONFIGFS_ITEM_NAME_LEN"
        },
    }
},
{
    "kprobe:config_item_set_name": {
        "description": "Set the name of an item @item:item. @fmt: The vsnprintf()'s format string. If strlen(name) >= CONFIGFS_ITEM_NAME_LEN, then use a dynamically allocated string that @item->ci_name points to. Otherwise, use the static @item->ci_namebuf array.",
        "proto" :"int (*config_item_set_name)(struct config_item *item, const char *fmt, ...)",
        "pre": {
            "item": "!=null",
            "fmt": "!=null",
            "item->ci_name": "!=null",
            "item->ci_namebuf": "!=null",
            "strlen(name)": "< CONFIGFS_ITEM_NAME_LEN"
        },
    }
},
{
    "kretprobe:config_item_put": {
        "description": "Decrement the refcount for item. If refcount is 0, call config_item_cleanup().",
        "proto": "void config_item_put(struct config_item *item)",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kprobe:config_item_put": {
        "description": "Decrement the refcount for item. If refcount is 0, call config_item_cleanup().",
        "proto" :"void (*config_item_put)(struct config_item *item)",
        "pre": {
            "item": "!=null"
        }
    }
},
{
    "kretprobe:config_group_find_item": {
        "description": "Iterate over @group->cg_list, looking for a matching config_item. If matching item is found take a reference and return the item. Caller must have locked group via @group->cg_subsys->su_mtx.",
        "proto" :"struct config_item *(*config_group_find_item)(struct config_group *group, const char *name)",
        "pre": {
            "group": "!=null",
            "name": "!=null && is_string(name)"
        },
    }
},
{
    "kprobe:config_group_find_item": {
        "description": "Iterate over @group->cg_list, looking for a matching config_item. If matching item is found take a reference and return the item. Caller must have locked group via @group->cg_subsys->su_mtx.",
        "proto" :"struct config_item *(*config_group_find_item)(struct config_group *group, const char *name)",
        "pre": {
            "group": "!=null",
            "name": "!=null && is_string(name)",
            "group->cg_subsys->su_mtx": "is_locked"
        },
    }
},
{
    "kretprobe:netfs_readahead": {
        "description": "Fulfil a readahead request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. If necessary, the readahead window can be expanded in either direction to a more convenient alignment for RPC efficiency or to make storage in the cache feasible. The calling netfs must initialise a netfs context contiguous to the vfs inode before calling this. This is usable whether or not caching is enabled.",
        "proto" :"void (*netfs_readahead)(struct readahead_control *ractl)",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kprobe:netfs_readahead": {
        "description": "Helper to manage a read request. Fulfil a readahead request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. If necessary, the readahead window can be expanded in either direction to a more convenient alighment for RPC efficiency or to make storage in the cache feasible. The calling netfs must initialise a netfs context contiguous to the vfs inode before calling this. This is usable whether or not caching is enabled.",
        "proto" :"void netfs_readahead(struct readahead_control *ractl)",
        "pre": {
            "ractl": "!=null"
        }
    }
},
{
    "kretprobe:netfs_read_folio": {
        "description": "Fulfil a read_folio request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. The calling netfs must initialise a netfs context contiguous to the vfs inode before calling this. This is usable whether or not caching is enabled.",
        "proto" :"int (*netfs_read_folio)(struct file *file, struct folio *folio)",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:netfs_read_folio": {
        "description": "Helper to manage a read_folio request. Fulfil a read_folio request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. The calling netfs must initialise a netfs context contiguous to the vfs inode before calling this. This is usable whether or not caching is enabled.",
        "proto" :"int (*netfs_read_folio)(struct file *file, struct folio *folio)",
        "pre": {
            "file": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:netfs_write_begin": {
        "description": "Pre-read data for a write-begin request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. If necessary, the readahead window can be expanded in either direction to a more convenient alignment for RPC efficiency or to make storage in the cache feasible.",
        "proto" :"int (*netfs_write_begin)(struct netfs_inode *ctx, struct file *file, struct address_space *mapping, loff_t pos, unsigned int len, struct folio **_folio, void **_fsdata)",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},
{
    "kprobe:netfs_write_begin": {
        "description": "Pre-read data for a write-begin request by drawing data from the cache if possible, or the netfs if not. Space beyond the EOF is zero-filled. Multiple IO requests from different sources will get munged together. If necessary, the readahead window can be expanded in either direction to a more convenient alignment for RPC efficiency or to make storage in the cache feasible.",
        "proto" :"int (*netfs_write_begin)(struct netfs_inode *ctx, struct file *file, struct address_space *mapping, loff_t pos, unsigned int len, struct folio **_folio, void **_fsdata)",
        "pre": {
            "ctx": "!=null",
            "file": "!=null",
            "mapping": "!=null",
            "pos": ">=0",
            "len": ">=0",
            "_folio": "!=null",
            "_fsdata": "!=null"
        }
    }
},
{
    "kretprobe:netfs_read_from_cache": {
        "description": "Issue a read against the cache. Eats the caller's ref on subreq.",
        "proto" :"static void netfs_read_from_cache(struct netfs_io_request *rreq, struct netfs_io_subrequest *subreq, enum netfs_read_from_hole read_hole)",
        "pre": {
            "rreq": "!=null",
            "subreq": "!=null",
            "read_hole": "in [NETFS_READ_FROM_HOLE_1, NETFS_READ_FROM_HOLE_2, NETFS_READ_FROM_HOLE_3]" // replace with actual enum values
        }
    }
},
{
    "kprobe:netfs_read_from_cache": {
        "description": "Issue a read against the cache. Eats the caller's ref on subreq.",
        "proto" :"static void (*netfs_read_from_cache)(struct netfs_io_request *rreq, struct netfs_io_subrequest *subreq, enum netfs_read_from_hole read_hole)",
        "pre": {
            "rreq": "!=null",
            "subreq": "!=null",
            "read_hole": "in [NETFS_READ_FROM_HOLE_YES, NETFS_READ_FROM_HOLE_NO]",
        },
    }
},
{
    "kretprobe:jbd2_journal_start": {
        "description": "Return a pointer to a newly allocated handle, or an ERR_PTR() value on failure. jbd2_journal_start_reserved() before it can be used.",
        "proto" :"handle_t *(*jbd2_journal_start)(journal_t *journal, int nblocks)",
        "pre": {
            "journal": "!=null",
            "nblocks": ">=0"
        }
    }
},
{
    "kprobe:jbd2_journal_start": {
        "description": "Return a pointer to a newly allocated handle, or an ERR_PTR() value on failure. jbd2_journal_start_reserved() should be called before it can be used.",
        "proto" :"handle_t *(*jbd2_journal_start)(journal_t *journal, int nblocks)",
        "pre": {
            "journal": "!=null",
            "nblocks": ">0",
        },
    }
},
{
    "kretprobe:jbd2_journal_free_reserved": {
        "description": "Get j_state_lock to pin running transaction if it exists",
        "proto" :"void (*jbd2_journal_free_reserved)(handle_t *handle)",
        "pre": {
            "handle": "!=null",
            "handle->h_journal": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_free_reserved": {
        "description": "Get j_state_lock to pin running transaction if it exists",
        "proto" :"void jbd2_journal_free_reserved(handle_t *handle)",
        "pre": {
            "handle": "!=null",
        },
    }
},
{
    "kretprobe:jbd2__journal_restart": {
        "description": "jbd2_journal_restart will commit the handle's transaction so far and reattach the handle to a new transaction capable of guaranteeing the requested number of credits. We preserve reserved handle if there's any attached to the passed in handle.",
        "proto" :"int jbd2__journal_restart(handle_t *handle, int nblocks, int revoke_records, gfp_t gfp_mask)",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace with actual gfp_t flags
        },
    }
},
{
    "kprobe:jbd2__journal_restart": {
        "description": "jbd2_journal_restart will commit the handle's transaction so far and reattach the handle to a new transaction capable of guaranteeing the requested number of credits. We preserve reserved handle if there's any attached to the passed in handle.",
        "proto" :"int (*jbd2__journal_restart)(handle_t *handle, int nblocks, int revoke_records, gfp_t gfp_mask)",
        "pre": {
            "handle": "!=null",
            "nblocks": ">=0",
            "revoke_records": ">=0",
            "gfp_mask": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]"
        },
    }
},
{
    "kretprobe:jbd2_trans_will_send_data_barrier": {
        "description": "Check if the transaction is already committed and if the journal flag is set to JBD2_BARRIER.",
        "proto" :"int (*jbd2_trans_will_send_data_barrier)(journal_t *journal, tid_t tid)",
        "pre": {
            "journal": "!=null",
            "tid": ">= journal->j_commit_sequence"
        },
        "post": {
            "ret": "in [0, 1]"
        }
    }
},

{
    "kretprobe:jbd2_fc_begin_commit": {
        "description": "Fast commits only allowed if at least one full commit has been processed.",
        "proto" :"int jbd2_fc_begin_commit(journal_t *journal, tid_t tid)",
        "pre": {
            "journal": "!=null",
            "tid": "is a valid transaction ID",
        },
        "post": {
            "return": "in [-EIO, -EINVAL, 0]"
        }
    }
},
{
    "kprobe:jbd2_fc_begin_commit": {
        "description": "Fast commits only allowed if at least one full commit has been processed.",
        "proto" :"static long (*jbd2_fc_begin_commit)(journal_t *journal, tid_t tid)",
        "pre": {
            "journal": "!=null",
            "journal->j_stats.ts_tid": ">0",
            "journal->j_commit_sequence": ">=tid",
            "tid": ">0"
        },
    }
},
{
    "kretprobe:jbd2_transaction_committed": {
        "description": "Return 1 when transaction with given tid has already committed.",
        "proto" :"int jbd2_transaction_committed(journal_t *journal, tid_t tid)",
        "pre": {
            "journal": "!=null",
            "tid": ">=0"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:jbd2_transaction_committed": {
        "description": "Return 1 when transaction with given tid has already committed.",
        "proto" :"int (*jbd2_transaction_committed)(journal_t *journal, tid_t tid)",
        "pre": {
            "journal": "!=null",
            "tid": ">=0",
        },
    }
},
{
    "kretprobe:jbd2_fc_wait_bufs": {
        "description": "Wait in reverse order to minimize chances of us being woken up before all IOs have completed",
        "proto" :"static void (*jbd2_fc_wait_bufs)(journal_t *journal, int num_blks)",
        "pre": {
            "journal": "!=null",
            "num_blks": ">=0"
        }
    }
},
{
    "kprobe:jbd2_fc_wait_bufs": {
        "description": "Wait in reverse order to minimize chances of us being woken up before all IOs have completed.",
        "proto" :"void jbd2_fc_wait_bufs(journal_t *journal, int num_blks)",
        "pre": {
            "journal": "!=null",
            "num_blks": ">=0",
        },
    }
},
{
    "kretprobe:jbd2_fc_release_bufs": {
        "description": "Can release remaining buffer head.",
        "proto" :"static long (*jbd2_fc_release_bufs)(void *bh)",
        "pre": {
            "bh": "!=null && !buffer_uptodate(bh)"
        }
    }
},
{
    "kprobe:jbd2_fc_release_bufs": {
        "description": "jbd2_fc_release_bufs can release remaining buffer head.",
        "proto" :"static int (*jbd2_fc_release_bufs)(struct buffer_head *bh)",
        "pre": {
            "bh": "!=null",
        },
    }
},
{
    "kretprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal. Write updated superblock to disk waiting for IO to complete.",
        "proto" :"static void (*jbd2_journal_update_sb_errno)(journal_t *journal)",
        "pre": {
            "journal": "!=null"
        }
    }
},
{
    "kprobe:jbd2_journal_update_sb_errno": {
        "description": "Update error in the journal. Write updated superblock to disk waiting for IO to complete.",
        "proto" :"static void (*jbd2_journal_update_sb_errno)(journal_t *journal)",
        "pre": {
            "journal": "!=null",
        },
    }
},
{
    "kretprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock.",
        "proto" :"void (*jbd2_journal_clear_features)(journal_t *journal, unsigned long compat, unsigned long ro, unsigned long incompat)",
        "pre": {
            "journal": "!=null",
            "compat": "is bitmask",
            "ro": "is bitmask",
            "incompat": "is bitmask"
        }
    }
},
{
    "kprobe:jbd2_journal_clear_features": {
        "description": "Clear a given journal feature in the superblock. Journal to act on. Bitmask of compatible features. Bitmask of features that force read-only mount. Bitmask of incompatible features. Clear a given journal feature as present on the superblock.",
        "proto" :"void (*jbd2_journal_clear_features)(journal_t *journal, unsigned long compat, unsigned long ro, unsigned long incompat)",
        "pre": {
            "journal": "!=null",
            "compat": "is bitmask",
            "ro": "is bitmask",
            "incompat": "is bitmask"
        }
    }
},


{
    "kretprobe:proc_create": {
        "description": "Create a new proc entry.",
        "proto" :"struct proc_dir_entry *proc_create(struct proc_dir_entry *parent, const char *name, umode_t mode, nlink_t nlink)",
        "pre": {
            "name": "!=null && length < 256 && !='.' && !='..'",
            "parent": "!=&proc_root && name_to_int(&qstr) != ~0U && !is_empty_pde(parent)",
            "ent": "!=null",
            "ent->name": "!=null"
        },
    }
},
{
    "kprobe:proc_create": {
        "description": "Create a new proc directory entry.",
        "proto" :"struct proc_dir_entry *(*proc_create)(struct proc_dir_entry *parent, const char *name, umode_t mode, nlink_t nlink)",
        "pre": {
            "parent": "!=null",
            "name": "!=null && strlen(name) > 0 && strlen(name) < 256 && name != '.' && name != '..' && parent != &proc_root && name_to_int(name) != ~0U && !is_empty_pde(parent)",
            "mode": "any",
            "nlink": "any"
        },
    }
},
{
    "kretprobe:__xlate_proc_name": {
        "description": "This function parses a name such as 'ttydriverserial', and returns the struct proc_dir_entry for 'procttydriver', and returns 'serial' in residual.",
        "proto" :"static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret, const char **residual)",
        "pre": {
            "name": "!=null",
            "ret": "can be null",
            "residual": "can be null"
        },
    }
},
{
    "__xlate_proc_name": {
        "description": "This function parses a name such as 'ttydriverserial', and returns the struct proc_dir_entry for 'procttydriver', and returns 'serial' in residual.",
        "proto" :"static int __xlate_proc_name(const char *name, struct proc_dir_entry **ret, const char **residual)",
        "pre": {
            "name": "!=null",
            "ret": "!=null",
            "residual": "!=null"
        },
    }
},
{
    "kretprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point. Used to create a permanently empty directory to serve as mount point. There are some subtle but important permission checks this allows in the case of unprivileged mounts.",
        "proto" :"struct ctl_table_header *(*register_sysctl_mount_point)(const char *path)",
        "pre": {
            "path": "!=null"
        }
    }
},
{
    "kprobe:register_sysctl_mount_point": {
        "description": "Registers a sysctl mount point. Used to create a permanently empty directory to serve as mount point. There are some subtle but important permission checks this allows in the case of unprivileged mounts.",
        "proto" :"struct ctl_table_header *(*register_sysctl_mount_point)(const char *path)",
        "pre": {
            "path": "!=null",
        },
    }
},
{
    "kretprobe:register_sysctl": {
        "description": "Register a sysctl table. @table should be a filled in ctl_table array. A completely 0 filled entry terminates the table. See __register_sysctl_table for more details.",
        "proto" :"struct ctl_table_header *(*register_sysctl)(const char *path, struct ctl_table *table)",
        "pre": {
            "path": "!=null",
            "table": "!=null"
        }
    }
},
{
    "kprobe:register_sysctl": {
        "description": "Register a sysctl table. @table should be a filled in ctl_table array. A completely 0 filled entry terminates the table. See __register_sysctl_table for more details.",
        "proto" :"struct ctl_table_header *(*register_sysctl)(const char *path, struct ctl_table *table)",
        "pre": {
            "path": "!=null",
            "table": "!=null"
        }
    }
},
{
    "kretprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore. Allocate a buffer and invoke the calling driver's dump collect routine. Write ELF note at the beginning of the buffer to indicate vmcore device dump and add the dump to global list.",
        "proto" :"int (*vmcore_add_device_dump)(struct vmcoredd_data *data)",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kprobe:vmcore_add_device_dump": {
        "description": "Add a buffer containing device dump to vmcore. Allocate a buffer and invoke the calling driver's dump collect routine. Write ELF note at the beginning of the buffer to indicate vmcore device dump and add the dump to global list.",
        "proto" :"int (*vmcore_add_device_dump)(struct vmcoredd_data *data)",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kretprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem. @name: a pointer to a string containing the name of the file to create. @parent: a pointer to the parent dentry for this file. This should be a directory dentry if set. If this parameter is NULL, then the file will be created in the root of the debugfs filesystem. @f: function to be called when pathname resolution steps on that one. @data: opaque argument to pass to f(). @f should return what ->d_automount() would.",
        "proto" :"struct dentry *(*debugfs_create_automount)(const char *name, struct dentry *parent, debugfs_automount_t f, void *data)",
        "pre": {
            "name": "!=null",
            "parent": "!=null || ==null",
            "f": "!=null",
            "data": "any"
        },
    }
},
{
    "kprobe:debugfs_create_automount": {
        "description": "Create automount point in the debugfs filesystem. @name: a pointer to a string containing the name of the file to create. @parent: a pointer to the parent dentry for this file. This should be a directory dentry if set. If this parameter is NULL, then the file will be created in the root of the debugfs filesystem. @f: function to be called when pathname resolution steps on that one. @data: opaque argument to pass to f(). @f should return what ->d_automount() would.",
        "proto" :"struct dentry *(*debugfs_create_automount)(const char *name, struct dentry *parent, debugfs_automount_t f, void *data)",
        "pre": {
            "name": "!=null",
            "parent": "can be null",
            "f": "!=null",
            "data": "can be any value"
        }
    }
},
{
    "kretprobe:utf16s_to_utf8s": {
        "description": "Converts a string of UTF-16 characters to a string of UTF-8 characters.",
        "proto" :"static int (*utf16s_to_utf8s)(const wchar_t *pwcs, int inlen, enum utf16_endian endian, u8 *s, int maxout)",
        "pre": {
            "pwcs": "!=null",
            "inlen": ">0",
            "endian": "in [UTF16_LITTLE_ENDIAN, UTF16_BIG_ENDIAN]",
            "s": "!=null",
            "maxout": ">0"
        }
    }
},
{
    "kprobe:utf16s_to_utf8s": {
        "description": "Converts a string of UTF-16 characters to a string of UTF-8 characters.",
        "proto" :"static int (*utf16s_to_utf8s)(const wchar_t *pwcs, int inlen, enum utf16_endian endian, u8 *s, int maxout)",
        "pre": {
            "pwcs": "!=null",
            "inlen": ">0",
            "endian": "in [UTF16_LITTLE_ENDIAN, UTF16_BIG_ENDIAN]",
            "s": "!=null",
            "maxout": ">0"
        },
    }
},


{
    "kretprobe:qid_eq": {
        "description": "Test to see if two kquid values are the same. Return true if the two qid values are equal and false otherwise.",
        "proto" :"bool (*qid_eq)(struct kqid left, struct kqid right)",
        "pre": {
            "left": "!=null",
            "right": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:qid_eq": {
        "description": "Test to see if two kquid values are the same. Return true if the two qid values are equal and false otherwise.",
        "proto" :"bool (*qid_eq)(struct kqid left, struct kqid right)",
        "pre": {
            "left": "is a valid struct kqid",
            "right": "is a valid struct kqid"
        }
    }
},
{
    "kretprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another. Return true if left is less than right and false otherwise.",
        "proto" :"bool (*qid_lt)(struct kqid left, struct kqid right)",
        "pre": {
            "left": "is a valid struct kqid",
            "right": "is a valid struct kqid"
        },
        "post": {
            "return": "is a boolean"
        }
    }
},
{
    "kprobe:qid_lt": {
        "description": "Test to see if one qid value is less than another. Return true if left is less than right and false otherwise.",
        "proto" :"bool (*qid_lt)(struct kqid left, struct kqid right)",
        "pre": {
            "left": "is a valid kqid",
            "right": "is a valid kqid"
        },
    }
},
{
    "kretprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair. Map @kqid into the user-namespace specified by @targ and return the resulting qid. There is always a mapping into the initial user_namespace. If @kqid has no mapping in @targ (qid_t)-1 is returned.",
        "proto" :"qid_t (*from_kqid)(struct user_namespace *targ, struct kqid kqid)",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
        "post": {
            "return": "in [qid_t, -1]"
        }
    }
},
{
    "kprobe:from_kqid": {
        "description": "Create a qid from a kqid user-namespace pair. Map @kqid into the user-namespace specified by @targ and return the resulting qid. There is always a mapping into the initial user_namespace. If @kqid has no mapping in @targ (qid_t)-1 is returned.",
        "proto" :"qid_t (*from_kqid)(struct user_namespace *targ, struct kqid kqid)",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
    }
},
{
    "kretprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair. Map @kqid into the user-namespace specified by @targ and return the resulting qid. There is always a mapping into the initial user_namespace. Unlike from_kqid, from_kqid_munged never fails and always returns a valid projid. This makes from_kqid_munged appropriate for use in places where failing to provide a qid_t is not a good option. If @kqid has no mapping in @targ the kqid.type specific overflow identifier is returned.",
        "proto" :"qid_t (*from_kqid_munged)(struct user_namespace *targ, struct kqid kqid)",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
    }
},
{
    "kprobe:from_kqid_munged": {
        "description": "Create a qid from a kqid user-namespace pair. Map @kqid into the user-namespace specified by @targ and return the resulting qid. There is always a mapping into the initial user_namespace. Unlike from_kqid from_kqid_munged never fails and always returns a valid projid. This makes from_kqid_munged appropriate for use in places where failing to provide a qid_t is not a good option. If @kqid has no mapping in @targ the kqid.type specific overflow identifier is returned.",
        "proto" :"qid_t (*from_kqid_munged)(struct user_namespace *targ, struct kqid kqid)",
        "pre": {
            "targ": "!=null",
            "kqid": "!=null"
        },
    }
},
{
    "kretprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid. @qid: The kernel internal quota identifier to test.",
        "proto": "bool (*qid_valid)(struct kqid qid)",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kprobe:qid_valid": {
        "description": "Report if a valid value is stored in a kqid. @qid: The kernel internal quota identifier to test.",
        "proto" :"bool (*qid_valid)(struct kqid qid)",
        "pre": {
            "qid": "!=null"
        }
    }
},
{
    "kretprobe:qtree_write_dquot": {
        "description": "The function description goes here.",
        "proto" :"static long (*qtree_write_dquot)(struct qtree_mem_dqinfo *info, struct dquot *dquot)",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "dquot->dq_off": "==0"
        },
    }
},
{
    "kprobe:qtree_write_dquot": {
        "description": "dq_off is guarded by dqio_sem",
        "proto" :"qtree_write_dquot(struct qtree_mem_dqinfo  info, struct dquot  dquot)",
        "pre": {
            "info": "!=null",
            "dquot": "!=null",
            "dquot->dq_off": "!=0"
        },
    }
},
{
    "kretprobe:qtree_delete_dquot": {
        "description": "Delete the dquot from the qtree. If the dquot is not allocated, it does nothing.",
        "proto" :"static long (*qtree_delete_dquot)(struct qtree_mem_dqinfo *info, struct dquot *dquot)",
        "pre": {
            "info": "!=null",
            "dquot": "!=null && dquot->dq_off != 0"
        },
    }
},
{
    "kprobe:qtree_delete_dquot": {
        "description": "Delete a dquot from the qtree. If the dquot is not allocated, do nothing.",
        "proto" :"static void (*qtree_delete_dquot)(struct qtree_mem_dqinfo *info, struct dquot *dquot)",
        "pre": {
            "info": "!=null",
            "dquot": "!=null && dquot->dq_off != 0"
        }
    }
},


{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:bpf_spin_lock": {
        "description": "Locks the spinlock associated with the provided key.",
        "proto" :"static long (*bpf_spin_lock)(void *lock)",
        "pre": {
            "lock": "!=null",
        },
    }
},
{
    "kretprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "variable1": "Your condition here",
            "variable2": "Your condition here",
            "variable3": "Your condition here",
            "variable4": "Your condition here",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "variable1": "Your precondition here",
            "variable2": "Your precondition here",
            "variable3": "Your precondition here",
            "variable4": "Your precondition here",
        },
    }
},
{
    "kretprobe:dquot_mark_dquot_dirty": {
        "description": "If quota is dirty already, we don't have to acquire dq_list_lock",
        "proto" :"dquot_mark_dquot_dirty(struct dquot  dquot)",
        "pre": {
            "dquot": "!=null",
            "DQ_ACTIVE_B": "in [0, 1]",
            "dq_flags": "!=null",
            "DQ_MOD_B": "in [0, 1]",
            "dq_list_lock": "!=null",
            "DQUOT_NOLIST_DIRTY": "in [0, 1]",
            "dq_sb": "!=null"
        },
    }
},
{
    "kprobe:dquot_mark_dquot_dirty": {
        "description": "If quota is dirty already, we don't have to acquire dq_list_lock",
        "proto" :"dquot_mark_dquot_dirty(struct dquot  dquot)",
        "pre": {
            "dquot": "!=null",
            "DQ_ACTIVE_B": "in bit array of dq_flags",
            "DQ_MOD_B": "in bit array of dq_flags",
            "dq_list_lock": "!=null",
            "dq_sb": "!=null",
            "DQUOT_NOLIST_DIRTY": "in flags of sb_dqopt(dquot->dq_sb)"
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[constraints]",
            "[param2]": "[constraints]",
            "...": "..."
        },
    }
},
{
    "kprobe:smp_mb__before_atomic": {
        "description": "Memory barrier before atomic operation.",
        "proto" :"void (*smp_mb__before_atomic)(void)",
        "pre": {},
    },
    "kprobe:set_bit": {
        "description": "Set a bit in memory.",
        "proto" :"void (*set_bit)(int nr, volatile unsigned long *addr)",
        "pre": {
            "nr": "in [0, sizeof(unsigned long)*8 - 1]",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:dquot_commit": {
        "description": "Inactive dquot can be only if there was error during readinit => we have better not writing it",
        "proto" :"dquot_commit(struct dquot  dquot)",
        "pre": {
            "dquot": "!=null",
        },
    }
},
{
    "kprobe:dquot_commit": {
        "description": "Inactive dquot can be only if there was error during readinit => we have better not writing it",
        "proto" :"dquot_commit(struct dquot  dquot){int ret = 0;unsigned int memalloc;struct quota_info  dqopt = sb_dqopt(dquot->dq_sb);mutex_lock(&dquot->dq_lock);memalloc = memalloc_nofs_save();if (!clear_dquot_dirty(dquot))goto out_lock;}",
        "pre": {
            "dquot": "!=null",
            "ret": "==0",
            "memalloc": "is unsigned int",
            "dqopt": "!=null",
            "dquot->dq_lock": "is locked",
            "clear_dquot_dirty(dquot)": "is false"
        },
    }
},
{
    "kretprobe:dqput": {
        "description": "The allocation and release operations are serialized by the dq_lock and by checking the use count in dquot_release(). Lock ordering (including related VFS locks) is the following: s_umount > i_mutex > journal_lock > dquot->dq_lock > dqio_sem",
        "proto" :"void dqput(struct dquot *dquot)",
        "pre": {
            "dquot": "!=null"
        }
    }
},
{
    "kprobe:dqput": {
        "description": "The allocation and release operations are serialized by the dq_lock and by checking the use count in dquot_release(). Lock ordering (including related VFS locks) is the following: s_umount > i_mutex > journal_lock > dquot->dq_lock > dqio_sem",
        "proto" :"void dqput(struct dquot *dquot)",
        "pre": {
            "dquot": "!=null",
        },
    }
},
{
    "kretprobe:dquot_scan_active": {
        "description": "Scan active dquots and increase use count if conditions are met.",
        "proto" :"int dquot_scan_active(struct super_block *sb, int (*fn)(struct dquot *dquot, unsigned long priv), unsigned long priv)",
        "pre": {
            "sb": "!=null",
            "fn": "!=null",
            "priv": "is a valid unsigned long value"
        },
    }
},



{
    "kretprobe:dquot_quota_sync": {
        "description": "The description of the function goes here.",
        "proto" :"dquot_quota_sync(struct super_block *sb, int type)",
        "pre": {
            "sb": "!=null",
            "type": "is an integer"
        }
    }
},
{
    "kprobe:dquot_quota_sync": {
        "description": "This function is not very clever (and fast) but currently I don't know about any other simple way of getting quota data to disk and we must get them there for userspace to be visible...",
        "proto" :"dquot_quota_sync(struct super_block  sb, int type)",
        "pre": {
            "sb": "!=null",
            "type": "is integer",
        },
    }
},


{
    "kretprobe:insert_dquot_hash": {
        "description": "This function is not well-documented in the provided helper doc. It seems to be related to inserting a 'dquot' into a hash.",
        "proto" :"static inline void insert_dquot_hash(struct dquot *dquot)",
        "pre": {
            "dquot": "!=null"
        }
    }
},


{
    "kprobe:dquot_drop": {
        "description": "Drops the disk quota for the given inode.",
        "proto" :"void dquot_drop(struct inode inode)",
        "pre": {
            "inode": "!=null",
        },
    },
    "kprobe:i_dquot": {
        "description": "Gets the disk quota for the given inode.",
        "proto" :"struct dquot* i_dquot(struct inode inode)",
        "pre": {
            "inode": "!=null",
        },
    },
    "kprobe:for_loop": {
        "description": "Iterates over the disk quotas.",
        "proto" :"for (cnt = 0; cnt < MAXQUOTAS; cnt++)",
        "pre": {
            "cnt": ">=0",
            "MAXQUOTAS": ">0",
        },
    }
},


{
    "kretprobe:dquot_alloc_inode": {
        "description": "Your function description here",
        "proto" :"static long (*dquot_alloc_inode)(struct inode *inode)",
        "pre": {
            "inode": "!=null",
        },
    }
},
{
    "kprobe:dquot_alloc_inode": {
        "description": "Allocates an inode with quota management.",
        "proto" :"int dquot_alloc_inode(struct inode *inode)",
        "pre": {
            "inode": "!=null",
        },
    }
},
{
    "__dquot_transfer": {
        "description": "Transfer quotas from one inode to another.",
        "proto": "int __dquot_transfer(struct inode *inode, struct dquot *transfer_to)",
        "pre": {
            "inode": "!=null",
            "transfer_to": "!=null"
        },
        "post": {
            "return": "in [0, -EDQUOT, -ENOMEM, -EIO]"
        }
    }
},
{
    "__dquot_transfer": {
        "description": "Transfer disk quotas from one set of inodes to another.",
        "proto" :"static int (__dquot_transfer)(struct inode *inode, struct dquot *transfer_to)",
        "pre": {
            "inode": "!=null",
            "transfer_to": "!=null"
        },
        "loop": {
            "cnt": {
                "start": "0",
                "end": "MAXQUOTAS",
                "step": "1"
            }
        }
    }
},
{
    "kretprobe:dquot_disable": {
        "description": "s_umount should be held in exclusive mode",
        "proto" :"int dquot_disable(struct super_block *sb, int type, unsigned int flags)",
        "pre": {
            "sb": "!=null",
            "type": "is integer",
            "flags": "is unsigned integer",
        },
    }
},
{
    "kprobe:dquot_disable": {
        "description": "s_umount should be held in exclusive mode",
        "proto" :"static long (*dquot_disable)(struct super_block *sb, int type, unsigned int flags)",
        "pre": {
            "sb": "!=null",
            "type": "is integer",
            "flags": "is unsigned integer",
        },
    }
},
{
    "kretprobe:dquot_load_quota_sb": {
        "description": "Load quota for a super block.",
        "proto" :"static long (*dquot_load_quota_sb)(struct super_block *sb, int type, int format_id, unsigned int flags)",
        "pre": {
            "sb": "!=null",
            "type": ">=0",
            "format_id": ">=0",
            "flags": "in [FLAG1, FLAG2, FLAG3]",
        },
    }
},
{
    "kprobe:dquot_load_quota_sb": {
        "description": "Load quota for a super block. If the quota is suspended, an error is returned.",
        "proto" :"static int (*dquot_load_quota_sb)(struct super_block *sb, int type, int format_id, unsigned int flags)",
        "pre": {
            "sb": "!=null",
            "type": "in [DQUOT_USR, DQUOT_GRP, DQUOT_PRJ]",
            "format_id": "in [QFMT_VFS_OLD, QFMT_VFS_V0, QFMT_VFS_V1]",
            "flags": "in [DQUOT_SUSPENDED, DQUOT_QUOTA_SYS_FILE, DQUOT_NEGATIVE]"
        },
    }
},
{
    "kretprobe:dquot_resume": {
        "description": "s_umount should be held in exclusive mode",
        "proto" :"static int (*dquot_resume)(struct super_block *sb, int type)",
        "pre": {
            "sb": "!=null",
            "type": "in [0, MAXQUOTAS-1]"
        },
    }
},
{
    "kprobe:dquot_resume": {
        "description": "s_umount should be held in exclusive mode",
        "proto" :"dquot_resume(struct super_block *sb, int type)",
        "pre": {
            "sb": "!=null",
            "type": "in [0, MAXQUOTAS-1]",
            "sb->s_umount": "is locked exclusively"
        },
    }
},
{
    "kretprobe:dquot_quota_on": {
        "description": "Quota file not on the same filesystem?",
        "proto" :"static long (*dquot_quota_on)(struct super_block *sb, int type, int format_id, const struct path *path)",
        "pre": {
            "sb": "!=null",
            "type": "is integer",
            "format_id": "is integer",
            "path": "!=null && path->dentry != null"
        },
    }
},
{
    "kprobe:dquot_quota_on": {
        "description": "Quota file not on the same filesystem?",
        "proto" :"int (*dquot_quota_on)(struct super_block *sb, int type, int format_id, const struct path *path)",
        "pre": {
            "sb": "!=null",
            "type": "is int",
            "format_id": "is int",
            "path": "!=null && path->dentry !=null && path->dentry->d_sb == sb"
        },
    }
},
{
    "kretprobe:dquot_get_state": {
        "description": "This function seems to be related to quota management in a file system, but the exact purpose is unclear due to the incomplete function.",
        "proto" :"dquot_get_state(struct super_block  sb, struct qc_state  state)",
        "pre": {
            "sb": "!=null",
            "state": "!=null"
        },
    }
},
{
    "kprobe:dquot_get_state": {
        "description": "Function description...",
        "proto" :"dquot_get_state(struct super_block *sb, struct qc_state *state)",
        "pre": {
            "sb": "!=null",
            "state": "!=null"
        },
    }
},
{
    "kretprobe:dquot_set_dqinfo": {
        "description": "Your function description here",
        "proto" :"static long (*dquot_set_dqinfo)(struct super_block  sb, int type, struct qc_info  ii)",
        "pre": {
            "sb": "Your condition here",
            "type": "Your condition here",
            "ii": "Your condition here"
        },
    }
},
{
    "kprobe:dquot_set_dqinfo": {
        "description": "Sets quota information for a specific type on a super block. If the fieldmask includes QC_WARNS_MASK or QC_RT_SPC_TIMER, or if the super block does not have an active quota of the specified type, or if the flags include QCI_ROOT_SQUASH and the format id is not QFMT_VFS_OLD, the function returns -EINVAL or -ESRCH. Otherwise, it sets the specified timers and flags, and marks the information as dirty.",
        "proto" :"int dquot_set_dqinfo(struct super_block *sb, int type, struct qc_info *ii)",
        "pre": {
            "sb": "!=null",
            "type": "is integer",
            "ii": "!=null",
            "ii->i_fieldmask": "is integer",
            "ii->i_flags": "is integer",
            "ii->i_spc_timelimit": "is integer",
            "ii->i_ino_timelimit": "is integer"
        },
    }
},
{
    "kretprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota. This can be used by filesystems (including those which don't use dquot) to send a message to userspace relating to quota limits.",
        "proto" :"void (*quota_send_warning)(struct kqid qid, dev_t dev, const char warntype)",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kprobe:quota_send_warning": {
        "description": "Send warning to userspace about exceeded quota.",
        "proto": "void (*quota_send_warning)(struct kqid qid, dev_t dev, const char warntype)",
        "pre": {
            "qid": "!=null",
            "dev": "!=null",
            "warntype": "in [QUOTA_NL_...]"
        }
    }
},
{
    "kretprobe:crypto_kdf108_setkey": {
        "description": "Set the key for the crypto_shash kmd. SP800-108 does not support IKM.",
        "proto" :"static int (*crypto_kdf108_setkey)(struct crypto_shash *kmd, const u8 *key, size_t keylen, const u8 *ikm, size_t ikmlen)",
        "pre": {
            "kmd": "!=null",
            "key": "!=null",
            "keylen": ">0",
            "ikm": "==null",
            "ikmlen": "==0"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:crypto_kdf108_setkey": {
        "description": "Set the key for the crypto_kdf108. SP800-108 does not support IKM.",
        "proto" :"static int (*crypto_kdf108_setkey)(struct crypto_shash *kmd, const u8 *key, size_t keylen, const u8 *ikm, size_t ikmlen)",
        "pre": {
            "kmd": "!=null",
            "key": "!=null",
            "keylen": ">0",
            "ikm": "==null",
            "ikmlen": "==0",
        },
    }
},
{
    "kretprobe:ecc_is_key_valid": {
        "description": "Make sure the private key is in the range [2, n-3].",
        "proto" :"int ecc_is_key_valid(const struct ecc_curve *curve, const u64 *private_key, unsigned int ndigits)",
        "pre": {
            "curve": "!=null",
            "private_key": "!=null",
            "ndigits": "in [2, curve->n - 3]"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:ecc_is_key_valid": {
        "description": "Make sure the private key is in the range [2, n-3].",
        "proto" :"int ecc_is_key_valid(const struct ecc_curve *curve, const u64 *private_key, unsigned int ndigits)",
        "pre": {
            "curve": "!=null",
            "private_key": "!=null",
            "ndigits": "in [2, curve->n - 3]",
        },
    }
},

{
    "kprobe:ecc_gen_privkey": {
        "description": "Check that N is included in Table 1 of FIPS 186-4, section 6.1.1",
        "proto" :"ecc_gen_privkey(unsigned int curve_id, unsigned int ndigits, u64  privkey)",
        "pre": {
            "curve_id": "!=null",
            "ndigits": "<= ARRAY_SIZE(priv)",
            "privkey": "!=null",
            "nbits": ">=160",
            "nbytes": "in [ECC_MAX_DIGITS]",
            "curve": "!=null",
            "err": "!=null"
        },
    }
},
{
    "kretprobe:ecc_make_pub_key": {
        "description": "Generate a public key from a given private key, curve and number of digits.",
        "proto" :"int ecc_make_pub_key(unsigned int curve_id, unsigned int ndigits, const u64 private_key, u64 public_key)",
        "pre": {
            "curve_id": "in [list of valid curve ids]",
            "ndigits": "<= ECC_MAX_DIGITS",
            "private_key": "!=null",
            "public_key": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -ENOMEM, 0]"
        }
    },
    "kretprobe:ecc_is_pubkey_valid_full": {
        "description": "Check if the generated public key is valid.",
        "proto" :"int ecc_is_pubkey_valid_full(const struct ecc_curve *curve, struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ecc_make_pub_key": {
        "description": "Generates a public key based on the provided curve_id, ndigits, and private_key. The public_key is output.",
        "proto" :"int ecc_make_pub_key(unsigned int curve_id, unsigned int ndigits, const u64 private_key, u64 public_key)",
        "pre": {
            "curve_id": "in [valid curve ids]",
            "ndigits": "<= ECC_MAX_DIGITS",
            "private_key": "!=null",
            "public_key": "!=null"
        },
    },
    "kprobe:ecc_is_pubkey_valid_full": {
        "description": "Checks if the public key is valid based on the provided curve and pk.",
        "proto" :"int ecc_is_pubkey_valid_full(const struct ecc_curve *curve, struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        },
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_partial": {
        "description": "Check if the public key is valid. The key is not valid if it is the zero point or not in the range [1, p-1].",
        "proto" :"static int (*ecc_is_pubkey_valid_partial)(const struct ecc_curve *curve, struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]",
            "pk": "!=zero point",
            "pk": "in range [1, p-1]"
        }
    }
},
{
    "kprobe:ecc_is_pubkey_valid_partial": {
        "description": "Check if the public key is valid. The key is not valid if it is the zero point.",
        "proto" :"static int (*ecc_is_pubkey_valid_partial)(const struct ecc_curve *curve, struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null",
            "pk->ndigits": "== curve->g.ndigits",
            "ecc_point_is_zero(pk)": "== false"
        },
    }
},
{
    "kretprobe:ecc_is_pubkey_valid_partial": {
        "description": "SP800-56A section 5.6.2.3.4 partial verification: ephemeral keys only",
        "proto" :"int ecc_is_pubkey_valid_partial(const struct ecc_curve *curve, struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kprobe:ecc_is_pubkey_valid_partial": {
        "description": "SP800-56A section 5.6.2.3.4 partial verification: ephemeral keys only",
        "proto" :"int ecc_is_pubkey_valid_partial(const struct ecc_curve *curve,struct ecc_point *pk)",
        "pre": {
            "curve": "!=null",
            "pk": "!=null"
        }
    }
},
{
    "kretprobe:dma_pool_create": {
        "description": "dma_pool_alloc() may be used to allocate memory. Such memory will all have 'consistent' DMA mappings, accessible by the device and its driver without using cache flushing primitives. The actual size of blocks allocated may be larger than requested because of alignment. If @boundary is nonzero, objects returned from dma_pool_alloc() won't cross that size boundary. This is useful for devices which have addressing restrictions on individual DMA transfers, such as not crossing boundaries of 4KBytes. Return: a dma allocation pool with the requested characteristics, or %NULL if one can't be created.",
        "proto" :"struct dma_pool *(*dma_pool_create)(const char *name, struct device *dev, size_t size, size_t align, size_t boundary)",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": ">=0",
            "boundary": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:dma_pool_create": {
        "description": "dma_pool_alloc() may be used to allocate memory. Such memory will all have 'consistent' DMA mappings, accessible by the device and its driver without using cache flushing primitives. The actual size of blocks allocated may be larger than requested because of alignment. If @boundary is nonzero, objects returned from dma_pool_alloc() won't cross that size boundary. This is useful for devices which have addressing restrictions on individual DMA transfers, such as not crossing boundaries of 4KBytes. Return: a dma allocation pool with the requested characteristics, or %NULL if one can't be created.",
        "proto" :"struct dma_pool *(*dma_pool_create)(const char *name, struct device *dev, size_t size, size_t align, size_t boundary)",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": ">=0",
            "boundary": ">=0"
        },
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex pointed by *pools_reg_lock*.",
        "proto" :"void (*mutex_lock)(struct mutex *pools_reg_lock)",
        "pre": {
            "pools_reg_lock": "!=null"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex. If the mutex is already locked, the current task will be put to sleep until the mutex can be locked.",
        "proto" :"void mutex_lock(struct mutex *lock)",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:dma_pool_free": {
        "description": "Put block back into dma pool. Caller promises neither device nor driver will again touch this block unless it is first re-allocated.",
        "proto" :"void (*dma_pool_free)(struct dma_pool *pool, void *vaddr, dma_addr_t dma)",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:dma_pool_free": {
        "description": "Put block back into dma pool. Caller promises neither device nor driver will again touch this block unless it is first re-allocated.",
        "proto" :"void (*dma_pool_free)(struct dma_pool *pool, void *vaddr, dma_addr_t dma)",
        "pre": {
            "pool": "!=null",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach. Return: a managed dma allocation pool with the requested characteristics, or %NULL if one can't be created.",
        "proto" :"struct dma_pool *(*dmam_pool_create)(const char *name, struct device *dev, size_t size, size_t align, size_t allocation)",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": "is_power_of_two",
            "allocation": ">=0"
        },
    }
},
{
    "kprobe:dmam_pool_create": {
        "description": "Managed dma_pool_create(). DMA pool created with this function is automatically destroyed on driver detach. Return: a managed dma allocation pool with the requested characteristics, or %NULL if one can't be created.",
        "proto" :"struct dma_pool *(*dmam_pool_create)(const char *name, struct device *dev, size_t size, size_t align, size_t allocation)",
        "pre": {
            "name": "!=null",
            "dev": "!=null",
            "size": ">0",
            "align": "is power of 2",
            "allocation": ">=0"
        }
    }
},
{
    "kretprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy() @pool: dma pool that will be destroyed Managed dma_pool_destroy().",
        "proto" :"void (*dmam_pool_destroy)(struct dma_pool *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:dmam_pool_destroy": {
        "description": "Managed dma_pool_destroy() @pool: dma pool that will be destroyed Managed dma_pool_destroy().",
        "proto" :"void (*dmam_pool_destroy)(struct dma_pool *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},




{
    "kretprobe:__alloc_pages_cpuset_fallback": {
        "description": "Fallback to ignore cpuset restriction if our nodes are depleted. The function tries to get a page from the free list. If it fails, it tries to allocate a new page.",
        "proto" :"static struct page *(__alloc_pages_cpuset_fallback)(gfp_t gfp_mask, unsigned int order, unsigned int alloc_flags, const struct alloc_context *ac)",
        "pre": {
            "gfp_mask": "!=null",
            "order": "is a non-negative integer",
            "alloc_flags": "is a non-negative integer",
            "ac": "!=null"
        },
    }
},
{
    "__alloc_pages_cpuset_fallback": {
        "description": "Fallback to ignore cpuset restriction if our nodes are depleted.",
        "proto" :"__alloc_pages_cpuset_fallback(gfp_t gfp_mask, unsigned int order, unsigned int alloc_flags, const struct alloc_context  ac)",
        "pre": {
            "gfp_mask": "!=null",
            "order": "is a positive integer",
            "alloc_flags": "is a positive integer",
            "ac": "!=null",
        },
    }
},




{
    "kretprobe:page_frag_alloc_align": {
        "description": "Allocates a page fragment with specified size, mask, and alignment. If the page fragment cache is empty, it is refilled. If the page size is less than the maximum cache size, the size can vary, otherwise the page size is used.",
        "proto" :"static struct page* (*page_frag_alloc_align)(struct page_frag_cache *nc, unsigned int fragsz, gfp_t gfp_mask, unsigned int align_mask)",
        "pre": {
            "nc": "!=null",
            "fragsz": ">=0",
            "gfp_mask": ">=0",
            "align_mask": ">=0"
        }
    }
},
{
    "kprobe:page_frag_alloc_align": {
        "description": "Allocates a page fragment with alignment. If size can vary, use size, else just use PAGE_SIZE.",
        "proto": "static struct page* (*page_frag_alloc_align)(struct page_frag_cache *nc, unsigned int fragsz, gfp_t gfp_mask, unsigned int align_mask)",
        "pre": {
            "nc": "!=null",
            "fragsz": ">=0",
            "gfp_mask": ">=0",
            "align_mask": ">=0"
        }
    }
},
{
    "kretprobe:alloc_pages_exact": {
        "description": "Allocates an area of memory and returns a pointer to the allocated area or %NULL in case of error.",
        "proto": "void *(*alloc_pages_exact)(size_t size, gfp_t gfp_mask)",
        "pre": {
            "size": "> 0",
            "gfp_mask": ">= 0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:alloc_pages_exact": {
        "description": "Return: pointer to the allocated area or %NULL in case of error.",
        "proto": "void *(*alloc_pages_exact)(size_t size, gfp_t gfp_mask)",
        "pre": {
            "size": ">=0",
            "gfp_mask": "is defined"
        }
    }
},
{
    "kretprobe:alloc_contig_range": {
        "description": "free_contig_range().",
        "proto" :"int (*alloc_contig_range)(unsigned long start, unsigned long end, unsigned migratetype, gfp_t gfp_mask)",
        "pre": {
            "start": ">=0",
            "end": ">start",
            "migratetype": ">=0",
            "gfp_mask": ">=0"
        },
    }
},
{
    "kprobe:alloc_contig_range": {
        "description": "free_contig_range().",
        "proto" :"int (*alloc_contig_range)(unsigned long start, unsigned long end, unsigned migratetype, gfp_t gfp_mask)",
        "pre": {
            "start": "!=null",
            "end": "!=null",
            "migratetype": "in [MIGRATE_UNMOVABLE, MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE, MIGRATE_PCPTYPES, MIGRATE_HIGHATOMIC]",
            "gfp_mask": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH]"
        },
    }
},

{
    "EXPORT_SYMBOL:high_memory": {
        "description": "high_memory defines the upper bound on direct map memory, then end of ZONE_NORMAL. Under CONFIG_DISCONTIG this means that max_low_pfn and highstart_pfn must be the same; there must be no gap between ZONE_NORMAL and ZONE_HIGHMEM.",
        "proto" :"void *high_memory",
        "pre": {},
    }
},
{
    "kretprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock. In case of error, we may have mapped a subset of the provided pages. It is the caller's responsibility to account for this case. The same restrictions apply as in vm_insert_page().",
        "proto" :"int vm_insert_pages(struct vm_area_struct *vma, unsigned long addr, struct page **pages, unsigned long *num)",
        "pre": {
            "vma": "!=null",
            "addr": ">=0",
            "pages": "!=null",
            "num": "!=null && >=0"
        },
        "post": {
            "return": "in [0, num]"
        }
    }
},
{
    "kprobe:vm_insert_pages": {
        "description": "Insert multiple pages into user vma, batching the pmd lock. In case of error, we may have mapped a subset of the provided pages. It is the caller's responsibility to account for this case. The same restrictions apply as in vm_insert_page().",
        "proto" :"int (*vm_insert_pages)(struct vm_area_struct *vma, unsigned long addr, struct page **pages, unsigned long *num)",
        "pre": {
            "vma": "!=null",
            "addr": ">=0",
            "pages": "!=null",
            "num": "!=null && >=0",
        },
    }
},
{
    "kretprobe:__vm_map_pages": {
        "description": "Maps range of kernel pages into user vma. This allows drivers to map range of kernel pages into a user vma.",
        "proto" :"static int (__vm_map_pages)(struct vm_area_struct *vma, struct page **pages, unsigned long num, unsigned long offset)",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        },
    }
},
{
    "kprobe:__vm_map_pages": {
        "description": "Maps range of kernel pages into user vma. This allows drivers to map range of kernel pages into a user vma.",
        "proto" :"static int (__vm_map_pages)(struct vm_area_struct *vma, struct page **pages, unsigned long num, unsigned long offset)",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0",
            "offset": ">=0"
        },
    }
},
{
    "kretprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starts with zero offset. This function is intended for the drivers that did not consider vm_pgoff. Called by mmap handlers.",
        "proto" :"int (*vm_map_pages_zero)(struct vm_area_struct *vma, struct page **pages, unsigned long num)",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        },
        "post": {
            "return": "in [0, error code]"
        }
    }
},
{
    "kprobe:vm_map_pages_zero": {
        "description": "Map range of kernel pages starts with zero offset. This function is intended for the drivers that did not consider vm_pgoff.",
        "proto" :"int (*vm_map_pages_zero)(struct vm_area_struct *vma, struct page **pages, unsigned long num)",
        "pre": {
            "vma": "!=null",
            "pages": "!=null",
            "num": ">=0"
        },
    }
},
{
    "kretprobe:vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot. This is exactly like vmf_insert_pfn(), except that it allows drivers to override pgprot on a per-page basis. This only makes sense for IO mappings, and it makes no sense for COW mappings. In general, using multiple vmas is preferable; vmf_insert_pfn_prot should only be used if using multiple VMAs is impractical.",
        "proto" :"vm_fault_t (*vmf_insert_pfn_prot)(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn, pgprot_t pgprot)",
        "pre": {
            "vma": "!=null",
            "addr": "is valid user address",
            "pfn": "is valid kernel pfn",
            "pgprot": "is valid pgprot flags"
        },
        "post": {
            "return": "is valid vm_fault_t value"
        }
    }
},
{
    "kprobe:vmf_insert_pfn_prot": {
        "description": "Insert single pfn into user vma with specified pgprot. This is exactly like vmf_insert_pfn(), except that it allows drivers to override pgprot on a per-page basis. This only makes sense for IO mappings, and it makes no sense for COW mappings. In general, using multiple vmas is preferable; vmf_insert_pfn_prot should only be used if using multiple VMAs is impractical.",
        "proto" :"vm_fault_t (*vmf_insert_pfn_prot)(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn, pgprot_t pgprot)",
        "pre": {
            "vma": "!=null",
            "addr": "is valid user address",
            "pfn": "is valid kernel pfn",
            "pgprot": "is valid pgprot flags"
        },
    }
},
{
    "kretprobe:vm_normal_page": {
        "description": "This function is used to handle the mapping of virtual addresses to physical frames. It checks if the vma is a COW mapping and if it is, it ensures that all ptes are special. It also supports VM_MIXEDMAP mappings which can contain memory with or without 'struct page' backing. The function returns a pointer to the page structure associated with the given virtual memory area, address, and page table entry.",
        "proto" :"struct page *(*vm_normal_page)(struct vm_area_struct *vma, unsigned long addr, pte_t pte)",
        "pre": {
            "vma": "!=null",
            "addr": ">= vma->vm_start && < vma->vm_end",
            "pte": "!=null"
        },
    }
},
{
    "kprobe:vm_normal_page": {
        "description": "This function is used to handle normal mappings in the VM. It checks if the vma is not a COW mapping and if all ptes are special. If the vma is a COW mapping, it supports COW of arbitrary special mappings with VM_MIXEDMAP. VM_MIXEDMAP mappings can contain memory with or without 'struct page' backing. All pages with a struct page (where pfn_valid is true) are refcounted and considered normal pages by the VM.",
        "proto" :"struct page *(*vm_normal_page)(struct vm_area_struct *vma, unsigned long addr, pte_t pte)",
        "pre": {
            "vma": "!=null",
            "addr": "is valid virtual address",
            "pte": "is valid page table entry"
        },
    }
},
{
    "kretprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace. This is a simplified io_remap_pfn_range() for common driver use. The driver just needs to give us the physical memory range to be mapped, we'll figure out the rest from the vma information. Some drivers might want to tweak vma->vm_page_prot first to get whatever write-combining details or similar.",
        "proto" :"int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)",
        "pre": {
            "vma": "!=null",
            "start": ">=0",
            "len": ">0"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:vm_iomap_memory": {
        "description": "Remap memory to userspace. This is a simplified io_remap_pfn_range() for common driver use. The driver just needs to give us the physical memory range to be mapped, we'll figure out the rest from the vma information. Some drivers might want to tweak vma->vm_page_prot first to get whatever write-combining details or similar.",
        "proto" :"int (*vm_iomap_memory)(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)",
        "pre": {
            "vma": "!=null",
            "start": ">=0",
            "len": ">0"
        },
    }
},
{
    "kretprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes. The folio should be locked and ready to be unmapped. This function is typically used for efficiency after the range of nearby pages has already been unmapped by unmap_mapping_pages() or unmap_mapping_range(). If truncation or invalidation holds the lock on a folio and finds that the page has been remapped again, it uses unmap_mapping_folio() to unmap it finally.",
        "proto": "void unmap_mapping_folio(struct folio *folio)",
        "pre": {
            "folio": "!=null && is_locked"
        }
    }
},
{
    "kprobe:unmap_mapping_folio": {
        "description": "Unmap single folio from processes. The function is used to unmap a single folio from any userspace process which still has it mapped. Typically, for efficiency, the range of nearby pages has already been unmapped by unmap_mapping_pages() or unmap_mapping_range(). But once truncation or invalidation holds the lock on a folio, it may find that the page has been remapped again: and then uses unmap_mapping_folio() to unmap it finally.",
        "proto" :"void (*unmap_mapping_folio)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:follow_pte": {
        "description": "follow_pfn, it is not a good general-purpose API. Return: zero on success, -ve otherwise.",
        "proto" :"int (*follow_pte)(struct mm_struct *mm, unsigned long address, pte_t **ptepp, spinlock_t **ptlp)",
        "pre": {
            "mm": "!=null",
            "address": ">=0",
            "ptepp": "!=null",
            "ptlp": "!=null"
        },
        "post": {
            "return": "in [-ve, 0]"
        }
    }
},
{
    "kprobe:follow_pte": {
        "description": "follow_pfn, it is not a good general-purpose API. Return: zero on success, -ve otherwise.",
        "proto" :"int (*follow_pte)(struct mm_struct *mm, unsigned long address, pte_t **ptepp, spinlock_t **ptlp)",
        "pre": {
            "mm": "!=null",
            "address": ">=0",
            "ptepp": "!=null",
            "ptlp": "!=null"
        }
    }
},
{
    "kretprobe:vmalloc_to_page": {
        "description": "Converts a vmalloc virtual address to its physical page structure.",
        "proto" :"struct page *(*vmalloc_to_page)(const void *vmalloc_addr)",
        "pre": {
            "vmalloc_addr": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_to_page": {
        "description": "This function converts a vmalloc virtual address to its physical page structure.",
        "proto" :"struct page *(*vmalloc_to_page)(const void *vmalloc_addr)",
        "pre": {
            "vmalloc_addr": "!=null && is_vmalloc_or_module_addr(vmalloc_addr)"
        },
        "post": {
            "pgd": "!=null && !pgd_none(*pgd) && !pgd_leaf(*pgd)"
        }
    }
},






{
    "kretprobe:__get_vm_area_caller": {
        "description": "With hardware tag-based KASAN, marking is skipped for non-VM_ALLOC mappings, see __kasan_unpoison_vmalloc().",
        "proto" :"struct vm_struct *__get_vm_area_caller(unsigned long size, unsigned long flags, unsigned long start, unsigned long end, const void *caller)",
        "pre": {
            "size": ">=0",
            "flags": "in [VM_ALLOC, ...]",
            "start": ">=0",
            "end": ">=start",
            "caller": "!=null"
        },
    }
},
{
    "kprobe:__get_vm_area_caller": {
        "description": "With hardware tag-based KASAN, marking is skipped for non-VM_ALLOC mappings, see __kasan_unpoison_vmalloc().",
        "proto" :"struct vm_struct *(__get_vm_area_caller)(unsigned long size, unsigned long flags, unsigned long start, unsigned long end, const void *caller)",
        "pre": {
            "size": "[your constraints here]",
            "flags": "[your constraints here]",
            "start": "[your constraints here]",
            "end": "[your constraints here]",
            "caller": "[your constraints here]"
        },
    }
},
{
    "kretprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill. Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space. The memory allocated is set to zero. For tight control over page level allocator and protection flags use __vmalloc() instead.",
        "proto" :"void *(*vzalloc)(unsigned long size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vzalloc": {
        "description": "Allocate virtually contiguous memory with zero fill. Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space. The memory allocated is set to zero. For tight control over page level allocator and protection flags use __vmalloc() instead.",
        "proto" :"void *(*vzalloc)(unsigned long size)",
        "pre": {
            "size": ">=0"
        }
    }
},
{
    "kretprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace. The resulting memory area is zeroed so it can be mapped to userspace without leaking data.",
        "proto" :"void *(*vmalloc_user)(unsigned long size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:vmalloc_user": {
        "description": "Allocate zeroed virtually contiguous memory for userspace. The resulting memory area is zeroed so it can be mapped to userspace without leaking data.",
        "proto" :"void *(*vmalloc_user)(unsigned long size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill. Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space. The memory allocated is set to zero. For tight control over page level allocator and protection flags use __vmalloc() instead.",
        "proto" :"void *(*vzalloc_node)(unsigned long size, int node)",
        "pre": {
            "size": ">=0",
            "node": ">=0"
        },
    }
},
{
    "kprobe:vzalloc_node": {
        "description": "Allocate memory on a specific node with zero fill. Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space. The memory allocated is set to zero. For tight control over page level allocator and protection flags use __vmalloc() instead.",
        "proto" :"void *(*vzalloc_node)(unsigned long size, int node)",
        "pre": {
            "size": ">=0",
            "node": ">=0",
        },
    }
},
{
    "kretprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable) @size:allocation size. Allocate enough 32bit PA addressable pages to cover @size from the page level allocator and map them into contiguous kernel virtual space.",
        "proto" :"void *(*vmalloc_32)(unsigned long size)",
        "pre": {
            "size": "> 0"
        },
    }
},
{
    "kprobe:vmalloc_32": {
        "description": "Allocate virtually contiguous memory (32bit addressable) @size:allocation size. Allocate enough 32bit PA addressable pages to cover @size from the page level allocator and map them into contiguous kernel virtual space.",
        "proto" :"static void *(*vmalloc_32)(unsigned long size)",
        "pre": {
            "size": ">=0"
        }
    }
},
{
    "kretprobe:vmalloc_32_user": {
        "description": "Allocates virtually contiguous memory that is only visible to the kernel, from the user space. The memory is zeroed on allocation.",
        "proto" :"void *vmalloc_32_user(unsigned long size)",
        "pre": {
            "size": "> 0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_32_user": {
        "description": "Allocates virtually contiguous memory that is only visible to the kernel, from the user space. The memory is zeroed on allocation.",
        "proto" :"void *(*vmalloc_32_user)(unsigned long size)",
        "pre": {
            "size": "> 0"
        }
    }
},
{
    "kretprobe:remap_vmalloc_range_partial": {
        "description": "This function checks that @kaddr is a valid vmalloc'ed area, and that it is big enough to cover the range starting at @uaddr in @vma. Will return failure if that criteria isn't met. Similar to remap_pfn_range() (see mmmemory.c)",
        "proto" :"int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,void *kaddr, unsigned long pgoff,unsigned long size)",
        "pre": {
            "vma": "!=null",
            "uaddr": ">=0",
            "kaddr": "!=null",
            "pgoff": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "in [0, -Exxx]"
        }
    }
},
{
    "kprobe:remap_vmalloc_range_partial": {
        "description": "Map vmalloc pages to userspace. Checks that kaddr is a valid vmalloc'ed area, and that it is big enough to cover the range starting at uaddr in vma. Returns 0 for success, -Exxx on failure.",
        "proto" :"int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr, void *kaddr, unsigned long pgoff, unsigned long size)",
        "pre": {
            "vma": "!=null",
            "uaddr": ">=0",
            "kaddr": "!=null && is_vmalloc_addr(kaddr)",
            "pgoff": ">=0",
            "size": ">0 && size <= vmalloc_area_length(kaddr)"
        },
    }
},
{
    "kretprobe:foo": {
        "description": "This is a description of what the function does.",
        "proto" :"int foo(int a, int b)",
        "pre": {
            "a": ">=0",
            "b": ">=0"
        },
    }
},
{
    "kprobe:do_brk_flags": {
        "description": "This function seems to be related to memory management, possibly changing the size of the data segment of the process.",
        "proto" :"static int do_brk_flags(struct vma_iterator vmi, struct vm_area_struct brkvma, unsigned long addr, unsigned long request, unsigned long flags)",
        "pre": {
            "vmi": "!=null",
            "brkvma": "!=null",
            "addr": ">=0",
            "request": ">=0",
            "flags": "in [FLAG1, FLAG2, FLAG3]",
        },
    }
},


{
    "kretprobe:vm_brk_flags": {
        "description": "Until we need other flags, refuse anything except VM_EXEC.",
        "proto" :"static long (*vm_brk_flags)(unsigned long addr, unsigned long request, unsigned long flags)",
        "pre": {
            "addr": "your_condition_here",
            "request": "your_condition_here",
            "flags": "your_condition_here"
        },
    }
},
{
    "kprobe:vm_brk_flags": {
        "description": "Until we need other flags, refuse anything except VM_EXEC.",
        "proto" :"vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags){struct mm_struct  mm = current->mm;struct vm_area_struct  vma = NULL;unsigned long len;int ret;bool populate;LIST_HEAD(uf);VMA_ITERATOR(vmi, mm, addr);len = PAGE_ALIGN(request);if (len < request)return -ENOMEM;if (!len)return 0;if (mmap_write_lock_killable(mm))return -EINTR;",
        "pre": {
            "addr": "!=null",
            "request": "!=null",
            "flags": "in [VM_EXEC]",
        },
    }
},
{
    "kretprobe:vm_brk_flags": {
        "description": "Until we need other flags, refuse anything except VM_EXEC.",
        "proto" :"vm_brk_flags(unsigned long addr, unsigned long request, unsigned long flags)",
        "pre": {
            "addr": "your_condition_here",
            "request": "your_condition_here",
            "flags": "your_condition_here"
        },
    }
},

{
    "kretprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete. This is equivalent to calling unregister_shrink() and register_shrinker(), but atomically and with less overhead. This is useful to guarantee that all shrinker invocations have seen an update, before freeing memory, similar to rcu.",
        "proto" :"void (*synchronize_shrinkers)(void)",
        "pre": {
            // Here you should add the preconditions for the parameters of the function
            // As the function does not seem to have any parameters, this section can be left empty
        },
    }
},
{
    "kprobe:synchronize_shrinkers": {
        "description": "Wait for all running shrinkers to complete. This is equivalent to calling unregister_shrink() and register_shrinker(), but atomically and with less overhead. This is useful to guarantee that all shrinker invocations have seen an update, before freeing memory, similar to rcu.",
        "proto" :"void (*synchronize_shrinkers)(void)",
        "pre": {
            // Input arguments and their constraints should go here
        },
    }
},
{
    "kretprobe:migrate_vma_setup": {
        "description": "migrate_vma_finalize() to update the CPU page table to point to new pages for successfully migrated pages or otherwise restore the CPU page table to point to the original source pages.",
        "proto" :"int (*migrate_vma_setup)(struct migrate_vma *args)",
        "pre": {
            "args": "!=null"
        }
    }
},

{
    "kretprobe:migrate_device_pages": {
        "description": "Migrates device pages from source to destination.",
        "proto" :"migrate_device_pages(unsigned long  src_pfns,unsigned long  dst_pfns, unsigned long npages,struct migrate_vma  migrate)",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": ">0",
            "migrate": "!=null"
        },
        "post": {
            "migrate": "!=null",
            "addr": "migrate->start + i*PAGE_SIZE",
            "notified": "==false"
        }
    }
},
{
    "kprobe:migrate_device_pages": {
        "description": "Your function description here",
        "proto" :"migrate_device_pages(unsigned long  src_pfns,unsigned long  dst_pfns, unsigned long npages,struct migrate_vma  migrate)",
        "pre": {
            "src_pfns": "Your condition here",
            "dst_pfns": "Your condition here",
            "npages": "Your condition here",
            "migrate": "Your condition here"
        },
    }
},
{
    "kretprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries. Drivers must ensure copying of page data is complete and visible to the CPU before calling this.",
        "proto" :"void (*migrate_device_finalize)(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": ">0"
        }
    }
},
{
    "kprobe:migrate_device_finalize": {
        "description": "Completes migration of the page by removing special migration entries. Drivers must ensure copying of page data is complete and visible to the CPU before calling this.",
        "proto" :"void (*migrate_device_finalize)(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": ">0"
        },
    }
},
{
    "kretprobe:migrate_device_pages": {
        "description": "Equivalent to migrate_vma_pages(). This is called to migrate struct page meta-data from source struct page to destination.",
        "proto" :"void (*migrate_device_pages)(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": ">0"
        }
    }
},
{
    "kprobe:migrate_device_pages": {
        "description": "Migrate struct page meta-data from source struct page to destination. Equivalent to migrate_vma_pages(). This is called to migrate memory.",
        "proto" :"void (*migrate_device_pages)(unsigned long *src_pfns, unsigned long *dst_pfns, unsigned long npages)",
        "pre": {
            "src_pfns": "!=null",
            "dst_pfns": "!=null",
            "npages": ">0"
        }
    }
},


{
    "kretprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag. The idea is that write_cache_pages (or whoever calls this function) will then use TOWRITE tag to identify pages eligible for writeback. This mechanism is used to avoid livelocking of writeback by a process steadily creating new dirty pages in the file (thus it is important for this function to be quick so that it can tag pages faster than a dirtying process can create them).",
        "proto" :"void tag_pages_for_writeback(struct address_space *mapping, pgoff_t start, pgoff_t end)",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kprobe:tag_pages_for_writeback": {
        "description": "This function scans the page range from @start to @end (inclusive) and tags all pages that have DIRTY tag set with a special TOWRITE tag. The idea is that write_cache_pages (or whoever calls this function) will then use TOWRITE tag to identify pages eligible for writeback. This mechanism is used to avoid livelocking of writeback by a process steadily creating new dirty pages in the file (thus it is important for this function to be quick so that it can tag pages faster than a dirtying process can create them).",
        "proto" :"void (*tag_pages_for_writeback)(struct address_space *mapping, pgoff_t start, pgoff_t end)",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start"
        }
    }
},
{
    "kretprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads. Filesystems which do not use buffer heads should call this function from their set_page_dirty address space operation. It ignores the contents of folio_get_private(), so if the filesystem marks individual blocks as dirty, the filesystem should handle that itself. This is also sometimes used by filesystems which use buffer_heads when a single buffer is being dirtied: we want to set the folio dirty in that case, but not all the buffers. This is a 'bottom-up' dirtying, whereas block_dirty_folio() is a 'top-down' dirtying. The caller must ensure this doesn't race with truncation. Most will simply hold the folio lock, but e.g. zap_pte_range() calls with the folio mapped and the pte lock held, which also locks out truncation.",
        "proto" :"bool (*filemap_dirty_folio)(struct address_space *mapping, struct folio *folio)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null"
        }
    }
},
{
    "kprobe:filemap_dirty_folio": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads. Filesystems which do not use buffer heads should call this function from their set_page_dirty address space operation. It ignores the contents of folio_get_private(), so if the filesystem marks individual blocks as dirty, the filesystem should handle that itself. This is also sometimes used by filesystems which use buffer_heads when a single buffer is being dirtied: we want to set the folio dirty in that case, but not all the buffers. This is a 'bottom-up' dirtying, whereas block_dirty_folio() is a 'top-down' dirtying. The caller must ensure this doesn't race with truncation. Most will simply hold the folio lock, but e.g. zap_pte_range() calls with the folio mapped and the pte lock held, which also locks out truncation.",
        "proto" :"bool (*filemap_dirty_folio)(struct address_space *mapping, struct folio *folio)",
        "pre": {
            "mapping": "!=null",
            "folio": "!=null",
            "folio": "is locked",
            "folio": "is not being truncated concurrently"
        },
    }
},
{
    "kretprobe:folio_account_redirty": {
        "description": "Avoid underflowing @bw calculation.",
        "proto" :"static long (*folio_account_redirty)(long written, long written_stamp, long HZ, long elapsed, long period)",
        "pre": {
            "written": ">=0",
            "written_stamp": ">=0",
            "HZ": ">0",
            "elapsed": ">=0",
            "period": ">0",
        },
    }
},

{
    "kretprobe:folio_account_redirty": {
        "description": "De-accounts the dirty counters (NR_DIRTIED, WB_DIRTIED, tsk->nr_dirtied), so that they match the written counters (NR_WRITTEN, WB_WRITTEN) in long term. The mismatches will lead to systematic errors in balanced_dirty_ratelimit and the dirty pages position control.",
        "proto" :"void (*folio_account_redirty)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_account_redirty": {
        "description": "De-accounts the dirty counters (NR_DIRTIED, WB_DIRTIED, tsk->nr_dirtied) to match the written counters (NR_WRITTEN, WB_WRITTEN) in long term. This function is used when redirtying a folio, especially when the filesystem is doing writeback outside the context of a writeback_control().",
        "proto" :"void (*folio_account_redirty)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_mark_dirty": {
        "description": "Mark a folio dirty for filesystems which do not use buffer_heads. Filesystems which do not use buffer heads should call this function from their set_page_dirty address space operation. It ignores the contents of folio_get_private(), so if the filesystem marks individual blocks as dirty, the filesystem should handle that itself.",
        "proto" :"static void (*folio_mark_dirty)(struct folio *folio, struct address_space *mapping, int warn)",
        "pre": {
            "folio": "!=null",
            "mapping": "!=null",
            "warn": "in [0, 1]"
        },
    }
},
{
    "kprobe:folio_mark_dirty": {
        "description": "Your description here",
        "proto" :"static long (*folio_mark_dirty)(struct folio *folio, struct address_space *mapping, int warn)",
        "pre": {
            "folio": "Your condition here",
            "mapping": "Your condition here",
            "warn": "Your condition here"
        },
    }
},
{
    "kretprobe:if_error_equals_AOP_WRITEPAGE_ACTIVATE": {
        "description": "Checks if the error equals AOP_WRITEPAGE_ACTIVATE.",
        "proto" :"static int (*if_error_equals_AOP_WRITEPAGE_ACTIVATE)(int error)",
        "pre": {
            "error": "== AOP_WRITEPAGE_ACTIVATE"
        }
    }
},



{
    "kretprobe:unpin_user_page": {
        "description": "Unpin user pages that have been pinned by pin_user_pages() routines. This is so that such pages can be separately tracked and uniquely handled. In particular, interactions with RDMA and filesystems need special handling.",
        "proto" :"void (*unpin_user_page)(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:unpin_user_page": {
        "description": "Unpin user pages that were previously pinned with pin_user_pages() routines. This is so that such pages can be separately tracked and uniquely handled. In particular, interactions with RDMA and filesystems need special handling.",
        "proto" :"void (*unpin_user_page)(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kretprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages. For each page in the @pages array, make that page (or its head page, if a compound page) dirty, if @make_dirty is true, and if the page was previously listed as clean. In any case, releases all pages using unpin_user_page(), possibly via unpin_user_pages(), for the non-dirty case.",
        "proto" :"void (*unpin_user_pages_dirty_lock)(struct page **pages, unsigned long npages, bool make_dirty)",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_pages_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned pages. For each page in the @pages array, make that page (or its head page, if a compound page) dirty, if @make_dirty is true, and if the page was previously listed as clean. In any case, releases all pages using unpin_user_page(), possibly via unpin_user_pages(), for the non-dirty case.",
        "proto" :"void (*unpin_user_pages_dirty_lock)(struct page **pages, unsigned long npages, bool make_dirty)",
        "pre": {
            "pages": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range. For the page ranges defined by [page .. page+npages], make that range (or its head pages, if a compound page) dirty, if @make_dirty is true, and if the page range was previously listed as clean. set_page_dirty_lock() is used internally.",
        "proto" :"void (*unpin_user_page_range_dirty_lock)(struct page *page, unsigned long npages, bool make_dirty)",
        "pre": {
            "page": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kprobe:unpin_user_page_range_dirty_lock": {
        "description": "Release and optionally dirty gup-pinned page range. For the page ranges defined by [page .. page+npages], make that range (or its head pages, if a compound page) dirty, if @make_dirty is true, and if the page range was previously listed as clean. set_page_dirty_lock() is used internally.",
        "proto" :"void (*unpin_user_page_range_dirty_lock)(struct page *page, unsigned long npages, bool make_dirty)",
        "pre": {
            "page": "!=null",
            "npages": ">=0",
            "make_dirty": "in [true, false]"
        }
    }
},
{
    "kretprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto" :"size_t (*fault_in_writeable)(char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:fault_in_writeable": {
        "description": "Fault in userspace address range for writing. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto" :"static size_t (*fault_in_writeable)(char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_subpage_writeable": {
        "description": "Fault in a user address range for writing while checking for permissions at sub-page granularity (e.g. arm64 MTE). This function should be used when the caller cannot guarantee forward progress of a copy_to_user() loop. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto" :"size_t (*fault_in_subpage_writeable)(char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_subpage_writeable": {
        "description": "Fault in a user address range for writing while checking for permissions at sub-page granularity (e.g. arm64 MTE). This function should be used when the caller cannot guarantee forward progress of a copy_to_user() loop. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto" :"size_t (*fault_in_subpage_writeable)(char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:fault_in_safe_writeable": {
        "description": "Faults in an address range for writing. This is primarily useful when we already know that some or all of the pages in the address range aren't in memory. Unlike fault_in_writeable(), this function is non-destructive. Note that we don't pin or otherwise hold the pages referenced that we fault in. There's no guarantee that they'll stay in memory for any duration of time. Returns the number of bytes not faulted in, like copy_to_user() and copy_from_user().",
        "proto" :"size_t (*fault_in_safe_writeable)(const char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_safe_writeable": {
        "description": "Faults in an address range for writing. This is primarily useful when we already know that some or all of the pages in the address range aren't in memory. Unlike fault_in_writeable(), this function is non-destructive. Note that we don't pin or otherwise hold the pages referenced that we fault in. There's no guarantee that they'll stay in memory for any duration of time. Returns the number of bytes not faulted in, like copy_to_user() and copy_from_user().",
        "proto" :"size_t (*fault_in_safe_writeable)(const char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">0"
        }
    }
},
{
    "kretprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto": "size_t (*fault_in_readable)(const char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:fault_in_readable": {
        "description": "Fault in userspace address range for reading. Returns the number of bytes not faulted in (like copy_to_user() and copy_from_user()).",
        "proto" :"size_t (*fault_in_readable)(const char __user *uaddr, size_t size)",
        "pre": {
            "uaddr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory. Returns either number of pages pinned (which may be less than the number requested), or an error.",
        "proto" :"long get_user_pages_remote(struct mm_struct *mm, unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages, int *locked)",
        "pre": {
            "mm": "!=null",
            "start": ">=0",
            "nr_pages": ">=0",
            "gup_flags": "in [FOLL_WRITE, FOLL_FORCE, FOLL_NOWAIT, FOLL_POPULATE, FOLL_SPLIT, FOLL_HWPOISON, FOLL_NUMA, FOLL_MIGRATION, FOLL_TRIED]",
            "pages": "!=null || ==null",
            "locked": "!=null"
        },
        "post": {
            "return": ">=0 || ==-errno"
        }
    }
},
{
    "kprobe:get_user_pages_remote": {
        "description": "Pin user pages in memory. Returns either number of pages pinned (which may be less than the number requested), or an error. Must be called with mmap_lock held for read or write.",
        "proto" :"long get_user_pages_remote(struct mm_struct *mm, unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages, int *locked)",
        "pre": {
            "mm": "!=null",
            "start": ">=0",
            "nr_pages": ">=0",
            "gup_flags": "in [FOLL_WRITE, FOLL_TOUCH, FOLL_GET, FOLL_DUMP]",
            "pages": "!=null || ==null",
            "locked": "!=null"
        },
    }
},
{
    "kretprobe:try_grab_folio": {
        "description": "The folio containing @page (with refcount appropriately incremented) for success, or NULL upon failure. If neither FOLL_GET nor FOLL_PIN was set, that's considered failure, and furthermore, a likely bug in the caller, so a warning is also emitted.",
        "proto" :"struct folio *(*try_grab_folio)(struct page *page, int refs, unsigned int flags)",
        "pre": {
            "page": "!=null",
            "refs": ">0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        }
    }
},
{
    "kprobe:try_grab_folio": {
        "description": "The function increments the folio's refcount based on the flags and refs. If neither FOLL_GET nor FOLL_PIN was set, that's considered failure, and a warning is also emitted.",
        "proto" :"struct folio *(*try_grab_folio)(struct page *page, int refs, unsigned int flags)",
        "pre": {
            "page": "!=null",
            "refs": ">=0",
            "flags": "in [FOLL_GET, FOLL_PIN]"
        },
    }
},
{
    "kretprobe:get_user_pages_unlocked": {
        "description": "get_user_pages_unlocked() is suitable to replace the form: mmap_read_lock(mm); get_user_pages(mm, ..., pages, NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages); It is functionally equivalent to get_user_pages_fast so get_user_pages_fast should be used instead if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "proto" :"long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages, struct page **pages, unsigned int gup_flags)",
        "pre": {
            "start": ">=0",
            "nr_pages": ">=0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_WRITE, FOLL_READ, FOLL_FORCE, FOLL_LONGTERM, FOLL_WRITE, FOLL_POPULATE, FOLL_SPLIT, FOLL_HWPOISON, FOLL_NUMA, FOLL_MIGRATION, FOLL_TRIED, FOLL_MLOCK, FOLL_REMOTE, FOLL_COW, FOLL_ANON, FOLL_LONGTERM, FOLL_SPLIT, FOLL_HWPOISON, FOLL_NUMA, FOLL_MIGRATION, FOLL_TRIED, FOLL_MLOCK, FOLL_REMOTE, FOLL_COW, FOLL_ANON]"
        }
    }
},
{
    "kprobe:get_user_pages_unlocked": {
        "description": "get_user_pages_unlocked() is suitable to replace the form: mmap_read_lock(mm); get_user_pages(mm, ..., pages, NULL); mmap_read_unlock(mm); with: get_user_pages_unlocked(mm, ..., pages); It is functionally equivalent to get_user_pages_fast so get_user_pages_fast should be used instead if specific gup_flags (e.g. FOLL_FORCE) are not required.",
        "proto" :"long get_user_pages_unlocked(unsigned long start, unsigned long nr_pages, struct page **pages, unsigned int gup_flags)",
        "pre": {
            "start": ">=0",
            "nr_pages": ">=0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_WRITE, FOLL_READ, FOLL_FORCE, FOLL_LONGTERM, FOLL_TOUCH, FOLL_GET, FOLL_MLOCK, FOLL_REMOTE, FOLL_COW, FOLL_ANON, FOLL_NOFAIL, FOLL_OWNER, FOLL_PIN, FOLL_GET_ACCOUNT]"
        }
    }
},
{
    "kretprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process. Nearly the same as get_user_pages_remote(), except that FOLL_PIN is set. See get_user_pages_remote() for documentation on the function arguments, because the arguments here are identical. FOLL_PIN means that the pages must be released via unpin_user_page(). Please see Documentationcore-apipin_user_pages.rst for details. Note that if a zero_page is amongst the returned pages, it will not have pins in it and unpin_user_page () will not remove pins from it.",
        "proto" :"long (*pin_user_pages_remote)(struct mm_struct *mm, unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages, int *locked)",
        "pre": {
            "mm": "!=null",
            "start": ">=0",
            "nr_pages": ">=0",
            "gup_flags": "in [FOLL_WRITE, FOLL_FORCE, FOLL_NOWAIT, FOLL_LONGTERM, FOLL_PIN]",
            "pages": "!=null && length >= nr_pages",
            "locked": "!=null && *locked == 1"
        }
    }
},
{
    "kprobe:pin_user_pages_remote": {
        "description": "Pin pages of a remote process. Nearly the same as get_user_pages_remote(), except that FOLL_PIN is set. If a zero_page is amongst the returned pages, it will not have pins in it and unpin_user_page() will not remove pins from it.",
        "proto": "long (*pin_user_pages_remote)(struct mm_struct *mm, unsigned long start, unsigned long nr_pages, unsigned int gup_flags, struct page **pages, int *locked)",
        "pre": {
            "mm": "!=null",
            "start": ">=0",
            "nr_pages": ">=0",
            "gup_flags": "in [FOLL_WRITE, FOLL_TOUCH, FOLL_GET, FOLL_DIRTY, FOLL_LONGTERM, FOLL_FORCE, FOLL_PIN, FOLL_HWPOISON, FOLL_NUMA, FOLL_MIGRATION, FOLL_TRIED, FOLL_MLOCK, FOLL_REMOTE, FOLL_COW, FOLL_ANON, FOLL_SPLIT, FOLL_HWPOISON_LARGE, FOLL_HWPOISON_COMP, FOLL_WRITE_PAGES, FOLL_POPULATE, FOLL_ANON_ONLY, FOLL_NOWAIT, FOLL_OWNER, FOLL_FORCE_SYSTEM, FOLL_ZFILL, FOLL_COW_BYPASS]",
            "pages": "!=null && length >= nr_pages",
            "locked": "!=null && *locked == 1"
        }
    }
},
{
    "kretprobe:pin_user_pages_unlocked": {
        "description": "pin_user_pages_unlocked() is the FOLL_PIN variant of get_user_pages_unlocked(). Behavior is the same, except that this one sets FOLL_PIN and rejects FOLL_GET. Note that if a zero_page is amongst the returned pages, it will not have pins in it and unpin_user_page () will not remove pins from it.",
        "proto" :"long pin_user_pages_unlocked(unsigned long start, unsigned long nr_pages, struct page **pages, unsigned int gup_flags)",
        "pre": {
            "start": ">=0",
            "nr_pages": ">=0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN, FOLL_GET]"
        },
    }
},
{
    "kprobe:pin_user_pages_unlocked": {
        "description": "pin_user_pages_unlocked() is the FOLL_PIN variant of get_user_pages_unlocked(). Behavior is the same, except that this one sets FOLL_PIN and rejects FOLL_GET. Note that if a zero_page is amongst the returned pages, it will not have pins in it and unpin_user_page () will not remove pins from it.",
        "proto" :"long pin_user_pages_unlocked(unsigned long start, unsigned long nr_pages, struct page **pages, unsigned int gup_flags)",
        "pre": {
            "start": ">=0",
            "nr_pages": ">0",
            "pages": "!=null",
            "gup_flags": "in [FOLL_PIN, FOLL_GET]"
        },
    }
},
{
    "kretprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and cpus of the node are removed. NOTE: The caller must call lock_device_hotplug() to serialize hotplug and onlineoffline operations before this call.",
        "proto" :"void (*try_offline_node)(int nid)",
        "pre": {
            "nid": ">=0"
        }
    }
},
{
    "kprobe:try_offline_node": {
        "description": "Offline a node if all memory sections and cpus of the node are removed. NOTE: The caller must call lock_device_hotplug() to serialize hotplug and onlineoffline operations before this call.",
        "proto" :"void (*try_offline_node)(int nid)",
        "pre": {
            "nid": ">=0"
        }
    }
},
{
    "kretprobe:mempool_exit": {
        "description": "Free all reserved elements in @pool and @pool itself. This function only sleeps if the free_fn() function sleeps. May be called on a zeroed but uninitialized mempool (i.e. allocated with kzalloc()).",
        "proto" :"void mempool_exit(mempool_t *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_exit": {
        "description": "Free all reserved elements in @pool and @pool itself. This function only sleeps if the free_fn() function sleeps. May be called on a zeroed but uninitialized mempool (i.e. allocated with kzalloc()).",
        "proto" :"void mempool_exit(mempool_t *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself. This function only sleeps if the free_fn() function sleeps.",
        "proto" :"void (*mempool_destroy)(mempool_t *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kprobe:mempool_destroy": {
        "description": "Free all reserved elements in @pool and @pool itself. This function only sleeps if the free_fn() function sleeps.",
        "proto" :"void mempool_destroy(mempool_t *pool)",
        "pre": {
            "pool": "!=null"
        }
    }
},
{
    "kretprobe:mempool_init_node": {
        "description": "Initializes a memory pool with a specified minimum number of buffers, allocation function, free function, pool data, gfp mask, and node id. It also pre-allocates the guaranteed number of buffers.",
        "proto" :"static long (*mempool_init_node)(mempool_t pool, int min_nr, mempool_alloc_t alloc_fn, mempool_free_t free_fn, void pool_data, gfp_t gfp_mask, int node_id)",
        "pre": {
            "pool": "!=null",
            "min_nr": ">=0",
            "alloc_fn": "!=null",
            "free_fn": "!=null",
            "pool_data": "can be any value",
            "gfp_mask": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]",
            "node_id": ">=0"
        },
    }
},
{
    "kprobe:mempool_init_node": {
        "description": "Initializes a memory pool with a specified minimum number of buffers, allocation function, free function, pool data, gfp mask, and node id. Pre-allocates the guaranteed number of buffers.",
        "proto" :"static int (*mempool_init_node)(mempool_t *pool, int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data, gfp_t gfp_mask, int node_id)",
        "pre": {
            "pool": "!=null",
            "min_nr": ">=0",
            "alloc_fn": "!=null",
            "free_fn": "!=null",
            "pool_data": "can be null or !=null",
            "gfp_mask": ">=0",
            "node_id": ">=0"
        },
    }
},
{
    "kretprobe:mempool_resize": {
        "description": "Resize an existing memory pool. This function may shrink or grow the pool. In the case of growing, it cannot be guaranteed that the pool will be grown to the new size immediately, but new mempool_free() calls will refill it. This function may sleep. Note, the caller must guarantee that no mempool_destroy is called while this function is running. mempool_alloc() & mempool_free() might be called (eg. from IRQ contexts) while this function executes.",
        "proto": "int mempool_resize(mempool_t *pool, int new_min_nr)",
        "pre": {
            "pool": "!=null",
            "new_min_nr": ">=0"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:mempool_resize": {
        "description": "Resize an existing memory pool. This function shrinksgrows the pool. In the case of growing, it cannot be guaranteed that the pool will be grown to the new size immediately, but new mempool_free() calls will refill it. This function may sleep. Note, the caller must guarantee that no mempool_destroy is called while this function is running. mempool_alloc() & mempool_free() might be called (eg. from IRQ contexts) while this function executes. Return: %0 on success, negative error code otherwise.",
        "proto" :"int mempool_resize(mempool_t *pool, int new_min_nr)",
        "pre": {
            "pool": "!=null",
            "new_min_nr": ">=0",
        },
    }
},
{
    "kretprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "proto" :"int order = (int)(long)pool->pool_data;void *addr = kmap_atomic((struct page *)element);__poison_element(addr, 1UL << (PAGE_SHIFT + order));kunmap_atomic(addr);",
        "pre": {
            "order": "is integer",
            "addr": "!=null",
            "element": "is struct page",
            "pool": "!=null",
            "pool->pool_data": "is long"
        }
    }
},
{
    "kprobe:mempool_alloc_pages": {
        "description": "Mempools backed by page allocator",
        "proto" :"int order = (int)(long)pool->pool_data;void *addr = kmap_atomic((struct page *)element);__poison_element(addr, 1UL << (PAGE_SHIFT + order));kunmap_atomic(addr);",
        "pre": {
            "pool": "!=null",
            "element": "!=null",
            "order": "is integer",
            "addr": "!=null",
        },
    }
},
{
    "kretprobe:kmap_atomic": {
        "description": "Maps a page into the kernel virtual address space.",
        "proto" :"void *kmap_atomic(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:mempool_free_pages": {
        "description": "Mempools backed by page allocator",
        "proto" :"static void (*mempool_free_pages)(void *pool, void *element, size_t size)",
        "pre": {
            "pool": "!=null",
            "element": "!=null",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:__ClearPageMovable": {
        "description": "This page still has the type of a movable page, but it's actually not movable any more.",
        "proto" :"void __ClearPageMovable(struct page *page)",
        "pre": {
            "page": "!=null"
        },
    }
},
{
    "kprobe:__ClearPageMovable": {
        "description": "This page still has the type of a movable page, but it's actually not movable any more.",
        "proto" :"void __ClearPageMovable(struct page *page)",
        "pre": {
            "page": "!=null && PageMovable(page)"
        }
    }
},
{
    "kretprobe:__put_devmap_managed_page_refs": {
        "description": "Checks if the page type is MEMORY_DEVICE_FS_DAX and if the refcount is 1, then the page is free and the refcount is stable because nobody holds a reference on the page.",
        "proto" :"bool (*__put_devmap_managed_page_refs)(struct page *page, int refs)",
        "pre": {
            "page": "!=null",
            "refs": ">=1"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "__put_devmap_managed_page_refs": {
        "description": "fsdax page refcounts are 1-based, rather than 0-based: if refcount is 1, then the page is free and the refcount is stable because nobody holds a reference on the page.",
        "proto": "bool (*__put_devmap_managed_page_refs)(struct page *page, int refs)",
        "pre": {
            "page": "!=null",
            "refs": ">=1"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            "[parameter3]": "[condition3]",
            "[parameter4]": "[condition4]",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your constraints for arg1 here",
            "arg2": "Your constraints for arg2 here",
            // Add more arguments as needed
        },
    }
},
{
    "kretprobe:readahead_expand": {
        "description": "Expand a readahead request. Attempt to expand a readahead request outwards from the current size to the specified size by inserting locked pages before and after the current window to increase the size to the new window. This may involve the insertion of THPs, in which case the window may get expanded even beyond what was requested. The algorithm will stop if it encounters a conflicting page already in the pagecache and leave a smaller expansion than requested. The caller must check for this by examining the revised @ractl object for a different expansion than was requested.",
        "proto" :"void readahead_expand(struct readahead_control *ractl, loff_t new_start, size_t new_len)",
        "pre": {
            "ractl": "!=null",
            "new_start": ">=0",
            "new_len": ">=0"
        }
    }
},
{
    "kprobe:readahead_expand": {
        "description": "Expand a readahead request. Attempt to expand a readahead request outwards from the current size to the specified size by inserting locked pages before and after the current window to increase the size to the new window. This may involve the insertion of THPs, in which case the window may get expanded even beyond what was requested. The algorithm will stop if it encounters a conflicting page already in the pagecache and leave a smaller expansion than requested. The caller must check for this by examining the revised @ractl object for a different expansion than was requested.",
        "proto" :"void readahead_expand(struct readahead_control *ractl, loff_t new_start, size_t new_len)",
        "pre": {
            "ractl": "!=null",
            "new_start": ">=0",
            "new_len": ">=0"
        }
    }
},
{
    "kretprobe:hmm_range_fault": {
        "description": "If the vma does not allow read access, then assume that it does not allow write access either. HMM does not support architectures that allow write without read. If a fault is requested for an unsupported range then it is a hard failure.",
        "proto" :"int hmm_range_fault(struct hmm_range *range, unsigned long flags)",
        "pre": {
            "range": "!=null",
            "flags": "in [FAULT_FLAG_ALLOW_RETRY, FAULT_FLAG_RETRY_NOWAIT, FAULT_FLAG_KILLABLE, FAULT_FLAG_TRIED]"
        },
        "post": {
            "return": "in [-EFAULT, 0]"
        }
    }
},
{
    "kprobe:hmm_range_fault": {
        "description": "If the vma does not allow read access, then assume that it does not allow write access either. HMM does not support architectures that allow write without read. If a fault is requested for an unsupported range then it is a hard failure.",
        "proto" :"static long (*hmm_range_fault)(struct hmm_range *range, unsigned long start, unsigned long end)",
        "pre": {
            "range": "!=null",
            "start": ">=0",
            "end": ">start",
        },
    }
},
{
    "kretprobe:folio_migrate_mapping": {
        "description": "Migrate a folio from one mapping to another, adjusting the reference count as necessary.",
        "proto" :"static long (*folio_migrate_mapping)(struct address_space *mapping, struct folio *newfolio, struct folio *folio, int extra_count)",
        "pre": {
            "mapping": "!=null",
            "newfolio": "!=null",
            "folio": "!=null",
            "extra_count": "is integer",
            "folio_ref_count(folio)": "== expected_count"
        },
        "post": {
            "return": "in [-EAGAIN, 0]"
        }
    }
},
{
    "kprobe:folio_migrate_mapping": {
        "description": "Migrate a folio from one mapping to another, adjusting the reference count as necessary.",
        "proto": "int folio_migrate_mapping(struct address_space *mapping, struct folio *newfolio, struct folio *folio, int extra_count)",
        "pre": {
            "mapping": "!=null",
            "newfolio": "!=null",
            "folio": "!=null",
            "extra_count": "is integer",
            "folio_ref_count(folio)": "== expected_count"
        }
    }
},
{
    "kretprobe:folio_migrate_flags": {
        "description": "Migrates flags from one folio to another. If certain conditions are met, the corresponding flags are set on the new folio.",
        "proto" :"folio_migrate_flags(struct folio newfolio, struct folio folio)",
        "pre": {
            "newfolio": "!=null",
            "folio": "!=null"
        },
        "post": {
            "newfolio": "Has the same flags as 'folio' that meet the conditions in the function."
        }
    }
},
{
    "kprobe:folio_migrate_flags": {
        "description": "Migrates flags from one folio to another. If a flag is set in the original folio, it is also set in the new folio.",
        "proto" :"folio_migrate_flags(struct folio newfolio, struct folio folio)",
        "pre": {
            "newfolio": "!=null",
            "folio": "!=null"
        },
    }
},
{
    "kretprobe:migrate_folio_extra": {
        "description": "Common logic to directly migrate a single LRU folio suitable for folios that do not use PagePrivate/PagePrivate2. Folios are locked upon entry and exit.",
        "proto" :"int migrate_folio_extra(struct address_space *mapping, struct folio *dst, struct folio *src, enum migrate_mode mode, int extra_count)",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC, MIGRATE_SYNC_NO_COPY]",
            "extra_count": ">=0",
            "src": "!folio_test_writeback(src)"
        },
        "post": {
            "rc": "in [MIGRATEPAGE_SUCCESS, MIGRATEPAGE_FAILURE]"
        }
    }
},
{
    "kprobe:migrate_folio_extra": {
        "description": "Common logic to directly migrate a single LRU folio suitable for folios that do not use PagePrivate/PagePrivate2. Folios are locked upon entry and exit.",
        "proto" :"migrate_folio_extra(struct address_space *mapping, struct folio *dst, struct folio *src, enum migrate_mode mode, int extra_count)",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_SYNC, MIGRATE_ASYNC, MIGRATE_SYNC_NO_COPY]",
            "extra_count": ">=0",
            "src": "!folio_test_writeback(src)"
        },
    }
},
{
    "kretprobe:buffer_migrate_folio": {
        "description": "Check whether page does not have extra refs before we do more work",
        "proto" :"buffer_migrate_folio(struct address_space  mapping,struct folio  dst, struct folio  src, enum migrate_mode mode,bool check_refs)",
        "pre": {
            "mapping": "!=null",
            "dst": "!=null",
            "src": "!=null",
            "mode": "in [MIGRATE_MODE_1, MIGRATE_MODE_2, ...]", // replace with actual migrate modes
            "check_refs": "is bool"
        },
    }
},
{
    "kprobe:folio_expected_refs": {
        "description": "Get the expected reference count for a folio.",
        "proto" :"static int (*folio_expected_refs)(struct address_space *mapping, struct folio *src)",
        "pre": {
            "mapping": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:bdi_register": {
        "description": "Register a backing_dev_info structure, add it to the list and unlock the cgwb_lock.",
        "proto" :"static void (*bdi_register)(struct backing_dev_info *bdi)",
        "pre": {
            "bdi": "!=null"
        },
    }
},


{
    "kprobe:cleanup_offline_cgwbs_workfn": {
        "description": "Try to release dying cgwbs by switching attached inodes to the nearest living ancestor's writeback. Processed wbs are placed at the end of the list to guarantee the forward progress.",
        "proto" :"static void cleanup_offline_cgwbs_workfn(struct work_struct *work)",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Locks cgwb_lock and saves the current state of flags.",
        "proto" :"void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)",
        "pre": {
            "lock": "!=null",
            "flags": "in [range]"
        }
    },
    "kretprobe:radix_tree_lookup": {
        "description": "Looks up the value associated with the given key in the given radix tree.",
        "proto" :"void *radix_tree_lookup(radix_tree_root *root, unsigned long index)",
        "pre": {
            "root": "!=null",
            "index": "valid ID"
        }
    },
    "kretprobe:if": {
        "description": "Checks if wb and wb->blkcg_css are not equal to blkcg_css.",
        "proto" :"if (wb && wb->blkcg_css != blkcg_css)",
        "pre": {
            "wb": "!=null",
            "wb->blkcg_css": "!=null",
            "blkcg_css": "!=null"
        }
    }
},

{
    "kretprobe:generic_error_remove_page": {
        "description": "Only punch for normal data pages for now. Handling other types like directories would need more auditing.",
        "proto" :"static long (*generic_error_remove_page)(struct address_space *mapping, struct page *page)",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:generic_error_remove_page": {
        "description": "Only punch for normal data pages for now. Handling other types like directories would need more auditing.",
        "proto" :"static long (*generic_error_remove_page)(struct address_space *mapping, struct page *page)",
        "pre": {
            "mapping": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_range": {
        "description": "Truncate the page cache, removing the pages that are between specified offsets (and zeroing out partial pages if lstart or lend + 1 is not page aligned). Truncate takes two passes - the first pass is nonblocking. It will not block on page locks and it will not block on writeback. The second pass will wait. This is to prevent as much IO as possible in the affected region. The first pass will remove most pages, so the search cost of the second pass is low. We pass down the cache-hot hint to the page freeing code. Even if the mapping is large, it is probably the case that the final pages are the most recently touched, and freeing happens in ascending file offset order. Note that since ->invalidate_folio() accepts range to invalidate truncate_inode_pages_range is able to handle cases where lend + 1 is not page aligned properly.",
        "proto" :"void (*truncate_inode_pages_range)(struct address_space *mapping,loff_t lstart, loff_t lend)",
        "pre": {
            "mapping": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kprobe:truncate_inode_pages_range": {
        "description": "Truncate the page cache, removing the pages that are between specified offsets (and zeroing out partial pages if lstart or lend + 1 is not page aligned).",
        "proto" :"void truncate_inode_pages_range(struct address_space *mapping,loff_t lstart, loff_t lend)",
        "pre": {
            "mapping": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kretprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies. Called under (and serialized by) inode->i_rwsem. Filesystems have to use this in the .evict_inode path to inform the VM that this is the final truncate and the inode is going away.",
        "proto" :"void (*truncate_inode_pages_final)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:truncate_inode_pages_final": {
        "description": "Truncate all pages before inode dies. Called under (and serialized by) inode->i_rwsem. Filesystems have to use this in the .evict_inode path to inform the VM that this is the final truncate and the inode is going away.",
        "proto" :"void (*truncate_inode_pages_final)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kretprobe:truncate_cleanup_folio": {
        "description": "invalidate_mapping_pages got there first and c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.",
        "proto" :"static void truncate_cleanup_folio(struct folio *folio)",
        "pre": {
            "folio": "your_condition_here"
        }
    }
},
{
    "kprobe:truncate_cleanup_folio": {
        "description": "invalidate_mapping_pages got there first and c) when tmpfs swizzles a page between a tmpfs inode and swapper_space.",
        "proto" :"static void truncate_cleanup_folio(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated. The inode's new i_size must already be written before truncate_pagecache is called. This function should typically be called before the filesystem releases resources associated with the freed range (eg. deallocates blocks). This way, pagecache will always stay logically coherent with on-disk format, and the filesystem would not have to deal with situations such as writepage being called for a page that has already had its underlying blocks deallocated.",
        "proto": "void truncate_pagecache(struct inode *inode, loff_t newsize)",
        "pre": {
            "inode": "!=null",
            "newsize": ">=0"
        }
    }
},
{
    "kprobe:truncate_pagecache": {
        "description": "Unmap and remove pagecache that has been truncated. Inode's new i_size must already be written before truncate_pagecache is called. This function should typically be called before the filesystem releases resources associated with the freed range (eg. deallocates blocks). This way, pagecache will always stay logically coherent with on-disk format, and the filesystem would not have to deal with situations such as writepage being called for a page that has already had its underlying blocks deallocated.",
        "proto" :"void truncate_pagecache(struct inode *inode, loff_t newsize)",
        "pre": {
            "inode": "!=null",
            "newsize": ">=0",
        },
    }
},
{
    "kretprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size. It updates i_size and performs pagecache truncation (if necessary) to @newsize. Typically called from the filesystem's setattr function when ATTR_SIZE is passed in. Must be called with a lock serializing truncates and writes (generally i_rwsem but e.g. xfs uses a different lock) and before all filesystem specific block truncation has been performed.",
        "proto" :"void truncate_setsize(struct inode *inode, loff_t newsize)",
        "pre": {
            "inode": "!=null",
            "newsize": ">=0"
        }
    }
},
{
    "kprobe:truncate_setsize": {
        "description": "Update inode and pagecache for a new file size. Must be called with a lock serializing truncates and writes.",
        "proto" :"void (*truncate_setsize)(struct inode *inode, loff_t newsize)",
        "pre": {
            "inode": "!=null",
            "newsize": "!=null"
        }
    }
},
{
    "kretprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size. The function must be called after i_size is updated so that page fault coming after we unlock the page will already see the new i_size. The function must be called while we still hold i_rwsem - this not only makes sure i_size is stable but also that userspace cannot observe new i_size value before we are prepared to store mmap writes at new inode size.",
        "proto" :"void (*pagecache_isize_extended)(struct inode *inode, loff_t from, loff_t to)",
        "pre": {
            "inode": "!=null",
            "from": ">=0",
            "to": ">from"
        }
    }
},
{
    "kprobe:pagecache_isize_extended": {
        "description": "Update pagecache after extension of i_size. Handle extension of inode size either caused by extending truncate or by write starting after current i_size. We mark the page straddling current i_size RO so that page_mkwrite() is called on the nearest write access to the page. This way filesystem can be sure that page_mkwrite() is called on the page before user writes to the page via mmap after the i_size has been changed. The function must be called after i_size is updated so that page fault coming after we unlock the page will already see the new i_size. The function must be called while we still hold i_rwsem - this not only makes sure i_size is stable but also that userspace cannot observe new i_size value before we are prepared to store mmap writes at new inode size.",
        "proto" :"void (*pagecache_isize_extended)(struct inode *inode, loff_t from, loff_t to)",
        "pre": {
            "inode": "!=null",
            "from": "is a valid loff_t value",
            "to": "is a valid loff_t value and >= from",
        },
    }
},
{
    "kretprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched. This function should typically be called before the filesystem releases resources associated with the freed range (eg. deallocates blocks). This way, pagecache will always stay logically coherent with on-disk format, and the filesystem would not have to deal with situations such as writepage being called for a page that has already had its underlying blocks deallocated.",
        "proto" :"void (*truncate_pagecache_range)(struct inode *inode, loff_t lstart, loff_t lend)",
        "pre": {
            "inode": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kprobe:truncate_pagecache_range": {
        "description": "Unmap and remove pagecache that is hole-punched. This function should typically be called before the filesystem releases resources associated with the freed range (eg. deallocates blocks). This way, pagecache will always stay logically coherent with on-disk format, and the filesystem would not have to deal with situations such as writepage being called for a page that has already had its underlying blocks deallocated.",
        "proto" :"void (*truncate_pagecache_range)(struct inode *inode, loff_t lstart, loff_t lend)",
        "pre": {
            "inode": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kretprobe:__kmap_to_page": {
        "description": "kmap() mappings",
        "proto" :"static long (*__kmap_to_page)(unsigned long addr, void *vaddr)",
        "pre": {
            "addr": ">= PKMAP_ADDR(0) && < PKMAP_ADDR(LAST_PKMAP)",
            "vaddr": "!=null"
        },
    }
},
{
    "kprobe:__kmap_to_page": {
        "description": "kmap() mappings",
        "proto": "__kmap_to_page(void  vaddr){unsigned long base = (unsigned long) vaddr & PAGE_MASK;struct kmap_ctrl  kctrl = &current->kmap_ctrl;unsigned long addr = (unsigned long)vaddr;int i;  kmap() mappings",
        "pre": {
            "vaddr": "!=null",
        },
    }
},
{
    "kretprobe:lock_kmap_any": {
        "description": "Locks the kmap, potentially saving on overhead by abstracting the disabling of IRQ.",
        "proto" :"#define lock_kmap_any(flags)    spin_lock_irqsave(&kmap_lock, flags)",
        "pre": {
            "flags": "!=null",
        },
    },
    "kretprobe:unlock_kmap_any": {
        "description": "Unlocks the kmap, potentially saving on overhead by abstracting the disabling of IRQ.",
        "proto" :"#define unlock_kmap_any(flags)    spin_unlock_irqrestore(&kmap_lock, flags)",
        "pre": {
            "flags": "!=null",
        },
    }
},
{
    "kprobe:lock_kmap": {
        "description": "Locks the kmap, potentially disabling IRQ.",
        "proto" :"#define lock_kmap()",
        "pre": {
            // No clear preconditions can be defined for a macro without arguments
        },
    },
    "kprobe:unlock_kmap": {
        "description": "Unlocks the kmap, potentially enabling IRQ.",
        "proto" :"#define unlock_kmap()",
        "pre": {
            // No clear preconditions can be defined for a macro without arguments
        },
    },
    "kprobe:lock_kmap_any": {
        "description": "Locks the kmap with given flags, potentially disabling IRQ.",
        "proto" :"#define lock_kmap_any(flags)",
        "pre": {
            "flags": "!=null",
        },
    },
    "kprobe:unlock_kmap_any": {
        "description": "Unlocks the kmap with given flags, potentially enabling IRQ.",
        "proto" :"#define unlock_kmap_any(flags)",
        "pre": {
            "flags": "!=null",
        },
    }
},
{
    "kretprobe:kmap_high_get": {
        "description": "kunmap_high() is necessary. This can be called from any context.",
        "proto" :"void *(*kmap_high_get)(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:kmap_high_get": {
        "description": "kunmap_high() is necessary. This can be called from any context.",
        "proto" :"void *(*kmap_high_get)(struct page *page)",
        "pre": {
            "page": "!=null"
        }
    }
},

{
    "kprobe:__kmap_local_page_prot": {
        "description": "To broaden the usage of the actual kmap_local() machinery always map pages when debugging is enabled and the architecture has no problems with alias mappings.",
        "proto" :"__kmap_local_page_prot(struct page *page, pgprot_t prot)",
        "pre": {
            "page": "your_condition_here",
            "prot": "your_condition_here"
        },
    }
},
{
    "kretprobe:kunmap_local_indexed": {
        "description": "Handle mappings which were obtained by kmap_high_get() first as the virtual address of such mappings is below PAGE_OFFSET. Warn for all other addresses which are in the user space part of the virtual address space.",
        "proto" :"static void (*kunmap_local_indexed)(const void *vaddr)",
        "pre": {
            "vaddr": "!=null"
        },
    }
},
{
    "kprobe:kunmap_local_indexed": {
        "description": "Handle mappings which were obtained by kmap_high_get() first as the virtual address of such mappings is below PAGE_OFFSET. Warn for all other addresses which are in the user space part of the virtual address space.",
        "proto" :"kunmap_local_indexed(const void  vaddr)",
        "pre": {
            "vaddr": "!=null && is a valid virtual address",
        },
    }
},


{
    "kretprobe:vma_alloc_folio": {
        "description": "vma_alloc_folio() will use task or system default policy.",
        "proto" :"static long (*vma_alloc_folio)(int gfp, int folio_order, void *src, void *vma, unsigned long address, int folio_test_large)",
        "pre": {
            "gfp": ">=0",
            "folio_order": ">=0",
            "src": "!=null",
            "vma": "!=null",
            "address": ">=0",
            "folio_test_large": ">=0"
        }
    }
},


{
    "kprobe:alloc_pages": {
        "description": "skip NUMA_INTERLEAVE_HIT counter update if numa stats is disabled",
        "proto" :"static struct page *alloc_pages(gfp_t gfp_mask, unsigned int order, int nid, struct zonelist *zonelist)",
        "pre": {
            "gfp_mask": "!=null",
            "order": ">=0",
            "nid": ">=0",
            "zonelist": "can be null or !=null",
        },
    }
},
{
    "kretprobe:folio_alloc_node": {
        "description": "If hugepage allocations are configured to always synchronous compact or the vma has been madvised to prefer hugepage backing, retry allowing remote memory with both reclaim and compact as well.",
        "proto" :"static long (*folio_alloc_node)(gfp | __GFP_THISNODE |__GFP_NORETRY, order, hpage_node)",
        "pre": {
            "gfp": "your_condition_here",
            "order": "your_condition_here",
            "hpage_node": "your_condition_here"
        },
    }
},
{
    "kprobe:folio_alloc_node": {
        "description": "If hugepage allocations are configured to always synchronous compact or the vma has been madvised to prefer hugepage backing, retry allowing remote memory with both reclaim and compact as well.",
        "proto" :"static long (*folio_alloc_node)(gfp | __GFP_THISNODE |__GFP_NORETRY, order, hpage_node)",
        "pre": {
            "gfp": "your_condition_here",
            "order": "your_condition_here",
            "hpage_node": "your_condition_here"
        },
    }
},
{
    "kretprobe:get_hwpoison_page": {
        "description": "unpoison_memory(), the caller should already ensure that the given page has PG_hwpoison. So it's never reused for other page allocations, and __get_unpoison_page() never races with them. Return: 0 on failure, 1 on success for in-use pages in a well-defined state, -EIO for pages on which we can not handle memory errors, -EBUSY when get_hwpoison_page() has raced with page lifecycle operations like allocation and free, -EHWPOISON when the page is hwpoisoned and taken off from buddy.",
        "proto" :"static int get_hwpoison_page(struct page *p, unsigned long flags)",
        "pre": {
            "p": "!=null",
            "flags": ">=0"
        },
        "post": {
            "return": "in [0, 1, -EIO, -EBUSY, -EHWPOISON]"
        }
    }
},
{
    "kprobe:get_hwpoison_page": {
        "description": "unpoison_memory(), the caller should already ensure that the given page has PG_hwpoison. So it's never reused for other page allocations, and __get_unpoison_page() never races with them. Return: 0 on failure, 1 on success for in-use pages in a well-defined state, -EIO for pages on which we can not handle memory errors, -EBUSY when get_hwpoison_page() has raced with page lifecycle operations like allocation and free, -EHWPOISON when the page is hwpoisoned and taken off from buddy.",
        "proto" :"static int (*get_hwpoison_page)(struct page *p, unsigned long flags)",
        "pre": {
            "p": "!=null",
            "flags": "unsigned long"
        },
        "post": {
            "return": "in [0, 1, -EIO, -EBUSY, -EHWPOISON]"
        }
    }
},
{
    "kretprobe:dump_page": {
        "description": "Accessing the pageblock without the zone lock. It could change to 'isolate' again in the meantime, but since we are just dumping the state for debugging, it should be fine to accept a bit of inaccuracy here due to racing.",
        "proto" :"void dump_page(struct page *page)",
        "pre": {
            "page": "!=null"
        },
        "post": {
            "page": "!=null"
        }
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "argument1": "Your argument1 constraints here",
            "argument2": "Your argument2 constraints here",
            "argument3": "Your argument3 constraints here",
            "argument4": "Your argument4 constraints here",
        },
    }
},
{
    "kretprobe:generic_fadvise": {
        "description": "Advise about the use of a range of the file. The advice is not binding; it merely constitutes an expectation on behalf of the application.",
        "proto" :"static int (*generic_fadvise)(struct file *file, loff_t offset, loff_t len, int advice)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "len": ">=0",
            "advice": "in [POSIX_FADV_NORMAL, POSIX_FADV_RANDOM, POSIX_FADV_SEQUENTIAL, POSIX_FADV_WILLNEED, POSIX_FADV_DONTNEED, POSIX_FADV_NOREUSE]"
        },
    }
},
{
    "kprobe:generic_fadvise": {
        "description": "This function provides advice about the specified file range to the filesystem.",
        "proto" :"static int (*generic_fadvise)(struct file *file, loff_t offset, loff_t len, int advice)",
        "pre": {
            "file": "!=null",
            "offset": ">=0",
            "len": ">=0",
            "advice": "in [POSIX_FADV_NORMAL, POSIX_FADV_RANDOM, POSIX_FADV_SEQUENTIAL, POSIX_FADV_WILLNEED, POSIX_FADV_DONTNEED, POSIX_FADV_NOREUSE]"
        }
    }
},
{
    "kretprobe:slab_alloc_node": {
        "description": "The fastpath works by first checking if the lockless freelist can be used. If not then __slab_alloc is called for slow processing. Otherwise we can simply pick the next object from the lockless free list.",
        "proto" :"static __fastpath_inline void *slab_alloc_node(struct kmem_cache *s, struct list_lru *lru,gfp_t gfpflags, int node, unsigned long addr, size_t orig_size)",
        "pre": {
            "s": "!=null",
            "lru": "!=null",
            "gfpflags": "in [GFP_KERNEL, GFP_ATOMIC, ...]", // replace with actual flags
            "node": ">=0",
            "addr": ">=0",
            "orig_size": ">0"
        },
    }
},
{
    "kprobe:slab_alloc_node": {
        "description": "The fastpath works by first checking if the lockless freelist can be used. If not then __slab_alloc is called for slow processing. Otherwise we can simply pick the next object from the lockless free list.",
        "proto" :"static __fastpath_inline void *(*slab_alloc_node)(struct kmem_cache *s, struct list_lru *lru, gfp_t gfpflags, int node, unsigned long addr, size_t orig_size)",
        "pre": {
            "s": "!=null",
            "lru": "!=null",
            "gfpflags": "in [GFP_KERNEL, GFP_ATOMIC, ...]", // replace with actual flags
            "node": ">=0",
            "addr": ">=0",
            "orig_size": ">0"
        }
    }
},
{
    "kretprobe:do_slab_free": {
        "description": "kmem_cache_free that can perform fastpath freeing without additional function calls. The fastpath is only possible if we are freeing to the current cpu slab of this processor. This typically the case if we have just allocated the item before. If fastpath is not possible then fall back to __slab_free where we deal with all sorts of special processing. Bulk free of a freelist with several objects (all pointing to the same slab) possible by specifying head and tail ptr, plus objects count (cnt). Bulk free indicated by tail pointer being set.",
        "proto" :"static __always_inline void do_slab_free(struct kmem_cache *s,struct slab *slab, void *head, void *tail,int cnt, unsigned long addr)",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": "!=0"
        },
    }
},
{
    "kprobe:do_slab_free": {
        "description": "kmem_cache_free that can perform fastpath freeing without additional function calls. The fastpath is only possible if we are freeing to the current cpu slab of this processor. This typically the case if we have just allocated the item before. If fastpath is not possible then fall back to __slab_free where we deal with all sorts of special processing. Bulk free of a freelist with several objects (all pointing to the same slab) possible by specifying head and tail ptr, plus objects count (cnt). Bulk free indicated by tail pointer being set.",
        "proto" :"static __always_inline void do_slab_free(struct kmem_cache *s,struct slab *slab, void *head, void *tail,int cnt, unsigned long addr)",
        "pre": {
            "s": "!=null",
            "slab": "!=null",
            "head": "!=null",
            "tail": "!=null",
            "cnt": ">=0",
            "addr": "!=0"
        },
    }
},
{
    "kretprobe:kmem_cache_alloc_bulk": {
        "description": "Drain objects in the per cpu slab, while disabling local IRQs, which protects against PREEMPT and interrupts handlers invoking normal fastpath.",
        "proto" :"static long (*kmem_cache_alloc_bulk)(struct kmem_cache *s, gfp_t flags, size_t size, void *p, struct obj_cgroup *objcg)",
        "pre": {
            "s": "!=null",
            "flags": "is valid gfp_t flags",
            "size": ">=0",
            "p": "!=null",
            "objcg": "!=null"
        },
    }
},
{
    "kprobe:kmem_cache_alloc_bulk": {
        "description": "Drain objects in the per cpu slab, while disabling local IRQs, which protects against PREEMPT and interrupts handlers invoking normal fastpath.",
        "proto" :"static long (*kmem_cache_alloc_bulk)(struct kmem_cache *s, gfp_t flags, size_t size, void *p, struct obj_cgroup *objcg)",
        "pre": {
            "s": "!=null",
            "flags": "is valid gfp_t flags",
            "size": ">=0",
            "p": "!=null",
            "objcg": "!=null"
        }
    }
},
{
    "kretprobe:__folio_put": {
        "description": "__folio_put() is a function that releases the page cache and uncharges the memory cgroup for a small folio, or releases the page cache for a large folio. It does not operate on hugetlb pages.",
        "proto" :"void __folio_put(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:__folio_put_small": {
        "description": "__folio_put_small() is a function that releases the page cache, uncharges the memory cgroup, and frees the unref page for a small folio.",
        "proto" :"void __folio_put_small(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    },
    "kretprobe:__folio_put_large": {
        "description": "__folio_put_large() is a function that releases the page cache for a large folio. It does not operate on hugetlb pages.",
        "proto" :"void __folio_put_large(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:__folio_put": {
        "description": "__folio_put_small(struct folio folio){__page_cache_release(folio);mem_cgroup_uncharge(folio);free_unref_page(&folio->page, 0);}static void __folio_put_large(struct folio folio){__page_cache_release() is supposed to be called for thp, not for hugetlb. This is because hugetlb page does never have PageLRU set (it's never listed to any LRU lists) and no memcg routines should be called for hugetlb (it has a separate hugetlb_cgroup.)",
        "proto" :"void __folio_put(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:put_pages_list": {
        "description": "Release a list of pages which are strung together on page.lru.",
        "proto" :"void (*put_pages_list)(struct list_head *pages)",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kprobe:put_pages_list": {
        "description": "Release a list of pages which are strung together on page.lru.",
        "proto" :"void (*put_pages_list)(struct list_head *pages)",
        "pre": {
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:folio_mark_accessed": {
        "description": "Marks the folio as accessed. If lru_gen is enabled, it increases the reference count of the folio. If the folio is not referenced, it sets the folio as referenced. If the folio is unevictable, it does nothing as unevictable pages are on the 'LRU_UNEVICTABLE' list which is never rotated or maintained.",
        "proto" :"void (*folio_mark_accessed)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_mark_accessed": {
        "description": "Marks a folio as accessed. If lru_gen is enabled, it increases the reference count of the folio. If the folio is not referenced, it sets the folio as referenced. If the folio is unevictable, it does nothing as unevictable pages are on the 'LRU_UNEVICTABLE' list which is never rotated or maintained.",
        "proto" :"static void (*folio_mark_accessed)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list. Queue the folio for addition to the LRU. The decision on whether to add the page to the [in]active [file|anon] list is deferred until the folio_batch is drained. This gives a chance for the caller of folio_add_lru() to have the folio added to the active list using folio_mark_accessed().",
        "proto" :"void (*folio_add_lru)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_add_lru": {
        "description": "Add a folio to an LRU list. Queue the folio for addition to the LRU. The decision on whether to add the page to the [in]active [file|anon] list is deferred until the folio_batch is drained. This gives a chance for the caller of folio_add_lru() to have the folio added to the active list using folio_mark_accessed().",
        "proto" :"void (*folio_add_lru)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:__folio_batch_release": {
        "description": "__folio_batch_release() will drain those queues here. folio_batch_move_lru() calls folios_put() directly to avoid mutual recursion.",
        "proto" :"void (*__folio_batch_release)(struct folio_batch *fbatch)",
        "pre": {
            "fbatch": "!=null"
        }
    }
},
{
    "kprobe:__folio_batch_release": {
        "description": "__folio_batch_release() will drain those queues here. folio_batch_move_lru() calls folios_put() directly to avoid mutual recursion.",
        "proto" :"void (*__folio_batch_release)(struct folio_batch *fbatch)",
        "pre": {
            "fbatch": "!=null",
        },
    }
},
{
    "kretprobe:mod_zone_page_state": {
        "description": "Accurate vmstat updates require a RMW. On !PREEMPT_RT kernels, atomicity is provided by IRQs being disabled -- either explicitly or via local_lock_irq. On PREEMPT_RT, local_lock_irq only disables CPU migrations and preemption potentially corrupts a counter so disable preemption.",
        "proto" :"mod_zone_page_state(struct zone  zone, enum zone_stat_item item,   long delta){struct per_cpu_zonestat __percpu  pcp = zone->per_cpu_zonestats;s8 __percpu  p = pcp->vm_stat_diff + item;long x;long t;}",
        "pre": {
            "zone": "your_condition_here",
            "item": "your_condition_here",
            "delta": "your_condition_here",
            "pcp": "your_condition_here",
            "p": "your_condition_here",
            "x": "your_condition_here",
            "t": "your_condition_here"
        },
    }
},
{
    "kprobe:mod_zone_page_state": {
        "description": "Accurate vmstat updates require a RMW. On !PREEMPT_RT kernels, atomicity is provided by IRQs being disabled -- either explicitly or via local_lock_irq. On PREEMPT_RT, local_lock_irq only disables CPU migrations and preemption potentially corrupts a counter so disable preemption.",
        "proto" :"void mod_zone_page_state(struct zone *zone, enum zone_stat_item item, long delta)",
        "pre": {
            "zone": "!=null",
            "item": "is valid enum zone_stat_item",
            "delta": "is long"
        },
    }
},
{
    "kretprobe:mod_node_page_state": {
        "description": "Only cgroups use subpage accounting right now; at the global level, these items still change in multiples of whole pages. Store them as pages internally to keep the per-cpu counters compact.",
        "proto" :"static long (*mod_node_page_state)(struct pglist_data *pgdat, enum node_stat_item item, long delta)",
        "pre": {
            "pgdat": "!=null",
            "item": "is valid enum node_stat_item",
            "delta": "is long"
        },
    }
},
{
    "kprobe:mod_node_page_state": {
        "description": "Only cgroups use subpage accounting right now; at the global level, these items still change in multiples of whole pages. Store them as pages internally to keep the per-cpu counters compact.",
        "proto": "mod_node_page_state(struct pglist_data *pgdat, enum node_stat_item item, long delta)",
        "pre": {
            "pgdat": "!=null",
            "item": "is an enum node_stat_item",
            "delta": "is a long integer"
        }
    }
},

{
    "kprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[arg1]": "[constraint1]",
            "[arg2]": "[constraint2]",
            "[arg3]": "[constraint3]",
            "[arg4]": "[constraint4]",
        },
    }
},

{
    "kprobe:mod_zone_state": {
        "description": "mod_state() modifies the zone counter state through atomic per cpu operations. Overstep mode specifies how overstep should handled: 0 No overstepping, 1 Overstepping half of threshold, -1 Overstepping minus half of threshold.",
        "proto" :"static inline void mod_zone_state(struct zone *zone, enum zone_stat_item item, long delta, int overstep_mode)",
        "pre": {
            "zone": "!=null",
            "item": "in [enum zone_stat_item]",
            "delta": "is long",
            "overstep_mode": "in [-1, 0, 1]",
        },
    }
},

{
    "kprobe:inc_node_state": {
        "description": "Your description here",
        "proto" :"Your prototype here",
        "pre": {
            "pgdat": "Your condition here",
            "item": "Your condition here",
            "pcp": "Your condition here",
            "p": "Your condition here",
            "v": "Your condition here",
            "t": "Your condition here"
        },
    }
},
{
    "kretprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace. Cannot be called within a interrupt, but can be interrupted. The @ctor is run when new pages are allocated by the cache.",
        "proto" :"struct kmem_cache *(*kmem_cache_create_usercopy)(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*ctor)(void *))",
        "pre": {
            "name": "!=null",
            "size": ">0",
            "align": ">=0",
            "flags": "in [%SLAB_POISON, %SLAB_RED_ZONE, %SLAB_HWCACHE_ALIGN]",
            "useroffset": ">=0",
            "usersize": ">=0",
            "ctor": "can be null"
        },
        "post": {
            "return": "!=null or ==null (on failure)"
        }
    }
},
{
    "kprobe:kmem_cache_create_usercopy": {
        "description": "Create a cache with a region suitable for copying to userspace. Cannot be called within a interrupt, but can be interrupted. The @ctor is run when new pages are allocated by the cache.",
        "proto" :"struct kmem_cache *(*kmem_cache_create_usercopy)(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, unsigned int useroffset, unsigned int usersize, void (*ctor)(void *))",
        "pre": {
            "name": "!=null",
            "size": ">0",
            "align": ">=0",
            "flags": "in [SLAB_POISON, SLAB_RED_ZONE, SLAB_HWCACHE_ALIGN]",
            "useroffset": ">=0",
            "usersize": ">=0",
            "ctor": "can be null"
        },
        "post": {
            "return": "!=null or ==null (on failure)"
        }
    }
},
{
    "kretprobe:kmem_cache_sanity_check": {
        "description": "Performs an integrity check on kmem_cache_create with the given name. Returns -EINVAL if the check fails, and warns if the name contains a space as it confuses parsers.",
        "proto" :"static inline int kmem_cache_sanity_check(const char *name, unsigned int size)",
        "pre": {
            "name": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:kmem_cache_sanity_check": {
        "description": "This function seems to perform a sanity check on a kmem_cache object. More details are needed for a precise description.",
        "proto" :"static inline int kmem_cache_sanity_check(const char *name, unsigned int size)",
        "pre": {
            "name": "!=null",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:kmem_cache_release": {
        "description": "kmem_cache_destroy() should only be called once or there will be a use-after-free problem. The actual deletion and release of the kobject does not need slab_mutex or cpu_hotplug_lock protection. So they are now done without holding those locks. Note that there will be a slight delay in the deletion of sysfs files if kmem_cache_release() is called indirectly from a work function.",
        "proto" :"static void kmem_cache_release(struct kmem_cache *s)",
        "pre": {
            "s": "!=null"
        },
        "post": {
            "kmem_cache_destroy": "called_once"
        }
    }
},
{
    "kprobe:kmem_cache_release": {
        "description": "kmem_cache_destroy() should only be called once or there will be a use-after-free problem. The actual deletion and release of the kobject does not need slab_mutex or cpu_hotplug_lock protection. So they are now done without holding those locks. Note that there will be a slight delay in the deletion of sysfs files if kmem_cache_release() is called indirectly from a work function.",
        "proto" :"static void kmem_cache_release(struct kmem_cache *s)",
        "pre": {
            "s": "!=null && kmem_cache_destroy() should only be called once"
        }
    }
},
{
    "kretprobe:kmem_cache_shrink": {
        "description": "Shrink a cache. Releases as many slabs as possible for a cache. A zero exit status indicates all slabs were released.",
        "proto" :"int kmem_cache_shrink(struct kmem_cache *cachep)",
        "pre": {
            "cachep": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:kmem_cache_shrink": {
        "description": "Shrink a cache. Releases as many slabs as possible for a cache. A zero exit status indicates all slabs were released.",
        "proto" :"int kmem_cache_shrink(struct kmem_cache *cachep)",
        "pre": {
            "cachep": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},


{
    "kretprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "proto" :"static long (*kmalloc_size_roundup)(size_t size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "if (size == 0) then 0 else unknown"
        }
    }
},
{
    "kprobe:kmalloc_size_roundup": {
        "description": "Short-circuit the 0 size case.",
        "proto" :"kmalloc_size_roundup(size_t size)",
        "pre": {
            "size": ">=0",
        },
    }
},
{
    "kretprobe:__kmalloc_minalign": {
        "description": "Returns the minimum alignment for kmalloc. If CONFIG_DMA_BOUNCE_UNALIGNED_KMALLOC is enabled, it returns ARCH_KMALLOC_MINALIGN, otherwise it returns the result of dma_get_cache_alignment().",
        "proto": "unsigned int (*__kmalloc_minalign)(void)",
        "pre": {},
        "post": ">= ARCH_KMALLOC_MINALIGN"
    },
    "kretprobe:__initnew_kmalloc_cache": {
        "description": "Initializes a new kmalloc cache. Sets various flags based on the type of kmalloc cache.",
        "proto": "void (*__initnew_kmalloc_cache)(int idx, enum kmalloc_cache_type type, slab_flags_t flags)",
        "pre": {
            "idx": ">= 0",
            "type": "in [KMALLOC_RECLAIM, KMALLOC_NORMAL, KMALLOC_CGROUP, KMALLOC_DMA]",
            "flags": ">= 0"
        },
        "post": {
            "flags": "in [SLAB_RECLAIM_ACCOUNT, SLAB_ACCOUNT, SLAB_CACHE_DMA, SLAB_NO_MERGE]"
        }
    }
},
{
    "kprobe:__initnew_kmalloc_cache": {
        "description": "Your function description here",
        "proto" :"void __initnew_kmalloc_cache(int idx, enum kmalloc_cache_type type, slab_flags_t flags)",
        "pre": {
            "idx": "Your idx constraints here",
            "type": "Your type constraints here",
            "flags": "Your flags constraints here",
        },
    }
},
{
    "kretprobe:kmem_cache_create": {
        "description": "Create a cache. Cannot be called within a interrupt, but can be interrupted. The @ctor is run when new pages are allocated by the cache.",
        "proto" :"struct kmem_cache *(*kmem_cache_create)(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, void (*ctor)(void *))",
        "pre": {
            "name": "!=null",
            "size": ">0",
            "align": ">=0",
            "flags": "in [SLAB_POISON, SLAB_RED_ZONE, SLAB_HWCACHE_ALIGN]",
            "ctor": "can be null or valid function pointer"
        },
        "post": {
            "return": "!=null or NULL on failure"
        }
    }
},
{
    "kprobe:kmem_cache_create": {
        "description": "Create a cache. The @ctor is run when new pages are allocated by the cache. Cannot be called within a interrupt, but can be interrupted. Return: a pointer to the cache on success, NULL on failure.",
        "proto" :"struct kmem_cache *(*kmem_cache_create)(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, void (*ctor)(void *))",
        "pre": {
            "name": "!=null",
            "size": ">0",
            "align": ">=0",
            "flags": "in [SLAB_POISON, SLAB_RED_ZONE, SLAB_HWCACHE_ALIGN]",
            "ctor": "can be null or valid function pointer"
        },
    }
},
{
    "kretprobe:kfree": {
        "description": "Free previously allocated memory. If @object is NULL, no operation is performed.",
        "proto": "void kfree(const void *object)",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kprobe:kfree": {
        "description": "Free previously allocated memory.",
        "proto": "void kfree(const void *object)",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:krealloc": {
        "description": "Reallocate the memory block pointed to by *p* to be *new_size* bytes, with *flags* specifying the allocation behavior. Check for double-free before calling ksize.",
        "proto" :"static void* (*krealloc)(const void *p, size_t new_size, gfp_t flags)",
        "pre": {
            "p": "!=null",
            "new_size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:krealloc": {
        "description": "Reallocate the memory block pointed to by *p* to *new_size* bytes, with *flags* specifying the allocation behavior. Check for double-free before calling ksize.",
        "proto": "static void* (*krealloc)(const void *p, size_t new_size, gfp_t flags)",
        "pre": {
            "p": "!=null && !ZERO_OR_NULL_PTR(p)",
            "new_size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing. The memory of the object @p points to is zeroed before freed. If @p is %NULL, kfree_sensitive() does nothing. Note: this function zeroes the whole allocated buffer which can be a good deal bigger than the requested buffer size passed to kmalloc(). So be careful when using this function in performance sensitive code.",
        "proto" :"void (*kfree_sensitive)(const void *p)",
        "pre": {
            "p": "!=null"
        },
    }
},
{
    "kprobe:kfree_sensitive": {
        "description": "Clear sensitive information in memory before freeing. The memory of the object @p points to is zeroed before freed. If @p is %NULL, kfree_sensitive() does nothing. Note: this function zeroes the whole allocated buffer which can be a good deal bigger than the requested buffer size passed to kmalloc(). So be careful when using this function in performance sensitive code.",
        "proto" :"void (*kfree_sensitive)(const void *p)",
        "pre": {
            "p": "!=null"
        }
    }
},
{
    "kretprobe:__ksize": {
        "description": "Report full size of underlying allocation. This should only be used internally to query the true size of allocations. It is not meant to be a way to discover the usable size of an allocation after the fact. Instead, use kmalloc_size_roundup(). Using memory beyond the originally requested allocation size may trigger KASAN, UBSAN_BOUNDS, andor FORTIFY_SOURCE.",
        "proto" :"size_t (*__ksize)(const void *object)",
        "pre": {
            "object": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__ksize": {
        "description": "Report full size of underlying allocation. This should only be used internally to query the true size of allocations. It is not meant to be a way to discover the usable size of an allocation after the fact. Instead, use kmalloc_size_roundup(). Using memory beyond the originally requested allocation size may trigger KASAN, UBSAN_BOUNDS, andor FORTIFY_SOURCE.",
        "proto" :"size_t (*__ksize)(const void *object)",
        "pre": {
            "object": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_update_trace": {
        "description": "Override the object allocation stack trace for cases where the actual allocation place is not always useful.",
        "proto" :"void __ref (*kmemleak_update_trace)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_update_trace": {
        "description": "Override the object allocation stack trace for cases where the actual allocation place is not always useful.",
        "proto" :"void __ref (*kmemleak_update_trace)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive. Calling this function on an object will cause the memory block to no longer be reported as leak and always be scanned.",
        "proto": "void __ref (*kmemleak_not_leak)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_not_leak": {
        "description": "Mark an allocated object as false positive. Calling this function on an object will cause the memory block to no longer be reported as leak and always be scanned.",
        "proto" :"void __ref (*kmemleak_not_leak)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object. Calling this function on an object will cause the memory block to be ignored (not scanned and not reported as a leak). This is usually done when it is known that the corresponding block is not a leak and does not contain any references to other allocated memory blocks.",
        "proto" :"void __ref (*kmemleak_ignore)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore": {
        "description": "Ignore an allocated object. Calling this function on an object will cause the memory block to be ignored (not scanned and not reported as a leak). This is usually done when it is known that the corresponding block is not a leak and does not contain any references to other allocated memory blocks.",
        "proto" :"void __ref (*kmemleak_ignore)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},


{
    "kretprobe:kmemleak_no_scan": {
        "description": "This function notifies kmemleak not to scan the given memory block. Useful in situations where it is known that the given object does not contain any references to other objects. Kmemleak will not scan such objects reducing the number of false negatives.",
        "proto" :"void __ref (*kmemleak_no_scan)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_no_scan": {
        "description": "This function notifies kmemleak not to scan the given memory block. Useful in situations where it is known that the given object does not contain any references to other objects. Kmemleak will not scan such objects reducing the number of false negatives.",
        "proto" :"void __ref (*kmemleak_no_scan)(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        }
    }
},
{
    "kretprobe:kmemleak_alloc_phys": {
        "description": "Allocates a block of memory and tracks it in kmemleak.",
        "proto" :"void (*kmemleak_alloc_phys)(void *ptr, size_t size, gfp_t flags, int min_count)",
        "pre": {
            "ptr": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "min_count": ">=0"
        },
    }
},
{
    "kprobe:kmemleak_alloc_phys": {
        "description": "Allocates a block of memory, the size of which is specified by size parameter, and returns a pointer to the first byte of the block.",
        "proto" :"void (*kmemleak_alloc_phys)(void *ptr, size_t size, gfp_t flags, int min_order)",
        "pre": {
            "ptr": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "min_order": ">=0"
        },
    }
},
{
    "kretprobe:kmemleak_free_part_phys": {
        "description": "Similar to kmemleak_free_part but taking a physical address argument. This represents the start of the range to be freed.",
        "proto" :"void __ref (*kmemleak_free_part_phys)(phys_addr_t phys, size_t size)",
        "pre": {
            "phys": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:kmemleak_free_part_phys": {
        "description": "Similar to kmemleak_free_part but taking a physical address argument. This represents the start of the range to be freed.",
        "proto" :"void __ref (*kmemleak_free_part_phys)(phys_addr_t phys, size_t size)",
        "pre": {
            "phys": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but taking a physical address argument.",
        "proto" :"static void (*kmemleak_ignore_phys)(phys_addr_t phys)",
        "pre": {
            "phys": "!=null"
        }
    }
},
{
    "kprobe:kmemleak_ignore_phys": {
        "description": "Similar to kmemleak_ignore but taking a physical address argument.",
        "proto" :"static void (*kmemleak_ignore_phys)(phys_addr_t phys)",
        "pre": {
            "phys": "!=null"
        }
    }
},
{
    "kretprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "proto": "void (*zpool_register_driver)(struct zpool_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:zpool_register_driver": {
        "description": "Register a zpool implementation.",
        "proto" :"static void (*zpool_register_driver)(struct zpool_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation. Module usage counting is used to prevent using a driver while after unloading. If this is called from other than the module exit function, and this returns failure, the driver is in use and must remain available.",
        "proto" :"int zpool_unregister_driver(struct zpool_driver *driver)",
        "pre": {
            "driver": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:zpool_unregister_driver": {
        "description": "Unregister a zpool implementation. Module usage counting is used to prevent using a driver while unloading. If this is called from module exit function, this should never fail; if called from other than the module exit function, and this returns failure, the driver is in use and must remain available.",
        "proto" :"int zpool_unregister_driver(struct zpool_driver *driver)",
        "pre": {
            "driver": "!=null && is_registered && !is_in_use",
        },
    }
},
{
    "kretprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available. This checks if the @type pool driver is available. This will try to load the requested module, if needed, but there is no guarantee the module will still be loaded and available immediately after calling. If this returns true, the caller should assume the pool is available, but must be prepared to handle the @zpool_create_pool() returning failure. However if this returns false, the caller should assume the requested pool type is not available; either the requested pool type module does not exist, or could not be loaded, and calling @zpool_create_pool() with the pool type will fail. The @type string must be null-terminated.",
        "proto" :"bool (*zpool_has_pool)(char *type)",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "kprobe:zpool_has_pool": {
        "description": "Check if the pool driver is available. This checks if the @type pool driver is available. This will try to load the requested module, if needed, but there is no guarantee the module will still be loaded and available immediately after calling. If this returns true, the caller should assume the pool is available, but must be prepared to handle the @zpool_create_pool() returning failure. However if this returns false, the caller should assume the requested pool type is not available; either the requested pool type module does not exist, or could not be loaded, and calling @zpool_create_pool() with the pool type will fail.",
        "proto" :"bool (*zpool_has_pool)(char *type)",
        "pre": {
            "type": "!=null"
        }
    }
},
{
    "__mod_lruvec_page_state": {
        "description": "Your function description here",
        "proto" :"__mod_lruvec_page_state(struct page *page, enum node_stat_item idx, int val)",
        "pre": {
            "page": "!=null",
            "idx": "in [your possible enum values here]",
            "val": "is integer",
        },
    }
},
{
    "__mod_lruvec_page_state": {
        "description": "Your function description here",
        "proto" :"__mod_lruvec_page_state(struct page *page, enum node_stat_item idx, int val)",
        "pre": {
            "page": "!=null",
            "idx": "Your constraints here",
            "val": "Your constraints here"
        },
    }
},
{
    "kretprobe:mem_cgroup_from_task": {
        "description": "mm_update_next_owner() may clear mm->owner to NULL if it races with swapoff, page migration, etc. So this can be called with p == NULL.",
        "proto" :"static struct mem_cgroup *(*mem_cgroup_from_task)(struct task_struct *p)",
        "pre": {
            "p": "can be null"
        },
    }
},
{
    "kprobe:mem_cgroup_from_task": {
        "description": "mm_update_next_owner() may clear mm->owner to NULL if it races with swapoff, page migration, etc. So this can be called with p == NULL.",
        "proto" :"mem_cgroup_from_task(struct task_struct *p)",
        "pre": {
            "p": "can be null"
        },
    }
},
{
    "kretprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg. If mm is NULL, then the memcg is chosen as follows: 1) The active memcg, if set. 2) current->mm->memcg, if available 3) root memcg. If mem_cgroup is disabled, NULL is returned.",
        "proto" :"struct mem_cgroup *(*get_mem_cgroup_from_mm)(struct mm_struct *mm)",
        "pre": {
            "mm": "can be null"
        },
        "post": {
            "return": "If mem_cgroup is disabled, return == null. Else, return != null"
        }
    }
},
{
    "kprobe:get_mem_cgroup_from_mm": {
        "description": "Obtain a reference on given mm_struct's memcg. @mm: mm from which memcg should be extracted. It can be NULL. Obtain a reference on mm->memcg and returns it if successful. If mm is NULL, then the memcg is chosen as follows: 1) The active memcg, if set. 2) current->mm->memcg, if available 3) root memcg If mem_cgroup is disabled, NULL is returned.",
        "proto" :"struct mem_cgroup *(*get_mem_cgroup_from_mm)(struct mm_struct *mm)",
        "pre": {
            "mm": "can be null"
        },
    }
},
{
    "kretprobe:mem_cgroup_write": {
        "description": "The user of this function is... RES_LIMIT.",
        "proto" :"static ssize_t mem_cgroup_write(struct kernfs_open_file *of, char *buf, size_t nbytes, loff_t off)",
        "pre": {
            "of": "!=null",
            "buf": "!=null",
            "nbytes": ">=0",
            "off": ">=0"
        },
    }
},

{
    "kretprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "proto" :"static struct slab *(*cache_grow_begin)(struct kmem_cache *cachep, gfp_t flags, int nodeid)",
        "pre": {
            "cachep": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_HIGHMEM, GFP_NOFS, GFP_NOIO, GFP_NOWAIT]",
            "nodeid": ">=0"
        },
    }
},
{
    "kprobe:cache_grow_begin": {
        "description": "kmem_cache_alloc() when there are no active objs left in a cache.",
        "proto" :"static struct slab *(*cache_grow_begin)(struct kmem_cache *cachep, gfp_t flags, int nodeid)",
        "pre": {
            "cachep": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]", // replace with actual flag values
            "nodeid": ">=0"
        },
    }
},
{
    "kretprobe:kmem_cache_alloc_bulk": {
        "description": "Allocates a bulk of memory caches.",
        "proto" :"static long (*kmem_cache_alloc_bulk)(struct kmem_cache *s, gfp_t flags, size_t size, void *p)",
        "pre": {
            "s": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "size": ">=0",
            "p": "!=null"
        },
    }
},
{
    "kprobe:kmem_cache_alloc_bulk": {
        "description": "Allocates a bulk of memory caches. If allocation fails, it returns 0.",
        "proto" :"static long (*kmem_cache_alloc_bulk)(struct kmem_cache *s, gfp_t flags, size_t size, void *p)",
        "pre": {
            "s": "!=null",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "size": ">0",
            "p": "!=null"
        },
    }
},
{
    "kretprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node. Identical to kmem_cache_alloc but it will allocate memory on the given node, which can improve the performance for cpu bound structures. Fallback to other node is possible if __GFP_THISNODE is not set.",
        "proto" :"void *(*kmem_cache_alloc_node)(struct kmem_cache *cachep, gfp_t flags, int nodeid)",
        "pre": {
            "cachep": "!=null",
            "flags": "in [__GFP_THISNODE, __GFP_WAIT, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_HIGHMEM, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
            "nodeid": ">=0"
        },
    }
},
{
    "kprobe:kmem_cache_alloc_node": {
        "description": "Allocate an object on the specified node. Identical to kmem_cache_alloc but it will allocate memory on the given node, which can improve the performance for cpu bound structures. Fallback to other node is possible if __GFP_THISNODE is not set.",
        "proto" :"void *(*kmem_cache_alloc_node)(struct kmem_cache *cachep, gfp_t flags, int nodeid)",
        "pre": {
            "cachep": "!=null",
            "flags": "in [__GFP_THISNODE, __GFP_WAIT, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_HIGHMEM, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
            "nodeid": ">=0"
        }
    }
},
{
    "kretprobe:kmem_cache_free": {
        "description": "Your description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here",
            "param4": "Your condition here",
        },
    }
},
{
    "kprobe:kmem_cache_free": {
        "description": "Your description here",
        "proto" :"Your function prototype here",
        "pre": {
            "Your first argument": "Your condition here",
            "Your second argument": "Your condition here",
            "Your third argument": "Your condition here",
            "Your fourth argument": "Your condition here",
        },
    }
},
{
    "kretprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode, and produces a novel ino for the newly allocated inode. It may also be called when making a hard link to permit the space needed by each dentry. However, in that case, no new inode number is needed since that internally draws from another pool of inode numbers (currently global get_next_ino()). This case is indicated by passing NULL as inop.",
        "proto" :"static int shmem_reserve_inode(struct super_block *sb, ino_t *inop)",
        "pre": {
            "sb": "!=null",
            "inop": "can be null or !=null"
        },
    }
},
{
    "kprobe:shmem_reserve_inode": {
        "description": "Performs bookkeeping to reserve a shmem inode, and produces a novel ino for the newly allocated inode. It may also be called when making a hard link to permit the space needed by each dentry. However, in that case, no new inode number is needed since that internally draws from another pool of inode numbers (currently global get_next_ino()). This case is indicated by passing NULL as inop.",
        "proto" :"static int shmem_reserve_inode(struct super_block *sb, ino_t *inop)",
        "pre": {
            "sb": "!=null",
            "inop": "can be null or !=null"
        }
    }
},
{
    "kretprobe:kfree_const": {
        "description": "Function calls kfree only if @x is not in .rodata section.",
        "proto": "void (*kfree_const)(const void *x)",
        "pre": {
            "x": "!=null && !in .rodata section"
        }
    }
},
{
    "kprobe:kfree_const": {
        "description": "Conditionally free memory. Function calls kfree only if @x is not in .rodata section.",
        "proto" :"void (*kfree_const)(const void *x)",
        "pre": {
            "x": "!=null && not in .rodata section"
        }
    }
},
{
    "kretprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string. Returns newly allocated copy of @s or %NULL in case of error.",
        "proto" :"noinlinechar *(*kstrdup)(const char *s, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "gfp": ">=0"
        },
    }
},
{
    "kprobe:kstrdup": {
        "description": "Allocate space for and copy an existing string. Returns newly allocated copy of @s or %NULL in case of error.",
        "proto" :"noinline char *(*kstrdup)(const char *s, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "gfp": "is a valid GFP mask"
        }
    }
},
{
    "kretprobe:kstrdup_const": {
        "description": "Conditionally duplicate an existing const string. Strings allocated by kstrdup_const should be freed by kfree_const and must not be passed to krealloc(). Returns source string if it is in .rodata section otherwise fallback to kstrdup.",
        "proto" :"const char *(*kstrdup_const)(const char *s, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "gfp": "is valid GFP mask"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kstrdup_const": {
        "description": "Conditionally duplicate an existing const string. Strings allocated by kstrdup_const should be freed by kfree_const and must not be passed to krealloc. Returns source string if it is in .rodata section otherwise fallback to kstrdup.",
        "proto" :"const char *(*kstrdup_const)(const char *s, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "gfp": "is a valid GFP mask"
        }
    }
},
{
    "kretprobe:kstrndup": {
        "description": "Return: newly allocated copy of @s or %NULL in case of error",
        "proto" :"char *(*kstrndup)(const char *s, size_t max, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH]"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:kstrndup": {
        "description": "kmemdup_nul() instead if the size is known exactly. Return: newly allocated copy of @s or %NULL in case of error",
        "proto" :"char *(*kstrndup)(const char *s, size_t max, gfp_t gfp)",
        "pre": {
            "s": "!=null",
            "max": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:kvmemdup": {
        "description": "Duplicates a block of memory in a safe way. The returned pointer must be passed to kvfree() to free.",
        "proto": "void *(*kvmemdup)(const void *src, size_t len, gfp_t gfp)",
        "pre": {
            "src": "!=null",
            "len": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:kvmemdup": {
        "description": "Duplicates a block of memory in a safe way. The returned pointer must be passed to kvfree() to free.",
        "proto": "void *(*kvmemdup)(const void *src, size_t len, gfp_t gfp)",
        "pre": {
            "src": "!=null",
            "len": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kretprobe:memdup_user": {
        "description": "Duplicate memory region from user space. The source address is in user space. The number of bytes to copy is specified. The result is physically contiguous, to be freed by kfree(). Returns an ERR_PTR() on failure.",
        "proto": "void *memdup_user(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:memdup_user": {
        "description": "Duplicate memory region from user space. The result is physically contiguous, to be freed by kfree().",
        "proto" :"void *(*memdup_user)(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space. The source address is in user space. The number of bytes to copy is defined by len. The result may not be physically contiguous. Use kvfree() to free. Returns an ERR_PTR() on failure.",
        "proto" :"void *(*vmemdup_user)(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kprobe:vmemdup_user": {
        "description": "Duplicate memory region from user space. The source address is in user space. The number of bytes to copy is defined by len. Returns an ERR_PTR() on failure. The result may not be physically contiguous. Use kvfree() to free.",
        "proto" :"void *(*vmemdup_user)(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:strndup_user": {
        "description": "Duplicate an existing string from user space. Maximum number of bytes to copy, including the trailing NUL. Returns newly allocated copy of @s or an ERR_PTR() in case of error.",
        "proto" :"char *(*strndup_user)(const char __user *s, long n)",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:strndup_user": {
        "description": "Duplicate an existing string from user space. Maximum number of bytes to copy, including the trailing NUL. Returns newly allocated copy of @s or an ERR_PTR() in case of error.",
        "proto" :"char *(*strndup_user)(const char __user *s, long n)",
        "pre": {
            "s": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kretprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate. @src: source address in user space. @len: number of bytes to copy. Return: an ERR_PTR() on failure.",
        "proto" :"void *(*memdup_user_nul)(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:memdup_user_nul": {
        "description": "Duplicate memory region from user space and NUL-terminate. Returns an ERR_PTR() on failure.",
        "proto" :"void *(*memdup_user_nul)(const void __user *src, size_t len)",
        "pre": {
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vma_set_file": {
        "description": "Changes the file associated with a vma. Changing an anonymous vma with this is illegal.",
        "proto" :"static void (*vma_set_file)(struct vm_area_struct *vma, struct file *file)",
        "pre": {
            "vma": "!=null && !=anonymous",
            "file": "!=null",
        },
    }
},
{
    "kprobe:vma_set_file": {
        "description": "Changing an anonymous vma with this is illegal",
        "proto" :"static void (*vma_set_file)(struct vm_area_struct *vma, struct file *file)",
        "pre": {
            "vma": "!=null",
            "file": "!=null",
            "vma->vm_file": "!=null"
        },
    }
},
{
    "kretprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation. Uses kmalloc to get the memory but if the allocation fails then falls back to the vmalloc allocator. Use kvfree for freeing the memory. GFP_NOWAIT and GFP_ATOMIC are not supported, neither is the __GFP_NORETRY modifier. __GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is preferable to the vmalloc fallback, due to visible performance drawbacks.",
        "proto" :"void *(*kvmalloc_node)(size_t size, gfp_t flags, int node)",
        "pre": {
            "size": ">=0",
            "flags": "in [GFP_KERNEL, __GFP_RETRY_MAYFAIL] and not in [GFP_NOWAIT, GFP_ATOMIC, __GFP_NORETRY]",
            "node": ">=0"
        },
    }
},
{
    "kprobe:kvmalloc_node": {
        "description": "Attempt to allocate physically contiguous memory, but upon failure, fall back to non-contiguous (vmalloc) allocation. Uses kmalloc to get the memory but if the allocation fails then falls back to the vmalloc allocator. Use kvfree for freeing the memory. GFP_NOWAIT and GFP_ATOMIC are not supported, neither is the __GFP_NORETRY modifier. __GFP_RETRY_MAYFAIL is supported, and it should be used only if kmalloc is preferable to the vmalloc fallback, due to visible performance drawbacks.",
        "proto" :"void *(*kvmalloc_node)(size_t size, gfp_t flags, int node)",
        "pre": {
            "size": ">=0",
            "flags": "in [GFP_KERNEL, __GFP_RETRY_MAYFAIL] and not in [GFP_NOWAIT, GFP_ATOMIC, __GFP_NORETRY]",
            "node": ">=0"
        },
    }
},
{
    "kretprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information. Use the special memzero_explicit() function to clear the content of a kvmalloc'ed object containing sensitive data to make sure that the compiler won't optimize out the data clearing.",
        "proto" :"void (*kvfree_sensitive)(const void *addr, size_t len)",
        "pre": {
            "addr": "!=null",
            "len": ">0"
        }
    }
},
{
    "kprobe:kvfree_sensitive": {
        "description": "Free a data object containing sensitive information. Use the special memzero_explicit() function to clear the content of a kvmalloc'ed object containing sensitive data to make sure that the compiler won't optimize out the data clearing.",
        "proto" :"void (*kvfree_sensitive)(const void *addr, size_t len)",
        "pre": {
            "addr": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array. @n: number of elements. @size: element size. @flags: the type of memory to allocate (see kmalloc).",
        "proto" :"void *__vmalloc_array(size_t n, size_t size, gfp_t flags)",
        "pre": {
            "n": ">0",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_ZERO, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_HIGH, __GFP_NO_KSWAPD, __GFP_NOTRACK, __GFP_NO_GFP_WAIT, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:__vmalloc_array": {
        "description": "Allocate memory for a virtually contiguous array. @n: number of elements. @size: element size. @flags: the type of memory to allocate (see kmalloc).",
        "proto" :"void *__vmalloc_array(size_t n, size_t size, gfp_t flags)",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_ZERO, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIMABLE, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ACCOUNT]",
        },
    }
},
{
    "kretprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array. @n: number of elements. @size: element size. @flags: the type of memory to allocate (see kmalloc).",
        "proto" :"void *__vcalloc(size_t n, size_t size, gfp_t flags)",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_ZERO, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_COMP, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_HIGH, __GFP_NO_KSWAPD, __GFP_NOTRACK, __GFP_NO_GFP_WAIT, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kprobe:__vcalloc": {
        "description": "Allocate and zero memory for a virtually contiguous array. @n: number of elements. @size: element size. @flags: the type of memory to allocate (see kmalloc).",
        "proto" :"static void *(*__vcalloc)(size_t n, size_t size, gfp_t flags)",
        "pre": {
            "n": ">=0",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
        },
    }
},
{
    "kretprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored. For folios which are in the page cache, return the mapping that this page belongs to. Folios in the swap cache return the swap mapping this page is stored in. You can call this for folios which aren't in the swap cache or page cache and it will return NULL.",
        "proto" :"struct address_space *(*folio_mapping)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        },
    }
},
{
    "kprobe:folio_mapping": {
        "description": "Find the mapping where this folio is stored. For folios which are in the page cache, return the mapping that this page belongs to. Folios in the swap cache return the swap mapping this page is stored in (which is different from the mapping for the swap file or swap device where the data is stored). You can call this for folios which aren't in the swap cache or page cache and it will return NULL.",
        "proto" :"struct address_space *(*folio_mapping)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:page_offline_freeze": {
        "description": "page_offline_end() is used by drivers that care about such races when setting a page PageOffline().",
        "proto" :"static DECLARE_RWSEM(page_offline_rwsem);void page_offline_freeze(void)",
        "pre": {}
    }
},
{
    "kprobe:page_offline_freeze": {
        "description": "Used by drivers that care about such races when setting a page PageOffline.",
        "proto" :"static DECLARE_RWSEM(page_offline_rwsem);void page_offline_freeze(void)",
        "pre": {
            // Hypothetical preconditions
            "page": "!=null",
            "PageOffline": "!=null",
        },
    }
},
{
    "kretprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "proto" :"static int (*filemap_check_errors)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "ret": "in [-ENOSPC, -EIO, 0]"
        }
    }
},
{
    "kprobe:filemap_check_errors": {
        "description": "Check for outstanding write errors",
        "proto" :"static int (*filemap_check_errors)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "ret": "in [-ENOSPC, -EIO, 0]"
        }
    }
},
{
    "kretprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range. Call writepages on the mapping using the provided wbc to control the writeout.",
        "proto" :"int filemap_fdatawrite_wbc(struct address_space *mapping, struct writeback_control *wbc)",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:filemap_fdatawrite_wbc": {
        "description": "Start writeback on mapping dirty pages in range. Call writepages on the mapping using the provided wbc to control the writeout.",
        "proto" :"int (*filemap_fdatawrite_wbc)(struct address_space *mapping, struct writeback_control *wbc)",
        "pre": {
            "mapping": "!=null",
            "wbc": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback against all of a mapping's dirty pages that lie within the byte offsets <start, end> inclusive. If sync_mode is WB_SYNC_ALL then this is a 'data integrity' operation, as opposed to a regular memory cleansing writeback. The difference between these two operations is that if a dirty pagebuffer is encountered, it must be waited upon, and not just skipped over. Return: %0 on success, negative error code otherwise.",
        "proto" :"int (*__filemap_fdatawrite_range)(struct address_space *mapping, loff_t start, loff_t end, int sync_mode)",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start",
            "sync_mode": "in [WB_SYNC_ALL, WB_SYNC_NONE]"
        },
    }
},
{
    "kprobe:__filemap_fdatawrite_range": {
        "description": "Start writeback against all of a mapping's dirty pages that lie within the byte offsets <start, end> inclusive. If sync_mode is WB_SYNC_ALL then this is a 'data integrity' operation, as opposed to a regular memory cleansing writeback. The difference between these two operations is that if a dirty pagebuffer is encountered, it must be waited upon, and not just skipped over. Return: %0 on success, negative error code otherwise.",
        "proto" :"int (*__filemap_fdatawrite_range)(struct address_space *mapping, loff_t start, loff_t end, int sync_mode)",
        "pre": {
            "mapping": "!=null",
            "start": ">=0",
            "end": ">=start",
            "sync_mode": "in [WB_SYNC_ALL, WB_SYNC_NONE]"
        },
    }
},
{
    "kretprobe:filemap_flush": {
        "description": "This is a mostly non-blocking flush. Not suitable for data-integrity purposes - IO may not be started against all dirty pages. Return: %0 on success, negative error code otherwise.",
        "proto" :"int filemap_flush(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        }
    }
},
{
    "kprobe:filemap_flush": {
        "description": "This is a mostly non-blocking flush. Not suitable for data-integrity purposes - IO may not be started against all dirty pages.",
        "proto" :"int filemap_flush(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:filemap_range_has_page": {
        "description": "Find at least one page in the range supplied, usually used to check if direct writing in this range will trigger a writeback.",
        "proto" :"bool (*filemap_range_has_page)(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:filemap_range_has_page": {
        "description": "Check if a page exists in range. Find at least one page in the range supplied, usually used to check if direct writing in this range will trigger a writeback.",
        "proto" :"bool (*filemap_range_has_page)(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte"
        },
    }
},
{
    "kretprobe:filemap_fdatawait_range": {
        "description": "Walk the list of under-writeback pages of the given address space in the given range and wait for all of them. Check error status of the address space and return it. Since the error status of the address space is cleared by this function, callers are responsible for checking the return value and handling and/or reporting the error.",
        "proto" :"int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">=start_byte"
        },
    }
},
{
    "kprobe:filemap_fdatawait_range": {
        "description": "Walk the list of under-writeback pages of the given address space in the given range and wait for all of them. Check error status of the address space and return it. Since the error status of the address space is cleared by this function, callers are responsible for checking the return value and handling and/or reporting the error.",
        "proto": "int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">=start_byte"
        }
    }
},
{
    "kretprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Walk the list of under-writeback pages of the given address space in the given range and wait for all of them. Unlike filemap_fdatawait_range(), this function does not clear error status of the address space. Use this function if callers don't handle errors themselves. Expected call sites are system-wide filesystem-wide data flushers: e.g. sync(2), fsfreeze(8)",
        "proto" :"int filemap_fdatawait_range_keep_errors(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte"
        }
    }
},
{
    "kprobe:filemap_fdatawait_range_keep_errors": {
        "description": "Walk the list of under-writeback pages of the given address space in the given range and wait for all of them. Unlike filemap_fdatawait_range(), this function does not clear error status of the address space. Use this function if callers don't handle errors themselves. Expected call sites are system-wide filesystem-wide data flushers: e.g. sync(2), fsfreeze(8)",
        "proto" :"int (*filemap_fdatawait_range_keep_errors)(struct address_space *mapping, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "mapping": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte",
        },
    }
},
{
    "kretprobe:file_fdatawait_range": {
        "description": "Walk the list of under-writeback pages of the address space that file refers to, in the given range and wait for all of them. Check error status of the address space vs. the file->f_wb_err cursor and return it. Since the error status of the file is advanced by this function, callers are responsible for checking the return value and handling and/or reporting the error.",
        "proto" :"int file_fdatawait_range(struct file *file, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "file": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte"
        },
    }
},
{
    "kprobe:file_fdatawait_range": {
        "description": "Walk the list of under-writeback pages of the address space that file refers to, in the given range and wait for all of them. Check error status of the address space vs. the file->f_wb_err cursor and return it. Since the error status of the file is advanced by this function, callers are responsible for checking the return value and handling and/or reporting the error.",
        "proto" :"int (*file_fdatawait_range)(struct file *file, loff_t start_byte, loff_t end_byte)",
        "pre": {
            "file": "!=null",
            "start_byte": ">=0",
            "end_byte": ">= start_byte",
        },
    }
},
{
    "kretprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors. Walk the list of under-writeback pages of the given address space and wait for all of them. This function does not clear error status of the address space. Use this function if callers don't handle errors themselves. Expected call sites are system-wide filesystem-wide data flushers: e.g. sync(2), fsfreeze(8).",
        "proto" :"int (*filemap_fdatawait_keep_errors)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": "is an error status of the address space"
        }
    }
},
{
    "kprobe:filemap_fdatawait_keep_errors": {
        "description": "Wait for writeback without clearing errors. Walk the list of under-writeback pages of the given address space and wait for all of them. Unlike filemap_fdatawait(), this function does not clear error status of the address space. Use this function if callers don't handle errors themselves. Expected call sites are system-wide filesystem-wide data flushers: e.g. sync(2), fsfreeze(8).",
        "proto" :"int (*filemap_fdatawait_keep_errors)(struct address_space *mapping)",
        "pre": {
            "mapping": "!=null"
        },
        "post": {
            "return": "is error status of the address space"
        }
    }
},
{
    "kretprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive. Note that @lend is inclusive (describes the last byte to be written) so that this function can be used to write to the very end-of-file (end = -1). Return: error status of the address space.",
        "proto" :"int (*filemap_write_and_wait_range)(struct address_space *mapping, loff_t lstart, loff_t lend)",
        "pre": {
            "mapping": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        }
    }
},
{
    "kprobe:filemap_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive. Note that @lend is inclusive (describes the last byte to be written) so that this function can be used to write to the very end-of-file (end = -1). Return: error status of the address space.",
        "proto" :"int (*filemap_write_and_wait_range)(struct address_space *mapping, loff_t lstart, loff_t lend)",
        "pre": {
            "mapping": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart || ==-1",
        },
    }
},
{
    "kretprobe:file_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive. After writing out and waiting on the data, we check and advance the f_wb_err cursor to the latest value, and return any errors detected there.",
        "proto" :"int (*file_write_and_wait_range)(struct file *file, loff_t lstart, loff_t lend)",
        "pre": {
            "file": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart"
        },
    }
},
{
    "kprobe:file_write_and_wait_range": {
        "description": "Write out and wait upon file offsets lstart->lend, inclusive. After writing out and waiting on the data, we check and advance the f_wb_err cursor to the latest value, and return any errors detected there.",
        "proto" :"int (*file_write_and_wait_range)(struct file *file, loff_t lstart, loff_t lend)",
        "pre": {
            "file": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart || ==-1"
        },
    }
},
{
    "kretprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "proto" :"void (*filemap_invalidate_lock_two)(struct address_space *mapping1, struct address_space *mapping2)",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_lock_two": {
        "description": "Lock exclusively invalidate_lock of any passed mapping that is not NULL.",
        "proto" :"static void (*filemap_invalidate_lock_two)(struct address_space *mapping1, struct address_space *mapping2)",
        "pre": {
            "mapping1": "can be null",
            "mapping2": "can be null"
        }
    }
},
{
    "kretprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock of any passed mapping that is not NULL.",
        "proto" :"void (*filemap_invalidate_unlock_two)(struct address_space *mapping1, struct address_space *mapping2)",
        "pre": {
            "mapping1": "!=null",
            "mapping2": "!=null"
        }
    }
},
{
    "kprobe:filemap_invalidate_unlock_two": {
        "description": "Unlock exclusive invalidate_lock of any passed mapping that is not NULL.",
        "proto" :"void (*filemap_invalidate_unlock_two)(struct address_space *mapping1, struct address_space *mapping2)",
        "pre": {
            "mapping1": "!=null || ==null",
            "mapping2": "!=null || ==null",
        },
    }
},
{
    "kretprobe:wake_up_state": {
        "description": "Wake up a specific process state.",
        "proto" :"static void (*wake_up_state)(void *private, int mode)",
        "pre": {
            "private": "!=null",
            "mode": "in [TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE, TASK_WAKEKILL, TASK_WAKING]"
        }
    }
},
{
    "kprobe:wake_up_state": {
        "description": "Wake up a process in a specific state.",
        "proto" :"static void (*wake_up_state)(void *private, int mode)",
        "pre": {
            "private": "!=null",
            "mode": "in [TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE, TASK_WAKEKILL, TASK_WAKING]",
        },
    }
},
{
    "kretprobe:folio_unlock": {
        "description": "Unlock a locked folio. Unlocks the folio and wakes up any thread sleeping on the page lock. Context: May be called from interrupt or process context. May not be called from NMI context.",
        "proto" :"void (*folio_unlock)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_unlock": {
        "description": "Unlock a locked folio. Unlocks the folio and wakes up any thread sleeping on the page lock. Context: May be called from interrupt or process context. May not be called from NMI context.",
        "proto" :"void (*folio_unlock)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters. The folio reference held for PG_private_2 being set is released. This is, for example, used when a netfs folio is being written to a local disk cache, thereby allowing writes to the cache for the same folio to be serialised.",
        "proto" :"void (*folio_end_private_2)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_private_2": {
        "description": "Clear PG_private_2 and wake any waiters. The folio reference held for PG_private_2 being set is released. This is, for example, used when a netfs folio is being written to a local disk cache, thereby allowing writes to the cache for the same folio to be serialised.",
        "proto" :"void (*folio_end_private_2)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio.",
        "proto" :"void (*folio_wait_private_2)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_wait_private_2": {
        "description": "Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio.",
        "proto" :"void (*folio_wait_private_2)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kretprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio or until a fatal signal is received by the calling task.",
        "proto" :"int (*folio_wait_private_2_killable)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        },
        "post": {
            "return": "in [0, -EINTR]"
        }
    }
},
{
    "kprobe:folio_wait_private_2_killable": {
        "description": "Wait for PG_private_2 (aka PG_fscache) to be cleared on a folio or until a fatal signal is received by the calling task.",
        "proto" :"int (*folio_wait_private_2_killable)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        },
        "post": {
            "return": "in [0, -EINTR]"
        }
    }
},
{
    "kretprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "proto": "void (*folio_end_writeback)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},
{
    "kprobe:folio_end_writeback": {
        "description": "End writeback against a folio.",
        "proto" :"static void (*folio_end_writeback)(struct folio *folio)",
        "pre": {
            "folio": "!=null"
        }
    }
},


{
    "kretprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache. Search the range [index, min(index + max_scan - 1, ULONG_MAX)] for the gap with the lowest index. This function may be called under the rcu_read_lock. However, this will not atomically search a snapshot of the cache at a single point in time. For example, if a gap is created at index 5, then subsequently a gap is created at index 10, page_cache_next_miss covering both indices may return 10 if called under the rcu_read_lock. The index of the gap if found, otherwise an index outside the range specified (in which case 'return - index >= max_scan' will be true). In the rare case of index wrap-around, 0 will be returned.",
        "proto" :"pgoff_t (*page_cache_next_miss)(struct address_space *mapping, pgoff_t index, unsigned long max_scan)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "max_scan": ">=0"
        },
    }
},
{
    "kprobe:page_cache_next_miss": {
        "description": "Find the next gap in the page cache. Search the range [index, min(index + max_scan - 1, ULONG_MAX)] for the gap with the lowest index. This function may be called under the rcu_read_lock. However, this will not atomically search a snapshot of the cache at a single point in time. For example, if a gap is created at index 5, then subsequently a gap is created at index 10, page_cache_next_miss covering both indices may return 10 if called under the rcu_read_lock. Return: The index of the gap if found, otherwise an index outside the range specified (in which case 'return - index >= max_scan' will be true). In the rare case of index wrap-around, 0 will be returned.",
        "proto" :"pgoff_t (*page_cache_next_miss)(struct address_space *mapping, pgoff_t index, unsigned long max_scan)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "max_scan": ">=0"
        },
    }
},
{
    "kretprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache. Search the range [max(index - max_scan + 1, 0), index] for the gap with the highest index. This function may be called under the rcu_read_lock. However, this will not atomically search a snapshot of the cache at a single point in time. For example, if a gap is created at index 10, then subsequently a gap is created at index 5, page_cache_prev_miss() covering both indices may return 5 if called under the rcu_read_lock. The index of the gap if found, otherwise an index outside the range specified (in which case 'index - return >= max_scan' will be true). In the rare case of wrap-around, ULONG_MAX will be returned.",
        "proto" :"pgoff_t (*page_cache_prev_miss)(struct address_space *mapping, pgoff_t index, unsigned long max_scan)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "max_scan": ">=0"
        },
    }
},
{
    "kprobe:page_cache_prev_miss": {
        "description": "Find the previous gap in the page cache. Search the range [max(index - max_scan + 1, 0), index] for the gap with the highest index. This function may be called under the rcu_read_lock. However, this will not atomically search a snapshot of the cache at a single point in time. For example, if a gap is created at index 10, then subsequently a gap is created at index 5, page_cache_prev_miss() covering both indices may return 5 if called under the rcu_read_lock. Return: The index of the gap if found, otherwise an index outside the range specified (in which case 'index - return >= max_scan' will be true). In the rare case of wrap-around, ULONG_MAX will be returned.",
        "proto" :"pgoff_t (*page_cache_prev_miss)(struct address_space *mapping, pgoff_t index, unsigned long max_scan)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "max_scan": ">=0"
        }
    }
},
{
    "kretprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio. Looks up the page cache entry at @mapping & @index. If there is a page cache page, it is returned with an increased refcount. Return: The found folio or an ERR_PTR() otherwise.",
        "proto" :"struct folio *(*__filemap_get_folio)(struct address_space *mapping, pgoff_t index, int fgp_flags, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "fgp_flags": "in [%FGP_ACCESSED, %FGP_LOCK, %FGP_CREAT, %FGP_FOR_MMAP, %FGP_WRITE, %FGP_NOFS, %FGP_NOWAIT, %FGP_STABLE]",
            "gfp": ">=0"
        }
    }
},
{
    "kprobe:__filemap_get_folio": {
        "description": "Find and get a reference to a folio. Looks up the page cache entry at @mapping & @index. If there is a page cache page, it is returned with an increased refcount. Return: The found folio or an ERR_PTR() otherwise.",
        "proto" :"struct folio *(*__filemap_get_folio)(struct address_space *mapping, pgoff_t index, int fgp_flags, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "fgp_flags": "in [%FGP_ACCESSED, %FGP_LOCK, %FGP_CREAT, %FGP_FOR_MMAP, %FGP_WRITE, %FGP_NOFS, %FGP_NOWAIT, %FGP_STABLE]",
            "gfp": "in [__GFP_FS, __GFP_ATOMIC, __GFP_IO, __GFP_HIGHMEM, __GFP_HIGH, __GFP_MEMALLOC, __GFP_DMA, __GFP_RECLAIMABLE, __GFP_HARDWALL, __GFP_HIGHUSER, __GFP_FS, __GFP_NOFS, __GFP_RECLAIM, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_WRITE, __GFP_NOWARN, __GFP_RETRY_MAYFAIL, __GFP_NO_GFP_WAIT, __GFP_NORETRY, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_NORECLAIM, __GFP_NOWAIT, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_THISNODE, __GFP_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kretprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios from the address_space. The returned folios are guaranteed to be contiguous. This may not return all contiguous folios if the batch gets filled up. The number of folios found is returned and the start is updated for traversal of the next folio.",
        "proto" :"unsigned (*filemap_get_folios_contig)(struct address_space *mapping, pgoff_t *start, pgoff_t end, struct folio_batch *fbatch)",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": ">= *start",
            "fbatch": "!=null"
        }
    }
},
{
    "kprobe:filemap_get_folios_contig": {
        "description": "Get a batch of contiguous folios from the address_space. The returned folios are guaranteed to be contiguous. This may not return all contiguous folios if the batch gets filled up. The number of folios found is returned and @start is updated for traversal of the next folio.",
        "proto" :"unsigned (*filemap_get_folios_contig)(struct address_space *mapping, pgoff_t *start, pgoff_t end, struct folio_batch *fbatch)",
        "pre": {
            "mapping": "!=null",
            "start": "!=null",
            "end": ">= *start",
            "fbatch": "!=null"
        }
    }
},
{
    "kretprobe:generic_file_read_iter": {
        "description": "This is the 'read_iter()' routine for all filesystems that can use the page cache directly. The IOCB_NOWAIT flag in iocb->ki_flags indicates that -EAGAIN shall be returned when no data can be read without waiting for IO requests to complete; it doesn't prevent readahead. The IOCB_NOIO flag in iocb->ki_flags indicates that no new IO requests shall be made for the read or for readahead. When no data can be read, -EAGAIN shall be returned. When readahead would be triggered, a partial, possibly empty read shall be returned.",
        "proto" :"ssize_t (*generic_file_read_iter)(struct kiocb *iocb, struct iov_iter *iter)",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        },
        "post": {
            "return": ">=0 || ==-EAGAIN || (iocb->ki_flags & IOCB_NOIO && return == 0)"
        }
    }
},
{
    "kprobe:generic_file_read_iter": {
        "description": "This is the 'read_iter()' routine for all filesystems that can use the page cache directly. The IOCB_NOWAIT flag in iocb->ki_flags indicates that -EAGAIN shall be returned when no data can be read without waiting for IO requests to complete; it doesn't prevent readahead. The IOCB_NOIO flag in iocb->ki_flags indicates that no new IO requests shall be made for the read or for readahead. When no data can be read, -EAGAIN shall be returned. When readahead would be triggered, a partial, possibly empty read shall be returned.",
        "proto" :"ssize_t (*generic_file_read_iter)(struct kiocb *iocb, struct iov_iter *iter)",
        "pre": {
            "iocb": "!=null",
            "iter": "!=null",
            "iocb->ki_flags": "in [IOCB_NOWAIT, IOCB_NOIO]"
        }
    }
},
{
    "kretprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe. This function gets folios from a file's pagecache and splices them into the pipe. Readahead will be called as necessary to fill more folios. This may be used for blockdevs also.",
        "proto" :"ssize_t (*filemap_splice_read)(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
        "post": {
            "return": "in [-EAGAIN, 0, len]"
        }
    }
},
{
    "kprobe:filemap_splice_read": {
        "description": "Splice data from a file's pagecache into a pipe. This function gets folios from a file's pagecache and splices them into the pipe. Readahead will be called as necessary to fill more folios. This may be used for blockdevs also.",
        "proto" :"ssize_t (*filemap_splice_read)(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags)",
        "pre": {
            "in": "!=null",
            "ppos": "!=null",
            "pipe": "!=null",
            "len": ">=0",
            "flags": "in [SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT]"
        },
        "post": {
            "return": "in [-EAGAIN, 0, len]"
        }
    }
},

{
    "kprobe:page_cache_delete": {
        "description": "Description of the function",
        "proto" :"static void page_cache_delete(struct address_space *mapping, struct folio *folio, void *shadow)",
        "pre": {
            "mapping": "!=null",
            "folio": "is valid folio object",
            "shadow": "can be any value",
        },
    }
},


{
    "kretprobe:filemap_page_mkwrite": {
        "description": "Marks the folio dirty so that when freeze is in progress, we are guaranteed that writeback during freezing will see the dirty folio and writeprotect it again.",
        "proto" :"vm_fault_t (*filemap_page_mkwrite)(struct vm_fault *vmf)",
        "pre": {
            "vmf": "!=null",
            "vmf->vma": "!=null",
            "vmf->vma->vm_file": "!=null",
            "vmf->vma->vm_file->f_mapping": "!=null",
            "vmf->page": "!=null"
        },
    }
},
{
    "kprobe:filemap_page_mkwrite": {
        "description": "We mark the folio dirty already here so that when freeze is in progress, we are guaranteed that writeback during freezing will see the dirty folio and writeprotect it again.",
        "proto" :"filemap_page_mkwrite(struct vm_fault  vmf){struct address_space  mapping = vmf->vma->vm_file->f_mapping;struct folio  folio = page_folio(vmf->page);vm_fault_t ret = VM_FAULT_LOCKED;sb_start_pagefault(mapping->host->i_sb);file_update_time(vmf->vma->vm_file);folio_lock(folio);if (folio->mapping != mapping) {folio_unlock(folio);ret = VM_FAULT_NOPAGE;goto out;}",
        "pre": {
            "vmf": "!=null",
            "mapping": "!=null",
            "folio": "!=null",
            "ret": "==VM_FAULT_LOCKED",
        },
    }
},
{
    "kretprobe:generic_file_readonly_mmap": {
        "description": "This is for filesystems which do not implement ->writepage.",
        "proto" :"int generic_file_readonly_mmap(struct file *file, struct vm_area_struct *vma)",
        "pre": {
            "file": "!=null",
            "file->f_mapping": "!=null",
            "file->f_mapping->a_ops": "!=null",
            "file->f_mapping->a_ops->read_folio": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return": "in [0, -ENOEXEC]"
        }
    }
},
{
    "kprobe:generic_file_readonly_mmap": {
        "description": "This is for filesystems which do not implement ->writepage.",
        "proto" :"int (*generic_file_readonly_mmap)(struct file *file, struct vm_area_struct *vma)",
        "pre": {
            "file": "!=null",
            "file->f_mapping": "!=null",
            "file->f_mapping->a_ops->read_folio": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kretprobe:filemap_page_mkwrite": {
        "description": "Returns VM_FAULT_SIGBUS.",
        "proto" :"vm_fault_t (*filemap_page_mkwrite)(struct vm_fault  vmf)",
        "pre": {
            "vmf": "!=null"
        }
    },
    "kretprobe:generic_file_mmap": {
        "description": "Returns -ENOSYS.",
        "proto" :"int (*generic_file_mmap)(struct file  file, struct vm_area_struct  vma)",
        "pre": {
            "file": "!=null",
            "vma": "!=null"
        }
    },
    "kretprobe:generic_file_readonly_mmap": {
        "description": "Returns -ENOSYS.",
        "proto" :"int (*generic_file_readonly_mmap)(struct file  file, struct vm_area_struct  vma)",
        "pre": {
            "file": "!=null",
            "vma": "!=null"
        }
    }
},
{
    "kprobe:filemap_page_mkwrite": {
        "description": "Always returns VM_FAULT_SIGBUS.",
        "proto" :"vm_fault_t (*filemap_page_mkwrite)(struct vm_fault  vmf)",
        "pre": {},
    },
    "kprobe:generic_file_mmap": {
        "description": "Always returns -ENOSYS.",
        "proto" :"int (*generic_file_mmap)(struct file  file, struct vm_area_struct  vma)",
        "pre": {},
    },
    "kprobe:generic_file_readonly_mmap": {
        "description": "Returns -EINVAL if both VM_SHARED and VM_MAYWRITE are set in vma->vm_flags, otherwise returns -ENOSYS.",
        "proto" :"int (*generic_file_readonly_mmap)(struct file  file, struct vm_area_struct  vma)",
        "pre": {
            "vma->vm_flags": "not (VM_SHARED and VM_MAYWRITE)"
        },
    }
},
{
    "kretprobe:read_cache_folio": {
        "description": "Reads a folio from the cache or fills it if it's not present.",
        "proto": "struct folio *(*read_cache_folio)(struct address_space *mapping, pgoff_t index, filler_t filler, struct file *file, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "filler": "!=null || mapping->a_ops->read_folio !=null",
            "file": "!=null",
            "gfp": ">=0"
        },
        "post": {
            "return": "!=null || ==ERR_PTR(-ENOMEM)"
        }
    }
},
{
    "kprobe:read_cache_folio": {
        "description": "Reads a folio from the cache or fills it if it doesn't exist.",
        "proto" :"static struct folio *(*read_cache_folio)(struct address_space *mapping, pgoff_t index, filler_t filler, struct file *file, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "filler": "!=null || mapping->a_ops->read_folio",
            "file": "!=null",
            "gfp": ">=0"
        },
    }
},
{
    "kretprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags. This is the same as 'read_cache_folio(mapping, index, NULL, NULL)', but with any new memory allocations done using the specified allocation flags. The most likely error from this function is EIO, but ENOMEM is possible and so is EINTR. If ->read_folio returns another error, that will be returned to the caller. The function expects mapping->invalidate_lock to be already held. Return: Uptodate folio on success, ERR_PTR() on failure.",
        "proto" :"struct folio *(*mapping_read_folio_gfp)(struct address_space *mapping, pgoff_t index, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_COMP, GFP_HIGH, GFP_NOFS, GFP_NOIO, GFP_NOWAIT]"
        }
    }
},
{
    "kprobe:mapping_read_folio_gfp": {
        "description": "Read into page cache, using specified allocation flags. This is the same as 'read_cache_folio(mapping, index, NULL, NULL)', but with any new memory allocations done using the specified allocation flags. The most likely error from this function is EIO, but ENOMEM is possible and so is EINTR. If ->read_folio returns another error, that will be returned to the caller. The function expects mapping->invalidate_lock to be already held. Return: Uptodate folio on success, ERR_PTR() on failure.",
        "proto" :"struct folio *(*mapping_read_folio_gfp)(struct address_space *mapping, pgoff_t index, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]"
        }
    }
},
{
    "kretprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags. If the page does not get brought uptodate, return -EIO. The function expects mapping->invalidate_lock to be already held. Return: up to date page on success, ERR_PTR() on failure.",
        "proto" :"struct page *(*read_cache_page_gfp)(struct address_space *mapping, pgoff_t index, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]"
        },
        "post": {
            "return": "!=null || ==ERR_PTR()"
        }
    }
},
{
    "kprobe:read_cache_page_gfp": {
        "description": "Read into page cache, using specified page allocation flags. If the page does not get brought uptodate, return -EIO. The function expects mapping->invalidate_lock to be already held. Return: up to date page on success, ERR_PTR() on failure.",
        "proto" :"struct page *(*read_cache_page_gfp)(struct address_space *mapping, pgoff_t index, gfp_t gfp)",
        "pre": {
            "mapping": "!=null",
            "index": ">=0",
            "gfp": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]",
        },
    }
},
{
    "kretprobe:generic_file_direct_write": {
        "description": "If a page can not be invalidated, return 0 to fall back to buffered write.",
        "proto" :"ssize_t generic_file_direct_write(struct kiocb iocb, struct iov_iter from)",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        },
    }
},
{
    "kprobe:generic_file_direct_write": {
        "description": "Please fill in the description here",
        "proto" :"static long (*generic_file_direct_write)(struct kiocb  iocb, struct iov_iter  from)",
        "pre": {
            "iocb": "Please fill in the condition here",
            "from": "Please fill in the condition here"
        },
    }
},
{
    "kretprobe:__generic_file_write_iter": {
        "description": "Write data to a file. It does all basic checks, removes SUID from the file, updates modification times and calls proper subroutines depending on whether we do direct IO or a standard buffered write. It expects i_rwsem to be grabbed unless we work on a block device or similar object which does not need locking at all. This function does not take care of syncing data in case of O_SYNC write. A caller has to handle it. This is mainly due to the fact that we want to avoid syncing under i_rwsem.",
        "proto" :"ssize_t (*__generic_file_write_iter)(struct kiocb *iocb, struct iov_iter *from)",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:__generic_file_write_iter": {
        "description": "Write data to a file. This function does all the work needed for actually writing data to a file. It does all basic checks, removes SUID from the file, updates modification times and calls proper subroutines depending on whether we do direct IO or a standard buffered write. It expects i_rwsem to be grabbed unless we work on a block device or similar object which does not need locking at all. This function does not take care of syncing data in case of O_SYNC write. A caller has to handle it. This is mainly due to the fact that we want to avoid syncing under i_rwsem.",
        "proto" :"ssize_t (*__generic_file_write_iter)(struct kiocb *iocb, struct iov_iter *from)",
        "pre": {
            "iocb": "!=null",
            "from": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio. The address_space is trying to release any data attached to a folio (presumably at folio->private). This will also be called if the private_2 flag is set on a page, indicating that the folio has other metadata associated with it. The @gfp argument specifies whether IO may be performed to release this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM & __GFP_FS). Return: %true if the release was successful, otherwise %false.",
        "proto" :"bool (*filemap_release_folio)(struct folio *folio, gfp_t gfp)",
        "pre": {
            "folio": "!=null",
            "gfp": "in [__GFP_IO, __GFP_RECLAIM, __GFP_FS]"
        },
    }
},
{
    "kprobe:filemap_release_folio": {
        "description": "Release fs-specific metadata on a folio. The address_space is trying to release any data attached to a folio (presumably at folio->private). This will also be called if the private_2 flag is set on a page, indicating that the folio has other metadata associated with it. The @gfp argument specifies whether IO may be performed to release this page (__GFP_IO), and whether the call may block (__GFP_RECLAIM & __GFP_FS).",
        "proto" :"bool (*filemap_release_folio)(struct folio *folio, gfp_t gfp)",
        "pre": {
            "folio": "!=null",
            "gfp": "in [__GFP_IO, __GFP_RECLAIM, __GFP_FS]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:ioremap_prot": {
        "description": "Maps physical memory into the kernel's virtual address space with specific protections. Disallows wrap-around or zero size.",
        "proto" :"static void* (*ioremap_prot)(phys_addr_t phys_addr, size_t size, unsigned long prot)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
            "prot": "in [PROT_NONE, PROT_READ, PROT_WRITE, PROT_EXEC]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ioremap_prot": {
        "description": "Maps physical memory into the kernel's virtual address space, disallowing wrap-around or zero size.",
        "proto": "static void* (*ioremap_prot)(phys_addr_t phys_addr, size_t size, unsigned long prot)",
        "pre": {
            "phys_addr": ">=0",
            "size": ">0",
            "prot": ">=0"
        },
        "post": {
            "return": "!=NULL"
        }
    }
},
{
    "kretprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address. Only IO mappings and raw PFN mappings are allowed. Returns zero and the pfn at @pfn on success, -ve otherwise.",
        "proto" :"int (*follow_pfn)(struct vm_area_struct *vma, unsigned long address, unsigned long *pfn)",
        "pre": {
            "vma": "!=null",
            "address": ">=0",
            "pfn": "!=null"
        },
    }
},
{
    "kprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address. Only IO mappings and raw PFN mappings are allowed. Returns zero and the pfn at @pfn on success, -ve otherwise.",
        "proto" :"int (*follow_pfn)(struct vm_area_struct *vma, unsigned long address, unsigned long *pfn)",
        "pre": {
            "vma": "!=null",
            "address": ">=0",
            "pfn": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc": {
        "description": "Allocates virtually contiguous memory. You can't specify __GFP_HIGHMEM with kmalloc() since kmalloc() returns only a logical address.",
        "proto" :"static void* (*__vmalloc)(unsigned long size, gfp_t gfp_mask)",
        "pre": {
            "size": "> 0",
            "gfp_mask": "!= __GFP_HIGHMEM"
        },
    }
},
{
    "__vmalloc": {
        "description": "Allocates virtually contiguous memory. You can't specify __GFP_HIGHMEM with kmalloc() since kmalloc() returns only a logical address.",
        "proto" :"static void* (*__vmalloc)(unsigned long size, gfp_t gfp_mask)",
        "pre": {
            "size": ">0",
            "gfp_mask": "!= __GFP_HIGHMEM"
        }
    }
},

{
    "kprobe:foo": {
        "description": "Description of what the function does.",
        "proto" :"static long (*foo)(void *bar, const void *baz, __u64 qux)",
        "pre": {
            "bar": "!=null",
            "baz": "!=null",
            "qux": "in [range of acceptable values]",
        },
    }
},
{
    "kretprobe:vmalloc_node_range": {
        "description": "Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space.",
        "proto" :"unsigned long (*vmalloc_node_range)(unsigned long size, unsigned long align, unsigned long start, unsigned long end, gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags, int node, const void *caller)",
        "pre": {
            "size": ">0",
            "align": ">=0",
            "start": ">=0",
            "end": ">start",
            "gfp_mask": "is valid gfp_t",
            "prot": "is valid pgprot_t",
            "vm_flags": "is valid vm_flags",
            "node": "is valid node",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:vmalloc_node_range": {
        "description": "Allocate enough pages to cover @size from the page level allocator and map them into contiguous kernel virtual space.",
        "proto" :"unsigned long (*vmalloc_node_range)(unsigned long size, unsigned long align, unsigned long start, unsigned long end, gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags, int node, const void *caller)",
        "pre": {
            "size": "> 0",
            "align": ">= 0",
            "start": ">= 0",
            "end": "> start",
            "gfp_mask": "!=null",
            "prot": "!=null",
            "vm_flags": ">= 0",
            "node": ">= 0",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:__vmalloc_node_range": {
        "description": "Allocates virtually contiguous memory region of size *size* with protection *prot*, using the method specified by *gfp_mask*. The memory is allocated on node *node*. The memory region begins at *start* and ends at *end*. The function returns a pointer to the allocated memory.",
        "proto" :"void *__vmalloc_node_range(unsigned long size, unsigned long align, unsigned long start, unsigned long end, gfp_t gfp_mask, pgprot_t prot, unsigned long vm_flags, int node, const void *caller)",
        "pre": {
            "size": "> 0",
            "align": ">= 0",
            "start": "< end",
            "end": "> start",
            "gfp_mask": "!= (__GFP_HIGHMEM | __GFP_COMP)",
            "prot": "!=null",
            "vm_flags": ">= 0",
            "node": ">= 0",
            "caller": "!=null"
        }
    }
},
{
    "__vmalloc": {
        "description": "You can't specify __GFP_HIGHMEM with kmalloc() since kmalloc() returns only a logical address.",
        "proto" :"void *__vmalloc(unsigned long size, gfp_t gfp_mask)",
        "pre": {
            "size": ">=0",
            "gfp_mask": "!=__GFP_HIGHMEM",
        },
    }
},
{
    "kretprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address. Only IO mappings and raw PFN mappings are allowed. Returns zero and the pfn at @pfn on success, -ve otherwise.",
        "proto" :"int follow_pfn(struct vm_area_struct *vma, unsigned long address, unsigned long *pfn)",
        "pre": {
            "vma": "!=null",
            "address": "is valid user virtual address",
            "pfn": "!=null"
        },
        "post": {
            "return": "in [0, -ve]"
        }
    }
},
{
    "kprobe:follow_pfn": {
        "description": "Look up PFN at a user virtual address. Only IO mappings and raw PFN mappings are allowed. Returns zero and the pfn at @pfn on success, -ve otherwise.",
        "proto" :"static long (*follow_pfn)(struct vm_area_struct *vma, unsigned long address, unsigned long *pfn)",
        "pre": {
            "vma": "!=null",
            "address": "valid user virtual address",
            "pfn": "pointer to store the found PFN",
        },
    }
},
{
    "kretprobe:usercopy_abort": {
        "description": "__check_object_size() function. Normal stack buffer usage should never trip the checks, and kernel text addressing will always trip the check. For cache objects, it is checking that only the whitelisted range of bytes for a given cache is being accessed (via the cache's usersize and useroffset fields). To adjust a cache whitelist, use the usercopy-aware kmem_cache_create_usercopy() function to create the cache (and carefully audit the whitelist range).",
        "proto" :"void __noreturn (*usercopy_abort)(const char *name, const char *detail, bool to_user, unsigned long offset, unsigned long len)",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "is bool",
            "offset": "is unsigned long",
            "len": "is unsigned long"
        }
    }
},
{
    "kprobe:usercopy_abort": {
        "description": "__check_object_size() function. Normal stack buffer usage should never trip the checks, and kernel text addressing will always trip the check. For cache objects, it is checking that only the whitelisted range of bytes for a given cache is being accessed (via the cache's usersize and useroffset fields). To adjust a cache whitelist, use the usercopy-aware kmem_cache_create_usercopy() function to create the cache (and carefully audit the whitelist range).",
        "proto" :"void __noreturn (*usercopy_abort)(const char *name, const char *detail, bool to_user, unsigned long offset, unsigned long len)",
        "pre": {
            "name": "!=null",
            "detail": "!=null",
            "to_user": "in [true, false]",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:kasan_poison": {
        "description": "Perform shadow offset calculation based on untagged address, as some of the callers (e.g. kasan_poison_object_data) pass tagged addresses to this function.",
        "proto" :"static long (*kasan_poison)(const void *addr, size_t size, u8 value, bool init)",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": "in [0, 255]",
            "init": "is bool"
        },
    }
},
{
    "kprobe:kasan_poison": {
        "description": "Perform shadow offset calculation based on untagged address, as some of the callers (e.g. kasan_poison_object_data) pass tagged addresses to this function.",
        "proto" :"void kasan_poison(const void  addr, size_t size, u8 value, bool init)",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
            "value": "in [0, 255]",
            "init": "in [true, false]"
        },
    }
},
{
    "__kasan_kmalloc": {
        "description": "Kernel function for memory allocation with KASAN support.",
        "proto" :"__kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size, gfp_t flags)",
        "pre": {
            "cache": "!=null",
            "object": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "__kasan_kmalloc": {
        "description": "The object has already been unpoisoned by kasan_slab_alloc() for kmalloc() or by kasan_krealloc() for krealloc().",
        "proto" :"__kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size, gfp_t flags)",
        "pre": {
            "cache": "!=null",
            "object": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:kmsan_copy_page_meta": {
        "description": "Copy metadata from one page to another. If KMSAN is not enabled, or if either page does not have metadata, the function returns without doing anything.",
        "proto" :"void kmsan_copy_page_meta(struct page *dst, struct page *src)",
        "pre": {
            "dst": "!=null && page_has_metadata(dst)",
            "src": "!=null && page_has_metadata(src)"
        },
    }
},
{
    "kprobe:kmsan_copy_page_meta": {
        "description": "Copies metadata from one page to another. If KMSAN is not enabled, in runtime, or if the destination or source pages do not have metadata, the function returns. If the source page does not have metadata, the destination page's memory is unpoisoned.",
        "proto" :"void kmsan_copy_page_meta(struct page *dst, struct page *src)",
        "pre": {
            "dst": "!=null && page_has_metadata(dst)",
            "src": "!=null && page_has_metadata(src)"
        }
    }
},
{
    "kretprobe:__msan_metadata_ptr_for_load_n": {
        "description": "Please provide the function description here",
        "proto" :"__msan_metadata_ptr_for_load_n(void *addr, uintptr_t size)",
        "pre": {
            "addr": "!=null",
            "size": "Please provide the condition for size here"
        }
    }
},



{
    "kretprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "proto" :"void (*__msan_instrument_asm_store)(void *addr, uintptr_t size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:__msan_instrument_asm_store": {
        "description": "__msan_instrument_asm_store() may be called for inline assembly code when entering or leaving IRQ. We omit the check for kmsan_in_runtime() to ensure the memory written to in these cases is also marked as initialized.",
        "proto" :"void (*__msan_instrument_asm_store)(void *addr, uintptr_t size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:__msan_memmove": {
        "description": "Moves n bytes from src to dst. If n is zero, the function does nothing.",
        "proto" :"void __msan_memmove(void dst, const void src, uintptr_t n)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "__msan_memmove": {
        "description": "Some people call memmove() with zero length.",
        "proto" :"void __msan_memmove(void dst, const void src, uintptr_t n)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0",
        },
    }
},
{
    "kretprobe:__msan_memcpy": {
        "description": "Copies n bytes from memory area src to memory area dst. If n is zero, the function does nothing.",
        "proto" :"void (*__msan_memcpy)(void *dst, const void *src, uintptr_t n)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "__msan_memcpy": {
        "description": "Copies n bytes from memory area src to memory area dst. If n is zero, the function does nothing.",
        "proto": "void  __msan_memcpy(void  dst, const void  src, uintptr_t n)",
        "pre": {
            "dst": "!=null",
            "src": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:kmsan_internal_unpoison_memory": {
        "description": "Unpoison a memory region.",
        "proto" :"void (*kmsan_internal_unpoison_memory)(void *dst, uintptr_t n, bool /*checked)",
        "pre": {
            "dst": "!=null",
            "n": ">0",
            "/*checked": "in [true, false]"
        },
    }
},
{
    "kprobe:kmsan_internal_unpoison_memory": {
        "description": "A wrapper around __memset(dst, c, n) function. It doesn't pass parameter metadata, so it is impossible to use shadow of @c to set up the shadow for @dst.",
        "proto" :"__msan_memset(void  dst, int c, uintptr_t n)",
        "pre": {
            "dst": "!=null",
            "c": "!=null",
            "n": ">0",
        },
    }
},
{
    "kretprobe:__msan_chain_origin": {
        "description": "Creating new origins may allocate memory.",
        "proto" :"depot_stack_handle_t __msan_chain_origin(depot_stack_handle_t origin)",
        "pre": {
            "origin": "!=null"
        },
    },
    "kretprobe:kmsan_enter_runtime": {
        "description": "Enter KMSAN runtime.",
        "proto" :"void kmsan_enter_runtime()",
        "pre": {},
    },
    "kretprobe:kmsan_internal_chain_origin": {
        "description": "Internal chain origin in KMSAN.",
        "proto" :"depot_stack_handle_t kmsan_internal_chain_origin(depot_stack_handle_t origin)",
        "pre": {
            "origin": "!=null"
        },
    },
    "kretprobe:kmsan_leave_runtime": {
        "description": "Leave KMSAN runtime.",
        "proto" :"void kmsan_leave_runtime()",
        "pre": {},
    },
    "kretprobe:user_access_restore": {
        "description": "Restore user access.",
        "proto" :"void user_access_restore(unsigned long ua_flags)",
        "pre": {
            "ua_flags": ">=0"
        },
    }
},
{
    "kprobe:__msan_chain_origin": {
        "description": "Creating new origins may allocate memory.",
        "proto" :"depot_stack_handle_t __msan_chain_origin(depot_stack_handle_t origin)",
        "pre": {
            "origin": "!=null",
        },
    }
},
{
    "kretprobe:__msan_poison_alloca": {
        "description": "With frame pointers enabled, it is possible to quickly fetch the second frame of the caller stack without calling the unwinder. Without them, simply do not bother.",
        "proto": "void __msan_poison_alloca(void  address, uintptr_t size, char  descr)",
        "pre": {
            "address": "!=null",
            "size": ">=0",
            "descr": "!=null"
        }
    }
},
{
    "kprobe:__msan_poison_alloca": {
        "description": "Poisons a region of memory. The region starts at address and has size bytes. The description is stored in descr.",
        "proto" :"void __msan_poison_alloca(void  address, uintptr_t size, char  descr)",
        "pre": {
            "address": "!=null",
            "size": ">=0",
            "descr": "!=null"
        },
    }
},
{
    "kretprobe:__msan_unpoison_alloca": {
        "description": "Unpoison a memory region of a certain size starting from a given address.",
        "proto" :"void __msan_unpoison_alloca(void *address, uintptr_t size)",
        "pre": {
            "address": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:__msan_unpoison_alloca": {
        "description": "Unpoison a memory region of a given size starting from a given address.",
        "proto" :"void __msan_unpoison_alloca(void *address, uintptr_t size)",
        "pre": {
            "address": "!=null",
            "size": ">0",
        },
    }
},
{
    "kretprobe:0, /*size": {
        "description": "Description of the function goes here",
        "proto" :"Function prototype goes here",
        "pre": {
            "param1": "Condition for param1",
            "param2": "Condition for param2",
            "...": "...",
        },
    }
},
{
    "kprobe:0, /*size": {
        "description": "Please provide a description for this function",
        "proto" :"Please provide the prototype for this function",
        "pre": {
            "origin": "Please provide the constraints for this argument",
        },
    }
},
{
    "kretprobe:kmsan_copy_to_user": {
        "description": "At this point we've copied the memory already. It's hard to check it before copying, as the size of actually copied buffer is unknown.",
        "proto" :"kmsan_copy_to_user(void __user  to, const void  from, size_t to_copy, size_t left)",
        "pre": {
            "to": "!=null",
            "from": "!=null",
            "to_copy": ">=0",
            "left": ">=0"
        }
    }
},
{
    "kprobe:kmsan_copy_to_user": {
        "description": "At this point we've copied the memory already. It's hard to check it before copying, as the size of actually copied buffer is unknown.",
        "proto" :"kmsan_copy_to_user(void __user  to, const void  from, size_t to_copy, size_t left)",
        "pre": {
            "to": "your_constraint_here",
            "from": "your_constraint_here",
            "to_copy": "your_constraint_here",
            "left": "your_constraint_here"
        },
    }
},
{
    "kretprobe:kmsan_poison_memory": {
        "description": "The users may want to poison/unpoison random memory.",
        "proto" :"kmsan_poison_memory(const void *address, size_t size, gfp_t flags)",
        "pre": {
            "address": "!=null",
            "size": ">=0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace with actual flag values
        },
    }
},
{
    "kprobe:kmsan_poison_memory": {
        "description": "The users may want to poison/unpoison random memory.",
        "proto" :"kmsan_internal_poison_memory((void *)address, size_t size, gfp_t flags)",
        "pre": {
            "address": "!=null",
            "size": ">=0",
            "flags": "any valid gfp_t flags"
        },
    }
},
{
    "kretprobe:kmsan_unpoison_memory": {
        "description": "The users may want to poison/unpoison random memory.",
        "proto" :"kmsan_unpoison_memory(const void *address, size_t size)",
        "pre": {
            "address": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:kmsan_unpoison_memory": {
        "description": "The users may want to poison/unpoison random memory.",
        "proto" :"kmsan_unpoison_memory(const void *address, size_t size)",
        "pre": {
            "address": "!=null",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:kmsan_check_memory": {
        "description": "Checks if the memory is enabled for KernelMemorySanitizer (KMSAN).",
        "proto" :"void kmsan_check_memory(const void *addr, size_t size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kprobe:kmsan_check_memory": {
        "description": "Check memory for a given address and size. If kmsan is not enabled, it returns immediately. Otherwise, it checks the memory using kmsan_internal_check_memory.",
        "proto" :"static void (*kmsan_check_memory)(const void *addr, size_t size)",
        "pre": {
            "addr": "!=null",
            "size": ">=0"
        }
    }
},
{
    "kretprobe:invalidate_bdev": {
        "description": "Description of the function",
        "proto" :"static long (*invalidate_bdev)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null",
        },
    }
},
{
    "kprobe:invalidate_bdev": {
        "description": "Invalidates the block device's buffer heads and drains all lru add caches if there are any pages in the device's address space.",
        "proto" :"void (*invalidate_bdev)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null",
            "bdev->bd_inode": "!=null",
            "bdev->bd_inode->i_mapping": "!=null"
        }
    }
},
{
    "kretprobe:set_blocksize": {
        "description": "Size must be a power of two, and between 512 and PAGE_SIZE",
        "proto" :"static long (*set_blocksize)(struct block_device *bdev, int size)",
        "pre": {
            "bdev": "!=null",
            "size": ">=512 && <=PAGE_SIZE && is_power_of_2(size)"
        },
    }
},
{
    "kprobe:set_blocksize": {
        "description": "Size must be a power of two, and between 512 and PAGE_SIZE",
        "proto" :"static int (*set_blocksize)(struct block_device *bdev, int size)",
        "pre": {
            "bdev": "!=null",
            "size": ">=512 && <=PAGE_SIZE && is_power_of_2(size)"
        },
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size for the super block. If the block size is set successfully, return 0. The size is a power of two and its value is between 512 and PAGE_SIZE.",
        "proto" :"static long (*sb_set_blocksize)(struct super_block *sb, int size)",
        "pre": {
            "sb": "!=null",
            "size": "is power of two and in [512, PAGE_SIZE]"
        },
        "post": {
            "sb->s_blocksize": "=size",
            "sb->s_blocksize_bits": "=blksize_bits(size)",
            "return": "=sb->s_blocksize"
        }
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Sets the block size for the super block. If the block size is set successfully, returns 0. The size must be a power of two and its value is between 512 and PAGE_SIZE.",
        "proto": "int sb_set_blocksize(struct super_block *sb, int size)",
        "pre": {
            "sb": "!=null",
            "size": "is power of two and in [512, PAGE_SIZE]"
        }
    }
},
{
    "kretprobe:sb_set_blocksize": {
        "description": "Set the block size for the super block. If we get here, we know size is power of two and it's value is between 512 and PAGE_SIZE.",
        "proto" :"int sb_set_blocksize(struct super_block *sb, int size)",
        "pre": {
            "sb": "!=null",
            "size": "is power of two and in [512, PAGE_SIZE]"
        },
    }
},
{
    "kprobe:sb_set_blocksize": {
        "description": "Sets the block size for the super block. If we get here, we know size is power of two and it's value is between 512 and PAGE_SIZE.",
        "proto" :"int sb_set_blocksize(struct super_block *sb, int size)",
        "pre": {
            "sb": "!=null",
            "size": "is power of two and in [512, PAGE_SIZE]"
        },
    }
},
{
    "kretprobe:freeze_bdev": {
        "description": "When it becomes 0, thaw_bdev() will unfreeze actually.",
        "proto" :"int (*freeze_bdev)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null"
        }
    }
},
{
    "kprobe:freeze_bdev": {
        "description": "thaw_bdev(). When it becomes 0, thaw_bdev() will unfreeze actually.",
        "proto" :"int (*freeze_bdev)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null"
        }
    }
},
{
    "kretprobe:invalidate_inode_pages2_range": {
        "description": "Someone else has handle exclusively open. Try invalidating instead. The 'end' argument is inclusive so the rounding is safe.",
        "proto" :"static void (*invalidate_inode_pages2_range)(struct block_device *bdev, ...)",
        "pre": {
            "bdev": "!=null",
            "...": "..."
        },
    }
},
{
    "kprobe:invalidate_inode_pages2_range": {
        "description": "Someone else has handle exclusively open. Try invalidating instead. The 'end' argument is inclusive so the rounding is safe.",
        "proto" :"static void (*invalidate_inode_pages2_range)(struct block_device *bdev, long lstart, long lend)",
        "pre": {
            "bdev": "!=null",
            "lstart": ">=0",
            "lend": ">=lstart",
        },
    }
},
{
    "kretprobe:blkdev_get_by_dev": {
        "description": "Might sleep. Returns reference to the block_device on success, ERR_PTR(-errno) on failure.",
        "proto" :"struct block_device *(*blkdev_get_by_dev)(dev_t dev, blk_mode_t mode, void *holder, const struct blk_holder_ops *hops)",
        "pre": {
            "dev": "!=null",
            "mode": "in [FMODE_READ, FMODE_WRITE, FMODE_EXCL, FMODE_EXEC]",
            "holder": "!=null",
            "hops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:blkdev_get_by_dev": {
        "description": "Might sleep. Returns reference to the block_device on success, ERR_PTR(-errno) on failure.",
        "proto" :"struct block_device *(*blkdev_get_by_dev)(dev_t dev, blk_mode_t mode, void *holder, const struct blk_holder_ops *hops)",
        "pre": {
            "dev": ">=0",
            "mode": "in [FMODE_READ, FMODE_WRITE, FMODE_EXCL]",
            "holder": "!=null",
            "hops": "!=null"
        }
    }
},
{
    "kretprobe:blkdev_get_no_open": {
        "description": "Your function description here",
        "proto" :"static struct block_device *(*blkdev_get_no_open)(dev_t dev)",
        "pre": {
            "dev": "Your constraints here",
        },
    }
},
{
    "kprobe:blkdev_get_no_open": {
        "description": "Description of the function",
        "proto" :"Function prototype",
        "pre": {
            "bdev": "!=null",
            "inode": "!=null",
            "dev": "!=null",
            "part": "!=null",
            "mode": "in [mode1, mode2, mode3]",
        },
    }
},
{
    "kretprobe:blkdev_get_by_dev": {
        "description": "Get a block device by its device identifier, mode, holder, and hops.",
        "proto" :"struct block_device *(*blkdev_get_by_dev)(dev_t dev, fmode_t mode, void *holder, int hops)",
        "pre": {
            "dev": "!=null",
            "mode": "in [FMODE_READ, FMODE_WRITE, FMODE_EXCL, FMODE_OPENED]",
            "holder": "!=null",
            "hops": ">=0",
        },
    }
},
{
    "kprobe:blkdev_put": {
        "description": "This function seems to handle block device operations, including checking if the device is read-only, syncing the block device, and releasing the block device.",
        "proto" :"void blkdev_put(struct block_device *bdev, void *holder)",
        "pre": {
            "bdev": "!=null",
            "holder": "!=null"
        },
    }
},
{
    "kretprobe:__invalidate_device": {
        "description": "Invalidates a block device",
        "proto" :"__invalidate_device(struct block_device bdev, bool kill_dirty)",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "is [true, false]"
        },
    }
},
{
    "kprobe:__invalidate_device": {
        "description": "Your function description here",
        "proto" :"static long (*__invalidate_device)(struct block_device *bdev, bool kill_dirty)",
        "pre": {
            "bdev": "!=null",
            "kill_dirty": "is bool",
        },
    }
},
{
    "kretprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set. The function will be called for each started request. Return true to continue iterating tags, false to stop. We grab one request reference before calling the function and release it after the function returns.",
        "proto" :"void (*blk_mq_tagset_busy_iter)(struct blk_mq_tag_set *tagset, busy_tag_iter_fn *fn, void *priv)",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_busy_iter": {
        "description": "Iterate over all started requests in a tag set. The function will be called for each started request. Return true to continue iterating tags, false to stop. We grab one request reference before calling the function and release it after the function returns.",
        "proto" :"void (*blk_mq_tagset_busy_iter)(struct blk_mq_tag_set *tagset, busy_tag_iter_fn *fn, void *priv)",
        "pre": {
            "tagset": "!=null",
            "fn": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished. This function has to be run after all IO queues are shutdown.",
        "proto" :"void (*blk_mq_tagset_wait_completed_request)(struct blk_mq_tag_set *tagset)",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_tagset_wait_completed_request": {
        "description": "Wait until all scheduled request completions have finished. This function has to be run after all IO queues are shutdown.",
        "proto" :"void (*blk_mq_tagset_wait_completed_request)(struct blk_mq_tag_set *tagset)",
        "pre": {
            "tagset": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide. The tag field in struct request is unique per hardware queue but not over all hardware queues. Hence this function that returns a tag with the hardware context index in the upper bits and the per hardware queue tag in the lower bits. When called for a request that is queued on a non-multiqueue request queue, the hardware context index is set to zero.",
        "proto" :"u32 (*blk_mq_unique_tag)(struct request *rq)",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_unique_tag": {
        "description": "Return a tag that is unique queue-wide. The tag field in struct request is unique per hardware queue but not over all hardware queues. Hence this function that returns a tag with the hardware context index in the upper bits and the per hardware queue tag in the lower bits. When called for a request that is queued on a non-multiqueue request queue, the hardware context index is set to zero.",
        "proto" :"u32 (*blk_mq_unique_tag)(struct request *rq)",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "proto" :"int (*blkdev_issue_flush)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null"
        }
    }
},
{
    "kprobe:blkdev_issue_flush": {
        "description": "Issue a flush for the block device in question.",
        "proto" :"int (*blkdev_issue_flush)(struct block_device *bdev)",
        "pre": {
            "bdev": "!=null",
        },
    }
},

{
    "kprobe:fs_bio_set": {
        "description": "The bio_set containing bio and iovec memory pools used by IO code that does not need private memory pools.",
        "proto" :"void (*fs_bio_set)(struct bio_set *bs, struct bio *bio, struct iovec *iov)",
        "pre": {
            "bs": "!=null",
            "bio": "!=null",
            "iov": "!=null"
        },
    }
},
{
    "kretprobe:bio_init": {
        "description": "Initializes a bio structure for IO operations. It should be paired with bio_uninit() when IO has completed, or when the bio is released.",
        "proto" :"void (*bio_init)(struct bio *bio, struct block_device *bdev, struct bio_vec *table, unsigned short max_vecs, blk_opf_t opf)",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "table": "!=null",
            "max_vecs": ">=0",
            "opf": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_RESET_ALL, REQ_OP_WRITE_LOCK, REQ_OP_WRITE_UNLOCK, REQ_OP_ZONE_ACTIVE, REQ_OP_ZONE_INACTIVE]"
        }
    }
},
{
    "kprobe:bio_init": {
        "description": "bio_init() with bio_uninit() when IO has completed, or when the bio is released.",
        "proto" :"void bio_init(struct bio *bio, struct block_device *bdev, struct bio_vec *table, unsigned short max_vecs, blk_opf_t opf)",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "table": "!=null",
            "max_vecs": ">=0",
            "opf": "!=null"
        }
    }
},
{
    "kretprobe:bio_reset": {
        "description": "The only fields that are preserved are the ones that are initialized by bio_alloc_bioset(). See comment in struct bio.",
        "proto" :"void (*bio_reset)(struct bio *bio, struct block_device *bdev, blk_opf_t opf)",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "is initialized"
        },
    }
},
{
    "kprobe:bio_reset": {
        "description": "The only fields that are preserved are the ones that are initialized by bio_alloc_bioset(). See comment in struct bio.",
        "proto" :"void (*bio_reset)(struct bio *bio, struct block_device *bdev, blk_opf_t opf)",
        "pre": {
            "bio": "!=null",
            "bdev": "!=null",
            "opf": "!=null",
        },
    }
},
{
    "kretprobe:bio_chain": {
        "description": "Chain bio completions. The caller won't have a bi_end_io called when @bio completes - instead, @parent's bi_end_io won't be called until both @parent and @bio have completed; the chained bio will also be freed when it completes. The caller must not set bi_private or bi_end_io in @bio.",
        "proto" :"void (*bio_chain)(struct bio *bio, struct bio *parent)",
        "pre": {
            "bio": "!=null && bi_private==null && bi_end_io==null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:bio_chain": {
        "description": "Chain bio completions. The caller won't have a bi_end_io called when @bio completes - instead, @parent's bi_end_io won't be called until both @parent and @bio have completed; the chained bio will also be freed when it completes. The caller must not set bi_private or bi_end_io in @bio.",
        "proto" :"void (*bio_chain)(struct bio *bio, struct bio *parent)",
        "pre": {
            "bio": "!=null && bi_private==null && bi_end_io==null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:bio_kmalloc": {
        "description": "Use kmalloc to allocate a bio (including bvecs). The bio must be initialized using bio_init() before use. To free a bio returned from this function use kfree() after calling bio_uninit(). A bio returned from this function can be reused by calling bio_uninit() before calling bio_init() again. Note that unlike bio_alloc() or bio_alloc_bioset() allocations from this function are not backed by a mempool can fail. Do not use this function for allocations in the file system IO path. Returns: Pointer to new bio on success, NULL on failure.",
        "proto": "struct bio *(*bio_kmalloc)(unsigned short nr_vecs, gfp_t gfp_mask)",
        "pre": {
            "nr_vecs": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_HIGHMEM, GFP_NOIO, GFP_NOFS, GFP_NOWAIT, GFP_THISNODE, GFP_RECLAIMABLE, GFP_MOVABLE_MASK, GFP_TRANSHUGE, GFP_TRANSHUGE_LIGHT, GFP_ACCOUNT, GFP_KERNEL_ACCOUNT, GFP_NOWAIT_ACCOUNT, GFP_NOTRACK, GFP_NOACCOUNT, GFP_DIRECT_RECLAIM, GFP_WRITE, GFP_HARDWALL, GFP_MEMALLOC, GFP_NORETRY, GFP_NO_GFP_WAIT, GFP_NOFAIL, GFP_FAIL_ON_MISS, GFP_EXCESS_RET, GFP_ATOMIC_HIGH, GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:bio_kmalloc": {
        "description": "Use kmalloc to allocate a bio (including bvecs). The bio must be initialized using bio_init() before use. To free a bio returned from this function use kfree() after calling bio_uninit(). A bio returned from this function can be reused by calling bio_uninit() before calling bio_init() again. Note that unlike bio_alloc() or bio_alloc_bioset() allocations from this function are not backed by a mempool can fail. Do not use this function for allocations in the file system IO path. Returns: Pointer to new bio on success, NULL on failure.",
        "proto" :"struct bio *(*bio_kmalloc)(unsigned short nr_vecs, gfp_t gfp_mask)",
        "pre": {
            "nr_vecs": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_HIGHMEM, GFP_NOIO, GFP_NOFS, GFP_NOWAIT, GFP_THISNODE, GFP_RECLAIMABLE, GFP_MOVABLE_MASK, GFP_TRANSHUGE, GFP_TRANSHUGE_LIGHT, GFP_ACCOUNT, GFP_KERNEL_ACCOUNT, GFP_NOWAIT_ACCOUNT, GFP_NOTRACK, GFP_NOACCOUNT, GFP_DIRECT_RECLAIM, GFP_WRITE, GFP_HARDWALL, GFP_MEMALLOC, GFP_NORETRY, GFP_NO_GFP_WAIT, GFP_NOFAIL, GFP_FAIL_ON_MISS, GFP_EXCESS_RET, GFP_ATOMIC_HIGH, GFP_KSWAPD_RECLAIM]"
        },
    }
},


{
    "kretprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec. The caller owns the returned bio, but not the actual data it points to. The caller must ensure that the return bio is not freed before @bio_src.",
        "proto" :"struct bio *(*bio_alloc_clone)(struct block_device *bdev, struct bio *bio_src, gfp_t gfp, struct bio_set *bs)",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "is valid gfp_t value",
            "bs": "!=null"
        },
    }
},
{
    "kprobe:bio_alloc_clone": {
        "description": "Clone a bio that shares the original bio's biovec. The caller owns the returned bio, but not the actual data it points to. The caller must ensure that the return bio is not freed before @bio_src.",
        "proto" :"struct bio *(*bio_alloc_clone)(struct block_device *bdev, struct bio *bio_src, gfp_t gfp, struct bio_set *bs)",
        "pre": {
            "bdev": "!=null",
            "bio_src": "!=null",
            "gfp": "is valid allocation priority",
            "bs": "!=null",
        },
    }
},
{
    "kretprobe:bio_init_clone": {
        "description": "Initialize a new bio in caller provided memory that is a clone of @bio_src. The caller owns the returned bio, but not the actual data it points to. The caller must ensure that @bio_src is not freed before @bio.",
        "proto" :"int (*bio_init_clone)(struct block_device *bdev, struct bio *bio, struct bio *bio_src, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": ">=0"
        },
    }
},
{
    "kprobe:bio_init_clone": {
        "description": "Initialize a new bio in caller provided memory that is a clone of @bio_src. The caller owns the returned bio, but not the actual data it points to. The caller must ensure that @bio_src is not freed before @bio.",
        "proto" :"int (*bio_init_clone)(struct block_device *bdev, struct bio *bio, struct bio *bio_src, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "bio": "!=null",
            "bio_src": "!=null",
            "gfp": ">=0"
        },
    }
},
{
    "kretprobe:bio_add_pc_page": {
        "description": "Attempt to add a page to the bio_vec maplist. This can fail for a number of reasons, such as the bio being full or target block device limitations. The target block device must allow bio's up to PAGE_SIZE, so it is always possible to add a single page to an empty bio. This should only be used by passthrough bios.",
        "proto" :"int (*bio_add_pc_page)(struct request_queue *q, struct bio *bio, struct page *page, unsigned int len, unsigned int offset)",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        },
    }
},
{
    "kprobe:bio_add_pc_page": {
        "description": "Attempt to add a page to the bio_vec maplist. This can fail for a number of reasons, such as the bio being full or target block device limitations. The target block device must allow bio's up to PAGE_SIZE, so it is always possible to add a single page to an empty bio. This should only be used by passthrough bios.",
        "proto" :"int (*bio_add_pc_page)(struct request_queue *q, struct bio *bio, struct page *page, unsigned int len, unsigned int offset)",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        },
    }
},
{
    "kretprobe:__bio_add_page": {
        "description": "Add the data at @page + @off to @bio as a new bvec. The caller must ensure that @bio has space for another bvec.",
        "proto" :"void (*__bio_add_page)(struct bio *bio, struct page *page, unsigned int len, unsigned int off)",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kprobe:__bio_add_page": {
        "description": "Add page(s) to a bio in a new segment. The data at @page + @off is added to @bio as a new bvec. The caller must ensure that @bio has space for another bvec.",
        "proto" :"void (*__bio_add_page)(struct bio *bio, struct page *page, unsigned int len, unsigned int off)",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "off": ">=0"
        }
    }
},
{
    "kretprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio. Filesystems that use folios can call this function instead of calling bio_add_page() for each page in the folio. If @off is bigger than PAGE_SIZE, this function can create a bio_vec that starts in a page after the bv_page. BIOs do not support folios that are 4GiB or larger.",
        "proto" :"bool (*bio_add_folio)(struct bio *bio, struct folio *folio, size_t len, size_t off)",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": "<=UINT_MAX && <4GiB",
            "off": "<=UINT_MAX && <PAGE_SIZE"
        },
    }
},
{
    "kprobe:bio_add_folio": {
        "description": "Attempt to add part of a folio to a bio. Filesystems that use folios can call this function instead of calling bio_add_page() for each page in the folio. If @off is bigger than PAGE_SIZE, this function can create a bio_vec that starts in a page after the bv_page. BIOs do not support folios that are 4GiB or larger. Return: Whether the addition was successful.",
        "proto" :"bool (*bio_add_folio)(struct bio *bio, struct folio *folio, size_t len, size_t off)",
        "pre": {
            "bio": "!=null",
            "folio": "!=null",
            "len": "<=UINT_MAX && >0",
            "off": "<=UINT_MAX && >=0",
        },
    }
},
{
    "kretprobe:submit_bio_wait": {
        "description": "Submit a bio, and wait until it completes. Returns 0 on success, or the error from bio_endio() on failure.",
        "proto" :"int (*submit_bio_wait)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        },
        "post": {
            "return": "in [0, error from bio_endio()]"
        }
    }
},
{
    "kprobe:submit_bio_wait": {
        "description": "Submit a bio, and wait until it completes. Returns 0 on success, or the error from bio_endio() on failure. Unlike to how submit_bio() is usually used, this function does not result in bio reference to be consumed. The caller must drop the reference on his own.",
        "proto" :"int (*submit_bio_wait)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:bio_split": {
        "description": "Allocates and returns a new bio which represents @sectors from the start of @bio, and updates @bio to represent the remaining sectors. Unless this is a discard request the newly allocated bio will point to @bio's bi_io_vec. It is the caller's responsibility to ensure that neither @bio nor @bs are freed before the split bio.",
        "proto" :"struct bio *(*bio_split)(struct bio *bio, int sectors, gfp_t gfp, struct bio_set *bs)",
        "pre": {
            "bio": "!=null",
            "sectors": ">=0",
            "gfp": ">=0",
            "bs": "!=null"
        }
    }
},
{
    "kprobe:bio_split": {
        "description": "Allocates and returns a new bio which represents @sectors from the start of @bio, and updates @bio to represent the remaining sectors. Unless this is a discard request the newly allocated bio will point to @bio's bi_io_vec. It is the caller's responsibility to ensure that neither @bio nor @bs are freed before the split bio.",
        "proto" :"struct bio *(*bio_split)(struct bio *bio, int sectors, gfp_t gfp, struct bio_set *bs)",
        "pre": {
            "bio": "!=null",
            "sectors": ">=0",
            "gfp": "is valid gfp_t value",
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:bioset_exit": {
        "description": "Deallocate or clean up the resources initialized by bioset_init().",
        "proto" :"void (*bioset_exit)(struct bio_set *bs)",
        "pre": {
            "bs": "!=null"
        },
    }
},
{
    "kprobe:bioset_exit": {
        "description": "Deallocate or clean up a bioset that was previously initialized with bioset_init().",
        "proto" :"void (*bioset_exit)(struct bio_set *bs)",
        "pre": {
            "bs": "!=null"
        }
    }
},
{
    "kretprobe:disk_check_media_change": {
        "description": "Check whether a removable media has been changed, and attempt to free all dentries and inodes and invalidates all block device page cache entries in that case. Returns %true if the media has changed, or %false if not.",
        "proto" :"bool disk_check_media_change(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:disk_check_media_change": {
        "description": "Check whether a removable media has been changed, and attempt to free all dentries and inodes and invalidates all block device page cache entries in that case. Returns %true if the media has changed, or %false if not.",
        "proto" :"bool (*disk_check_media_change)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements. Returns the number of elements required in a scatterlist corresponding to the integrity metadata in a bio.",
        "proto" :"int (*blk_rq_count_integrity_sg)(struct request_queue *q, struct bio *bio)",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_count_integrity_sg": {
        "description": "Count number of integrity scatterlist elements. Returns the number of elements required in a scatterlist corresponding to the integrity metadata in a bio.",
        "proto" :"int (*blk_rq_count_integrity_sg)(struct request_queue *q, struct bio *bio)",
        "pre": {
            "q": "!=null",
            "bio": "!=null"
        }
    }
},
{
    "kretprobe:blk_rq_map_integrity_sg": {
        "description": "Map the integrity vectors in request into a scatterlist. The scatterlist must be big enough to hold all elements. I.e. sized using blk_rq_count_integrity_sg().",
        "proto" :"int (*blk_rq_map_integrity_sg)(struct request_queue *q, struct bio *bio, struct scatterlist *sglist)",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null"
        }
    }
},
{
    "kprobe:blk_rq_map_integrity_sg": {
        "description": "Map the integrity vectors in request into a scatterlist. The scatterlist must be big enough to hold all elements. I.e. sized using blk_rq_count_integrity_sg().",
        "proto" :"int (*blk_rq_map_integrity_sg)(struct request_queue *q, struct bio *bio, struct scatterlist *sglist)",
        "pre": {
            "q": "!=null",
            "bio": "!=null",
            "sglist": "!=null && size >= blk_rq_count_integrity_sg(bio)"
        }
    }
},
{
    "kretprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks. Meta-devices like DM and MD need to verify that all sub-devices use the same integrity format before advertising to upper layers that they can send/receive integrity metadata. This function can be used to check whether two gendisk devices have compatible integrity formats.",
        "proto" :"int blk_integrity_compare(struct gendisk *gd1, struct gendisk *gd2)",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        },
    }
},
{
    "kprobe:blk_integrity_compare": {
        "description": "Compare integrity profile of two disks. Meta-devices like DM and MD need to verify that all sub-devices use the same integrity format before advertising to upper layers that they can send/receive integrity metadata. This function can be used to check whether two gendisk devices have compatible integrity formats.",
        "proto" :"int (*blk_integrity_compare)(struct gendisk *gd1, struct gendisk *gd2)",
        "pre": {
            "gd1": "!=null",
            "gd2": "!=null"
        }
    }
},
{
    "kretprobe:blk_integrity_register": {
        "description": "Register a gendisk as being integrity-capable. When a device needs to advertise itself as being able to send/receive integrity metadata it must use this function to register the capability with the block layer. The template is a blk_integrity struct with values appropriate for the underlying hardware.",
        "proto" :"void (*blk_integrity_register)(struct gendisk *disk, struct blk_integrity *template)",
        "pre": {
            "disk": "!=null",
            "template": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_register": {
        "description": "Register a gendisk as being integrity-capable. When a device needs to advertise itself as being able to send/receive integrity metadata it must use this function to register the capability with the block layer. The template is a blk_integrity struct with values appropriate for the underlying hardware.",
        "proto" :"void (*blk_integrity_register)(struct gendisk *disk, struct blk_integrity *template)",
        "pre": {
            "disk": "!=null",  // You may need to replace this with the actual constraint
            "template": "!=null"  // You may need to replace this with the actual constraint
        }
    }
},
{
    "kretprobe:blk_integrity_unregister": {
        "description": "This function unregisters the integrity capability from a block device.",
        "proto" :"void (*blk_integrity_unregister)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:blk_integrity_unregister": {
        "description": "This function unregisters the integrity capability from a block device.",
        "proto" :"void (*blk_integrity_unregister)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:blk_pm_runtime_init": {
        "description": "Initialize runtime-PM-related fields for @q and start auto suspend for @dev. Drivers that want to take advantage of request-based runtime PM should call this function after @dev has been initialized, and its request queue @q has been allocated, and runtime PM for it can not happen yet(either due to disabledforbidden or its usage_count > 0). In most cases, driver should call this function before any IO has taken place.",
        "proto" :"void (*blk_pm_runtime_init)(struct request_queue *q, struct device *dev)",
        "pre": {
            "q": "!=null",
            "dev": "!=null && initialized && request_queue_allocated && runtime_PM_not_yet_possible"
        }
    }
},
{
    "kprobe:blk_pm_runtime_init": {
        "description": "Block layer runtime PM initialization routine. Initialize runtime-PM-related fields for @q and start auto suspend for @dev. Drivers that want to take advantage of request-based runtime PM should call this function after @dev has been initialized, and its request queue @q has been allocated, and runtime PM for it can not happen yet(either due to disabledforbidden or its usage_count > 0). In most cases, driver should call this function before any IO has taken place. This function takes care of setting up using auto suspend for the device, the autosuspend delay is set to -1 to make runtime suspend impossible until an updated value is either set by user or by driver. Drivers do not need to touch other autosuspend settings. The block layer runtime PM is request based, so only works for drivers that use request as their IO unit instead of those directly use bio's.",
        "proto" :"void (*blk_pm_runtime_init)(struct request_queue *q, struct device *dev)",
        "pre": {
            "q": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_suspend": {
        "description": "This function checks if runtime suspend is allowed for the device by examining if there are any requests pending in the queue. If there are requests pending, the device cannot be runtime suspended; otherwise, the queue's status will be updated to SUSPENDING and the driver can proceed to suspend the device. The function returns 0 if it's okay to runtime suspend the device, and -EBUSY if the device should not be runtime suspended.",
        "proto" :"int blk_pre_runtime_suspend(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kprobe:blk_pre_runtime_suspend": {
        "description": "This function checks if runtime suspend is allowed for the device by examining if there are any requests pending in the queue. If there are requests pending, the device cannot be runtime suspended; otherwise, the queue's status will be updated to SUSPENDING and the driver can proceed to suspend the device. For the not allowed case, we mark last busy for the device so that runtime PM core will try to autosuspend it some time later. This function should be called near the start of the device's runtime_suspend callback.",
        "proto" :"int blk_pre_runtime_suspend(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]"
        }
    }
},
{
    "kretprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing. Update the queue's runtime status according to the return value of the device's runtime suspend function and mark last busy for the device so that PM core will try to auto suspend the device at a later time. This function should be called near the end of the device's runtime_suspend callback.",
        "proto": "void (*blk_post_runtime_suspend)(struct request_queue *q, int err)",
        "pre": {
            "q": "!=null",
            "err": "is integer"
        }
    }
},
{
    "kprobe:blk_post_runtime_suspend": {
        "description": "Post runtime suspend processing. Update the queue's runtime status according to the return value of the device's runtime suspend function and mark last busy for the device so that PM core will try to auto suspend the device at a later time. This function should be called near the end of the device's runtime_suspend callback.",
        "proto": "void (*blk_post_runtime_suspend)(struct request_queue *q, int err)",
        "pre": {
            "q": "!=null",
            "err": "in [0, errno values]"
        }
    }
},
{
    "kretprobe:blk_pre_runtime_resume": {
        "description": "Update the queue's runtime status to RESUMING in preparation for the runtime resume of the device. This function should be called near the start of the device's runtime_resume callback.",
        "proto" :"void (*blk_pre_runtime_resume)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_pre_runtime_resume": {
        "description": "Update the queue's runtime status to RESUMING in preparation for the runtime resume of the device. This function should be called near the start of the device's runtime_resume callback.",
        "proto" :"void (*blk_pre_runtime_resume)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_post_runtime_resume": {
        "description": "To do the real work of restarting the queue. It does this regardless of whether the device's runtime-resume succeeded; even if it failed the driver or error handler will need to communicate with the device. This function should be called near the end of the device's runtime_resume callback.",
        "proto" :"void (*blk_post_runtime_resume)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_post_runtime_resume": {
        "description": "To do the real work of restarting the queue. It does this regardless of whether the device's runtime-resume succeeded; even if it failed the driver or error handler will need to communicate with the device. This function should be called near the end of the device's runtime_resume callback.",
        "proto" :"void blk_post_runtime_resume(struct request_queue *q)",
        "pre": {
            "q": "your_condition_here"
        }
    }
},
{
    "kretprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio. This function prepares a bio for attaching integrity metadata. nr_vecs specifies the maximum number of pages containing integrity metadata that can be attached.",
        "proto" :"struct bio_integrity_payload *(*bio_integrity_alloc)(struct bio *bio, gfp_t gfp_mask, unsigned int nr_vecs)",
        "pre": {
            "bio": "!=null",
            "gfp_mask": ">=0",
            "nr_vecs": ">=0"
        }
    }
},
{
    "kprobe:bio_integrity_alloc": {
        "description": "Allocate integrity payload and attach it to bio. This function prepares a bio for attaching integrity metadata. nr_vecs specifies the maximum number of pages containing integrity metadata that can be attached.",
        "proto" :"struct bio_integrity_payload *(*bio_integrity_alloc)(struct bio *bio, gfp_t gfp_mask, unsigned int nr_vecs)",
        "pre": {
            "bio": "!=null",
            "gfp_mask": ">=0",
            "nr_vecs": ">=0",
        },
    }
},
{
    "kretprobe:bio_integrity_add_page": {
        "description": "Attach a page containing integrity metadata to bio.",
        "proto" :"int (*bio_integrity_add_page)(struct bio *bio, struct page *page, unsigned int len, unsigned int offset)",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0"
        },
    }
},
{
    "kprobe:bio_integrity_add_page": {
        "description": "Attach a page containing integrity metadata to bio.",
        "proto" :"int (*bio_integrity_add_page)(struct bio *bio, struct page *page, unsigned int len, unsigned int offset)",
        "pre": {
            "bio": "!=null",
            "page": "!=null",
            "len": ">=0",
            "offset": ">=0",
        },
    }
},
{
    "kretprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO. Checks if the bio already has an integrity payload attached. If it does, the payload has been generated by another kernel subsystem, and we just pass it through. Otherwise allocates integrity payload. The bio must have data direction, target device and start sector set prior to calling. In the WRITE case, integrity metadata will be generated using the block device's integrity function. In the READ case, the buffer will be prepared for DMA and a suitable end_io handler set up.",
        "proto" :"bool (*bio_integrity_prep)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_prep": {
        "description": "Prepare bio for integrity IO. Checks if the bio already has an integrity payload attached. If it does, the payload has been generated by another kernel subsystem, and we just pass it through. Otherwise allocates integrity payload. The bio must have data direction, target device and start sector set prior to calling. In the WRITE case, integrity metadata will be generated using the block device's integrity function. In the READ case, the buffer will be prepared for DMA and a suitable end_io handler set up.",
        "proto" :"bool (*bio_integrity_prep)(struct bio *bio)",
        "pre": {
            "bio": "!=null",
            "bio->bi_integrity": "!=null || ==null",
            "bio->bi_direction": "in [READ, WRITE]",
            "bio->bi_target_device": "!=null",
            "bio->bi_start_sector": ">=0"
        }
    }
},
{
    "kretprobe:bio_integrity_trim": {
        "description": "Used to trim the integrity vector in a cloned bio.",
        "proto" :"void (*bio_integrity_trim)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kprobe:bio_integrity_trim": {
        "description": "Used to trim the integrity vector in a cloned bio.",
        "proto" :"void (*bio_integrity_trim)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        }
    }
},

{
    "kprobe:blkdev_issue_discard": {
        "description": "Issues a discard request for a range of sectors. Returns -EPERM if the block device is read-only, -EOPNOTSUPP if the device does not support discarding sectors, or an error from the underlying block layer.",
        "proto" :"int blkdev_issue_discard(struct block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, struct bio *biop)",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "biop": "!=null",
            "bdev_read_only(bdev)": "==false",
            "bdev_max_discard_sectors(bdev)": ">0",
            "bdev_discard_granularity(bdev)": "!=0"
        }
    }
},
{
    "kretprobe:__blkdev_issue_zeroout": {
        "description": "Zero-fill a block range, either using hardware offload or by explicitly writing zeroes to the device. If a device is using logical block provisioning, the underlying space will not be released if %flags contains BLKDEV_ZERO_NOUNMAP. If %flags contains BLKDEV_ZERO_NOFALLBACK, the function will return -EOPNOTSUPP if no explicit hardware offload for zeroing is provided.",
        "proto" :"int (*__blkdev_issue_zeroout)(struct block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, struct bio **biop, unsigned flags)",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp_mask": "in [__GFP_DMA, __GFP_HIGHMEM, __GFP_DMA32, __GFP_MOVABLE, __GFP_RECLAIMABLE, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_ATOMIC, __GFP_ACCOUNT]",
            "biop": "!=null",
            "flags": "in [BLKDEV_ZERO_NOUNMAP, BLKDEV_ZERO_NOFALLBACK]"
        }
    }
},
{
    "kprobe:__blkdev_issue_zeroout": {
        "description": "Zero-fill a block range, either using hardware offload or by explicitly writing zeroes to the device. If a device is using logical block provisioning, the underlying space will not be released if %flags contains BLKDEV_ZERO_NOUNMAP. If %flags contains BLKDEV_ZERO_NOFALLBACK, the function will return -EOPNOTSUPP if no explicit hardware offload for zeroing is provided.",
        "proto" :"int (*__blkdev_issue_zeroout)(struct block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp_mask, struct bio **biop, unsigned flags)",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
            "biop": "!=null",
            "flags": "in [BLKDEV_ZERO_NOUNMAP, BLKDEV_ZERO_NOFALLBACK]"
        },
    }
},
{
    "kretprobe:blkdev_issue_secure_erase": {
        "description": "This function issues a secure erase command to a block device.",
        "proto": "int blkdev_issue_secure_erase(struct block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "sector": ">=0",
            "nr_sects": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "in [-EOPNOTSUPP, -EINVAL, -EPERM, 0]"
        }
    }
},
{
    "kprobe:blkdev_issue_secure_erase": {
        "description": "This function issues a secure erase command to a block device.",
        "proto" :"static int blkdev_issue_secure_erase(struct block_device *bdev, sector_t sector, sector_t nr_sects, gfp_t gfp)",
        "pre": {
            "bdev": "!=null",
            "sector": "your constraints here",
            "nr_sects": "your constraints here",
            "gfp": "your constraints here"
        },
    }
},
{
    "kretprobe:ioc_lookup_icq": {
        "description": "Look up io_cq associated with @ioc - @q pair from @ioc. Must be called with @q->queue_lock held.",
        "proto" :"struct io_cq *(*ioc_lookup_icq)(struct request_queue *q)",
        "pre": {
            "q": "!=null && q->queue_lock == held"
        },
    }
},
{
    "kprobe:ioc_lookup_icq": {
        "description": "Look up io_cq associated with @ioc - @q pair from @ioc. Must be called with @q->queue_lock held.",
        "proto" :"struct io_cq *(*ioc_lookup_icq)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:__register_blkdev": {
        "description": "__register_blkdev - register a new block device. The @name must be unique within the system. The return value depends on the @major input parameter. See Documentationadmin-guidedevices.txt for the list of allocated major numbers. Use register_blkdev instead for any new code.",
        "proto" :"int __register_blkdev(unsigned int major, const char *name, void (*probe)(dev_t devt))",
        "pre": {
            "major": "in [0, BLKDEV_MAJOR_MAX-1]",
            "name": "!=null",
            "probe": "!=null or ==null"
        },
        "post": {
            "return": "if major in [1, BLKDEV_MAJOR_MAX-1] then return in [0, -inf] else return in [1, BLKDEV_MAJOR_MAX-1, -inf]"
        }
    }
},
{
    "__register_blkdev": {
        "description": "__register_blkdev - register a new block device. The @name must be unique within the system. The return value depends on the @major input parameter. Use register_blkdev instead for any new code.",
        "proto" :"int __register_blkdev(unsigned int major, const char *name,void (*probe)(dev_t devt))",
        "pre": {
            "major": "in [0, BLKDEV_MAJOR_MAX-1]",
            "name": "!=null && unique",
            "probe": "!=null || ==null"
        },
    }
},
{
    "kretprobe:device_add_disk": {
        "description": "This function registers the partitioning information in @disk with the kernel.",
        "proto" :"int __must_check (*device_add_disk)(struct device *parent, struct gendisk *disk, const struct attribute_group **groups)",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null"
        },
    }
},
{
    "kprobe:device_add_disk": {
        "description": "This function registers the partitioning information in @disk with the kernel.",
        "proto" :"int __must_check (*device_add_disk)(struct device *parent, struct gendisk *disk, const struct attribute_group **groups)",
        "pre": {
            "parent": "!=null",
            "disk": "!=null",
            "groups": "!=null",
        },
    }
},
{
    "kretprobe:del_gendisk": {
        "description": "Should be called after __device_add_disk() and before put_disk(). It should not be deferred. Drivers exist which depend on the release of the gendisk to be synchronous.",
        "proto" :"void (*del_gendisk)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:del_gendisk": {
        "description": "put_disk(), which should be called after del_gendisk(), if __device_add_disk() was used. Drivers exist which depend on the release of the gendisk to be synchronous, it should not be deferred. Context: can sleep",
        "proto" :"void del_gendisk(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:invalidate_disk": {
        "description": "Invalidate the disk. It will clean the disk's associated bufferpage caches and reset its internal states so that the disk can be reused by the drivers.",
        "proto" :"void (*invalidate_disk)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kprobe:invalidate_disk": {
        "description": "Invalidates the disk. It will clean the disk's associated bufferpage caches and reset its internal states so that the disk can be reused by the drivers.",
        "proto" :"void (*invalidate_disk)(struct gendisk *disk)",
        "pre": {
            "disk": "!=null"
        }
    }
},
{
    "kretprobe:set_disk_ro": {
        "description": "Set a gendisk read-only. This function is used to indicate whether a given disk device should have its read-only flag set. set_disk_ro() is typically used by device drivers to indicate whether the underlying physical device is write-protected.",
        "proto": "void set_disk_ro(struct gendisk *disk, bool read_only)",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kprobe:set_disk_ro": {
        "description": "Set a gendisk read-only. This function is used to indicate whether a given disk device should have its read-only flag set. set_disk_ro() is typically used by device drivers to indicate whether the underlying physical device is write-protected.",
        "proto" :"void (*set_disk_ro)(struct gendisk *disk, bool read_only)",
        "pre": {
            "disk": "!=null",
            "read_only": "in [true, false]"
        }
    }
},
{
    "kretprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag",
        "proto" :"void (*blk_queue_flag_set)(unsigned int flag, struct request_queue *q)",
        "pre": {
            "flag": "is a valid flag value",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_set": {
        "description": "Atomically set a queue flag",
        "proto": "void (*blk_queue_flag_set)(unsigned int flag, struct request_queue *q)",
        "pre": {
            "flag": "is a valid flag value",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag",
        "proto": "void (*blk_queue_flag_clear)(unsigned int flag, struct request_queue *q)",
        "pre": {
            "flag": "is a valid flag",
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_queue_flag_clear": {
        "description": "Atomically clear a queue flag",
        "proto": "void (*blk_queue_flag_clear)(unsigned int flag, struct request_queue *q)",
        "pre": {
            "flag": "is a valid flag",
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_sync_queue": {
        "description": "submit_bio will not re-add plugging prior to calling this function. This function does not cancel any asynchronous activity arising out of elevator or throttling code. That would require elevator_exit() and blkcg_exit_queue() to be called with queue lock initialized.",
        "proto" :"void (*blk_sync_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_sync_queue": {
        "description": "submit_bio will not re-add plugging prior to calling this function. This function does not cancel any asynchronous activity arising out of elevator or throttling code. That would require elevator_exit() and blkcg_exit_queue() to be called with queue lock initialized.",
        "proto" :"void (*blk_sync_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_put_queue": {
        "description": "Decrement the refcount of the request_queue and free it when the refcount reaches 0.",
        "proto": "void (*blk_put_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_put_queue": {
        "description": "Decrement the request_queue refcount. Free it when the refcount reaches 0.",
        "proto": "void (*blk_put_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_get_queue": {
        "description": "Increment the refcount of the request_queue kobject.",
        "proto" :"bool (*blk_get_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        },
    }
},
{
    "kprobe:blk_get_queue": {
        "description": "Increment the refcount of the request_queue kobject.",
        "proto": "bool (*blk_get_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:__submit_bio_noacct": {
        "description": "Handles bios submitted by the current ->submit_bio and bios that were submitted before the current ->submit_bio, but that haven't been processed yet.",
        "proto" :"static void (*__submit_bio_noacct)(struct bio *bio)",
        "pre": {
            "bio": "!=null"
        }
    }
},
{
    "kprobe:__submit_bio_noacct": {
        "description": "submit_bio_noacct. If it did, we find a non-NULL value in bio_list and re-enter the loop from the top. - In this case we really did just take the bio of the top of the list (no pretending) and so remove it from bio_list, and call into ->submit_bio() again. bio_list_on_stack[0] contains bios submitted by the current ->submit_bio. bio_list_on_stack[1] contains bios that were submitted before the current ->submit_bio, but that haven't been processed yet.",
        "proto" :"static void (*__submit_bio_noacct)(struct bio *bio)",
        "pre": {
            "bio": "[placeholder for preconditions]"
        }
    }
},

{
    "kprobe:blk_alloc_queue": {
        "description": "Init percpu_ref in atomic mode so that it's faster to shutdown. See blk_register_queue() for details.",
        "proto" :"struct request_queue  blk_alloc_queue(int node_id)",
        "pre": {
            "node_id": "your_condition_here",
        },
    }
},
{
    "kretprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "proto" :"static void (*blk_start_plug_nr_ios)(struct blk_plug *plug, unsigned short nr_ios)",
        "pre": {
            "plug": "!=null",
            "nr_ios": ">=0"
        }
    }
},
{
    "kprobe:blk_start_plug_nr_ios": {
        "description": "If this is a nested plug, don't actually assign it.",
        "proto" :"static void (*blk_start_plug_nr_ios)(struct blk_plug *plug, unsigned short nr_ios)",
        "pre": {
            "plug": "!=null",
            "nr_ios": ">=0 && <= BLK_MAX_REQUEST_COUNT"
        }
    }
},
{
    "kretprobe:blk_check_plugged": {
        "description": "Check if the block device is currently plugged. If not, return NULL. If it is, iterate through the callback list. If the callback and data match the provided parameters, return the callback. If not, it's not currently on the callback list.",
        "proto" :"blk_check_plugged(blk_plug_cb_fn unplug, void  data, int size)",
        "pre": {
            "unplug": "!=null",
            "data": "!=null",
            "size": "> sizeof(*cb)"
        },
    }
},
{
    "kprobe:blk_check_plugged": {
        "description": "Check if the block device is currently plugged. If not, allocate a new block plug callback and add it to the callback list.",
        "proto" :"blk_check_plugged(blk_plug_cb_fn unplug, void  data, int size)",
        "pre": {
            "unplug": "!=null",
            "data": "!=null",
            "size": "> sizeof(*cb)"
        },
    }
},
{
    "kretprobe:blk_start_plug": {
        "description": "Starts a block plug, which is used to queue IOs. The block layer may choose to submit requests before a call to blk_finish_plug() if the number of queued IOs exceeds %BLK_MAX_REQUEST_COUNT, or if the size of the IO is larger than %BLK_PLUG_FLUSH_SIZE. The queued IOs may also be submitted early if the task schedules.",
        "proto" :"void (*blk_start_plug)(struct blk_plug *plug)",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kprobe:blk_start_plug": {
        "description": "Starts a block plug. The block layer may choose to submit requests before a call to blk_finish_plug() if the number of queued IOs exceeds %BLK_MAX_REQUEST_COUNT, or if the size of the IO is larger than %BLK_PLUG_FLUSH_SIZE. The queued IOs may also be submitted early if the task schedules. Tracking blk_plug inside the task_struct will help with auto-flushing the pending IO should the task end up blocking between blk_start_plug() and blk_finish_plug(). This is important from a performance perspective, but also ensures that we don't deadlock. For instance, if the task is blocking for a memory allocation, memory reclaim could end up wanting to free a page belonging to that request that is currently residing in our private plug. By flushing the pending IO when the process goes to sleep, we avoid this kind of deadlock.",
        "proto" :"void (*blk_start_plug)(struct blk_plug *plug)",
        "pre": {
            "plug": "!=null"
        }
    }
},
{
    "kretprobe:__bio_split_to_limits": {
        "description": "Check if @bio needs splitting based on the queue limits, and if so split off a bio fitting the limits from the beginning of @bio and return it. @bio is shortened to the remainder and re-submitted. The split bio is allocated from @q->bio_split, which is provided by the block layer.",
        "proto" :"struct bio *(__bio_split_to_limits)(struct bio *bio, const struct queue_limits *lim, unsigned int *nr_segs)",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        },
    }
},
{
    "kprobe:__bio_split_to_limits": {
        "description": "Check if @bio needs splitting based on the queue limits, and if so split off a bio fitting the limits from the beginning of @bio and return it. @bio is shortened to the remainder and re-submitted. The split bio is allocated from @q->bio_split, which is provided by the block layer.",
        "proto" :"struct bio *(__bio_split_to_limits)(struct bio *bio, const struct queue_limits *lim, unsigned int *nr_segs)",
        "pre": {
            "bio": "!=null",
            "lim": "!=null",
            "nr_segs": "!=null"
        }
    }
},
{
    "kretprobe:__blk_rq_map_sg": {
        "description": "Maps the scatter/gather list of a block request. If the number of segments is bigger than the number of request's physical segments, something must have been wrong.",
        "proto" :"int (*__blk_rq_map_sg)(struct request_queue *q, struct request *rq, struct scatterlist *sglist, struct scatterlist *last_sg)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "sglist": "!=null",
            "last_sg": "!=null",
            "rq->rq_flags": "in [RQF_SPECIAL_PAYLOAD]",
            "rq->bio": "!=null",
            "nsegs": "<= blk_rq_nr_phys_segments(rq)"
        },
    }
},
{
    "kprobe:__blk_rq_map_sg": {
        "description": "Maps a block request to a scatterlist.",
        "proto" :"static long (*__blk_rq_map_sg)(struct request_queue *q, struct request *rq, struct scatterlist *sglist, struct scatterlist *last_sg)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "nsegs": "<= blk_rq_nr_phys_segments(rq)"
        },
    }
},
{
    "kretprobe:init_opal_dev": {
        "description": "Initializes an opal_dev structure. The function allocates memory for the structure and its cmd and resp fields, initializes the unlk_lst and dev_lock fields, sets the flags field to 0, and assigns the data and send_recv parameters to the corresponding fields. If any of the kmalloc calls fail, the function cleans up and returns NULL.",
        "proto": "void *init_opal_dev(void *data, sec_send_recv *send_recv)",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        },
        "post": {
            "dev": "!=null",
            "dev->cmd": "!=null",
            "dev->resp": "!=null",
            "dev->unlk_lst": "initialized",
            "dev->dev_lock": "initialized",
            "dev->flags": "==0",
            "dev->data": "==data",
            "dev->send_recv": "==send_recv",
            "check_opal_support(dev)": "==0"
        }
    }
},
{
    "kprobe:init_opal_dev": {
        "description": "Initialize an opal_dev structure and allocate memory for cmd and resp fields. The allocated buffer is DMA-safe.",
        "proto" :"static struct opal_dev* (*init_opal_dev)(void *data, sec_send_recv *send_recv)",
        "pre": {
            "data": "!=null",
            "send_recv": "!=null"
        },
        "post": {
            "dev->cmd": "!=null",
            "dev->resp": "!=null",
            "dev->unlk_lst": "is initialized",
            "dev->dev_lock": "is initialized",
            "dev->flags": "==0",
            "dev->data": "==data",
            "dev->send_recv": "==send_recv",
            "check_opal_support(dev)": "==0"
        }
    }
},
{
    "kretprobe:blk_rq_map_bio_alloc": {
        "description": "Allocates a bio structure and initializes it.",
        "proto" :"static struct bio (*blk_rq_map_bio_alloc)(struct request rq, unsigned int nr_vecs, gfp_t gfp_mask)",
        "pre": {
            "rq": "!=null",
            "nr_vecs": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    },
    "kretprobe:bio_map_user_iov": {
        "description": "Maps user pages into a bio.",
        "proto" :"static int (*bio_map_user_iov)(struct request rq, struct iov_iter iter, gfp_t gfp_mask)",
        "pre": {
            "rq": "!=null",
            "iter": "!=null",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "bio": "!=null",
            "pages": "!=null",
            "j": "is a non-negative integer",
            "npages": "is a non-negative integer",
        },
    }
},
{
    "kretprobe:blk_rq_map_user_iov": {
        "description": "blk_rq_unmap_user() must be issued at the end of IO, while still in process context.",
        "proto" :"int (*blk_rq_map_user_iov)(struct request_queue *q, struct request *rq, struct rq_map_data *map_data, const struct iov_iter *iter, gfp_t gfp_mask)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "map_data": "!=null",
            "iter": "!=null",
            "gfp_mask": ">=0"
        },
    }
},
{
    "kprobe:blk_rq_map_user_iov": {
        "description": "blk_rq_unmap_user() must be issued at the end of IO, while still in process context.",
        "proto" :"int (*blk_rq_map_user_iov)(struct request_queue *q, struct request *rq, struct rq_map_data *map_data, const struct iov_iter *iter, gfp_t gfp_mask)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "map_data": "!=null",
            "iter": "!=null",
            "gfp_mask": "is valid gfp_t value"
        },
    }
},
{
    "kretprobe:blk_rq_map_user_bvec": {
        "description": "Maps a user bvec to a request.",
        "proto" :"blk_rq_map_user_bvec(struct request *rq, const struct iov_iter *iter)",
        "pre": {
            "rq": "!=null",
            "iter": "!=null",
            "nr_iter": ">0 && <= queue_max_hw_sectors(q)",
            "nr_segs": "<= queue_max_segments(q)"
        },
    }
},
{
    "kprobe:blk_rq_map_user_bvec": {
        "description": "Maps a user's bio to a request queue.",
        "proto" :"static long (*blk_rq_map_user_bvec)(struct request *rq, const struct iov_iter *iter)",
        "pre": {
            "rq": "!=null",
            "iter": "!=null",
            "q": "rq->q !=null",
            "nr_iter": "iov_iter_count(iter) != 0 && (iov_iter_count(iter) >> SECTOR_SHIFT) <= queue_max_hw_sectors(q)",
            "nr_segs": "iter->nr_segs <= queue_max_segments(q)",
            "bvecs": "!=null",
            "bvprvp": "!=null",
            "lim": "&q->limits !=null",
            "nsegs": ">=0",
            "bytes": ">=0",
            "bio": "!=null",
            "i": ">=0"
        },
    }
},
{
    "kretprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests. Data will be mapped directly if possible. Otherwise a bounce buffer is used. Can be called multiple times to append multiple buffers.",
        "proto" :"int blk_rq_map_kern(struct request_queue *q, struct request *rq, void *kbuf, unsigned int len, gfp_t gfp_mask)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_NOWAIT, GFP_ATOMIC, GFP_NOIO, GFP_NOFS, GFP_USER, GFP_DMA, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_TRANSHUGE_LIGHT, GFP_TRANSHUGE, GFP_TRANSHUGE_HARD, GFP_ATOMIC_LOW, GFP_DIRECT_RECLAIM, GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "kprobe:blk_rq_map_kern": {
        "description": "Map kernel data to a request, for passthrough requests. Data will be mapped directly if possible. Otherwise a bounce buffer is used. Can be called multiple times to append multiple buffers.",
        "proto" :"int blk_rq_map_kern(struct request_queue *q, struct request *rq, void *kbuf, unsigned int len, gfp_t gfp_mask)",
        "pre": {
            "q": "!=null",
            "rq": "!=null",
            "kbuf": "!=null",
            "len": ">=0",
            "gfp_mask": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NOACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        },
    }
},
{
    "kretprobe:blk_set_stacking_limits": {
        "description": "Returns a queue_limit struct to its default state. Should be used by stacking drivers like DM that have no internal limits.",
        "proto" :"void (*blk_set_stacking_limits)(struct queue_limits *lim)",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kprobe:blk_set_stacking_limits": {
        "description": "Returns a queue_limit struct to its default state. Should be used by stacking drivers like DM that have no internal limits.",
        "proto" :"void (*blk_set_stacking_limits)(struct queue_limits *lim)",
        "pre": {
            "lim": "!=null"
        }
    }
},
{
    "kretprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue. Force bouncing for ISA DMA ranges or highmem. DEPRECATED, don't use in new code.",
        "proto" :"void (*blk_queue_bounce_limit)(struct request_queue *q, enum blk_bounce bounce)",
        "pre": {
            "q": "!=null",
            "bounce": "in [BLK_BOUNCE_HIGH, BLK_BOUNCE_ANY, BLK_BOUNCE_ISA, BLK_BOUNCE_NONE]"
        }
    }
},
{
    "kprobe:blk_queue_bounce_limit": {
        "description": "Set bounce buffer limit for queue. Force bouncing for ISA DMA ranges or highmem. DEPRECATED, don't use in new code.",
        "proto" :"void (*blk_queue_bounce_limit)(struct request_queue *q, enum blk_bounce bounce)",
        "pre": {
            "q": "!=null",
            "bounce": "in [enum blk_bounce values]",
        },
    }
},
{
    "kretprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue. Enables a low level driver to set a hard upper limit, max_hw_sectors, on the size of requests. max_hw_sectors is set by the device driver based upon the capabilities of the IO controller.",
        "proto" :"void (*blk_queue_max_hw_sectors)(struct request_queue *q, unsigned int max_hw_sectors)",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": ">0"
        },
    }
},
{
    "kprobe:blk_queue_max_hw_sectors": {
        "description": "Set max sectors for a request for this queue. Enables a low level driver to set a hard upper limit, max_hw_sectors, on the size of requests. max_hw_sectors is set by the device driver based upon the capabilities of the IO controller. max_dev_sectors is a hard limit imposed by the storage device for READWRITE requests. It is set by the disk driver. max_sectors is a soft limit imposed by the block layer for filesystem type requests. This value can be overridden on a per-device basis in sysblock<device>queuemax_sectors_kb. The soft limit can not exceed max_hw_sectors.",
        "proto": "void (*blk_queue_max_hw_sectors)(struct request_queue *q, unsigned int max_hw_sectors)",
        "pre": {
            "q": "!=null",
            "max_hw_sectors": ">0"
        }
    }
},
{
    "kretprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue. If a driver doesn't want IOs to cross a given chunk size, it can set this limit and prevent merging across chunks. Note that the block layer must accept a page worth of data at any offset. So if the crossing of chunks is a hard limitation in the driver, it must still be prepared to split single page bios.",
        "proto" :"void (*blk_queue_chunk_sectors)(struct request_queue *q, unsigned int chunk_sectors)",
        "pre": {
            "q": "!=null",
            "chunk_sectors": ">0"
        }
    }
},
{
    "kprobe:blk_queue_chunk_sectors": {
        "description": "Set size of the chunk for this queue. If a driver doesn't want IOs to cross a given chunk size, it can set this limit and prevent merging across chunks. Note that the block layer must accept a page worth of data at any offset. So if the crossing of chunks is a hard limitation in the driver, it must still be prepared to split single page bios.",
        "proto" :"void (*blk_queue_chunk_sectors)(struct request_queue *q, unsigned int chunk_sectors)",
        "pre": {
            "q": "!=null",
            "chunk_sectors": ">0",
        },
    }
},
{
    "kretprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard. @q: the request queue for the device. @max_discard_sectors: maximum number of sectors to discard.",
        "proto" :"void (*blk_queue_max_discard_sectors)(struct request_queue *q, unsigned int max_discard_sectors)",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_discard_sectors": {
        "description": "Set max sectors for a single discard. @q: the request queue for the device. @max_discard_sectors: maximum number of sectors to discard.",
        "proto" :"void (*blk_queue_max_discard_sectors)(struct request_queue *q, unsigned int max_discard_sectors)",
        "pre": {
            "q": "!=null",
            "max_discard_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase. @q: the request queue for the device. @max_sectors: maximum number of sectors to secure_erase.",
        "proto" :"void (*blk_queue_max_secure_erase_sectors)(struct request_queue *q, unsigned int max_sectors)",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_secure_erase_sectors": {
        "description": "Set max sectors for a secure erase",
        "proto" :"void (*blk_queue_max_secure_erase_sectors)(struct request_queue *q, unsigned int max_sectors)",
        "pre": {
            "q": "!=null",
            "max_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes. @q: the request queue for the device. @max_write_zeroes_sectors: maximum number of sectors to write per command.",
        "proto" :"void (*blk_queue_max_write_zeroes_sectors)(struct request_queue *q, unsigned int max_write_zeroes_sectors)",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_write_zeroes_sectors": {
        "description": "Set max sectors for a single write zeroes. @q: the request queue for the device. @max_write_zeroes_sectors: maximum number of sectors to write per command.",
        "proto" :"void (*blk_queue_max_write_zeroes_sectors)(struct request_queue *q, unsigned int max_write_zeroes_sectors)",
        "pre": {
            "q": "!=null",
            "max_write_zeroes_sectors": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue. Enables a low level driver to set an upper limit on the number of hw data segments in a request.",
        "proto" :"void (*blk_queue_max_segments)(struct request_queue *q, unsigned short max_segments)",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_max_segments": {
        "description": "Set max hw segments for a request for this queue. Enables a low level driver to set an upper limit on the number of hw data segments in a request.",
        "proto" :"void (*blk_queue_max_segments)(struct request_queue *q, unsigned short max_segments)",
        "pre": {
            "q": "!=null",
            "max_segments": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_max_segment_size": {
        "description": "Enables a low level driver to set an upper limit on the size of a coalesced segment.",
        "proto" :"void (*blk_queue_max_segment_size)(struct request_queue *q, unsigned int max_size)",
        "pre": {
            "q": "!=null",
            "max_size": ">0"
        }
    }
},
{
    "kprobe:blk_queue_max_segment_size": {
        "description": "Enables a low level driver to set an upper limit on the size of a coalesced segment.",
        "proto" :"void (*blk_queue_max_segment_size)(struct request_queue *q, unsigned int max_size)",
        "pre": {
            "q": "!=null",
            "max_size": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue. This should be set to the lowest possible block size that the storage device can address. The default of 512 covers most hardware.",
        "proto" :"void (*blk_queue_logical_block_size)(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set logical block size for the queue. This should be set to the lowest possible block size that the storage device can address. The default of 512 covers most hardware.",
        "proto" :"void (*blk_queue_logical_block_size)(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": ">=512"
        }
    }
},
{
    "kretprobe:blk_queue_physical_block_size": {
        "description": "Set the lowest possible sector size that the hardware can operate on without reverting to read-modify-write operations for the queue.",
        "proto": "void (*blk_queue_physical_block_size)(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": ">0"
        }
    }
},
{
    "kprobe:blk_queue_physical_block_size": {
        "description": "Set physical block size for the queue. This should be set to the lowest possible sector size that the hardware can operate on without reverting to read-modify-write operations.",
        "proto" :"void (*blk_queue_physical_block_size)(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": "> 0"
        }
    }
},
{
    "kretprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset. Some devices are naturally misaligned to compensate for things like the legacy DOS partition table 63-sector offset. Low-level drivers should call this function for devices whose first sector is not naturally aligned.",
        "proto" :"void (*blk_queue_alignment_offset)(struct request_queue *q, unsigned int offset)",
        "pre": {
            "q": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_alignment_offset": {
        "description": "Set physical block alignment offset. Some devices are naturally misaligned to compensate for things like the legacy DOS partition table 63-sector offset. Low-level drivers should call this function for devices whose first sector is not naturally aligned.",
        "proto" :"void (*blk_queue_alignment_offset)(struct request_queue *q, unsigned int offset)",
        "pre": {
            "q": "!=null",
            "offset": ">=0",
        },
    }
},
{
    "kretprobe:blk_limits_io_min": {
        "description": "Set minimum request size for a device. Some devices have an internal block size bigger than the reported hardware sector size. This function can be used to signal the smallest IO the device can perform without incurring a performance penalty.",
        "proto": "void (*blk_limits_io_min)(struct queue_limits *limits, unsigned int min)",
        "pre": {
            "limits": "!=null",
            "min": ">0"
        }
    }
},
{
    "kprobe:blk_limits_io_min": {
        "description": "Set minimum request size for a device. Some devices have an internal block size bigger than the reported hardware sector size. This function can be used to signal the smallest IO the device can perform without incurring a performance penalty.",
        "proto": "void (*blk_limits_io_min)(struct queue_limits *limits, unsigned int min)",
        "pre": {
            "limits": "!=null",
            "min": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue. Storage devices may report a granularity or preferred minimum IO size which is the smallest request the device can perform without incurring a performance penalty. For disk drives this is often the physical block size. For RAID arrays it is often the stripe chunk size. A properly aligned multiple of minimum_io_size is the preferred request size for workloads where a high number of IO operations is desired.",
        "proto" :"void (*blk_queue_io_min)(struct request_queue *q, unsigned int min)",
        "pre": {
            "q": "!=null",
            "min": ">0"
        }
    }
},
{
    "kprobe:blk_queue_io_min": {
        "description": "Set minimum request size for the queue. Storage devices may report a granularity or preferred minimum IO size which is the smallest request the device can perform without incurring a performance penalty. For disk drives this is often the physical block size. For RAID arrays it is often the stripe chunk size. A properly aligned multiple of minimum_io_size is the preferred request size for workloads where a high number of IO operations is desired.",
        "proto": "void (*blk_queue_io_min)(struct request_queue *q, unsigned int min)",
        "pre": {
            "q": "!=null",
            "min": ">0"
        }
    }
},
{
    "kretprobe:blk_limits_io_opt": {
        "description": "Set optimal request size for a device. Storage devices may report an optimal IO size, which is the device's preferred unit for sustained IO. This is rarely reported for disk drives. For RAID arrays it is usually the stripe width or the internal track size. A properly aligned multiple of optimal_io_size is the preferred request size for workloads where sustained throughput is desired.",
        "proto" :"void (*blk_limits_io_opt)(struct queue_limits *limits, unsigned int opt)",
        "pre": {
            "limits": "!=null",
            "opt": ">0"
        }
    }
},
{
    "kprobe:blk_limits_io_opt": {
        "description": "Set optimal request size for a device. Storage devices may report an optimal IO size, which is the device's preferred unit for sustained IO. This is rarely reported for disk drives. For RAID arrays it is usually the stripe width or the internal track size. A properly aligned multiple of optimal_io_size is the preferred request size for workloads where sustained throughput is desired.",
        "proto": "void (*blk_limits_io_opt)(struct queue_limits *limits, unsigned int opt)",
        "pre": {
            "limits": "!=null",
            "opt": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue. Storage devices may report an optimal IO size, which is the device's preferred unit for sustained IO. This is rarely reported for disk drives. For RAID arrays it is usually the stripe width or the internal track size. A properly aligned multiple of optimal_io_size is the preferred request size for workloads where sustained throughput is desired.",
        "proto" :"void (*blk_queue_io_opt)(struct request_queue *q, unsigned int opt)",
        "pre": {
            "q": "!=null",
            "opt": ">0"
        }
    }
},
{
    "kprobe:blk_queue_io_opt": {
        "description": "Set optimal request size for the queue. Storage devices may report an optimal IO size, which is the device's preferred unit for sustained IO. This is rarely reported for disk drives. For RAID arrays it is usually the stripe width or the internal track size. A properly aligned multiple of optimal_io_size is the preferred request size for workloads where sustained throughput is desired.",
        "proto" :"void (*blk_queue_io_opt)(struct request_queue *q, unsigned int opt)",
        "pre": {
            "q": "!=null",
            "opt": ">0"
        }
    }
},
{
    "kretprobe:blk_stack_limits": {
        "description": "This function is used by stacking drivers like MD and DM to ensure that all component devices have compatible block sizes and alignments. The stacking driver must provide a queue_limits struct (top) and then iteratively call the stacking function for all component (bottom) devices. The stacking function will attempt to combine the values and ensure proper alignment. Returns 0 if the top and bottom queue_limits are compatible. The top device's block sizes and alignment offsets may be adjusted to ensure alignment with the bottom device. If no compatible sizes and alignments exist, -1 is returned and the resulting top queue_limits will have the misaligned flag set to indicate that the alignment_offset is undefined.",
        "proto" :"int blk_stack_limits(struct queue_limits *t, struct queue_limits *b, sector_t start)",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": ">=0"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:blk_stack_limits": {
        "description": "This function is used by stacking drivers like MD and DM to ensure that all component devices have compatible block sizes and alignments. The stacking driver must provide a queue_limits struct (top) and then iteratively call the stacking function for all component (bottom) devices. The stacking function will attempt to combine the values and ensure proper alignment. Returns 0 if the top and bottom queue_limits are compatible. The top device's block sizes and alignment offsets may be adjusted to ensure alignment with the bottom device. If no compatible sizes and alignments exist, -1 is returned and the resulting top queue_limits will have the misaligned flag set to indicate that the alignment_offset is undefined.",
        "proto" :"int blk_stack_limits(struct queue_limits *t, struct queue_limits *b, sector_t start)",
        "pre": {
            "t": "!=null",
            "b": "!=null",
            "start": ">=0"
        },
    }
},
{
    "kretprobe:disk_stack_limits": {
        "description": "Merges the limits for a top level gendisk and a bottom level block_device.",
        "proto" :"void (*disk_stack_limits)(struct gendisk *disk, struct block_device *bdev, sector_t offset)",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:disk_stack_limits": {
        "description": "Merges the limits for a top level gendisk and a bottom level block_device.",
        "proto" :"void disk_stack_limits(struct gendisk *disk, struct block_device *bdev, sector_t offset)",
        "pre": {
            "disk": "!=null",
            "bdev": "!=null",
            "offset": ">=0",
        },
    }
},
{
    "kretprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask. Appending pad buffer to a request modifies the last entry of a scatter list such that it includes the pad buffer.",
        "proto" :"void (*blk_queue_update_dma_pad)(struct request_queue *q, unsigned int mask)",
        "pre": {
            "q": "!=null",
            "mask": "is a valid unsigned integer"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_pad": {
        "description": "Update dma pad mask. Appending pad buffer to a request modifies the last entry of a scatter list such that it includes the pad buffer.",
        "proto" :"void (*blk_queue_update_dma_pad)(struct request_queue *q, unsigned int mask)",
        "pre": {
            "q": "!=null",
            "mask": "is unsigned int"
        },
    }
},
{
    "kretprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging. @q: the request queue for the device. @mask: the memory boundary mask.",
        "proto" :"void (*blk_queue_segment_boundary)(struct request_queue *q, unsigned long mask)",
        "pre": {
            "q": "!=null",
            "mask": "is a valid memory boundary mask"
        }
    }
},
{
    "kprobe:blk_queue_segment_boundary": {
        "description": "Set boundary rules for segment merging. @q: the request queue for the device. @mask: the memory boundary mask.",
        "proto" :"void (*blk_queue_segment_boundary)(struct request_queue *q, unsigned long mask)",
        "pre": {
            "q": "!=null",
            "mask": "is an unsigned long"
        }
    }
},
{
    "kretprobe:blk_queue_logical_block_size": {
        "description": "Set the logical block size for the queue. This should be set to the lowest possible block size that the storage device can address. The default of 512 covers most hardware.",
        "proto" :"void blk_queue_logical_block_size(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": ">0"
        },
    }
},
{
    "kprobe:blk_queue_logical_block_size": {
        "description": "Set the logical block size for the queue. This should be set to the lowest possible block size that the storage device can address. The default of 512 covers most hardware.",
        "proto" :"static void (*blk_queue_logical_block_size)(struct request_queue *q, unsigned int size)",
        "pre": {
            "q": "!=null",
            "size": "> 0",
        },
    }
},
{
    "kretprobe:blk_queue_dma_alignment": {
        "description": "Set required memory and length alignment for direct dma transactions. This is used when building direct io requests for the queue.",
        "proto" :"void (*blk_queue_dma_alignment)(struct request_queue *q, int mask)",
        "pre": {
            "q": "!=null",
            "mask": "is int"
        }
    }
},
{
    "kprobe:blk_queue_dma_alignment": {
        "description": "Set required memory and length alignment for direct dma transactions. This is used when building direct io requests for the queue.",
        "proto" :"void (*blk_queue_dma_alignment)(struct request_queue *q, int mask)",
        "pre": {
            "q": "!=null",
            "mask": ">=0"
        }
    }
},
{
    "kretprobe:blk_queue_update_dma_alignment": {
        "description": "Update required memory and length alignment for direct dma transactions. If the requested alignment is larger than the current alignment, then the current queue alignment is updated to the new value, otherwise it is left alone. The design of this is to allow multiple objects (driver, device, transport etc) to set their respective alignments without having them interfere.",
        "proto" :"void (*blk_queue_update_dma_alignment)(struct request_queue *q, int mask)",
        "pre": {
            "q": "!=null",
            "mask": ">=0"
        }
    }
},
{
    "kprobe:blk_queue_update_dma_alignment": {
        "description": "Update required memory and length alignment for direct dma transactions. If the requested alignment is larger than the current alignment, then the current queue alignment is updated to the new value, otherwise it is left alone. The design of this is to allow multiple objects (driver, device, transport etc) to set their respective alignments without having them interfere.",
        "proto" :"void (*blk_queue_update_dma_alignment)(struct request_queue *q, int mask)",
        "pre": {
            "q": "!=null",
            "mask": "is integer"
        }
    }
},
{
    "kretprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth. @q: the request queue for the device. @depth: queue depth.",
        "proto": "void (*blk_set_queue_depth)(struct request_queue *q, unsigned int depth)",
        "pre": {
            "q": "!=null",
            "depth": ">=0"
        }
    }
},
{
    "kprobe:blk_set_queue_depth": {
        "description": "Tell the block layer about the device queue depth.",
        "proto": "void (*blk_set_queue_depth)(struct request_queue *q, unsigned int depth)",
        "pre": {
            "q": "!=null",
            "depth": "is a positive integer"
        }
    }
},
{
    "kretprobe:blk_mq_alloc_requests_batch": {
        "description": "Your function description here",
        "proto" :"static struct request *blk_mq_alloc_requests_batch(struct blk_mq_alloc_data *data)",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_alloc_requests_batch": {
        "description": "Your function description here",
        "proto" :"static struct request *blk_mq_alloc_requests_batch(struct blk_mq_alloc_data *data)",
        "pre": {
            "data": "!=null",
            // Add other parameters and their constraints here
        },
    }
},


{
    "kretprobe:blk_mq_start_request": {
        "description": "Function used by device drivers to notify the block layer that a request is going to be processed now, so blk layer can do proper initializations such as starting the timeout timer.",
        "proto" :"void (*blk_mq_start_request)(struct request *rq)",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_start_request": {
        "description": "Function used by device drivers to notify the block layer that a request is going to be processed now, so blk layer can do proper initializations such as starting the timeout timer.",
        "proto" :"void (*blk_mq_start_request)(struct request *rq)",
        "pre": {
            "rq": "!=null"
        }
    }
},
{
    "kretprobe:blk_execute_rq_nowait": {
        "description": "Insert a fully prepared request at the back of the IO scheduler queue for execution. Don't wait for completion. This function will invoke @done directly if the queue is dead.",
        "proto" :"void (*blk_execute_rq_nowait)(struct request *rq, bool at_head)",
        "pre": {
            "rq": "!=null",
            "at_head": "in [true, false]"
        }
    }
},
{
    "kprobe:blk_execute_rq_nowait": {
        "description": "Insert a fully prepared request at the back of the IO scheduler queue for execution. Don't wait for completion. This function will invoke @done directly if the queue is dead.",
        "proto" :"void (*blk_execute_rq_nowait)(struct request *rq, bool at_head)",
        "pre": {
            "rq": "!=null",
            "at_head": "is bool"
        }
    }
},

{
    "kprobe:blk_mq_requeue_request": {
        "description": "This function re-inserts a request to the io scheduler queue.",
        "proto" :"void blk_mq_requeue_request(struct request  rq, bool kick_requeue_list)",
        "pre": {
            "rq": "!=null",
            "kick_requeue_list": "is boolean"
        },
    }
},

{
    "kprobe:blk_mq_requeue_work": {
        "description": "If RQF_DONTPREP is set, the request has been started by the driver already and might have driver-specific data allocated already. Insert it into the hctx dispatch list to avoid block layer merges for the request.",
        "proto" :"static void blk_mq_requeue_work(struct work_struct  work)",
        "pre": {
            "work": "!=null",
            "rq->rq_flags": "in [RQF_DONTPREP, ~RQF_DONTPREP]"
        },
    }
},
{
    "kretprobe:blk_mq_hctx_next_cpu": {
        "description": "This function's description is not provided in the helper doc.",
        "proto" :"static int blk_mq_hctx_next_cpu(struct blk_mq_hw_ctx *hctx)",
        "pre": {
            "hctx": "!=null"
        }
    }
},

{
    "kretprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "proto" :"void (*blk_freeze_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_freeze_queue": {
        "description": "Guarantee no request is in use, so we can change any data structure of the queue afterward.",
        "proto" :"void (*blk_freeze_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null && !in_use"
        },
    }
},
{
    "kretprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously. @q: Pointer to the request queue to run. @msecs: Milliseconds of delay to wait before running the queues.",
        "proto" :"void (*blk_mq_delay_run_hw_queues)(struct request_queue *q, unsigned long msecs)",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kprobe:blk_mq_delay_run_hw_queues": {
        "description": "Run all hardware queues asynchronously. @q: Pointer to the request queue to run. @msecs: Milliseconds of delay to wait before running the queues.",
        "proto" :"void (*blk_mq_delay_run_hw_queues)(struct request_queue *q, unsigned long msecs)",
        "pre": {
            "q": "!=null",
            "msecs": ">=0"
        }
    }
},
{
    "kretprobe:blk_mq_stop_hw_queue": {
        "description": "blk_mq_stop_hw_queue() returns. Please use blk_mq_quiesce_queue() for that requirement.",
        "proto" :"void (*blk_mq_stop_hw_queue)(struct blk_mq_hw_ctx *hctx)",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queue": {
        "description": "blk_mq_stop_hw_queue() returns. Please use blk_mq_quiesce_queue() for that requirement.",
        "proto" :"void (*blk_mq_stop_hw_queue)(struct blk_mq_hw_ctx *hctx)",
        "pre": {
            "hctx": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_stop_hw_queues": {
        "description": "blk_mq_stop_hw_queues() returns. Please use blk_mq_quiesce_queue() for that requirement.",
        "proto" :"void (*blk_mq_stop_hw_queues)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_stop_hw_queues": {
        "description": "blk_mq_stop_hw_queues() returns. Please use blk_mq_quiesce_queue() for that requirement.",
        "proto" :"void (*blk_mq_stop_hw_queues)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_destroy_queue": {
        "description": "This shuts down a request queue allocated by blk_mq_init_queue(). All future requests will be failed with -ENODEV. The caller is responsible for dropping the reference from blk_mq_init_queue() by calling blk_put_queue().",
        "proto": "void blk_mq_destroy_queue(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:blk_mq_destroy_queue": {
        "description": "Shutdown a request queue. All future requests will be failed with -ENODEV. The caller is responsible for dropping the reference from blk_mq_init_queue() by calling blk_put_queue().",
        "proto" :"void (*blk_mq_destroy_queue)(struct request_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:blk_mq_alloc_tag_set": {
        "description": "Allocate a tag set, with various constraints.",
        "proto" :"int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set)",
        "pre": {
            "set": "!=null",
            "set->nr_hw_queues": ">0",
            "set->queue_depth": ">0",
            "set->queue_depth": ">= set->reserved_tags + BLK_MQ_TAG_MIN",
            "set->ops->queue_rq": "!=null",
            "set->ops->get_budget ^ set->ops->put_budget": "==0",
            "set->queue_depth": "<= BLK_MQ_MAX_DEPTH",
            "set->nr_maps": "in [1, HCTX_MAX_TYPES]"
        },
    }
},
{
    "kprobe:blk_mq_alloc_tag_set": {
        "description": "Allocate a tag set.",
        "proto" :"int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set)",
        "pre": {
            "set": "!=null",
            "set->nr_hw_queues": ">0",
            "set->queue_depth": ">0",
            "set->queue_depth": ">= set->reserved_tags + BLK_MQ_TAG_MIN",
            "set->ops->queue_rq": "!=null",
            "set->ops->get_budget ^ set->ops->put_budget": "==0",
            "set->queue_depth": "<= BLK_MQ_MAX_DEPTH",
            "set->nr_maps": "in [1, HCTX_MAX_TYPES]"
        },
    }
},

{
    "kprobe:EXPORT_SYMBOL(EISA_bus)": {
        "description": "For legacy drivers",
        "proto" :"void (*EXPORT_SYMBOL(EISA_bus))(int *bus_id)",
        "pre": {
            "bus_id": "!=null",
        },
    }
},
{
    "kretprobe:xen_alloc_unpopulated_pages": {
        "description": "alloc unpopulated pages @nr_pages: Number of pages @pages: pages returned @return 0 on success, error otherwise",
        "proto" :"int (*xen_alloc_unpopulated_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">0",
            "pages": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:xen_alloc_unpopulated_pages": {
        "description": "alloc unpopulated pages @nr_pages: Number of pages @pages: pages returned @return 0 on success, error otherwise",
        "proto" :"int (*xen_alloc_unpopulated_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">0",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages",
        "proto" :"void (*xen_free_unpopulated_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">=0",
            "pages": "!=null"
        }
    }
},
{
    "kprobe:xen_free_unpopulated_pages": {
        "description": "Return unpopulated pages",
        "proto" :"void (*xen_free_unpopulated_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">=0",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out. Returns 0 on success, error otherwise.",
        "proto" :"int (*xen_alloc_ballooned_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">0",
            "pages": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:xen_alloc_ballooned_pages": {
        "description": "Get pages that have been ballooned out. Returns 0 on success, error otherwise.",
        "proto" :"int (*xen_alloc_ballooned_pages)(unsigned int nr_pages, struct page **pages)",
        "pre": {
            "nr_pages": ">=0",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:xen_free_ballooned_pages": {
        "description": "Return pages retrieved with get_ballooned_pages. xen_free_ballooned_pages will only subtract pgno pages, but since target_unpopulated is incremented with nr_pages at the start we need to remove the remaining ones also, or accounting will be screwed.",
        "proto" :"void xen_free_ballooned_pages(int pgno, struct page **pages)",
        "pre": {
            "pgno": ">=0",
            "pages": "!=null"
        },
    }
},
{
    "kprobe:xen_free_ballooned_pages": {
        "description": "Return pages retrieved with get_ballooned_pages. It will only subtract pgno pages, but since target_unpopulated is incremented with nr_pages at the start we need to remove the remaining ones also, or accounting will be screwed.",
        "proto" :"void xen_free_ballooned_pages(int pgno, struct page **pages)",
        "pre": {
            "pgno": ">=0",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:st21nfca_hci_control_se": {
        "description": "Description of the function",
        "proto" :"static long (*st21nfca_hci_control_se)(struct nfc_hci_dev hdev, u32 se_idx, int ST21NFCA_SE_MODE_ON)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!= NFC_SE_UICC when info->se_status->is_uicc_enable is true",
            "ST21NFCA_SE_MODE_ON": "Possible values"
        },
    }
},
{
    "kprobe:st21nfca_hci_control_se": {
        "description": "According to upper layer, se_idx == NFC_SE_UICC when info->se_status->is_uicc_enable is true should never happen. Same for eSE.",
        "proto" :"int (*st21nfca_hci_control_se)(struct nfc_hci_dev hdev, u32 se_idx, int mode)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!= NFC_SE_UICC when info->se_status->is_uicc_enable is true",
            "mode": "== ST21NFCA_SE_MODE_ON",
        },
    }
},
{
    "kretprobe:st21nfca_hci_disable_se": {
        "description": "According to upper layer, se_idx == NFC_SE_UICC when info->se_status->is_uicc_enable is true should never happen. Same for eSE.",
        "proto" :"int st21nfca_hci_disable_se(struct nfc_hci_dev hdev, u32 se_idx)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "!=NFC_SE_UICC when info->se_status->is_uicc_enable is true"
        },
    }
},
{
    "kprobe:st21nfca_hci_disable_se": {
        "description": "According to upper layer, se_idx == NFC_SE_UICC when info->se_status->is_uicc_enable is true should never happen. Same for eSE.",
        "proto" :"int st21nfca_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "in [NFC_SE_UICC, ...]", // Please replace ... with other possible values
        },
    }
},
{
    "kretprobe:st21nfca_hci_se_io": {
        "description": "This function handles the secure element I/O operations for the ST21NFCA NFC controller. It sends an APDU to the secure element and sets up a callback for the response.",
        "proto": "int st21nfca_hci_se_io(struct nfc_hci_dev *hdev, u32 se_idx, u8 *apdu, size_t apdu_length, se_io_cb_t cb, void *cb_context)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "in [ST21NFCA_ESE_HOST_ID, ...]",
            "apdu": "!=null",
            "apdu_length": ">0",
            "cb": "!=null",
            "cb_context": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, ...]"
        }
    }
},
{
    "kprobe:st21nfca_hci_se_io": {
        "description": "This function handles the secure element I/O operations for the ST21NFCA NFC controller. It sets up the callback and context, starts a timer, and sends an event. If the secure element index is not recognized, it frees the callback context and returns a negative value.",
        "proto" :"static long (*st21nfca_hci_se_io)(struct nfc_hci_dev  hdev, u32 se_idx, u8  apdu, size_t apdu_length, se_io_cb_t cb, void  cb_context)",
        "pre": {
            "hdev": "!=null",
            "se_idx": "in [ST21NFCA_ESE_HOST_ID, ...]",
            "apdu": "!=null",
            "apdu_length": ">=0",
            "cb": "!=null",
            "cb_context": "!=null"
        },
    }
},
{
    "kretprobe:st21nfca_connectivity_event_received": {
        "description": "Processes NFC events, including ST21NFCA_EVT_TRANSACTION.",
        "proto" :"int (*st21nfca_connectivity_event_received)(struct nfc_hci_dev *hdev, u8 host, u8 event, struct sk_buff *skb)",
        "pre": {
            "hdev": "!=null",
            "skb": "!=null",
            "skb->len": ">=2",
            "skb->data[0]": "==NFC_EVT_TRANSACTION_AID_TAG",
            "skb->data[1]": "<=sizeof(transaction->aid)",
            "skb->len": ">=skb->data[1] + 4"
        },
    }
},
{
    "kprobe:st21nfca_connectivity_event_received": {
        "description": "Handles connectivity events received from ST21NFCA.",
        "proto" :"int (*st21nfca_connectivity_event_received)(struct nfc_hci_dev *hdev, u8 host, u8 event, struct sk_buff *skb)",
        "pre": {
            "hdev": "!=null",
            "host": "in [possible host values]",
            "event": "in [ST21NFCA_EVT_CONNECTIVITY, ST21NFCA_EVT_TRANSACTION]",
            "skb": "!=null",
            "skb->len": ">=2",
            "skb->data[0]": "==NFC_EVT_TRANSACTION_AID_TAG",
            "skb->data[1]": "in [possible aid_len values]",
            "skb->len": ">=skb->data[1] + 4",
            "skb->data[1]": "<=sizeof(transaction->aid)",
            "skb->data[skb->data[1] + 3]": "in [possible params_len values]"
        },
    }
},
{
    "kretprobe:timer_setup": {
        "description": "Initialize a timer to call the function pointed to by the function pointer argument when it expires.",
        "proto" :"void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), int flags)",
        "pre": {
            "timer": "!=null",
            "callback": "!=null",
            "flags": "==0"
        }
    }
},
{
    "kprobe:my_function": {
        "description": "This function does something.",
        "proto" :"static long (*my_function)(int *a, int b)",
        "pre": {
            "a": "!=null",
            "b": ">=0",
        },
        "post": {
            "*a": "==old(*a)+b",
        },
    }
},
{
    "kretprobe:find_first_zero_bit": {
        "description": "Finds the first zero bit in the given bit mask.",
        "proto" :"static long (*find_first_zero_bit)(const unsigned long *dev_mask, int ST21NFCA_NUM_DEVICES)",
        "pre": {
            "dev_mask": "!=null",
            "ST21NFCA_NUM_DEVICES": ">=0"
        },
        "post": {
            "return": "<=ST21NFCA_NUM_DEVICES"
        }
    }
},

{
    "kretprobe:st21nfca_im_send_atr_req": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "hdev": "Your condition here",
            "gb": "Your condition here",
            "gb_len": "Your condition here",
            "info": "Your condition here",
            "atr_req": "Your condition here",
            "target": "Your condition here",
            "size": "Your condition here",
            "skb": "Your condition here"
        },
    }
},

{
    "kretprobe:pn544_hci_probe": {
        "description": "This function is used to probe the pn544 hci device. It initializes the device and sets up the necessary protocols.",
        "proto" :"pn544_hci_probe(void  phy_id, const struct nfc_phy_ops  phy_ops, char  llc_name, int phy_headroom, int phy_tailroom, int phy_payload, fw_download_t fw_download, struct nfc_hci_dev   hdev)",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        },
        "post": {
            "info": "!=null",
            "info->phy_ops": "==phy_ops",
            "info->phy_id": "==phy_id",
            "info->fw_download": "==fw_download",
            "info->state": "==PN544_ST_COLD",
            "init_data.gate_count": "==ARRAY_SIZE(pn544_gates)",
            "init_data.gates": "==pn544_gates",
            "init_data.session_id": "==\"ID544HCI\"",
            "protocols": "==NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | NFC_PROTO_FELICA_MASK | NFC_PROTO_ISO14443_MASK | NFC_PROTO_ISO14443_B_MASK | NFC_PROTO_NFC_DEP_MASK",
            "info->hdev": "==nfc_hci_allocate_device(&pn544_hci_ops, &init_data, 0, protocols, llc_name, phy_headroom + PN544_CMDS_HEADROOM, phy_tailroom, phy_payload)"
        }
    }
},
{
    "kprobe:pn544_hci_probe": {
        "description": "Probes the pn544 hci device.",
        "proto": "void (*pn544_hci_probe)(void  phy_id, const struct nfc_phy_ops  phy_ops, char  llc_name, int phy_headroom, int phy_tailroom, int phy_payload, fw_download_t fw_download, struct nfc_hci_dev   hdev)",
        "pre": {
            "phy_id": "!=null",
            "phy_ops": "!=null",
            "llc_name": "!=null",
            "phy_headroom": ">=0",
            "phy_tailroom": ">=0",
            "phy_payload": ">=0",
            "fw_download": "!=null",
            "hdev": "!=null"
        }
    }
},
{
    "kretprobe:st_nci_se_io": {
        "description": "Handles the I/O operations for the NCI device. Frees the cb_context in case of an error.",
        "proto" :"st_nci_se_io(struct nci_dev ndev, u32 se_idx, u8 apdu, size_t apdu_length, se_io_cb_t cb, void cb_context)",
        "pre": {
            "ndev": "!=null",
            "se_idx": "in [ST_NCI_ESE_HOST_ID, ...]",
            "apdu": "!=null",
            "apdu_length": ">=0",
            "cb": "!=null",
            "cb_context": "!=null"
        },
    }
},
{
    "kprobe:st_nci_se_io": {
        "description": "Handles the I/O operations for the NCI device. If the se_idx is not ST_NCI_ESE_HOST_ID, it frees the cb_context and returns a negative value.",
        "proto" :"static long (*st_nci_se_io)(struct nci_dev *ndev, u32 se_idx, u8 *apdu, size_t apdu_length, se_io_cb_t cb, void *cb_context)",
        "pre": {
            "ndev": "!=null",
            "se_idx": "in [ST_NCI_ESE_HOST_ID, ...]",
            "apdu": "!=null",
            "apdu_length": ">=0",
            "cb": "!=null",
            "cb_context": "!=null"
        },
    }
},
{
    "kretprobe:timer_setup": {
        "description": "Initialize a timer with the given function and data.",
        "proto" :"void timer_setup(struct timer_list *timer, void (*callback)(struct timer_list *), int flags)",
        "pre": {
            "timer": "!=null",
            "callback": "!=null",
            "flags": "in [0]"
        },
    }
},
{
    "kprobe:st_nci_se_init": {
        "description": "Initialize the secure element information and timers in the nci device.",
        "proto" :"static long (*st_nci_se_init)(struct nci_dev *ndev, struct st_nci_se_status *se_status)",
        "pre": {
            "ndev": "!=null",
            "se_status": "!=null"
        },
    }
},
{
    "kretprobe:ndlc_open": {
        "description": "Toggle reset pin",
        "proto" :"EXPORT_SYMBOL(ndlc_open(struct llt_ndlc *ndlc))",
        "pre": {
            "ndlc": "!=null",
        },
    }
},
{
    "kprobe:ndlc_open": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "Your first argument": "Your first argument's constraints",
            "Your second argument": "Your second argument's constraints",
            "Your third argument": "Your third argument's constraints",
            "Your fourth argument": "Your fourth argument's constraints",
        },
    }
},
{
    "kretprobe:ndlc->ops->enable": {
        "description": "Enables the ndlc with the given phy_id.",
        "proto" :"void (*enable)(__u64 phy_id)",
        "pre": {
            "phy_id": "!=null",
        },
    }
},
{
    "kprobe:ndlc->ops->enable": {
        "description": "Enable the ndlc with the given phy_id.",
        "proto" :"static void (*ndlc->ops->enable)(__u64 phy_id)",
        "pre": {
            "phy_id": "!=null",
        },
    }
},
{
    "kretprobe:ndlc_send": {
        "description": "Add ndlc header",
        "proto" :"static long (*ndlc_send)(struct llt_ndlc *ndlc, struct sk_buff *skb)",
        "pre": {
            "ndlc": "!=null",
            "skb": "!=null"
        },
        "post": "return == 0"
    }
},
{
    "kprobe:ndlc_send": {
        "description": "Add ndlc header",
        "proto" :"static long (*ndlc_send)(struct llt_ndlc *ndlc, struct sk_buff *skb)",
        "pre": {
            "ndlc": "!=null",
            "skb": "!=null"
        }
    }
},

{
    "kprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[argument1]": "[constraint1]",
            "[argument2]": "[constraint2]",
            "[argument3]": "[constraint3]",
            "[argument4]": "[constraint4]",
        },
    }
},


{
    "kretprobe:tc_register_driver": {
        "description": "Register a new TC driver. Adds the driver structure to the list of registered drivers. Returns a negative value on error, otherwise 0. If no error occurred, the driver remains registered even if no device was claimed during registration.",
        "proto": "int tc_register_driver(struct tc_driver *tdrv)",
        "pre": {
            "tdrv": "!=null"
        },
        "post": {
            "return": "in [0, negative values]"
        }
    }
},
{
    "kprobe:tc_register_driver": {
        "description": "Register a new TC driver. Adds the driver structure to the list of registered drivers. Returns a negative value on error, otherwise 0. If no error occurred, the driver remains registered even if no device was claimed during registration.",
        "proto" :"int tc_register_driver(struct tc_driver *tdrv)",
        "pre": {
            "tdrv": "!=null"
        }
    }
},
{
    "kretprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver. Deletes the driver structure from the list of registered TC drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void (*tc_unregister_driver)(struct tc_driver *tdrv)",
        "pre": {
            "tdrv": "!=null"
        }
    }
},
{
    "kprobe:tc_unregister_driver": {
        "description": "Unregister a TC driver. Deletes the driver structure from the list of registered TC drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void (*tc_unregister_driver)(struct tc_driver *tdrv)",
        "pre": {
            "tdrv": "!=null"
        }
    }
},
{
    "kretprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Mutex_lock(&tpg->acl_node_mutex); must be held when calling",
        "proto" :"struct se_node_acl *(*__core_tpg_get_initiator_node_acl)(struct se_portal_group *tpg, const char *initiatorname)",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null"
        },
    }
},
{
    "kprobe:__core_tpg_get_initiator_node_acl": {
        "description": "Mutex lock (&tpg->acl_node_mutex) must be held when calling this function.",
        "proto" :"struct se_node_acl *(__core_tpg_get_initiator_node_acl)(struct se_portal_group *tpg, const char *initiatorname)",
        "pre": {
            "tpg": "!=null",
            "initiatorname": "!=null",
            "tpg->acl_node_mutex": "locked"
        },
    }
},


{
    "kretprobe:core_tpg_set_initiator_node_queue_depth": {
        "description": "core_tpg_set_initiator_node_queue_depth() function",
        "proto" :"int (*core_tpg_set_initiator_node_queue_depth)(struct se_node_acl *acl, u32 queue_depth)",
        "pre": {
            "acl": "!=null",
            "queue_depth": ">0",
        },
    }
},
{
    "kprobe:core_tpg_set_initiator_node_queue_depth": {
        "description": "core_tpg_set_initiator_node_queue_depth()",
        "proto" :"int (*core_tpg_set_initiator_node_queue_depth)(struct se_node_acl *acl, u32 queue_depth)",
        "pre": {
            "acl": "!=null",
            "queue_depth": ">=0"
        }
    }
},
{
    "kretprobe:core_tpg_set_initiator_node_tag": {
        "description": "Initiator nodeacl tags are not used internally, but may be used by userspace to emulate aliases or groups. Returns length of newly-set tag or -EINVAL.",
        "proto" :"int (*core_tpg_set_initiator_node_tag)(struct se_portal_group *tpg, struct se_node_acl *acl, const char *new_tag)",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
    }
},
{
    "kprobe:core_tpg_set_initiator_node_tag": {
        "description": "Initiator nodeacl tags are not used internally, but may be used by userspace to emulate aliases or groups. Returns length of newly-set tag or -EINVAL.",
        "proto" :"int (*core_tpg_set_initiator_node_tag)(struct se_portal_group *tpg, struct se_node_acl *acl, const char *new_tag)",
        "pre": {
            "tpg": "!=null",
            "acl": "!=null",
            "new_tag": "!=null"
        },
    }
},
{
    "kretprobe:core_tpg_register": {
        "description": "For the typical case where core_tpg_register() is called by a fabric driver from target_core_fabric_ops->fabric_make_tpg() configfs context, use the original tf_ops pointer already saved by target-core in target_fabric_make_wwn(). Otherwise, for special cases like iscsi-target discovery TPGs the caller is responsible for setting ->se_tpg_tfo ahead of calling core_tpg_register().",
        "proto" :"int core_tpg_register(struct se_wwn *se_wwn, struct se_portal_group *se_tpg, int proto_id)",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "is integer"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:core_tpg_register": {
        "description": "Description of the function",
        "proto" :"core_tpg_register(struct se_wwn  se_wwn,struct se_portal_group  se_tpg,int proto_id)",
        "pre": {
            "se_wwn": "!=null",
            "se_tpg": "!=null",
            "proto_id": "is a valid protocol id",
        },
    }
},
{
    "kretprobe:list_for_each_entry_safe": {
        "description": "Release any remaining demo-mode generated se_node_acl that have not been released because of TFO->tpg_check_demo_mode_cache() == 1 in transport_deregister_session().",
        "proto" :"void list_for_each_entry_safe(struct se_node_acl nacl, struct se_node_acl nacl_tmp, struct list_head *node_list, struct list_head acl_list)",
        "pre": {
            "nacl": "!=null",
            "nacl_tmp": "!=null",
            "node_list": "!=null",
            "acl_list": "!=null"
        }
    }
},
{
    "kprobe:list_for_each_entry_safe": {
        "description": "Placeholder description for list_for_each_entry_safe",
        "proto" :"void list_for_each_entry_safe(struct se_node_acl nacl, struct se_node_acl nacl_tmp, struct list_head *node_list, struct list_head acl_list)",
        "pre": {
            "nacl": "!=null",
            "nacl_tmp": "!=null",
            "node_list": "!=null",
            "acl_list": "!=null"
        },
    }
},
{
    "kretprobe:spc_emulate_inquiry_std": {
        "description": "Set RMB (removable media) for tape devices",
        "proto": "void (*spc_emulate_inquiry_std)(struct se_cmd *cmd, unsigned char *buf)",
        "pre": {
            "cmd": "!=null",
            "buf": "!=null",
            "cmd->se_lun": "!=null",
            "cmd->se_dev": "!=null",
            "cmd->se_dev->transport": "!=null",
            "cmd->se_dev->transport->get_device_type": "!=null"
        },
        "post": {
            "buf[1]": "in [0x00, 0x80]",
            "buf[2]": "in [0x00, 0x06]"
        }
    }
},

{
    "kretprobe:spc_emulate_evpd_83": {
        "description": "Description of the function goes here",
        "proto" :"static long (*spc_emulate_evpd_83)(struct se_cmd cmd, unsigned char buf)",
        "pre": {
            "cmd": "!=null",
            "buf": "!=null",
            // Add other preconditions here
        },
        // Add postconditions here if any
    }
},
{
    "kprobe:spc_emulate_evpd_83": {
        "description": "NAA IEEE Registered Extended Assigned designator format, see spc4r17 section 7.7.3.6.5. We depend upon a target_core_modConfigFS provided syskernelconfigtargetcore$HBA$DEVwwnvpd_unit_serial value in order to return the NAA id.",
        "proto" :"static void (*spc_emulate_evpd_83)(struct se_cmd *cmd, unsigned char *buf)",
        "pre": {
            "cmd": "!=null",
            "buf": "!=null",
            "dev": "cmd->se_dev != null",
            "lun": "cmd->se_lun != null",
            "prod": "&dev->t10_wwn.model[0] != null",
            "off": "off = 4",
            "len": "len = 0",
            "id_len": "id_len is undefined",
            "dev_flags": "dev->dev_flags & DF_EMULATED_VPD_UNIT_SERIAL != 0"
        },
    }
},
{
    "kretprobe:spc_emulate_report_luns": {
        "description": "Description of the function goes here",
        "proto" :"static long (*spc_emulate_report_luns)(struct se_cmd  cmd)",
        "pre": {
            "cmd": "!=null",
            // Add other preconditions here
        },
        "post": {
            // Add postconditions here
        }
    }
},


{
    "kprobe:spc_parse_cdb": {
        "description": "Parses the SCSI command descriptor block (CDB) and sets the size and execute_cmd fields of the se_cmd structure accordingly.",
        "proto": "static void (*spc_parse_cdb)(struct se_cmd *cmd, unsigned int *size)",
        "pre": {
            "cmd": "!=null",
            "size": "!=null"
        },
        "post": {
            "size": "depends on the cdb[0] value",
            "cmd->execute_cmd": "depends on the cdb[0] value"
        }
    }
},
{
    "kretprobe:transport_init_session": {
        "description": "Initialize a session object. The caller must have zero-initialized @se_sess before calling this function.",
        "proto" :"void (*transport_init_session)(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null && is_zero_initialized"
        }
    }
},
{
    "kprobe:transport_init_session": {
        "description": "Initialize a session object. The caller must have zero-initialized @se_sess before calling this function.",
        "proto" :"void (*transport_init_session)(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null && is_zero_initialized"
        }
    }
},
{
    "kretprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it. @sup_prot_ops: bitmask that defines which T10-PI modes are supported.",
        "proto" :"struct se_session *(*transport_alloc_session)(enum target_prot_op sup_prot_ops)",
        "pre": {
            "sup_prot_ops": "!=null"
        }
    }
},
{
    "kprobe:transport_alloc_session": {
        "description": "Allocate a session object and initialize it. @sup_prot_ops: bitmask that defines which T10-PI modes are supported.",
        "proto" :"struct se_session *(*transport_alloc_session)(enum target_prot_op sup_prot_ops)",
        "pre": {
            "sup_prot_ops": "is bitmask"
        }
    }
},
{
    "kretprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data. @se_sess: Session pointer. @tag_num: Maximum number of in-flight commands between initiator and target. @tag_size: Size in bytes of the private data a target driver associates with each command.",
        "proto" :"int (*transport_alloc_session_tags)(struct se_session *se_sess, unsigned int tag_num, unsigned int tag_size)",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0"
        },
    }
},
{
    "kprobe:transport_alloc_session_tags": {
        "description": "Allocate target driver private data. Maximum number of in-flight commands between initiator and target. Size in bytes of the private data a target driver associates with each command.",
        "proto" :"int (*transport_alloc_session_tags)(struct se_session *se_sess, unsigned int tag_num, unsigned int tag_size)",
        "pre": {
            "se_sess": "!=null",
            "tag_num": ">0",
            "tag_size": ">0"
        },
    }
},
{
    "kretprobe:transport_register_session": {
        "description": "Used by struct se_node_acl's under ConfigFS to locate active se_session-t. Only set for struct se_session's that will actually be moving IO. eg: NOT discovery sessions.",
        "proto" :"static long (*transport_register_session)(struct se_portal_group se_tpg, struct se_node_acl se_nacl, struct se_session se_sess, void fabric_sess_ptr)",
        "pre": {
            "se_tpg": "!=null",
            "se_nacl": "!=null",
            "se_sess": "!=null",
            "fabric_sess_ptr": "!=null"
        },
    }
},
{
    "kprobe:transport_register_session": {
        "description": "Used by struct se_node_acl's under ConfigFS to locate active se_session-t. Only set for struct se_session's that will actually be moving IO. eg: NOT discovery sessions.",
        "proto" :"static long (*transport_register_session)(struct se_portal_group se_tpg, struct se_node_acl se_nacl, struct se_session se_sess, void fabric_sess_ptr)",
        "pre": {
            "se_nacl": "!=null",
        },
    }
},
{
    "kretprobe:target_setup_session": {
        "description": "Your function description here",
        "proto" :"target_setup_session(struct se_portal_group  tpg, unsigned int tag_num, unsigned int tag_size, enum target_prot_op prot_op, const char  initiatorname, void  private, int ( callback)(struct se_portal_group  , struct se_session  , void  ))",
        "pre": {
            "tpg": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0",
            "prot_op": "in [your enum values here]",
            "initiatorname": "!=null",
            "private": "!=null",
            "callback": "!=null"
        },
    }
},
{
    "kprobe:target_setup_session": {
        "description": "If the fabric driver is using percpu-ida based pre allocation of IO descriptor tags, go ahead and perform that setup now.",
        "proto" :"target_setup_session(struct se_portal_group tpg, unsigned int tag_num, unsigned int tag_size, enum target_prot_op prot_op, const char initiatorname, void private, int (callback)(struct se_portal_group, struct se_session, void))",
        "pre": {
            "tpg": "!=null",
            "tag_num": ">=0",
            "tag_size": ">=0",
            "prot_op": "in [enum values]",
            "initiatorname": "!=null",
            "private": "!=null",
            "callback": "!=null"
        },
    }
},
{
    "kretprobe:target_show_dynamic_sessions": {
        "description": "This function locks the session, iterates over the session list, and if the session has a node ACL and it is dynamic, it appends the initiator name to the page. If the length of the initiator name plus the current length exceeds the page size, it breaks the loop.",
        "proto" :"void target_show_dynamic_sessions(struct se_portal_group *se_tpg, char *page)",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null"
        },
    }
},
{
    "kprobe:target_show_dynamic_sessions": {
        "description": "Show dynamic sessions for a given SCSI target portal group.",
        "proto" :"target_show_dynamic_sessions(struct se_portal_group *se_tpg, char *page)",
        "pre": {
            "se_tpg": "!=null",
            "page": "!=null"
        }
    }
},
{
    "kretprobe:transport_deregister_session_configfs": {
        "description": "Used by struct se_node_acl's under ConfigFS to locate active struct se_session",
        "proto" :"void transport_deregister_session_configfs(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null",
            "se_sess->se_node_acl": "!=null"
        },
    }
},
{
    "kprobe:transport_deregister_session_configfs": {
        "description": "Used by struct se_node_acl's under ConfigFS to locate active struct se_session",
        "proto" :"void transport_deregister_session_configfs(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null",
            "se_sess->se_node_acl": "!=null"
        },
    }
},
{
    "kretprobe:__transport_register_session": {
        "description": "Called with spin_lock_irqsave(&struct se_portal_group->session_lock called. transport_free_session(se_sess);return ERR_PTR(-ENOMEM);}return se_sess;",
        "proto" :"void __transport_register_session(struct se_portal_group *se_tpg,struct se_node_acl *se_nacl,struct se_session *se_sess,void *fabric_sess_ptr)",
        "pre": {
            "se_tpg": "constraint for se_tpg",
            "se_nacl": "constraint for se_nacl",
            "se_sess": "constraint for se_sess",
            "fabric_sess_ptr": "constraint for fabric_sess_ptr",
        },
    }
},
{
    "kprobe:__transport_register_session": {
        "description": "This function's description is not provided in the helper doc.",
        "proto" :"void (*__transport_register_session)(struct se_portal_group *se_tpg,struct se_node_acl *se_nacl,struct se_session *se_sess,void *fabric_sess_ptr)",
        "pre": {
            "se_tpg": "!=null",
            "se_nacl": "!=null",
            "se_sess": "!=null",
            "fabric_sess_ptr": "!=null",
        },
    }
},
{
    "kretprobe:transport_set_vpd_proto_id": {
        "description": "Check if the Protocol Identifier Valid (PIV) bit is set. From spc3r23.pdf section 7.5.1",
        "proto" :"static long (*transport_set_vpd_proto_id)(struct t10_vpd vpd, unsigned char page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "is an array of at least 2 bytes"
        },
        "post": {
            "return": "is either 0 (if PIV bit is not set) or 1 (if PIV bit is set)"
        }
    }
},
{
    "kprobe:transport_set_vpd_proto_id": {
        "description": "Check if the Protocol Identifier Valid (PIV) bit is set.. from spc3r23.pdf section 7.5.1",
        "proto" :"static void (*transport_set_vpd_proto_id)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null",
            "page_83[1]": "in [0x00, 0xFF]",
            "page_83[1] & 0x80": "is boolean"
        },
    }
},
{
    "kretprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association from spc3r23.pdf Section 7.6.3.1 Table 297.",
        "proto" :"static long (*transport_set_vpd_assoc)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        }
    }
},
{
    "kprobe:transport_set_vpd_assoc": {
        "description": "The VPD identification association from spc3r23.pdf Section 7.6.3.1 Table 297.",
        "proto" :"static long (*transport_set_vpd_assoc)(struct t10_vpd *vpd, unsigned char page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "in [0x00, 0xFF]"
        },
    }
},
{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type from spc3r23.pdf Section 7.6.3.1 Table 298.",
        "proto" :"static long (*transport_set_vpd_ident_type)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
    }
},
{
    "kprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type from spc3r23.pdf Section 7.6.3.1 Table 298.",
        "proto" :"static long (*transport_set_vpd_ident_type)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
    }
},
{
    "kretprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type from spc3r23.pdf Section 7.6.3.1 Table 298",
        "proto" :"static long (*transport_set_vpd_ident_type)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null"
        },
    }
},
{
    "kprobe:transport_set_vpd_ident_type": {
        "description": "The VPD identifier type from spc3r23.pdf Section 7.6.3.1 Table 298",
        "proto" :"static long (*transport_set_vpd_ident_type)(struct t10_vpd *vpd, unsigned char *page_83)",
        "pre": {
            "vpd": "!=null",
            "page_83": "!=null",
        },
    }
},
{
    "kretprobe:sense_reason_ttarget_cmd_size_check": {
        "description": "__target_init_cmd(). Return: TCM_NO_SENSE",
        "proto" :"static long (*sense_reason_ttarget_cmd_size_check)(struct se_cmd *cmd, unsigned int size)",
        "pre": {
            "cmd": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kprobe:sense_reason_ttarget_cmd_size_check": {
        "description": "__target_init_cmd(). Return: TCM_NO_SENSE",
        "proto" :"static long (*sense_reason_ttarget_cmd_size_check)(struct se_cmd *cmd, unsigned int size)",
        "pre": {
            "cmd": "!=null",
            "size": ">0",
        },
    }
},
{
    "kretprobe:target_cmd_init_cdb": {
        "description": "Ensure that the received CDB is less than the max (252 + 8) bytes for VARIABLE_LENGTH_CMD",
        "proto" :"sense_reason_t (*target_cmd_init_cdb)(struct se_cmd *cmd, unsigned char *cdb, gfp_t gfp)",
        "pre": {
            "cmd": "!=null",
            "cdb": "<=SCSI_MAX_VARLEN_CDB_SIZE",
            "gfp": "!=null"
        },
    }
},
{
    "kprobe:target_cmd_init_cdb": {
        "description": "Ensure that the received CDB is less than the max (252 + 8) bytes for VARIABLE_LENGTH_CMD",
        "proto" :"static sense_reason_t (*target_cmd_init_cdb)(struct se_cmd *cmd, unsigned char *cdb, gfp_t gfp)",
        "pre": {
            "cmd": "!=null",
            "cdb": "!=null",
            "gfp": "is valid gfp_t value",
            "scsi_command_size(cdb)": "<= SCSI_MAX_VARLEN_CDB_SIZE"
        },
    }
},
{
    "kretprobe:transport_handle_cdb_direct": {
        "description": "Set TRANSPORT_NEW_CMD state and CMD_T_ACTIVE to ensure that outstanding descriptors are handled correctly during shutdown via transport_wait_for_tasks(). Also, we don't take cmd->t_state_lock here as we only expect this to be called for initial descriptor submission.",
        "proto" :"sense_reason_t (*transport_handle_cdb_direct)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:transport_handle_cdb_direct": {
        "description": "Set TRANSPORT_NEW_CMD state and CMD_T_ACTIVE to ensure that outstanding descriptors are handled correctly during shutdown via transport_wait_for_tasks(). Also, we don't take cmd->t_state_lock here as we only expect this to be called for initial descriptor submission.",
        "proto" :"transport_handle_cdb_direct(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->se_lun": "!=null"
        },
    }
},
{
    "kretprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd. This function must only be used by drivers that do their own sync during shutdown and does not use target_stop_session. If there is a failure this function will call into the fabric driver's queue_status with a CHECK_CONDITION.",
        "proto" :"void (*target_submit_cmd)(struct se_cmd *se_cmd, struct se_session *se_sess, unsigned char *cdb, unsigned char *sense, u64 unpacked_lun, u32 data_length, int task_attr, int data_dir, int flags)",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": ">=0",
            "data_length": ">=0",
            "task_attr": "in [SAM_TASK_ATTRIBUTES]",
            "data_dir": "in [DMA_DATA_DIRECTION]",
            "flags": "in [TARGET_SC_FLAGS]"
        }
    }
},
{
    "kprobe:target_submit_cmd": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd. This function must only be used by drivers that do their own sync during shutdown and does not use target_stop_session. If there is a failure this function will call into the fabric driver's queue_status with a CHECK_CONDITION.",
        "proto" :"void (*target_submit_cmd)(struct se_cmd *se_cmd, struct se_session *se_sess, unsigned char *cdb, unsigned char *sense, u64 unpacked_lun, u32 data_length, int task_attr, int data_dir, int flags)",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "cdb": "!=null",
            "sense": "!=null",
            "unpacked_lun": ">=0",
            "data_length": ">=0",
            "task_attr": "in [SAM_TASK_ATTRIBUTES]",
            "data_dir": "in [DMA_DATA_DIRECTION]",
            "flags": "in [TARGET_SC_FLAGS]"
        }
    }
},
{
    "kretprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs.",
        "proto" :"int (*target_submit_tmr)(struct se_cmd *se_cmd, struct se_session *se_sess, unsigned char *sense, u64 unpacked_lun, void *fabric_tmr_ptr, unsigned char tm_type, gfp_t gfp, u64 tag, int flags)",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": ">=0",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "in [TM_ABORT_TASK, TM_ABORT_TASK_SET, TM_CLEAR_ACA, TM_CLEAR_TASK_SET, TM_LUN_RESET, TM_TARGET_WARM_RESET, TM_TARGET_COLD_RESET, TM_ACA, TM_QUERY_TASK, TM_QUERY_TASK_SET, TM_QUERY_ASYNCHRONOUS_EVENT]",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM, __GFP_RECLAIMABLE, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]",
            "tag": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:target_submit_tmr": {
        "description": "Lookup unpacked lun and submit uninitialized se_cmd for TMR CDBs.",
        "proto" :"int (*target_submit_tmr)(struct se_cmd *se_cmd, struct se_session *se_sess, unsigned char *sense, u64 unpacked_lun, void *fabric_tmr_ptr, unsigned char tm_type, gfp_t gfp, u64 tag, int flags)",
        "pre": {
            "se_cmd": "!=null",
            "se_sess": "!=null",
            "sense": "!=null",
            "unpacked_lun": ">=0",
            "fabric_tmr_ptr": "!=null",
            "tm_type": "in [TM_ABORT_TASK, TM_ABORT_TASK_SET, TM_CLEAR_ACA, TM_CLEAR_TASK_SET, TM_LUN_RESET, TM_TARGET_WARM_RESET, TM_TARGET_COLD_RESET, TM_ACA]",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_HIGHUSER, GFP_NOFS, GFP_NOIO, GFP_NOWAIT]",
            "tag": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:transport_get_sense_buffer": {
        "description": "Used when asking transport to copy Sense Data from the underlying LinuxSCSI struct scsi_cmnd",
        "proto" :"static unsigned char *(*transport_get_sense_buffer)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:transport_get_sense_buffer": {
        "description": "Used when asking transport to copy Sense Data from the underlying LinuxSCSI struct scsi_cmnd.",
        "proto" :"static unsigned char *(*transport_get_sense_buffer)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},

{
    "kprobe:target_execute_cmd": {
        "description": "Check for an existing UNIT ATTENTION condition after target_handle_task_attr() has done SAM task attr checking, and possibly have already defered execution out to target_restart_delayed_cmds() context.",
        "proto" :"sense_reason_t (*target_execute_cmd)(struct se_cmd *cmd, bool do_checks)",
        "pre": {
            "cmd": "!=null",
            "do_checks": "in [true, false]"
        },
    }
},
{
    "kretprobe:transport_kmap_data_sg": {
        "description": "We need to take into account a possible offset here for fabrics like tcm_loop who may be using a contig buffer from the SCSI midlayer for control CDBs passed as SGLs via transport_generic_map_mem_to_cmd()",
        "proto" :"struct page* (*transport_kmap_data_sg)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->t_data_nents": ">=1",
            "cmd->t_data_sg": "!=null"
        },
    }
},
{
    "kprobe:transport_kmap_data_sg": {
        "description": "We need to take into account a possible offset here for fabrics like tcm_loop who may be using a contig buffer from the SCSI midlayer for control CDBs passed as SGLs via transport_generic_map_mem_to_cmd()",
        "proto" :"static void* (*transport_kmap_data_sg)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->t_data_nents": ">=0",
            "cmd->t_data_sg": "!=null"
        },
    }
},
{
    "kretprobe:transport_generic_new_cmd": {
        "description": "transport_generic_new_cmd() is already handling QUEUE_FULL, so follow TRANSPORT_NEW_CMD processing thread context usage and call transport_generic_request_failure() if necessary.",
        "proto" :"static long (*transport_generic_new_cmd)(cmd);if (ret)transport_generic_request_failure(cmd, ret);return 0;}EXPORT_SYMBOL(transport_handle_cdb_direct);sense_reason_ttransport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)",
        "pre": {
            "cmd": "!=null",
            "ret": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0"
        },
    }
},
{
    "kprobe:transport_generic_new_cmd": {
        "description": "transport_generic_new_cmd() is already handling QUEUE_FULL, so follow TRANSPORT_NEW_CMD processing thread context usage and call transport_generic_request_failure() if necessary.",
        "proto" :"static long (*transport_generic_new_cmd)(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)",
        "pre": {
            "cmd": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "!=null",
            "sgl_bidi_count": ">=0",
        },
    }
},
{
    "kretprobe:transport_generic_free_cmd": {
        "description": "transport_generic_free_cmd() skips its call to target_put_sess_cmd(). - For aborted commands for which CMD_T_TAS has been set .queue_status() will be called and will drop a reference. - For aborted commands for which CMD_T_TAS has not been set .aborted_task() will be called. target_handle_abort() will drop the final reference.",
        "proto" :"int (*transport_generic_free_cmd)(struct se_cmd *cmd, int wait_for_tasks)",
        "pre": {
            "cmd": "!=null",
            "wait_for_tasks": "in [0, 1]"
        }
    }
},
{
    "kprobe:transport_generic_free_cmd": {
        "description": "transport_generic_free_cmd() skips its call to target_put_sess_cmd(). For aborted commands for which CMD_T_TAS has been set .queue_status() will be called and will drop a reference. For aborted commands for which CMD_T_TAS has not been set .aborted_task() will be called. target_handle_abort() will drop the final reference.",
        "proto" :"int transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)",
        "pre": {
            "cmd": "[Your condition here]",
            "wait_for_tasks": "[Your condition here]"
        },
    }
},
{
    "kretprobe:target_submit_prep": {
        "description": "Prepare cmd for submission. If failure is returned, lio will the callers queue_status to complete the cmd.",
        "proto" :"int target_submit_prep(struct se_cmd *se_cmd, unsigned char *cdb, struct scatterlist *sgl, u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count, struct scatterlist *sgl_prot, u32 sgl_prot_count, gfp_t gfp)",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "can be null",
            "sgl_bidi_count": ">=0",
            "sgl_prot": "can be null",
            "sgl_prot_count": ">=0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "in [-n, 0] where n is a positive integer"
        }
    }
},
{
    "kprobe:target_submit_prep": {
        "description": "Prepare cmd for submission. Returns less than zero to signal failure, zero on success. If failure is returned, lio will the callers queue_status to complete the cmd.",
        "proto" :"int (*target_submit_prep)(struct se_cmd *se_cmd, unsigned char *cdb, struct scatterlist *sgl, u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count, struct scatterlist *sgl_prot, u32 sgl_prot_count, gfp_t gfp)",
        "pre": {
            "se_cmd": "!=null",
            "cdb": "!=null",
            "sgl": "!=null",
            "sgl_count": ">=0",
            "sgl_bidi": "can be null",
            "sgl_bidi_count": ">=0 if sgl_bidi != null",
            "sgl_prot": "can be null",
            "sgl_prot_count": ">=0 if sgl_prot != null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},

{
    "kprobe:target_put_sess_cmd": {
        "description": "Establish a unit attention condition on the I_T nexus associated with cmd. See also the paragraph 'Aborting commands' in SAM.",
        "proto" :"static long (*target_put_sess_cmd)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
        },
    }
},
{
    "kretprobe:transport_complete_task_attr": {
        "description": "For SAM Task Attribute emulation for failed struct se_cmd",
        "proto" :"void transport_complete_task_attr(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    },
    "kretprobe:transport_complete_callback": {
        "description": "Callback function for transport completion",
        "proto" :"void (*transport_complete_callback)(struct se_cmd *cmd, bool failed, int *post_ret)",
        "pre": {
            "cmd": "!=null",
            "failed": "is bool",
            "post_ret": "!=null"
        }
    },
    "kretprobe:CMD_T_ABORTED": {
        "description": "Check if the command is aborted",
        "proto" :"bool CMD_T_ABORTED(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:transport_complete_task_attr": {
        "description": "For SAM Task Attribute emulation for failed struct se_cmd",
        "proto" :"static void (*transport_complete_task_attr)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
    },
    "kprobe:transport_complete_callback": {
        "description": "Callback function for transport completion",
        "proto" :"void (*transport_complete_callback)(struct se_cmd *cmd, bool, int *post_ret)",
        "pre": {
            "cmd": "!=null",
            "post_ret": "!=null"
        },
    },
    "kprobe:CMD_T_ABORTED": {
        "description": "Check if the command has been aborted",
        "proto" :"int (*CMD_T_ABORTED)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
    }
},
{
    "kretprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1",
            "param2": "Your condition for param2",
            "param3": "Your condition for param3",
            "param4": "Your condition for param4",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1 here",
            "param2": "Your condition for param2 here",
            "param3": "Your condition for param3 here",
            "param4": "Your condition for param4 here",
        },
    }
},
{
    "kretprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands @se_sess: session to wait for active IO",
        "proto" :"void (*target_wait_for_sess_cmds)(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kprobe:target_wait_for_sess_cmds": {
        "description": "Wait for outstanding commands @se_sess: session to wait for active IO",
        "proto" :"void (*target_wait_for_sess_cmds)(struct se_session *se_sess)",
        "pre": {
            "se_sess": "!=null"
        }
    }
},
{
    "kretprobe:transport_cmd_check_stop_to_fabric": {
        "description": "transport_wait_for_tasks() for t_transport_stop_comp.",
        "proto" :"static int (*transport_cmd_check_stop_to_fabric)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
        },
    }
},



{
    "kretprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator. Only call this function if target_submit_cmd() failed.",
        "proto" :"int (*target_send_busy)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:target_send_busy": {
        "description": "Send SCSI BUSY status back to the initiator. Only call this function if target_submit_cmd() failed.",
        "proto" :"int (*target_send_busy)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},

{
    "kprobe:target_submit_tmr": {
        "description": "For callback during failure handling, push this work off to process context with TMR_LUN_DOES_NOT_EXIST status.",
        "proto" :"static long (*target_submit_tmr)(void *se_cmd)",
        "pre": {
            "se_cmd": "!=null",
        },
    }
},

{
    "kprobe:sbc_get_write_same_sectors": {
        "description": "This function gets the number of sectors to write the same data based on the command type.",
        "proto" :"sbc_get_write_same_sectors(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->t_task_cdb[0]": "in [WRITE_SAME, WRITE_SAME_16, WRITE_SAME_32]",
            "cmd->t_task_cdb[7]": "!=null",
            "cmd->t_task_cdb[10]": "!=null",
            "cmd->t_task_cdb[28]": "!=null"
        },
    }
},
{
    "kretprobe:sbc_parse_cdb": {
        "description": "Parse the command descriptor block (CDB) of a SCSI command and execute the corresponding operation.",
        "proto": "sense_reason_t (*sbc_parse_cdb)(struct se_cmd *cmd, struct exec_cmd_ops *ops)",
        "pre": {
            "cmd": "!=null",
            "ops": "!=null"
        },
        "post": {
            "sectors": ">1"
        }
    }
},
{
    "kprobe:sbc_parse_cdb": {
        "description": "This function parses the command descriptor block (CDB) of a SCSI command. It sets the sectors, logical block address (LBA), command flags, and execute command based on the opcode in the CDB. It also checks for certain conditions and returns an error if they are not met.",
        "proto": "sense_reason_t (*sbc_parse_cdb)(struct se_cmd *cmd, struct exec_cmd_ops *ops)",
        "pre": {
            "cmd": "!=null",
            "ops": "!=null",
            "sectors": ">1"
        }
    }
},
{
    "kretprobe:core_alua_check_nonop_delay": {
        "description": "The ALUA ActiveNonOptimized access state delay can be disabled in via configfs with a value of zero",
        "proto" :"static long (*core_alua_check_nonop_delay)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->se_cmd_flags": "in [SCF_ALUA_NON_OPTIMIZED]"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:core_alua_check_nonop_delay": {
        "description": "The ALUA ActiveNonOptimized access state delay can be disabled in via configfs with a value of zero.",
        "proto" :"static long (*core_alua_check_nonop_delay)(struct se_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->se_cmd_flags": "in [SCF_ALUA_NON_OPTIMIZED]",
            "cmd->alua_nonop_delay": "!=null"
        },
    }
},

{
    "kprobe:if (se_cmd->orig_fe_lun != 0)": {
        "description": "Checks if the orig_fe_lun attribute of the se_cmd object is not equal to 0.",
        "proto" :"static long (*if (se_cmd->orig_fe_lun != 0))(void *se_cmd)",
        "pre": {
            "se_cmd": "!=null",
            "se_cmd->orig_fe_lun": "!=0",
        },
    }
},
{
    "kretprobe:target_configure_unmap_from_queue": {
        "description": "Configure the unmap attributes from the queue. The function calculates the unmap granularity and alignment based on the block device's discard granularity and alignment. It also sets the max_unmap_block_desc_count to 1. The function returns true if the block device supports discarding sectors, otherwise it returns false.",
        "proto" :"bool (*target_configure_unmap_from_queue)(struct se_dev_attrib *attrib, struct block_device *bdev)",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null"
        },
        "post": {
            "attrib->max_unmap_block_desc_count": "=1",
            "attrib->unmap_granularity": "=bdev_discard_granularity(bdev) / block_size",
            "attrib->unmap_granularity_alignment": "=bdev_discard_alignment(bdev) / block_size",
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:target_configure_unmap_from_queue": {
        "description": "Configures unmap from queue. Currently hardcoded to 1 in LinuxSCSI code.",
        "proto": "bool (*target_configure_unmap_from_queue)(struct se_dev_attrib *attrib, struct block_device *bdev)",
        "pre": {
            "attrib": "!=null",
            "bdev": "!=null",
            "block_size": "bdev_logical_block_size(bdev)",
            "max_unmap_lba_count": "bdev_max_discard_sectors(bdev) >> (ilog2(block_size) - 9)",
            "max_unmap_block_desc_count": "=1",
            "unmap_granularity": "bdev_discard_granularity(bdev) / block_size",
            "unmap_granularity_alignment": "bdev_discard_alignment(bdev) / block_size"
        }
    }
},


{
    "kretprobe:target_unregister_template": {
        "description": "Wait for any outstanding fabric se_deve_entry->rcu_head callbacks to complete post kfree_rcu(), before allowing fabric driver unload of TFO->module to proceed.",
        "proto" :"target_unregister_template(const struct target_core_fabric_ops  fo)",
        "pre": {
            "fo": "!=null"
        },
    }
},
{
    "kprobe:target_unregister_template": {
        "description": "Wait for any outstanding fabric se_deve_entry->rcu_head callbacks to complete post kfree_rcu(), before allowing fabric driver unload of TFO->module to proceed.",
        "proto" :"target_unregister_template(const struct target_core_fabric_ops  fo)",
        "pre": {
            "fo": "!=null",
            "t": "!=null",
            "t->tf_ops": "!=null",
            "t->tf_tpg_base_cit.ct_attrs": "!=null",
            "t->tf_access_cnt": "==0",
            "t->tf_ops->fabric_name": "==fo->fabric_name"
        },
    }
},
{
    "kretprobe:rcu_barrier": {
        "description": "Wait for any outstanding backend driver ->rcu_head callbacks to complete post TBO->free_device() -> call_rcu(), before allowing backend driver module unload of target_backend_ops->owner to proceed.",
        "proto" :"void rcu_barrier(void)",
        "pre": {},
        "post": "return == 0"
    }
},
{
    "kprobe:target_backend_unregister": {
        "description": "Unregister the target backend. Wait for any outstanding backend driver ->rcu_head callbacks to complete post TBO->free_device() -> call_rcu(), before allowing backend driver module unload of target_backend_ops->owner to proceed.",
        "proto" :"static long (*target_backend_unregister)(const struct target_backend_ops *ops, struct target_backend *tb, struct mutex *backend_mutex, struct rcu_head *rcu_head)",
        "pre": {
            "ops": "!=null",
            "tb": "!=null",
            "backend_mutex": "!=null",
            "rcu_head": "!=null"
        },
    }
},
{
    "kretprobe:iscsit_sequence_cmd": {
        "description": "This function handles the sequence of commands in iSCSI.",
        "proto" :"int iscsit_sequence_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, unsigned char *buf, __be32 cmdsn)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": ">=0"
        },
    }
},
{
    "kprobe:iscsit_sequence_cmd": {
        "description": "This function handles the sequence of the iSCSI command. It locks the cmdsn_mutex, checks the received cmdsn, and executes the command based on the cmdsn_ret value. If the command execution fails, it sets the reject flag and returns an error.",
        "proto" :"int iscsit_sequence_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, unsigned char *buf, __be32 cmdsn)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "cmdsn": "!=null"
        },
    }
},
{
    "kretprobe:iscsit_allocate_cmd": {
        "description": "Description of the function goes here",
        "proto" :"struct iscsit_cmd *(*iscsit_allocate_cmd)(struct iscsit_conn *conn, int state)",
        "pre": {
            "conn": "!=null",
            "state": "is an integer"
        }
    }
},
{
    "kprobe:iscsit_allocate_cmd": {
        "description": "This function needs a more detailed description.",
        "proto" :"struct iscsit_cmd *(*iscsit_allocate_cmd)(struct iscsit_conn *conn, int state)",
        "pre": {
            "conn": "!=null",
            "state": "is an integer"
        }
    }
},
{
    "kretprobe:iscsit_setup_scsi_cmd": {
        "description": "Setup SCSI command for iSCSI connection.",
        "proto": "int iscsit_setup_scsi_cmd(struct iscsit_conn  conn, struct iscsit_cmd  cmd,  unsigned char  buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null"
        },
        "post": {
            "hdr->flags": "!(hdr->flags & ISCSI_FLAG_CMD_WRITE) && !(hdr->flags & ISCSI_FLAG_CMD_FINAL)"
        }
    }
},
{
    "kprobe:iscsit_setup_scsi_cmd": {
        "description": "Setup SCSI command for iSCSI target. It processes the iSCSI command and sets up the SCSI command.",
        "proto" :"void iscsit_setup_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, unsigned char *buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "hdr": "!=null",
            "hdr->flags": "in [ISCSI_FLAG_CMD_WRITE, ISCSI_FLAG_CMD_FINAL]",
            "!(hdr->flags & ISCSI_FLAG_CMD_WRITE)": "true",
            "!(hdr->flags & ISCSI_FLAG_CMD_FINAL)": "true"
        },
    }
},
{
    "kretprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached. A PDUCmdSN carrying Immediate Data can only be processed after the DataCRC has passed. If the DataCRC fails, the CmdSN MUST NOT be acknowledged.",
        "proto" :"int iscsit_process_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_scsi_req *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->immediate_data": "==false"
        },
    }
},
{
    "kprobe:iscsit_process_scsi_cmd": {
        "description": "Check the CmdSN against ExpCmdSNMaxCmdSN here if the Immediate Bit is not set, and no Immediate Data is attached. A PDUCmdSN carrying Immediate Data can only be processed after the DataCRC has passed. If the DataCRC fails, the CmdSN MUST NOT be acknowledged.",
        "proto" :"void iscsit_process_scsi_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_scsi_req *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": {
                "immediate_data": "==null"
            },
            "hdr": "!=null"
        },
    }
},
{
    "kretprobe:iscsit_check_dataout_hdr": {
        "description": "iSCSI write",
        "proto" :"int (*iscsit_check_dataout_hdr)(struct iscsit_conn *conn, void *buf, struct iscsit_cmd *cmd, u32 payload_length, bool success)",
        "pre": {
            "conn": "!=null",
            "buf": "!=null",
            "cmd": "!=null",
            "payload_length": ">=0",
            "success": "in [true, false]"
        },
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:iscsit_check_post_dataout": {
        "description": "Increment post receive data and CRC values or perform within-command recovery.",
        "proto" :"int (*iscsit_check_post_dataout)(struct iscsit_cmd *cmd, unsigned char *hdr, bool data_crc_failed)",
        "pre": {
            "cmd": "!=null",
            "hdr": "!=null",
            "data_crc_failed": "in [true, false]"
        },
        "post": {
            "rc": "in [DATAOUT_NORMAL, DATAOUT_WITHIN_COMMAND_RECOVERY, DATAOUT_SEND_R2T]"
        }
    }
},
{
    "kprobe:iscsit_check_dataout_payload": {
        "description": "Increment post receive data and CRC values or perform within-command recovery.",
        "proto" :"int iscsit_check_dataout_payload(struct iscsit_cmd *cmd, struct iscsi_data *hdr, bool data_crc_failed)",
        "pre": {
            "cmd": "!=null",
            "hdr": "!=null",
            "data_crc_failed": "is bool",
        },
    }
},
{
    "kretprobe:iscsit_setup_nop_out": {
        "description": "This function sets up a Nop-Out in the iSCSI target. It checks various conditions to ensure protocol compliance and handles different scenarios based on the opcode, ITT, TTT, and payload length.",
        "proto" :"int iscsit_setup_nop_out(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_nopout *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "can be null",
            "hdr": "!=null && hdr->ttt == cpu_to_be32(0xFFFFFFFF)"
        },
    }
},
{
    "kprobe:iscsit_setup_nop_out": {
        "description": "This function sets up a NOP-OUT message in the iSCSI protocol. It checks various conditions and flags to ensure the message is valid and can be processed correctly.",
        "proto" :"void iscsit_setup_nop_out(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_nopout *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "hdr->ttt": "== cpu_to_be32(0xFFFFFFFF)"
        },
    }
},
{
    "kretprobe:iscsit_process_nop_out": {
        "description": "Initiator is expecting a NopIN ping reply.",
        "proto" :"static long (*iscsit_process_nop_out)(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_nopout *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null && hdr->itt != RESERVED_ITT",
        },
    }
},
{
    "kprobe:iscsit_process_nop_out": {
        "description": "Initiator is expecting a NopIN ping reply.",
        "proto" :"static void (*iscsit_process_nop_out)(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_nopout *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null && hdr->itt != RESERVED_ITT",
        },
    }
},
{
    "kretprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handle task management command in iSCSI protocol.",
        "proto" :"int iscsit_handle_task_mgt_cmd(struct iscsit_conn  conn, struct iscsit_cmd  cmd, unsigned char  buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null"
        },
        "post": {
            "function": "!= ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kprobe:iscsit_handle_task_mgt_cmd": {
        "description": "Handles task management commands in iSCSI.",
        "proto": "int (*iscsit_handle_task_mgt_cmd)(struct iscsit_conn *conn, struct iscsit_cmd *cmd, unsigned char *buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "function": "!=ISCSI_TM_FUNC_TASK_REASSIGN"
        }
    }
},
{
    "kretprobe:iscsit_process_text_cmd": {
        "description": "Process the text command in iSCSI. The function checks if the text_in buffer is null, if it is, it sets the target transfer tag. If the target transfer tag is 0xFFFFFFFF, it logs an error and goes to reject. If the text_in buffer is not null, it checks if the text_in buffer starts with 'SendTargets=', if not, it logs an error and goes to reject. If it does, it checks if the text_in buffer contains '=All', if it does, it continues the process.",
        "proto" :"void iscsit_process_text_cmd(struct iscsit_conn *conn, struct iscsit_cmd *cmd, struct iscsi_text *hdr)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "hdr": "!=null",
            "cmd->text_in_ptr": "!=null",
            "hdr->ttt": "!=0xFFFFFFFF",
            "text_in": "startsWith('SendTargets=')",
            "text_ptr": "contains('=All')"
        },
    }
},
{
    "kprobe:iscsit_process_text_cmd": {
        "description": "Process the text command in iSCSI",
        "proto" :"void iscsit_process_text_cmd(struct iscsit_conn  conn, struct iscsit_cmd  cmd,struct iscsi_text  hdr)",
        "pre": {
            "text_in": "!=null",
            "text_in": "startsWith('SendTargets=')",
            "text_in": "contains('=')",
            "text_in": "substring(indexOf('=')) == '=All'"
        },
    }
},
{
    "kretprobe:iscsit_handle_logout_cmd": {
        "description": "Handles logout command in iSCSI",
        "proto" :"int iscsit_handle_logout_cmd(struct iscsit_conn  conn, struct iscsit_cmd  cmd, unsigned char  buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null"
        },
    }
},
{
    "kprobe:iscsit_handle_logout_cmd": {
        "description": "Handles the logout command in the iSCSI target.",
        "proto": "int (*iscsit_handle_logout_cmd)(struct iscsit_conn *conn, struct iscsit_cmd *cmd, unsigned char *buf)",
        "pre": {
            "conn": "!=null",
            "cmd": "!=null",
            "buf": "!=null",
            "conn->conn_state": "==TARG_CONN_STATE_LOGGED_IN",
            "hdr->opcode": "in [ISCSI_OP_LOGOUT, ISCSI_OP_IMMEDIATE]",
            "reason_code": "in [ISCSI_LOGOUT_REASON_CLOSE_SESSION, ISCSI_LOGOUT_REASON_CLOSE_CONNECTION, ISCSI_LOGOUT_REASON_RECOVERY]",
            "hdr->cid": "==conn->cid"
        }
    }
},
{
    "kretprobe:iscsit_handle_snack": {
        "description": "Handles ISCSI_INIT_SNACK, checks ErrorRecoveryLevel, and decides which function to call from inside iscsi_send_recovery_datain_or_r2t().",
        "proto" :"void iscsit_handle_snack(struct iscsit_conn  conn, unsigned char  buf)",
        "pre": {
            "conn": "!=null",
            "buf": "!=null"
        },
        "post": {
            "return": "in [ISCSI_REASON_PROTOCOL_ERROR, 0]"
        }
    },
    "kretprobe:switch": {
        "description": "Switches based on the flags of hdr after applying the ISCSI_FLAG_SNACK_TYPE_MASK mask.",
        "proto" :"void switch(hdr->flags & ISCSI_FLAG_SNACK_TYPE_MASK)",
        "pre": {
            "hdr->flags": "!=null"
        }
    }
},
{
    "kprobe:iscsit_handle_snack": {
        "description": "Handles SNACK request in iSCSI protocol. If ErrorRecoveryLevel is 0, it adds a reject. Otherwise, it checks which function to call from inside iscsi_send_recovery_datain_or_r2t().",
        "proto" :"void iscsit_handle_snack(struct iscsit_conn *conn, unsigned char *buf)",
        "pre": {
            "conn": "!=null",
            "buf": "!=null",
            "hdr->flags": "in [ISCSI_FLAG_SNACK_TYPE_MASK]",
            "conn->sess->sess_ops->ErrorRecoveryLevel": "in [0, 1]"
        },
    }
},
{
    "kretprobe:iscsit_build_logout_rsp": {
        "description": "The actual shutting down of Sessions and/or Connections for CLOSESESSION and CLOSECONNECTION Logout Requests is done in scsi_logout_post_handler().",
        "proto" :"static long (*iscsit_build_logout_rsp)(struct iscsit_cmd *cmd, struct iscsit_conn *conn, struct iscsi_logout_rsp *hdr)",
        "pre": {
            "cmd": "!=null",
            "conn": "!=null",
            "hdr": "!=null",
            "cmd->logout_reason": "in [LOGOUT_REASON_CLOSE_SESSION, LOGOUT_REASON_CLOSE_CONNECTION]",
        },
    }
},
{
    "kprobe:iscsit_build_logout_rsp": {
        "description": "The actual shutting down of Sessions and/or Connections for CLOSESESSION and CLOSECONNECTION Logout Requests is done in scsi_logout_post_handler().",
        "proto" :"iscsit_build_logout_rsp(struct iscsit_cmd  cmd, struct iscsit_conn  conn,struct iscsi_logout_rsp  hdr)",
        "pre": {
            "cmd->logout_reason": "in [REASON1, REASON2, REASON3]",
        },
    }
},


{
    "kretprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for the iSCSI target. The function returns the length of the text response plus padding.",
        "proto": "int iscsit_build_text_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn, struct iscsi_text_rsp *hdr, enum iscsit_transport_type network_transport)",
        "pre": {
            "cmd": "!=null",
            "conn": "!=null",
            "hdr": "!=null",
            "network_transport": "in [ISCSIT_TCP, ISCSIT_IPOIB]"
        }
    }
},
{
    "kprobe:iscsit_build_text_rsp": {
        "description": "Builds a text response for the iSCSI protocol. It handles the text response's flags, opcode, data length, initiator task tag, target transfer tag, and status sequence number. It also increments the maximum command sequence number and resets it in multi-part text payload exchanges.",
        "proto": "int (*iscsit_build_text_rsp)(struct iscsit_cmd *cmd, struct iscsit_conn *conn, struct iscsi_text_rsp *hdr, enum iscsit_transport_type network_transport)",
        "pre": {
            "cmd": "!=null",
            "conn": "!=null",
            "hdr": "!=null",
            "network_transport": "in [ISCSIT_TCP, ISCSIT_IPOIB]"
        },
        "post": {
            "hdr->flags": "in [ISCSI_FLAG_CMD_FINAL, ISCSI_FLAG_TEXT_CONTINUE]",
            "hdr->opcode": "==ISCSI_OP_TEXT_RSP",
            "hdr->dlength": ">=0",
            "hdr->itt": "==cmd->init_task_tag",
            "hdr->ttt": "==cpu_to_be32(cmd->targ_xfer_tag)",
            "hdr->statsn": "==cpu_to_be32(cmd->stat_sn)",
            "cmd->stat_sn": "==conn->stat_sn++",
            "cmd->maxcmdsn_inc": "==0"
        }
    }
},
{
    "kretprobe:iscsit_thread_reschedule": {
        "description": "The TX and RX threads may call iscsit_thread_check_cpumask() at the same time. The RX thread might be faster and return from iscsit_thread_reschedule() with conn_rx_reset_cpumask set to 0. Then the TX thread sets it back to 1. The next time the RX thread loops, it sees conn_rx_reset_cpumask set to 1 and calls set_cpus_allowed_ptr() again and set it to 0.",
        "proto" :"void iscsit_thread_reschedule(struct iscsit_conn *conn, int mode)",
        "pre": {
            "conn": "!=null",
            "mode": "in [0, 1]"
        }
    }
},
{
    "kprobe:iscsit_thread_reschedule": {
        "description": "The TX and RX threads maybe call iscsit_thread_check_cpumask() at the same time. The RX thread might be faster and return from iscsit_thread_reschedule() with conn_rx_reset_cpumask set to 0. Then the TX thread sets it back to 1. The next time the RX thread loops, it sees conn_rx_reset_cpumask set to 1 and calls set_cpus_allowed_ptr() again and set it to 0.",
        "proto" :"void iscsit_thread_reschedule(struct iscsit_conn *conn)",
        "pre": {
            "conn": "!=null",
        },
    }
},
{
    "kretprobe:iscsit_get_conn_from_cid": {
        "description": "Here we simply make sure the CID is still around.",
        "proto" :"static long (*iscsit_get_conn_from_cid)(void *sess, __u64 logout_cid)",
        "pre": {
            "sess": "!=null",
            "logout_cid": "!=null",
        },
    }
},
{
    "kprobe:iscsit_get_conn_from_cid": {
        "description": "Here we simply make sure the CID is still around.",
        "proto" :"static struct iscsi_conn *(*iscsit_get_conn_from_cid)(struct iscsi_session *sess, uint32_t logout_cid)",
        "pre": {
            "sess": "!=null",
            "logout_cid": "!=null",
        },
    }
},
{
    "kretprobe:pmu_request": {
        "description": "Ack all pending interrupts",
        "proto": "static long (*pmu_request)(void *req, void *null, int num, int PMU_SET_INTR_MASK, int pmu_intr_mask)",
        "pre": {
            "req": "!=null",
            "null": "==null",
            "num": "==2",
            "PMU_SET_INTR_MASK": "is a valid PMU_SET_INTR_MASK value",
            "pmu_intr_mask": "is a valid pmu_intr_mask value"
        }
    }
},

{
    "kretprobe:pmu_queue_request": {
        "description": "Queue a request to the PMU (Power Management Unit).",
        "proto" :"int (*pmu_queue_request)(struct pmu_request *req)",
        "pre": {
            "req": "!=null",
            "req->data": "!=null",
            "req->nbytes": ">=0",
            "req->reply_expected": "in [0, 1]",
            "req->reply_len": ">=0"
        },
        "post": {
            "ret": ">=0"
        }
    }
},
{
    "kprobe:pmu_queue_request": {
        "description": "Queue a request to the PMU (Power Management Unit).",
        "proto" :"static int (*pmu_queue_request)(struct pmu_request *req)",
        "pre": {
            "req": "!=null",
            "req->data[0]": "in [PMU_ADB_CMD, PMU_READ_RTC, PMU_SET_RTC]",
            "req->nbytes": ">=1",
            "req->reply_expected": "in [0, 1]",
            "req->reply_len": ">=0",
        },
    }
},





{
    "kprobe:pmu_send_request": {
        "description": "Send a request to the PMU.",
        "proto": "static int (*pmu_send_request)(struct adb_request *req, int sync)",
        "pre": {
            "req": "!=null",
            "sync": "in [0, 1]"
        }
    }
},
{
    "kretprobe:pmu_handle_data": {
        "description": "Handle the data received from an interrupt.",
        "proto" :"static void (*pmu_handle_data)(unsigned char *data, int len)",
        "pre": {
            "data": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:pmu_handle_data": {
        "description": "Handle data from the Performance Monitoring Unit (PMU).",
        "proto" :"static void (*pmu_handle_data)(unsigned char *data, int len)",
        "pre": {
            "data": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:pmu_get_time": {
        "description": "Returns the current Unix time with an offset between Unix time (1970-based) and Mac time (1904-based).",
        "proto" :"#define RTC_OFFSET2082844800time64_t pmu_get_time(void)",
        "post": {
            "return": ">= RTC_OFFSET2082844800"
        }
    }
},
{
    "kprobe:pmu_get_time": {
        "description": "This function needs a proper description here.",
        "proto" :"time64_t (*pmu_get_time)(void)",
        "pre": {
        },
    }
},
{
    "kretprobe:init_pmu": {
        "description": "Your description here",
        "proto" :"static int (*init_pmu)(void)",
        "pre": {
            // Add your conditions here
        }
    },
    "kretprobe:pmu_start": {
        "description": "Your description here",
        "proto" :"static void (*pmu_start)(void)",
        "pre": {
            // Add your conditions here
        }
    },
    "kretprobe:via_pmu_interrupt": {
        "description": "Your description here",
        "proto" :"static irqreturn_t (*via_pmu_interrupt)(int irq, void *arg)",
        "pre": {
            "irq": "Your condition here",
            "arg": "Your condition here"
        }
    },
    "kretprobe:gpio1_interrupt": {
        "description": "Your description here",
        "proto" :"static irqreturn_t (*gpio1_interrupt)(int irq, void *arg)",
        "pre": {
            "irq": "Your condition here",
            "arg": "Your condition here"
        }
    },
    // Continue with the rest of your functions
},
{
    "kprobe:init_pmu": {
        "description": "Description of the function",
        "proto" :"static int (*init_pmu)(void)",
        "pre": {
            "void": "Your constraints here"
        }
    },
    "kprobe:pmu_start": {
        "description": "Description of the function",
        "proto" :"static void (*pmu_start)(void)",
        "pre": {
            "void": "Your constraints here"
        }
    },
    "kprobe:via_pmu_interrupt": {
        "description": "Description of the function",
        "proto" :"static irqreturn_t (*via_pmu_interrupt)(int irq, void *arg)",
        "pre": {
            "irq": "Your constraints here",
            "arg": "Your constraints here"
        }
    },
    "kprobe:gpio1_interrupt": {
        "description": "Description of the function",
        "proto" :"static irqreturn_t (*gpio1_interrupt)(int irq, void *arg)",
        "pre": {
            "irq": "Your constraints here",
            "arg": "Your constraints here"
        }
    },
    "kprobe:pmu_info_proc_show": {
        "description": "Description of the function",
        "proto" :"static int (*pmu_info_proc_show)(struct seq_file *m, void *v)",
        "pre": {
            "m": "Your constraints here",
            "v": "Your constraints here"
        }
    },
    "kprobe:pmu_irqstats_proc_show": {
        "description": "Description of the function",
        "proto" :"static int (*pmu_irqstats_proc_show)(struct seq_file *m, void *v)",
        "pre": {
            "m": "Your constraints here",
            "v": "Your constraints here"
        }
    },
    "kprobe:pmu_battery_proc_show": {
        "description": "Description of the function",
        "proto" :"static int (*pmu_battery_proc_show)(struct seq_file *m, void *v)",
        "pre": {
            "m": "Your constraints here",
            "v": "Your constraints here"
        }
    },
    "kprobe:pmu_pass_intr": {
        "description": "Description of the function",
        "proto" :"static void (*pmu_pass_intr)(unsigned char *data, int len)",
        "pre": {
            "data": "Your constraints here",
            "len": "Your constraints here"
        }
    }
},
{
    "kretprobe:smu_queue_cmd": {
        "description": "This function queues a command to the SMU (System Management Unit). It checks if the SMU is initialized, if the data length and reply length of the command are within the SMU_MAX_DATA limit, and then adds the command to the SMU's command list. If there is no current command, it starts the command. It also includes a workaround for early calls when irq isn't available.",
        "proto" :"int smu_queue_cmd(struct smu_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->data_len": "<=SMU_MAX_DATA",
            "cmd->reply_len": "<=SMU_MAX_DATA",
            "smu": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, -EINVAL, 0]"
        }
    }
},
{
    "kprobe:smu_queue_cmd": {
        "description": "This function queues a command to the SMU. It returns -ENODEV if smu is NULL, or -EINVAL if the data_len or reply_len of the command is greater than SMU_MAX_DATA. It adds the command to the cmd_list of smu and starts the command if there is no current command. It also saves and restores the irq flags.",
        "proto" :"int smu_queue_cmd(struct smu_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->data_len": "<=SMU_MAX_DATA",
            "cmd->reply_len": "<=SMU_MAX_DATA",
            "smu": "!=null"
        },
    }
},


{
    "kretprobe:macio_register_driver": {
        "description": "Registers a new MacIO device driver",
        "proto" :"int macio_register_driver(struct macio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:macio_register_driver": {
        "description": "Registers a new MacIO device driver",
        "proto" :"int (*macio_register_driver)(struct macio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:macio_unregister_driver": {
        "description": "Unregisters a new MacIO device driver",
        "proto": "void macio_unregister_driver(struct macio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:macio_unregister_driver": {
        "description": "Unregisters a new MacIO device driver",
        "proto" :"void (*macio_unregister_driver)(struct macio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished. This function is called only by the device core when all users of this macio device are done. This currently means never as we don't hot remove any macio device yet, though that will happen with mediabay based devices in a later implementation.",
        "proto": "static void macio_release_dev(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_dev": {
        "description": "Free a macio device structure when all users of it are finished.",
        "proto": "static void macio_release_dev(struct device *dev)",
        "pre": {
            "dev": "!=null && !in_use"
        }
    }
},
{
    "kretprobe:macio_request_resource": {
        "description": "Mark memory region number @resource_no associated with MacIO device @dev as being reserved by owner @name. Do not access any address inside the memory regions unless this call returns successfully. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name)",
        "pre": {
            "dev": "!=null",
            "resource_no": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kprobe:macio_request_resource": {
        "description": "Mark memory region number @resource_no associated with MacIO device @dev as being reserved by owner @name. Do not access any address inside the memory regions unless this call returns successfully. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int macio_request_resource(struct macio_dev *dev, int resource_no, const char *name)",
        "pre": {
            "dev": "!=null",
            "resource_no": ">=0",
            "name": "!=null"
        }
    }
},
{
    "kretprobe:macio_request_resources": {
        "description": "Reserve all memory resources. Mark all memory regions associated with MacIO device @dev as being reserved by owner @name. Do not access any address inside the memory regions unless this call returns successfully. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int (*macio_request_resources)(struct macio_dev *dev, const char *name)",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, EBUSY]"
        }
    }
},
{
    "kprobe:macio_request_resources": {
        "description": "Reserve all memory resources. Mark all memory regions associated with MacIO device @dev as being reserved by owner @name. Do not access any address inside the memory regions unless this call returns successfully. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int (*macio_request_resources)(struct macio_dev *dev, const char *name)",
        "pre": {
            "dev": "!=null",
            "name": "!=null"
        },
    }
},
{
    "kretprobe:macio_release_resources": {
        "description": "Release reserved memory resources for a MacIO device whose resources were previously reserved.",
        "proto" :"void (*macio_release_resources)(struct macio_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:macio_release_resources": {
        "description": "Release reserved memory resources for a MacIO device whose resources were previously reserved.",
        "proto" :"void (*macio_release_resources)(struct macio_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:printADBreply": {
        "description": "adb_unregister returns, we know that the old handler isn't being called.",
        "proto" :"static void printADBreply(struct adb_request *req)",
        "pre": {
            "req": "!=null",
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here.",
        "pre": {
            "param1": "Your condition for param1",
            "param2": "Your condition for param2",
            "param3": "Your condition for param3",
            "param4": "Your condition for param4",
        },
    }
},
{
    "kretprobe:rproc_va_to_pa": {
        "description": "Return physical address according to virtual address location - in vmalloc: if region ioremapped or defined as dma_alloc_coherent - in kernel: if region allocated in generic dma memory pool",
        "proto" :"static long (*rproc_va_to_pa)(void *cpu_addr)",
        "pre": {
            "cpu_addr": "!=null && is_vmalloc_addr(cpu_addr)"
        }
    }
},
{
    "kprobe:rproc_va_to_pa": {
        "description": "Return physical address according to virtual address location - in vmalloc: if region ioremapped or defined as dma_alloc_coherent - in kernel: if region allocated in generic dma memory pool",
        "proto" :"static long (*rproc_va_to_pa)(void *cpu_addr)",
        "pre": {
            "cpu_addr": "!=null && is_vmalloc_addr(cpu_addr)"
        },
    }
},
{
    "kretprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address. This function is a helper function with which we can go over the allocated carveouts and translate specific device addresses to kernel virtual addresses so we can access the referenced memory. This function also allows to perform translations on the internal remoteproc memory regions through a platform implementation specific da_to_va ops, if present.",
        "proto" :"void *(*rproc_da_to_va)(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "len": ">=0",
            "is_iomem": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:rproc_da_to_va": {
        "description": "Lookup the kernel virtual address for a remoteproc address. This function is a helper function with which we can go over the allocated carveouts and translate specific device addresses to kernel virtual addresses so we can access the referenced memory. This function also allows to perform translations on the internal remoteproc memory regions through a platform implementation specific da_to_va ops, if present.",
        "proto" :"void *(*rproc_da_to_va)(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "len": ">=0",
            "is_iomem": "!=null || ==null"
        },
    }
},
{
    "kretprobe:idr_alloc": {
        "description": "Assign an rproc-wide unique index for this vring",
        "proto" :"int idr_alloc(struct idr *idr, void *ptr, int start, int end, gfp_t gfp_mask)",
        "pre": {
            "&rproc->notifyids": "!=null",
            "rvring": "!=null",
            "0": "is valid integer",
            "0": "is valid integer",
            "GFP_KERNEL": "is valid flag",
        },
    }
},

{
    "kretprobe:rproc_of_resm_mem_entry_init": {
        "description": "This function allocates a rproc_mem_entry struct and fill it with parameters provided by client.",
        "proto" :"__printf(5, 6)struct rproc_mem_entry *rproc_of_resm_mem_entry_init(struct device *dev, u32 of_resm_idx, size_t len, u32 da, const char *name, ...)",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": ">=0",
            "len": ">0",
            "da": ">=0",
            "name": "!=null"
        },
    }
},
{
    "kprobe:rproc_of_resm_mem_entry_init": {
        "description": "This function allocates a rproc_mem_entry struct and fill it with parameters provided by client.",
        "proto" :"__printf(5, 6)struct rproc_mem_entry *rproc_of_resm_mem_entry_init(struct device *dev, u32 of_resm_idx, size_t len, u32 da, const char *name, ...)",
        "pre": {
            "dev": "!=null",
            "of_resm_idx": ">=0",
            "len": ">0",
            "da": ">=0",
            "name": "!=null"
        },
    }
},
{
    "kretprobe:rproc_of_parse_firmware": {
        "description": "This is an OF helper function that parses a device's DT node for the 'firmware-name' property and returns the firmware name pointer in @fw_name on success.",
        "proto" :"int (*rproc_of_parse_firmware)(struct device *dev, int index, const char **fw_name)",
        "pre": {
            "dev": "!=null",
            "index": ">=0",
            "fw_name": "!=null"
        },
        "post": {
            "return": "in [0, appropriate failure code]"
        }
    }
},
{
    "kprobe:rproc_of_parse_firmware": {
        "description": "This is an OF helper function that parses a device's DT node for the 'firmware-name' property and returns the firmware name pointer in @fw_name on success.",
        "proto" :"int rproc_of_parse_firmware(struct device *dev, int index, const char **fw_name)",
        "pre": {
            "dev": "!=null",
            "index": ">=0",
            "fw_name": "!=null"
        },
        "post": {
            "return": "in [0, appropriate failure code]"
        }
    }
},
{
    "kretprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources. This function will free all resources acquired for @rproc, and it is called whenever @rproc either shuts down or fails to boot.",
        "proto" :"void (*rproc_resource_cleanup)(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_resource_cleanup": {
        "description": "Clean up and free all acquired resources. This function will free all resources acquired for @rproc, and it is called whenever @rproc either shuts down or fails to boot.",
        "proto" :"void (*rproc_resource_cleanup)(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_boot": {
        "description": "Since the remote processor is in a detached state, it has already been booted by another entity. As such there is no point in waiting for a firmware image to be loaded, we can simply initiate the process of attaching to it immediately.",
        "proto" :"static int (*rproc_boot)(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null && rproc->state == RPROC_DETACHED"
        },
    }
},
{
    "kprobe:rproc_boot": {
        "description": "Since the remote processor is in a detached state, it has already been booted by another entity. As such there is no point in waiting for a firmware image to be loaded, we can simply initiate the process of attaching to it immediately.",
        "proto" :"static int (*rproc_boot)(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null && rproc->state == RPROC_DETACHED",
        },
    }
},
{
    "kretprobe:rproc_shutdown": {
        "description": "Shuts down the remote processor and frees the cached table.",
        "proto" :"void rproc_shutdown(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": ">0",
            "GFP_KERNEL": "is defined"
        },
        "post": {
            "rproc->cached_table": "!=null || return value == -ENOMEM"
        }
    }
},
{
    "rproc_shutdown": {
        "description": "Shuts down the remote processor and frees the cached resource table.",
        "proto" :"void rproc_shutdown(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null",
            "rproc->table_ptr": "!=null",
            "rproc->table_sz": ">0",
            "GFP_KERNEL": "is defined"
        },
        "post": {
            "rproc->cached_table": "!=null || return value == -ENOMEM"
        }
    }
},
{
    "kretprobe:kmemdup": {
        "description": "Duplicates the memory block of a given size and returns a pointer to the duplicate.",
        "proto" :"void *kmemdup(const void *src, size_t len, gfp_t gfp)",
        "pre": {
            "src": "!=null",
            "len": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rproc_detach": {
        "description": "Detaches the rproc instance and frees the cached table if it exists.",
        "proto" :"static long (*rproc_detach)(struct rproc *rproc, void *table_ptr, size_t table_sz, gfp_t gfp)",
        "pre": {
            "rproc": "!=null",
            "table_ptr": "!=null",
            "table_sz": ">0",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:rproc_get_by_phandle": {
        "description": "rproc_put() to decrement it back once rproc isn't needed anymore. Return: rproc handle on success, and NULL on failure",
        "proto" :"#ifdef CONFIG_OFstruct rproc *rproc_get_by_phandle(phandle phandle)",
        "pre": {
            "phandle": "your_condition_here"
        }
    }
},
{
    "kprobe:rproc_get_by_phandle": {
        "description": "rproc_put() to decrement it back once rproc isn't needed anymore. Return: rproc handle on success, and NULL on failure",
        "proto" :"#ifdef CONFIG_OFstruct rproc *rproc_get_by_phandle(phandle phandle)",
        "pre": {
            "phandle": "your precondition here",
        },
    }
},
{
    "kretprobe:rproc_set_firmware": {
        "description": "Assign a new firmware name to a remote processor. This function should be called only when the remote processor is offline.",
        "proto" :"int rproc_set_firmware(struct rproc *rproc, const char *fw_name)",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null && !=''"
        },
        "post": {
            "return": "in [0, negative value]"
        }
    }
},
{
    "kprobe:rproc_set_firmware": {
        "description": "Assign a new firmware to a remote processor. This function does not trigger a remote processor boot, only sets the firmware name used for a subsequent boot. This function should also be called only when the remote processor is offline.",
        "proto" :"int rproc_set_firmware(struct rproc *rproc, const char *fw_name)",
        "pre": {
            "rproc": "!=null",
            "fw_name": "!=null && !=''",
            "rproc_state": "==offline"
        },
    }
},
{
    "kretprobe:devm_rproc_add": {
        "description": "This function performs like rproc_add() but the registered rproc device will automatically be removed on driver detach.",
        "proto" :"int devm_rproc_add(struct device *dev, struct rproc *rproc)",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:devm_rproc_add": {
        "description": "This function performs like rproc_add() but the registered rproc device will automatically be removed on driver detach.",
        "proto" :"int devm_rproc_add(struct device *dev, struct rproc *rproc)",
        "pre": {
            "dev": "!=null",
            "rproc": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kretprobe:rproc_alloc_carveout": {
        "description": "Allocates a carveout memory region for the rproc device.",
        "proto" :"static int (*rproc_alloc_carveout)(struct rproc *rproc, struct rproc_mem_entry *mem)",
        "pre": {
            "rproc": "!=null",
            "mem": "!=null"
        }
    }
},
{
    "kprobe:rproc_alloc_carveout": {
        "description": "Allocates a carveout memory region for a remoteproc device.",
        "proto" :"static struct rproc_mem_entry (*rproc_alloc_carveout)(struct rproc *rproc, struct rproc_mem_entry *mem)",
        "pre": {
            "rproc": "!=null",
            "mem": "!=null"
        }
    },
    "kprobe:rproc_release_carveout": {
        "description": "Releases a carveout memory region of a remoteproc device.",
        "proto" :"static int (*rproc_release_carveout)(struct rproc *rproc, struct rproc_mem_entry *mem)",
        "pre": {
            "rproc": "!=null",
            "mem": "!=null"
        }
    }
},
{
    "kretprobe:rproc_free_vring": {
        "description": "Reset the virtio device section in the cached resource table only if there is one to work with. The cached resource table is only available when a remote processor has been booted by the remoteproc core, otherwise it is NULL.",
        "proto" :"void rproc_free_vring(struct rproc_vring *rvring)",
        "pre": {
            "rvring": "!=null",
            "rvring->rvdev": "!=null",
            "rvring->rvdev->rproc": "!=null",
            "rvring->rvdev->rproc->table_ptr": "!=null"
        },
    }
},
{
    "kprobe:rproc_free_vring": {
        "description": "Reset the virtio device section in the cached resource table only if there is one to work with. The cached resource table is only available when a remote processor has been booted by the remoteproc core, otherwise it is NULL.",
        "proto" :"void rproc_free_vring(struct rproc_vring *rvring)",
        "pre": {
            "rvring": "!=null",
            "rvring->rvdev": "!=null",
            "rvring->rvdev->rproc": "!=null",
            "rvring->rvdev->vring": "!=null",
            "rvring->notifyid": ">=0",
            "rproc->table_ptr": "!=null"
        },
    }
},
{
    "kretprobe:devm_rproc_alloc": {
        "description": "This function performs like rproc_alloc() but the acquired rproc device will automatically be released on driver detach.",
        "proto" :"struct rproc *(*devm_rproc_alloc)(struct device *dev, const char *name, const struct rproc_ops *ops, const char *firmware, int len)",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "can be null",
            "len": ">=0"
        },
        "post": {
            "return": "!=null or ==null on failure"
        }
    }
},
{
    "kprobe:devm_rproc_alloc": {
        "description": "This function performs like rproc_alloc() but the acquired rproc device will automatically be released on driver detach.",
        "proto" :"struct rproc *(*devm_rproc_alloc)(struct device *dev, const char *name, const struct rproc_ops *ops, const char *firmware, int len)",
        "pre": {
            "dev": "!=null",
            "name": "!=null",
            "ops": "!=null",
            "firmware": "can be null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc. Caller is responsible for populating optional subdevice function pointers.",
        "proto" :"void (*rproc_add_subdev)(struct rproc *rproc, struct rproc_subdev *subdev)",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_add_subdev": {
        "description": "Add a subdevice to a remoteproc. Caller is responsible for populating optional subdevice function pointers.",
        "proto" :"void rproc_add_subdev(struct rproc *rproc, struct rproc_subdev *subdev)",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc. @rproc: rproc handle to remove the subdevice from. @subdev: subdev handle, previously registered with rproc_add_subdev()",
        "proto" :"void (*rproc_remove_subdev)(struct rproc *rproc, struct rproc_subdev *subdev)",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kprobe:rproc_remove_subdev": {
        "description": "Remove a subdevice from a remoteproc. The rproc handle is used to remove the subdevice from and the subdev handle was previously registered with rproc_add_subdev().",
        "proto" :"void rproc_remove_subdev(struct rproc *rproc, struct rproc_subdev *subdev)",
        "pre": {
            "rproc": "!=null",
            "subdev": "!=null"
        }
    }
},
{
    "kretprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor. @dev: child device to find ancestor of. Return: the ancestor rproc instance, or NULL if not found.",
        "proto": "struct rproc *(*rproc_get_by_child)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:rproc_get_by_child": {
        "description": "Acquire rproc handle of @dev's ancestor. @dev: child device to find ancestor of. Return: the ancestor rproc instance, or NULL if not found.",
        "proto" :"struct rproc *(*rproc_get_by_child)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:rproc_enable_iommu": {
        "description": "Let the iommu core know we're not really handling this fault; we just used it as a recovery trigger.",
        "proto" :"static int rproc_enable_iommu(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null"
        },
    }
},
{
    "kprobe:rproc_enable_iommu": {
        "description": "Let the iommu core know we're not really handling this fault; we just used it as a recovery trigger.",
        "proto" :"static int rproc_enable_iommu(struct rproc *rproc)",
        "pre": {
            "rproc": "your precondition here",
        },
    }
},
{
    "kretprobe:rproc_coredump_add_segment": {
        "description": "Add device memory to the list of segments to be included in a coredump for the remoteproc.",
        "proto" :"int rproc_coredump_add_segment(struct rproc *rproc, dma_addr_t da, size_t size)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "size": ">0"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:rproc_coredump_add_segment": {
        "description": "Add device memory to the list of segments to be included in a coredump for the remoteproc.",
        "proto" :"int rproc_coredump_add_segment(struct rproc *rproc, dma_addr_t da, size_t size)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "size": ">=0"
        },
    }
},
{
    "kretprobe:rproc_coredump_add_custom_segment": {
        "description": "Add device memory to the list of segments to be included in the coredump and associate the segment with the given custom dump function and private data.",
        "proto" :"int rproc_coredump_add_custom_segment(struct rproc *rproc, dma_addr_t da, size_t size, void (*dumpfn)(struct rproc *rproc, struct rproc_dump_segment *segment, void *dest, size_t offset, size_t size), void *priv)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "size": ">=0",
            "dumpfn": "!=null",
            "priv": "can be null or !=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:rproc_coredump_add_custom_segment": {
        "description": "Add device memory to the list of segments to be included in the coredump and associate the segment with the given custom dump function and private data.",
        "proto" :"int rproc_coredump_add_custom_segment(struct rproc *rproc, dma_addr_t da, size_t size, void (*dumpfn)(struct rproc *rproc, struct rproc_dump_segment *segment, void *dest, size_t offset, size_t size), void *priv)",
        "pre": {
            "rproc": "!=null",
            "da": ">=0",
            "size": ">=0",
            "dumpfn": "!=null",
            "priv": "can be null or !=null"
        },
    }
},
{
    "kretprobe:rproc_coredump_set_elf_info": {
        "description": "Set elf information which will be used for coredump elf file.",
        "proto" :"int rproc_coredump_set_elf_info(struct rproc *rproc, u8 class, u16 machine)",
        "pre": {
            "rproc": "!=null",
            "class": "is u8",
            "machine": "is u16"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:rproc_coredump_set_elf_info": {
        "description": "Set elf information which will be used for coredump elf file.",
        "proto" :"int rproc_coredump_set_elf_info(struct rproc *rproc, u8 class, u16 machine)",
        "pre": {
            "rproc": "!=null",
            "class": "is a valid elf class",
            "machine": "is a valid elf machine"
        },
    }
},
{
    "kretprobe:rproc_coredump_using_sections": {
        "description": "This function will generate an ELF header for the registered sections of segments and create a devcoredump device associated with rproc. Based on the coredump configuration this function will directly copy the segments from device memory to userspace or copy segments from device memory to a separate buffer, which can then be read by userspace. The first approach avoids using extra vmalloc memory. But it will stall recovery flow until dump is read by userspace.",
        "proto" :"void rproc_coredump_using_sections(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kprobe:rproc_coredump_using_sections": {
        "description": "This function will generate an ELF header for the registered sections of segments and create a devcoredump device associated with rproc. Based on the coredump configuration this function will directly copy the segments from device memory to userspace or copy segments from device memory to a separate buffer, which can then be read by userspace. The first approach avoids using extra vmalloc memory. But it will stall recovery flow until dump is read by userspace.",
        "proto" :"void (*rproc_coredump_using_sections)(struct rproc *rproc)",
        "pre": {
            "rproc": "!=null"
        }
    }
},
{
    "kretprobe:st_slim_rproc_alloc": {
        "description": "Function for allocating and initialising a slim rproc for use by device drivers whose IP is based around the SLIM core. It obtains and enables any clocks required by the SLIM core and also ioremaps the various IO.",
        "proto" :"struct st_slim_rproc *(*st_slim_rproc_alloc)(struct platform_device *pdev, char *fw_name)",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        },
        "post": {
            "return": "!=null || ==PTR_ERR()"
        }
    }
},
{
    "kprobe:st_slim_rproc_alloc": {
        "description": "Function for allocating and initialising a slim rproc for use by device drivers whose IP is based around the SLIM core. It obtains and enables any clocks required by the SLIM core and also ioremaps the various IO.",
        "proto" :"struct st_slim_rproc *(*st_slim_rproc_alloc)(struct platform_device *pdev, char *fw_name)",
        "pre": {
            "pdev": "!=null",
            "fw_name": "!=null"
        },
        "post": {
            "return": "!=null || ==PTR_ERR()"
        }
    }
},
{
    "kretprobe:st_slim_rproc_put": {
        "description": "Function for calling respective _put() functions on slim_rproc resources.",
        "proto" :"void (*st_slim_rproc_put)(struct st_slim_rproc *slim_rproc)",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kprobe:st_slim_rproc_put": {
        "description": "Function for calling respective _put() functions on slim_rproc resources.",
        "proto" :"void (*st_slim_rproc_put)(struct st_slim_rproc *slim_rproc)",
        "pre": {
            "slim_rproc": "!=null"
        }
    }
},
{
    "kretprobe:rproc_vq_interrupt": {
        "description": "This function should be called by the platform-specific rproc driver, when the remote processor signals that a specific virtqueue has pending messages available. Returns IRQ_NONE if no message was found in the @notifyid virtqueue, and otherwise returns IRQ_HANDLED.",
        "proto" :"irqreturn_t (*rproc_vq_interrupt)(struct rproc *rproc, int notifyid)",
        "pre": {
            "rproc": "!=null",
            "notifyid": ">=0"
        },
        "post": {
            "return": "in [IRQ_NONE, IRQ_HANDLED]"
        }
    }
},
{
    "kprobe:rproc_vq_interrupt": {
        "description": "This function should be called by the platform-specific rproc driver, when the remote processor signals that a specific virtqueue has pending messages available. Returns IRQ_NONE if no message was found in the @notifyid virtqueue, and otherwise returns IRQ_HANDLED.",
        "proto" :"irqreturn_t (*rproc_vq_interrupt)(struct rproc *rproc, int notifyid)",
        "pre": {
            "rproc": "!=null",
            "notifyid": ">=0"
        },
    }
},
{
    "kretprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image. Make sure this fw image is sane (ie a correct ELF32ELF64 file).",
        "proto" :"int rproc_elf_sanity_check(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:rproc_elf_sanity_check": {
        "description": "Sanity Check for ELF32ELF64 firmware image. Make sure this fw image is sane (ie a correct ELF32ELF64 file).",
        "proto" :"int rproc_elf_sanity_check(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address. Note that the boot address is not a configurable property of all remote processors. Some will always boot at a specific hard-coded address.",
        "proto" :"u64 (*rproc_elf_get_boot_addr)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
    }
},
{
    "kprobe:rproc_elf_get_boot_addr": {
        "description": "Get rproc's boot address. Note that the boot address is not a configurable property of all remote processors. Some will always boot at a specific hard-coded address.",
        "proto" :"u64 (*rproc_elf_get_boot_addr)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
    }
},
{
    "kretprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory. The function takes two parameters: rproc and fw. rproc is the remote processor which will be booted using these firmware segments and fw is the ELF firmware image.",
        "proto" :"int (*rproc_elf_load_segments)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, appropriate error code]"
        }
    }
},
{
    "kprobe:rproc_elf_load_segments": {
        "description": "Load firmware segments to memory for a remote processor. The function goes through the physically contiguous 'carveout' memory regions which were allocated (and mapped) earlier on behalf of the remote processor, and 'translates' device address to kernel addresses, so it can copy the segments where they are expected.",
        "proto" :"int rproc_elf_load_segments(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null",
            "rproc->carveout_mem": "!=null && is_mapped",
            "fw->segments": "!=null && is_in_device_address"
        },
    }
},
{
    "kretprobe:rproc_elf_load_rsc_table": {
        "description": "This function finds the resource table inside the remote processor's firmware, load it into the @cached_table and update @table_ptr.",
        "proto" :"int rproc_elf_load_rsc_table(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:rproc_elf_load_rsc_table": {
        "description": "This function finds the resource table inside the remote processor's firmware, load it into the @cached_table and update @table_ptr.",
        "proto" :"int (*rproc_elf_load_rsc_table)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
    }
},
{
    "kretprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "This function finds the location of the loaded resource table. Don't call this function if the table wasn't loaded yet - it's a bug if you do.",
        "proto" :"struct resource_table *(*rproc_elf_find_loaded_rsc_table)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:rproc_elf_find_loaded_rsc_table": {
        "description": "This function finds the location of the loaded resource table. Don't call this function if the table wasn't loaded yet - it's a bug if you do.",
        "proto" :"struct resource_table *(*rproc_elf_find_loaded_rsc_table)(struct rproc *rproc, const struct firmware *fw)",
        "pre": {
            "rproc": "!=null",
            "fw": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov. @iov: an iov passed to vringh_getdesc_() (updated as we consume). @len: the maximum length to advance.",
        "proto": "void (*vringh_kiov_advance)(struct vringh_kiov *iov, size_t len)",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vringh_kiov_advance": {
        "description": "Skip bytes from vring_kiov. @iov: an iov passed to vringh_getdesc_() (updated as we consume). @len: the maximum length to advance.",
        "proto" :"void vringh_kiov_advance(struct vringh_kiov *iov, size_t len)",
        "pre": {
            "iov": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring. Returns an error if num is invalid: you should check pointers yourself!",
        "proto" :"int vringh_init_user(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, vring_desc_t __user *desc, vring_avail_t __user *avail, vring_used_t __user *used)",
        "pre": {
            "vrh": "!=null",
            "features": ">=0",
            "num": ">0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kprobe:vringh_init_user": {
        "description": "Initialize a vringh for a userspace vring. Returns an error if num is invalid: you should check pointers yourself!",
        "proto" :"int vringh_init_user(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, vring_desc_t __user *desc, vring_avail_t __user *avail, vring_used_t __user *used)",
        "pre": {
            "vrh": "!=null",
            "features": ">=0",
            "num": ">0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_user": {
        "description": "Returns 0 if there was no descriptor, 1 if there was, or -errno. Note that on error return, you can tell the difference between an invalid ring and a single invalid descriptor: in the former case, head will be vrh->vring.num. You may be able to ignore an invalid descriptor, but there's not much you can do with an invalid ring. Note that you can reuse riov and wiov with subsequent calls. Content is overwritten and memory reallocated if more space is needed. When you don't have to use riov and wiov anymore, you should clean up them calling vringh_iov_cleanup() to release the memory, even on error!",
        "proto" :"int vringh_getdesc_user(struct vringh *vrh,struct vringh_iov *riov,struct vringh_iov *wiov,bool (*getrange)(struct vringh *vrh, u64 addr, struct vringh_range *r),u16 *head)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "getrange": "!=null",
            "head": "!=null"
        },
    }
},
{
    "kprobe:vringh_getdesc_user": {
        "description": "Description needed",
        "proto" :"int vringh_getdesc_user(struct vringh *vrh,struct vringh_iov *riov,struct vringh_iov *wiov,bool (*getrange)(struct vringh *vrh, u64 addr, struct vringh_range *r),u16 *head)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "getrange": "!=null",
            "head": "!=null",
        },
    }
},
{
    "kretprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov. @riov: the riov as passed to vringh_getdesc_user() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_user)(struct vringh_iov *riov, void *dst, size_t len)",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len, >=-errno_max"
        }
    }
},
{
    "kprobe:vringh_iov_pull_user": {
        "description": "Copy bytes from vring_iov. @riov: the riov as passed to vringh_getdesc_user() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_user)(struct vringh_iov *riov, void *dst, size_t len)",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov. @wiov: the wiov as passed to vringh_getdesc_user() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_user)(struct vringh_iov *wiov, const void *src, size_t len)",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len && >=-errno"
        }
    }
},
{
    "kprobe:vringh_iov_push_user": {
        "description": "Copy bytes into vring_iov. @wiov: the wiov as passed to vringh_getdesc_user() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_user)(struct vringh_iov *wiov, const void *src, size_t len)",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_user() will return the old descriptor(s) again.",
        "proto" :"void (*vringh_abandon_user)(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_user": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_user() will return the old descriptor(s) again.",
        "proto" :"void vringh_abandon_user(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors. You should check vringh_need_notify_user() after one or more calls to this function.",
        "proto" :"int vringh_complete_multi_user(struct vringh *vrh, const struct vring_used_elem used[], unsigned num_used)",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0"
        }
    }
},
{
    "kprobe:vringh_complete_multi_user": {
        "description": "We've finished with many descriptors. You should check vringh_need_notify_user() after one or more calls to this function.",
        "proto" :"int vringh_complete_multi_user(struct vringh *vrh, const struct vring_used_elem used[], unsigned num_used)",
        "pre": {
            "vrh": "!=null",
            "used": "!=null",
            "num_used": ">=0",
        },
    }
},
{
    "kretprobe:vringh_notify_enable_user": {
        "description": "This always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool vringh_notify_enable_user(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        },
    }
},
{
    "kprobe:vringh_notify_enable_user": {
        "description": "This function always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool vringh_notify_enable_user(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void (*vringh_notify_disable_user)(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_user": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void (*vringh_notify_disable_user)(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_user": {
        "description": "vringh_need_notify_user() after one or more calls to this function.",
        "proto" :"int vringh_complete_user(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0",
        },
    }
},
{
    "kprobe:vringh_complete_user": {
        "description": "vringh_need_notify_user() after one or more calls to this function.",
        "proto" :"int vringh_complete_user(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": "is u16",
            "len": "is u32",
        },
    }
},
{
    "kretprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring. Returns an error if num is invalid.",
        "proto" :"int vringh_init_kern(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_desc *desc, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": ">=0",
            "num": ">0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
    }
},
{
    "kprobe:vringh_init_kern": {
        "description": "Initialize a vringh for a kernelspace vring.",
        "proto": "int (*vringh_init_kern)(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_desc *desc, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": "is u64",
            "num": "is unsigned int",
            "weak_barriers": "is bool",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "is int, error if num is invalid"
        }
    }
},
{
    "kretprobe:vringh_getdesc_kern": {
        "description": "Returns 0 if there was no descriptor, 1 if there was, or -errno. Note that on error return, you can tell the difference between an invalid ring and a single invalid descriptor: in the former case, head will be vrh->vring.num. You may be able to ignore an invalid descriptor, but there's not much you can do with an invalid ring. Note that you can reuse riov and wiov with subsequent calls. Content is overwritten and memory reallocated if more space is needed. When you don't have to use riov and wiov anymore, you should clean up them calling vringh_kiov_cleanup() to release the memory, even on error!",
        "proto" :"int vringh_getdesc_kern(struct vringh *vrh,struct vringh_kiov *riov,struct vringh_kiov *wiov,u16 *head,gfp_t gfp)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "is valid gfp_t flag"
        },
    }
},
{
    "kprobe:vringh_getdesc_kern": {
        "description": "Returns 0 if there was no descriptor, 1 if there was, or -errno. Note that on error return, you can tell the difference between an invalid ring and a single invalid descriptor: in the former case, head will be vrh->vring.num. You may be able to ignore an invalid descriptor, but there's not much you can do with an invalid ring. Note that you can reuse riov and wiov with subsequent calls. Content is overwritten and memory reallocated if more space is needed. When you don't have to use riov and wiov anymore, you should clean up them calling vringh_kiov_cleanup() to release the memory, even on error!",
        "proto" :"int vringh_getdesc_kern(struct vringh *vrh,struct vringh_kiov *riov,struct vringh_kiov *wiov,u16 *head,gfp_t gfp)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "in [GFP_KERNEL, GFP_ATOMIC, GFP_DMA, GFP_DMA32, GFP_HIGHUSER, GFP_HIGHUSER_MOVABLE, GFP_USER, GFP_HIGHMEM, GFP_NOIO, GFP_NOFS, GFP_NOWAIT, GFP_THISNODE, GFP_RECLAIMABLE, GFP_MOVABLE_MASK, GFP_TRANSHUGE, GFP_TRANSHUGE_LIGHT, GFP_ACCOUNT, GFP_NOACCOUNT, GFP_NOTRACK, GFP_DIRECT_RECLAIM, GFP_WRITE, GFP_HARDWALL, GFP_MEMALLOC, GFP_NORETRY, GFP_NO_GFP_WAIT, GFP_NOFAIL, GFP_ATOMIC_LOW]",
        },
    }
},
{
    "kretprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov. @riov: the riov as passed to vringh_getdesc_kern() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_kern)(struct vringh_kiov *riov, void *dst, size_t len)",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "<=len && >=-errno"
        }
    }
},
{
    "kprobe:vringh_iov_pull_kern": {
        "description": "Copy bytes from vring_iov. @riov: the riov as passed to vringh_getdesc_kern() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_kern)(struct vringh_kiov *riov, void *dst, size_t len)",
        "pre": {
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov. @wiov: the wiov as passed to vringh_getdesc_kern() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_kern)(struct vringh_kiov *wiov, const void *src, size_t len)",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kprobe:vringh_iov_push_kern": {
        "description": "Copy bytes into vring_iov. @wiov: the wiov as passed to vringh_getdesc_kern() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_kern)(struct vringh_kiov *wiov, const void *src, size_t len)",
        "pre": {
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_kern() will return the old descriptor(s) again.",
        "proto" :"void vringh_abandon_kern(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_kern": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_kern() will return the old descriptor(s) again.",
        "proto" :"void vringh_abandon_kern(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_kern": {
        "description": "This always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool vringh_notify_enable_kern(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_enable_kern": {
        "description": "This always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool (*vringh_notify_enable_kern)(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void vringh_notify_disable_kern(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_kern": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void (*vringh_notify_disable_kern)(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_kern": {
        "description": "vringh_need_notify_kern() after one or more calls to this function.",
        "proto" :"int vringh_complete_kern(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vringh_complete_kern": {
        "description": "vringh_need_notify_kern() after one or more calls to this function.",
        "proto" :"int vringh_complete_kern(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": "is u16",
            "len": "is u32",
        },
    }
},
{
    "kretprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB. Returns an error if num is invalid.",
        "proto" :"int vringh_init_iotlb(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_desc *desc, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": ">=0",
            "num": ">0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
    }
},
{
    "kprobe:vringh_init_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "proto" :"int (*vringh_init_iotlb)(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": "is u64",
            "num": "is unsigned int",
            "weak_barriers": "is bool",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "is int, error if num is invalid"
        }
    }
},
{
    "kretprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "proto" :"int vringh_init_iotlb_va(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_desc *desc, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": ">=0",
            "num": ">=0",
            "weak_barriers": "in [true, false]",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vringh_init_iotlb_va": {
        "description": "Initialize a vringh for a ring with IOTLB containing user VA.",
        "proto" :"int (*vringh_init_iotlb_va)(struct vringh *vrh, u64 features, unsigned int num, bool weak_barriers, struct vring_desc *desc, struct vring_avail *avail, struct vring_used *used)",
        "pre": {
            "vrh": "!=null",
            "features": "is u64",
            "num": "is unsigned int",
            "weak_barriers": "is bool",
            "desc": "!=null",
            "avail": "!=null",
            "used": "!=null"
        },
        "post": {
            "return": "is int"
        }
    }
},
{
    "kretprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB. @vrh: the vring @iotlb: iotlb associated with this vring @iotlb_lock: spinlock to synchronize the iotlb accesses",
        "proto" :"void (*vringh_set_iotlb)(struct vringh *vrh, struct vhost_iotlb *iotlb, spinlock_t *iotlb_lock)",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kprobe:vringh_set_iotlb": {
        "description": "Initialize a vringh for a ring with IOTLB.",
        "proto" :"void vringh_set_iotlb(struct vringh *vrh, struct vhost_iotlb *iotlb, spinlock_t *iotlb_lock)",
        "pre": {
            "vrh": "!=null",
            "iotlb": "!=null",
            "iotlb_lock": "!=null"
        }
    }
},
{
    "kretprobe:vringh_getdesc_iotlb": {
        "description": "Returns 0 if there was no descriptor, 1 if there was, or -errno. Note that on error return, you can tell the difference between an invalid ring and a single invalid descriptor: in the former case, head will be vrh->vring.num. You may be able to ignore an invalid descriptor, but there's not much you can do with an invalid ring. Note that you can reuse riov and wiov with subsequent calls. Content is overwritten and memory reallocated if more space is needed. When you don't have to use riov and wiov anymore, you should clean up them calling vringh_kiov_cleanup() to release the memory, even on error!",
        "proto" :"int vringh_getdesc_iotlb(struct vringh *vrh, struct vringh_kiov *riov, struct vringh_kiov *wiov, u16 *head, gfp_t gfp)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "is a valid gfp_t flag"
        },
        "post": {
            "return": "in [-errno, 0, 1]",
            "head": "if return == -errno, head == vrh->vring.num"
        }
    }
},
{
    "kprobe:vringh_getdesc_iotlb": {
        "description": "Returns 0 if there was no descriptor, 1 if there was, or -errno. Note that on error return, you can tell the difference between an invalid ring and a single invalid descriptor: in the former case, head will be vrh->vring.num. You may be able to ignore an invalid descriptor, but there's not much you can do with an invalid ring. Note that you can reuse riov and wiov with subsequent calls. Content is overwritten and memory reallocated if more space is needed. When you don't have to use riov and wiov anymore, you should clean up them calling vringh_kiov_cleanup() to release the memory, even on error!",
        "proto" :"int vringh_getdesc_iotlb(struct vringh *vrh, struct vringh_kiov *riov, struct vringh_kiov *wiov, u16 *head, gfp_t gfp)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "wiov": "!=null",
            "head": "!=null",
            "gfp": "is a valid gfp_t flag"
        },
    }
},
{
    "kretprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov. @vrh: the vring. @riov: the riov as passed to vringh_getdesc_iotlb() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_iotlb)(struct vringh *vrh, struct vringh_kiov *riov, void *dst, size_t len)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kprobe:vringh_iov_pull_iotlb": {
        "description": "Copy bytes from vring_iov. @vrh: the vring. @riov: the riov as passed to vringh_getdesc_iotlb() (updated as we consume) @dst: the place to copy. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_pull_iotlb)(struct vringh *vrh, struct vringh_kiov *riov, void *dst, size_t len)",
        "pre": {
            "vrh": "!=null",
            "riov": "!=null",
            "dst": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov. @vrh: the vring. @wiov: the wiov as passed to vringh_getdesc_iotlb() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_iotlb)(struct vringh *vrh, struct vringh_kiov *wiov, const void *src, size_t len)",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kprobe:vringh_iov_push_iotlb": {
        "description": "Copy bytes into vring_iov. @vrh: the vring. @wiov: the wiov as passed to vringh_getdesc_iotlb() (updated as we consume) @src: the place to copy from. @len: the maximum length to copy. Returns the bytes copied <= len or a negative errno.",
        "proto" :"ssize_t (*vringh_iov_push_iotlb)(struct vringh *vrh, struct vringh_kiov *wiov, const void *src, size_t len)",
        "pre": {
            "vrh": "!=null",
            "wiov": "!=null",
            "src": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_iotlb() will return the old descriptor(s) again.",
        "proto" :"void vringh_abandon_iotlb(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kprobe:vringh_abandon_iotlb": {
        "description": "We've decided not to handle the descriptor(s). The next vringh_get_iotlb() will return the old descriptor(s) again.",
        "proto" :"void vringh_abandon_iotlb(struct vringh *vrh, unsigned int num)",
        "pre": {
            "vrh": "!=null",
            "num": ">=0"
        }
    }
},
{
    "kretprobe:vringh_notify_enable_iotlb": {
        "description": "This function always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool vringh_notify_enable_iotlb(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        },
    }
},
{
    "kprobe:vringh_notify_enable_iotlb": {
        "description": "This always enables notifications, but returns false if there are now more buffers available in the vring.",
        "proto" :"bool vringh_notify_enable_iotlb(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void vringh_notify_disable_iotlb(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kprobe:vringh_notify_disable_iotlb": {
        "description": "Don't tell us if something changes. This is our normal running state: we disable and then only enable when we're going to sleep.",
        "proto" :"void (*vringh_notify_disable_iotlb)(struct vringh *vrh)",
        "pre": {
            "vrh": "!=null"
        }
    }
},
{
    "kretprobe:vringh_complete_iotlb": {
        "description": "vringh_need_notify_iotlb() after one or more calls to this function.",
        "proto" :"int vringh_complete_iotlb(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:vringh_complete_iotlb": {
        "description": "vringh_need_notify_iotlb() after one or more calls to this function.",
        "proto" :"int (*vringh_complete_iotlb)(struct vringh *vrh, u16 head, u32 len)",
        "pre": {
            "vrh": "!=null",
            "head": "your specific constraints here",
            "len": "your specific constraints here"
        },
    }
},
{
    "kretprobe:vhost_chr_write_iter": {
        "description": "Writes to the vhost character device, handling different message types.",
        "proto": "int vhost_chr_write_iter(struct vhost_dev *dev, struct iov_iter *from)",
        "pre": {
            "dev": "!=null",
            "from": "!=null"
        },
        "post": {
            "ret": "in [-EINVAL, sizeof(type)]"
        }
    }
},
{
    "kprobe:vhost_chr_write_iter": {
        "description": "There maybe a hole after type for V1 message type, so skip it here.",
        "proto" :"static long (*vhost_chr_write_iter)(struct vhost_dev *dev, struct iov_iter *from)",
        "pre": {
            "dev": "!=null",
            "from": "!=null"
        },
    }
},
{
    "kretprobe:atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "proto" :"static long (*atmel_i2c_init_read_cmd)(struct atmel_i2c_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->word_addr": "CONDITION",
            "cmd->opcode": "CONDITION",
            "cmd->param1": "CONDITION",
            "cmd->param2": "CONDITION",
            "cmd->count": "CONDITION",
            "cmd->msecs": "CONDITION",
            "cmd->rxsize": "CONDITION"
        }
    }
},
{
    "kprobe:atmel_i2c_init_read_cmd": {
        "description": "Read the word from Configuration zone that contains the lock bytes (UserExtra, Selector, LockValue, LockConfig).",
        "proto" :"static void (*atmel_i2c_init_read_cmd)(struct atmel_i2c_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->word_addr": "==COMMAND",
            "cmd->opcode": "==OPCODE_READ",
            "cmd->param1": "==CONFIGURATION_ZONE",
            "cmd->param2": "==cpu_to_le16(DEVICE_LOCK_ADDR)",
            "cmd->count": "==READ_COUNT",
            "cmd->msecs": "==MAX_EXEC_TIME_READ",
            "cmd->rxsize": "==READ_RSP_SIZE"
        },
    }
},
{
    "kretprobe:atmel_i2c_init_genkey_cmd": {
        "description": "A random private key will be generated and stored in slot keyID.",
        "proto" :"static void (*atmel_i2c_init_genkey_cmd)(struct atmel_i2c_cmd *cmd, u16 keyid)",
        "pre": {
            "cmd": "!=null",
            "keyid": "is a valid key identifier"
        },
        "post": {
            "cmd->word_addr": "==COMMAND",
            "cmd->count": "==GENKEY_COUNT",
            "cmd->opcode": "==OPCODE_GENKEY",
            "cmd->param1": "==GENKEY_MODE_PRIVATE",
            "cmd->param2": "==cpu_to_le16(keyid)",
            "cmd->msecs": "==MAX_EXEC_TIME_GENKEY",
            "cmd->rxsize": "==GENKEY_RSP_SIZE"
        }
    }
},
{
    "kprobe:atmel_i2c_init_genkey_cmd": {
        "description": "A random private key will be generated and stored in slot keyID.",
        "proto" :"atmel_i2c_init_genkey_cmd(struct atmel_i2c_cmd  cmd, u16 keyid)",
        "pre": {
            "cmd": "!=null",
            "keyid": "is u16"
        },
    }
},
{
    "kretprobe:atmel_i2c_init_ecdh_cmd": {
        "description": "Initializes an ECDH command for the Atmel I2C device. The command sets the word address to COMMAND, the count to ECDH_COUNT, the opcode to OPCODE_ECDH, and the param1 to ECDH_PREFIX_MODE. The public key is provided through the pubkey parameter.",
        "proto" :"static void (*atmel_i2c_init_ecdh_cmd)(struct atmel_i2c_cmd *cmd, struct scatterlist *pubkey)",
        "pre": {
            "cmd": "!=null",
            "pubkey": "!=null"
        }
    }
},
{
    "kprobe:atmel_i2c_init_ecdh_cmd": {
        "description": "Initializes the ECDH command for the Atmel I2C device.",
        "proto" :"static void (*atmel_i2c_init_ecdh_cmd)(struct atmel_i2c_cmd *cmd, struct scatterlist *pubkey)",
        "pre": {
            "cmd": "!=null",
            "pubkey": "!=null"
        },
    }
},
{
    "kretprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response. After the device receives a Wake token, a watchdog counter starts within the device. After the watchdog timer expires, the device enters sleep mode regardless of whether some IO transmission or command execution is in progress. If a command is attempted when insufficient time remains prior to watchdog timer execution, the device will return the watchdog timeout error code without attempting to execute the command. There is no way to reset the counter other than to put the device into sleep or idle mode and then wake it up again.",
        "proto" :"int (*atmel_i2c_send_receive)(struct i2c_client *client, struct atmel_i2c_cmd *cmd)",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:atmel_i2c_send_receive": {
        "description": "Send a command to the device and receive its response. After the device receives a Wake token, a watchdog counter starts within the device. After the watchdog timer expires, the device enters sleep mode regardless of whether some IO transmission or command execution is in progress. If a command is attempted when insufficient time remains prior to watchdog timer execution, the device will return the watchdog timeout error code without attempting to execute the command. There is no way to reset the counter other than to put the device into sleep or idle mode and then wake it up again.",
        "proto" :"int (*atmel_i2c_send_receive)(struct i2c_client *client, struct atmel_i2c_cmd *cmd)",
        "pre": {
            "client": "!=null",
            "cmd": "!=null"
        },
    }
},
{
    "kretprobe:atmel_i2c_probe": {
        "description": "Description of the function",
        "proto" :"static long (*atmel_i2c_probe)(struct i2c_client *client)",
        "pre": {
            "client": "!=null",
            // Add other parameters and their conditions here
        },
    }
},
{
    "kprobe:atmel_i2c_probe": {
        "description": "This function probes the Atmel I2C client. It checks the I2C functionality, reads the bus clock rate, checks the clock frequency, allocates memory for the client private data, initializes a mutex, and sets the wake token size.",
        "proto": "int atmel_i2c_probe(struct i2c_client *client)",
        "pre": {
            "client": "!=null",
            "client->adapter": "!=null",
            "client->adapter->dev": "!=null",
            "I2C_FUNC_I2C": "is supported",
            "bus_clk_rate": "is read successfully and <= 1000000L",
            "i2c_priv": "is allocated successfully"
        },
        "post": {
            "i2c_priv->client": "=client",
            "i2c_priv->lock": "is initialized",
            "i2c_priv->wake_token_sz": "is set and <= WAKE_TOKEN_MAX_SIZE",
            "i2c_priv->wake_token": "is set to 0",
            "i2c_priv->tfm_count": "is set to 0",
            "client": "has i2c_priv as clientdata",
            "return": "is 0 if successful, or an error code if not"
        }
    }
},
{
    "kretprobe:caam_dump_sg": {
        "description": "Make sure the scatterlist's page has a valid virtual memory mapping",
        "proto" :"void caam_dump_sg(const char prefix_str, int prefix_type, int rowsize, int groupsize, struct scatterlist sg, size_t tlen, bool ascii)",
        "pre": {
            "prefix_str": "!=null",
            "prefix_type": "is int",
            "rowsize": "is int",
            "groupsize": "is int",
            "sg": "!=null",
            "tlen": "is size_t",
            "ascii": "is bool"
        },
        "post": {
            "it_page": "!=null"
        }
    }
},
{
    "kprobe:caam_dump_sg": {
        "description": "Make sure the scatterlist's page has a valid virtual memory mapping.",
        "proto" :"void caam_dump_sg(const char prefix_str, int prefix_type, int rowsize, int groupsize, struct scatterlist sg, size_t tlen, bool ascii)",
        "pre": {
            "prefix_str": "!=null",
            "prefix_type": "is int",
            "rowsize": "is int",
            "groupsize": "is int",
            "sg": "!=null",
            "tlen": "is size_t",
            "ascii": "is bool"
        },
    }
},
{
    "kretprobe:caam_strstatus": {
        "description": "If there is an error handling function, call it to report the error. Otherwise print the error source name.",
        "proto" :"caam_strstatus(struct device  jrdev, u32 status, bool qi_v2)",
        "pre": {
            "jrdev": "!=null",
            "status": "is u32",
            "qi_v2": "is bool"
        },
    }
},
{
    "kprobe:caam_strstatus": {
        "description": "If there is an error handling function, call it to report the error. Otherwise print the error source name.",
        "proto" :"caam_strstatus(struct device  jrdev, u32 status, bool qi_v2)",
        "pre": {
            "jrdev": "!=null",
            "status": "is u32",
            "qi_v2": "is bool",
        },
    }
},
{
    "kretprobe:aead_decrypt": {
        "description": "Allocate extended descriptor and enqueue it. If the operation is not in progress and not busy, unmap the descriptor and free the cache. Return the result of the enqueue operation.",
        "proto" :"static int aead_decrypt(struct aead_request req)",
        "pre": {
            "req": "!=null",
            // Add other preconditions here
        },
        "post": {
            "ret": "in [-EINPROGRESS, -EBUSY, ...]", // Add other possible return values here
            // Add other postconditions here
        }
    }
},
{
    "kprobe:dpaa2_caam_enqueue": {
        "description": "Your description here",
        "proto" :"Your prototype here",
        "pre": {
            "ctx->dev": "Your condition here",
            "caam_req": "Your condition here",
            "ret": "Your condition here",
            "req->base.flags": "Your condition here",
            "edesc": "Your condition here"
        },
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption. @desc: pointer to buffer used for descriptor construction @adata: pointer to authentication transform definitions. A split key is required for SEC Era < 6; the size of the split key is specified in this case. Valid algorithm values - one of OP_ALG_ALGSEL_{MD5, SHA1, SHA224, SHA256, SHA384, SHA512} ANDed with OP_ALG_AAI_HMAC_PRECOMP. @icvsize: integrity check value (ICV) size (truncated or full) @era: SEC Era",
        "proto": "void cnstr_shdsc_aead_null_encap(u32 * const desc, struct alginfo *adata, unsigned int icvsize, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": "in [0, 1, 2, 3, 4, 5, 6]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_null_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with no (null) encryption. @desc: pointer to buffer used for descriptor construction @adata: pointer to authentication transform definitions. A split key is required for SEC Era < 6; the size of the split key is specified in this case. Valid algorithm values - one of OP_ALG_ALGSEL_{MD5, SHA1, SHA224, SHA256, SHA384, SHA512} ANDed with OP_ALG_AAI_HMAC_PRECOMP. @icvsize: integrity check value (ICV) size (truncated or full) @era: SEC Era",
        "proto" :"void cnstr_shdsc_aead_null_encap(u32 * const desc, struct alginfo *adata, unsigned int icvsize, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": "in [0, 1, 2, 3, 4, 5]"
        },
    }
},
{
    "kretprobe:cnstr_shdsc_aead_null_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol) with no (null) decryption. @desc: pointer to buffer used for descriptor construction @adata: pointer to authentication transform definitions. A split key is required for SEC Era < 6; the size of the split key is specified in this case. Valid algorithm values - one of OP_ALG_ALGSEL_{MD5, SHA1, SHA224, SHA256, SHA384, SHA512} ANDed with OP_ALG_AAI_HMAC_PRECOMP. @icvsize: integrity check value (ICV) size (truncated or full) @era: SEC Era",
        "proto" :"void cnstr_shdsc_aead_null_decap(u32 * const desc, struct alginfo *adata, unsigned int icvsize, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": "in [0, 1, 2, 3, 4, 5, 6]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_null_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol) with no (null) decryption.",
        "proto" :"void (*cnstr_shdsc_aead_null_decap)(u32 * const desc, struct alginfo *adata, unsigned int icvsize, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "icvsize": ">=0",
            "era": ">=0",
            "adata->alg": "in [OP_ALG_ALGSEL_MD5, OP_ALG_ALGSEL_SHA1, OP_ALG_ALGSEL_SHA224, OP_ALG_ALGSEL_SHA256, OP_ALG_ALGSEL_SHA384, OP_ALG_ALGSEL_SHA512] AND OP_ALG_AAI_HMAC_PRECOMP",
            "adata->split_key_size": "specified if era < 6"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "proto" :"void cnstr_shdsc_aead_encap(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_encap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol).",
        "proto" :"void cnstr_shdsc_aead_encap(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null when is_rfc3686 is true",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "proto": "void cnstr_shdsc_aead_decap(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool geniv, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "in [true, false]",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_decap": {
        "description": "IPSec ESP decapsulation shared descriptor (non-protocol).",
        "proto": "void cnstr_shdsc_aead_decap(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool geniv, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "geniv": "in [true, false]",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "proto" :"void cnstr_shdsc_aead_givencap(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_aead_givencap": {
        "description": "IPSec ESP encapsulation shared descriptor (non-protocol) with HW-generated initialization vector.",
        "proto" :"void (*cnstr_shdsc_aead_givencap)(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool is_rfc3686, u32 *nonce, const u32 ctx1_iv_off, const bool is_qi, int era)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "adata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "nonce": "!=null",
            "ctx1_iv_off": ">=0",
            "is_qi": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor @desc: pointer to buffer used for descriptor construction @cdata: pointer to block cipher transform definitions Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM. @ivsize: initialization vector size @icvsize: integrity check value (ICV) size (truncated or full) @is_qi: true when called from caamqi",
        "proto" :"void (*cnstr_shdsc_gcm_encap)(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_encap": {
        "description": "gcm encapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM. @ivsize: initialization vector size. @icvsize: integrity check value (ICV) size (truncated or full). @is_qi: true when called from caamqi.",
        "proto" :"void cnstr_shdsc_gcm_encap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM. @ivsize: initialization vector size. @icvsize: integrity check value (ICV) size (truncated or full). @is_qi: true when called from caamqi.",
        "proto" :"void (*cnstr_shdsc_gcm_decap)(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]",
            "ivsize": "is an unsigned int",
            "icvsize": "is an unsigned int",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_gcm_decap": {
        "description": "gcm decapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM. @ivsize: initialization vector size. @icvsize: integrity check value (ICV) size (truncated or full). @is_qi: true when called from caamqi.",
        "proto" :"void cnstr_shdsc_gcm_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol). Input sequence: AAD | PTXT. Output sequence: AAD | CTXT | ICV. AAD length (assoclen), which includes the IV length, is available in Math3.",
        "proto" :"void (*cnstr_shdsc_rfc4106_encap)(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_encap": {
        "description": "IPSec ESP gcm encapsulation shared descriptor (non-protocol).",
        "proto": "void (*cnstr_shdsc_rfc4106_encap)(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "proto" :"void (*cnstr_shdsc_rfc4106_decap)(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]",
        },
    }
},
{
    "kprobe:cnstr_shdsc_rfc4106_decap": {
        "description": "IPSec ESP gcm decapsulation shared descriptor (non-protocol).",
        "proto" :"void cnstr_shdsc_rfc4106_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]",
        },
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "proto": "void cnstr_shdsc_rfc4543_encap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_encap": {
        "description": "IPSec ESP gmac encapsulation shared descriptor (non-protocol).",
        "proto": "void cnstr_shdsc_rfc4543_encap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "proto": "void cnstr_shdsc_rfc4543_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]"
        }
    }
},
{
    "kprobe:cnstr_shdsc_rfc4543_decap": {
        "description": "IPSec ESP gmac decapsulation shared descriptor (non-protocol).",
        "proto" :"void cnstr_shdsc_rfc4543_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, unsigned int icvsize, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "icvsize": ">=0",
            "is_qi": "in [true, false]",
            "cdata->algorithm": "in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_GCM]"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "proto" :"void cnstr_shdsc_chachapoly(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool encap, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_CHACHA20 AND OP_ALG_AAI_AEAD]",
            "adata": "!=null && adata->algorithm in [OP_ALG_ALGSEL_POLY1305 AND OP_ALG_AAI_AEAD]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "encap": "is a boolean",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kprobe:cnstr_shdsc_chachapoly": {
        "description": "Chacha20 + Poly1305 generic AEAD (rfc7539) and IPsec ESP (rfc7634, a.k.a. rfc7539esp) shared descriptor (non-protocol).",
        "proto" :"void (*cnstr_shdsc_chachapoly)(u32 * const desc, struct alginfo *cdata, struct alginfo *adata, unsigned int ivsize, unsigned int icvsize, const bool encap, const bool is_qi)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->algorithm in [OP_ALG_ALGSEL_CHACHA20 ANDed with OP_ALG_AAI_AEAD]",
            "adata": "!=null && adata->algorithm in [OP_ALG_ALGSEL_POLY1305 ANDed with OP_ALG_AAI_AEAD]",
            "ivsize": "is a positive integer",
            "icvsize": "is a positive integer",
            "encap": "is a boolean",
            "is_qi": "is a boolean"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "proto": "void cnstr_shdsc_skcipher_encap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, const bool is_rfc3686, const u32 ctx1_iv_off)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_encap": {
        "description": "skcipher encapsulation shared descriptor",
        "proto": "void cnstr_shdsc_skcipher_encap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, const bool is_rfc3686, const u32 ctx1_iv_off)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && (cdata->alg == OP_ALG_ALGSEL_AES || cdata->alg == OP_ALG_ALGSEL_DES || cdata->alg == OP_ALG_ALGSEL_3DES || cdata->alg == OP_ALG_ALGSEL_CHACHA20) && (cdata->aai == OP_ALG_AAI_CBC || cdata->aai == OP_ALG_AAI_CTR_MOD128)",
            "ivsize": ">=0",
            "is_rfc3686": "is boolean",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "proto" :"void cnstr_shdsc_skcipher_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, const bool is_rfc3686, const u32 ctx1_iv_off)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "ctx1_iv_off": ">=0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_skcipher_decap": {
        "description": "skcipher decapsulation shared descriptor",
        "proto": "void cnstr_shdsc_skcipher_decap(u32 * const desc, struct alginfo *cdata, unsigned int ivsize, const bool is_rfc3686, const u32 ctx1_iv_off)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null",
            "ivsize": ">=0",
            "is_rfc3686": "in [true, false]",
            "ctx1_iv_off": ">=0",
            "cdata->algtype": "in [OP_ALG_ALGSEL_AES, OP_ALG_ALGSEL_DES, OP_ALG_ALGSEL_3DES, OP_ALG_ALGSEL_CHACHA20] AND [OP_ALG_AAI_CBC, OP_ALG_AAI_CTR_MOD128]"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_XTS.",
        "proto" :"void cnstr_shdsc_xts_skcipher_encap(u32 * const desc, struct alginfo *cdata)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->alg = (OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS)"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_encap": {
        "description": "xts skcipher encapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_XTS.",
        "proto" :"void (*cnstr_shdsc_xts_skcipher_encap)(u32 * const desc, struct alginfo *cdata)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->alg = (OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS)"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor. @desc: pointer to buffer used for descriptor construction. @cdata: pointer to block cipher transform definitions. Valid algorithm values - OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_XTS.",
        "proto" :"void cnstr_shdsc_xts_skcipher_decap(u32 * const desc, struct alginfo *cdata)",
        "pre": {
            "desc": "!=null",
            "cdata": "!=null && cdata->alg = (OP_ALG_ALGSEL_AES & OP_ALG_AAI_XTS)"
        }
    }
},
{
    "kprobe:cnstr_shdsc_xts_skcipher_decap": {
        "description": "xts skcipher decapsulation shared descriptor",
        "proto" :"void cnstr_shdsc_xts_skcipher_decap(u32 * const desc, struct alginfo *cdata)",
        "pre": {
            "desc": "!=null",
            "cdata": {
                "!=null",
                "algorithm": "in [OP_ALG_ALGSEL_AES ANDed with OP_ALG_AAI_XTS]"
            }
        }
    }
},

{
    "kprobe:gen_split_key": {
        "description": "Generates a split key. The function takes in a device, a key_out, an alginfo structure, a key_in, a keylen, and a max_keylen. It then calculates the split key length and the padded split key length. If the local_max is greater than the max_keylen, it returns -EINVAL. It then allocates memory for the desc. If it fails, it returns -ENOMEM. It then copies the key_in into the key_out and maps the key_out into memory. If the mapping fails, it frees the allocated memory and returns. It then initializes the job desc and appends the key to the desc.",
        "proto": "gen_split_key(struct device  jrdev, u8  key_out,  struct alginfo   const adata, const u8  key_in, u32 keylen,  int max_keylen)",
        "pre": {
            "jrdev": "!=null",
            "key_out": "!=null",
            "adata": "!=null",
            "key_in": "!=null",
            "keylen": ">=0",
            "max_keylen": ">=keylen"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "proto": "void cnstr_shdsc_ahash(u32 * const desc, struct alginfo *adata, u32 state, int digestsize, int ctx_len, bool import_ctx, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": "> 0",
            "ctx_len": "> 0",
            "import_ctx": "in [true, false]",
            "era": ">= 0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_ahash": {
        "description": "ahash shared descriptor",
        "proto": "void cnstr_shdsc_ahash(u32 * const desc, struct alginfo *adata, u32 state, int digestsize, int ctx_len, bool import_ctx, int era)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">0",
            "ctx_len": ">0",
            "import_ctx": "in [true, false]",
            "era": ">=0"
        }
    }
},
{
    "kretprobe:cnstr_shdsc_sk_hash": {
        "description": "Shared descriptor for symmetric key cipher-based hash algorithms. @desc: pointer to buffer used for descriptor construction. @adata: pointer to authentication transform definitions. @state: algorithm state OP_ALG_AS_{INIT, FINALIZE, INITFINALIZE, UPDATE}. @digestsize: algorithm's digest size. @ctx_len: size of Context Register.",
        "proto" :"void cnstr_shdsc_sk_hash(u32 * const desc, struct alginfo *adata, u32 state, int digestsize, int ctx_len)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">0",
            "ctx_len": ">0"
        }
    }
},
{
    "kprobe:cnstr_shdsc_sk_hash": {
        "description": "Shared descriptor for symmetric key cipher-based hash algorithms",
        "proto" :"void cnstr_shdsc_sk_hash(u32 * const desc, struct alginfo *adata, u32 state, int digestsize, int ctx_len)",
        "pre": {
            "desc": "!=null",
            "adata": "!=null",
            "state": "in [OP_ALG_AS_INIT, OP_ALG_AS_FINALIZE, OP_ALG_AS_INITFINALIZE, OP_ALG_AS_UPDATE]",
            "digestsize": ">0",
            "ctx_len": ">0"
        }
    }
},


{
    "kretprobe:caam_drv_ctx_init": {
        "description": "Initialise pre-header - set RSLS and SDLEN - and shared descriptor and dma-map them.",
        "proto" :"static long (*caam_drv_ctx_init)(struct device *qidev, int cpu, u32 sh_desc)",
        "pre": {
            "qidev": "!=null",
            "cpu": "is an integer",
            "sh_desc": "!=null && length <= MAX_SDLEN",
        },
    }
},
{
    "kprobe:caam_drv_ctx_init": {
        "description": "Initialise pre-header - set RSLS and SDLEN - and shared descriptor and dma-map them.",
        "proto" :"caam_drv_ctx_init(struct device  qidev, int  cpu, u32  sh_desc)",
        "pre": {
            "qidev": "!=null",
            "cpu": "is an integer",
            "sh_desc": "!=null and length <= MAX_SDLEN",
        },
    }
},
{
    "kretprobe:caam_drv_ctx_rel": {
        "description": "Remove request FQ",
        "proto" :"void caam_drv_ctx_rel(struct caam_drv_ctx *drv_ctx)",
        "pre": {
            "drv_ctx": "!=null"
        }
    }
},
{
    "kprobe:caam_drv_ctx_rel": {
        "description": "Remove request FQ",
        "proto" :"void caam_drv_ctx_rel(struct caam_drv_ctx *drv_ctx)",
        "pre": {
            "drv_ctx": "!=null"
        }
    }
},


{
    "kretprobe:caam_jr_alloc": {
        "description": "caam_jr_alloc() may expectedly fail with -ENODEV, e.g. when CAAM driver didn't probe or when SoC lacks BLOB support. An error would be harsh in this case, so we stick to info level.",
        "proto" :"static struct device* (*caam_jr_alloc)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_alloc": {
        "description": "caam_blob_gen_init() may expectedly fail with -ENODEV, e.g. when CAAM driver didn't probe or when SoC lacks BLOB support. An error would be harsh in this case, so we stick to info level.",
        "proto" :"static struct device (*caam_jr_alloc)(void)",
        "pre": {
            // Constraints for the function's parameters should be here
        },
    }
},
{
    "kretprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed. Returns a pointer to the newly allocated physical JobR dev can be written to if successful.",
        "proto" :"struct device *(*caam_jr_alloc)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_alloc": {
        "description": "Alloc a job ring for someone to use as needed. Returns a pointer to the newly allocated physical JobR dev if successful.",
        "proto" :"struct device *(*caam_jr_alloc)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_free": {
        "description": "Free the Job Ring. @rdev points to the dev that identifies the Job ring to be released.",
        "proto" :"void (*caam_jr_free)(struct device *rdev)",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kprobe:caam_jr_free": {
        "description": "Free the Job Ring. @rdev points to the dev that identifies the Job ring to be released.",
        "proto" :"static void (*caam_jr_free)(struct device *rdev)",
        "pre": {
            "rdev": "!=null"
        }
    }
},
{
    "kretprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head. Returns -EINPROGRESS if OK, -ENOSPC if the queue is full, -EIO if it cannot map the caller's descriptor.",
        "proto" :"int caam_jr_enqueue(struct device *dev, u32 *desc, void (*cbk)(struct device *dev, u32 *desc,u32 status, void *areq), void *areq)",
        "pre": {
            "dev": "!=null",
            "desc": "!=null",
            "cbk": "!=null",
            "areq": "can be null or !=null"
        },
        "post": {
            "return": "in [-EINPROGRESS, -ENOSPC, -EIO]"
        }
    }
},
{
    "kprobe:caam_jr_enqueue": {
        "description": "Enqueue a job descriptor head. Returns -EINPROGRESS if OK, -ENOSPC if the queue is full, -EIO if it cannot map the caller's descriptor.",
        "proto" :"int caam_jr_enqueue(struct device *dev, u32 *desc, void (*cbk)(struct device *dev, u32 *desc,u32 status, void *areq), void *areq)",
        "pre": {
            "dev": "!=null",
            "desc": "!=null && is in a DMAable region && is a physical address accessible to CAAM",
            "cbk": "!=null && is a function pointer",
            "areq": "optional"
        },
    }
},
{
    "kretprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue. This may be called with qp->s_lock held. Return true on success, else return false if cq is full.",
        "proto" :"bool (*rvt_cq_enter)(struct rvt_cq *cq, struct ib_wc *entry, bool solicited)",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_cq_enter": {
        "description": "Add a new entry to the completion queue. This may be called with qp->s_lock held. Return true on success, else return false if cq is full.",
        "proto" :"bool (*rvt_cq_enter)(struct rvt_cq *cq, struct ib_wc *entry, bool solicited)",
        "pre": {
            "cq": "!=null",
            "entry": "!=null",
            "solicited": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_alloc_device": {
        "description": "Use IB core device alloc to allocate space for the rdi which is assumed to be inside of the ib_device. Any extra space that drivers require should be included in size. We also allocate a port array based on the number of ports.",
        "proto" :"struct rvt_dev_info *(*rvt_alloc_device)(size_t size, int nports)",
        "pre": {
            "size": ">=0",
            "nports": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rvt_alloc_device": {
        "description": "Use IB core device alloc to allocate space for the rdi which is assumed to be inside of the ib_device. Any extra space that drivers require should be included in size. We also allocate a port array based on the number of ports.",
        "proto" :"struct rvt_dev_info *(*rvt_alloc_device)(size_t size, int nports)",
        "pre": {
            "size": ">=0",
            "nports": ">=0"
        },
    }
},
{
    "kretprobe:rvt_dealloc_device": {
        "description": "Deallocate rdi. Free a structure allocated with rvt_alloc_device()",
        "proto" :"void (*rvt_dealloc_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_dealloc_device": {
        "description": "Deallocate rdi. Free a structure allocated with rvt_alloc_device()",
        "proto" :"void (*rvt_dealloc_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_register_device": {
        "description": "Register a driver. It is up to drivers to allocate the rdi and fill in the appropriate information.",
        "proto" :"int (*rvt_register_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        },
        "post": {
            "return": "in [0, errno]"
        }
    }
},
{
    "kprobe:rvt_register_device": {
        "description": "Register a driver. It is up to drivers to allocate the rdi and fill in the appropriate information. Return: 0 on success otherwise an errno.",
        "proto" :"int (*rvt_register_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_unregister_device": {
        "description": "Remove a driver @rdi: rvt dev struct",
        "proto" :"void (*rvt_unregister_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_unregister_device": {
        "description": "Remove a driver",
        "proto" :"void (*rvt_unregister_device)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_init_port": {
        "description": "Init internal data for driver port. Keep track of a list of ports. They persist until the driver goes away.",
        "proto" :"int rvt_init_port(struct rvt_dev_info *rdi, struct rvt_ibport *port, int port_index, u16 *pkey_table)",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rvt_init_port": {
        "description": "Init internal data for driver port. Keep track of a list of ports. They persist until the driver goes away.",
        "proto" :"int (*rvt_init_port)(struct rvt_dev_info *rdi, struct rvt_ibport *port,  int port_index, u16 *pkey_table)",
        "pre": {
            "rdi": "!=null",
            "port": "!=null",
            "port_index": ">=0",
            "pkey_table": "!=null"
        },
    }
},
{
    "kretprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "proto" :"static void rvt_remove_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_remove_qp": {
        "description": "Remove the QP from the table so it can't be found asynchronously by the receive routine.",
        "proto" :"static void (*rvt_remove_qp)(struct rvt_dev_info *rdi, struct rvt_qp *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        },
    }
},
{
    "kretprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "proto" :"static void rvt_insert_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_insert_qp": {
        "description": "Put the QP into the hash table. The hash table holds a reference to the QP.",
        "proto" :"static void rvt_insert_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_comm_est": {
        "description": "Handle trap with QP established",
        "proto" :"void (*rvt_comm_est)(struct rvt_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_comm_est": {
        "description": "Handle trap with QP established",
        "proto": "void (*rvt_comm_est)(struct rvt_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return usec from an index into ib_rvt_rnr_table",
        "proto" :"unsigned long (*rvt_rnr_tbl_to_usec)(u32 index)",
        "pre": {
            "index": ">=0"
        },
    }
},
{
    "kprobe:rvt_rnr_tbl_to_usec": {
        "description": "Return usec from an index into ib_rvt_rnr_table",
        "proto" :"unsigned long (*rvt_rnr_tbl_to_usec)(u32 index)",
        "pre": {
            "index": "is a valid u32"
        }
    }
},
{
    "kretprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP with a timeout shift to wait for multiple packets.",
        "proto" :"void (*rvt_add_retry_timer_ext)(struct rvt_qp *qp, u8 shift)",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kprobe:rvt_add_retry_timer_ext": {
        "description": "Add a retry timer on the QP with a timeout shift to wait for multiple packets.",
        "proto" :"static void (*rvt_add_retry_timer_ext)(struct rvt_qp *qp, u8 shift)",
        "pre": {
            "qp": "!=null",
            "shift": ">=0"
        }
    }
},
{
    "kretprobe:rvt_add_rnr_timer": {
        "description": "Addstart an rnr timer on the QP @qp: the QP @aeth: aeth of RNR timeout, simulated aeth for loopback",
        "proto" :"void (*rvt_add_rnr_timer)(struct rvt_qp *qp, u32 aeth)",
        "pre": {
            "qp": "!=null",
            "aeth": ">=0"
        }
    }
},
{
    "kprobe:rvt_add_rnr_timer": {
        "description": "Addstart an rnr timer on the QP. @qp: the QP. @aeth: aeth of RNR timeout, simulated aeth for loopback.",
        "proto" :"void (*rvt_add_rnr_timer)(struct rvt_qp *qp, u32 aeth)",
        "pre": {
            "qp": "!=null",
            "aeth": ">=0"
        }
    }
},
{
    "kretprobe:rvt_stop_rc_timers": {
        "description": "Stop the send queue and the retry timer.",
        "proto" :"static void (*rvt_stop_rc_timers)(struct rvt_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rdi->driver_f.stop_send_queue(qp);rvt_del_timers_sync(qp);/* Wait for things to stop": {
        "description": "Stop the send queue and the retry timer",
        "proto" :"void (*rdi->driver_f.stop_send_queue)(struct rvt_qp *qp); void (*rvt_del_timers_sync)(struct rvt_qp *qp);",
        "pre": {
            "qp": "!=null",
        },
    }
},
{
    "kretprobe:rdi->driver_f.quiesce_qp": {
        "description": "Take qp out the hash and wait for it to be unused",
        "proto" :"void (*rdi->driver_f.quiesce_qp)(void *qp)",
        "pre": {
            "qp": "!=null",
        },
    }
},

{
    "kretprobe:rvt_rc_rnr_retry": {
        "description": "Driver needs to set up its private QP structure and do any initialization that is needed.",
        "proto": "static void *(*rdi->driver_f.qp_priv_alloc)(void *rdi, void *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        },
        "post": {
            "priv": "!=null && !IS_ERR(priv)"
        }
    }
},
{
    "kprobe:rvt_rc_rnr_retry": {
        "description": "Driver needs to set up its private QP structure and do any initialization that is needed.",
        "proto" :"static long (*rvt_rc_rnr_retry)(void *rdi, void *qp)",
        "pre": {
            "rdi": "!=null",
            "qp": "!=null"
        },
    }
},
{
    "kretprobe:rvt_qp_iter_init": {
        "description": "Initial for QP iteration. This returns an iterator suitable for iterating QPs in the system. The @cb is a user-defined callback and @v is a 64-bit value passed to and relevant for processing in the @cb. An example use case would be to alter QP processing based on criteria not part of the rvt_qp. Use cases that require memory allocation to succeed must preallocate appropriately.",
        "proto" :"struct rvt_qp_iter *(*rvt_qp_iter_init)(struct rvt_dev_info *rdi, u64 v, void (*cb)(struct rvt_qp *qp, u64 v))",
        "pre": {
            "rdi": "!=null",
            "v": "!=null",
            "cb": "!=null"
        },
    }
},
{
    "kprobe:rvt_qp_iter_init": {
        "description": "Initial for QP iteration. This returns an iterator suitable for iterating QPs in the system. The @cb is a user-defined callback and @v is a 64-bit value passed to and relevant for processing in the @cb. An example use case would be to alter QP processing based on criteria not part of the rvt_qp. Use cases that require memory allocation to succeed must preallocate appropriately.",
        "proto" :"struct rvt_qp_iter *(*rvt_qp_iter_init)(struct rvt_dev_info *rdi, u64 v, void (*cb)(struct rvt_qp *qp, u64 v))",
        "pre": {
            "rdi": "!=null",
            "v": "is u64",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter. Fine grained QP iterator suitable for use with debugfs seq_file mechanisms. Updates iter->qp with the current QP when the return value is 0.",
        "proto" :"int rvt_qp_iter_next(struct rvt_qp_iter *iter)__must_hold(RCU)",
        "pre": {
            "iter": "!=null"
        },
        "post": {
            "return": "in [0, 1]",
            "iter->qp": "if return == 0 then !=null else unchanged"
        }
    }
},
{
    "kprobe:rvt_qp_iter_next": {
        "description": "Return the next QP in iter. Fine grained QP iterator suitable for use with debugfs seq_file mechanisms. Updates iter->qp with the current QP when the return value is 0. Return: 0 - iter->qp is valid 1 - no more QPs",
        "proto" :"int rvt_qp_iter_next(struct rvt_qp_iter *iter)__must_hold(RCU)",
        "pre": {
            "iter": "[Your condition here]"
        },
    }
},
{
    "kretprobe:rvt_qp_exit": {
        "description": "Check for qp leaks and free resources on device exit.",
        "proto" :"void (*rvt_qp_exit)(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kprobe:rvt_qp_exit": {
        "description": "Clean up qps on device exit, check for qp leaks and free resources.",
        "proto" :"void rvt_qp_exit(struct rvt_dev_info *rdi)",
        "pre": {
            "rdi": "!=null"
        }
    }
},
{
    "kretprobe:rvt_copy_sge": {
        "description": "rvt_copy_sge - copy data to SGE memory   @qp: associated QP   @ss: the SGE state   @data: the data to copy   @length: the length of the data   @release: boolean to release MR   @copy_last: do a separate copy of the last 8 bytes",
        "proto" :"void (*rvt_copy_sge)(struct rvt_qp *qp, struct rvt_sge_state *ss,  void *data, u32 length,  bool release, bool copy_last)",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kprobe:rvt_copy_sge": {
        "description": "Copy data to SGE memory. @qp: associated QP. @ss: the SGE state. @data: the data to copy. @length: the length of the data. @release: boolean to release MR. @copy_last: do a separate copy of the last 8 bytes.",
        "proto" :"void (*rvt_copy_sge)(struct rvt_qp *qp, struct rvt_sge_state *ss, void *data, u32 length, bool release, bool copy_last)",
        "pre": {
            "qp": "!=null",
            "ss": "!=null",
            "data": "!=null",
            "length": ">=0",
            "release": "in [true, false]",
            "copy_last": "in [true, false]"
        }
    }
},
{
    "kretprobe:rvt_ruc_loopback": {
        "description": "Handle UC and RC loopback requests. This is called from rvt_do_send() to forward a WQE addressed to the same HFI. Note that although we are single threaded due to the send engine, we still have to protect against post_send(). We don't have to worry about receive interrupts since this is a connected protocol and all packets will pass through here.",
        "proto" :"void (*rvt_ruc_loopback)(struct rvt_qp *sqp)",
        "pre": {
            "sqp": "!=null"
        }
    }
},
{
    "kprobe:rvt_ruc_loopback": {
        "description": "Handle UC and RC loopback requests. This is called from rvt_do_send() to forward a WQE addressed to the same HFI. Note that although we are single threaded due to the send engine, we still have to protect against post_send(). We don't have to worry about receive interrupts since this is a connected protocol and all packets will pass through here.",
        "proto" :"void (*rvt_ruc_loopback)(struct rvt_qp *sqp)",
        "pre": {
            "sqp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN) for the queue pair.",
        "proto" :"__be32 (*rvt_compute_aeth)(struct rvt_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:rvt_compute_aeth": {
        "description": "Compute the AETH (syndrome + MSN) for the queue pair.",
        "proto" :"__be32 (*rvt_compute_aeth)(struct rvt_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP. The QP s_lock should be held.",
        "proto" :"void (*rvt_get_credit)(struct rvt_qp *qp, u32 aeth)",
        "pre": {
            "qp": "!=null",
            "aeth": "is a valid u32 value"
        }
    }
},
{
    "kprobe:rvt_get_credit": {
        "description": "Flush the send work queue of a QP",
        "proto" :"void (*rvt_get_credit)(struct rvt_qp *qp, u32 aeth)",
        "pre": {
            "qp": "!=null && qp->s_lock == locked",
            "aeth": "unknown"
        },
    }
},
{
    "kretprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe. Returns the remaining data length.",
        "proto": "u32 (*rvt_restart_sge)(struct rvt_sge_state *ss, struct rvt_swqe *wqe, u32 len)",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:rvt_restart_sge": {
        "description": "Rewind the sge state for a wqe. Returns the remaining data length.",
        "proto" :"u32 (*rvt_restart_sge)(struct rvt_sge_state *ss, struct rvt_swqe *wqe, u32 len)",
        "pre": {
            "ss": "!=null",
            "wqe": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH. If driver supports a more detailed check_ah function call back to it, otherwise just check the basics.",
        "proto" :"int (*rvt_check_ah)(struct ib_device *ibdev, struct rdma_ah_attr *ah_attr)",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:rvt_check_ah": {
        "description": "Validate the attributes of AH. If driver supports a more detailed check_ah function call back to it, otherwise just check the basics.",
        "proto" :"int (*rvt_check_ah)(struct ib_device *ibdev, struct rdma_ah_attr *ah_attr)",
        "pre": {
            "ibdev": "!=null",
            "ah_attr": "!=null"
        },
    }
},
{
    "kretprobe:rvt_fast_reg_mr": {
        "description": "Fast register physical MR. The queue pair where the work request comes from. The memory region to be registered. Updated key for this memory region. Access flags for this memory region. Returns 0 on success.",
        "proto" :"int rvt_fast_reg_mr(struct rvt_qp *qp, struct ib_mr *ibmr, u32 key, int access)",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "is u32",
            "access": "is int"
        },
    }
},
{
    "kprobe:rvt_fast_reg_mr": {
        "description": "Fast register physical MR. The queue pair where the work request comes from. The memory region to be registered. Updated key for this memory region. Access flags for this memory region. Returns 0 on success.",
        "proto" :"int (*rvt_fast_reg_mr)(struct rvt_qp *qp, struct ib_mr *ibmr, u32 key, int access)",
        "pre": {
            "qp": "!=null",
            "ibmr": "!=null",
            "key": "is u32",
            "access": "is int"
        },
    }
},
{
    "kretprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey. Returns 0 on success.",
        "proto" :"int (*rvt_invalidate_rkey)(struct rvt_qp *qp, u32 rkey)",
        "pre": {
            "qp": "!=null",
            "rkey": "is a valid rkey"
        },
    }
},
{
    "kprobe:rvt_invalidate_rkey": {
        "description": "Invalidate an MR rkey. Returns 0 on success.",
        "proto" :"int (*rvt_invalidate_rkey)(struct rvt_qp *qp, u32 rkey)",
        "pre": {
            "qp": "!=null",
            "rkey": "is a valid rkey"
        }
    }
},
{
    "kretprobe:rvt_lkey_ok": {
        "description": "Check the IB SGE for validity and initialize our internal version of it. Increments the reference count when a new sge is stored.",
        "proto" :"int rvt_lkey_ok(struct rvt_lkey_table *rkt, struct rvt_pd *pd, struct rvt_sge *isge, struct rvt_sge *last_sge, struct ib_sge *sge, int acc)",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "in [0, 1, -errno]"
        },
        "post": {
            "return": "in [0, 1, -errno]"
        }
    }
},
{
    "kprobe:rvt_lkey_ok": {
        "description": "Check the IB SGE for validity and initialize our internal version of it. Increments the reference count when a new sge is stored. Return: 0 if compressed, 1 if added , otherwise returns -errno.",
        "proto" :"int rvt_lkey_ok(struct rvt_lkey_table *rkt, struct rvt_pd *pd,struct rvt_sge *isge, struct rvt_sge *last_sge,struct ib_sge *sge, int acc)",
        "pre": {
            "rkt": "!=null",
            "pd": "!=null",
            "isge": "!=null",
            "last_sge": "!=null",
            "sge": "!=null",
            "acc": "in [0, 1, -errno]",
        },
    }
},
{
    "kretprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual address, length, and RKEY. Increments the reference count upon success.",
        "proto" :"int (*rvt_rkey_ok)(struct rvt_qp *qp, struct rvt_sge *sge, u32 len, u64 vaddr, u32 rkey, int acc)",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">=0",
            "vaddr": ">=0",
            "rkey": ">=0",
            "acc": "in [ACCESS_FLAG_1, ACCESS_FLAG_2, ...]" // replace with actual access flags
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:rvt_rkey_ok": {
        "description": "Check the IB virtual address, length, and RKEY. Increments the reference count upon success.",
        "proto" :"int (*rvt_rkey_ok)(struct rvt_qp *qp, struct rvt_sge *sge, u32 len, u64 vaddr, u32 rkey, int acc)",
        "pre": {
            "qp": "!=null",
            "sge": "!=null",
            "len": ">=0",
            "vaddr": ">=0",
            "rkey": ">=0",
            "acc": "in [ACCESS_FLAG_1, ACCESS_FLAG_2, ...]" // replace with actual access flags
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GIDLID. It is valid to have 1 MLID with multiple MGIDs. It is not valid to have 1 MGID with multiple MLIDs. The caller is responsible for decrementing the reference count if found. Returns NULL if not found.",
        "proto" :"struct rvt_mcast *(*rvt_mcast_find)(struct rvt_ibport *ibp, union ib_gid *mgid, u16 lid)",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": ">=0"
        },
    }
},
{
    "kprobe:rvt_mcast_find": {
        "description": "Search the global table for the given multicast GID/LID. It is valid to have 1 MLID with multiple MGIDs. It is not valid to have 1 MGID with multiple MLIDs. The caller is responsible for decrementing the reference count if found. Returns NULL if not found.",
        "proto" :"struct rvt_mcast *(*rvt_mcast_find)(struct rvt_ibport *ibp, union ib_gid *mgid, u16 lid)",
        "pre": {
            "ibp": "!=null",
            "mgid": "!=null",
            "lid": ">=0"
        },
    }
},
{
    "kretprobe:ib_uverbs_get_ucontext_file": {
        "description": "We do not hold the hw_destroy_rwsem lock for this flow, instead srcu is used. It does not matter if someone races this with get_context, we get NULL or valid ucontext.",
        "proto" :"struct ib_ucontext *(*ib_uverbs_get_ucontext_file)(struct ib_uverbs_file *ufile)",
        "pre": {
            "ufile": "!=null"
        },
        "post": {
            "return": "in [NULL, valid ucontext, ERR_PTR(-EIO), ERR_PTR(-EINVAL)]"
        }
    }
},
{
    "kprobe:ib_uverbs_get_ucontext_file": {
        "description": "We do not hold the hw_destroy_rwsem lock for this flow, instead srcu is used. It does not matter if someone races this with get_context, we get NULL or valid ucontext.",
        "proto" :"struct ib_ucontext *(*ib_uverbs_get_ucontext_file)(struct ib_uverbs_file *ufile)",
        "pre": {
            "ufile": "!=null",
        },
    }
},
{
    "kretprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context. This function is used to process all outstanding CQ entries. It does not offload CQ processing to a different context and does not ask for completion interrupts from the HCA. Using direct processing on CQ with non IB_POLL_DIRECT type may trigger concurrent processing. Note: do not pass -1 as %budget unless it is guaranteed that the number of completions that will be processed is small.",
        "proto" :"int (*ib_process_cq_direct)(struct ib_cq *cq, int budget)",
        "pre": {
            "cq": "!=null",
            "budget": ">=0"
        }
    }
},
{
    "kprobe:ib_process_cq_direct": {
        "description": "Process a CQ in caller context. This function is used to process all outstanding CQ entries. It does not offload CQ processing to a different context and does not ask for completion interrupts from the HCA. Using direct processing on CQ with non IB_POLL_DIRECT type may trigger concurrent processing. Note: do not pass -1 as %budget unless it is guaranteed that the number of completions that will be processed is small.",
        "proto" :"int (*ib_process_cq_direct)(struct ib_cq *cq, int budget)",
        "pre": {
            "cq": "!=null",
            "budget": ">=0 && !=-1 unless it is guaranteed that the number of completions that will be processed is small"
        }
    }
},
{
    "kretprobe:__ib_alloc_cq": {
        "description": "__ib_alloc_cq - allocate a completion queue. This is the proper interface to allocate a CQ for in-kernel users. A CQ allocated with this interface will automatically be polled from the specified context. The ULP must use wr->wr_cqe instead of wr->wr_id to use this CQ abstraction.",
        "proto" :"struct ib_cq *__ib_alloc_cq(struct ib_device *dev, void *private, int nr_cqe, int comp_vector, enum ib_poll_context poll_ctx, const char *caller)",
        "pre": {
            "dev": "!=null",
            "private": "can be null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        },
    }
},
{
    "__ib_alloc_cq": {
        "description": "__ib_alloc_cq - allocate a completion queue. This is the proper interface to allocate a CQ for in-kernel users. A CQ allocated with this interface will automatically be polled from the specified context. The ULP must use wr->wr_cqe instead of wr->wr_id to use this CQ abstraction.",
        "proto" :"struct ib_cq *(__ib_alloc_cq)(struct ib_device *dev, void *private, int nr_cqe, int comp_vector, enum ib_poll_context poll_ctx, const char *caller)",
        "pre": {
            "dev": "!=null",
            "private": "can be null",
            "nr_cqe": ">=0",
            "comp_vector": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null",
        },
    }
},
{
    "kretprobe:__ib_alloc_cq_any": {
        "description": "Allocate a completion queue. Attempt to spread ULP Completion Queues over each device's interrupt vectors. A simple best-effort mechanism is used.",
        "proto" :"struct ib_cq * (*__ib_alloc_cq_any)(struct ib_device *dev, void *private, int nr_cqe, enum ib_poll_context poll_ctx, const char *caller)",
        "pre": {
            "dev": "!=null",
            "private": "can be null",
            "nr_cqe": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null"
        },
    }
},
{
    "__ib_alloc_cq_any": {
        "description": "Allocate a completion queue. Attempt to spread ULP Completion Queues over each device's interrupt vectors. A simple best-effort mechanism is used.",
        "proto" :"struct ib_cq *(*__ib_alloc_cq_any)(struct ib_device *dev, void *private, int nr_cqe, enum ib_poll_context poll_ctx, const char *caller)",
        "pre": {
            "dev": "!=null",
            "private": "can be null",
            "nr_cqe": ">=0",
            "poll_ctx": "in [IB_POLL_DIRECT, IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE]",
            "caller": "!=null",
        },
    }
},
{
    "kretprobe:ib_free_cq": {
        "description": "Free a completion queue",
        "proto": "void (*ib_free_cq)(struct ib_cq *cq)",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kprobe:ib_free_cq": {
        "description": "Free a completion queue",
        "proto": "void (*ib_free_cq)(struct ib_cq *cq)",
        "pre": {
            "cq": "!=null"
        }
    }
},
{
    "kretprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe. In case there is no available cq, allocate a new cq with the requirements and add it to the device pool. IB_POLL_DIRECT cannot be used for shared cqs so it is not a valid value for @poll_ctx.",
        "proto" :"struct ib_cq *(*ib_cq_pool_get)(struct ib_device *dev, unsigned int nr_cqe, int comp_vector_hint, enum ib_poll_context poll_ctx)",
        "pre": {
            "dev": "!=null",
            "nr_cqe": ">0",
            "comp_vector_hint": ">=-1",
            "poll_ctx": "in [IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE, IB_POLL_AFFINITY]"
        },
    }
},
{
    "kprobe:ib_cq_pool_get": {
        "description": "Find the least used completion queue that matches a given cpu hint (or least used for wild card affinity) and fits nr_cqe. In case there is no available cq, allocate a new cq with the requirements and add it to the device pool. IB_POLL_DIRECT cannot be used for shared cqs so it is not a valid value for @poll_ctx.",
        "proto" :"struct ib_cq *(*ib_cq_pool_get)(struct ib_device *dev, unsigned int nr_cqe, int comp_vector_hint, enum ib_poll_context poll_ctx)",
        "pre": {
            "dev": "!=null",
            "nr_cqe": ">=0",
            "comp_vector_hint": ">=-1",
            "poll_ctx": "in [IB_POLL_SOFTIRQ, IB_POLL_WORKQUEUE, IB_POLL_AFFINITY]"
        }
    }
},
{
    "kretprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool. @cq: The CQ to return. @nr_cqe: The max number of cqes that the user had requested.",
        "proto" :"void (*ib_cq_pool_put)(struct ib_cq *cq, unsigned int nr_cqe)",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kprobe:ib_cq_pool_put": {
        "description": "Return a CQ taken from a shared pool. @cq: The CQ to return. @nr_cqe: The max number of cqes that the user had requested.",
        "proto" :"void (*ib_cq_pool_put)(struct ib_cq *cq, unsigned int nr_cqe)",
        "pre": {
            "cq": "!=null",
            "nr_cqe": ">=0"
        }
    }
},
{
    "kretprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "proto" :"int (*ib_cm_listen)(struct ib_cm_id *cm_id, __be64 service_id)",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=IB_CM_ASSIGN_SERVICE_ID"
        },
    }
},
{
    "kprobe:ib_cm_listen": {
        "description": "Initiates listening on the specified service ID for connection and service ID resolution requests.",
        "proto" :"int (*ib_cm_listen)(struct ib_cm_id *cm_id, __be64 service_id)",
        "pre": {
            "cm_id": "!=null",
            "service_id": "!=IB_CM_ASSIGN_SERVICE_ID && >=0"
        }
    }
},
{
    "kretprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID. If there's an existing ID listening on that same device and service ID, return it. All related communication will be associated with the specified device. The service ID should be specified in network-byte order. If set to IB_CM_ASSIGN_SERVICE_ID, the CM will assign a service ID to the caller. Callers should call ib_destroy_cm_id when done with the listener ID.",
        "proto" :"struct ib_cm_id *(*ib_cm_insert_listen)(struct ib_device *device, ib_cm_handler cm_handler, __be64 service_id)",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "in [IB_CM_ASSIGN_SERVICE_ID, other valid service IDs]"
        },
    }
},
{
    "kprobe:ib_cm_insert_listen": {
        "description": "Create a new listening ib_cm_id and listen on the given service ID. If there's an existing ID listening on that same device and service ID, return it.",
        "proto" :"struct ib_cm_id *(*ib_cm_insert_listen)(struct ib_device *device, ib_cm_handler cm_handler, __be64 service_id)",
        "pre": {
            "device": "!=null",
            "cm_handler": "!=null",
            "service_id": "!=null && (service_id in network-byte order || service_id == IB_CM_ASSIGN_SERVICE_ID)"
        },
    }
},
{
    "kretprobe:ib_send_cm_req": {
        "description": "Verify that we're not in timewait.",
        "proto" :"int ib_send_cm_req(struct ib_cm_id cm_id, struct ib_cm_req_param param)",
        "pre": {
            "cm_id": "!=null",
            "param": "!=null"
        },
    }
},
{
    "kprobe:ib_send_cm_req": {
        "description": "Verify that we're not in timewait.",
        "proto" :"static long (*ib_send_cm_req)(struct ib_cm_id cm_id, struct ib_cm_req_param param)",
        "pre": {
            "cm_id": "!=null",
            "param": "!=null",
            "cm_id->state": "!=IB_CM_IDLE",
            "cm_id_priv->timewait_info": "==false",
        },
    }
},




{
    "kretprobe:ib_send_cm_sidr_rep": {
        "description": "Your function description here",
        "proto" :"static long (*ib_send_cm_sidr_rep)(void *id, struct ib_cm_sidr_rep_param *param)",
        "pre": {
            "id": "!=null",
            "param": "!=null",
        },
    }
},

{
    "kretprobe:ib_pack": {
        "description": "ib_pack() packs a list of structure fields into a buffer, controlled by the array of fields in @desc.",
        "proto": "void ib_pack(const struct ib_field *desc, int desc_len, void *structure, void *buf)",
        "pre": {
            "desc": "!=null",
            "desc_len": ">0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_pack": {
        "description": "ib_pack() packs a list of structure fields into a buffer, controlled by the array of fields in @desc.",
        "proto" :"static void (*ib_pack)(const struct ib_field *desc, int desc_len, void *structure, void *buf)",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "structure": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure. ib_pack() unpacks a list of structure fields from a buffer, controlled by the array of fields in @desc.",
        "proto" :"void (*ib_unpack)(const struct ib_field *desc, int desc_len, void *buf, void *structure)",
        "pre": {
            "desc": "!=null",
            "desc_len": ">0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kprobe:ib_unpack": {
        "description": "Unpack a buffer into a structure. ib_pack() unpacks a list of structure fields from a buffer, controlled by the array of fields in @desc.",
        "proto" :"void (*ib_unpack)(const struct ib_field *desc, int desc_len, void *buf, void *structure)",
        "pre": {
            "desc": "!=null",
            "desc_len": ">=0",
            "buf": "!=null",
            "structure": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_count": {
        "description": "The current usage of specific object @dev: IB device @type: actual type of object to operate",
        "proto" :"int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type)",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_restrack_count": {
        "description": "The current usage of specific object @dev: IB device @type: actual type of object to operate",
        "proto" :"int (*rdma_restrack_count)(struct ib_device *dev, enum rdma_restrack_type type)",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource. The current task will be used if the caller is NULL.",
        "proto" :"void (*rdma_restrack_set_name)(struct rdma_restrack_entry *res, const char *caller)",
        "pre": {
            "res": "!=null",
            "caller": "!=null || ==null"
        }
    }
},
{
    "kprobe:rdma_restrack_set_name": {
        "description": "Set the task for this resource. The current task will be used if the caller is NULL.",
        "proto" :"void (*rdma_restrack_set_name)(struct rdma_restrack_entry *res, const char *caller)",
        "pre": {
            "res": "!=null",
            "caller": "can be null"
        }
    }
},
{
    "kretprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack.",
        "proto" :"void (*rdma_restrack_parent_name)(struct rdma_restrack_entry *dst, const struct rdma_restrack_entry *parent)",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_parent_name": {
        "description": "Set the restrack name properties based on parent restrack.",
        "proto" :"void (*rdma_restrack_parent_name)(struct rdma_restrack_entry *dst, const struct rdma_restrack_entry *parent)",
        "pre": {
            "dst": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in fully automatic way.",
        "proto" :"void (*rdma_restrack_new)(struct rdma_restrack_entry *res, enum rdma_restrack_type type)",
        "pre": {
            "res": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_restrack_new": {
        "description": "Initializes new restrack entry to allow _put() interface to release memory in fully automatic way.",
        "proto" :"void (*rdma_restrack_new)(struct rdma_restrack_entry *res, enum rdma_restrack_type type)",
        "pre": {
            "res": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_restrack_add": {
        "description": "Add object to the resource tracking database",
        "proto": "void (*rdma_restrack_add)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_add": {
        "description": "Add object to the resource tracking database",
        "proto" :"void (*rdma_restrack_add)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object. Return: Pointer to restrack entry or -ENOENT in case of error.",
        "proto" :"struct rdma_restrack_entry *(*rdma_restrack_get_byid)(struct ib_device *dev, enum rdma_restrack_type type, u32 id)",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]",
            "id": ">=0"
        },
    }
},
{
    "kprobe:rdma_restrack_get_byid": {
        "description": "Translate from ID to restrack object. Returns pointer to restrack entry or -ENOENT in case of error.",
        "proto" :"struct rdma_restrack_entry *(*rdma_restrack_get_byid)(struct ib_device *dev, enum rdma_restrack_type type, u32 id)",
        "pre": {
            "dev": "!=null",
            "type": "in [RDMA_RESTRACK_PD, RDMA_RESTRACK_MR, RDMA_RESTRACK_CQ, RDMA_RESTRACK_QP, RDMA_RESTRACK_CM_ID, RDMA_RESTRACK_DEVICE]",
            "id": ">=0"
        }
    }
},
{
    "kretprobe:rdma_restrack_del": {
        "description": "Delete object from the resource tracking database",
        "proto": "void (*rdma_restrack_del)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:rdma_restrack_del": {
        "description": "Delete object from the resource tracking database.",
        "proto" :"void (*rdma_restrack_del)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:ib_copy_path_rec_from_user": {
        "description": "Copies a user space path record to a kernel space path record.",
        "proto" :"void ib_copy_path_rec_from_user(struct sa_path_rec *dst, struct ib_user_path_rec *src)",
        "pre": {
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:ib_copy_path_rec_from_user": {
        "description": "Copies data from *src* to *dst*, performs checks and transformations on the data.",
        "proto" :"void ib_copy_path_rec_from_user(struct sa_path_rec *dst, struct ib_user_path_rec *src)",
        "pre": {
            "dst": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:ib_sa_join_multicast": {
        "description": "The user will get the multicast structure in their callback. They could then free the multicast structure before we can return from this routine. So we save the pointer to return before queuing any callback.",
        "proto" :"ib_sa_join_multicast(struct ib_sa_client client, struct ib_device device, u32 port_num, struct ib_sa_mcmember_rec rec, ib_sa_comp_mask comp_mask, gfp_t gfp_mask, int (callback)(int status, struct ib_sa_multicast multicast), void context)",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_join_multicast": {
        "description": "The user will get the multicast structure in their callback. They could then free the multicast structure before we can return from this routine. So we save the pointer to return before queuing any callback.",
        "proto" :"ib_sa_join_multicast(struct ib_sa_client client, struct ib_device device, u32 port_num, struct ib_sa_mcmember_rec rec, ib_sa_comp_mask comp_mask, gfp_t gfp_mask, int ( callback)(int status, struct ib_sa_multicast multicast), void context)",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": "!=null",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "!=null"
        },
    }
},


{
    "kretprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device. On success the caller is responsible to call rdma_destroy_ah_attr on the ah_attr. Returns 0 on success or appropriate error code.",
        "proto" :"int ib_init_ah_from_mcmember(struct ib_device *device, u32 port_num, struct ib_sa_mcmember_rec *rec, struct net_device *ndev, enum ib_gid_type gid_type, struct rdma_ah_attr *ah_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "ndev": "can be null, applicable only for RoCE",
            "gid_type": "in [IB_GID_TYPE_IB, IB_GID_TYPE_ROCE, IB_GID_TYPE_ROCE_UDP_ENCAP, IB_GID_TYPE_SIZE]",
            "ah_attr": "!=null"
        },
    }
},
{
    "kprobe:ib_init_ah_from_mcmember": {
        "description": "Initialize AH attribute from multicast member record and gid of the device.",
        "proto" :"int (*ib_init_ah_from_mcmember)(struct ib_device *device, u32 port_num, struct ib_sa_mcmember_rec *rec, struct net_device *ndev, enum ib_gid_type gid_type, struct rdma_ah_attr *ah_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "ndev": "can be null, applicable only for RoCE",
            "gid_type": "in [IB_GID_TYPE_IB, IB_GID_TYPE_ROCE, IB_GID_TYPE_ROCE_UDP_ENCAP, IB_GID_TYPE_SIZE]",
            "ah_attr": "!=null, to be filled up on successful completion"
        },
    }
},
{
    "kretprobe:uverbs_uobject_put": {
        "description": "Is called. When the reference count is decreased, the uobject is freed. For example, this is used when attaching a completion channel to a CQ.",
        "proto" :"void (*uverbs_uobject_put)(struct ib_uobject *uobject)",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kprobe:uverbs_uobject_put": {
        "description": "uverbs_uobject_put is called. When the reference count is decreased, the uobject is freed. For example, this is used when attaching a completion channel to a CQ.",
        "proto" :"void (*uverbs_uobject_put)(struct ib_uobject *uobject)",
        "pre": {
            "uobject": "!=null"
        }
    }
},
{
    "kretprobe:uverbs_uobject_fd_release": {
        "description": "Release is never done while a call to lookup is possible.",
        "proto" :"static long (*uverbs_uobject_fd_release)(struct file *f, struct fd_type *fd_type, struct uobject *uobject, struct ufile *ufile)",
        "pre": {
            "f": "!=null",
            "fd_type": "!=null",
            "uobject": "!=null",
            "ufile": "!=null",
            "f->f_op": "!= fd_type->fops",
            "uobject->ufile": "!= ufile"
        },
    }
},

{
    "kretprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain. A protection domain object provides an association between QPs, shared receive queues, address handles, memory regions, and memory windows. Every PD has a local_dma_lkey which can be used as the lkey value for local memory operations.",
        "proto" :"struct ib_pd* (*__ib_alloc_pd)(struct ib_device *device, unsigned int flags, const char *caller)",
        "pre": {
            "device": "!=null",
            "flags": "unsigned int",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:__ib_alloc_pd": {
        "description": "Allocates an unused protection domain. A protection domain object provides an association between QPs, shared receive queues, address handles, memory regions, and memory windows. Every PD has a local_dma_lkey which can be used as the lkey value for local memory operations.",
        "proto" :"struct ib_pd* (*__ib_alloc_pd)(struct ib_device *device, unsigned int flags, const char *caller)",
        "pre": {
            "device": "!=null",
            "flags": "unsigned int",
            "caller": "!=null"
        }
    }
},
{
    "kretprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain. It is an error to call this function while any resources in the pd still exist. The caller is responsible to synchronously destroy them and guarantee no new allocations will happen.",
        "proto" :"int (*ib_dealloc_pd_user)(struct ib_pd *pd, struct ib_udata *udata)",
        "pre": {
            "pd": "!=null && resources_in_pd == 0",
            "udata": "!=null || ==null"
        },
    }
},
{
    "kprobe:ib_dealloc_pd_user": {
        "description": "Deallocates a protection domain. It is an error to call this function while any resources in the pd still exist. The caller is responsible to synchronously destroy them and guarantee no new allocations will happen.",
        "proto" :"int (*ib_dealloc_pd_user)(struct ib_pd *pd, struct ib_udata *udata)",
        "pre": {
            "pd": "!=null && no resources exist",
            "udata": "valid user data or NULL for kernel object"
        },
    }
},
{
    "kretprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination. Contents of the destination pointer is assumed to be invalid and attribute are overwritten.",
        "proto" :"void (*rdma_copy_ah_attr)(struct rdma_ah_attr *dest, const struct rdma_ah_attr *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_ah_attr": {
        "description": "Copy rdma ah attribute from source to destination. Contents of the destination pointer is assumed to be invalid and attributes are overwritten.",
        "proto" :"void (*rdma_copy_ah_attr)(struct rdma_ah_attr *dest, const struct rdma_ah_attr *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        }
    }
},
{
    "kretprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new new one. rdma_replace_ah_attr() first releases any reference in the old ah_attr if old the ah_attr is valid; after that it copies the new attribute and holds the reference to the replaced ah_attr.",
        "proto" :"void (*rdma_replace_ah_attr)(struct rdma_ah_attr *old, const struct rdma_ah_attr *new)",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kprobe:rdma_replace_ah_attr": {
        "description": "Replace valid ah_attr with new one. First releases any reference in the old ah_attr if the ah_attr is valid; after that it copies the new attribute and holds the reference to the replaced ah_attr.",
        "proto" :"void (*rdma_replace_ah_attr)(struct rdma_ah_attr *old, const struct rdma_ah_attr *new)",
        "pre": {
            "old": "!=null",
            "new": "!=null"
        }
    }
},
{
    "kretprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination. It first releases any reference in the destination ah_attr if it is valid. This also transfers ownership of internal references from src to dest, making src invalid in the process. No new reference of the src ah_attr is taken.",
        "proto" :"void rdma_move_ah_attr(struct rdma_ah_attr *dest, struct rdma_ah_attr *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
        "post": {
            "dest": "!=null",
            "src": "invalid"
        }
    }
},
{
    "kprobe:rdma_move_ah_attr": {
        "description": "Move ah_attr pointed by source to destination. Releases any reference in the destination ah_attr if it is valid. Transfers ownership of internal references from src to dest, making src invalid in the process. No new reference of the src ah_attr is taken.",
        "proto" :"void rdma_move_ah_attr(struct rdma_ah_attr *dest, struct rdma_ah_attr *src)",
        "pre": {
            "dest": "!=null",
            "src": "!=null"
        },
    }
},
{
    "kretprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector. It returns 0 on success and returns appropriate error code on error. The address handle is used to reference a local or global destination in all UD QP post sends.",
        "proto" :"struct ib_ah *(*rdma_create_ah)(struct ib_pd *pd, struct rdma_ah_attr *ah_attr, u32 flags)",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "in [RDMA_CREATE_AH_SLEEPABLE, ...]" // Please replace ... with other possible flag values
        }
    }
},
{
    "kprobe:rdma_create_ah": {
        "description": "Creates an address handle for the given address vector. The address handle is used to reference a local or global destination in all UD QP post sends. It returns 0 on success and returns appropriate error code on error.",
        "proto" :"struct ib_ah *(*rdma_create_ah)(struct ib_pd *pd, struct rdma_ah_attr *ah_attr, u32 flags)",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "flags": "in [RDMA_CREATE_AH_SLEEPABLE, ...]", // Please replace ... with other possible flag values
        },
    }
},
{
    "kretprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector. It resolves destination mac address for ah attribute of RoCE type. The address handle is used to reference a local or global destination in all UD QP post sends. It returns 0 on success and returns appropriate error code on error.",
        "proto" :"struct ib_ah *(*rdma_create_user_ah)(struct ib_pd *pd, struct rdma_ah_attr *ah_attr, struct ib_udata *udata)",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:rdma_create_user_ah": {
        "description": "Creates an address handle for the given address vector. It resolves destination mac address for ah attribute of RoCE type. The address handle is used to reference a local or global destination in all UD QP post sends.",
        "proto" :"struct ib_ah *(*rdma_create_user_ah)(struct ib_pd *pd, struct rdma_ah_attr *ah_attr, struct ib_udata *udata)",
        "pre": {
            "pd": "!=null",
            "ah_attr": "!=null",
            "udata": "!=null"
        },
    }
},
{
    "kretprobe:ib_get_rdma_header_version": {
        "description": "If it's IPv6, the version must be 6, otherwise, the first 20 bytes (before the IPv4 header) are garbled.",
        "proto" :"static int (*ib_get_rdma_header_version)(const union rdma_network_hdr *hdr)",
        "pre": {
            "hdr": "!=null"
        },
        "post": {
            "return": "in [4, 6, 0]"
        }
    }
},
{
    "kprobe:ib_get_rdma_header_version": {
        "description": "If it's IPv6, the version must be 6, otherwise, the first 20 bytes (before the IPv4 header) are garbled.",
        "proto" :"static int (*ib_get_rdma_header_version)(const union rdma_network_hdr *hdr)",
        "pre": {
            "hdr": "!=null",
            "ip6h->version": "in [4, 6]",
            "ip4h->version": "in [4, 6]"
        },
        "post": {
            "return": "in [0, 4]"
        }
    }
},
{
    "kretprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference. The caller must ensure rdma_destroy_ah_attr() is called before destroying the rdma_ah_attr after calling this function.",
        "proto" :"void rdma_move_grh_sgid_attr(struct rdma_ah_attr *attr, union ib_gid *dgid, u32 flow_label, u8 hop_limit, u8 traffic_class, const struct ib_gid_attr *sgid_attr)",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "is u32",
            "hop_limit": "is u8",
            "traffic_class": "is u8",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_move_grh_sgid_attr": {
        "description": "Sets the sgid attribute of GRH, taking ownership of the reference. The caller must ensure rdma_destroy_ah_attr() is called before destroying the rdma_ah_attr after calling this function.",
        "proto" :"void (*rdma_move_grh_sgid_attr)(struct rdma_ah_attr *attr, union ib_gid *dgid, u32 flow_label, u8 hop_limit, u8 traffic_class, const struct ib_gid_attr *sgid_attr)",
        "pre": {
            "attr": "!=null",
            "dgid": "!=null",
            "flow_label": "in [0, 0xFFFFF]",
            "hop_limit": ">=0",
            "traffic_class": "in [0, 0xFF]",
            "sgid_attr": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain. If SRQ creation succeeds, then the attributes are updated to the actual capabilities of the created SRQ. srq_attr->max_wr and srq_attr->max_sge are read to determine the requested size of the SRQ, and set to the actual values allocated on return. If ib_create_srq() succeeds, then max_wr and max_sge will always be at least as large as the requested values.",
        "proto" :"struct ib_srq *(*ib_create_srq_user)(struct ib_pd *pd,  struct ib_srq_init_attr *srq_init_attr,  struct ib_usrq_object *uobject,  struct ib_udata *udata)",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_create_srq_user": {
        "description": "Creates a SRQ associated with the specified protection domain. If SRQ creation succeeds, then the attributes are updated to the actual capabilities of the created SRQ. srq_attr->max_wr and srq_attr->max_sge are read to determine the requested size of the SRQ, and set to the actual values allocated on return. If ib_create_srq() succeeds, then max_wr and max_sge will always be at least as large as the requested values.",
        "proto" :"struct ib_srq *(*ib_create_srq_user)(struct ib_pd *pd,  struct ib_srq_init_attr *srq_init_attr,  struct ib_usrq_object *uobject,  struct ib_udata *udata)",
        "pre": {
            "pd": "!=null",
            "srq_init_attr": "!=null",
            "uobject": "can be null",
            "udata": "can be null"
        },
    }
},
{
    "kretprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "proto" :"struct ib_qp *(*ib_create_qp_user)(struct ib_device *dev, struct ib_pd *pd, struct ib_qp_init_attr *attr, struct ib_udata *udata, struct ib_uqp_object *uobj, const char *caller)",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        }
    }
},
{
    "kprobe:ib_create_qp_user": {
        "description": "Creates a QP associated with the specified protection domain.",
        "proto" :"struct ib_qp *(*ib_create_qp_user)(struct ib_device *dev, struct ib_pd *pd, struct ib_qp_init_attr *attr, struct ib_udata *udata, struct ib_uqp_object *uobj, const char *caller)",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        },
    }
},
{
    "kretprobe:ib_create_qp_kernel": {
        "description": "If the callers is using the RDMA API calculate the resources needed for the RDMA READWRITE operations. Note that these callers need to pass in a port number.",
        "proto" :"ib_create_qp_kernel(struct ib_pd *pd, struct ib_qp_init_attr *qp_init_attr, const char *caller)",
        "pre": {
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "caller": "!=null"
        },
    }
},
{
    "kprobe:ib_create_qp_kernel": {
        "description": "If the callers is using the RDMA API calculate the resources needed for the RDMA READWRITE operations. Note that these callers need to pass in a port number.",
        "proto" :"ib_create_qp_kernel(struct ib_pd *pd, struct ib_qp_init_attr *qp_init_attr, const char *caller)",
        "pre": {
            "pd": "!=null",
            "qp_init_attr": "!=null",
            "caller": "!=null",
            "qp_init_attr->cap.max_rdma_ctxs": ">=0",
            "device": "!=null",
            "qp": "!=null"
        },
    }
},
{
    "kretprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP. @ib_qp: The QP to modify. @attr: On input, specifies the QP attributes to modify. On output, the current values of selected QP attributes are returned. @attr_mask: A bit-mask used to specify which attributes of the QP are being modified. @udata: pointer to user's input output buffer information are being modified. It returns 0 on success and returns appropriate error code on error.",
        "proto" :"int (*ib_modify_qp_with_udata)(struct ib_qp *ib_qp, struct ib_qp_attr *attr, int attr_mask, struct ib_udata *udata)",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": ">=0",
            "udata": "!=null"
        },
    }
},
{
    "kprobe:ib_modify_qp_with_udata": {
        "description": "Modifies the attributes for the specified QP. On input, specifies the QP attributes to modify. On output, the current values of selected QP attributes are returned. A bit-mask used to specify which attributes of the QP are being modified. Pointer to user's input output buffer information are being modified. It returns 0 on success and returns appropriate error code on error.",
        "proto" :"int (*ib_modify_qp_with_udata)(struct ib_qp *ib_qp, struct ib_qp_attr *attr, int attr_mask, struct ib_udata *udata)",
        "pre": {
            "ib_qp": "!=null",
            "attr": "!=null",
            "attr_mask": "is integer",
            "udata": "!=null"
        },
    }
},
{
    "kretprobe:create_qp": {
        "description": "Creates a QP associated with the specified protection domain.",
        "proto" :"static struct ib_qp (*create_qp)(struct ib_device *dev, struct ib_pd *pd, struct ib_qp_init_attr *attr, struct ib_udata *udata, struct ib_uqp_object *uobj, const char *caller)",
        "pre": {
            "dev": "!=null",
            "pd": "!=null",
            "attr": "!=null",
            "udata": "!=null",
            "uobj": "!=null",
            "caller": "!=null"
        },
    }
},
{
    "kprobe:create_qp": {
        "description": "Creates a QP associated with the specified protection domain.",
        "proto" :"static struct ib_qp create_qp(struct ib_device dev, struct ib_pd pd, struct ib_qp_init_attr attr, struct ib_udata udata, struct ib_uqp_object uobj, const char caller)",
        "pre": {
            "dev->ops.create_qp": "!=null",
            "qp": "!=null",
            "attr": "!=null"
        },
    }
},
{
    "kretprobe:ib_alloc_mr": {
        "description": "Allocates a memory region. The protection domain associated with the region is @pd. The memory region type is @mr_type. The maximum sg entries available for registration is @max_num_sg. Memory registration pagesg lists must not exceed max_num_sg. For mr_type IB_MR_TYPE_MEM_REG, the total length cannot exceed max_num_sg used_page_size.",
        "proto" :"struct ib_mr *(*ib_alloc_mr)(struct ib_pd *pd, enum ib_mr_type mr_type, u32 max_num_sg)",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, ...]", // replace ... with other possible enum values
            "max_num_sg": ">0"
        },
    }
},
{
    "kprobe:ib_alloc_mr": {
        "description": "Allocates a memory region. Memory registration pagesg lists must not exceed max_num_sg. For mr_type IB_MR_TYPE_MEM_REG, the total length cannot exceed max_num_sg used_page_size.",
        "proto" :"struct ib_mr *(*ib_alloc_mr)(struct ib_pd *pd, enum ib_mr_type mr_type, u32 max_num_sg)",
        "pre": {
            "pd": "!=null",
            "mr_type": "in [IB_MR_TYPE_MEM_REG, ...]",
            "max_num_sg": ">=0",
        },
    }
},
{
    "kretprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region. Memory registration pagesg lists must not exceed max_num_data_sg, also the integrity pagesg lists must not exceed max_num_meta_sg.",
        "proto" :"struct ib_mr *(*ib_alloc_mr_integrity)(struct ib_pd *pd, u32 max_num_data_sg, u32 max_num_meta_sg)",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        },
    }
},
{
    "kprobe:ib_alloc_mr_integrity": {
        "description": "Allocates an integrity memory region. Memory registration pagesg lists must not exceed max_num_data_sg, also the integrity pagesg lists must not exceed max_num_meta_sg.",
        "proto" :"struct ib_mr *(*ib_alloc_mr_integrity)(struct ib_pd *pd, u32 max_num_data_sg, u32 max_num_meta_sg)",
        "pre": {
            "pd": "!=null",
            "max_num_data_sg": ">=0",
            "max_num_meta_sg": ">=0"
        }
    }
},
{
    "kretprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain. @device: The device on which to allocate the XRC domain. @inode: inode to connect XRCD @udata: Valid user data or NULL for kernel object",
        "proto" :"struct ib_xrcd *(*ib_alloc_xrcd_user)(struct ib_device *device, struct inode *inode, struct ib_udata *udata)",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null || ==null",
        },
    }
},
{
    "kprobe:ib_alloc_xrcd_user": {
        "description": "Allocates an XRC domain. @device: The device on which to allocate the XRC domain. @inode: inode to connect XRCD @udata: Valid user data or NULL for kernel object",
        "proto" :"struct ib_xrcd *(*ib_alloc_xrcd_user)(struct ib_device *device, struct inode *inode, struct ib_udata *udata)",
        "pre": {
            "device": "!=null",
            "inode": "!=null",
            "udata": "!=null || ==null",
        },
    }
},
{
    "kretprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain. @xrcd: The XRC domain to deallocate. @udata: Valid user data or NULL for kernel object.",
        "proto" :"int (*ib_dealloc_xrcd_user)(struct ib_xrcd *xrcd, struct ib_udata *udata)",
        "pre": {
            "xrcd": "!=null",
            "udata": "!=null || ==null"
        },
    }
},
{
    "kprobe:ib_dealloc_xrcd_user": {
        "description": "Deallocates an XRC domain. @xrcd: The XRC domain to deallocate. @udata: Valid user data or NULL for kernel object.",
        "proto" :"int (*ib_dealloc_xrcd_user)(struct ib_xrcd *xrcd, struct ib_udata *udata)",
        "pre": {
            "xrcd": "!=null",
            "udata": "!=null || ==null",
        },
    }
},
{
    "kretprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain. If WQ creation succeeds, then the attributes are updated to the actual capabilities of the created WQ. wq_attr->max_wr and wq_attr->max_sge determine the requested size of the WQ, and set to the actual values allocated on return. If ib_create_wq() succeeds, then max_wr and max_sge will always be at least as large as the requested values.",
        "proto" :"struct ib_wq *(*ib_create_wq)(struct ib_pd *pd, struct ib_wq_init_attr *wq_attr)",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">= requested size",
            "wq_attr->max_sge": ">= requested size"
        },
    }
},
{
    "kprobe:ib_create_wq": {
        "description": "Creates a WQ associated with the specified protection domain. If WQ creation succeeds, then the attributes are updated to the actual capabilities of the created WQ. wq_attr->max_wr and wq_attr->max_sge determine the requested size of the WQ, and set to the actual values allocated on return. If ib_create_wq() succeeds, then max_wr and max_sge will always be at least as large as the requested values.",
        "proto" :"struct ib_wq *(*ib_create_wq)(struct ib_pd *pd, struct ib_wq_init_attr *wq_attr)",
        "pre": {
            "pd": "!=null",
            "wq_attr": "!=null",
            "wq_attr->max_wr": ">= requested value",
            "wq_attr->max_sge": ">= requested value"
        },
    }
},
{
    "kretprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ.",
        "proto" :"int (*ib_destroy_wq_user)(struct ib_wq *wq, struct ib_udata *udata)",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kprobe:ib_destroy_wq_user": {
        "description": "Destroys the specified user WQ. @wq: The WQ to destroy. @udata: Valid user data",
        "proto" :"int (*ib_destroy_wq_user)(struct ib_wq *wq, struct ib_udata *udata)",
        "pre": {
            "wq": "!=null",
            "udata": "!=null"
        }
    }
},
{
    "kretprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "proto" :"int (*ib_map_mr_sg_pi)(struct ib_mr *mr, struct scatterlist *data_sg, int data_sg_nents, unsigned int *data_sg_offset, struct scatterlist *meta_sg, int meta_sg_nents, unsigned int *meta_sg_offset, unsigned int page_size)",
        "pre": {
            "mr": "!=null && type == IB_MR_TYPE_INTEGRITY",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": ">=0",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": ">=0",
            "page_size": ">0",
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:ib_map_mr_sg_pi": {
        "description": "Map the dma mapped SG lists for PI (protection information) and set an appropriate memory region for registration.",
        "proto" :"int (*ib_map_mr_sg_pi)(struct ib_mr *mr, struct scatterlist *data_sg, int data_sg_nents, unsigned int *data_sg_offset, struct scatterlist *meta_sg, int meta_sg_nents, unsigned int *meta_sg_offset, unsigned int page_size)",
        "pre": {
            "mr": "!=null && type == IB_MR_TYPE_INTEGRITY",
            "data_sg": "!=null",
            "data_sg_nents": ">=0",
            "data_sg_offset": ">=0",
            "meta_sg": "!=null",
            "meta_sg_nents": ">=0",
            "meta_sg_offset": ">=0",
            "page_size": ">0",
        },
    }
},
{
    "kretprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector. The sg list prefix converted is the prefix that meet the requirements of ib_map_mr_sg. Returns the number of sg elements that were assigned to a page vector.",
        "proto" :"int (*ib_sg_to_pages)(struct ib_mr *mr, struct scatterlist *sgl, int sg_nents, unsigned int *sg_offset_p, int (*set_page)(struct ib_mr *, u64))",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kprobe:ib_sg_to_pages": {
        "description": "Convert the largest prefix of a sg list to a page vector. Core service helper for drivers to convert the largest prefix of given sg list to a page vector. The sg list prefix converted is the prefix that meet the requirements of ib_map_mr_sg. Returns the number of sg elements that were assigned to a page vector.",
        "proto" :"int (*ib_sg_to_pages)(struct ib_mr *mr, struct scatterlist *sgl, int sg_nents, unsigned int *sg_offset_p, int (*set_page)(struct ib_mr *, u64))",
        "pre": {
            "mr": "!=null",
            "sgl": "!=null",
            "sg_nents": ">=0",
            "sg_offset_p": "!=null",
            "set_page": "!=null"
        }
    }
},
{
    "kretprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "proto" :"static void (__ib_drain_rq)(struct ib_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:__ib_drain_rq": {
        "description": "Post a WR and block until its completion is reaped for the RQ.",
        "proto" :"static void __ib_drain_rq(struct ib_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kretprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application. If the device has a provider-specific drain function, then call that. Otherwise call the generic drain function __ib_drain_sq(). The caller must ensure there is room in the CQ and SQ for the drain work request and completion, allocate the CQ using ib_alloc_cq(), and ensure that there are no other contexts that are posting WRs concurrently. Otherwise the drain is not guaranteed.",
        "proto" :"void (*ib_drain_sq)(struct ib_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:ib_drain_sq": {
        "description": "Block until all SQ CQEs have been consumed by the application.",
        "proto": "void ib_drain_sq(struct ib_qp *qp)",
        "pre": {
            "qp": "!=null",
            "qp->recv_cq": "!=null",
            "qp->recv_cq->poll_ctx": "in [IB_POLL_DIRECT, other_contexts]",
            "room_in_CQ_and_SQ_for_drain_WR_and_completion": "true",
            "CQ_allocated_using_ib_alloc_cq": "true",
            "no_other_contexts_posting_WRs_concurrently": "true"
        }
    }
},
{
    "kretprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "proto" :"static void __ib_drain_sq(struct ib_qp *qp)",
        "pre": {
            "qp": "!=null"
        }
    }
},
{
    "kprobe:__ib_drain_sq": {
        "description": "Post a WR and block until its completion is reaped for the SQ.",
        "proto" :"static void (__ib_drain_sq)(struct ib_qp *qp)",
        "pre": {
            "qp": "your_condition_here"
        }
    }
},
{
    "kretprobe:__rdma_block_iter_start": {
        "description": "Driver provides best block size to use.",
        "proto" :"void __rdma_block_iter_start(struct ib_block_iter *biter, struct scatterlist *sglist, unsigned int nents, unsigned long pgsz)",
        "pre": {
            "biter": "!=null",
            "sglist": "!=null",
            "nents": "is a positive integer",
            "pgsz": "is a positive integer"
        }
    }
},
{
    "kprobe:__rdma_block_iter_start": {
        "description": "Driver provides best block size to use",
        "proto" :"void __rdma_block_iter_start(struct ib_block_iter *biter, struct scatterlist *sglist, unsigned int nents, unsigned long pgsz)",
        "pre": {
            "biter": "!=null",
            "sglist": "!=null",
            "nents": ">=0",
            "pgsz": ">0",
        },
    }
},
{
    "kretprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers. @descs: array of static descriptors @num_counters: number of elements in array @lifespan: milliseconds between updates",
        "proto" :"struct rdma_hw_stats *(*rdma_alloc_hw_stats_struct)(const struct rdma_stat_desc *descs, int num_counters, unsigned long lifespan)",
        "pre": {
            "descs": "!=null",
            "num_counters": ">=0",
            "lifespan": ">=0"
        },
    }
},
{
    "kprobe:rdma_alloc_hw_stats_struct": {
        "description": "Helper function to allocate dynamic struct for the drivers. @descs: array of static descriptors @num_counters: number of elements in array @lifespan: milliseconds between updates",
        "proto" :"struct rdma_hw_stats *(*rdma_alloc_hw_stats_struct)(const struct rdma_stat_desc *descs, int num_counters, unsigned long lifespan)",
        "pre": {
            "descs": "!=null",
            "num_counters": ">0",
            "lifespan": ">=0",
        },
    }
},
{
    "kretprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats @stats: statistics to release",
        "proto" :"void (*rdma_free_hw_stats_struct)(struct rdma_hw_stats *stats)",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kprobe:rdma_free_hw_stats_struct": {
        "description": "Helper function to release rdma_hw_stats",
        "proto" :"void (*rdma_free_hw_stats_struct)(struct rdma_hw_stats *stats)",
        "pre": {
            "stats": "!=null"
        }
    }
},
{
    "kretprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port. Do not use. Only for legacy sysfs compatibility.",
        "proto" :"int (*ib_port_register_client_groups)(struct ib_device *ibdev, u32 port_num, const struct attribute_group **groups)",
        "pre": {
            "ibdev": "!=null",
            "port_num": "is a valid port number",
            "groups": "!=null"
        },
    }
},
{
    "kprobe:ib_port_register_client_groups": {
        "description": "Add an ib_client's attributes to the port. Do not use. Only for legacy sysfs compatibility.",
        "proto" :"int (*ib_port_register_client_groups)(struct ib_device *ibdev, u32 port_num, const struct attribute_group **groups)",
        "pre": {
            "ibdev": "!=null",
            "port_num": "is valid port number",
            "groups": "!=null",
        },
    }
},
{
    "kretprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure. @payload_bytes:Length of packet payload. @lrh_present: specify if LRH is present. @eth_present: specify if Eth header is present. @vlan_present: packet is tagged vlan. @grh_present: GRH flag (if non-zero, GRH will be included). @ip_version: if non-zero, IP header, V4 or V6, will be included. @udp_present :if non-zero, UDP header will be included. @immediate_present: specify if immediate data is present. @header:Structure to initialize.",
        "proto" :"int ib_ud_header_init(int payload_bytes, int lrh_present, int eth_present, int vlan_present, int grh_present, int ip_version, int udp_present, int immediate_present, struct ib_ud_header *header)",
        "pre": {
            "payload_bytes": ">=0",
            "lrh_present": "in [0, 1]",
            "eth_present": "in [0, 1]",
            "vlan_present": "in [0, 1]",
            "grh_present": "in [0, 1]",
            "ip_version": "in [0, 4, 6]",
            "udp_present": "in [0, 1]",
            "immediate_present": "in [0, 1]",
            "header": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_init": {
        "description": "Initialize UD header structure. @payload_bytes:Length of packet payload. @lrh_present: specify if LRH is present. @eth_present: specify if Eth header is present. @vlan_present: packet is tagged vlan. @grh_present: GRH flag (if non-zero, GRH will be included). @ip_version: if non-zero, IP header, V4 or V6, will be included. @udp_present :if non-zero, UDP header will be included. @immediate_present: specify if immediate data is present. @header:Structure to initialize.",
        "proto" :"int ib_ud_header_init(int payload_bytes, int lrh_present, int eth_present, int vlan_present, int grh_present, int ip_version, int udp_present, int immediate_present, struct ib_ud_header *header)",
        "pre": {
            "payload_bytes": ">=0",
            "lrh_present": "in [0, 1]",
            "eth_present": "in [0, 1]",
            "vlan_present": "in [0, 1]",
            "grh_present": "in [0, 1]",
            "ip_version": "in [0, 4, 6]",
            "udp_present": "in [0, 1]",
            "immediate_present": "in [0, 1]",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_pack": {
        "description": "Packs the UD header structure @header into wire format in the buffer @buf.",
        "proto" :"int (*ib_ud_header_pack)(struct ib_ud_header *header, void *buf)",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_pack": {
        "description": "Packs the UD header structure @header into wire format in the buffer @buf.",
        "proto" :"int (*ib_ud_header_pack)(struct ib_ud_header *header, void *buf)",
        "pre": {
            "header": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_ud_header_unpack": {
        "description": "Unpacks the UD header structure @header from wire format in the buffer @buf.",
        "proto" :"int (*ib_ud_header_unpack)(void *buf, struct ib_ud_header *header)",
        "pre": {
            "buf": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kprobe:ib_ud_header_unpack": {
        "description": "Unpack UD header struct from wire format. ib_ud_header_pack() unpacks the UD header structure @header from wire format in the buffer @buf.",
        "proto" :"int (*ib_ud_header_unpack)(void *buf, struct ib_ud_header *header)",
        "pre": {
            "buf": "!=null",
            "header": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR. This helper is intended for HW that support multiple page sizes but can do only a single page size in an MR. Returns 0 if the umem requires page sizes not supported by the driver to be mapped. Drivers always supporting PAGE_SIZE or smaller will never see a 0 result.",
        "proto" :"unsigned long (*ib_umem_find_best_pgsz)(struct ib_umem *umem, unsigned long pgsz_bitmap, unsigned long virt)",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": ">=0",
            "virt": ">=0"
        },
    }
},
{
    "kprobe:ib_umem_find_best_pgsz": {
        "description": "Find best HW page size to use for this MR. This helper is intended for HW that support multiple page sizes but can do only a single page size in an MR. Returns 0 if the umem requires page sizes not supported by the driver to be mapped. Drivers always supporting PAGE_SIZE or smaller will never see a 0 result.",
        "proto" :"unsigned long (*ib_umem_find_best_pgsz)(struct ib_umem *umem, unsigned long pgsz_bitmap, unsigned long virt)",
        "pre": {
            "umem": "!=null",
            "pgsz_bitmap": ">=0",
            "virt": ">=0"
        }
    }
},
{
    "kretprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory. @device: IB device to connect UMEM @addr: userspace virtual address to start at @size: length of region to pin @access: IB_ACCESS_xxx flags for memory being pinned",
        "proto" :"struct ib_umem *(*ib_umem_get)(struct ib_device *device, unsigned long addr, size_t size, int access)",
        "pre": {
            "device": "!=null",
            "addr": ">=0",
            "size": ">0",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC, IB_ACCESS_MW_BIND, IB_ZERO_BASED, IB_ACCESS_ON_DEMAND, IB_ACCESS_HUGETLB]"
        },
    }
},
{
    "kprobe:ib_umem_get": {
        "description": "Pin and DMA map userspace memory.",
        "proto" :"struct ib_umem *(*ib_umem_get)(struct ib_device *device, unsigned long addr, size_t size, int access)",
        "pre": {
            "device": "!=null",
            "addr": ">=0",
            "size": ">0",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC, IB_ACCESS_MW_BIND, IB_ZERO_BASED, IB_ACCESS_ON_DEMAND, IB_ACCESS_PHYS_MR, IB_ACCESS_HUGETLB]"
        },
    }
},
{
    "kretprobe:iwcm_reject_msg": {
        "description": "iWARP uses negative errnos",
        "proto" :"static long (*iwcm_reject_msg)(int reason)",
        "pre": {
            "reason": "<=0",
        },
    }
},
{
    "kprobe:iwcm_reject_msg": {
        "description": "iWARP uses negative errnos",
        "proto" :"int iwcm_reject_msg(int reason)",
        "pre": {
            "reason": "in [0, ARRAY_SIZE(iwcm_rej_reason_strs)-1]",
            "iwcm_rej_reason_strs[reason]": "!=null",
        },
    }
},
{
    "kretprobe:iw_cm_disconnect": {
        "description": "Wait if we're currently in a connect or accept downcall",
        "proto" :"static int (*iw_cm_disconnect)(struct iw_cm_id cm_id, int abrupt)",
        "pre": {
            "cm_id": "!=null",
            "abrupt": "is an integer"
        }
    }
},
{
    "kprobe:iw_cm_disconnect": {
        "description": "Disconnects the iw_cm_id. Waits if we're currently in a connect or accept downcall.",
        "proto" :"static int (*iw_cm_disconnect)(struct iw_cm_id cm_id, int abrupt)",
        "pre": {
            "cm_id": "!=null",
            "abrupt": "is an integer"
        }
    }
},
{
    "kretprobe:iw_get_qp": {
        "description": "Get the ib_qp given the QPN",
        "proto": "struct ib_qp *(*iw_get_qp)(struct ib_device *device, int qpn)",
        "pre": {
            "device": "!=null",
            "qpn": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:iw_cm_connect": {
        "description": "Get the ib_qp given the QPN",
        "proto" :"struct iw_cm_connect(struct iw_cm_id  cm_id, struct iw_cm_conn_param  iw_param)",
        "pre": {
            "cm_id": "!=null",
            "iw_param": "!=null",
            "cm_id->device": "!=null",
            "cm_id->device->ops": "!=null",
            "cm_id->device->ops.iw_get_qp": "!=null",
            "iw_param->qpn": "!=null",
            "qp": "==null"
        },
    }
},
{
    "kretprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context. Returns the number of WQEs that will be needed on the workqueue if successful, or a negative error code.",
        "proto": "int rdma_rw_ctx_init(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, u32 sg_offset, u64 remote_addr, u32 rkey, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "sg_offset": ">=0",
            "remote_addr": ">=0",
            "rkey": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_init": {
        "description": "Initialize a RDMA READWRITE context. Returns the number of WQEs that will be needed on the workqueue if successful, or a negative error code.",
        "proto" :"int (*rdma_rw_ctx_init)(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, u32 sg_offset, u64 remote_addr, u32 rkey, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "sg_offset": ">=0",
            "remote_addr": ">=0",
            "rkey": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]",
        },
    }
},
{
    "kretprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload. Returns the number of WQEs that will be needed on the workqueue if successful, or a negative error code.",
        "proto" :"int rdma_rw_ctx_signature_init(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, struct scatterlist *prot_sg, u32 prot_sg_cnt, struct ib_sig_attrs *sig_attrs, u64 remote_addr, u32 rkey, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": ">=0",
            "rkey": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_signature_init": {
        "description": "Initialize a RW context with signature offload. Returns the number of WQEs that will be needed on the workqueue if successful, or a negative error code.",
        "proto" :"int (*rdma_rw_ctx_signature_init)(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, struct scatterlist *prot_sg, u32 prot_sg_cnt, struct ib_sig_attrs *sig_attrs, u64 remote_addr, u32 rkey, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "sig_attrs": "!=null",
            "remote_addr": ">=0",
            "rkey": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_wrs": {
        "description": "Return the WR chain for the set of RDMA READWRITE operations described by @ctx, as well as any memory registration operations needed. If @chain_wr is non-NULL the WR it points to will be appended to the chain of WRs posted. If @chain_wr is not set @cqe must be set so that the caller gets a completion notification.",
        "proto" :"struct ib_send_wr *(*rdma_rw_ctx_wrs)(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct ib_cqe *cqe, struct ib_send_wr *chain_wr)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "is a valid port number",
            "cqe": "!=null if chain_wr == null",
            "chain_wr": "!=null or cqe != null"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_wrs": {
        "description": "Return the WR chain for the set of RDMA READWRITE operations described by @ctx, as well as any memory registration operations needed. If @chain_wr is non-NULL the WR it points to will be appended to the chain of WRs posted. If @chain_wr is not set @cqe must be set so that the caller gets a completion notification.",
        "proto" :"struct ib_send_wr *(*rdma_rw_ctx_wrs)(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct ib_cqe *cqe, struct ib_send_wr *chain_wr)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "is a valid port number",
            "cqe": "!=null if chain_wr == null",
            "chain_wr": "!=null or cqe != null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_post": {
        "description": "Post the set of RDMA READWRITE operations described by @ctx, as well as any memory registration operations needed. If @chain_wr is non-NULL the WR it points to will be appended to the chain of WRs posted. If @chain_wr is not set @cqe must be set so that the caller gets a completion notification.",
        "proto" :"int rdma_rw_ctx_post(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct ib_cqe *cqe, struct ib_send_wr *chain_wr)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "is a valid port number",
            "cqe": "!=null if chain_wr == null",
            "chain_wr": "!=null or cqe != null"
        },
    }
},
{
    "kprobe:rdma_rw_ctx_post": {
        "description": "Post a RDMA READ or RDMA WRITE operation. Post the set of RDMA READWRITE operations described by @ctx, as well as any memory registration operations needed. If @chain_wr is non-NULL the WR it points to will be appended to the chain of WRs posted. If @chain_wr is not set @cqe must be set so that the caller gets a completion notification.",
        "proto" :"int rdma_rw_ctx_post(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct ib_cqe *cqe, struct ib_send_wr *chain_wr)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": "is a valid port number",
            "cqe": "!=null if chain_wr is null",
            "chain_wr": "!=null or cqe !=null"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init. @ctx:context to release. @qp:queue pair to operate on. @port_num:port num to which the connection is bound. @sg:scatterlist that was used for the READWRITE. @sg_cnt:number of entries in @sg. @dir:%DMA_TO_DEVICE for RDMA WRITE, %DMA_FROM_DEVICE for RDMA READ.",
        "proto" :"void (*rdma_rw_ctx_destroy)(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy": {
        "description": "Release all resources allocated by rdma_rw_ctx_init",
        "proto": "void rdma_rw_ctx_destroy(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init. @ctx:context to release. @qp:queue pair to operate on. @port_num:port num to which the connection is bound. @sg:scatterlist that was used for the READWRITE. @sg_cnt:number of entries in @sg. @prot_sg:scatterlist that was used for the READWRITE of the PI. @prot_sg_cnt: number of entries in @prot_sg. @dir:%DMA_TO_DEVICE for RDMA WRITE, %DMA_FROM_DEVICE for RDMA READ.",
        "proto" :"void rdma_rw_ctx_destroy_signature(struct rdma_rw_ctx *ctx, struct ib_qp *qp,u32 port_num, struct scatterlist *sg, u32 sg_cnt,struct scatterlist *prot_sg, u32 prot_sg_cnt,enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kprobe:rdma_rw_ctx_destroy_signature": {
        "description": "Release all resources allocated by rdma_rw_ctx_signature_init",
        "proto": "void rdma_rw_ctx_destroy_signature(struct rdma_rw_ctx *ctx, struct ib_qp *qp, u32 port_num, struct scatterlist *sg, u32 sg_cnt, struct scatterlist *prot_sg, u32 prot_sg_cnt, enum dma_data_direction dir)",
        "pre": {
            "ctx": "!=null",
            "qp": "!=null",
            "port_num": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0",
            "prot_sg": "!=null",
            "prot_sg_cnt": ">=0",
            "dir": "in [%DMA_TO_DEVICE, %DMA_FROM_DEVICE]"
        }
    }
},
{
    "kretprobe:rdma_rw_mr_factor": {
        "description": "Returns the number of MRs the device requires to move @maxpayload bytes. The returned value is used during transport creation to compute max_rdma_ctxts and the size of the transport's Send and Send Completion Queues.",
        "proto" :"unsigned int (*rdma_rw_mr_factor)(struct ib_device *device, u32 port_num, unsigned int maxpages)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1 && <=65535",
            "maxpages": ">=1"
        }
    }
},
{
    "kprobe:rdma_rw_mr_factor": {
        "description": "Returns the number of MRs the device requires to move @maxpayload bytes. The returned value is used during transport creation to compute max_rdma_ctxts and the size of the transport's Send and Send Completion Queues.",
        "proto" :"unsigned int (*rdma_rw_mr_factor)(struct ib_device *device, u32 port_num, unsigned int maxpages)",
        "pre": {
            "device": "!=null",
            "port_num": "!=null",
            "maxpages": "!=null"
        },
    }
},
{
    "kretprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not. When the rdma device is in shared mode, it ignores the net namespace. When the rdma device is exclusive to a net namespace, rdma device net namespace is checked against the specified one.",
        "proto" :"bool (*rdma_dev_access_netns)(const struct ib_device *dev, const struct net *net)",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        },
    }
},
{
    "kprobe:rdma_dev_access_netns": {
        "description": "Return whether an rdma device can be accessed from a specified net namespace or not. When the rdma device is in shared mode, it ignores the net namespace. When the rdma device is exclusive to a net namespace, rdma device net namespace is checked against the specified one.",
        "proto" :"bool (*rdma_dev_access_netns)(const struct ib_device *dev, const struct net *net)",
        "pre": {
            "dev": "!=null",
            "net": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_index": {
        "description": "ib_device_put() to return the device reference count when ib_device_get_by_index() returns valid device pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_index)(const struct net *net, u32 index)",
        "pre": {
            "net": "!=null",
            "index": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ib_device_get_by_index": {
        "description": "Returns a valid device pointer. The device reference count is returned when ib_device_get_by_index() returns valid device pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_index)(const struct net *net, u32 index)",
        "pre": {
            "net": "!=null",
            "index": "is a valid index"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:ib_device_get_by_name": {
        "description": "Find and hold an ib_device by its name. The caller must call ib_device_put() on the returned pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_name)(const char *name, enum rdma_driver_id driver_id)",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, RDMA_DRIVER_MLX5, RDMA_DRIVER_MLX4, RDMA_DRIVER_CXGB4, RDMA_DRIVER_EFA, RDMA_DRIVER_I40IW, RDMA_DRIVER_IW_CXGB4, RDMA_DRIVER_MTHCA, RDMA_DRIVER_NES, RDMA_DRIVER_OCRDMA, RDMA_DRIVER_QEDR, RDMA_DRIVER_QIB, RDMA_DRIVER_RNIC, RDMA_DRIVER_SIW, RDMA_DRIVER_USNIC, RDMA_DRIVER_VMW_PVRDMA, RDMA_DRIVER_HNS, RDMA_DRIVER_RXE, RDMA_DRIVER_BNXT_RE, RDMA_DRIVER_HFI1, RDMA_DRIVER_QLCNIC, RDMA_DRIVER_VMWARE_PVRDMA, RDMA_DRIVER_USIW]"
        }
    }
},
{
    "kprobe:ib_device_get_by_name": {
        "description": "Find and hold an ib_device by its name. The caller must call ib_device_put() on the returned pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_name)(const char *name, enum rdma_driver_id driver_id)",
        "pre": {
            "name": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, RDMA_DRIVER_MLX5, RDMA_DRIVER_CXGB4, RDMA_DRIVER_EFA, RDMA_DRIVER_I40IW, RDMA_DRIVER_MLX4, RDMA_DRIVER_BNXT_RE, RDMA_DRIVER_HNS, RDMA_DRIVER_RXE, RDMA_DRIVER_QEDR, RDMA_DRIVER_VMWARE_PVRDMA, RDMA_DRIVER_USNIC, RDMA_DRIVER_HFI1, RDMA_DRIVER_OCRDMA, RDMA_DRIVER_NES, RDMA_DRIVER_RNIC, RDMA_DRIVER_SIW, RDMA_DRIVER_CXGB3, RDMA_DRIVER_IW_CXGB3, RDMA_DRIVER_IW_NES, RDMA_DRIVER_IW_SIW]"
        },
    }
},
{
    "kretprobe:_ib_alloc_device": {
        "description": "Allocates structures that must be freed with ib_dealloc_device().",
        "proto" :"struct ib_device *(*_ib_alloc_device)(size_t size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:_ib_alloc_device": {
        "description": "Allocates structures with ib_alloc_device(). ib_dealloc_device() must be used to free these structures.",
        "proto" :"struct ib_device *(*ib_alloc_device)(size_t size)",
        "pre": {
            "size": ">=0",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data. @dev: IB device. @port: port number whose immutable data to read. It starts with index 1 and valid upto including rdma_end_port().",
        "proto" :"const struct ib_port_immutable* (*ib_port_immutable_read)(struct ib_device *dev, unsigned int port)",
        "pre": {
            "dev": "!=null",
            "port": ">=1 && <=rdma_end_port()"
        }
    }
},
{
    "kprobe:ib_port_immutable_read": {
        "description": "Read rdma port's immutable data. @dev: IB device. @port: port number whose immutable data to read. It starts with index 1 and valid upto including rdma_end_port().",
        "proto" :"const struct ib_port_immutable* (*ib_port_immutable_read)(struct ib_device *dev, unsigned int port)",
        "pre": {
            "dev": "!=null",
            "port": ">=1 && <=rdma_end_port()"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex associated with the device's compat_devs_mutex. If the mutex is already locked, the function will wait until it is unlocked.",
        "proto": "void mutex_lock(struct mutex *lock);",
        "pre": {
            "lock": "!=null"
        }
    },
    "kretprobe:xa_load": {
        "description": "Loads the value associated with the given index in the xarray. If the index is not present in the xarray, it returns NULL.",
        "proto": "void *xa_load(struct xarray *xa, unsigned long index);",
        "pre": {
            "xa": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kprobe:mutex_lock_and_load": {
        "description": "Locks the compat_devs_mutex and loads the device. If the device is already registered, it waits for completion.",
        "proto" :"static long (*mutex_lock_and_load)(struct mutex *device_mutex, struct xa *device_xa, int id)",
        "pre": {
            "device_mutex": "!=null",
            "device_xa": "!=null",
            "id": ">=0",
        },
    }
},


{
    "kretprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'. This is the same as ib_unregister_device(), except it includes an internal ib_device_put() that should match a 'get' obtained by the caller. It is safe to call this routine concurrently from multiple threads while holding the 'get'. When the function returns the device is fully unregistered. Drivers using this flow MUST use the driver_unregister callback to clean up their resources associated with the device and dealloc it.",
        "proto" :"void (*ib_unregister_device_and_put)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_and_put": {
        "description": "Unregister a device while holding a 'get'. This is the same as ib_unregister_device(), except it includes an internal ib_device_put() that should match a 'get' obtained by the caller. It is safe to call this routine concurrently from multiple threads while holding the 'get'. When the function returns the device is fully unregistered. Drivers using this flow MUST use the driver_unregister callback to clean up their resources associated with the device and dealloc it.",
        "proto" :"void (*ib_unregister_device_and_put)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},


{
    "kretprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue. This schedules an asynchronous unregistration using a WQ for the device. A driver should use this to avoid holding locks while doing unregistration, such as holding the RTNL lock. Drivers using this API must use ib_unregister_driver before module unload to ensure that all scheduled unregistrations have completed.",
        "proto" :"void (*ib_unregister_device_queued)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_device_queued": {
        "description": "Unregister a device using a work queue. This schedules an asynchronous unregistration using a WQ for the device. A driver should use this to avoid holding locks while doing unregistration, such as holding the RTNL lock. Drivers using this API must use ib_unregister_driver before module unload to ensure that all scheduled unregistrations have completed.",
        "proto" :"void (*ib_unregister_device_queued)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_client": {
        "description": "Register an IB client. When an IB device is added, each registered client's add method will be called (in the order the clients were registered), and when a device is removed, each client's remove method will be called (in the reverse order that clients were registered). In addition, when ib_register_client() is called, the client will receive an add callback for all devices already registered.",
        "proto" :"int ib_register_client(struct ib_client *client)",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_register_client": {
        "description": "Register an IB client. Upper level users of the IB drivers can use ib_register_client() to register callbacks for IB device addition and removal. When an IB device is added, each registered client's add method will be called (in the order the clients were registered), and when a device is removed, each client's remove method will be called (in the reverse order that clients were registered). In addition, when ib_register_client() is called, the client will receive an add callback for all devices already registered.",
        "proto" :"int (*ib_register_client)(struct ib_client *client)",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_client": {
        "description": "Unregister an IB client. Once it returns no client callbacks will be called, or are running in another thread.",
        "proto" :"void (*ib_unregister_client)(struct ib_client *client)",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_client": {
        "description": "Unregister an IB client. Once it returns, no client callbacks will be called, or are running in another thread.",
        "proto" :"void (*ib_unregister_client)(struct ib_client *client)",
        "pre": {
            "client": "!=null"
        }
    }
},
{
    "kretprobe:ib_set_client_data": {
        "description": "ib_set_client_data() sets client context data that can be retrieved with ib_get_client_data(). This can only be called while the client is registered to the device, once the ib_client remove() callback returns this cannot be called.",
        "proto" :"void (*ib_set_client_data)(struct ib_device *device, struct ib_client *client, void *data)",
        "pre": {
            "device": "!=null",
            "client": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:ib_set_client_data": {
        "description": "Sets client context data that can be retrieved with ib_get_client_data(). This can only be called while the client is registered to the device, once the ib_client remove() callback returns this cannot be called.",
        "proto" :"void (*ib_set_client_data)(struct ib_device *device, struct ib_client *client, void *data)",
        "pre": {
            "device": "!=null",
            "client": "!=null && registered",
            "data": "!=null",
        },
    }
},
{
    "kretprobe:ib_register_event_handler": {
        "description": "Register an IB event handler that will be called back when asynchronous IB events occur (as defined in chapter 11 of the InfiniBand Architecture Specification). This callback occurs in workqueue context.",
        "proto" :"void (*ib_register_event_handler)(struct ib_event_handler *event_handler)",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_register_event_handler": {
        "description": "Register an IB event handler. This callback occurs in workqueue context.",
        "proto" :"static void (*ib_register_event_handler)(struct ib_event_handler *event_handler)",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler registered with ib_register_event_handler().",
        "proto" :"void (*ib_unregister_event_handler)(struct ib_event_handler *event_handler)",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_event_handler": {
        "description": "Unregister an event handler registered with ib_register_event_handler().",
        "proto" :"void (*ib_unregister_event_handler)(struct ib_event_handler *event_handler)",
        "pre": {
            "event_handler": "!=null"
        }
    }
},
{
    "kretprobe:ib_query_port": {
        "description": "ib_query_port() returns the attributes of a port through the @port_attr pointer.",
        "proto" :"int ib_query_port(struct ib_device *device,  u32 port_num,  struct ib_port_attr *port_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "port_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_query_port": {
        "description": "Query IB port attributes. Returns the attributes of a port through the @port_attr pointer.",
        "proto" :"int (*ib_query_port)(struct ib_device *device, u32 port_num, struct ib_port_attr *port_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "port_attr": "!=null"
        },
    }
},
{
    "kretprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device. Drivers should use this to link the ib_device to a netdev so the netdev shows up in interfaces like ib_enum_roce_netdev. Only one netdev may be affiliated with any port. The caller must ensure that the given ndev is not unregistered or unregistering, and that either the ib_device is unregistered or ib_device_set_netdev() is called with NULL when the ndev sends a NETDEV_UNREGISTER event.",
        "proto" :"int (*ib_device_set_netdev)(struct ib_device *ib_dev, struct net_device *ndev, u32 port)",
        "pre": {
            "ib_dev": "!=null",
            "ndev": "!=null || ==null",
            "port": "is valid port number"
        },
    }
},
{
    "kprobe:ib_device_set_netdev": {
        "description": "Associate the ib_dev with an underlying net_device. Only one netdev may be affiliated with any port. The caller must ensure that the given ndev is not unregistered or unregistering, and that either the ib_device is unregistered or ib_device_set_netdev() is called with NULL when the ndev sends a NETDEV_UNREGISTER event.",
        "proto" :"int (*ib_device_set_netdev)(struct ib_device *ib_dev, struct net_device *ndev, u32 port)",
        "pre": {
            "ib_dev": "!=unregistered",
            "ndev": "!=unregistered && !=unregistering",
            "port": "any u32 value"
        },
    }
},
{
    "kretprobe:ib_device_get_by_netdev": {
        "description": "Find and hold an ib_device that is associated with a netdev via ib_device_set_netdev(). The caller must call ib_device_put() on the returned pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_netdev)(struct net_device *ndev, enum rdma_driver_id driver_id)",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, RDMA_DRIVER_RDMA_CM, RDMA_DRIVER_IWARP, RDMA_DRIVER_RXE, RDMA_DRIVER_USNIC, RDMA_DRIVER_HNS, RDMA_DRIVER_MLX5, RDMA_DRIVER_BNXT_RE, RDMA_DRIVER_SIW, RDMA_DRIVER_ICE, RDMA_DRIVER_EFA, RDMA_DRIVER_VMWARE_PVRDMA, RDMA_DRIVER_HFI1, RDMA_DRIVER_QEDR, RDMA_DRIVER_CXGB4, RDMA_DRIVER_NES, RDMA_DRIVER_OCRDMA, RDMA_DRIVER_BNAD, RDMA_DRIVER_I40IW, RDMA_DRIVER_MTHCA, RDMA_DRIVER_AML, RDMA_DRIVER_CXGB3, RDMA_DRIVER_MVPP2, RDMA_DRIVER_EDMA, RDMA_DRIVER_BE2NET, RDMA_DRIVER_NTB, RDMA_DRIVER_VMW_PVRDMA, RDMA_DRIVER_QIB, RDMA_DRIVER_QLCNIC, RDMA_DRIVER_SMC, RDMA_DRIVER_SOFT_ROCE, RDMA_DRIVER_BNXT_RE_VF, RDMA_DRIVER_MLX4, RDMA_DRIVER_MLX5_VF, RDMA_DRIVER_MLX5_USER, RDMA_DRIVER_MLX5_CORE, RDMA_DRIVER_MLX5_ACCEL, RDMA_DRIVER_MLX5_FPGA, RDMA_DRIVER_MLX5_IB]"
        },
    }
},
{
    "kprobe:ib_device_get_by_netdev": {
        "description": "Find and hold an ib_device that is associated with a netdev via ib_device_set_netdev(). The caller must call ib_device_put() on the returned pointer.",
        "proto" :"struct ib_device *(*ib_device_get_by_netdev)(struct net_device *ndev, enum rdma_driver_id driver_id)",
        "pre": {
            "ndev": "!=null",
            "driver_id": "in [RDMA_DRIVER_UNKNOWN, RDMA_DRIVER_RDMA_CM, RDMA_DRIVER_IWARP, RDMA_DRIVER_IB_USER_VERBS, RDMA_DRIVER_IB_USER_MAD, RDMA_DRIVER_IB_USER_SMI, RDMA_DRIVER_IB_USER_PKEY, RDMA_DRIVER_IB_USER_MEM, RDMA_DRIVER_IB_USER_AH, RDMA_DRIVER_IB_USER_MAD_USER_AH, RDMA_DRIVER_IB_USER_MULTICAST, RDMA_DRIVER_IB_USER_CM, RDMA_DRIVER_IB_USER_IP_OVER_IB, RDMA_DRIVER_IB_USER_LED, RDMA_DRIVER_IB_USER_ENHANCED_QP, RDMA_DRIVER_IB_USER_SRQ, RDMA_DRIVER_IB_USER_XRC, RDMA_DRIVER_IB_USER_QP, RDMA_DRIVER_IB_USER_MR, RDMA_DRIVER_IB_USER_SCQ, RDMA_DRIVER_IB_USER_RCQ, RDMA_DRIVER_IB_USER_PD, RDMA_DRIVER_IB_USER_OBJ]"
        },
    }
},
{
    "kretprobe:ib_query_pkey": {
        "description": "ib_query_pkey() fetches the specified P_Key table entry.",
        "proto" :"int ib_query_pkey(struct ib_device *device, u32 port_num, u16 index, u16 *pkey)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "index": ">=0",
            "pkey": "!=null"
        }
    }
},
{
    "kprobe:ib_query_pkey": {
        "description": "Fetches the specified P_Key table entry.",
        "proto" :"int (*ib_query_pkey)(struct ib_device *device, u32 port_num, u16 index, u16 *pkey)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "index": ">=0",
            "pkey": "!=null"
        }
    }
},
{
    "kretprobe:ib_modify_device": {
        "description": "Change IB device attributes. ib_modify_device() changes a device's attributes as specified by the @device_modify_mask and @device_modify structure.",
        "proto" :"int ib_modify_device(struct ib_device *device, int device_modify_mask, struct ib_device_modify *device_modify)",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "is int",
            "device_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_device": {
        "description": "Change IB device attributes. ib_modify_device() changes a device's attributes as specified by the @device_modify_mask and @device_modify structure.",
        "proto" :"int (*ib_modify_device)(struct ib_device *device, int device_modify_mask, struct ib_device_modify *device_modify)",
        "pre": {
            "device": "!=null",
            "device_modify_mask": "is int",
            "device_modify": "!=null",
        },
    }
},
{
    "kretprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port. Changes a port's attributes as specified by the @port_modify_mask and @port_modify structure.",
        "proto" :"int (*ib_modify_port)(struct ib_device *device, u32 port_num, int port_modify_mask, struct ib_port_modify *port_modify)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "port_modify_mask": "is int",
            "port_modify": "!=null"
        }
    }
},
{
    "kprobe:ib_modify_port": {
        "description": "Modifies the attributes for the specified port. Changes a port's attributes as specified by the @port_modify_mask and @port_modify structure.",
        "proto" :"int (*ib_modify_port)(struct ib_device *device, u32 port_num, int port_modify_mask, struct ib_port_modify *port_modify)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "port_modify_mask": "is integer",
            "port_modify": "!=null"
        }
    }
},
{
    "kretprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs. Its searches only for IB link layer.",
        "proto" :"int (*ib_find_gid)(struct ib_device *device, union ib_gid *gid, u32 *port_num, u16 *index)",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": "!=null || ==null"
        },
    }
},
{
    "kprobe:ib_find_gid": {
        "description": "Returns the port number and GID table index where a specified GID value occurs. Its searches only for IB link layer.",
        "proto" :"int (*ib_find_gid)(struct ib_device *device, union ib_gid *gid, u32 *port_num, u16 *index)",
        "pre": {
            "device": "!=null",
            "gid": "!=null",
            "port_num": "!=null",
            "index": "can be null or !=null",
        },
    }
},
{
    "kretprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "proto" :"int (*ib_find_pkey)(struct ib_device *device, u32 port_num, u16 pkey, u16 *index)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1 && <=65535",
            "pkey": ">=0 && <=65535",
            "index": "!=null"
        }
    }
},
{
    "kprobe:ib_find_pkey": {
        "description": "Returns the PKey table index where a specified PKey value occurs.",
        "proto" :"int (*ib_find_pkey)(struct ib_device *device, u32 port_num, u16 pkey, u16 *index)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1 && <=65535",
            "pkey": ">=0 && <=65535",
            "index": "!=null",
        },
    }
},
{
    "kretprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request. @dev: An RDMA device on which the request has been received. @port: Port number on the RDMA device. @pkey: The Pkey the request came on. @gid: A GID that the net_dev uses to communicate. @addr: Contains the IP address that the request specified as its destination.",
        "proto" :"struct net_device *(*ib_get_net_dev_by_params)(struct ib_device *dev, u32 port, u16 pkey, const union ib_gid *gid, const struct sockaddr *addr)",
        "pre": {
            "dev": "!=null",
            "port": ">=1 && <=65535",
            "pkey": ">=0 && <=65535",
            "gid": "!=null",
            "addr": "!=null"
        }
    }
},
{
    "kprobe:ib_get_net_dev_by_params": {
        "description": "Return the appropriate net_dev for a received CM request. @dev:An RDMA device on which the request has been received. @port:Port number on the RDMA device. @pkey:The Pkey the request came on. @gid:A GID that the net_dev uses to communicate. @addr:Contains the IP address that the request specified as its destination.",
        "proto" :"struct net_device *(*ib_get_net_dev_by_params)(struct ib_device *dev, u32 port, u16 pkey, const union ib_gid *gid, const struct sockaddr *addr)",
        "pre": {
            "dev": "!=null",
            "port": ">=0",
            "pkey": ">=0",
            "gid": "!=null",
            "addr": "!=null"
        },
    }
},
{
    "kretprobe:rdma_nl_register": {
        "description": "Register a callback table for a specific index. Pairs with the READ_ONCE in is_nl_valid()",
        "proto" :"void (*rdma_nl_register)(unsigned int index, const struct rdma_nl_cbs cb_table[])",
        "pre": {
            "index": "is_nl_msg_valid(index, 0) == true",
            "cb_table": "READ_ONCE(rdma_nl_types[index].cb_table) == null"
        },
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Store the value of *cb_table* in *rdma_nl_types[index].cb_table* with release semantics.",
        "proto" :"void smp_store_release(void **ptr, void *val)",
        "pre": {
            "ptr": "!=null",
            "val": "!=null"
        },
    },
    "kprobe:rdma_nl_register": {
        "description": "Register a set of callbacks for a specific RDMA netlink message type.",
        "proto" :"int rdma_nl_register(unsigned int index, const struct rdma_nl_cbs cb_table[])",
        "pre": {
            "index": ">=0",
            "cb_table": "!=null"
        },
    }
},
{
    "kretprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gids, as needed, to the relevant RoCE devices.",
        "proto" :"void (*rdma_roce_rescan_device)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_roce_rescan_device": {
        "description": "Rescan all of the network devices in the system and add their gids, as needed, to the relevant RoCE devices.",
        "proto" :"void (*rdma_roce_rescan_device)(struct ib_device *ib_dev)",
        "pre": {
            "ib_dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not. Returns true if given GID is zero, returns false otherwise.",
        "proto" :"bool (*rdma_is_zero_gid)(const union ib_gid *gid)",
        "pre": {
            "gid": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rdma_is_zero_gid": {
        "description": "Check if given GID is zero or not. Returns true if given GID is zero, returns false otherwise.",
        "proto" :"bool (*rdma_is_zero_gid)(const union ib_gid *gid)",
        "pre": {
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:rdma_find_gid_by_port": {
        "description": "rdma_put_gid_attr() to release the reference.",
        "proto" :"const struct ib_gid_attr *(*rdma_find_gid_by_port)(struct ib_device *ib_dev, const union ib_gid *gid, enum ib_gid_type gid_type, u32 port, struct net_device *ndev)",
        "pre": {
            "ib_dev": "!=null",
            "gid": "!=null",
            "gid_type": "in [IB_GID_TYPE_IB, IB_GID_TYPE_ROCE, IB_GID_TYPE_ROCE_UDP_ENCAP, IB_GID_TYPE_SIZE]",
            "port": ">=0",
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:rdma_find_gid_by_port": {
        "description": "rdma_put_gid_attr() to release the reference.",
        "proto" :"const struct ib_gid_attr *(*rdma_find_gid_by_port)(struct ib_device *ib_dev, const union ib_gid *gid, enum ib_gid_type gid_type, u32 port, struct net_device *ndev)",
        "pre": {
            "ib_dev": "!=null",
            "gid": "!=null",
            "gid_type": "in [IB_GID_TYPE_IB, IB_GID_TYPE_ROCE, IB_GID_TYPE_ROCE_UDP_ENCAP, IB_GID_TYPE_SIZE]",
            "port": ">=0",
            "ndev": "!=null"
        },
    }
},
{
    "kretprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache for requested device, port and index. It reads for IB, RoCE and iWarp link layers. It doesn't hold any reference to the GID table entry in the HCA or software cache.",
        "proto" :"int rdma_query_gid(struct ib_device *device, u32 port_num, int index, union ib_gid *gid)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "index": ">=0",
            "gid": "!=null"
        },
    }
},
{
    "kprobe:rdma_query_gid": {
        "description": "Read the GID content from the GID software cache. rdma_query_gid() only reads the GID entry content for requested device, port and index. It reads for IB, RoCE and iWarp link layers. It doesn't hold any reference to the GID table entry in the HCA or software cache. Returns 0 on success or appropriate error code.",
        "proto" :"int (*rdma_query_gid)(struct ib_device *device, u32 port_num, int index, union ib_gid *gid)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "index": ">=0",
            "gid": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute. Callers are required to already be holding the reference to an existing GID entry.",
        "proto" :"void *(*rdma_read_gid_hw_context)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null"
        },
    }
},
{
    "kprobe:rdma_read_gid_hw_context": {
        "description": "Read the HW GID context from GID attribute. Callers are required to already be holding the reference to an existing GID entry.",
        "proto" :"void *(*rdma_read_gid_hw_context)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists. rdma_get_gid_attr() acquires reference count of gid attributes from the cached GID table. Caller must invoke rdma_put_gid_attr() to release reference to gid attribute regardless of link layer. Returns pointer to valid gid attribute or ERR_PTR for the appropriate error code.",
        "proto" :"const struct ib_gid_attr *(*rdma_get_gid_attr)(struct ib_device *device, u32 port_num, int index)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "index": ">=0"
        }
    }
},
{
    "kprobe:rdma_get_gid_attr": {
        "description": "Returns GID attributes for a port of a device at a requested gid_index, if a valid GID entry exists. rdma_get_gid_attr() acquires reference count of gid attributes from the cached GID table. Caller must invoke rdma_put_gid_attr() to release reference to gid attribute regardless of link layer. Returns pointer to valid gid attribute or ERR_PTR for the appropriate error code.",
        "proto" :"const struct ib_gid_attr *(*rdma_get_gid_attr)(struct ib_device *device, u32 port_num, int index)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries. Returns number of entries on success or appropriate error code.",
        "proto" :"ssize_t (*rdma_query_gid_table)(struct ib_device *device, struct ib_uverbs_gid_entry *entries, size_t max_entries)",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": ">0"
        }
    }
},
{
    "kprobe:rdma_query_gid_table": {
        "description": "Reads GID table entries of all the ports of a device up to max_entries.",
        "proto" :"ssize_t (*rdma_query_gid_table)(struct ib_device *device, struct ib_uverbs_gid_entry *entries, size_t max_entries)",
        "pre": {
            "device": "!=null",
            "entries": "!=null",
            "max_entries": ">=0",
        },
    }
},
{
    "kretprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute. Increase the reference count to a GID attribute to keep it from being freed. Callers are required to already be holding a reference to attribute.",
        "proto" :"void (*rdma_hold_gid_attr)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rdma_hold_gid_attr": {
        "description": "Get reference to existing GID attribute. Increase the reference count to a GID attribute to keep it from being freed. Callers are required to already be holding a reference to attribute.",
        "proto" :"void (*rdma_hold_gid_attr)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null && already_held"
        }
    }
},
{
    "kretprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state. Returns pointer to netdevice if the netdevice was attached to GID and netdevice is in UP state. Caller must hold RCU lock as this API reads the netdev flags which can change while netdevice migrates to different net namespace. Returns ERR_PTR with error code otherwise.",
        "proto" :"struct net_device *(*rdma_read_gid_attr_ndev_rcu)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null"
        },
    }
},
{
    "kprobe:rdma_read_gid_attr_ndev_rcu": {
        "description": "Read GID attribute netdevice which must be in UP state. Returns pointer to netdevice if the netdevice was attached to GID and netdevice is in UP state. Caller must hold RCU lock as this API reads the netdev flags which can change while netdevice migrates to different net namespace. Returns ERR_PTR with error code otherwise.",
        "proto" :"struct net_device *(*rdma_read_gid_attr_ndev_rcu)(const struct ib_gid_attr *attr)",
        "pre": {
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry. Returns 0 on success and returns vlan id (if gid entry has vlan) and source MAC, or returns error.",
        "proto" :"int (*rdma_read_gid_l2_fields)(const struct ib_gid_attr *attr, u16 *vlan_id, u8 *smac)",
        "pre": {
            "attr": "!=null",
            "vlan_id": "optional",
            "smac": "optional"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:rdma_read_gid_l2_fields": {
        "description": "Read the vlan ID and source MAC address of a GID entry.",
        "proto" :"int (*rdma_read_gid_l2_fields)(const struct ib_gid_attr *attr, u16 *vlan_id, u8 *smac)",
        "pre": {
            "attr": "!=null",
            "vlan_id": "optional",
            "smac": "optional"
        },
        "post": {
            "return": "in [0, error]",
            "vlan_id": "optional",
            "smac": "optional"
        }
    }
},
{
    "kretprobe:ib_cache_gid_type_str": {
        "description": "Return a string representation of the gid_type enum. IB/RoCE v1 value is set for IB_GID_TYPE_IB and IB_GID_TYPE_ROCE for user space compatibility reasons.",
        "proto" :"const char *(*ib_cache_gid_type_str)(enum ib_gid_type gid_type)",
        "pre": {
            "gid_type": "unknown"
        }
    }
},
{
    "kprobe:ib_cache_gid_type_str": {
        "description": "IBRoCE v1 value is set for IB_GID_TYPE_IB and IB_GID_TYPE_ROCE for user space compatibility reasons.",
        "proto" :"const char *ib_cache_gid_type_str(enum ib_gid_type gid_type)",
        "pre": {
            "gid_type": "in [IB_GID_TYPE_IB, IB_GID_TYPE_ROCE, IB_GID_TYPE_ROCE_UDP_ENCAP]"
        }
    }
},
{
    "kretprobe:ib_create_qp_security": {
        "description": "Checks if the device is an IB device and if it is, it creates a security context. If it's not an IB device, it doesn't create the security context and returns 0.",
        "proto" :"int (*ib_create_qp_security)(struct ib_qp *qp, struct ib_device *dev)",
        "pre": {
            "qp": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, -ENOMEM, ret]"
        }
    }
},
{
    "kprobe:ib_create_qp_security": {
        "description": "Create a security context for a Queue Pair (QP). If the device is not an IB device, the security context is not created.",
        "proto" :"int (*ib_create_qp_security)(struct ib_qp *qp, struct ib_device *dev)",
        "pre": {
            "qp": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma. Each time we map IO memory into user space this keeps track of the mapping. When the device is hot-unplugged we 'zap' the mmaps in user space to point to the zero page and allow the hot unplug to proceed. This is necessary for cases like PCI physical hot unplug as the actual BAR memory may vanish after this and access to it from userspace could MCE. RDMA drivers supporting disassociation must have their user space designed to cope in some way with their IO pages going to the zero page.",
        "proto" :"void (*rdma_umap_priv_init)(struct rdma_umap_priv *priv, struct vm_area_struct *vma, struct rdma_user_mmap_entry *entry)",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_umap_priv_init": {
        "description": "Initialize the private data of a vma. Each time we map IO memory into user space this keeps track of the mapping. When the device is hot-unplugged we 'zap' the mmaps in user space to point to the zero page and allow the hot unplug to proceed. This is necessary for cases like PCI physical hot unplug as the actual BAR memory may vanish after this and access to it from userspace could MCE. RDMA drivers supporting disassociation must have their user space designed to cope in some way with their IO pages going to the zero page.",
        "proto" :"void (*rdma_umap_priv_init)(struct rdma_umap_priv *priv, struct vm_area_struct *vma, struct rdma_user_mmap_entry *entry)",
        "pre": {
            "priv": "!=null",
            "vma": "!=null",
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_io": {
        "description": "This is to be called by drivers as part of their mmap() functions if they wish to send something like PCI-E BAR memory to userspace. Return -EINVAL on wrong flags or size, -EAGAIN on failure to map. 0 on success.",
        "proto" :"int rdma_user_mmap_io(struct ib_ucontext *ucontext, struct vm_area_struct *vma, unsigned long pfn, unsigned long size, pgprot_t prot, struct rdma_user_mmap_entry *entry)",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": ">=0",
            "size": ">0",
            "prot": "!=null",
            "entry": "!=null || ==null"
        },
        "post": {
            "return": "in [-EINVAL, -EAGAIN, 0]"
        }
    }
},
{
    "kprobe:rdma_user_mmap_io": {
        "description": "This is to be called by drivers as part of their mmap() functions if they wish to send something like PCI-E BAR memory to userspace. Return -EINVAL on wrong flags or size, -EAGAIN on failure to map. 0 on success.",
        "proto" :"int rdma_user_mmap_io(struct ib_ucontext *ucontext, struct vm_area_struct *vma, unsigned long pfn, unsigned long size, pgprot_t prot, struct rdma_user_mmap_entry *entry)",
        "pre": {
            "ucontext": "!=null",
            "vma": "!=null",
            "pfn": ">=0",
            "size": ">0",
            "prot": "!=null",
            "entry": "!=null or ==null"
        },
    }
},
{
    "kretprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "This function increases the refcnt of the entry so that it won't be deleted from the xarray in the meantime. Return an reference to an entry if exists or NULL if there is no match. rdma_user_mmap_entry_put() must be called to put the reference.",
        "proto" :"struct rdma_user_mmap_entry *(*rdma_user_mmap_entry_get_pgoff)(struct ib_ucontext *ucontext, unsigned long pgoff)",
        "pre": {
            "ucontext": "!=null",
            "pgoff": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_get_pgoff": {
        "description": "This function increases the refcnt of the entry so that it won't be deleted from the xarray in the meantime. Return an reference to an entry if exists or NULL if there is no match. rdma_user_mmap_entry_put() must be called to put the reference.",
        "proto" :"struct rdma_user_mmap_entry *(*rdma_user_mmap_entry_get_pgoff)(struct ib_ucontext *ucontext, unsigned long pgoff)",
        "pre": {
            "ucontext": "!=null",
            "pgoff": ">=0"
        },
    }
},
{
    "kretprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable. Drivers can call this to prevent userspace from creating more mappings for entry, however existing mmaps continue to exist and ops->mmap_free() will not be called until all user mmaps are destroyed.",
        "proto" :"void (*rdma_user_mmap_entry_remove)(struct rdma_user_mmap_entry *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_remove": {
        "description": "Drop reference to entry and mark it as unmmapable. Drivers can call this to prevent userspace from creating more mappings for entry, however existing mmaps continue to exist and ops->mmap_free() will not be called until all user mmaps are destroyed.",
        "proto" :"void (*rdma_user_mmap_entry_remove)(struct rdma_user_mmap_entry *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range. This function should be called by drivers that use the rdma_user_mmap interface for implementing their mmap syscall. A database of mmap offsets is handled in the core and helper functions are provided to insert entries into the database and extract entries when the user calls mmap with the given offset. The function allocates a unique page offset in a given range that should be provided to user, the user will use the offset to retrieve information such as address to be mapped and how.",
        "proto" :"int rdma_user_mmap_entry_insert_range(struct ib_ucontext *ucontext, struct rdma_user_mmap_entry *entry, size_t length, u32 min_pgoff, u32 max_pgoff)",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": ">0",
            "min_pgoff": ">=0",
            "max_pgoff": ">=min_pgoff"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:rdma_user_mmap_entry_insert_range": {
        "description": "Insert an entry to the mmap_xa in a given range. This function should be called by drivers that use the rdma_user_mmap interface for implementing their mmap syscall. A database of mmap offsets is handled in the core and helper functions are provided to insert entries into the database and extract entries when the user calls mmap with the given offset. The function allocates a unique page offset in a given range that should be provided to user, the user will use the offset to retrieve information such as address to be mapped and how.",
        "proto" :"int (*rdma_user_mmap_entry_insert_range)(struct ib_ucontext *ucontext, struct rdma_user_mmap_entry *entry, size_t length, u32 min_pgoff, u32 max_pgoff)",
        "pre": {
            "ucontext": "!=null",
            "entry": "!=null",
            "length": ">0",
            "min_pgoff": ">=0",
            "max_pgoff": ">=min_pgoff"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kretprobe:ib_umem_dmabuf_map_pages": {
        "description": "Modify the sg list in-place to match umem address and length.",
        "proto" :"ib_umem_dmabuf_map_pages(struct ib_umem_dmabuf  umem_dmabuf)",
        "pre": {
            "umem_dmabuf": "Your condition here",
        },
    }
},
{
    "kprobe:ib_umem_dmabuf_map_pages": {
        "description": "Modify the sg list in-place to match umem address and length.",
        "proto" :"ib_umem_dmabuf_map_pages(struct ib_umem_dmabuf  umem_dmabuf)",
        "pre": {
            "umem_dmabuf": "!=null",
            "sgt": "!=null",
            "sg": "!=null",
            "start": "[your constraints here]",
            "end": "[your constraints here]",
            "cur": "[your constraints here]",
            "nmap": "[your constraints here]",
            "ret": "[your constraints here]",
            "i": "[your constraints here]"
        },
    }
},

{
    "kprobe:ib_umem_dmabuf_unmap_pages": {
        "description": "Restore the original sg list if umem_dmabuf->first_sg is not null.",
        "proto" :"static void (*ib_umem_dmabuf_unmap_pages)(struct ib_umem_dmabuf *umem_dmabuf)",
        "pre": {
            "umem_dmabuf": "!=null",
            "umem_dmabuf->first_sg": "!=null",
            "umem_dmabuf->attach": "!=null",
            "umem_dmabuf->attach->dmabuf": "!=null",
            "umem_dmabuf->attach->dmabuf->resv": "!=null",
            "umem_dmabuf->sgt": "!=null"
        }
    }
},
{
    "kretprobe:rdma_copy_src_l2_addr": {
        "description": "rdma_copy_src_l2_addr() copies source addresses from the specified netdevice. This includes unicast address, broadcast address, device type and interface index.",
        "proto" :"void rdma_copy_src_l2_addr(struct rdma_dev_addr *dev_addr, const struct net_device *dev)",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:rdma_copy_src_l2_addr": {
        "description": "rdma_copy_src_l2_addr() copies source addresses from the specified netdevice. This includes unicast address, broadcast address, device type and interface index.",
        "proto" :"void rdma_copy_src_l2_addr(struct rdma_dev_addr *dev_addr, const struct net_device *dev)",
        "pre": {
            "dev_addr": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request. rdma_addr_cancel() is a synchronous function which cancels any pending request if there is any.",
        "proto" :"void (*rdma_addr_cancel)(struct rdma_dev_addr *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel resolve ip request. rdma_addr_cancel() is a synchronous function which cancels any pending request if there is any.",
        "proto": "void (*rdma_addr_cancel)(struct rdma_dev_addr *addr)",
        "pre": {
            "addr": "!=null"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem. Implicit ODP umems do not have a VA range and do not have any page lists. They exist only to hold the per_mm reference to help the driver create children umems.",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_alloc_implicit)(struct ib_device *device, int access)",
        "pre": {
            "device": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC, IB_ACCESS_MW_BIND, IB_ZERO_BASED, IB_ACCESS_ON_DEMAND, IB_ACCESS_PHYS_MR, IB_ACCESS_HUGETLB]"
        }
    }
},
{
    "kprobe:ib_umem_odp_alloc_implicit": {
        "description": "Allocate a parent implicit ODP umem. Implicit ODP umems do not have a VA range and do not have any page lists. They exist only to hold the per_mm reference to help the driver create children umems.",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_alloc_implicit)(struct ib_device *device, int access)",
        "pre": {
            "device": "!=null",
            "access": "in [IB_ACCESS_LOCAL_WRITE, IB_ACCESS_REMOTE_WRITE, IB_ACCESS_REMOTE_READ, IB_ACCESS_REMOTE_ATOMIC, IB_ACCESS_MW_BIND, IB_ZERO_BASED, IB_ACCESS_ON_DEMAND, IB_ACCESS_PHYS_MR, IB_ACCESS_HUGETLB]"
        }
    }
},
{
    "kretprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem. The parent umem enclosing the child must be allocated using ib_alloc_implicit_odp_umem().",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_alloc_child)(struct ib_umem_odp *root, unsigned long addr, size_t size, const struct mmu_interval_notifier_ops *ops)",
        "pre": {
            "root": "!=null",
            "addr": ">=0",
            "size": ">0",
            "ops": "!=null"
        },
    }
},
{
    "kprobe:ib_umem_odp_alloc_child": {
        "description": "Allocate a child ODP umem under an implicit parent ODP umem. @root: The parent umem enclosing the child. This must be allocated using ib_alloc_implicit_odp_umem(). @addr: The starting userspace VA. @size: The length of the userspace VA. @ops: MMU interval ops, currently only @invalidate.",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_alloc_child)(struct ib_umem_odp *root, unsigned long addr, size_t size, const struct mmu_interval_notifier_ops *ops)",
        "pre": {
            "root": "!=null",
            "addr": ">=0",
            "size": ">0",
            "ops": "!=null",
        },
    }
},
{
    "kretprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va. The driver should use when the access flags indicate ODP memory. It avoids pinning, instead, stores the mm for future page fault handling in conjunction with MMU notifiers.",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_get)(struct ib_device *device, unsigned long addr, size_t size, int access, const struct mmu_interval_notifier_ops *ops)",
        "pre": {
            "device": "!=null",
            "addr": ">=0",
            "size": ">0",
            "access": "in [IB_ACCESS_xxx flags]",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_odp_get": {
        "description": "Create a umem_odp for a userspace va. The driver should use when the access flags indicate ODP memory. It avoids pinning, instead, stores the mm for future page fault handling in conjunction with MMU notifiers.",
        "proto" :"struct ib_umem_odp *(*ib_umem_odp_get)(struct ib_device *device, unsigned long addr, size_t size, int access, const struct mmu_interval_notifier_ops *ops)",
        "pre": {
            "device": "!=null",
            "addr": ">=0",
            "size": ">0",
            "access": "in [IB_ACCESS_xxx]",
            "ops": "!=null"
        },
    }
},
{
    "kretprobe:ib_umem_odp_release": {
        "description": "Ensure that no more pages are mapped in the umem. It is the driver's responsibility to ensure, before calling us, that the hardware will not attempt to access the MR any more.",
        "proto" :"static void (*ib_umem_odp_release)(struct ib_umem_odp *umem_odp)",
        "pre": {
            "umem_odp": "!=null"
        }
    }
},
{
    "kprobe:ib_umem_odp_release": {
        "description": "Ensure that no more pages are mapped in the umem. It is the driver's responsibility to ensure, before calling us, that the hardware will not attempt to access the MR any more.",
        "proto" :"void ib_umem_odp_release(struct ib_umem_odp *umem_odp)",
        "pre": {
            "umem_odp": "!=null",
            "umem_odp->is_implicit_odp": "is boolean"
        },
    }
},
{
    "kretprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it. Maps the range passed in the argument to DMA addresses. The DMA addresses of the mapped pages is updated in umem_odp->dma_list. Upon success the ODP MR will be locked to let caller complete its device page table update. Returns the number of pages mapped in success, negative error code for failure.",
        "proto" :"int (*ib_umem_odp_map_dma_and_lock)(struct ib_umem_odp *umem_odp, u64 user_virt, u64 bcnt, u64 access_mask, bool fault)__acquires(&umem_odp->umem_mutex)",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": ">=0",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "in [true, false]"
        },
    }
},
{
    "kprobe:ib_umem_odp_map_dma_and_lock": {
        "description": "DMA map userspace memory in an ODP MR and lock it. Maps the range passed in the argument to DMA addresses. The DMA addresses of the mapped pages is updated in umem_odp->dma_list. Upon success the ODP MR will be locked to let caller complete its device page table update. Returns the number of pages mapped in success, negative error code for failure.",
        "proto" :"int (*ib_umem_odp_map_dma_and_lock)(struct ib_umem_odp *umem_odp, u64 user_virt, u64 bcnt, u64 access_mask, bool fault)__acquires(&umem_odp->umem_mutex)",
        "pre": {
            "umem_odp": "!=null",
            "user_virt": ">=0",
            "bcnt": ">=0",
            "access_mask": ">=0",
            "fault": "in [true, false]"
        },
    }
},
{
    "kretprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables.",
        "proto" :"static int (*ib_umem_odp_map_dma_single_page)(struct ib_umem_odp *umem_odp, unsigned int dma_index, struct page *page, u64 access_mask)",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": "is a valid index",
            "page": "!=null",
            "access_mask": "is a valid access permission"
        },
        "post": {
            "return": "in [-EFAULT, 0]"
        }
    }
},
{
    "kprobe:ib_umem_odp_map_dma_single_page": {
        "description": "Map for DMA and insert a single page into the on-demand paging page tables. The function returns -EFAULT if the DMA mapping operation fails.",
        "proto" :"static int (*ib_umem_odp_map_dma_single_page)(struct ib_umem_odp *umem_odp, unsigned int dma_index, struct page *page, u64 access_mask)",
        "pre": {
            "umem_odp": "!=null",
            "dma_index": ">=0",
            "page": "!=null",
            "access_mask": ">=0"
        }
    }
},
{
    "kretprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query. If the id and query don't match up or the query has already completed, nothing is done. Otherwise the query is canceled and will complete with a status of -EINTR.",
        "proto" :"void (*ib_sa_cancel_query)(int id, struct ib_sa_query *query)",
        "pre": {
            "id": ">=0",
            "query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_cancel_query": {
        "description": "Try to cancel an SA query. If the id and query don't match up or the query has already completed, nothing is done. Otherwise the query is canceled and will complete with a status of -EINTR.",
        "proto" :"void (*ib_sa_cancel_query)(int id, struct ib_sa_query *query)",
        "pre": {
            "id": "is integer",
            "query": "!=null"
        }
    }
},
{
    "kretprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record. When ib_init_ah_attr_from_path() returns success, (a) for IB link layer it optionally contains a reference to SGID attribute when GRH is present for IB link layer. (b) for RoCE link layer it contains a reference to SGID attribute. User must invoke rdma_destroy_ah_attr() to release reference to SGID attributes which are initialized using ib_init_ah_attr_from_path().",
        "proto" :"int ib_init_ah_attr_from_path(struct ib_device *device, u32 port_num, struct sa_path_rec *rec, struct rdma_ah_attr *ah_attr, const struct ib_gid_attr *gid_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        }
    }
},
{
    "kprobe:ib_init_ah_attr_from_path": {
        "description": "Initialize address handle attributes based on an SA path record.",
        "proto" :"int (*ib_init_ah_attr_from_path)(struct ib_device *device, u32 port_num, struct sa_path_rec *rec, struct rdma_ah_attr *ah_attr, const struct ib_gid_attr *gid_attr)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1",
            "rec": "!=null",
            "ah_attr": "!=null",
            "gid_attr": "!=null"
        },
    }
},
{
    "kretprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query. Send a Path Record Get query to the SA to look up a path. The callback function will be called when the query completes (or fails); status is 0 for a successful response, -EINTR if the query is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error occurred sending the query. The resp parameter of the callback is only valid if status is 0. If the return value of ib_sa_path_rec_get() is negative, it is an error code. Otherwise it is a query ID that can be used to cancel the query.",
        "proto" :"int (*ib_sa_path_rec_get)(struct ib_sa_client *client, struct ib_device *device, u32 port_num, struct sa_path_rec *rec, ib_sa_comp_mask comp_mask, unsigned long timeout_ms, gfp_t gfp_mask, void (*callback)(int status,struct sa_path_rec *resp,unsigned int num_paths, void *context), void *context, struct ib_sa_query **sa_query)",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": ">=0",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "can be null",
            "sa_query": "!=null"
        }
    }
},
{
    "kprobe:ib_sa_path_rec_get": {
        "description": "Start a Path get query. Send a Path Record Get query to the SA to look up a path. The callback function will be called when the query completes (or fails); status is 0 for a successful response, -EINTR if the query is canceled, -ETIMEDOUT is the query timed out, or -EIO if an error occurred sending the query. The resp parameter of the callback is only valid if status is 0. If the return value of ib_sa_path_rec_get() is negative, it is an error code. Otherwise it is a query ID that can be used to cancel the query.",
        "proto" :"int (*ib_sa_path_rec_get)(struct ib_sa_client *client, struct ib_device *device, u32 port_num, struct sa_path_rec *rec, ib_sa_comp_mask comp_mask, unsigned long timeout_ms, gfp_t gfp_mask, void (*callback)(int status,struct sa_path_rec *resp,unsigned int num_paths, void *context), void *context, struct ib_sa_query **sa_query)",
        "pre": {
            "client": "!=null",
            "device": "!=null",
            "port_num": ">=0",
            "rec": "!=null",
            "comp_mask": ">=0",
            "timeout_ms": ">=0",
            "gfp_mask": ">=0",
            "callback": "!=null",
            "context": "can be null",
            "sa_query": "!=null"
        }
    }
},
{
    "kretprobe:ib_register_mad_agent": {
        "description": "Register to sendreceive MADs. Context: Process context.",
        "proto" :"struct ib_mad_agent *(*ib_register_mad_agent)(struct ib_device *device, u32 port_num, enum ib_qp_type qp_type, struct ib_mad_reg_req *mad_reg_req, u8 rmpp_version, ib_mad_send_handler send_handler, ib_mad_recv_handler recv_handler, void *context, u32 registration_flags)",
        "pre": {
            "device": "!=null",
            "port_num": ">=1 && <=65535",
            "qp_type": "in [IB_QPT_SMI, IB_QPT_GSI, IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW_IPV6, IB_QPT_RAW_ETHERTYPE, IB_QPT_XRC_INI, IB_QPT_XRC_TGT]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=1 && <=255",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "can be null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kprobe:ib_register_mad_agent": {
        "description": "Register to sendreceive MADs. Context: Process context.",
        "proto" :"struct ib_mad_agent *(*ib_register_mad_agent)(struct ib_device *device, u32 port_num, enum ib_qp_type qp_type, struct ib_mad_reg_req *mad_reg_req, u8 rmpp_version, ib_mad_send_handler send_handler, ib_mad_recv_handler recv_handler, void *context, u32 registration_flags)",
        "pre": {
            "device": "!=null",
            "port_num": ">=0",
            "qp_type": "in [IB_QPT_SMI, IB_QPT_GSI, IB_QPT_RC, IB_QPT_UC, IB_QPT_UD, IB_QPT_RAW_IPV6, IB_QPT_RAW_ETHERTYPE, IB_QPT_XRC_INI, IB_QPT_XRC_TGT]",
            "mad_reg_req": "!=null",
            "rmpp_version": ">=0",
            "send_handler": "!=null",
            "recv_handler": "!=null",
            "context": "!=null",
            "registration_flags": ">=0"
        }
    }
},
{
    "kretprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services. Context: Process context.",
        "proto" :"void (*ib_unregister_mad_agent)(struct ib_mad_agent *mad_agent)",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kprobe:ib_unregister_mad_agent": {
        "description": "Unregisters a client from using MAD services. Context: Process context.",
        "proto" :"void (*ib_unregister_mad_agent)(struct ib_mad_agent *mad_agent)",
        "pre": {
            "mad_agent": "!=null"
        }
    }
},
{
    "kretprobe:ib_create_send_mad": {
        "description": "Create a send MAD.",
        "proto" :"static long (*ib_create_send_mad)(struct ib_mad_agent *mad_agent, u32 remote_qpn, u16 pkey_index, int rmpp_active, int hdr_len, int data_len, gfp_t gfp_mask, u8 base_version)",
        "pre": {
            "mad_agent": "!=null",
            "remote_qpn": "is valid",
            "pkey_index": "is valid",
            "rmpp_active": "is boolean",
            "hdr_len": ">0",
            "data_len": ">0",
            "gfp_mask": "is valid",
            "base_version": "is valid"
        },
    }
},

{
    "kretprobe:qp_type_check": {
        "description": "Check if qp_type is equal to IB_QPT_SMI.",
        "proto" :"static long (*qp_type_check)(int qp_type)",
        "pre": {
            "qp_type": "== IB_QPT_SMI",
        },
    }
},

{
    "kretprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "proto" :"int (*ib_post_send_mad)(struct ib_mad_send_buf *send_buf, struct ib_mad_send_buf **bad_send_buf)",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kprobe:ib_post_send_mad": {
        "description": "Posts MAD(s) to the send queue of the QP associated with the registered client",
        "proto" :"int ib_post_send_mad(struct ib_mad_send_buf *send_buf, struct ib_mad_send_buf **bad_send_buf)",
        "pre": {
            "send_buf": "!=null",
            "bad_send_buf": "!=null"
        }
    }
},
{
    "kretprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer",
        "proto" :"void (*ib_free_recv_mad)(struct ib_mad_recv_wc *mad_recv_wc)",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kprobe:ib_free_recv_mad": {
        "description": "Returns data buffers used to receive a MAD to the access layer",
        "proto" :"void (*ib_free_recv_mad)(struct ib_mad_recv_wc *mad_recv_wc)",
        "pre": {
            "mad_recv_wc": "!=null"
        }
    }
},
{
    "kretprobe:_uverbs_alloc": {
        "description": "_uverbs_alloc() - Quickly allocate memory for use with a bundle. The bundle allocator is intended for allocations that are connected with processing the system call related to the bundle. The allocated memory is always freed once the system call completes, and cannot be freed any other way. This tries to use a small pool of pre-allocated memory for performance.",
        "proto" :"__malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size, gfp_t flags)",
        "pre": {
            "bundle": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, __GFP_HIGHMEM, __GFP_HIGH, __GFP_IO, __GFP_FS, __GFP_COLD, __GFP_NOWARN, __GFP_REPEAT, __GFP_NOFAIL, __GFP_NORETRY, __GFP_MEMALLOC, __GFP_COMP, __GFP_ZERO, __GFP_NOMEMALLOC, __GFP_HARDWALL, __GFP_THISNODE, __GFP_RECLAIMABLE, __GFP_NOLOCK, __GFP_NOTRACK, __GFP_NO_KSWAPD, __GFP_OTHER_NODE, __GFP_WRITE, __GFP_NOTRACK_FALSE_POSITIVE, __GFP_NO_ACCOUNT, __GFP_DIRECT_RECLAIM, __GFP_KSWAPD_RECLAIM]"
        }
    }
},
{
    "__malloc void *_uverbs_alloc": {
        "description": "_uverbs_alloc() - Quickly allocate memory for use with a bundle. The bundle allocator is intended for allocations that are connected with processing the system call related to the bundle. The allocated memory is always freed once the system call completes, and cannot be freed any other way. This tries to use a small pool of pre-allocated memory for performance.",
        "proto" :"__malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size, gfp_t flags)",
        "pre": {
            "bundle": "!=null",
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]" // replace ... with other possible gfp_t flags
        },
    }
},
{
    "kretprobe:uverbs_get_flags64": {
        "description": "Get flags from the attribute bundle. Missing attribute means 0 flags.",
        "proto": "u64 (*uverbs_get_flags64)(u64 to, const struct uverbs_attr_bundle attrs_bundle, size_t idx, u64 allowed_bits)",
        "pre": {
            "to": "is a valid u64 value",
            "attrs_bundle": "!=null",
            "idx": "is a valid index in attrs_bundle",
            "allowed_bits": "is a valid u64 value"
        },
        "post": {
            "attr": "!=ERR_PTR"
        }
    }
},
{
    "kprobe:uverbs_get_flags64": {
        "description": "Get flags from the attribute bundle. Missing attribute means 0 flags.",
        "proto": "u64 (*uverbs_get_flags64)(u64 to, const struct uverbs_attr_bundle attrs_bundle, size_t idx, u64 allowed_bits)",
        "pre": {
            "to": "is a valid u64 value",
            "attrs_bundle": "!=null",
            "idx": "is a valid index in attrs_bundle",
            "allowed_bits": "is a valid u64 value",
            "attr": "!=null && !IS_ERR(attr)"
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[parameter1]": "[constraints]",
            "[parameter2]": "[constraints]",
            "[parameter3]": "[constraints]",
            "[parameter4]": "[constraints]",
        },
    }
},
{
    "kprobe:uverbs_get_const_signed": {
        "description": "_uverbs_get_const_signed() is the accessor",
        "proto" :"static long (*uverbs_get_const_signed)(void *pbundle, const void *attr_uapi, void *objs_arr_attr, const void *uattr, const void *attr_bkey)",
        "pre": {
            "pbundle": "!=null",
            "attr_uapi": "!=null",
            "objs_arr_attr": "!=null",
            "uattr": "!=null",
            "attr_bkey": "!=null"
        },
    }
},
{
    "kretprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "proto" :"struct iw_cm_id *(*rdma_iw_cm_id)(struct rdma_cm_id *id)",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kprobe:rdma_iw_cm_id": {
        "description": "Return the iw_cm_id pointer for this cm_id.",
        "proto" :"struct iw_cm_id *(*rdma_iw_cm_id)(struct rdma_cm_id *id)",
        "pre": {
            "id": "!=null"
        }
    }
},
{
    "kretprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "proto" :"struct rdma_cm_id *(*rdma_res_to_id)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:rdma_res_to_id": {
        "description": "Return the rdma_cm_id pointer for this restrack.",
        "proto" :"struct rdma_cm_id *(*rdma_res_to_id)(struct rdma_restrack_entry *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:cma_modify_qp_rts": {
        "description": "Modify the QP state to RTS and update QP attributes from default values.",
        "proto" :"static int cma_modify_qp_rts(struct rdma_id_private *id_priv, struct rdma_conn_param *conn_param)",
        "pre": {
            "id_priv": "!=null",
            "conn_param": "!=null",
            "id_priv->id.qp": "!=null",
            "id_priv->qp_mutex": "locked"
        },
    }
},
{
    "kprobe:cma_modify_qp_rts": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "id_priv": "Your precondition here",
            "conn_param": "Your precondition here"
        },
    }
},
{
    "kretprobe:rdma_addr_cancel": {
        "description": "Cancel the address query operation. This function is only called when the state is RDMA_CM_ADDR_QUERY. The addr_handler work could still be exiting outside this state, however due to the interaction with the handler_mutex the work is guaranteed not to touch id_priv during exit.",
        "proto" :"static void (*rdma_addr_cancel)(struct rdma_dev_addr *dev_addr)",
        "pre": {
            "dev_addr": "!=null",
        },
    }
},
{
    "kprobe:rdma_addr_cancel": {
        "description": "Cancel the address query operation. This function is only called when the state is RDMA_CM_ADDR_QUERY. The addr_handler work could still be exiting outside this state, however due to the interaction with the handler_mutex the work is guaranteed not to touch id_priv during exit.",
        "proto" :"static void (*rdma_addr_cancel)(struct rdma_dev_addr *dev_addr)",
        "pre": {
            "dev_addr": "!=null",
        },
    }
},
{
    "kretprobe:rdma_set_ack_timeout": {
        "description": "rdma_accept(). It is applicable to primary path only. The timeout will affect the local side of the QP, it is not negotiated with remote side and zero disables the timer. In case it is set before rdma_resolve_route, the value will also be used to determine PacketLifeTime for RoCE. Return: 0 for success",
        "proto" :"int rdma_set_ack_timeout(struct rdma_cm_id *id, u8 timeout)",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:rdma_set_ack_timeout": {
        "description": "rdma_accept(). It is applicable to primary path only. The timeout will affect the local side of the QP, it is not negotiated with remote side and zero disables the timer. In case it is set before rdma_resolve_route, the value will also be used to determine PacketLifeTime for RoCE. Return: 0 for success",
        "proto" :"int (*rdma_set_ack_timeout)(struct rdma_cm_id *id, u8 timeout)",
        "pre": {
            "id": "!=null",
            "timeout": ">=0"
        },
    }
},
{
    "kretprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier. This function should be called before rdma_connect() on active side, and on passive side before rdma_accept(). The timer value will be associated with the local QP. When it receives a send it is not ready to handle, typically if the receive queue is empty, an RNR Retry NAK is returned to the requester with the min_rnr_timer encoded. The requester will then wait at least the time specified in the NAK before retrying. The default is zero, which translates to a minimum RNR Timer value of 655 ms.",
        "proto" :"int (*rdma_set_min_rnr_timer)(struct rdma_cm_id *id, u8 min_rnr_timer)",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": "in [0, 31]"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:rdma_set_min_rnr_timer": {
        "description": "Set the minimum RNR Retry timer of the QP associated with a connection identifier. This function should be called before rdma_connect() on active side, and on passive side before rdma_accept(). The timer value will be associated with the local QP. When it receives a send it is not read to handle, typically if the receive queue is empty, an RNR Retry NAK is returned to the requester with the min_rnr_timer encoded. The requester will then wait at least the time specified in the NAK before retrying. The default is zero, which translates to a minimum RNR Timer value of 655 ms.",
        "proto" :"int (*rdma_set_min_rnr_timer)(struct rdma_cm_id *id, u8 min_rnr_timer)",
        "pre": {
            "id": "!=null",
            "min_rnr_timer": "in [0, 31]"
        },
    }
},
{
    "kretprobe:cma_listen_on_all": {
        "description": "Caller must destroy this after releasing lock",
        "proto" :"static int cma_listen_on_all(struct rdma_id_private *id_priv)",
        "pre": {
            "id_priv": "!=null",
        },
    }
},
{
    "kprobe:cma_listen_on_all": {
        "description": "Caller must destroy this after releasing lock",
        "proto" :"static int cma_listen_on_all(struct rdma_id_private *id_priv)",
        "pre": {
            "id_priv": "!=null",
        },
    }
},
{
    "kretprobe:rdma_resolve_addr": {
        "description": "The description of the function based on the helper doc",
        "proto" :"rdma_resolve_addr(struct rdma_cm_id  id, struct sockaddr  src_addr, const struct sockaddr  dst_addr, unsigned long timeout_ms)",
        "pre": {
            "id": "!=null",
            "src_addr": "!=null",
            "dst_addr": "!=null",
            "timeout_ms": ">=0",
        },
    }
},

{
    "kretprobe:id_priv->reuseaddr": {
        "description": "Once the ID reaches RDMA_CM_LISTEN it is not allowed to be reusable any more, and has to be unique in the bind list.",
        "proto" :"if (id_priv->reuseaddr)",
        "pre": {
            "id_priv->reuseaddr": "in [0, 1]",
        },
    }
},
{
    "kprobe:rdma_bind_addr": {
        "description": "Once the ID reaches RDMA_CM_LISTEN it is not allowed to be reusable any more, and has to be unique in the bind list.",
        "proto" :"static int (*rdma_bind_addr)(struct rdma_cm_id *id, struct sockaddr *addr)",
        "pre": {
            "id": "!=null",
            "addr": "!=null"
        },
    },
    "kprobe:id_priv->reuseaddr": {
        "description": "Checks if the ID is reusable.",
        "proto" :"static int (*id_priv->reuseaddr)()",
        "pre": {
            "id_priv": "!=null"
        },
    }
},
{
    "kretprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request. Same as rdma_connect() but can only be called from the RDMA_CM_EVENT_ROUTE_RESOLVED handler callback.",
        "proto" :"int (*rdma_connect_locked)(struct rdma_cm_id *id, struct rdma_conn_param *conn_param)",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_locked": {
        "description": "Initiate an active connection request. Same as rdma_connect() but can only be called from the RDMA_CM_EVENT_ROUTE_RESOLVED handler callback.",
        "proto" :"int (*rdma_connect_locked)(struct rdma_cm_id *id, struct rdma_conn_param *conn_param)",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null"
        },
    }
},
{
    "kretprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "proto" :"int (*rdma_connect_ece)(struct rdma_cm_id *id, struct rdma_conn_param *conn_param, struct rdma_ucm_ece *ece)",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        }
    }
},
{
    "kprobe:rdma_connect_ece": {
        "description": "Initiate an active connection request with ECE data.",
        "proto" :"int (*rdma_connect_ece)(struct rdma_cm_id *id, struct rdma_conn_param *conn_param, struct rdma_ucm_ece *ece)",
        "pre": {
            "id": "!=null",
            "conn_param": "!=null",
            "ece": "!=null"
        },
    }
},
{
    "kretprobe:trace_cm_disconnect": {
        "description": "Please fill in the description here.",
        "proto" :"Please fill in the prototype here.",
        "pre": {
            "id_priv": "Please fill in the condition here.",
        },
    },
    "kretprobe:ib_send_cm_dreq": {
        "description": "Please fill in the description here.",
        "proto" :"Please fill in the prototype here.",
        "pre": {
            "id_priv->cm_id.ib": "Please fill in the condition here.",
            "NULL": "Please fill in the condition here.",
            "0": "Please fill in the condition here.",
        },
    }
},
{
    "kprobe:trace_cm_disconnect": {
        "description": "Initiate or respond to a disconnect.",
        "proto" :"static long (*trace_cm_disconnect)(struct rdma_id_private *id_priv)",
        "pre": {
            "id_priv": "!=null",
            "id_priv->cm_id.ib": "!=null"
        },
    },
    "kprobe:ib_send_cm_dreq": {
        "description": "Send a disconnect request.",
        "proto" :"static long (*ib_send_cm_dreq)(struct ib_cm_id *cm_id, const void *private_data, __u8 private_data_len)",
        "pre": {
            "cm_id": "!=null",
            "private_data": "==null",
            "private_data_len": "==0"
        },
    }
},
{
    "kretprobe:rdma_join_multicast": {
        "description": "Not supported for kernel QPs",
        "proto" :"rdma_join_multicast(struct rdma_cm_id  id, struct sockaddr  addr,u8 join_state, void  context)",
        "pre": {
            "id": "!=null",
            "addr": "!=null",
            "join_state": "in [0, 1]",
            "context": "!=null"
        },
    }
},
{
    "kprobe:rdma_join_multicast": {
        "description": "Not supported for kernel QPs",
        "proto" :"rdma_join_multicast(struct rdma_cm_id  id, struct sockaddr  addr,u8 join_state, void  context)",
        "pre": {
            "id": "!=null",
            "addr": "!=null",
            "join_state": "in [0, 255]", // Assuming u8 is an 8-bit unsigned integer
            "context": "can be null or !=null", // Assuming context can be null
        },
    }
},
{
    "kretprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for the following RDMA operation. Permit is used to preallocate all resources and to propagate memory pressure up earlier. Can sleep if @wait == RTRS_PERMIT_WAIT",
        "proto" :"struct rtrs_permit *(*rtrs_clt_get_permit)(struct rtrs_clt_sess *clt,  enum rtrs_clt_con_type con_type,  enum wait_type can_wait)",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, ...]", // replace with actual enum values
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NOWAIT]" // replace with actual enum values
        },
    }
},
{
    "kprobe:rtrs_clt_get_permit": {
        "description": "Allocates permit for the following RDMA operation. Permit is used to preallocate all resources and to propagate memory pressure up earlier. Can sleep if @wait == RTRS_PERMIT_WAIT",
        "proto" :"struct rtrs_permit *(*rtrs_clt_get_permit)(struct rtrs_clt_sess *clt,  enum rtrs_clt_con_type con_type,  enum wait_type can_wait)",
        "pre": {
            "clt": "!=null",
            "con_type": "in [RTRS_CLT_CON_TYPE_1, RTRS_CLT_CON_TYPE_2, ...]", // replace with actual enum values
            "can_wait": "in [RTRS_PERMIT_WAIT, RTRS_PERMIT_NOWAIT]", // replace with actual enum values
        },
    }
},
{
    "kretprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit. @clt: Current session. @permit: Permit to be freed. Context: Does not matter.",
        "proto" :"void (*rtrs_clt_put_permit)(struct rtrs_clt_sess *clt, struct rtrs_permit *permit)",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},
{
    "kprobe:rtrs_clt_put_permit": {
        "description": "Puts allocated permit. @clt: Current session. @permit: Permit to be freed. Context: Does not matter.",
        "proto" :"void (*rtrs_clt_put_permit)(struct rtrs_clt_sess *clt, struct rtrs_permit *permit)",
        "pre": {
            "clt": "!=null",
            "permit": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_clt_open": {
        "description": "Manage connections. Each was disconnected and the first one connected again. That's why this nasty game with counter value.",
        "proto" :"static long (*rtrs_clt_open)(parameters...)",
        "pre": {
            "param1": "condition1",
            "param2": "condition2",
            ...
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your condition for arg1",
            "arg2": "Your condition for arg2",
            "arg3": "Your condition for arg3",
            // Add more arguments as needed
        },
    }
},
{
    "kretprobe:alloc_path": {
        "description": "Allocates a path for the rtrs_clt_sess",
        "proto" :"static struct rtrs_clt_path* (*alloc_path)(struct rtrs_clt_sess* clt, const struct rtrs_addr* path, size_t con_num, u32 nr_poll_queues)",
        "pre": {
            "clt": "!=null",
            "path": "!=null",
            "con_num": ">=0",
            "nr_poll_queues": ">=0"
        },
    }
},

{
    "kretprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA. On dir=READ rtrs client will request a data transfer from Server to client. The data that the server will respond with will be stored in @sg when the user receives an %RTRS_CLT_RDMA_EV_RDMA_REQUEST_WRITE_COMPL event. On dir=WRITE rtrs client will rdma write data in sg to server side.",
        "proto" :"int rtrs_clt_request(int dir, struct rtrs_clt_req_ops *ops, struct rtrs_clt_sess *clt, struct rtrs_permit *permit, const struct kvec *vec, size_t nr, size_t data_len, struct scatterlist *sg, unsigned int sg_cnt)",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:rtrs_clt_request": {
        "description": "Request data transfer to/from server via RDMA. On dir=READ rtrs client will request a data transfer from Server to client. The data that the server will respond with will be stored in @sg when the user receives an %RTRS_CLT_RDMA_EV_RDMA_REQUEST_WRITE_COMPL event. On dir=WRITE rtrs client will rdma write data in sg to server side.",
        "proto" :"int rtrs_clt_request(int dir, struct rtrs_clt_req_ops *ops, struct rtrs_clt_sess *clt, struct rtrs_permit *permit, const struct kvec *vec, size_t nr, size_t data_len, struct scatterlist *sg, unsigned int sg_cnt)",
        "pre": {
            "dir": "in [READ, WRITE]",
            "ops": "!=null",
            "clt": "!=null",
            "permit": "!=null",
            "vec": "!=null",
            "nr": ">=0",
            "data_len": ">=0",
            "sg": "!=null",
            "sg_cnt": ">=0"
        }
    }
},

{
    "kprobe:rtrs_clt_rdma_cq_direct": {
        "description": "If no path, return -1 for block layer not to try again",
        "proto" :"int rtrs_clt_rdma_cq_direct(struct rtrs_clt_sess clt, unsigned int index)",
        "pre": {
            "clt": "!=null",
            "index": "is a valid index in the range of the paths array"
        },
    }
},
{
    "kretprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes. Returns 0 on success, -ECOMM if there is no connection to the server.",
        "proto" :"int rtrs_clt_query(struct rtrs_clt_sess *clt, struct rtrs_attrs *attr)",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        }
    }
},
{
    "kprobe:rtrs_clt_query": {
        "description": "Queries RTRS session attributes. Returns 0 on success, -ECOMM if no connection to the server.",
        "proto" :"int (*rtrs_clt_query)(struct rtrs_clt_sess *clt, struct rtrs_attrs *attr)",
        "pre": {
            "clt": "!=null",
            "attr": "!=null"
        },
    }
},
{
    "kretprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA operation. A message is sent to the client and the corresponding memory areas will be released.",
        "proto" :"bool (*rtrs_srv_resp_rdma)(struct rtrs_srv_op *id, int status)",
        "pre": {
            "id": "!=null",
            "status": "in [0, <=0]"
        },
    }
},
{
    "kprobe:rtrs_srv_resp_rdma": {
        "description": "Finish an RDMA operation. A message is sent to the client and the corresponding memory areas will be released.",
        "proto" :"bool (*rtrs_srv_resp_rdma)(struct rtrs_srv_op *id, int status)",
        "pre": {
            "id": "!=null",
            "status": "integer"
        },
    }
},
{
    "kretprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv. @srv:Session pointer @priv:The private pointer that is associated with the session.",
        "proto" :"void (*rtrs_srv_set_sess_priv)(struct rtrs_srv_sess *srv, void *priv)",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:rtrs_srv_set_sess_priv": {
        "description": "Set private pointer in rtrs_srv. @srv:Session pointer @priv:The private pointer that is associated with the session.",
        "proto" :"void (*rtrs_srv_set_sess_priv)(struct rtrs_srv_sess *srv, void *priv)",
        "pre": {
            "srv": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname. @srv:Session @pathname:Pathname buffer @len:Length of sessname buffer",
        "proto" :"int (*rtrs_srv_get_path_name)(struct rtrs_srv_sess *srv, char *pathname, size_t len)",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">0"
        },
    }
},
{
    "kprobe:rtrs_srv_get_path_name": {
        "description": "Get rtrs_srv peer hostname. @srv:Session @pathname:Pathname buffer @len:Length of sessname buffer",
        "proto" :"int (*rtrs_srv_get_path_name)(struct rtrs_srv_sess *srv, char *pathname, size_t len)",
        "pre": {
            "srv": "!=null",
            "pathname": "!=null",
            "len": ">0"
        }
    }
},
{
    "kretprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth. @srv:Session",
        "proto" :"int rtrs_srv_get_queue_depth(struct rtrs_srv_sess *srv)",
        "pre": {
            "srv": "!=null",
        },
    }
},
{
    "kprobe:rtrs_srv_get_queue_depth": {
        "description": "Get rtrs_srv qdepth. @srv:Session",
        "proto" :"int rtrs_srv_get_queue_depth(struct rtrs_srv_sess *srv)",
        "pre": {
            "srv": "!=null"
        }
    }
},
{
    "kretprobe:rtrs_srv_open": {
        "description": "Creates server context with specified callbacks. Return a valid pointer on success otherwise PTR_ERR.",
        "proto" :"struct rtrs_srv_ctx *(*rtrs_srv_open)(struct rtrs_srv_ops *ops, u16 port)",
        "pre": {
            "ops": "!=null",
            "port": ">=0 && <=65535"
        },
    }
},
{
    "kprobe:rtrs_srv_open": {
        "description": "Creates server context with specified callbacks. Return a valid pointer on success otherwise PTR_ERR.",
        "proto" :"struct rtrs_srv_ctx *(*rtrs_srv_open)(struct rtrs_srv_ops *ops, u16 port)",
        "pre": {
            "ops": "!=null",
            "port": ">=0 && <=65535"
        }
    }
},
{
    "kretprobe:percpu_ref_kill": {
        "description": "Decrements the reference count of the percpu_ref object and waits for all in-flight references to complete.",
        "proto" :"void (*percpu_ref_kill)(struct percpu_ref *ref)",
        "pre": {
            "ref": "!=null"
        }
    }
},

{
    "kretprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string. The return value is the number of characters written into buf not including the trailing '\\0'. If len is == 0 the function returns 0.",
        "proto" :"int (*sockaddr_to_str)(const struct sockaddr *addr, char *buf, size_t len)",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": ">=0 && <=len"
        }
    }
},
{
    "kprobe:sockaddr_to_str": {
        "description": "Convert sockaddr to a string. The return value is the number of characters written into buf not including the trailing '\\0'. If len is == 0 the function returns 0.",
        "proto" :"int (*sockaddr_to_str)(const struct sockaddr *addr, char *buf, size_t len)",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'. The return value is the number of characters written into buf not including the trailing '\\0'.",
        "proto" :"int rtrs_addr_to_str(const struct rtrs_addr *addr, char *buf, size_t len)",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": ">0"
        }
    }
},
{
    "kprobe:rtrs_addr_to_str": {
        "description": "Convert rtrs_addr to a string 'src@dst'. The return value is the number of characters written into buf not including the trailing '\\0'.",
        "proto" :"int (*rtrs_addr_to_str)(const struct rtrs_addr *addr, char *buf, size_t len)",
        "pre": {
            "addr": "!=null",
            "buf": "!=null",
            "len": "> 0"
        }
    }
},
{
    "kretprobe:rtrs_addr_to_sockaddr": {
        "description": "Convert path string 'src,dst' or 'src@dst' to sockaddreses. If str contains only one address it's considered to be destination. Returns zero if conversion successful. Non-zero otherwise.",
        "proto" :"int (*rtrs_addr_to_sockaddr)(const char *str, size_t len, u16 port, struct rtrs_addr *addr)",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "!=null"
        },
    }
},
{
    "kprobe:rtrs_addr_to_sockaddr": {
        "description": "Convert path string 'src,dst' or 'src@dst' to sockaddreses. If str contains only one address it's considered to be destination. Returns zero if conversion successful. Non-zero otherwise.",
        "proto" :"int (*rtrs_addr_to_sockaddr)(const char *str, size_t len, u16 port, struct rtrs_addr *addr)",
        "pre": {
            "str": "!=null",
            "len": ">=0",
            "port": ">=0",
            "addr": "can be null or !=null"
        },
    }
},
{
    "kretprobe:btbcm_patchram": {
        "description": "Your function description here",
        "proto" :"static long (*btbcm_patchram)(struct hci_dev hdev, const struct firmware fw, const struct hci_command_hdr cmd, const u8 fw_ptr, size_t fw_size, struct sk_buff skb, u16 opcode, int err)",
        "pre": {
            "hdev": "Your condition here",
            "fw": "Your condition here",
            "cmd": "Your condition here",
            "fw_ptr": "Your condition here",
            "fw_size": "Your condition here",
            "skb": "Your condition here",
            "opcode": "Your condition here",
            "err": "Your condition here"
        },
    }
},

{
    "kretprobe:vme_alloc_consistent": {
        "description": "Allocate a contiguous block of memory for use by the driver. This is used to create the buffers for the slave windows.",
        "proto" :"void *(*vme_alloc_consistent)(struct vme_resource *resource, size_t size, dma_addr_t *dma)",
        "pre": {
            "resource": "!=null",
            "size": ">0",
            "dma": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_alloc_consistent": {
        "description": "Allocate a contiguous block of memory for use by the driver. This is used to create the buffers for the slave windows.",
        "proto" :"void *(*vme_alloc_consistent)(struct vme_resource *resource, size_t size, dma_addr_t *dma)",
        "pre": {
            "resource": "!=null",
            "size": ">0",
            "dma": "!=null"
        },
    }
},
{
    "kretprobe:vme_free_consistent": {
        "description": "Free previously allocated block of contiguous memory.",
        "proto" :"void (*vme_free_consistent)(struct vme_resource *resource, size_t size, void *vaddr, dma_addr_t dma)",
        "pre": {
            "resource": "!=null",
            "size": ">0",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kprobe:vme_free_consistent": {
        "description": "Free previously allocated block of contiguous memory.",
        "proto" :"void (*vme_free_consistent)(struct vme_resource *resource, size_t size, void *vaddr, dma_addr_t dma)",
        "pre": {
            "resource": "!=null",
            "size": ">0",
            "vaddr": "!=null",
            "dma": "!=null"
        }
    }
},
{
    "kretprobe:vme_get_size": {
        "description": "vme_master_get or vme_slave_get depending on the type of window resource handed to it. Return: Size of the window on success, zero on failure.",
        "proto" :"size_t (*vme_get_size)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:vme_get_size": {
        "description": "vme_master_get or vme_slave_get depending on the type of window resource handed to it. Return: Size of the window on success, zero on failure.",
        "proto" :"size_t (*vme_get_size)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_check_window": {
        "description": "Check the VME window size and base, return -EINVAL if the base + size < size, return -EFAULT if the base + size > MAX limit of the aspace.",
        "proto" :"int (*vme_check_window)(u32 aspace, unsigned long long vme_base, unsigned long long size)",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64, VME_CRCSR, VME_USER1, VME_USER2, VME_USER3, VME_USER4]",
            "vme_base": ">=0",
            "size": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, -EFAULT, 0]"
        }
    }
},
{
    "kprobe:vme_check_window": {
        "description": "Check if the VME window defined by the base address and size is valid for the given address space. Returns 0 if valid, -EINVAL if the size is too large, or -EFAULT if the base address plus size exceeds the maximum for the given address space.",
        "proto" :"int (*vme_check_window)(u32 aspace, unsigned long long vme_base, unsigned long long size)",
        "pre": {
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "vme_base": ">=0",
            "size": ">=0 && size <= U64_MAX"
        },
    }
},
{
    "kretprobe:vme_slave_request": {
        "description": "Request use of a VME window resource capable of being set for the requested address space and data transfer cycle.",
        "proto" :"struct vme_resource *(*vme_slave_request)(struct vme_dev *vdev, u32 address, u32 cycle)",
        "pre": {
            "vdev": "!=null",
            "address": ">=0",
            "cycle": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_request": {
        "description": "Request a VME slave window resource. Request use of a VME window resource capable of being set for the requested address space and data transfer cycle.",
        "proto" :"struct vme_resource *(*vme_slave_request)(struct vme_dev *vdev, u32 address, u32 cycle)",
        "pre": {
            "vdev": "!=null",
            "address": "is a valid VME address space",
            "cycle": "is a valid VME data transfer cycle type"
        },
    }
},
{
    "kretprobe:vme_slave_set": {
        "description": "Set configuration for provided VME slave window.",
        "proto" :"int vme_slave_set(struct vme_resource *resource, int enabled, unsigned long long vme_base, unsigned long long size, dma_addr_t buf_base, u32 aspace, u32 cycle)",
        "pre": {
            "resource": "!=null",
            "enabled": "in [0, 1]",
            "vme_base": ">=0",
            "size": ">0",
            "buf_base": ">=0",
            "aspace": ">=0",
            "cycle": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_slave_set": {
        "description": "Set VME slave window configuration.",
        "proto" :"int (*vme_slave_set)(struct vme_resource *resource, int enabled, unsigned long long vme_base, unsigned long long size, dma_addr_t buf_base, u32 aspace, u32 cycle)",
        "pre": {
            "resource": "!=null",
            "enabled": "in [0, 1]",
            "vme_base": ">=0",
            "size": ">=0",
            "buf_base": ">=0",
            "aspace": ">=0",
            "cycle": ">=0"
        },
    }
},
{
    "kretprobe:vme_slave_free": {
        "description": "Free VME slave window. Free the provided slave resource so that it may be reallocated.",
        "proto" :"void (*vme_slave_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_slave_free": {
        "description": "Free VME slave window. Free the provided slave resource so that it may be reallocated.",
        "proto" :"void (*vme_slave_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null",
        },
    }
},
{
    "kretprobe:vme_master_request": {
        "description": "Request use of a VME window resource capable of being set for the requested address space, data transfer cycle and width.",
        "proto" :"struct vme_resource *(*vme_master_request)(struct vme_dev *vdev, u32 address, u32 cycle, u32 dwidth)",
        "pre": {
            "vdev": "!=null",
            "address": ">=0",
            "cycle": ">=0",
            "dwidth": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_master_request": {
        "description": "Request use of a VME window resource capable of being set for the requested address space, data transfer cycle and width.",
        "proto" :"struct vme_resource *(*vme_master_request)(struct vme_dev *vdev, u32 address, u32 cycle, u32 dwidth)",
        "pre": {
            "vdev": "!=null",
            "address": "is a valid VME address space",
            "cycle": "is a valid VME data transfer cycle type",
            "dwidth": "is a valid VME data transfer width"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_master_set": {
        "description": "Set configuration for provided VME master window.",
        "proto" :"int vme_master_set(struct vme_resource *resource, int enabled, unsigned long long vme_base, unsigned long long size, u32 aspace, u32 cycle, u32 dwidth)",
        "pre": {
            "resource": "!=null",
            "enabled": "in [0, 1]",
            "vme_base": ">=0",
            "size": ">0",
            "aspace": ">=0",
            "cycle": ">=0",
            "dwidth": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_master_set": {
        "description": "Set VME master window configuration.",
        "proto" :"int (*vme_master_set)(struct vme_resource *resource, int enabled, unsigned long long vme_base, unsigned long long size, u32 aspace, u32 cycle, u32 dwidth)",
        "pre": {
            "resource": "!=null",
            "enabled": "in [0, 1]",
            "vme_base": ">=0",
            "size": ">=0",
            "aspace": ">=0",
            "cycle": ">=0",
            "dwidth": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kretprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer. Perform read of count bytes of data from location on VME bus which maps into the VME master window at offset to buf.",
        "proto" :"ssize_t (*vme_master_read)(struct vme_resource *resource, void *buf, size_t count, loff_t offset)",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, -EFAULT, 0, count]"
        }
    }
},
{
    "kprobe:vme_master_read": {
        "description": "Read data from VME space into a buffer. Perform read of count bytes of data from location on VME bus which maps into the VME master window at offset to buf.",
        "proto" :"ssize_t (*vme_master_read)(struct vme_resource *resource, void *buf, size_t count, loff_t offset)",
        "pre": {
            "resource": "!=null && is a VME master resource",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0 && valid in the VME master window"
        },
        "post": {
            "return": "Number of bytes read, -EINVAL if resource is not a VME master resource or read operation is not supported. -EFAULT returned if invalid offset is provided. Hardware specific errors may also be returned."
        }
    }
},
{
    "kretprobe:vme_master_write": {
        "description": "Perform write of count bytes of data from buf to location on VME bus which maps into the VME master window at offset.",
        "proto" :"ssize_t (*vme_master_write)(struct vme_resource *resource, void *buf, size_t count, loff_t offset)",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, -EFAULT, count]"
        }
    }
},
{
    "kprobe:vme_master_write": {
        "description": "Write data out to VME space from a buffer. Perform write of count bytes of data from buf to location on VME bus which maps into the VME master window at offset.",
        "proto" :"ssize_t (*vme_master_write)(struct vme_resource *resource, void *buf, size_t count, loff_t offset)",
        "pre": {
            "resource": "!=null",
            "buf": "!=null",
            "count": ">=0",
            "offset": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, -EFAULT, count]"
        }
    }
},
{
    "kretprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle on provided location. Location on VME bus is read. Bits selected by mask are compared with compare. Where a selected bit matches that in compare and are selected in swap, the bit is swapped. Result written back to location on VME bus. Return: Bytes written on success, -EINVAL if resource is not a VME master resource or RMW operation is not supported. Hardware specific errors may also be returned.",
        "proto" :"unsigned int (*vme_master_rmw)(struct vme_resource *resource, unsigned int mask, unsigned int compare, unsigned int swap, loff_t offset)",
        "pre": {
            "resource": "!=null",
            "mask": "is a valid unsigned int",
            "compare": "is a valid unsigned int",
            "swap": "is a valid unsigned int",
            "offset": "is a valid loff_t"
        },
    }
},
{
    "kprobe:vme_master_rmw": {
        "description": "Perform read-modify-write cycle on provided location. Location on VME bus is read. Bits selected by mask are compared with compare. Where a selected bit matches that in compare and are selected in swap, the bit is swapped. Result written back to location on VME bus. Return: Bytes written on success, -EINVAL if resource is not a VME master resource or RMW operation is not supported. Hardware specific errors may also be returned.",
        "proto" :"unsigned int (*vme_master_rmw)(struct vme_resource *resource, unsigned int mask, unsigned int compare, unsigned int swap, loff_t offset)",
        "pre": {
            "resource": "!=null",
            "mask": "is unsigned int",
            "compare": "is unsigned int",
            "swap": "is unsigned int",
            "offset": "is loff_t"
        },
    }
},
{
    "kretprobe:vme_master_mmap": {
        "description": "Memory map a region of the VME master window into user space. Return: Zero on success, -EINVAL if resource is not a VME master resource or -EFAULT if map exceeds window size. Other generic mmap errors may also be returned.",
        "proto" :"int vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma)",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EFAULT]"
        }
    }
},
{
    "kprobe:vme_master_mmap": {
        "description": "Memory map a region of the VME master window into user space.",
        "proto" :"int vme_master_mmap(struct vme_resource *resource, struct vm_area_struct *vma)",
        "pre": {
            "resource": "!=null",
            "vma": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EFAULT]"
        },
        "error": {
            "-EINVAL": "resource is not a VME master resource",
            "-EFAULT": "map exceeds window size"
        }
    }
},
{
    "kretprobe:vme_master_free": {
        "description": "Free VME master window. Free the provided master resource so that it may be reallocated.",
        "proto" :"void (*vme_master_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:vme_master_free": {
        "description": "Free the provided master resource so that it may be reallocated.",
        "proto" :"void (*vme_master_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_request": {
        "description": "Request a VME DMA controller with capability to perform transfers between requested source/destination combination.",
        "proto": "struct vme_resource *(*vme_dma_request)(struct vme_dev *vdev, u32 route)",
        "pre": {
            "vdev": "!=null",
            "route": "is a valid src/destination combination"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_request": {
        "description": "Request a VME DMA controller with capability to perform transfers between requested source/destination combination.",
        "proto" :"struct vme_resource *(*vme_dma_request)(struct vme_dev *vdev, u32 route)",
        "pre": {
            "vdev": "!=null",
            "route": "is a valid u32 value"
        },
    }
},
{
    "kretprobe:vme_new_dma_list": {
        "description": "Return: Pointer to new VME DMA list, NULL on allocation failure or invalid VME DMA resource.",
        "proto" :"struct vme_dma_list *(*vme_new_dma_list)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "!=null || (resource == null || allocation failure || invalid VME DMA resource)"
        }
    }
},
{
    "kprobe:vme_new_dma_list": {
        "description": "Return: Pointer to new VME DMA list, NULL on allocation failure or invalid VME DMA resource.",
        "proto" :"struct vme_dma_list *(*vme_new_dma_list)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_pattern_attribute": {
        "description": "Return: Pointer to VME DMA attribute, NULL on failure.",
        "proto" :"struct vme_dma_attr *(*vme_dma_pattern_attribute)(u32 pattern, u32 type)",
        "pre": {
            "pattern": "is u32",
            "type": "is u32"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:vme_dma_pattern_attribute": {
        "description": "Return: Pointer to VME DMA attribute, NULL on failure.",
        "proto" :"struct vme_dma_attr *(*vme_dma_pattern_attribute)(u32 pattern, u32 type)",
        "pre": {
            "pattern": "!=null",
            "type": "!=null"
        },
    }
},
{
    "kretprobe:vme_dma_pci_attribute": {
        "description": "Create VME DMA list attribute pointing to a location on PCI for DMA transfers. It is the responsibility of the user to free used attributes using vme_dma_free_attribute().",
        "proto" :"struct vme_dma_attr *(*vme_dma_pci_attribute)(dma_addr_t address)",
        "pre": {
            "address": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_pci_attribute": {
        "description": "Create VME DMA list attribute pointing to a location on PCI for DMA transfers. It is the responsibility of the user to free used attributes using vme_dma_free_attribute().",
        "proto" :"struct vme_dma_attr *(*vme_dma_pci_attribute)(dma_addr_t address)",
        "pre": {
            "address": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_vme_attribute": {
        "description": "Create VME DMA list attribute pointing to a location on the VME bus for DMA transfers. It is the responsibility of the user to free used attributes using vme_dma_free_attribute().",
        "proto" :"struct vme_dma_attr *(*vme_dma_vme_attribute)(unsigned long long address, u32 aspace, u32 cycle, u32 dwidth)",
        "pre": {
            "address": ">=0",
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64]",
            "cycle": "in [VME_SCT, VME_BLT, VME_MBLT, VME_2eVME, VME_2eSST, VME_2eSSTB]",
            "dwidth": "in [VME_D8, VME_D16, VME_D32, VME_D64]"
        },
    }
},
{
    "kprobe:vme_dma_vme_attribute": {
        "description": "Create VME DMA list attribute pointing to a location on the VME bus for DMA transfers. It is the responsibility of the user to free used attributes using vme_dma_free_attribute().",
        "proto" :"struct vme_dma_attr *(*vme_dma_vme_attribute)(unsigned long long address, u32 aspace, u32 cycle, u32 dwidth)",
        "pre": {
            "address": ">=0",
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64, VME_CRCSR, VME_USER1, VME_USER2]",
            "cycle": "in [VME_SCT, VME_BLT, VME_MBLT, VME_2eVME, VME_2eSST, VME_2eSSTB]",
            "dwidth": "in [VME_D8, VME_D16, VME_D32, VME_D64]"
        },
    }
},
{
    "kretprobe:vme_dma_free_attribute": {
        "description": "vme_dma_list_add() has returned.",
        "proto" :"void (*vme_dma_free_attribute)(struct vme_dma_attr *attributes)",
        "pre": {
            "attributes": "!=null"
        }
    }
},
{
    "kprobe:vme_dma_free_attribute": {
        "description": "vme_dma_list_add() has returned.",
        "proto" :"void (*vme_dma_free_attribute)(struct vme_dma_attr *attributes)",
        "pre": {
            "attributes": "!=null"
        }
    }
},
{
    "kretprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution. The call will return once the list has been executed.",
        "proto" :"int vme_dma_list_exec(struct vme_dma_list *list)",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_dma_list_exec": {
        "description": "Queue a VME DMA list for execution. The call will return once the list has been executed. Return: Zero on success, -EINVAL if operation is not supported on this device. Hardware specific errors also possible.",
        "proto" :"int vme_dma_list_exec(struct vme_dma_list *list)",
        "pre": {
            "list": "!=null"
        },
    }
},
{
    "kretprobe:vme_irq_request": {
        "description": "Request callback to be attached as a handler for VME interrupts with provided level and statid.",
        "proto" :"int vme_irq_request(struct vme_dev *vdev, int level, int statid, void (*callback)(int, int, void *), void *priv_data)",
        "pre": {
            "vdev": "!=null",
            "level": ">=0",
            "statid": ">=0",
            "callback": "!=null",
            "priv_data": "can be null or !=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:vme_irq_request": {
        "description": "Request a specific VME interrupt. Request callback to be attached as a handler for VME interrupts with provided level and statid. Return: Zero on success, -EINVAL on invalid vme device, level or if the function is not supported, -EBUSY if the levelstatid combination is already in use. Hardware specific errors also possible.",
        "proto" :"int (*vme_irq_request)(struct vme_dev *vdev, int level, int statid, void (*callback)(int, int, void *), void *priv_data)",
        "pre": {
            "vdev": "!=null",
            "level": ">=0",
            "statid": ">=0",
            "callback": "!=null",
            "priv_data": "can be null or !=null"
        },
    }
},
{
    "kretprobe:vme_irq_free": {
        "description": "Free a VME interrupt. Remove previously attached callback from VME interrupt priority vector.",
        "proto" :"void vme_irq_free(struct vme_dev *vdev, int level, int statid)",
        "pre": {
            "vdev": "!=null",
            "level": ">=0",
            "statid": ">=0"
        }
    }
},
{
    "kprobe:vme_irq_free": {
        "description": "Free a VME interrupt. Remove previously attached callback from VME interrupt priority vector.",
        "proto" :"void (*vme_irq_free)(struct vme_dev *vdev, int level, int statid)",
        "pre": {
            "vdev": "!=null",
            "level": "!=null",
            "statid": "!=null"
        },
    }
},
{
    "kretprobe:vme_irq_generate": {
        "description": "Generate a VME interrupt of the provided level and with the provided statid.",
        "proto" :"int vme_irq_generate(struct vme_dev *vdev, int level, int statid)",
        "pre": {
            "vdev": "!=null",
            "level": "in [1, 7]",
            "statid": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_irq_generate": {
        "description": "Generate a VME interrupt of the provided level and with the provided statid.",
        "proto" :"int (*vme_irq_generate)(struct vme_dev *vdev, int level, int statid)",
        "pre": {
            "vdev": "!=null",
            "level": ">=0",
            "statid": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:vme_lm_request": {
        "description": "Request a VME location monitor. Allocate a location monitor resource to the driver. A location monitor allows the driver to monitor accesses to a contiguous number of addresses on the VME bus.",
        "proto" :"struct vme_resource *(*vme_lm_request)(struct vme_dev *vdev)",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:vme_lm_request": {
        "description": "Request a VME location monitor. Allocate a location monitor resource to the driver. A location monitor allows the driver to monitor accesses to a contiguous number of addresses on the VME bus.",
        "proto" :"struct vme_resource *(*vme_lm_request)(struct vme_dev *vdev)",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored. The number of contiguous addresses monitored is hardware dependent. Return the number of contiguous addresses monitored by the location monitor. Return: Count of addresses monitored or -EINVAL when provided with an invalid location monitor resource.",
        "proto" :"int (*vme_lm_count)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": ">=0 || ==-EINVAL"
        }
    }
},
{
    "kprobe:vme_lm_count": {
        "description": "Determine number of VME Addresses monitored. The number of contiguous addresses monitored is hardware dependent. Return the number of contiguous addresses monitored by the location monitor. Return: Count of addresses monitored or -EINVAL when provided with an invalid location monitor resource.",
        "proto" :"int vme_lm_count(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_lm_set": {
        "description": "Set the base address, address space and cycle type of accesses to be monitored by the location monitor. Return: Zero on success, -EINVAL when provided with an invalid location monitor resource or function is not supported. Hardware specific errors may also be returned.",
        "proto" :"int vme_lm_set(struct vme_resource *resource, unsigned long long lm_base, u32 aspace, u32 cycle)",
        "pre": {
            "resource": "!=null",
            "lm_base": ">=0",
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64, VME_CRCSR, VME_USER1, VME_USER2]",
            "cycle": "in [VME_SCT, VME_BLT, VME_MBLT, VME_2eVME, VME_2eSST, VME_2eSSTB]"
        },
    }
},
{
    "kprobe:vme_lm_set": {
        "description": "Set the base address, address space and cycle type of accesses to be monitored by the location monitor.",
        "proto" :"int vme_lm_set(struct vme_resource *resource, unsigned long long lm_base, u32 aspace, u32 cycle)",
        "pre": {
            "resource": "!=null",
            "lm_base": ">=0",
            "aspace": "in [VME_A16, VME_A24, VME_A32, VME_A64, VME_CRCSR, VME_USER1, VME_USER2]",
            "cycle": "in [VME_SCT, VME_BLT, VME_MBLT, VME_2eVME, VME_2eSST, VME_2eSSTB]"
        },
        "post": {
            "return": "in [0, -EINVAL, -EIO, -ENODEV, -ENXIO, -EPERM]"
        }
    }
},
{
    "kretprobe:vme_lm_get": {
        "description": "Retrieve the base address, address space and cycle type of accesses to be monitored by the location monitor.",
        "proto" :"int vme_lm_get(struct vme_resource *resource, unsigned long long *lm_base, u32 *aspace, u32 *cycle)",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_lm_get": {
        "description": "Retrieve the base address, address space and cycle type of accesses to be monitored by the location monitor.",
        "proto" :"int (*vme_lm_get)(struct vme_resource *resource, unsigned long long *lm_base, u32 *aspace, u32 *cycle)",
        "pre": {
            "resource": "!=null",
            "lm_base": "!=null",
            "aspace": "!=null",
            "cycle": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:vme_lm_attach": {
        "description": "Attach a callback to the specificed offset into the location monitors monitored addresses. A generic pointer is provided to allow data to be passed to the callback when called.",
        "proto" :"int vme_lm_attach(struct vme_resource *resource, int monitor,void (*callback)(void *), void *data)",
        "pre": {
            "resource": "!=null",
            "monitor": "is integer",
            "callback": "!=null",
            "data": "can be any value"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_lm_attach": {
        "description": "Attach a callback to the specificed offset into the location monitors monitored addresses. A generic pointer is provided to allow data to be passed to the callback when called.",
        "proto" :"int vme_lm_attach(struct vme_resource *resource, int monitor,void (*callback)(void *), void *data)",
        "pre": {
            "resource": "!=null",
            "monitor": ">=0",
            "callback": "!=null",
            "data": "can be null or !=null",
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kretprobe:vme_lm_detach": {
        "description": "Remove the callback associated with the specificed offset into the location monitors monitored addresses.",
        "proto" :"int (*vme_lm_detach)(struct vme_resource *resource, int monitor)",
        "pre": {
            "resource": "!=null",
            "monitor": ">=0"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_lm_detach": {
        "description": "Remove callback for location monitor address. Remove the callback associated with the specificed offset into the location monitors monitored addresses.",
        "proto" :"int (*vme_lm_detach)(struct vme_resource *resource, int monitor)",
        "pre": {
            "resource": "!=null",
            "monitor": ">=0",
        },
    }
},
{
    "kretprobe:vme_lm_free": {
        "description": "Free allocation of a VME location monitor. WARNING: This function currently expects that any callbacks that have been attached to the location monitor have been removed.",
        "proto" :"void (*vme_lm_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vme_lm_free": {
        "description": "Free allocation of a VME location monitor. WARNING: This function currently expects that any callbacks that have been attached to the location monitor have been removed. Return: Zero on success, -EINVAL when provided with an invalid location monitor resource.",
        "proto" :"void (*vme_lm_free)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:vme_slot_num": {
        "description": "Retrieve the slot ID associated with the provided VME device. Returns the slot ID on success, -EINVAL if VME bridge cannot be determined or the function is not supported. Hardware specific errors may also be returned.",
        "proto" :"int vme_slot_num(struct vme_dev *vdev)",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return": "in [valid slot ID, -EINVAL, hardware specific errors]"
        }
    }
},
{
    "kprobe:vme_slot_num": {
        "description": "Retrieve the slot ID associated with the provided VME device.",
        "proto" :"int (*vme_slot_num)(struct vme_dev *vdev)",
        "pre": {
            "vdev": "!=null"
        },
        "post": {
            "return": "in [The slot ID on success, -EINVAL if VME bridge cannot be determined or the function is not supported. Hardware specific errors may also be returned.]"
        }
    }
},
{
    "kretprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "proto" :"static struct vme_bridge *(*find_bridge)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kprobe:find_bridge": {
        "description": "Find the bridge that the resource is associated with.",
        "proto" :"static struct vme_bridge *(*find_bridge)(struct vme_resource *resource)",
        "pre": {
            "resource": "!=null"
        }
    }
},
{
    "kretprobe:__vme_register_driver_bus": {
        "description": "Register a VME device driver with the VME subsystem.",
        "proto" :"int (*__vme_register_driver_bus)(struct vme_driver *drv, struct vme_bridge *bridge, unsigned int ndevs)",
        "pre": {
            "drv": "!=null",
            "bridge": "!=null",
            "ndevs": ">=0"
        },
        "post": {
            "return": "in [0, error value]"
        }
    }
},

{
    "kretprobe:vme_unregister_driver": {
        "description": "Unregister a VME device driver from the VME subsystem.",
        "proto" :"void (*vme_unregister_driver)(struct vme_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:vme_unregister_driver": {
        "description": "Unregister a VME device driver from the VME subsystem.",
        "proto" :"void (*vme_unregister_driver)(struct vme_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:sscanf": {
        "description": "This function reads data from w->sname and stores them according to the parameter format in the locations pointed by the other arguments.",
        "proto" :"int sscanf(const char *str, const char *format, ...)",
        "pre": {
            "w->sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "!=null",
            "dir": "!=null",
            "format": "==\"%s %d %s\""
        },
        "post": {
            "ret": ">=3"
        }
    }
},
{
    "kprobe:gbaudio_module_update": {
        "description": "Updates the gbaudio module. Parses dai_id from AIF widget's stream_name.",
        "proto" :"int gbaudio_module_update(struct gbaudio_codec_info  codec,  struct snd_soc_dapm_widget  w,  struct gbaudio_module_info  module, int enable)",
        "pre": {
            "codec": "!=null",
            "w": "!=null",
            "module": "!=null",
            "enable": "in [0, 1]",
            "w->sname": "!=null",
            "intf_name": "!=null",
            "dai_id": "is integer",
            "dir": "!=null",
            "ret": "is integer and >= 3"
        },
    }
},
{
    "kretprobe:gbaudio_register_module": {
        "description": "Registers a gbaudio module.",
        "proto" :"int gbaudio_register_module(struct gbaudio_module_info module)",
        "pre": {
            "module": "!=null"
        },
    }
},
{
    "kprobe:gbaudio_register_module": {
        "description": "Register a gbaudio module. If the card is already instantiated, create widgets here only.",
        "proto" :"gbaudio_register_module(struct gbaudio_module_info  module)",
        "pre": {
            "module": "!=null",
            "comp": "!=null",
            "comp->card": "!=null",
            "comp->card->instantiated": "is boolean"
        },
    }
},


{
    "kretprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"sp8870_attach(const struct sp8870_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:sp8870_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"sp8870_attach(const struct sp8870_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},

{
    "kprobe:adt7316_probe": {
        "description": "This function is used for device removal purposes.",
        "proto" :"adt7316_probe(struct device  dev, struct adt7316_bus  bus,  const char  name)",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "name": "!=null"
        },
        "post": {
            "chip->id": "in [ID_ADT7316, ID_ADT7516, ID_ADT7317, ID_ADT7517]",
            "chip->dac_bits": "in [8, 10, 12]",
            "chip->ldac_pin": "!=null"
        }
    }
},

{
    "kprobe:ieee80211_softmac_scan_syncro": {
        "description": "Performs a synchronous scan in the software MAC layer of the IEEE 802.11 device.",
        "proto": "void (*ieee80211_softmac_scan_syncro)(struct ieee80211_device *ieee)",
        "pre": {
            "ieee": "!=null"
        }
    }
},
{
    "kretprobe:rtllib_ps_tx_ack": {
        "description": "This function is not fully described in the provided helper doc. Please provide a complete description.",
        "proto" :"rtllib_ps_tx_ack(struct rtllib_device  ieee, short success)",
        "pre": {
            "ieee": "!=null",
            "success": "is short"
        },
    }
},
{
    "kprobe:rtllib_ps_tx_ack": {
        "description": "This function handles the acknowledgement of the transmission in power save mode in rtllib.",
        "proto" :"rtllib_ps_tx_ack(struct rtllib_device *ieee, short success)",
        "pre": {
            "ieee": "!=null",
            "success": "is short"
        },
    }
},

{
    "kprobe:ieee80211_sta_wakeup": {
        "description": "Description of the function's behavior",
        "proto" :"void (*ieee80211_sta_wakeup)(struct ieee80211_device *ieee, int parm)",
        "pre": {
            "ieee": "!=null",
            "parm": "==0"
        },
    }
},


{
    "kretprobe:ieee80211_softmac_scan_syncro": {
        "description": "This performs syncro scan blocking the caller until all channels in the allowed channel map has been checked.",
        "proto" :"static void (*ieee80211_softmac_scan_syncro)(struct ieee80211_device *ieee)",
        "pre": {
            "ieee": "!=null"
        }
    }
},

{
    "kretprobe:ieee80211_softmac_new_net": {
        "description": "This function seems to handle some aspects of network management in an 802.11 wireless context, but without more specific documentation it's hard to be sure.",
        "proto" :"if (ieee->state != IEEE80211_NOLINK)return;if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))return;if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))return;if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)",
        "pre": {
            "ieee->state": "!= IEEE80211_NOLINK",
            "ieee->iw_mode": "in [IW_MODE_INFRA, IW_MODE_ADHOC]",
            "net->capability": "in [WLAN_CAPABILITY_BSS, WLAN_CAPABILITY_IBSS]"
        },
    }
},
{
    "kprobe:ieee80211_softmac_new_net": {
        "description": "This function seems to be related to the association process in an IEEE 802.11 network. It appears to handle different modes and capabilities of the network.",
        "proto" :"if (ieee->state != IEEE80211_NOLINK)return;if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))return;if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))return;if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC)",
        "pre": {
            "ieee->state": "!= IEEE80211_NOLINK",
            "ieee->iw_mode": "in [IW_MODE_INFRA, IW_MODE_ADHOC]",
            "net->capability": "in [WLAN_CAPABILITY_BSS, WLAN_CAPABILITY_IBSS]"
        },
    }
},


{
    "kretprobe:ieee80211_wx_set_encode_ext": {
        "description": "Your function description here",
        "proto" :"static long (*ieee80211_wx_set_encode_ext)(struct ieee80211_device ieee, struct iw_request_info info, union iwreq_data wrqu, char extra)",
        "pre": {
            "idx": "!=0",
            "ext->alg": "!=IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "==IW_MODE_INFRA",
            "encoding->flags": "&IW_ENCODE_DISABLED",
            "ext->alg": "==IW_ENCODE_ALG_NONE"
        },
    }
},
{
    "kprobe:ieee80211_wx_set_encode_ext": {
        "description": "This function sets the encoding parameters for the ieee80211 device.",
        "proto" :"int ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "idx": ">= 0 && <= WEP_KEYS",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "encoding->flags": "in [IW_ENCODE_DISABLED, IW_ENCODE_ALG_NONE]"
        },
    }
},
{
    "kretprobe:ieee80211_wx_set_auth": {
        "description": "Set authentication parameters for the ieee80211 device.",
        "proto" :"static int (*ieee80211_wx_set_auth)(struct ieee80211_device *ieee, struct iw_request_info *info, struct iw_param *data, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": "!=null",
            "extra": "!=null",
            "data->flags": "in [IW_AUTH_WPA_VERSION]"
        },
    }
},
{
    "kprobe:ieee80211_wx_set_auth": {
        "description": "Set authentication parameters for the ieee80211 device. Supports WPA2 version.",
        "proto" :"static long (*ieee80211_wx_set_auth)(struct ieee80211_device *ieee, struct iw_request_info *info, struct iw_param *data, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": {
                "flags": "in [IW_AUTH_WPA_VERSION]"
            },
            "extra": "!=null"
        },
    }
},
{
    "kretprobe:ieee80211_frag_cache_find": {
        "description": "Find a fragment cache entry in the IEEE 802.11 device.",
        "proto": "static struct ieee80211_frag_entry *(*ieee80211_frag_cache_find)(struct ieee80211_device *ieee, unsigned int seq, unsigned int frag, u8 tid, u8 *src, u8 *dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "tid": "in [0, 255]",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:ieee80211_frag_cache_find": {
        "description": "Finds a fragment cache in an IEEE 802.11 device.",
        "proto" :"static struct ieee80211_frag_entry *(*ieee80211_frag_cache_find)(struct ieee80211_device *ieee, unsigned int seq, unsigned int frag, u8 tid, u8 *src, u8 *dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "tid": "in [0, 255]",
            "src": "!=null",
            "dst": "!=null"
        },
    }
},
{
    "kretprobe:memcmp": {
        "description": "Compare the first *n* bytes (each interpreted as unsigned char) of the memory areas *s1* and *s2*.",
        "proto" :"int memcmp(const void *s1, const void *s2, size_t n)",
        "pre": {
            "s1": "!=null",
            "s2": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:ieee80211_rx_mgt": {
        "description": "Your description here",
        "proto" :"static long (*ieee80211_rx_mgt)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct sk_buff *skb, struct ieee80211_rx_status *status)",
        "pre": {
            "hw": "Your condition here",
            "vif": "Your condition here",
            "skb": "Your condition here",
            "status": "Your condition here"
        },
    },
    "kprobe:memcmp": {
        "description": "Your description here",
        "proto" :"int memcmp(const void *str1, const void *str2, size_t n)",
        "pre": {
            "str1": "Your condition here",
            "str2": "Your condition here",
            "n": "Your condition here"
        },
    }
},
{
    "kretprobe:rtllib_wx_set_freq": {
        "description": "If setting by freq convert to channel",
        "proto" :"static int (*rtllib_wx_set_freq)(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "fwrq->e": "==1"
        },
    }
},
{
    "kprobe:rtllib_wx_set_freq": {
        "description": "If setting by freq convert to channel",
        "proto" :"static int (*rtllib_wx_set_freq)(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "fwrq->e": "==1"
        },
    }
},
{
    "kretprobe:ieee80211_wx_get_freq": {
        "description": "Get the frequency of the current network channel. If the current network channel is 0, return -1. NM 0.7.0 will not accept channel any more.",
        "proto" :"static long (*ieee80211_wx_get_freq)(struct ieee80211_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ieee->current_network.channel": "!=0"
        },
    }
},
{
    "kprobe:ieee80211_wx_get_freq": {
        "description": "Get the frequency of the current network channel. If the current network channel is 0, return -1. NM 0.7.0 will not accept channel any more.",
        "proto": "int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ieee->current_network.channel": "> 0"
        },
        "post": {
            "fwrq->m": "= ieee80211_wlan_frequencies[ieee->current_network.channel - 1] * 100000",
            "fwrq->e": "= 1"
        }
    }
},
{
    "kretprobe:ieee80211_wx_get_wap": {
        "description": "We want avoid to give to the user inconsistent infos",
        "proto" :"int ieee80211_wx_get_wap(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:ieee80211_wx_get_wap": {
        "description": "We want avoid to give to the user inconsistent infos",
        "proto" :"ieee80211_wx_get_wap(struct ieee80211_device  ieee, struct iw_request_info  info, union iwreq_data  wrqu, char  extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "flags": "in [ARPHRD_ETHER, IW_MODE_MONITOR]",
        },
    }
},
{
    "kretprobe:ieee80211_wx_set_wap": {
        "description": "Description of the function",
        "proto" :"int ieee80211_wx_set_wap(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *awrq, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null"
        },
    }
},
{
    "kprobe:ieee80211_wx_set_wap": {
        "description": "Your function description here",
        "proto" :"int (*ieee80211_wx_set_wap)(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *awrq, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null"
        },
    }
},
{
    "kretprobe:rtllib_wx_get_essid": {
        "description": "Get the ESSID of the rtllib device. Avoid giving the user inconsistent information.",
        "proto" :"int rtllib_wx_get_essid(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ieee->iw_mode": "!=IW_MODE_MONITOR"
        },
    }
},
{
    "kprobe:rtllib_wx_get_essid": {
        "description": "Get the ESSID of the rtllib device. If the device is in monitor mode or the ESSID is empty, return -1 to avoid giving the user inconsistent information.",
        "proto" :"int (*rtllib_wx_get_essid)(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ieee->iw_mode": "!=IW_MODE_MONITOR",
            "ieee->current_network.ssid[0]": "!='\\0'",
            "ieee->current_network.ssid_len": ">0"
        },
    }
},
{
    "kretprobe:ieee80211_wx_set_rate": {
        "description": "FIXME: we might want to limit rate also in management protocols.",
        "proto" :"EXPORT_SYMBOL(ieee80211_wx_set_rate(struct ieee80211_device ieee, struct iw_request_info info, union iwreq_data wrqu, char extra))",
        "pre": {
            "ieee": "condition",
            "info": "condition",
            "wrqu": "condition",
            "extra": "condition"
        },
    }
},

{
    "kretprobe:ieee80211_wx_get_rts": {
        "description": "Get the RTS (Request to Send) value of the ieee80211 device and set it to wrqu->rts.value. Set wrqu->rts.fixed to 0, indicating no auto select.",
        "proto" :"void ieee80211_wx_get_rts(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
        "post": {
            "wrqu->rts.value": "== ieee->rts",
            "wrqu->rts.fixed": "== 0"
        }
    }
},
{
    "kprobe:ieee80211_wx_get_rts": {
        "description": "Get the RTS (Request to Send) threshold of the ieee80211 device.",
        "proto": "void ieee80211_wx_get_rts(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        }
    }
},
{
    "kretprobe:ieee80211_wx_set_scan": {
        "description": "Locks the mutex, checks the mode and the state of the device, and queues work if the device is linked. Returns -1 if the device is in monitor mode or if the protocol has not started, otherwise returns 0.",
        "proto" :"int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null"
        },
        "post": {
            "ret": "in [-1, 0]"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_scan": {
        "description": "Locks the mutex, checks the mode and proto_started of the ieee device, and if the state is LINKED, queues work to the wx_sync_scan_wq. If any condition is not met, it returns -1.",
        "proto" :"int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null",
            "ieee->wx_mutex": "is locked",
            "ieee->iw_mode": "!= IW_MODE_MONITOR",
            "ieee->proto_started": "== true",
            "ieee->state": "== IEEE80211_LINKED"
        },
    }
},
{
    "kretprobe:rtllib_wx_set_essid": {
        "description": "Set the ESSID of the rtllib device.",
        "proto": "int (*rtllib_wx_set_essid)(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->essid.length": "<= IW_ESSID_MAX_SIZE",
            "ieee->iw_mode": "!= IW_MODE_MONITOR"
        },
        "post": {
            "ret": "in [-1, 0]"
        }
    }
},

{
    "kretprobe:ieee80211_wx_set_power": {
        "description": "Set the power management parameters for the ieee80211 device.",
        "proto" :"int (*ieee80211_wx_set_power)(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
        "post": {
            "ret": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:ieee80211_wx_set_power": {
        "description": "Sets the power settings for the ieee80211 device. If the power is disabled, the power state is set to IEEE80211_PS_DISABLED. If the power timeout flag is set, the power period is set to the power value divided by 1000.",
        "proto" :"int (*ieee80211_wx_set_power)(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "wrqu->power.disabled": "in [0, 1]",
            "wrqu->power.flags": "in [IW_POWER_TIMEOUT, ...]",
            "wrqu->power.value": ">=0"
        }
    }
},
{
    "kretprobe:ieee80211_wx_get_power": {
        "description": "Get the power state of the ieee80211 device.",
        "proto" :"static int (*ieee80211_wx_get_power)(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
    }
},
{
    "kprobe:ieee80211_wx_get_power": {
        "description": "Get the power state of the ieee80211 device.",
        "proto" :"static int ieee80211_wx_get_power(struct ieee80211_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
    }
},

{
    "kprobe:HTUpdateSelfAndPeerSetting": {
        "description": "Updates self and peer setting based on HT information.",
        "proto" :"void HTUpdateSelfAndPeerSetting(struct ieee80211_device *ieee, struct ieee80211_network *pNetwork)",
        "pre": {
            "ieee": "!=null",
            "pNetwork": "!=null",
            "pNetwork->bssht.bdHTInfoLen": "!=0",
            "pHTInfo": "!=null",
            "pPeerHTInfo": "!=null"
        },
    }
},


{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            "[parameter3]": "[condition3]",
            "[parameter4]": "[condition4]",
        },
    }
},
{
    "kprobe:dot11d_update_country_ie": {
        "description": "Description of the function",
        "proto" :"void dot11d_update_country_ie(struct ieee80211_device dev, u8 pTaddr, u16 CoutryIeLen, u8 pCoutryIe)",
        "pre": {
            "dev": "!=null",
            "pTaddr": "!=null",
            "CoutryIeLen": ">=3",
            "pCoutryIe": "!=null"
        },
    }
},
{
    "kretprobe:dot11d_scan_complete": {
        "description": "Reset country IE if previous one is gone.",
        "proto" :"void (*dot11d_scan_complete)(struct ieee80211_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:dot11d_scan_complete": {
        "description": "Reset country IE if previous one is gone.",
        "proto": "void dot11d_scan_complete(struct ieee80211_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:vchiq_initialise": {
        "description": "Initializes the VCHIQ instance. VideoCore may not be ready due to boot up timing. It may never be ready if kernel and firmware are mismatched, so don't block forever.",
        "proto" :"static long (*vchiq_initialise)(struct vchiq_instance instance_out)",
        "pre": {
            "instance_out": "!=null",
        },
    }
},
{
    "kprobe:vchiq_initialise": {
        "description": "Initialise the vchiq instance. VideoCore may not be ready due to boot up timing. It may never be ready if kernel and firmware are mismatched, so don't block forever.",
        "proto" :"int vchiq_initialise(struct vchiq_instance *instance_out)",
        "pre": {
            "instance_out": "!=null",
        },
    }
},
{
    "kretprobe:vchiq_shutdown": {
        "description": "Remove all services",
        "proto" :"int vchiq_shutdown(struct vchiq_instance *instance)",
        "pre": {
            "instance": "!=null"
        },
        "post": {
            "return": "in [-EAGAIN, 0]"
        }
    }
},
{
    "kprobe:vchiq_shutdown": {
        "description": "Remove all services",
        "proto" :"int vchiq_shutdown(struct vchiq_instance *instance)",
        "pre": {
            "instance": "!=null",
            "instance->state": "!=null"
        },
    }
},


{
    "kretprobe:vchiq_bulk_transmit": {
        "description": "This function is supposed to block until queued. It may return -EAGAIN, so a retry mechanism is implemented.",
        "proto" :"int vchiq_bulk_transmit(struct vchiq_instance *instance, unsigned int handle, const void *data, unsigned int size, void *userdata, enum vchiq_bulk_mode mode)",
        "pre": {
            "instance": "!=null",
            "handle": "is valid handle",
            "data": "!=null",
            "size": "is valid size",
            "userdata": "can be null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_transmit": {
        "description": "vchiq_bulk_transmit() may return -EAGAIN, so we need to implement a retry mechanism since this function is supposed to block until queued.",
        "proto" :"vchiq_bulk_transmit(struct vchiq_instance  instance, unsigned int handle, const void  data, unsigned int size, void  userdata, enum vchiq_bulk_mode mode)",
        "pre": {
            "instance": "your constraints here",
            "handle": "your constraints here",
            "data": "your constraints here",
            "size": "your constraints here",
            "userdata": "your constraints here",
            "mode": "your constraints here",
        },
    }
},
{
    "kretprobe:vchiq_bulk_receive": {
        "description": "vchiq_bulk_receive() may return -EAGAIN, so we need to implement a retry mechanism since this function is supposed to block until queued.",
        "proto" :"int vchiq_bulk_receive(struct vchiq_instance *instance, unsigned int handle, void *data, unsigned int size, void *userdata, enum vchiq_bulk_mode mode)",
        "pre": {
            "instance": "!=null",
            "handle": "is valid handle",
            "data": "!=null",
            "size": "is valid size",
            "userdata": "can be null or valid pointer",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
        "post": {
            "return": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_bulk_receive": {
        "description": "This function is supposed to block until queued. It may return -EAGAIN, so a retry mechanism is implemented.",
        "proto" :"int vchiq_bulk_receive(struct vchiq_instance *instance, unsigned int handle, void *data, unsigned int size, void *userdata, enum vchiq_bulk_mode mode)",
        "pre": {
            "instance": "!=null",
            "handle": "is valid handle",
            "data": "!=null",
            "size": "is valid size",
            "userdata": "can be null",
            "mode": "in [VCHIQ_BULK_MODE_NOCALLBACK, VCHIQ_BULK_MODE_CALLBACK, VCHIQ_BULK_MODE_BLOCKING]"
        },
    }
},

{
    "kprobe:vchiq_send_remote_use_active": {
        "description": "Description of the function",
        "proto" :"Function prototype",
        "pre": {
            "param1": "Constraint for param1",
            "param2": "Constraint for param2",
            "param3": "Constraint for param3",
            ...
        },
    }
},
{
    "kretprobe:voidpoll_services": {
        "description": "Description of the function goes here",
        "proto" :"static void (*voidpoll_services)(struct vchiq_state *state)",
        "pre": {
            "state": "!=null"
        }
    }
},

{
    "kretprobe:vchiq_queue_kernel_message": {
        "description": "vchiq_queue_message() may return -EAGAIN, so we need to implement a retry mechanism since this function is supposed to block until queued.",
        "proto": "int vchiq_queue_kernel_message(struct vchiq_instance instance, unsigned int handle, void data, unsigned int size)",
        "pre": {
            "instance": "!=null",
            "handle": "is valid handle",
            "data": "!=null",
            "size": ">=0"
        },
        "post": {
            "status": "!= -EAGAIN"
        }
    }
},
{
    "kprobe:vchiq_queue_kernel_message": {
        "description": "This function is supposed to block until queued. vchiq_queue_message() may return -EAGAIN, so we need to implement a retry mechanism.",
        "proto" :"int vchiq_queue_kernel_message(struct vchiq_instance *instance, unsigned int handle, void *data, unsigned int size)",
        "pre": {
            "instance": "!=null",
            "handle": "is valid handle",
            "data": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kretprobe:remote_event_create": {
        "description": "This function initializes a single remote_event, and the associated wait_queue.",
        "proto" :"static inline void remote_event_create(wait_queue_head_t *wq, struct remote_event *event)",
        "pre": {
            "wq": "!=null",
            "event": "!=null"
        }
    }
},

{
    "kretprobe:vchiq_add_connected_callback": {
        "description": "Add a connected callback. If already connected, call the callback immediately.",
        "proto" :"static void (*vchiq_add_connected_callback)(void (*callback)(void))",
        "pre": {
            "callback": "!=null"
        }
    }
},

{
    "kretprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry. Returns Zero on success, Negative on failure.",
        "proto" :"int (*cvm_oct_free_work)(void *work_queue_entry)",
        "pre": {
            "work_queue_entry": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:cvm_oct_free_work": {
        "description": "Free a work queue entry. Returns Zero on success, Negative on failure.",
        "proto" :"int (*cvm_oct_free_work)(void *work_queue_entry)",
        "pre": {
            "work_queue_entry": "!=null"
        }
    }
},
{
    "kretprobe:rtllib_wx_get_wap": {
        "description": "This function is used to get the Wireless Access Point (WAP) of a given rtllib device.",
        "proto" :"int rtllib_wx_get_wap(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:rtllib_wx_get_wap": {
        "description": "This function is used to get the wireless access point (WAP) in the rtllib device. It locks the device, checks the link state and wap_set, and then either zeroes the address or copies the current network's bssid into the address. It then unlocks the device and returns 0.",
        "proto" :"int rtllib_wx_get_wap(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "ieee->iw_mode": "!=IW_MODE_MONITOR",
            "ieee->link_state": "in [MAC80211_LINKED, MAC80211_LINKED_SCANNING]",
            "ieee->wap_set": "==0"
        },
    }
},
{
    "kretprobe:rtllib_wx_set_wap": {
        "description": "Set the Wireless Access Point (WAP) for the rtllib device. Stops any ongoing scan, locks the wx_mutex, and optionally changes the hardware MAC address if 'use ifconfig hw ether' is specified.",
        "proto" :"int rtllib_wx_set_wap(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *awrq, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "can be null or non-null"
        },
    }
},
{
    "kprobe:rtllib_wx_set_wap": {
        "description": "Sets the Wireless Access Point (WAP) for the rtllib device. Stops any ongoing scans, locks the wx_mutex, and uses ifconfig hw ether.",
        "proto" :"int rtllib_wx_set_wap(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *awrq, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "awrq": "!=null",
            "extra": "!=null"
        },
    }
},
{
    "kretprobe:rtllib_wx_get_rts": {
        "description": "This function gets the RTS (Request to Send) value of the rtllib device, sets the rts value and fixed flag in the wrqu data, and disables auto select.",
        "proto" :"static void (*rtllib_wx_get_rts)(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null"
        },
        "post": {
            "wrqu->rts.value": "== ieee->rts",
            "wrqu->rts.fixed": "== 0",
            "return": "== 0"
        }
    }
},

{
    "kretprobe:rtllib_wx_set_scan": {
        "description": "Sets the scan mode for the rtllib device. If the device is in monitor mode or the protocol has not started, it returns -1. If the device is linked, it schedules a sync scan work queue.",
        "proto" :"int rtllib_wx_set_scan(struct rtllib_device *ieee, struct iw_request_info *a, union iwreq_data *wrqu, char *b)",
        "pre": {
            "ieee": "!=null",
            "a": "!=null",
            "wrqu": "!=null",
            "b": "!=null"
        },
        "post": {
            "ret": "in [-1, 0]"
        }
    }
},

{
    "kretprobe:foo": {
        "description": "This is a description of what the function does.",
        "proto" :"static long (*foo)(type *a, type *b, type *c)",
        "pre": {
            "a": "!=null",
            "b": "!=null",
            "c": "in [CONSTANT_1, CONSTANT_2, CONSTANT_3]",
        },
    }
},
{
    "kprobe:rtllib_beacons_start": {
        "description": "This function appears to be related to wireless networking, possibly initiating a scan for available channels.",
        "proto" :"static void rtllib_beacons_start(struct rtllib_device *ieee)",
        "pre": {
            "ieee": "!=null",
        },
    }
},
{
    "kretprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "proto" :"void (*rtllib_EnableNetMonitorMode)(struct net_device *dev, bool bInitState)",
        "pre": {
            "dev": "!=null",
            "bInitState": "in [true, false]"
        }
    }
},
{
    "kprobe:rtllib_EnableNetMonitorMode": {
        "description": "Enables network monitor mode, all rx packets will be received.",
        "proto" :"void (*rtllib_EnableNetMonitorMode)(struct net_device *dev, bool bInitState)",
        "pre": {
            "dev": "!=null",
            "bInitState": "in [true, false]"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:ieee_link_state_check": {
        "description": "Checks if the link state is not MAC80211_NOLINK.",
        "proto" :"static long (*ieee_link_state_check)(struct ieee80211 *ieee)",
        "pre": {
            "ieee": "!=null",
            "ieee->link_state": "!=MAC80211_NOLINK"
        }
    }
},
{
    "kretprobe:rtllib_frag_cache_find": {
        "description": "Find a fragment cache entry in the rtllib device.",
        "proto" :"static struct rtllib_frag_entry *(*rtllib_frag_cache_find)(struct rtllib_device *ieee, unsigned int seq, unsigned int frag, u8 tid, u8 *src, u8 *dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "tid": "in [0, 255]",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:rtllib_frag_cache_find": {
        "description": "Find a fragment cache entry in the rtllib device. This function is called only as a tasklet (software IRQ).",
        "proto" :"static struct rtllib_frag_entry *(*rtllib_frag_cache_find)(struct rtllib_device *ieee, unsigned int seq, unsigned int frag, u8 tid, u8 *src, u8 *dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "tid": "in [0, 255]",
            "src": "!=null",
            "dst": "!=null"
        }
    }
},


{
    "kretprobe:rtllib_wx_set_encode_ext": {
        "description": "This function sets the encoding extension for the rtllib device.",
        "proto" :"int rtllib_wx_set_encode_ext(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "idx": ">= 0 && < NUM_WEP_KEYS",
            "ext->alg": "!= IW_ENCODE_ALG_WEP",
            "ieee->iw_mode": "== IW_MODE_INFRA",
            "encoding->flags": "in [IW_ENCODE_DISABLED, IW_ENCODE_ALG_NONE]"
        },
    }
},
{
    "kprobe:rtllib_wx_set_encode_ext": {
        "description": "Sets the encoding extension for the rtllib device.",
        "proto" :"static int (*rtllib_wx_set_encode_ext)(struct rtllib_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "idx": "in [1, NUM_WEP_KEYS]",
            "ext->ext_flags": "has IW_ENCODE_EXT_GROUP_KEY"
        },
    }
},
{
    "kretprobe:rtllib_wx_set_auth": {
        "description": "Host AP driver does not use these parameters and allows wpa_supplicant to control them internally.",
        "proto" :"static long (*rtllib_wx_set_auth)(struct rtllib_device *ieee, struct iw_request_info *info, struct iw_param *data, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": "!=null",
            "extra": "!=null",
            "data->flags": "in [IW_AUTH_WPA_VERSION, IW_AUTH_CIPHER_PAIRWISE, IW_AUTH_CIPHER_GROUP, IW_AUTH_KEY_MGMT]"
        },
    }
},
{
    "kprobe:rtllib_wx_set_auth": {
        "description": "Host AP driver does not use these parameters and allows wpa_supplicant to control them internally.",
        "proto" :"static long (*rtllib_wx_set_auth)(struct rtllib_device *ieee, struct iw_request_info *info, struct iw_param *data, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "data": "!=null",
            "extra": "!=null",
            "data->flags": "in [IW_AUTH_WPA_VERSION, IW_AUTH_CIPHER_PAIRWISE, IW_AUTH_CIPHER_GROUP, IW_AUTH_KEY_MGMT]"
        },
    }
},
{
    "kretprobe:alloc_rtllib": {
        "description": "Initializes rtllib, allocates net_device and beacon storage, and sets default values.",
        "proto" :"static struct rtllib_device* (*alloc_rtllib)(int sizeof_priv)",
        "pre": {
            "sizeof_priv": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:alloc_rtllib": {
        "description": "Allocates a rtllib device and initializes it.",
        "proto" :"static struct rtllib_device* (*alloc_rtllib)(int sizeof_priv)",
        "pre": {
            "sizeof_priv": ">=0",
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            ...
        },
    }
},

{
    "kretprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC. Queue a single message to be transferred to the embedded controller and return immediately.",
        "proto" :"int nvec_write_async(struct nvec_chip *nvec, const unsigned char *data, short size)",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">0"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:nvec_write_async": {
        "description": "Asynchronously write a message to NVEC. Queue a single message to be transferred to the embedded controller and return immediately.",
        "proto" :"int (*nvec_write_async)(struct nvec_chip *nvec, const unsigned char *data, short size)",
        "pre": {
            "nvec": "!=null",
            "data": "!=null",
            "size": ">0"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:nvec_register_notifier": {
        "description": "nvec_write_sync()",
        "proto" :"int (*nvec_register_notifier)(struct nvec_chip *nvec, struct notifier_block *nb, unsigned int events)",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": "in [EVENT_MIN, EVENT_MAX]",
        },
    }
},
{
    "kprobe:nvec_register_notifier": {
        "description": "nvec_write_sync()",
        "proto" :"int nvec_register_notifier(struct nvec_chip *nvec, struct notifier_block *nb, unsigned int events)",
        "pre": {
            "nvec": "!=null",
            "nb": "!=null",
            "events": "in [EVENT1, EVENT2, EVENT3]"
        }
    }
},
{
    "kretprobe:fbtft_write_spi_emulate_9": {
        "description": "Write SPI emulating 9-bit. When 9-bit SPI is not available, this function can be used to emulate that. par->extra must hold a transformation buffer used for transfer.",
        "proto" :"int fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)",
        "pre": {
            "par": "!=null && par->extra !=null",
            "buf": "!=null",
            "len": ">=0 && len%8 == 0"
        }
    }
},
{
    "kprobe:fbtft_write_spi_emulate_9": {
        "description": "When 9-bit SPI is not available, this function can be used to emulate that. par->extra must hold a transformation buffer used for transfer.",
        "proto" :"int fbtft_write_spi_emulate_9(struct fbtft_par *par, void *buf, size_t len)",
        "pre": {
            "par": "!=null",
            "buf": "!=null",
            "len": ">=0 && len%8 == 0",
            "par->extra": "!=null"
        },
    }
},


{
    "kretprobe:fbtft_write_reg8_bus9": {
        "description": "Write register 8 bus 9 for fbtft",
        "proto" :"void fbtft_write_reg8_bus9(struct fbtft_par *par, int len, ...)",
        "pre": {
            "par": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kprobe:fbtft_write_reg8_bus9": {
        "description": "Writes to the register of the fbtft device. If the device is using 8 bits per word, it pads the start of the buffer with no-ops.",
        "proto" :"static void (*fbtft_write_reg8_bus9)(struct fbtft_par *par, int len, ...)",
        "pre": {
            "par": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:fbtft_write_vmem16_bus8": {
        "description": "Writes to the framebuffer memory with a 16-bit value. If the txbuf is not null, it will write to the framebuffer using the buffered write method.",
        "proto" :"static int (*fbtft_write_vmem16_bus8)(struct fbtft_par *par, size_t offset, size_t len)",
        "pre": {
            "par": "!=null",
            "par->txbuf.buf": "!=null",
            "offset": ">=0",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, len]"
        }
    }
},
{
    "kprobe:fbtft_write_vmem16_bus8": {
        "description": "Writes to the virtual memory of the fbtft device. If the txbuf buffer is not available, it writes directly to the device.",
        "proto" :"static int (*fbtft_write_vmem16_bus8)(struct fbtft_par *par, size_t offset, size_t len)",
        "pre": {
            "par": "!=null",
            "par->txbuf.buf": "!=null",
            "par->fbtftops.write": "!=null",
            "offset": ">=0",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:fbtft_write_vmem16_bus16": {
        "description": "Writes to the virtual memory of a 16-bit bus. No need for buffered write with 16-bit bus.",
        "proto" :"void fbtft_write_vmem16_bus16(struct fbtft_par *par, size_t offset, size_t len)",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:fbtft_write_vmem16_bus16": {
        "description": "Writes to the virtual memory of a 16-bit bus. No need for buffered write with 16-bit bus.",
        "proto" :"static void (*fbtft_write_vmem16_bus16)(struct fbtft_par *par, size_t offset, size_t len)",
        "pre": {
            "par": "!=null",
            "offset": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:fbtft_register_backlight": {
        "description": "Register a backlight device for the fbtft display. If the led pin is not set, the function will exit.",
        "proto" :"static void (*fbtft_register_backlight)(struct fbtft_par *par)",
        "pre": {
            "par": "!=null",
            "par->gpio.led[0]": "!=null"
        },
    }
},
{
    "kprobe:fbtft_register_backlight": {
        "description": "Assume backlight is off, get polarity from current state of pin",
        "proto" :"static long (*fbtft_register_backlight)(struct fbtft_par par)",
        "pre": {
            "par": "!=null",
        },
    }
},
{
    "kretprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure. Also creates and populates the following structures: info->fbops, info->fbdefio, info->pseudo_palette, par->fbtftops, par->txbuf. Returns the new structure, or NULL if an error occurred.",
        "proto" :"struct fb_info *(*fbtft_framebuffer_alloc)(struct fbtft_display *display, struct device *dev, struct fbtft_platform_data *pdata)",
        "pre": {
            "display": "!=null",
            "dev": "can be null",
            "pdata": "!=null"
        },
        "post": {
            "return": "!=null or ==null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_alloc": {
        "description": "Creates a new frame buffer info structure. Also creates and populates the following structures: info->fbops, info->fbdefio, info->pseudo_palette, par->fbtftops, par->txbuf. Returns the new structure, or NULL if an error occurred.",
        "proto" :"struct fb_info *(*fbtft_framebuffer_alloc)(struct fbtft_display *display, struct device *dev, struct fbtft_platform_data *pdata)",
        "pre": {
            "display": "!=null",
            "dev": "can be null",
            "pdata": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer",
        "proto" :"static void (*fbtft_framebuffer_release)(struct fb_info *info)",
        "pre": {
            "info": "!=null"
        },
        "post": {
            "info": "==null"
        }
    }
},
{
    "kprobe:fbtft_framebuffer_release": {
        "description": "Frees up all memory used by the framebuffer",
        "proto" :"void (*fbtft_framebuffer_release)(struct fb_info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device. Sets SPI driverdata if needed. Requests needed gpios. Initializes display. Updates display. Registers a frame buffer device @fb_info. Returns negative errno on error, or zero for success.",
        "proto" :"int (*fbtft_register_framebuffer)(struct fb_info *fb_info)",
        "pre": {
            "fb_info": "!=null"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:fbtft_register_framebuffer": {
        "description": "Registers a tft frame buffer device, sets SPI driverdata if needed, requests needed gpios, initializes and updates the display. Registers a frame buffer device @fb_info. Returns negative errno on error, or zero for success.",
        "proto" :"int (*fbtft_register_framebuffer)(struct fb_info *fb_info)",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a tft frame buffer device. Frees SPI driverdata if needed. Frees gpios. Unregisters frame buffer device.",
        "proto" :"int (*fbtft_unregister_framebuffer)(struct fb_info *fb_info)",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_unregister_framebuffer": {
        "description": "Releases a tft frame buffer device. Frees SPI driverdata if needed. Frees gpios. Unregisters frame buffer device.",
        "proto" :"int (*fbtft_unregister_framebuffer)(struct fb_info *fb_info)",
        "pre": {
            "fb_info": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function. Driver data. Return: 0 if successful, negative if error.",
        "proto" :"static int fbtft_init_display_from_property(struct fbtft_par *par)",
        "pre": {
            "par": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:fbtft_init_display_from_property": {
        "description": "Device Tree init_display() function. @par: Driver data. Return: 0 if successful, negative if error.",
        "proto" :"static int (*fbtft_init_display_from_property)(struct fbtft_par *par)",
        "pre": {
            "par": "!=null"
        }
    }
},
{
    "kretprobe:fbtft_probe_common": {
        "description": "Generic device probe() helper function. Allocates, initializes and registers a framebuffer. Either @sdev or @pdev should be NULL. Return: 0 if successful, negative if error.",
        "proto" :"int fbtft_probe_common(struct fbtft_display *display, struct spi_device *sdev, struct platform_device *pdev)",
        "pre": {
            "display": "!=null",
            "sdev": "!=null || pdev !=null",
            "pdev": "!=null || sdev !=null"
        },
    }
},
{
    "kprobe:fbtft_probe_common": {
        "description": "Generic device probe() helper function. Allocates, initializes and registers a framebuffer. Either @sdev or @pdev should be NULL. Return: 0 if successful, negative if error.",
        "proto" :"int fbtft_probe_common(struct fbtft_display *display, struct spi_device *sdev, struct platform_device *pdev)",
        "pre": {
            "display": "!=null",
            "sdev": "!=null || pdev !=null",
            "pdev": "!=null || sdev !=null"
        }
    }
},
{
    "kretprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function. Unregisters and releases the framebuffer.",
        "proto" :"static void (*fbtft_remove_common)(struct device *dev, struct fb_info *info)",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:fbtft_remove_common": {
        "description": "Generic device remove() helper function. Unregisters and releases the framebuffer.",
        "proto" :"static void (*fbtft_remove_common)(struct device *dev, struct fb_info *info)",
        "pre": {
            "dev": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:of_iommu_get_resv_regions": {
        "description": "IOMMU drivers can use this to implement their .get_resv_regions() callback for memory regions attached to a device tree node. See the reserved-memory device tree bindings on how to use these.",
        "proto" :"void (*of_iommu_get_resv_regions)(struct device *dev, struct list_head *list)",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:of_iommu_get_resv_regions": {
        "description": "IOMMU drivers can use this to implement their .get_resv_regions() callback for memory regions attached to a device tree node. See the reserved-memory device tree bindings on how to use these.",
        "proto" :"void (*of_iommu_get_resv_regions)(struct device *dev, struct list_head *list)",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:iommu_group_alloc": {
        "description": "This function is called by an iommu driver to allocate a new iommu group. The iommu group represents the minimum granularity of the iommu. Upon successful return, the caller holds a reference to the supplied group in order to hold the group until devices are added. Use iommu_group_put() to release this extra reference count, allowing the group to be automatically reclaimed once it has no devices or external references.",
        "proto" :"struct iommu_group *(*iommu_group_alloc)(void)",
        "pre": {}
    }
},
{
    "kprobe:iommu_group_alloc": {
        "description": "Allocate a new group. This function is called by an iommu driver to allocate a new iommu group. The iommu group represents the minimum granularity of the iommu. Upon successful return, the caller holds a reference to the supplied group in order to hold the group until devices are added. Use iommu_group_put() to release this extra reference count, allowing the group to be automatically reclaimed once it has no devices or external references.",
        "proto" :"struct iommu_group *(*iommu_group_alloc)(void)",
        "pre": {}
    }
},
{
    "kretprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources. Users who manage their own IOVA allocation and do not want DMA API support, but would still like to take advantage of automatic MSI remapping, can use this to initialise their own domain appropriately. Users should reserve a contiguous IOVA region, starting at @base, large enough to accommodate the number of PAGE_SIZE mappings necessary to cover every MSI doorbell address used by the devices attached to @domain.",
        "proto" :"int (*iommu_get_msi_cookie)(struct iommu_domain *domain, dma_addr_t base)",
        "pre": {
            "domain": "!=null",
            "base": ">=0"
        },
    }
},
{
    "kprobe:iommu_get_msi_cookie": {
        "description": "Acquire just MSI remapping resources. Users who manage their own IOVA allocation and do not want DMA API support, but would still like to take advantage of automatic MSI remapping, can use this to initialise their own domain appropriately. Users should reserve a contiguous IOVA region, starting at @base, large enough to accommodate the number of PAGE_SIZE mappings necessary to cover every MSI doorbell address used by the devices attached to @domain.",
        "proto" :"int (*iommu_get_msi_cookie)(struct iommu_domain *domain, dma_addr_t base)",
        "pre": {
            "domain": "!=null",
            "base": ">=0"
        }
    }
},
{
    "kretprobe:iommu_dma_get_resv_regions": {
        "description": "IOMMU drivers can use this to implement their .get_resv_regions callback for general non-IOMMU-specific reservations. Currently, this covers GICv3 ITS region reservation on ACPI based ARM platforms that may require HW MSI reservation.",
        "proto" :"void (*iommu_dma_get_resv_regions)(struct device *dev, struct list_head *list)",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kprobe:iommu_dma_get_resv_regions": {
        "description": "IOMMU drivers can use this to implement their .get_resv_regions callback for general non-IOMMU-specific reservations. Currently, this covers GICv3 ITS region reservation on ACPI based ARM platforms that may require HW MSI reservation.",
        "proto" :"void (*iommu_dma_get_resv_regions)(struct device *dev, struct list_head *list)",
        "pre": {
            "dev": "!=null",
            "list": "!=null"
        }
    }
},
{
    "kretprobe:amd_iommu_v2_supported": {
        "description": "CPU page table size should match IOMMU guest page table size",
        "proto" :"static bool (*amd_iommu_v2_supported)(int X86_FEATURE_LA57, int amd_iommu_gpt_level)",
        "pre": {
            "X86_FEATURE_LA57": "is a valid CPU feature",
            "amd_iommu_gpt_level": "is a valid IOMMU guest page table level",
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:amd_iommu_v2_supported": {
        "description": "CPU page table size should match IOMMU guest page table size",
        "proto" :"static bool (*amd_iommu_v2_supported)(void)",
        "pre": {
            "X86_FEATURE_LA57": "enabled",
            "amd_iommu_gpt_level": "!= PAGE_MODE_5_LEVEL"
        },
    }
},
{
    "kretprobe:amd_iommu_domain_enable_v2": {
        "description": "Your description here",
        "proto" :"static long (*amd_iommu_domain_enable_v2)(struct iommu_domain *dom, int pasids)",
        "pre": {
            "dom": "Your condition here",
            "pasids": "Your condition here"
        },
        "post": {
            "ret": "Your condition here"
        }
    }
},
{
    "kprobe:amd_iommu_domain_enable_v2": {
        "description": "Sanity checks whether devices already in the domain support IOMMUv2. Just force that the domain has no devices attached when it is switched into IOMMUv2 mode.",
        "proto" :"int amd_iommu_domain_enable_v2(struct iommu_domain *dom, int pasids)",
        "pre": {
            "dom": "!=null",
            "pasids": ">=0",
            "pdom->dev_cnt": "==0",
            "pdom->flags": "not & PD_IOMMUV2_MASK",
            "pdom->gcr3_tbl": "!=null"
        },
    }
},
{
    "kretprobe:device_flush_iotlb": {
        "description": "Command send function for flushing on-device TLB",
        "proto" :"static int device_flush_iotlb(struct iommu_dev_data *dev_data, u64 address, size_t size)",
        "pre": {
            "dev_data": "!=null",
            "address": ">=0",
            "size": ">=0"
        }
    }
},
{
    "kprobe:device_flush_iotlb": {
        "description": "Flushes the IOTLB for a specific device.",
        "proto" :"static int device_flush_iotlb(struct iommu_dev_data *dev_data, u64 address, size_t size)",
        "pre": {
            "dev_data": "!=null",
            "address": ">=0",
            "size": ">0",
        },
    }
},

{
    "kprobe:amd_iommu_bind_pasid": {
        "description": "Bind a Process Address Space ID (PASID) to a device at a specific address.",
        "proto" :"static long (*amd_iommu_bind_pasid)(void *device, __u32 pasid, void *addr)",
        "pre": {
            "device": "!=null",
            "pasid": "is valid",
            "addr": "!=null"
        },
    }
},
{
    "kretprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used.",
        "proto" :"void (*put_pasid_state)(struct pasid_state *pasid_state)",
        "pre": {
            "pasid_state": "!=null"
        }
    }
},
{
    "kprobe:put_pasid_state": {
        "description": "Clear the pasid state so that the pasid can be re-used.",
        "proto" :"void (*put_pasid_state)(struct pasid_state *pasid_state)",
        "pre": {
            "pasid_state": "!=null",
        },
    }
},
{
    "kretprobe:amd_iommu_init_device": {
        "description": "When memory encryption is active the device is likely not in a direct-mapped domain. Forbid using IOMMUv2 functionality for now.",
        "proto" :"int amd_iommu_init_device(struct pci_dev *pdev, int pasids)",
        "pre": {
            "pdev": "!=null",
            "pasids": ">0 && <=PASID_MASK + 1"
        },
        "post": {
            "return": "in [-ENODEV, -EINVAL, -ENOMEM]"
        }
    }
},
{
    "kprobe:amd_iommu_init_device": {
        "description": "When memory encryption is active the device is likely not in a direct-mapped domain. Forbid using IOMMUv2 functionality for now.",
        "proto" :"int amd_iommu_init_device(struct pci_dev *pdev, int pasids)",
        "pre": {
            "pdev": "!=null",
            "pasids": ">0 && <= (PASID_MASK + 1)"
        },
        "post": {
            "ret": "in [-ENODEV, -EINVAL, -ENOMEM]",
            "dev_state": "!=null",
            "dev_state->pdev": "=pdev",
            "dev_state->pasid_levels": ">=0",
            "dev_state->count": "=1",
            "dev_state->max_pasids": "=pasids",
            "dev_state->states": "!=null",
            "dev_state->domain": "!=null"
        }
    }
},
{
    "kretprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device. Return: 0 on success or a negative error value.",
        "proto" :"int dev_pm_opp_register_notifier(struct device *dev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:dev_pm_opp_register_notifier": {
        "description": "Register OPP notifier for the device. Returns 0 on success or a negative error value.",
        "proto" :"int (*dev_pm_opp_register_notifier)(struct device *dev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device. Return: 0 on success or a negative error value.",
        "proto" :"int dev_pm_opp_unregister_notifier(struct device *dev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:dev_pm_opp_unregister_notifier": {
        "description": "Unregister OPP notifier for the device. Return: 0 on success or a negative error value.",
        "proto" :"int (*dev_pm_opp_unregister_notifier)(struct device *dev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dm_kcopyd_copy": {
        "description": "Allocate an array of jobs consisting of one master job followed by SPLIT_COUNT sub jobs.",
        "proto" :"static long (*dm_kcopyd_copy)(struct dm_kcopyd_client *kc, struct dm_io_region *from, unsigned int num_dests, struct dm_io_region *dests, unsigned int flags, dm_kcopyd_notify_fn fn, void *context)",
        "pre": {
            "kc": "!=null",
            "from": "!=null",
            "num_dests": ">=0",
            "dests": "!=null",
            "flags": "in [FLAG1, FLAG2, FLAG3]", // replace with actual flags
            "fn": "!=null",
            "context": "!=null"
        },
    }
},
{
    "kprobe:dm_kcopyd_copy": {
        "description": "Allocate an array of jobs consisting of one master job followed by SPLIT_COUNT sub jobs.",
        "proto" :"dm_kcopyd_copy(struct dm_kcopyd_client *kc, struct dm_io_region *from, unsigned int num_dests, struct dm_io_region *dests, unsigned int flags, dm_kcopyd_notify_fn fn, void *context)",
        "pre": {
            "kc": "!=null",
            "from": "!=null",
            "num_dests": ">=0",
            "dests": "!=null",
            "flags": ">=0",
            "fn": "!=null",
            "context": "!=null"
        },
    }
},
{
    "kretprobe:dm_kcopyd_client_destroy": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "proto" :"void dm_kcopyd_client_destroy(struct dm_kcopyd_client *kc)",
        "pre": {
            "kc": "!=null"
        }
    }
},
{
    "kprobe:dm_kcopyd_client_destroy": {
        "description": "Wait for completion of all jobs submitted by this client.",
        "proto" :"static void (*dm_kcopyd_client_destroy)(struct dm_kcopyd_client *kc)",
        "pre": {
            "kc": "!=null"
        }
    }
},

{
    "kprobe:struct_io": {
        "description": "Description of the function behavior",
        "proto" :"static long (*struct_io)(dm_io_client *client, __u64 flags)",
        "pre": {
            "client": "!=null",
            "flags": "in [range]",
        },
    }
},
{
    "kretprobe:dm_kobject_release": {
        "description": "dm_kobject_release is called from this process. It calls complete(), a reschedule happens before dm_kobject_release returns. dm_sysfs_exit continues, the dm device is unloaded, module reference count is decremented. The user unloads the dm module. The other process that was rescheduled in step 7 continues to run, it is now executing code in unloaded module, so it crashes. Note that if the process that takes the foreign reference to dm kobject has a low priority and the system is sufficiently loaded with higher-priority processes that prevent the low-priority process from being scheduled long enough, this bug may really happen. In order to fix this module unload race, we place the release method into a helper code that is compiled directly into the kernel.",
        "proto" :"void dm_kobject_release(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:dm_kobject_release": {
        "description": "dm_kobject_release is called from this process. It is used to release a kobject. This function is compiled directly into the kernel to fix a module unload race.",
        "proto" :"void dm_kobject_release(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null"
        }
    }
},
{
    "kretprobe:dm_get_device": {
        "description": "Extract the major and minor numbers",
        "proto" :"int dm_get_device(struct dm_target *ti, const char *path, blk_mode_t mode, struct dm_dev *result)",
        "pre": {
            "ti": "!=null",
            "path": "!=null",
            "mode": "is valid blk_mode_t",
            "result": "!=null"
        },
    }
},
{
    "kprobe:dm_get_device": {
        "description": "Extract the major and minor numbers",
        "proto" :"int dm_get_device(struct dm_target *ti, const char *path, blk_mode_t mode, struct dm_dev *result)",
        "pre": {
            "ti": "!=null",
            "path": "!=null",
            "mode": "in [FMODE_READ, FMODE_WRITE, FMODE_EXEC]",
            "result": "!=null"
        },
    }
},


{
    "kretprobe:md_bitmap_update_sb": {
        "description": "Update the superblock of the bitmap for the array. If there is no bitmap or no array, do nothing.",
        "proto" :"static void (*md_bitmap_update_sb)(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null"
        },
    }
},
{
    "kprobe:md_bitmap_update_sb": {
        "description": "Updates the superblock of the bitmap. If there is no bitmap for this array, it does nothing.",
        "proto" :"static void (*md_bitmap_update_sb)(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null",
            "bitmap->mddev": "!=null"
        },
    }
},
{
    "kretprobe:md_bitmap_unplug": {
        "description": "Look at each page to see if there are any set bits that need to be flushed out to disk.",
        "proto" :"void md_bitmap_unplug(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null"
        }
    }
},
{
    "kprobe:md_bitmap_unplug": {
        "description": "Look at each page to see if there are any set bits that need to be flushed out to disk.",
        "proto" :"void md_bitmap_unplug(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null"
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[constraints]",
            "[parameter2]": "[constraints]",
            "[parameter3]": "[constraints]",
            "[parameter4]": "[constraints]",
        },
    }
},
{
    "kprobe:prepare_to_wait": {
        "description": "Prepare a task to enter a wait queue.",
        "proto": "void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)",
        "pre": {
            "q": "!=null",
            "wait": "!=null",
            "state": "in [TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE]"
        }
    },
    "kprobe:spin_unlock_irq": {
        "description": "Unlock a spinlock and enable interrupts.",
        "proto": "void spin_unlock_irq(spinlock_t *lock)",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:schedule": {
        "description": "Schedule a task switch.",
        "proto": "void schedule(void)",
        "pre": {}
    },
    "kprobe:finish_wait": {
        "description": "Remove a task from a wait queue.",
        "proto": "void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)",
        "pre": {
            "q": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync must always report on multiples of whole pages, otherwise resync (which is very PAGE_SIZE based) will get confused. So call __bitmap_start_sync repeatedly (if needed) until At least PAGE_SIZE>>9 blocks are covered. Return the 'or' of the result.",
        "proto" :"int md_bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks, int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": ">=0",
            "blocks": "!=null && *blocks >= 0",
            "degraded": "in [0, 1]"
        },
    }
},
{
    "kprobe:md_bitmap_start_sync": {
        "description": "md_bitmap_start_sync must always report on multiples of whole pages, otherwise resync (which is very PAGE_SIZE based) will get confused. So call __bitmap_start_sync repeatedly (if needed) until At least PAGE_SIZE>>9 blocks are covered. Return the 'or' of the result.",
        "proto" :"int md_bitmap_start_sync(struct bitmap *bitmap, sector_t offset, sector_t *blocks, int degraded)",
        "pre": {
            "bitmap": "!=null",
            "offset": ">=0",
            "blocks": "!=null && *blocks >= 0",
            "degraded": "in [0, 1]"
        },
    }
},
{
    "kretprobe:md_bitmap_end_sync": {
        "description": "This function is not clearly described in the provided helper doc.",
        "proto" :"md_bitmap_end_sync(struct bitmap  bitmap, sector_t offset, sector_t  blocks, int aborted)",
        "pre": {
            "bitmap": "!=null",
            "offset": ">=0",
            "blocks": ">=0",
            "aborted": "in [0, 1]"
        },
    }
},

{
    "kretprobe:md_bitmap_close_sync": {
        "description": "Sync has finished, and any bitmap chunks that weren't synced properly have been aborted. It remains to us to clear the RESYNC bit wherever it is still on.",
        "proto" :"void md_bitmap_close_sync(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null"
        }
    }
},
{
    "kprobe:md_bitmap_close_sync": {
        "description": "Sync has finished, and any bitmap chunks that weren't synced properly have been aborted. It remains to us to clear the RESYNC bit wherever it is still on.",
        "proto" :"void md_bitmap_close_sync(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null"
        }
    }
},
{
    "kretprobe:md_bitmap_free": {
        "description": "Free the bitmap if it exists.",
        "proto" :"static void (*md_bitmap_free)(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null"
        },
    }
},
{
    "kprobe:md_bitmap_free": {
        "description": "Free the bitmap if it exists.",
        "proto" :"static void (*md_bitmap_free)(struct bitmap *bitmap)",
        "pre": {
            "bitmap": "!=null",
        },
    }
},
{
    "kretprobe:md_handle_request": {
        "description": "Bail out if REQ_NOWAIT is set for the bio",
        "proto" :"static long (*md_handle_request)(struct mddev *mddev, struct bio *bio)",
        "pre": {
            "mddev": "!=null",
            "bio": "!=null",
            "bio->bi_opf & REQ_NOWAIT": "your_condition_here"
        },
    }
},
{
    "kprobe:md_handle_request": {
        "description": "Handle a request. Bail out if REQ_NOWAIT is set for the bio.",
        "proto": "static void (*md_handle_request)(struct mddev *mddev, struct bio *bio)",
        "pre": {
            "mddev": "!=null",
            "bio": "!=null",
            "bio->bi_opf & REQ_NOWAIT": "!=0"
        }
    }
},
{
    "kretprobe:md_flush_request": {
        "description": "Flush requests wait until ongoing flush completes, hence coalescing all the pending requests.",
        "proto" :"void md_flush_request(struct mddev *mddev, struct bio *bio)",
        "pre": {
            "mddev": "!=null",
            "bio": "!=null"
        }
    }
},

{
    "kretprobe:md_integrity_register": {
        "description": "Registers the integrity of the mddev. If the list of disks is empty, it returns 0.",
        "proto" :"static long (*md_integrity_register)(struct mddev *mddev)",
        "pre": {
            "mddev": "!=null",
        },
    }
},
{
    "md_integrity_register": {
        "description": "Register the integrity of a RAID device",
        "proto": "int md_integrity_register(struct mddev *mddev)",
        "pre": {
            "mddev": "!=null",
            "mddev->gendisk": "!=null || blk_get_integrity(mddev->gendisk) != 0",
            "mddev->disks": "!list_empty(&mddev->disks)"
        },
        "post": {
            "return": "in [0]"
        }
    }
},

{
    "kprobe:md_integrity_add_rdev": {
        "description": "Add or update the integrity of the block device associated with *mddev* and *rdev*. If *mddev*'s gendisk is null or its blk_integrity is null, do nothing.",
        "proto" :"static long (*md_integrity_add_rdev)(struct md_rdev *rdev, struct mddev *mddev)",
        "pre": {
            "rdev": "!=null",
            "mddev": "!=null",
            "mddev->gendisk": "!=null",
            "bi_mddev": "!=null"
        },
    }
},
{
    "kretprobe:does_sb_need_changing": {
        "description": "Check if the structure needs to be updated.",
        "proto" :"static int (*does_sb_need_changing)(struct mddev *mddev)",
        "pre": {
            "mddev": "!=null",
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},


{
    "kprobe:md_wakeup_thread_directly": {
        "description": "Wakes up a thread directly in the md (Multiple Devices) subsystem. The number of read corrections attempted on an rdev before ejecting it from the array is defined elsewhere.",
        "proto" :"static void (*md_wakeup_thread_directly)(struct md_thread __rcu *thread)",
        "pre": {
            "thread": "!=null"
        },
    }
},
{
    "kretprobe:md_check_recovery": {
        "description": "Description of the function",
        "proto" :"static long (*md_check_recovery)(mddev_t *mddev, const char *page)",
        "pre": {
            "mddev": "!=null",
            "page": "matches ['resync', 'recover']",
        },
    }
},
{
    "kprobe:md_check_recovery": {
        "description": "Checks the recovery status of the md device.",
        "proto" :"static int (*md_check_recovery)(struct mddev *mddev)",
        "pre": {
            "mddev": "!=null",
        },
    }
},

{
    "kprobe:md_super_write": {
        "description": "Write first size bytes of page to sector of rdev. Increment mddev->pending_writes before returning and decrement it on completion, waking up sb_wait if zero is reached. If an error occurred, call md_error.",
        "proto" :"void md_super_write(struct mddev mddev, struct md_rdev rdev, sector_t sector, int size, struct page page)",
        "pre": {
            "mddev": "!=null",
            "rdev": "!=null",
            "sector": ">=0",
            "size": ">=0",
            "page": "!=null"
        },
    },
    "kprobe:md_super_wait": {
        "description": "Your description here",
        "proto" :"int md_super_wait(struct mddev *mddev)",
        "pre": {
            "mddev": "!=null"
        },
    }
},
{
    "kretprobe:md_done_sync": {
        "description": "Another 'blocks' (512byte) blocks have been synced.",
        "proto" :"static void (*md_done_sync)(struct mddev *mddev, int blocks, int ok)",
        "pre": {
            "mddev": "!=null",
            "blocks": ">=0",
            "ok": "in [0, 1]"
        }
    }
},
{
    "kprobe:md_done_sync": {
        "description": "Another 'blocks' (512byte) blocks have been synced.",
        "proto" :"static void (*md_done_sync)(struct mddev *mddev, int blocks, int ok)",
        "pre": {
            "mddev": "!=null",
            "blocks": ">=0",
            "ok": "in [0, 1]"
        }
    }
},

{
    "kprobe:md_write_start": {
        "description": "md_write_start and which are not ready for writes yet.",
        "proto" :"static long (*md_write_start)(void *ro, struct mddev_s *mddev)",
        "pre": {
            "ro": "!=null",
            "mddev": {
                "ro": "== MD_RDONLY",
                "pers": "!=null"
            }
        }
    }
},
{
    "kretprobe:md_write_inc": {
        "description": "Unlike md_write_start(), it is safe to call md_write_inc() inside a spinlocked region.",
        "proto" :"void (*md_write_inc)(struct mddev *mddev, struct bio *bi)",
        "pre": {
            "mddev": "!=null",
            "bi": "!=null"
        }
    }
},
{
    "kprobe:md_write_inc": {
        "description": "Unlike md_write_start(), it is safe to call md_write_inc() inside a spinlocked region.",
        "proto" :"void md_write_inc(struct mddev *mddev, struct bio *bi)",
        "pre": {
            "mddev": "your_condition_here",
            "bi": "your_condition_here"
        }
    }
},
{
    "kretprobe:clear_bit": {
        "description": "Clears the bit at the specified position in the recovery field of the mddev structure.",
        "proto" :"void clear_bit(int flag, unsigned long *addr)",
        "pre": {
            "flag": "in [MD_RECOVERY_FROZEN, MD_RECOVERY_RUNNING, MD_RECOVERY_RECOVER]",
            "addr": "!=null"
        },
    }
},
{
    "kprobe:clear_bit": {
        "description": "Clears the MD_RECOVERY_FROZEN bit of the recovery field of mddev.",
        "proto" :"void clear_bit(int nr, volatile unsigned long *addr)",
        "pre": {
            "nr": "==MD_RECOVERY_FROZEN",
            "addr": "==&mddev->recovery",
        },
    }
},
{
    "kretprobe:md_finish_reshape": {
        "description": "Called by personality module when reshape completes.",
        "proto" :"md_finish_reshape(struct mddev  mddev)",
        "pre": {
            "mddev": "!=null",
        },
    }
},
{
    "kprobe:md_finish_reshape": {
        "description": "Called by personality module when reshape completes.",
        "proto" :"md_finish_reshape(struct mddev  mddev)",
        "pre": {
            "mddev": "!=null",
        },
    }
},


{
    "kretprobe:ad_dpot_probe": {
        "description": "This function seems to be initializing some device parameters and creating sysfs files.",
        "proto" :"int ad_dpot_probe(struct device dev, struct ad_dpot_bus_data bdata, unsigned long devid, const char name)",
        "pre": {
            "dev": "!=null",
            "bdata": "!=null",
            "devid": "is valid device id",
            "name": "is valid string"
        },
    },
    "kretprobe:ad_dpot_remove_files": {
        "description": "This function seems to be removing some sysfs files based on the features provided.",
        "proto" :"void ad_dpot_remove_files(struct device dev, unsigned int features, unsigned int rdac)",
        "pre": {
            "dev": "!=null",
            "features": "is valid feature flag",
            "rdac": "is valid rdac value"
        },
    }
},
{
    "kprobe:ad_dpot_probe": {
        "description": "Probes the device and initializes the dpot_data structure.",
        "proto": "int (*ad_dpot_probe)(struct device *dev, struct ad_dpot_bus_data *bdata, unsigned long devid, const char *name)",
        "pre": {
            "dev": "!=null",
            "bdata": "!=null",
            "devid": "is valid device id",
            "name": "!=null"
        }
    },
    "kprobe:ad_dpot_remove_files": {
        "description": "Removes the files associated with the device and features.",
        "proto": "void (*ad_dpot_remove_files)(struct device *dev, unsigned int features, unsigned int rdac)",
        "pre": {
            "dev": "!=null",
            "features": "is valid feature flag",
            "rdac": "is valid rdac value"
        }
    },
    "kprobe:ad_dpot_add_files": {
        "description": "Adds files to the device based on the features and rdac value.",
        "proto": "int (*ad_dpot_add_files)(struct device *dev, unsigned int features, unsigned int rdac)",
        "pre": {
            "dev": "!=null",
            "features": "is valid feature flag",
            "rdac": "is valid rdac value"
        }
    }
},


{
    "kretprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "proto" :"void __iomem *(*fwnode_iomap)(struct fwnode_handle *fwnode, int index)",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kprobe:fwnode_iomap": {
        "description": "Maps the memory mapped IO for a given fwnode",
        "proto" :"void __iomem *(*fwnode_iomap)(struct fwnode_handle *fwnode, int index)",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        }
    }
},
{
    "kretprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode. Returns Linux IRQ number on success. Negative errno on failure.",
        "proto" :"int (*fwnode_irq_get)(const struct fwnode_handle *fwnode, unsigned int index)",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kprobe:fwnode_irq_get": {
        "description": "Get IRQ directly from a fwnode. Returns Linux IRQ number on success. Negative errno on failure.",
        "proto" :"int (*fwnode_irq_get)(const struct fwnode_handle *fwnode, unsigned int index)",
        "pre": {
            "fwnode": "!=null",
            "index": ">=0"
        },
    }
},
{
    "kretprobe:fwnode_irq_get_byname": {
        "description": "Find a match to the string @name in the 'interrupt-names' string array in _DSD for ACPI, or of_node for Device Tree. Then get the Linux IRQ number of the IRQ resource corresponding to the index of the matched string.",
        "proto" :"int fwnode_irq_get_byname(const struct fwnode_handle *fwnode, const char *name)",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null && is_string(name)"
        },
        "post": {
            "return": "is_int(return) && (return >= 0 || return < 0)"
        }
    }
},
{
    "kprobe:fwnode_irq_get_byname": {
        "description": "Find a match to the string @name in the 'interrupt-names' string array in _DSD for ACPI, or of_node for Device Tree. Then get the Linux IRQ number of the IRQ resource corresponding to the index of the matched string.",
        "proto" :"int (*fwnode_irq_get_byname)(const struct fwnode_handle *fwnode, const char *name)",
        "pre": {
            "fwnode": "!=null",
            "name": "!=null && is string"
        },
        "post": {
            "return": "is int && (>=0 || <0)"
        }
    }
},
{
    "kretprobe:fwnode_graph_get_endpoint_by_id": {
        "description": "Find and return an endpoint based on a given ID.",
        "proto" :"static long (*fwnode_graph_get_endpoint_by_id)(void *ep, struct fwnode_ep *fwnode_ep, int port, int endpoint, bool endpoint_next)",
        "pre": {
            "ep": "!=null",
            "fwnode_ep": "!=null",
            "port": "is valid port number",
            "endpoint": "is valid endpoint ID",
            "endpoint_next": "is boolean",
        },
    }
},
{
    "kprobe:fwnode_graph_get_endpoint_by_id": {
        "description": "Your description here",
        "proto" :"Your function prototype here",
        "pre": {
            "ep": "Your condition here",
            "fwnode_ep": "Your condition here",
            "ret": "Your condition here",
            "port": "Your condition here",
            "endpoint": "Your condition here",
            "endpoint_next": "Your condition here",
            "best_ep": "Your condition here",
            "best_ep_id": "Your condition here"
        },
    }
},
{
    "kretprobe:component_compare_of": {
        "description": "A common compare function when compare_data is device of_node. e.g. component_match_add_release(masterdev, &match, component_release_of, component_compare_of, component_dev_of_node)",
        "proto" :"int (*component_compare_of)(struct device *dev, void *data)",
        "pre": {
            "dev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:component_compare_of": {
        "description": "A common compare function when compare_data is device of_node. e.g. component_match_add_release(masterdev, &match, component_release_of, component_compare_of, component_dev_of_node)",
        "proto" :"int (*component_compare_of)(struct device *dev, void *data)",
        "pre": {
            "dev": "!=null",
            "data": "any"
        },
    }
},
{
    "kretprobe:component_match_add_release": {
        "description": "component_match_add_typed().",
        "proto" :"void (*component_match_add_release)(struct device *parent, struct component_match **matchptr, void (*release)(struct device *, void *), int (*compare)(struct device *, void *), void *compare_data)",
        "pre": {
            "parent": "!=null",
            "matchptr": "!=null",
            "release": "!=null",
            "compare": "!=null",
            "compare_data": "!=null"
        }
    }
},
{
    "kprobe:component_match_add_release": {
        "description": "component_match_add_typed()",
        "proto" :"void component_match_add_release(struct device *parent,struct component_match **matchptr,void (*release)(struct device *, void *),int (*compare)(struct device *, void *), void *compare_data)",
        "pre": {
            "parent": "!=null",
            "matchptr": "!=null",
            "release": "!=null",
            "compare": "!=null",
            "compare_data": "!=null"
        }
    }
},
{
    "kretprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible. Will return the device's driver's name if it is bound to a device. If the device is not bound to a driver, it will return the name of the bus it is attached to. If it is not attached to a bus either, an empty string will be returned.",
        "proto" :"const char *(*dev_driver_string)(const struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "is string"
        }
    }
},
{
    "kprobe:dev_driver_string": {
        "description": "Return a device's driver name, if at all possible. Will return the device's driver's name if it is bound to a device. If the device is not bound to a driver, it will return the name of the bus it is attached to. If it is not attached to a bus either, an empty string will be returned.",
        "proto" :"const char *(*dev_driver_string)(const struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:__fwnode_link_del": {
        "description": "Delete a link from a fwnode.",
        "proto" :"static void (*__fwnode_link_del)(struct fwnode_link *link)",
        "pre": {
            "link": "!=null"
        }
    }
},
{
    "kprobe:__fwnode_link_del": {
        "description": "Function is called.",
        "proto" :"static void (*__fwnode_link_del)(struct fwnode_link *link)",
        "pre": {
            "link": "!=null"
        }
    }
},
{
    "kretprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that. Returns pointer to allocated string on success, NULL on failure.",
        "proto" :"char *(*devm_kvasprintf)(struct device *dev, gfp_t gfp, const char *fmt, va_list ap)",
        "pre": {
            "dev": "!=null",
            "gfp": "is a valid gfp_t value",
            "fmt": "!=null",
            "ap": "!=null"
        },
    }
},
{
    "kprobe:devm_kvasprintf": {
        "description": "Allocate resource managed space and format a string into that. Returns pointer to allocated string on success, NULL on failure.",
        "proto" :"char *(*devm_kvasprintf)(struct device *dev, gfp_t gfp, const char *fmt, va_list ap)",
        "pre": {
            "dev": "!=null",
            "gfp": "is valid gfp_t mask",
            "fmt": "!=null",
            "ap": "is valid va_list"
        },
    }
},
{
    "kretprobe:request_firmware_prepare": {
        "description": "Prepares the firmware request, allocates memory for firmware, checks for built-in firmware, and binds with 'priv'.",
        "proto" :"int (*request_firmware_prepare)(struct firmware *firmware_p, const char *name, struct device *device, void *dbuf, size_t size, size_t offset, u32 opt_flags)",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "dbuf": "!=null",
            "size": ">=0",
            "offset": ">=0",
            "opt_flags": "in [OPTION_FLAG_1, OPTION_FLAG_2, ...]" // replace with actual flags
        },
    }
},
{
    "kprobe:alloc_lookup_fw_priv": {
        "description": "Allocates and looks up firmware private data.",
        "proto" :"static int (*alloc_lookup_fw_priv)(const char *name, struct firmware **fw_cache, struct fw_priv **fw_priv, void *dbuf, size_t size, size_t offset, u32 opt_flags)",
        "pre": {
            "name": "!=null",
            "fw_cache": "!=null",
            "fw_priv": "!=null",
            "dbuf": "!=null",
            "size": ">=0",
            "offset": ">=0",
            "opt_flags": "in [OPT_FLAG_1, OPT_FLAG_2, OPT_FLAG_3]",
        },
    }
},
{
    "kretprobe:firmware_request_cache": {
        "description": "request_firmware_nowait() with no uevent set.",
        "proto" :"int (*firmware_request_cache)(struct device *device, const char *name)",
        "pre": {
            "device": "!=null",
            "name": "!=null && !=''"
        }
    }
},
{
    "kprobe:firmware_request_cache": {
        "description": "request_firmware_nowait() with no uevent set.",
        "proto" :"int (*firmware_request_cache)(struct device *device, const char *name)",
        "pre": {
            "device": "!=null",
            "name": "!=null && !=''"
        }
    }
},
{
    "kretprobe:request_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer. This function works pretty much like request_firmware_into_buf except it allows a partial read of the file.",
        "proto" :"int (*request_partial_firmware_into_buf)(const struct firmware **firmware_p, const char *name, struct device *device, void *buf, size_t size, size_t offset)",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kprobe:request_partial_firmware_into_buf": {
        "description": "Load partial firmware into a previously allocated buffer. This function works pretty much like request_firmware_into_buf except it allows a partial read of the file.",
        "proto" :"int (*request_partial_firmware_into_buf)(const struct firmware **firmware_p, const char *name, struct device *device, void *buf, size_t size, size_t offset)",
        "pre": {
            "firmware_p": "!=null",
            "name": "!=null",
            "device": "!=null",
            "buf": "!=null",
            "size": ">=0",
            "offset": ">=0"
        }
    }
},
{
    "kretprobe:fw_abort_batch_reqs": {
        "description": "Failed batched requests are possible as well, in such cases we just share the struct fw_priv and won't release it until all requests are woken and have gone through this same path.",
        "proto" :"static void (*fw_abort_batch_reqs)(struct firmware *fw)",
        "pre": {
            "fw": "!=null"
        }
    }
},
{
    "kprobe:fw_abort_batch_reqs": {
        "description": "Failed batched requests are possible as well, in such cases we just share the struct fw_priv and won't release it until all requests are woken and have gone through this same path.",
        "proto" :"static void (*fw_abort_batch_reqs)(struct firmware *fw)",
        "pre": {
            "fw": "!=null"
        }
    }
},
{
    "kretprobe:scsi_cmd_allowed": {
        "description": "Root can do any command.",
        "proto" :"static bool (*scsi_cmd_allowed)(unsigned char cmd, bool open_for_write)",
        "pre": {
            "cmd": "in [0x00, 0xFF]",
            "open_for_write": "in [true, false]"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_cmd_allowed": {
        "description": "Root can do any command.",
        "proto" :"static bool (*scsi_cmd_allowed)(unsigned char cmd, bool open_for_write)",
        "pre": {
            "cmd": "is an unsigned char",
            "open_for_write": "is a boolean",
            "CAP_SYS_RAWIO": "capability is granted"
        },
    }
},
{
    "kretprobe:ioctl_probe": {
        "description": "Return an identifying string at *buffer*, if *buffer* is non-NULL, filling to the length stored at (int) *buffer*.",
        "proto" :"static int (*ioctl_probe)(struct Scsi_Host *host, void __user *buffer)",
        "pre": {
            "host": "!=null",
            "buffer": "!=null"
        },
    }
},
{
    "kprobe:ioctl_probe": {
        "description": "Return host identification. If @buffer is non-NULL, fill to the length stored at (int) @buffer.",
        "proto" :"static int (*ioctl_probe)(struct Scsi_Host *host, void __user *buffer)",
        "pre": {
            "host": "!=null",
            "buffer": "can be null or !=null"
        },
    }
},
{
    "kretprobe:__scsi_format_command": {
        "description": "Format SCSI command and print out all bytes in cdb.",
        "proto" :"static size_t (*__scsi_format_command)(char *logbuf, size_t logbuf_len, const unsigned char *cdb, size_t cdb_len)",
        "pre": {
            "logbuf": "!=null",
            "logbuf_len": ">0",
            "cdb": "!=null",
            "cdb_len": ">= scsi_command_size(cdb)"
        },
    }
},
{
    "kprobe:__scsi_format_command": {
        "description": "Formats a SCSI command and prints out all bytes in cdb.",
        "proto" :"static size_t (*__scsi_format_command)(char *logbuf, size_t logbuf_len, const unsigned char *cdb, size_t cdb_len)",
        "pre": {
            "logbuf": "!=null",
            "logbuf_len": ">0",
            "cdb": "!=null",
            "cdb_len": ">= scsi_command_size(cdb)"
        },
    }
},
{
    "kretprobe:scsi_print_command": {
        "description": "Prints out all bytes in cdb after formatting the opcode name, command name, and tag.",
        "proto" :"void (*scsi_print_command)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->cmd_len": ">16"
        },
    }
},
{
    "kprobe:scsi_print_command": {
        "description": "Format and print SCSI commands.",
        "proto": "void scsi_print_command(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->cmd_len": ">16"
        }
    }
},
{
    "kretprobe:scsi_change_queue_depth": {
        "description": "Sets the device queue depth and returns the new value.",
        "proto" :"int (*scsi_change_queue_depth)(struct scsi_device *sdev, int depth)",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0",
        },
    }
},
{
    "kprobe:scsi_change_queue_depth": {
        "description": "Change a device's queue depth. Sets the device queue depth and returns the new value.",
        "proto" :"int (*scsi_change_queue_depth)(struct scsi_device *sdev, int depth)",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0",
        },
    }
},
{
    "kretprobe:scsi_track_queue_full": {
        "description": "This function will track successive QUEUE_FULL events on a specific SCSI device to determine if and when there is a need to adjust the queue depth on the device.",
        "proto" :"int (*scsi_track_queue_full)(struct scsi_device *sdev, int depth)",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0"
        },
        "post": {
            "return": "in [-1, 0, depth]"
        }
    }
},
{
    "kprobe:scsi_track_queue_full": {
        "description": "This function will track successive QUEUE_FULL events on a specific SCSI device to determine if and when there is a need to adjust the queue depth on the device.",
        "proto" :"int (*scsi_track_queue_full)(struct scsi_device *sdev, int depth)",
        "pre": {
            "sdev": "!=null",
            "depth": ">=0",
        },
    }
},
{
    "kretprobe:scsi_report_opcode": {
        "description": "Uses the REPORT SUPPORTED OPERATION CODES to check support for the command identified with @opcode and @sa. If the command does not have a service action, @sa must be 0. Returns -EINVAL if RSOC fails, 0 if the command is not supported and 1 if the device claims to support the command.",
        "proto" :"int (*scsi_report_opcode)(struct scsi_device *sdev, unsigned char *buffer, unsigned int len, unsigned char opcode, unsigned short sa)",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null",
            "len": ">20",
            "opcode": "in [valid opcode range]",
            "sa": "in [valid service action range]"
        },
    }
},
{
    "kprobe:scsi_report_opcode": {
        "description": "Uses the REPORT SUPPORTED OPERATION CODES to check support for the command identified with @opcode and @sa. If the command does not have a service action, @sa must be 0. Returns -EINVAL if RSOC fails, 0 if the command is not supported and 1 if the device claims to support the command.",
        "proto" :"int (*scsi_report_opcode)(struct scsi_device *sdev, unsigned char *buffer, unsigned int len, unsigned char opcode, unsigned short sa)",
        "pre": {
            "sdev": "!=null",
            "buffer": "!=null && len >= 20",
            "len": "> 0",
            "opcode": "is unsigned char",
            "sa": "is unsigned short"
        },
    }
},
{
    "kretprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module. You must hold host_lock of the parent Scsi_Host or already have a reference when calling this. This will fail if a device is deleted or cancelled, or when the LLD module is in the process of being unloaded.",
        "proto" :"int scsi_device_get(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null && is_scsi_device(sdev) && !is_deleted(sdev) && !is_cancelled(sdev) && !is_unloading(sdev) && has_host_lock(sdev)"
        },
    }
},
{
    "kprobe:scsi_device_get": {
        "description": "Gets a reference to the scsi_device and increments the use count of the underlying LLDD module. This will fail if a device is deleted or cancelled, or when the LLD module is in the process of being unloaded.",
        "proto" :"int scsi_device_get(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_put": {
        "description": "Release a reference to the scsi_device and decrements the use count of the underlying LLDD module. The device is freed once the last user vanishes.",
        "proto": "void (*scsi_device_put)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_put": {
        "description": "Release a reference to the scsi_device and decrements the use count of the underlying LLDD module. The device is freed once the last user vanishes.",
        "proto": "void scsi_device_put(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:__scsi_iterate_devices": {
        "description": "Iterates over SCSI devices, skipping devices that we can't get a reference to.",
        "proto" :"__scsi_iterate_devices(struct Scsi_Host *shost, struct scsi_device *prev)",
        "pre": {
            "shost": "!=null",
            "prev": "can be null or valid pointer"
        },
    }
},
{
    "__scsi_iterate_devices": {
        "description": "Iterates over SCSI devices, skipping devices that we can't get a reference to.",
        "proto": "void __scsi_iterate_devices(struct Scsi_Host *shost, struct scsi_device *prev)",
        "pre": {
            "shost": "!=null",
            "prev": "can be null or valid pointer to struct scsi_device"
        },
    }
},
{
    "kretprobe:starget_for_each_device": {
        "description": "This traverses over each device of @starget. The devices have a reference that must be released by scsi_host_put when breaking out of the loop.",
        "proto" :"void (*starget_for_each_device)(struct scsi_target *starget, void *data, void (*fn)(struct scsi_device *, void *))",
        "pre": {
            "starget": "!=null",
            "data": "can be any value",
            "fn": "!=null"
        },
    }
},
{
    "kprobe:starget_for_each_device": {
        "description": "Helper to walk all devices of a target. This traverses over each device of @starget. The devices have a reference that must be released by scsi_host_put when breaking out of the loop.",
        "proto" :"void (*starget_for_each_device)(struct scsi_target *starget, void *data, void (*fn)(struct scsi_device *, void *))",
        "pre": {
            "starget": "!=null",
            "data": "can be any value",
            "fn": "!=null"
        }
    }
},
{
    "kretprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED). This traverses over each device of @starget. It does _not_ take a reference on the scsi_device, so the whole loop must be protected by shost->host_lock. Note: The only reason why drivers would want to use this is because they need to access the device list in irq context. Otherwise you really want to use starget_for_each_device instead.",
        "proto" :"void (*__starget_for_each_device)(struct scsi_target *starget, void *data, void (*fn)(struct scsi_device *, void *))",
        "pre": {
            "starget": "!=null",
            "data": "!=null",
            "fn": "!=null"
        }
    }
},
{
    "kprobe:__starget_for_each_device": {
        "description": "Helper to walk all devices of a target (UNLOCKED). This traverses over each device of @starget. It does _not_ take a reference on the scsi_device, so the whole loop must be protected by shost->host_lock. Note: The only reason why drivers would want to use this is because they need to access the device list in irq context. Otherwise you really want to use starget_for_each_device instead.",
        "proto" :"void (*__starget_for_each_device)(struct scsi_target *starget, void *data, void (*fn)(struct scsi_device *, void *))",
        "pre": {
            "starget": "!=null",
            "data": "can be any value",
            "fn": "!=null and is a valid function pointer"
        }
    }
},
{
    "kretprobe:__scsi_device_lookup_by_target": {
        "description": "Looks up the scsi_device with the specified @lun for a given @starget. The returned scsi_device does not have an additional reference. You must hold the host's host_lock over this call and any access to the returned scsi_device. A scsi_device in state SDEV_DEL is skipped. Note: The only reason why drivers should use this is because they need to access the device list in irq context. Otherwise you really want to use scsi_device_lookup_by_target instead.",
        "proto" :"struct scsi_device *(__scsi_device_lookup_by_target)(struct scsi_target *starget, u64 lun)",
        "pre": {
            "starget": "!=null",
            "lun": ">=0"
        }
    }
},
{
    "kprobe:__scsi_device_lookup_by_target": {
        "description": "Looks up the scsi_device with the specified @lun for a given @starget. The returned scsi_device does not have an additional reference. You must hold the host's host_lock over this call and any access to the returned scsi_device. A scsi_device in state SDEV_DEL is skipped. Note: The only reason why drivers should use this is because they need to access the device list in irq context. Otherwise you really want to use scsi_device_lookup_by_target instead.",
        "proto" :"struct scsi_device *(*__scsi_device_lookup_by_target)(struct scsi_target *starget, u64 lun)",
        "pre": {
            "starget": "!=null",
            "lun": ">=0"
        }
    }
},
{
    "kretprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued. We block until the host is out of error recovery, and then check to see whether the host or the device is offline.",
        "proto" :"int (*scsi_block_when_processing_errors)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:scsi_block_when_processing_errors": {
        "description": "Prevent cmds from being queued. We block until the host is out of error recovery, and then check to see whether the host or the device is offline.",
        "proto" :"int (*scsi_block_when_processing_errors)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery. If @sense_bytes is 0 the command sent must be one that does not transfer any data. If @sense_bytes != 0 @cmnd is ignored and this functions sets up a REQUEST_SENSE command and cmnd buffers to read @sense_bytes into @scmd->sense_buffer.",
        "proto" :"void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses, unsigned char *cmnd, int cmnd_size, unsigned sense_bytes)",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null || sense_bytes != 0",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kprobe:scsi_eh_prep_cmnd": {
        "description": "Save a scsi command info as part of error recovery. This function is used to save a scsi command information before re-execution as part of the error recovery process. If @sense_bytes is 0 the command sent must be one that does not transfer any data. If @sense_bytes != 0 @cmnd is ignored and this functions sets up a REQUEST_SENSE command and cmnd buffers to read @sense_bytes into @scmd->sense_buffer.",
        "proto" :"void (*scsi_eh_prep_cmnd)(struct scsi_cmnd *scmd, struct scsi_eh_save *ses, unsigned char *cmnd, int cmnd_size, unsigned sense_bytes)",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null",
            "cmnd": "!=null or ==null if sense_bytes != 0",
            "cmnd_size": "<= MAX_COMMAND_SIZE",
            "sense_bytes": ">= 0"
        }
    }
},
{
    "kretprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery. Undo any damage done by scsi_eh_prep_cmnd().",
        "proto" :"void (*scsi_eh_restore_cmnd)(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_restore_cmnd": {
        "description": "Restore a scsi command info as part of error recovery. Undo any damage done by scsi_eh_prep_cmnd().",
        "proto" :"void (*scsi_eh_restore_cmnd)(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)",
        "pre": {
            "scmd": "!=null",
            "ses": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with. We don't want to use the normal command completion while we are still handling errors - it may cause other commands to be queued, and that would disturb what we are doing. Thus we really want to keep a list of pending commands for final completion, and once we are ready to leave error handling we handle completion for real.",
        "proto" :"void (*scsi_eh_finish_cmd)(struct scsi_cmnd *scmd, struct list_head *done_q)",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_finish_cmd": {
        "description": "Handle a cmd that eh is finished with. We don't want to use the normal command completion while we are still handling errors - it may cause other commands to be queued, and that would disturb what we are doing. Thus we really want to keep a list of pending commands for final completion, and once we are ready to leave error handling we handle completion for real.",
        "proto" :"void scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)",
        "pre": {
            "scmd": "!=null",
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them. @done_q: list_head of processed commands.",
        "proto": "void (*scsi_eh_flush_done_q)(struct list_head *done_q)",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kprobe:scsi_eh_flush_done_q": {
        "description": "Finish processed commands or retry them. @done_q:list_head of processed commands.",
        "proto" :"void (*scsi_eh_flush_done_q)(struct list_head *done_q)",
        "pre": {
            "done_q": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_bus_reset": {
        "description": "Ask host to perform a bus reset",
        "proto" :"static enum scsi_disposition scsi_try_bus_reset(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_bus_reset": {
        "description": "Ask host to perform a bus reset",
        "proto" :"static enum scsi_disposition scsi_try_bus_reset(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset. There is no timeout for this operation. If this operation is unreliable for a given host, then the host itself needs to put a timer on it, and set the host back to a consistent state prior to returning.",
        "proto" :"static enum scsi_disposition scsi_try_target_reset(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_try_target_reset": {
        "description": "Ask host to perform a target reset. There is no timeout for this operation. If this operation is unreliable for a given host, then the host itself needs to put a timer on it, and set the host back to a consistent state prior to returning.",
        "proto" :"static enum scsi_disposition scsi_try_target_reset(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kretprobe:scsi_report_sense": {
        "description": "no valid sense data",
        "proto" :"static long (*scsi_report_sense)(void *sdev, void *sshdr)",
        "pre": {
            "sdev": "!=null",
            "sshdr": "!=null"
        },
    }
},
{
    "kprobe:scsi_report_sense": {
        "description": "no valid sense data",
        "proto" :"static long (*scsi_report_sense)(void *sdev, void *sshdr)",
        "pre": {
            "sdev": "!=null",
            "sshdr": "!=null"
        },
    }
},
{
    "kretprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format).",
        "proto": "bool (*scsi_get_sense_info_fld)(const u8 *sense_buffer, int sb_len, u64 *info_out)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_get_sense_info_fld": {
        "description": "Get information field from sense data (either fixed or descriptor format).",
        "proto": "bool (*scsi_get_sense_info_fld)(const u8 *sense_buffer, int sb_len, u64 *info_out)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "info_out": "!=null"
        }
    }
},
{
    "kretprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer fast IO failure and device loss timers. Do not modify a timer that was already started.",
        "proto" :"void srp_start_tl_fail_timers(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_start_tl_fail_timers": {
        "description": "Start the transport layer fast IO failure and device loss timers. Do not modify a timer that was already started.",
        "proto" :"void srp_start_tl_fail_timers(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},


{
    "kretprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH. If a timeout occurs while an rport is in the blocked state, ask the SCSI EH to continue waiting (SCSI_EH_RESET_TIMER). Otherwise let the SCSI core handle the timeout (SCSI_EH_NOT_HANDLED). Note: This function is called from soft-IRQ context and with the request queue lock held.",
        "proto" :"enum scsi_timeout_action srp_timed_out(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "your_condition_here"
        }
    }
},
{
    "kprobe:srp_timed_out": {
        "description": "SRP transport intercept of the SCSI timeout EH. If a timeout occurs while an rport is in the blocked state, ask the SCSI EH to continue waiting (SCSI_EH_RESET_TIMER). Otherwise let the SCSI core handle the timeout (SCSI_EH_NOT_HANDLED). This function is called from soft-IRQ context and with the request queue lock held.",
        "proto" :"enum scsi_timeout_action srp_timed_out(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "your_condition_here"
        }
    }
},
{
    "kretprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "proto": "void (*srp_rport_get)(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_get": {
        "description": "Increment rport reference count",
        "proto" :"void (*srp_rport_get)(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null",
        },
    }
},
{
    "kretprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "proto": "void (*srp_rport_put)(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:srp_rport_put": {
        "description": "Decrement rport reference count",
        "proto": "void (*srp_rport_put)(struct srp_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists. Returns the number of sg lists actually used, zero if the sg lists is NULL, or -ENOMEM if the mapping failed.",
        "proto" :"int (*scsi_dma_map)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [0, -ENOMEM] U NaturalNumbers"
        }
    }
},
{
    "kprobe:scsi_dma_map": {
        "description": "Perform DMA mapping against command's sg lists. Returns the number of sg lists actually used, zero if the sg lists is NULL, or -ENOMEM if the mapping failed.",
        "proto" :"int (*scsi_dma_map)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:scsi_dma_unmap": {
        "description": "Unmap command's sg lists mapped by scsi_dma_map",
        "proto": "void scsi_dma_unmap(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:scsi_dma_unmap": {
        "description": "Unmap command's sg lists mapped by scsi_dma_map",
        "proto" :"void (*scsi_dma_unmap)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:u32fc_get_event_number": {
        "description": "Obtain the next sequential FC event number. Atomic used to avoid lockunlock...",
        "proto" :"static long (*u32fc_get_event_number)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:u32fc_get_event_number": {
        "description": "Obtain the next sequential FC event number. Atomic used to avoid lockunlock...",
        "proto" :"static long (*u32fc_get_event_number)(void)",
        "pre": {}
    }
},
{
    "kretprobe:voidfc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host. This routine assumes no locks are held on entry.",
        "proto" :"void (*voidfc_host_post_fc_event)(struct Scsi_Host *shost, u32 event_number, enum fc_host_event_code event_code, u32 data_len, char *data_buf, u64 vendor_id)",
        "pre": {
            "shost": "!=null",
            "event_number": ">=0",
            "event_code": "in [enum fc_host_event_code]",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": ">=0"
        }
    }
},
{
    "kprobe:voidfc_host_post_fc_event": {
        "description": "Routine to do the work of posting an event on an fc_host.",
        "proto" :"void (*voidfc_host_post_fc_event)(struct Scsi_Host *shost, u32 event_number, enum fc_host_event_code event_code, u32 data_len, char *data_buf, u64 vendor_id)",
        "pre": {
            "shost": "!=null",
            "event_number": ">=0",
            "event_code": "in [enum fc_host_event_code]",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": ">=0"
        },
    }
},
{
    "kretprobe:fc_host_post_event": {
        "description": "Called to post an event on an fc_host. @shost: host the event occurred on @event_number: fc event number obtained from get_fc_event_number() @event_code: fc_host event being posted @event_data: 32bits of data for the event being posted. This routine assumes no locks are held on entry.",
        "proto" :"void (*fc_host_post_event)(struct Scsi_Host *shost, u32 event_number, enum fc_host_event_code event_code, u32 event_data)",
        "pre": {
            "shost": "!=null",
            "event_number": ">=0",
            "event_code": "in [enum fc_host_event_code]",
            "event_data": ">=0"
        }
    }
},
{
    "kprobe:fc_host_post_event": {
        "description": "Called to post an event on an fc_host. @shost: host the event occurred on @event_number: fc event number obtained from get_fc_event_number() @event_code: fc_host event being posted @event_data: 32bits of data for the event being posted. This routine assumes no locks are held on entry.",
        "proto" :"void (*fc_host_post_event)(struct Scsi_Host *shost, u32 event_number, enum fc_host_event_code event_code, u32 event_data)",
        "pre": {
            "shost": "!=null",
            "event_number": "is a valid fc event number",
            "event_code": "is a valid fc_host_event_code",
            "event_data": "is a 32-bit integer",
        },
    }
},
{
    "kretprobe:fc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host. This routine assumes no locks are held on entry.",
        "proto" :"void (*fc_host_post_vendor_event)(struct Scsi_Host *shost, u32 event_number, u32 data_len, char * data_buf, u64 vendor_id)",
        "pre": {
            "shost": "!=null",
            "event_number": ">=0",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": ">=0"
        }
    }
},
{
    "kprobe:voidfc_host_post_vendor_event": {
        "description": "Called to post a vendor unique event on an fc_host. This routine assumes no locks are held on entry.",
        "proto" :"void (*voidfc_host_post_vendor_event)(struct Scsi_Host *shost, u32 event_number, u32 data_len, char * data_buf, u64 vendor_id)",
        "pre": {
            "shost": "!=null",
            "event_number": ">=0",
            "data_len": ">=0",
            "data_buf": "!=null",
            "vendor_id": ">=0"
        },
    }
},
{
    "kretprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn. The fc_rport is associated with the host @shost. The wwpn of the fc_rport device is @wwpn. This routine assumes no locks are held on entry.",
        "proto" :"struct fc_rport *(*fc_find_rport_by_wwpn)(struct Scsi_Host *shost, u64 wwpn)",
        "pre": {
            "shost": "!=null",
            "wwpn": ">=0"
        }
    }
},
{
    "kprobe:fc_find_rport_by_wwpn": {
        "description": "Find the fc_rport pointer for a given wwpn. The fc_rport is associated with the host @shost. The wwpn of the fc_rport device is @wwpn. This routine assumes no locks are held on entry.",
        "proto" :"struct fc_rport *(*fc_find_rport_by_wwpn)(struct Scsi_Host *shost, u64 wwpn)",
        "pre": {
            "shost": "!=null",
            "wwpn": "is valid wwpn"
        },
    }
},
{
    "kretprobe:fc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN. @shost:host the FPIN was received on @fpin_len:length of FPIN payload, in bytes @fpin_buf:pointer to FPIN payload @event_acknowledge:1, if LLDD handles this event. Notes: This routine assumes no locks are held on entry.",
        "proto" :"void (*fc_host_fpin_rcv)(struct Scsi_Host *shost, u32 fpin_len, char *fpin_buf, u8 event_acknowledge)",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kprobe:voidfc_host_fpin_rcv": {
        "description": "Routine to process a received FPIN. The FPIN was received on host. Length of FPIN payload, in bytes. Pointer to FPIN payload. 1, if LLDD handles this event. This routine assumes no locks are held on entry.",
        "proto" :"void (*voidfc_host_fpin_rcv)(struct Scsi_Host *shost, u32 fpin_len, char *fpin_buf, u8 event_acknowledge)",
        "pre": {
            "shost": "!=null",
            "fpin_len": ">=0",
            "fpin_buf": "!=null",
            "event_acknowledge": "in [0, 1]"
        }
    }
},
{
    "kretprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler. This routine protects against error handlers getting invoked while a rport is in a blocked state, typically due to a temporarily loss of connectivity. If the error handlers are allowed to proceed, requests to abort io, reset the target, etc will likely fail as there is no way to communicate with the device to perform the requested function. These failures may result in the midlayer taking the device offline, requiring manual intervention to restore operation. This routine, called whenever an io times out, validates the state of the underlying rport. If the rport is blocked, it returns EH_RESET_TIMER, which will continue to reschedule the timeout. Eventually, either the device will return, or devloss_tmo will fire, and when the timeout then fires, it will be handled normally. If the rport is not blocked, normal error handling continues.",
        "proto" :"enum scsi_timeout_action fc_eh_timed_out(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_timed_out": {
        "description": "FC Transport IO timeout intercept handler. This routine protects against error handlers getting invoked while a rport is in a blocked state, typically due to a temporarily loss of connectivity. If the error handlers are allowed to proceed, requests to abort io, reset the target, etc will likely fail as there is no way to communicate with the device to perform the requested function. These failures may result in the midlayer taking the device offline, requiring manual intervention to restore operation. This routine, called whenever an io times out, validates the state of the underlying rport. If the rport is blocked, it returns EH_RESET_TIMER, which will continue to reschedule the timeout. Eventually, either the device will return, or devloss_tmo will fire, and when the timeout then fires, it will be handled normally. If the rport is not blocked, normal error handling continues. Notes: This routine assumes no locks are held on entry.",
        "proto" :"enum scsi_timeout_action (*fc_eh_timed_out)(struct scsi_cmnd *scmd)",
        "pre": {
            "scmd": "!=null"
        }
    }
},


{
    "kretprobe:voidfc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host. This routine is expected to be called immediately preceding the a driver's call to scsi_remove_host(). WARNING: A driver utilizing the fc_transport, which fails to call this routine prior to scsi_remove_host(), will leave dangling objects in sysclassfc_remote_ports. Access to any of these objects can result in a system crash !!! Notes: This routine assumes no locks are held on entry.",
        "proto" :"void (*voidfc_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:voidfc_remove_host": {
        "description": "Called to terminate any fc_transport-related elements for a scsi host. This routine is expected to be called immediately preceding the a driver's call to scsi_remove_host(). WARNING: A driver utilizing the fc_transport, which fails to call this routine prior to scsi_remove_host(), will leave dangling objects in sysclassfc_remote_ports. Access to any of these objects can result in a system crash !!! Notes: This routine assumes no locks are held on entry.",
        "proto" :"void (*voidfc_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null",
            "call_order": "voidfc_remove_host() before scsi_remove_host()"
        }
    }
},
{
    "kretprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port. The LLDD calls this routine to notify the transport of the existence of a remote port. The LLDD provides the unique identifiers (wwpn,wwn) of the port, it's FC address (port_id), and the FC4 roles that are active for the port. This routine is responsible for returning a remote port structure.",
        "proto" :"struct fc_rport *(*fc_remote_port_add)(struct Scsi_Host *shost, int channel, struct fc_rport_identifiers *ids)",
        "pre": {
            "shost": "!=null",
            "channel": "!=null",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_remote_port_add": {
        "description": "Notify fc transport of the existence of a remote FC port. The LLDD provides the unique identifiers (wwpn,wwn) of the port, it's FC address (port_id), and the FC4 roles that are active for the port. For ports that are FCP targets (aka scsi targets), the FC transport maintains consistent target id bindings on behalf of the LLDD. This routine is responsible for returning a remote port structure. Should not be called from interrupt context.",
        "proto" :"struct fc_rport *(*fc_remote_port_add)(struct Scsi_Host *shost, int channel, struct fc_rport_identifiers  *ids)",
        "pre": {
            "shost": "!=null",
            "channel": "is an integer",
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:voidfc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "proto" :"void (*voidfc_remote_port_delete)(struct fc_rport  *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:voidfc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence. The LLDD calls this routine to notify the transport that a remote port is no longer part of the topology. If the remote port is not an FCP Target, it will be fully torn down and deallocated, including the fc_remote_port class device. If the remote port is an FCP Target, the port will be placed in a temporary blocked state.",
        "proto" :"void (*voidfc_remote_port_delete)(struct fc_rport  *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},

{
    "kprobe:fc_remote_port_create": {
        "description": "Creates a remote port and notifies the fc transport that a remote port is no longer in existence.",
        "proto" :"static struct fc_rport *(*fc_remote_port_create)(struct Scsi_Host *shost, u32 channel, struct fc_rport_identifiers *ids)",
        "pre": {
            "shost": "!=null",
            "channel": ">=0",
            "ids": "!=null"
        },
    },
    "kprobe:fc_remote_port_delete": {
        "description": "Notifies the fc transport that a remote port is no longer in existence.",
        "proto" :"void (*fc_remote_port_delete)(struct fc_rport *rport)",
        "pre": {
            "rport": "!=null"
        },
    },
    "kprobe:fc_remote_port_rolechg": {
        "description": "Changes the role of a remote port.",
        "proto" :"void (*fc_remote_port_rolechg)(struct fc_rport *rport, u32 roles)",
        "pre": {
            "rport": "!=null",
            "roles": ">=0"
        },
    }
},
{
    "kretprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport. This routine can be called from a FC LLD scsi_eh callback. It blocks the scsi_eh thread until the fc_rport leaves the FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is necessary to avoid the scsi_eh failing recovery actions for blocked rports which would lead to offlined SCSI devices.",
        "proto" :"int (*fc_block_rport)(struct fc_rport *rport)",
        "pre": {
            "rport": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_rport": {
        "description": "Block SCSI eh thread for blocked fc_rport. This routine can be called from a FC LLD scsi_eh callback. It blocks the scsi_eh thread until the fc_rport leaves the FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is necessary to avoid the scsi_eh failing recovery actions for blocked rports which would lead to offlined SCSI devices.",
        "proto" :"int (*fc_block_rport)(struct fc_rport *rport)",
        "pre": {
            "rport": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kretprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport. This routine can be called from a FC LLD scsi_eh callback. It blocks the scsi_eh thread until the fc_rport leaves the FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is necessary to avoid the scsi_eh failing recovery actions for blocked rports which would lead to offlined SCSI devices.",
        "proto" :"int (*fc_block_scsi_eh)(struct scsi_cmnd *cmnd)",
        "pre": {
            "cmnd": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kprobe:fc_block_scsi_eh": {
        "description": "Block SCSI eh thread for blocked fc_rport. This routine can be called from a FC LLD scsi_eh callback. It blocks the scsi_eh thread until the fc_rport leaves the FC_PORTSTATE_BLOCKED, or the fast_io_fail_tmo fires. This is necessary to avoid the scsi_eh failing recovery actions for blocked rports which would lead to offlined SCSI devices.",
        "proto" :"int (*fc_block_scsi_eh)(struct scsi_cmnd *cmnd)",
        "pre": {
            "cmnd": "!=null"
        },
        "post": {
            "return": "in [0, FAST_IO_FAIL]"
        }
    }
},
{
    "kretprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport. This routine assumes no locks are held on entry.",
        "proto" :"struct fc_vport *(*fc_vport_create)(struct Scsi_Host *shost, int channel, struct fc_vport_identifiers *ids)",
        "pre": {
            "shost": "!=null",
            "channel": ">=0",
            "ids": "!=null"
        }
    }
},
{
    "kprobe:fc_vport_create": {
        "description": "Admin App or LLDD requests creation of a vport. This routine assumes no locks are held on entry.",
        "proto" :"struct fc_vport *(*fc_vport_create)(struct Scsi_Host *shost, int channel, struct fc_vport_identifiers *ids)",
        "pre": {
            "shost": "!=null",
            "channel": "is an integer",
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Description of the function",
        "proto" :"void kfree(void *vport)",
        "pre": {
            "vport": "!=null"
        }
    },
    "kretprobe:scsi_is_fc_vport": {
        "description": "Description of the function",
        "proto" :"static int scsi_is_fc_vport(const struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:kfree(vport);}static int scsi_is_fc_vport(const struct device *dev)": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "Your first argument": "Your first argument's constraints",
            "Your second argument": "Your second argument's constraints",
            "Your third argument": "Your third argument's constraints",
            "Your fourth argument": "Your fourth argument's constraints",
        },
    }
},

{
    "kprobe:period_to_str": {
        "description": "Translate the period into ns according to the current spec for SDTRPPR messages",
        "proto" :"static int (*period_to_str)(char *buf, int period)",
        "pre": {
            "buf": "!=null",
            "period": ">0",
        },
    }
},
{
    "kretprobe:spi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device. All memory allocations are atomic, so may be called from any context including those holding SCSI locks.",
        "proto" :"void (*spi_schedule_dv_device)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:voidspi_schedule_dv_device": {
        "description": "Schedule domain validation to occur on the device. Identical to spi_dv_device() above, except that the DV will be scheduled to occur in a workqueue later. All memory allocations are atomic, so may be called from any context including those holding SCSI locks.",
        "proto" :"void (*spi_schedule_dv_device)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement. Each SPI port is required to maintain a transfer agreement for each other port on the bus. This function prints a one-line summary of the current agreement; more detailed information is available in sysfs.",
        "proto" :"void (*spi_display_xfer_agreement)(struct scsi_target *starget)",
        "pre": {
            "starget": "!=null"
        }
    }
},
{
    "kprobe:spi_display_xfer_agreement": {
        "description": "Print the current target transfer agreement. Each SPI port is required to maintain a transfer agreement for each other port on the bus. This function prints a one-line summary of the current agreement; more detailed information is available in sysfs.",
        "proto" :"void (*spi_display_xfer_agreement)(struct scsi_target *starget)",
        "pre": {
            "starget": "!=null",
        },
    }
},


{
    "kretprobe:sas_remove_children": {
        "description": "Tear down a device's SAS data structures. Removes all SAS PHYs and remote PHYs for a given object.",
        "proto" :"void sas_remove_children(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:sas_remove_children": {
        "description": "Tear down a devices SAS data structures. Removes all SAS PHYs and remote PHYs for a given object.",
        "proto" :"void sas_remove_children(struct device *dev)",
        "pre": {
            "dev": "!=null",
            // Add more preconditions here as per your understanding of the function
        },
    }
},
{
    "kretprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures. Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the Scsi_Host as well. Note: Do not call scsi_remove_host() on the Scsi_Host any more, as it is already removed.",
        "proto" :"void (*sas_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:sas_remove_host": {
        "description": "Tear down a Scsi_Host's SAS data structures. Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the Scsi_Host as well. Note: Do not call scsi_remove_host() on the Scsi_Host any more, as it is already removed.",
        "proto" :"void (*sas_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:sas_get_address": {
        "description": "Returns the SAS address of the scsi device.",
        "proto" :"u64 (*sas_get_address)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:sas_get_address": {
        "description": "Returns the SAS address of the scsi device.",
        "proto" :"u64 (*sas_get_address)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null",
        },
    }
},
{
    "kretprobe:sas_phy_alloc": {
        "description": "Allocates and initialize a SAS PHY structure. It will be added in the device tree below the device specified by @parent, which has to be either a Scsi_Host or sas_rphy. Returns: SAS PHY allocated or %NULL if the allocation failed.",
        "proto" :"struct sas_phy *(*sas_phy_alloc)(struct device *parent, int number)",
        "pre": {
            "parent": "!=null",
            "number": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:sas_phy_alloc": {
        "description": "Allocates and initialize a SAS PHY structure. It will be added in the device tree below the device specified by @parent, which has to be either a Scsi_Host or sas_rphy. Returns: SAS PHY allocated or %NULL if the allocation failed.",
        "proto" :"struct sas_phy *(*sas_phy_alloc)(struct device *parent, int number)",
        "pre": {
            "parent": "!=null",
            "number": ">=0",
        },
    }
},
{
    "kretprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy. Publishes a SAS PHY to the rest of the system.",
        "proto" :"int (*sas_phy_add)(struct sas_phy *phy)",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_phy_add": {
        "description": "Add a SAS PHY to the device hierarchy. Publishes a SAS PHY to the rest of the system.",
        "proto" :"int (*sas_phy_add)(struct sas_phy *phy)",
        "pre": {
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_phy_free": {
        "description": "Free a SAS PHY. This function must only be called on a PHY that has not successfully been added using sas_phy_add().",
        "proto" :"void (*sas_phy_free)(struct sas_phy *phy)",
        "pre": {
            "phy": "!=null && !sas_phy_add(phy)"
        }
    }
},
{
    "kprobe:sas_phy_free": {
        "description": "Free a SAS PHY. This function must only be called on a PHY that has not successfully been added using sas_phy_add().",
        "proto" :"void (*sas_phy_free)(struct sas_phy *phy)",
        "pre": {
            "phy": "!=null && !sas_phy_add(phy)"
        }
    }
},
{
    "kretprobe:sas_port_alloc": {
        "description": "Allocates a SAS port structure. It will be added to the device tree below the device specified by @parent which must be either a Scsi_Host or a sas_expander_device. Returns %NULL on error",
        "proto" :"struct sas_port *(*sas_port_alloc)(struct device *parent, int port_id)",
        "pre": {
            "parent": "!=null && (is_Scsi_Host || is_sas_expander_device)",
            "port_id": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:sas_port_alloc": {
        "description": "Allocate and initialize a SAS port structure. It will be added to the device tree below the device specified by @parent which must be either a Scsi_Host or a sas_expander_device. Returns %NULL on error",
        "proto" :"struct sas_port *(*sas_port_alloc)(struct device *parent, int port_id)",
        "pre": {
            "parent": "!=null && (is_Scsi_Host(parent) || is_sas_expander_device(parent))",
            "port_id": ">=0"
        }
    }
},
{
    "kretprobe:sas_port_alloc_num": {
        "description": "Allocates a SAS port structure and a number to go with it. This interface is really for adapters where the port number has no meansing, so the sas class should manage them. It will be added to the device tree below the device specified by @parent which must be either a Scsi_Host or a sas_expander_device. Returns %NULL on error",
        "proto" :"struct sas_port *(*sas_port_alloc_num)(struct device *parent)",
        "pre": {
            "parent": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:sas_port_alloc_num": {
        "description": "Allocates a SAS port structure and a number to go with it. This interface is really for adapters where the port number has no meansing, so the sas class should manage them. It will be added to the device tree below the device specified by @parent which must be either a Scsi_Host or a sas_expander_device. Returns %NULL on error",
        "proto" :"struct sas_port *(*sas_port_alloc_num)(struct device *parent)",
        "pre": {
            "parent": "!=null"
        },
    }
},
{
    "kretprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy. Publishes a port to the rest of the system.",
        "proto" :"int (*sas_port_add)(struct sas_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_add": {
        "description": "Add a SAS port to the device hierarchy. Publishes a port to the rest of the system.",
        "proto" :"int (*sas_port_add)(struct sas_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_free": {
        "description": "Free a SAS PORT. This function must only be called on a PORT that has not successfully been added using sas_port_add().",
        "proto" :"void (*sas_port_free)(struct sas_port *port)",
        "pre": {
            "port": "!=null && !sas_port_add(port)"
        }
    }
},
{
    "kprobe:sas_port_free": {
        "description": "Frees the specified SAS PORT. This function must only be called on a PORT that has not successfully been added using sas_port_add().",
        "proto" :"void (*sas_port_free)(struct sas_port *port)",
        "pre": {
            "port": "!=null && !sas_port_added(port)"
        }
    }
},
{
    "kretprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "proto": "struct sas_phy *(*sas_port_get_phy)(struct sas_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:sas_port_get_phy": {
        "description": "Try to take a reference on a port member",
        "proto" :"struct sas_phy *(*sas_port_get_phy)(struct sas_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port. When a port is initially created, it is empty (has no phys). All ports must have at least one phy to operate, and all wide ports must have at least two. The current code makes no difference between ports and wide ports, but the only object that can be connected to a remote device is a port, so ports must be formed on all devices with phys if they're connected to anything.",
        "proto" :"void (*sas_port_add_phy)(struct sas_port *port, struct sas_phy *phy)",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        },
        "post": {
            "port.phys": ">=1"
        }
    }
},
{
    "kprobe:sas_port_add_phy": {
        "description": "Add another phy to a port to form a wide port. All ports must have at least one phy to operate, and all wide ports must have at least two. The only object that can be connected to a remote device is a port, so ports must be formed on all devices with phys if they're connected to anything.",
        "proto" :"void (*sas_port_add_phy)(struct sas_port *port, struct sas_phy *phy)",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port. This operation is used for tearing down ports again. It must be done to every port or wide port before calling sas_port_delete.",
        "proto" :"void (*sas_port_delete_phy)(struct sas_port *port, struct sas_phy *phy)",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kprobe:sas_port_delete_phy": {
        "description": "Remove a phy from a port or wide port. This operation is used for tearing down ports again. It must be done to every port or wide port before calling sas_port_delete.",
        "proto" :"void (*sas_port_delete_phy)(struct sas_port *port, struct sas_phy *phy)",
        "pre": {
            "port": "!=null",
            "phy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_initialize": {
        "description": "Used by both sas_end_device_alloc() and sas_expander_alloc() to initialise the common rphy component of each.",
        "proto" :"static void sas_rphy_initialize(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_initialize": {
        "description": "Used by both sas_end_device_alloc() and sas_expander_alloc() to initialise the common rphy component of each.",
        "proto" :"static void sas_rphy_initialize(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy. Publishes a SAS remote PHY to the rest of the system.",
        "proto" :"int (*sas_rphy_add)(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_add": {
        "description": "Add a SAS remote PHY to the device hierarchy. Publishes a SAS remote PHY to the rest of the system.",
        "proto" :"int (*sas_rphy_add)(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_rphy_free": {
        "description": "Free the memory allocated to a sas_rphy object.",
        "proto" :"void (*sas_rphy_free)(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        },
    }
},
{
    "kprobe:sas_rphy_free": {
        "description": "Needs more information",
        "proto" :"void sas_rphy_free(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:scsi_is_sas_port": {
        "description": "Check if a struct device represents a SAS port.",
        "proto": "int scsi_is_sas_port(const struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kretprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY. Removes port reference to an rphy.",
        "proto" :"void (*sas_rphy_unlink)(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kprobe:sas_rphy_unlink": {
        "description": "Unlink SAS remote PHY. Removes port reference to an rphy.",
        "proto" :"void (*sas_rphy_unlink)(struct sas_rphy *rphy)",
        "pre": {
            "rphy": "!=null"
        }
    }
},
{
    "kretprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template @ft:SAS transport class function template",
        "proto" :"struct scsi_transport_template *(*sas_attach_transport)(struct sas_function_template *ft)",
        "pre": {
            "ft": "!=null"
        },
    }
},
{
    "kprobe:sas_attach_transport": {
        "description": "Instantiate SAS transport template @ft:SAS transport class function template",
        "proto" :"struct scsi_transport_template *(*sas_attach_transport)(struct sas_function_template *ft)",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kretprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "proto": "void (*sas_release_transport)(struct scsi_transport_template *t)",
        "pre": {
            "t": "!=null"
        }
    }
},
{
    "kprobe:sas_release_transport": {
        "description": "Release SAS transport template instance",
        "proto" :"void (*sas_release_transport)(struct scsi_transport_template *t)",
        "pre": {
            "t": "!=null"
        }
    }
},


{
    "kretprobe:scsi_remove_host": {
        "description": "Remove a scsi host",
        "proto" :"void (*scsi_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_remove_host": {
        "description": "Remove a scsi host",
        "proto" :"void (*scsi_remove_host)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:scsi_add_host_with_dma": {
        "description": "Add a scsi host with dma device. You rarely need to worry about this unless you're in a virtualised host environments, so use the simpler scsi_add_host() function instead.",
        "proto" :"int (*scsi_add_host_with_dma)(struct Scsi_Host *shost, struct device *dev, struct device *dma_dev)",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        },
        "post": {
            "return": "in [0, !=0]"
        }
    }
},
{
    "kprobe:scsi_add_host_with_dma": {
        "description": "Add a scsi host with dma device. You rarely need to worry about this unless you're in a virtualised host environments, so use the simpler scsi_add_host() function instead.",
        "proto" :"int (*scsi_add_host_with_dma)(struct Scsi_Host *shost, struct device *dev, struct device *dma_dev)",
        "pre": {
            "shost": "!=null",
            "dev": "!=null",
            "dma_dev": "!=null"
        },
        "post": {
            "return": "in [0, !=0]"
        }
    }
},
{
    "kretprobe:kfree": {
        "description": "Frees the memory space pointed to by *ptr*, which must have been returned by a previous call to kmalloc, kmalloc_array or other function that allocates dynamic memory.",
        "proto" :"void kfree(const void *ptr)",
        "pre": {
            "ptr": "!=null"
        },
    }
},
{
    "kprobe:kfree": {
        "description": "Frees the memory allocated for the shost_dev name to avoid leaks.",
        "proto" :"void kfree(const void *objp)",
        "pre": {
            "objp": "!=null",
        },
    }
},
{
    "kretprobe:scsi_host_lookup": {
        "description": "scsi_host_get() took. The put_device() below dropped the reference from class_find_device().",
        "proto" :"struct Scsi_Host *(*scsi_host_lookup)(unsigned short hostnum)",
        "pre": {
            "hostnum": ">=0"
        }
    }
},
{
    "kprobe:scsi_host_lookup": {
        "description": "scsi_host_get() took. The put_device() below dropped the reference from class_find_device().",
        "proto" :"struct Scsi_Host *(*scsi_host_lookup)(unsigned short hostnum)",
        "pre": {
            "hostnum": "is a valid unsigned short number"
        },
    }
},
{
    "kretprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "proto" :"int (*scsi_host_busy)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_host_busy": {
        "description": "Return the host busy counter",
        "proto": "int scsi_host_busy(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},

{
    "kprobe:wd33c93_host_reset": {
        "description": "Resets the host data and instance for a given SCSI command.",
        "proto" :"int wd33c93_host_reset(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null",
            "SCpnt->device": "!=null",
            "SCpnt->device->host": "!=null"
        },
        "post": {
            "hostdata->input_Q": "==null",
            "hostdata->selecting": "==null",
            "hostdata->connected": "==null",
            "hostdata->disconnected_Q": "==null",
            "hostdata->state": "==S_UNCONNECTED",
            "hostdata->dma": "==D_DMA_OFF",
            "hostdata->incoming_ptr": "==0",
            "hostdata->outgoing_len": "==0",
            "SCpnt->result": "==DID_RESET << 16"
        }
    }
},
{
    "kretprobe:wd33c93_init": {
        "description": "Initializes the WD33C93 SCSI host adapter.",
        "proto": "void wd33c93_init(struct Scsi_Host *instance, const wd33c93_regs regs, dma_setup_t setup, dma_stop_t stop, int clock_freq)",
        "pre": {
            "instance": "!=null",
            "regs": "!=null",
            "setup": "!=null",
            "stop": "!=null",
            "clock_freq": ">=0"
        }
    }
},
{
    "kprobe:wd33c93_init": {
        "description": "Initializes the WD33C93 SCSI host adapter.",
        "proto" :"wd33c93_init(struct Scsi_Host instance, const wd33c93_regs regs, dma_setup_t setup, dma_stop_t stop, int clock_freq)",
        "pre": {
            "instance": "!=null",
            "regs": "!=null",
            "setup": "!=null",
            "stop": "!=null",
            "clock_freq": "is integer",
        },
    }
},
{
    "kretprobe:wd33c93_abort": {
        "description": "If the command hasn't been issued yet, we simply remove it from the input_Q.",
        "proto" :"static void (*wd33c93_abort)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->device": "!=null",
            "cmd->device->host": "!=null",
            "cmd->device->host->irq": ">=0",
            "cmd->device->host->hostdata": "!=null",
            "cmd->device->host->hostdata->regs": "!=null",
            "cmd->device->host->hostdata->input_Q": "!=null"
        },
    }
},

{
    "kretprobe:wd33c93_queuecommand_lck": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use: - host_scribble is the pointer to the next cmd in the input queue - result is what you'd expect",
        "proto" :"wd33c93_queuecommand_lck(struct scsi_cmnd  cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->device": "!=null",
            "cmd->device->host": "!=null",
            "cmd->device->host->hostdata": "!=null",
            "cmd->device->id": "in [valid id range]",
            "cmd->cmnd[0]": "in [valid command range]"
        },
    }
},
{
    "kprobe:wd33c93_queuecommand_lck": {
        "description": "Set up a few fields in the scsi_cmnd structure for our own use: - host_scribble is the pointer to the next cmd in the input queue - result is what you'd expect",
        "proto" :"wd33c93_queuecommand_lck(struct scsi_cmnd  cmd)",
        "pre": {
            "cmd": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:wd33c93_execute": {
        "description": "wd33c93_intr itself, which means that a wd33c93 interrupt cannot occur while we are in here.",
        "proto" :"static void (*wd33c93_execute)(struct Scsi_Host *instance)",
        "pre": {
            "instance": "!=null"
        }
    }
},

{
    "kretprobe:wd33c93_show_info": {
        "description": "Provide a description for the function here",
        "proto" :"void wd33c93_show_info(struct seq_file *m, struct Scsi_Host *instance)",
        "pre": {
            "m": "Provide constraints for m here",
            "instance": "Provide constraints for instance here"
        }
    }
},
{
    "kprobe:wd33c93_show_info": {
        "description": "Show information about the wd33c93 SCSI controller.",
        "proto" :"void wd33c93_show_info(struct seq_file *m, struct Scsi_Host *instance)",
        "pre": {
            "m": "!=null",
            "instance": "!=null"
        },
    }
},

{
    "kprobe:wd33c93_write_info": {
        "description": "Accepts the following keywords (same format as command-line, but arguments are not optional): debug, disconnect, period, resync, proc, nodma, level2, burst, fast, nosync.",
        "proto" :"void wd33c93_write_info(struct Scsi_Host *instance, char *buf, int len)",
        "pre": {
            "instance": "!=null",
            "buf": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key. If @compatible, add to the tail of the list, do not space pad, and set devinfo->compatible. The scsi_static_device_list entries are added with @compatible 1 and @clfags NULL.",
        "proto" :"int scsi_dev_info_list_add_keyed(int compatible, char *vendor, char *model, char *strflags, blist_flags_t flags, enum scsi_devinfo_key key)",
        "pre": {
            "compatible": "in [0, 1]",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null || flags !=null",
            "flags": "!=null || strflags !=null",
            "key": "in [SCSI_DEVINFO_GLOBAL, ...]" // replace ... with other possible enum values
        },
    }
},
{
    "kprobe:scsi_dev_info_list_add_keyed": {
        "description": "Create and add one dev_info entry for @vendor, @model, @strflags or @flag in list specified by @key. If @compatible, add to the tail of the list, do not space pad, and set devinfo->compatible. The scsi_static_device_list entries are added with @compatible 1 and @clfags NULL. Returns: 0 OK, -error on failure.",
        "proto" :"int scsi_dev_info_list_add_keyed(int compatible, char *vendor, char *model, char *strflags, blist_flags_t flags, enum scsi_devinfo_key key)",
        "pre": {
            "compatible": "in [0, 1]",
            "vendor": "!=null",
            "model": "!=null",
            "strflags": "!=null || flags !=null",
            "flags": "is blist_flags_t",
            "key": "is enum scsi_devinfo_key",
        },
    }
},
{
    "kretprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key. Returns: 0 OK, -error on failure.",
        "proto" :"int (*scsi_dev_info_list_del_keyed)(char *vendor, char *model, enum scsi_devinfo_key key)",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL, SCSI_DEVINFO_LOCAL, SCSI_DEVINFO_LIST]"
        },
    }
},
{
    "kprobe:scsi_dev_info_list_del_keyed": {
        "description": "Remove and destroy one dev_info entry for @vendor, @model in list specified by @key.",
        "proto" :"int (*scsi_dev_info_list_del_keyed)(char *vendor, char *model, enum scsi_devinfo_key key)",
        "pre": {
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL, SCSI_DEVINFO_LOCAL, SCSI_DEVINFO_SPECIFIC]"
        },
    }
},
{
    "kretprobe:scsi_get_device_flags_keyed": {
        "description": "Search the scsi_dev_info_list specified by @key for an entry matching @vendor and @model, if found, return the matching flags value, else return the host or global default settings. Called during scan time.",
        "proto" :"blist_flags_t (*scsi_get_device_flags_keyed)(struct scsi_device *sdev, const unsigned char *vendor, const unsigned char *model, enum scsi_devinfo_key key)",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        }
    }
},
{
    "kprobe:scsi_get_device_flags_keyed": {
        "description": "Search the scsi_dev_info_list specified by @key for an entry matching @vendor and @model, if found, return the matching flags value, else return the host or global default settings. Called during scan time.",
        "proto" :"blist_flags_t (*scsi_get_device_flags_keyed)(struct scsi_device *sdev, const unsigned char *vendor, const unsigned char *model, enum scsi_devinfo_key key)",
        "pre": {
            "sdev": "!=null",
            "vendor": "!=null",
            "model": "!=null",
            "key": "in [SCSI_DEVINFO_GLOBAL]"
        },
    }
},
{
    "kretprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list. Returns zero on success, -EEXIST if the key is already registered to a list, or other error on failure.",
        "proto" :"int scsi_dev_info_add_list(enum scsi_devinfo_key key, const char *name)",
        "pre": {
            "key": "!=null",
            "name": "!=null"
        },
        "post": {
            "return": "in [0, -EEXIST, other error]"
        }
    }
},
{
    "kprobe:scsi_dev_info_add_list": {
        "description": "Add a new devinfo list. Returns zero on success, -EEXIST if the key is already registered to a list, or other error on failure.",
        "proto" :"int scsi_dev_info_add_list(enum scsi_devinfo_key key, const char *name)",
        "pre": {
            "key": "in [valid enum scsi_devinfo_key]",
            "name": "!=null",
        },
    }
},
{
    "kretprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result. Returns the scsi_cmnd result field if a command was executed, or a negative Linux error code if we didn't get that far.",
        "proto" :"int (*scsi_execute_cmd)(struct scsi_device *sdev, const unsigned char *cmd, blk_opf_t opf, void *buffer, unsigned int bufflen, int timeout, int retries, const struct scsi_exec_args *args)",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_ZEROES, REQ_OP_SCSI_IN, REQ_OP_SCSI_OUT]",
            "buffer": "!=null",
            "bufflen": ">=0",
            "timeout": ">=0",
            "retries": ">=0",
            "args": "!=null"
        }
    }
},
{
    "kprobe:scsi_execute_cmd": {
        "description": "Insert request and wait for the result. Returns the scsi_cmnd result field if a command was executed, or a negative Linux error code if we didn't get that far.",
        "proto" :"int (*scsi_execute_cmd)(struct scsi_device *sdev, const unsigned char *cmd, blk_opf_t opf, void *buffer, unsigned int bufflen, int timeout, int retries, const struct scsi_exec_args *args)",
        "pre": {
            "sdev": "!=null",
            "cmd": "!=null",
            "opf": "in [REQ_OP_READ, REQ_OP_WRITE, REQ_OP_FLUSH, REQ_OP_DISCARD, REQ_OP_SECURE_ERASE, REQ_OP_ZONE_RESET, REQ_OP_WRITE_SAME, REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE, REQ_OP_ZONE_FINISH, REQ_OP_ZONE_APPEND, REQ_OP_WRITE_ZEROES, REQ_OP_ZONE_RESET_ALL]",
            "buffer": "!=null",
            "bufflen": ">=0",
            "timeout": ">=0",
            "retries": ">=0",
            "args": "!=null || ==null"
        }
    }
},
{
    "kretprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists. Initializes @cmd->sdb and also @cmd->prot_sdb if data integrity is enabled for @cmd.",
        "proto" :"blk_status_t (*scsi_alloc_sgtables)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kprobe:scsi_alloc_sgtables": {
        "description": "Allocate and initialize data and integrity scatterlists. Initializes @cmd->sdb and also @cmd->prot_sdb if data integrity is enabled for @cmd.",
        "proto" :"blk_status_t (*scsi_alloc_sgtables)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [BLK_STS_OK, BLK_STS_RESOURCE, BLK_STS_IOERR]"
        }
    }
},
{
    "kretprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "proto" :"static unsigned int (*scsi_mq_inline_sgl_size)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_mq_inline_sgl_size": {
        "description": "Size in bytes of the sg-list stored in the scsi-mq command-private data.",
        "proto" :"static unsigned int (*scsi_mq_inline_sgl_size)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null",
        },
    }
},
{
    "kretprobe:scsi_block_requests": {
        "description": "scsi_unblock_requests()",
        "proto" :"void scsi_block_requests(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:scsi_block_requests": {
        "description": "Description of the function scsi_block_requests() goes here.",
        "proto" :"void scsi_block_requests(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null",
        },
    }
},
{
    "kretprobe:intscsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary. Returns zero if successful, or a negative error number on failure.",
        "proto" :"int (*scsi_mode_sense)(struct scsi_device *sdev, int dbd, int modepage, int subpage, unsigned char *buffer, int len, int timeout, int retries, struct scsi_mode_data *data, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sdev": "!=null",
            "dbd": "is integer",
            "modepage": "is integer",
            "subpage": "is integer",
            "buffer": "!=null",
            "len": "is integer",
            "timeout": "is integer",
            "retries": "is integer",
            "data": "!=null",
            "sshdr": "!=null || ==null"
        },
    }
},
{
    "kprobe:scsi_mode_sense": {
        "description": "Issue a mode sense, falling back from 10 to six bytes if necessary. Returns zero if successful, or a negative error number on failure.",
        "proto" :"int (*scsi_mode_sense)(struct scsi_device *sdev, int dbd, int modepage, int subpage, unsigned char *buffer, int len, int timeout, int retries, struct scsi_mode_data *data, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sdev": "!=null",
            "dbd": "is integer",
            "modepage": "is integer",
            "subpage": "is integer",
            "buffer": "!=null",
            "len": "is integer",
            "timeout": "is integer",
            "retries": "is integer",
            "data": "!=null",
            "sshdr": "!=null or ==null"
        },
    }
},
{
    "kretprobe:intscsi_test_unit_ready": {
        "description": "Test if unit is ready. Returns zero if unsuccessful or an error if TUR failed. For removable media, UNIT_ATTENTION sets ->changed flag.",
        "proto" :"int (*scsi_test_unit_ready)(struct scsi_device *sdev, int timeout, int retries, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null"
        },
    }
},
{
    "kprobe:scsi_test_unit_ready": {
        "description": "Test if unit is ready. Returns zero if unsuccessful or an error if TUR failed. For removable media, UNIT_ATTENTION sets ->changed flag.",
        "proto" :"int (*scsi_test_unit_ready)(struct scsi_device *sdev, int timeout, int retries, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sdev": "!=null",
            "timeout": ">=0",
            "retries": ">=0",
            "sshdr": "!=null",
        },
    }
},
{
    "kretprobe:scsi_device_set_state": {
        "description": "Take the given device through the device state model. Returns zero if successful or an error if the requested transition is illegal.",
        "proto" :"int (*scsi_device_set_state)(struct scsi_device *sdev, enum scsi_device_state state)",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_DEVICE_RUNNING, SCSI_DEVICE_UNKNOWN, SCSI_DEVICE_NOT_THERE, SCSI_DEVICE_DISCONNECTED, SCSI_DEVICE_OFFLINE, SCSI_DEVICE_BLOCKED, SCSI_DEVICE_CREATED, SCSI_DEVICE_CANCEL]"
        }
    }
},
{
    "kprobe:intscsi_device_set_state": {
        "description": "Take the given device through the device state model. Change the state of the scsi device. Returns zero if successful or an error if the requested transition is illegal.",
        "proto" :"int (*scsi_device_set_state)(struct scsi_device *sdev, enum scsi_device_state state)",
        "pre": {
            "sdev": "!=null",
            "state": "in [SCSI_DEVICE_RUNNING, SCSI_DEVICE_UNKNOWN, SCSI_DEVICE_QUIESCENT, SCSI_DEVICE_OFFLINE, SCSI_DEVICE_BLOCKED, SCSI_DEVICE_DEL, SCSI_DEVICE_CREATED]"
        }
    }
},
{
    "kretprobe:scsi_device_quiesce": {
        "description": "Block all commands except power management. This works by trying to transition to the SDEV_QUIESCE state (which must be a legal transition). When the device is in this state, only power management requests will be accepted, all others will be deferred. Must be called with user context, may sleep. Returns zero if unsuccessful or an error if not.",
        "proto" :"int (*scsi_device_quiesce)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_quiesce": {
        "description": "Block all commands except power management. This works by trying to transition to the SDEV_QUIESCE state (which must be a legal transition). When the device is in this state, only power management requests will be accepted, all others will be deferred. Must be called with user context, may sleep. Returns zero if unsuccessful or an error if not.",
        "proto" :"int (*scsi_device_quiesce)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device. Moves the device from quiesced back to running and restarts the queues. Must be called with user context, may sleep.",
        "proto" :"void (*scsi_device_resume)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:scsi_device_resume": {
        "description": "Restart user issued commands to a quiesced device. Moves the device from quiesced back to running and restarts the queues. Must be called with user context, may sleep.",
        "proto" :"void (*scsi_device_resume)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element. Returns virtual address of the start of the mapped page.",
        "proto" :"void *(*scsi_kmap_atomic_sg)(struct scatterlist *sgl, int sg_count, size_t *offset, size_t *len)",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null"
        },
    }
},
{
    "kprobe:scsi_kmap_atomic_sg": {
        "description": "Find and atomically map an sg-element. Returns virtual address of the start of the mapped page.",
        "proto" :"void *(*scsi_kmap_atomic_sg)(struct scatterlist *sgl, int sg_count, size_t *offset, size_t *len)",
        "pre": {
            "sgl": "!=null",
            "sg_count": ">=0",
            "offset": "!=null",
            "len": "!=null && *len > 0",
        },
    }
},
{
    "kretprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg.",
        "proto" :"static void (*scsi_kunmap_atomic_sg)(void *virt)",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kprobe:scsi_kunmap_atomic_sg": {
        "description": "Atomically unmap a virtual address, previously mapped with scsi_kmap_atomic_sg",
        "proto" :"void (*scsi_kunmap_atomic_sg)(void *virt)",
        "pre": {
            "virt": "!=null"
        }
    }
},
{
    "kretprobe:scsi_vpd_lun_id": {
        "description": "Copies a unique device identification into @id based on the information in the VPD page 0x83 of the device. The string will be formatted as a SCSI name string. Returns the length of the identification or error on failure. If the identifier is longer than the supplied buffer the actual identifier length is returned and the buffer is not zero-padded.",
        "proto" :"int scsi_vpd_lun_id(struct scsi_device *sdev, char *id, size_t id_len)",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">0"
        }
    }
},
{
    "kprobe:scsi_vpd_lun_id": {
        "description": "Copies a unique device identification into @id based on the information in the VPD page 0x83 of the device. The string will be formatted as a SCSI name string. Returns the length of the identification or error on failure. If the identifier is longer than the supplied buffer the actual identifier length is returned and the buffer is not zero-padded.",
        "proto" :"int scsi_vpd_lun_id(struct scsi_device *sdev, char *id, size_t id_len)",
        "pre": {
            "sdev": "!=null",
            "id": "!=null",
            "id_len": ">0"
        },
    }
},
{
    "kretprobe:scsi_vpd_tpg_id": {
        "description": "Returns the Target Port Group identifier from the information from VPD page 0x83 of the device. Returns the identifier or error on failure.",
        "proto" :"int (*scsi_vpd_tpg_id)(struct scsi_device *sdev, int *rel_id)",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kprobe:scsi_vpd_tpg_id": {
        "description": "Returns the Target Port Group identifier from the information from VPD page 0x83 of the device. Returns the identifier or error on failure.",
        "proto" :"int scsi_vpd_tpg_id(struct scsi_device *sdev, int *rel_id)",
        "pre": {
            "sdev": "!=null",
            "rel_id": "!=null"
        }
    }
},
{
    "kretprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "proto" :"const char *(*scsi_device_type)(unsigned type)",
        "pre": {
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]"
        },
        "post": {
            "return": "in ['Direct-Access    ','Sequential-Access','Printer          ','Processor        ','WORM             ','CD-ROM           ','Scanner          ','Optical Device   ','Medium Changer   ','Communications   ','ASC IT8          ','ASC IT8          ','RAID             ','Enclosure        ','Direct-Access-RBC','Optical card     ','Bridge controller','Object storage   ','AutomationDrive ','Security Manager ','Direct-Access-ZBC']"
        }
    }
},
{
    "kprobe:scsi_device_type": {
        "description": "Return 17-char string indicating device type.",
        "proto": "const char *(*scsi_device_type)(unsigned type)",
        "pre": {
            "type": "in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]"
        }
    }
},
{
    "kretprobe:scsilun_to_int": {
        "description": "Convert @scsilun from a struct scsi_lun to a four-byte host byte-ordered integer, and return the result. The caller must check for truncation before using this function.",
        "proto" :"u64 (*scsilun_to_int)(struct scsi_lun *scsilun)",
        "pre": {
            "scsilun": "!=null"
        },
        "post": {
            "return": "is a four-byte host byte-ordered integer"
        }
    }
},
{
    "kprobe:scsilun_to_int": {
        "description": "Convert @scsilun from a struct scsi_lun to a four-byte host byte-ordered integer, and return the result. The caller must check for truncation before using this function.",
        "proto" :"u64 (*scsilun_to_int)(struct scsi_lun *scsilun)",
        "pre": {
            "scsilun": "!=null"
        }
    }
},
{
    "kretprobe:int_to_scsilun": {
        "description": "Reverts an int into a scsi_lun. Reverts the functionality of the scsilun_to_int, which packed an 8-byte lun value into an int. This routine unpacks the int back into the lun value.",
        "proto" :"void (*int_to_scsilun)(u64 lun, struct scsi_lun *scsilun)",
        "pre": {
            "lun": "is u64",
            "scsilun": "!=null"
        }
    }
},
{
    "kprobe:int_to_scsilun": {
        "description": "Reverts the functionality of the scsilun_to_int, which packed an 8-byte lun value into an int. This routine unpacks the int back into the lun value.",
        "proto" :"void int_to_scsilun(u64 lun, struct scsi_lun *scsilun)",
        "pre": {
            "lun": "is u64",
            "scsilun": "!=null",
        },
    }
},
{
    "kretprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format. The 'main elements' from sense data are: response_code, sense_key, asc, ascq and additional_length (only for descriptor format). Typically this function can be called after a device has responded to a SCSI command with the CHECK_CONDITION status.",
        "proto" :"bool (*scsi_normalize_sense)(const u8 *sense_buffer, int sb_len, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_normalize_sense": {
        "description": "Normalize main elements from either fixed or descriptor sense data format into a common format. Typically this function can be called after a device has responded to a SCSI command with the CHECK_CONDITION status.",
        "proto" :"bool (*scsi_normalize_sense)(const u8 *sense_buffer, int sb_len, struct scsi_sense_hdr *sshdr)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "sshdr": "!=null"
        },
    }
},
{
    "kretprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format. Only valid when sense data is in descriptor format. Returns pointer to start of (first) descriptor if found else NULL.",
        "proto": "const u8 * (*scsi_sense_desc_find)(const u8 * sense_buffer, int sb_len, int desc_type)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": ">=0"
        }
    }
},
{
    "kprobe:scsi_sense_desc_find": {
        "description": "Search for a given descriptor type in descriptor sense data format. Only valid when sense data is in descriptor format. Returns pointer to start of (first) descriptor if found else NULL.",
        "proto" :"const u8 * (*scsi_sense_desc_find)(const u8 * sense_buffer, int sb_len, int desc_type)",
        "pre": {
            "sense_buffer": "!=null",
            "sb_len": ">=0",
            "desc_type": "is integer"
        }
    }
},
{
    "kretprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer. @desc:Sense format (non-zero == descriptor format, 0 == fixed format) @buf:Where to build sense data @key:Sense key @asc:Additional sense code @ascq:Additional sense code qualifier",
        "proto" :"void (*scsi_build_sense_buffer)(int desc, u8 *buf, u8 key, u8 asc, u8 ascq)",
        "pre": {
            "desc": "in [0, 1]",
            "buf": "!=null",
            "key": "in [0, 255]",
            "asc": "in [0, 255]",
            "ascq": "in [0, 255]"
        }
    }
},
{
    "kprobe:scsi_build_sense_buffer": {
        "description": "Build sense data in a buffer. @desc:Sense format (non-zero == descriptor format, 0 == fixed format) @buf:Where to build sense data @key:Sense key @asc:Additional sense code @ascq:Additional sense code qualifier",
        "proto" :"void (*scsi_build_sense_buffer)(int desc, u8 *buf, u8 key, u8 asc, u8 ascq)",
        "pre": {
            "desc": "in [0, 1]",
            "buf": "!=null",
            "key": "is u8",
            "asc": "is u8",
            "ascq": "is u8"
        }
    }
},
{
    "kretprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer. @buf: Where to build sense data. @buf_len: buffer length. @info: 64-bit information value to be set. Return value: 0 on success or -EINVAL for invalid sense buffer length.",
        "proto": "int (*scsi_set_sense_information)(u8 *buf, int buf_len, u64 info)",
        "pre": {
            "buf": "!=null",
            "buf_len": ">0",
            "info": "is u64"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_information": {
        "description": "Set the information field in a formatted sense data buffer. Returns 0 on success or -EINVAL for invalid sense buffer length.",
        "proto" :"int (*scsi_set_sense_information)(u8 *buf, int buf_len, u64 info)",
        "pre": {
            "buf": "!=null",
            "buf_len": ">0",
            "info": "is u64"
        },
    }
},
{
    "kretprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer. @buf: Where to build sense data. @buf_len: buffer length. @fp: field pointer to be set. @bp: bit pointer to be set. @cd: command data bit. Return value: 0 on success or -EINVAL for invalid sense buffer length.",
        "proto": "int (*scsi_set_sense_field_pointer)(u8 *buf, int buf_len, u16 fp, u8 bp, bool cd)",
        "pre": {
            "buf": "!=null",
            "buf_len": ">0",
            "fp": "is u16",
            "bp": "is u8",
            "cd": "is bool"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:scsi_set_sense_field_pointer": {
        "description": "Set the field pointer sense key specific information in a formatted sense data buffer.",
        "proto": "int (*scsi_set_sense_field_pointer)(u8 *buf, int buf_len, u16 fp, u8 bp, bool cd)",
        "pre": {
            "buf": "!=null",
            "buf_len": ">0",
            "fp": "is u16",
            "bp": "is u8",
            "cd": "is bool"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kretprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "proto" :"int qlogicfas408_get_chip_type(int qbase, int int_type)",
        "pre": {
            "qbase": ">=0",
            "int_type": "in [INT_TYPE_1, INT_TYPE_2, INT_TYPE_3, ...]" // replace with actual int_type values
        },
    }
},
{
    "kprobe:qlogicfas408_get_chip_type": {
        "description": "Get type of chip",
        "proto" :"int qlogicfas408_get_chip_type(int qbase, int int_type)",
        "pre": {
            "qbase": "is an integer",
            "int_type": "is an integer"
        }
    }
},
{
    "kretprobe:qlogicfas408_queuecommand_lck": {
        "description": "Queue a command to the qlogicfas408 device and wait for the last command's interrupt to finish.",
        "proto" :"static long (*qlogicfas408_queuecommand_lck)(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        },
        "post": {
            "return": "in [0, DID_BAD_TARGET]"
        }
    }
},

{
    "kretprobe:qlogicfas408_abort": {
        "description": "Reset SCSI bus. This function is invoked with cmd = NULL directly by the PCMCIA qlogic_stub code. This wants fixing.",
        "proto" :"int qlogicfas408_abort(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "can be null"
        },
    }
},
{
    "kprobe:qlogicfas408_host_reset": {
        "description": "Your description here",
        "proto" :"int qlogicfas408_host_reset(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "Your condition here",
        },
    }
},
{
    "kretprobe:qlogicfas408_host_reset": {
        "description": "Reset the host and return SUCCESS.",
        "proto" :"static long (*qlogicfas408_host_reset)(struct scsi_cmnd cmd)",
        "pre": {
            "cmd": "!=null"
        },
    }
},
{
    "kprobe:qlogicfas408_info": {
        "description": "Returns information string for the given Scsi_Host",
        "proto" :"const char *(*qlogicfas408_info)(struct Scsi_Host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "proto" :"static int (*qlogicfas408_biosparam)(struct scsi_device *disk, struct block_device *dev, sector_t capacity, int ip[])",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": ">=0",
            "ip": "!=null"
        },
        "post": {
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "== (unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2]": "<=1024"
        }
    }
},
{
    "kprobe:qlogicfas408_biosparam": {
        "description": "This should mimic the DOS Qlogic driver's behavior exactly",
        "proto" :"static long (*qlogicfas408_biosparam)(struct scsi_device *disk, struct block_device *dev, sector_t capacity, int ip[])",
        "pre": {
            "disk": "!=null",
            "dev": "!=null",
            "capacity": ">=0",
            "ip": "!=null && length >= 3",
            "ip[0]": "==0x40",
            "ip[1]": "==0x20",
            "ip[2]": "== (unsigned long) capacity / (ip[0] * ip[1])",
            "ip[2] > 1024": "==false"
        },
    }
},
{
    "kretprobe:qlogicfas408_queuecommand_lck": {
        "description": "Please provide a description for this function.",
        "proto" :"static int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:qlogicfas408_queuecommand_lck": {
        "description": "Description of the function goes here",
        "proto" :"static int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd)",
        "pre": {
            "cmd": "Condition for cmd goes here",
        },
    }
},
{
    "kretprobe:qlogicfas408_setup": {
        "description": "Perform initialization tasks",
        "proto" :"void qlogicfas408_setup(int qbase, int id, int int_type)",
        "pre": {
            "qbase": "is an integer",
            "id": "is an integer",
            "int_type": "is an integer"
        }
    }
},
{
    "kprobe:qlogicfas408_get_chip_type": {
        "description": "Perform initialization tasks",
        "proto" :"int qlogicfas408_get_chip_type(int qbase, int int_type)",
        "pre": {
            "qbase": ">=0",
            "int_type": "in [0, 1]"
        },
    }
},
{
    "kretprobe:qlogicfas408_setup": {
        "description": "Set for PIO pseudo DMA",
        "proto" :"static void (*qlogicfas408_setup)(int qbase, int id, int int_type)",
        "pre": {
            "qbase": "is an integer",
            "id": "is an integer",
            "int_type": "is an integer"
        }
    }
},


{
    "kprobe:qlogicfas408_disable_ints": {
        "description": "Your description here",
        "proto" :"void qlogicfas408_disable_ints(struct qlogicfas408_priv *priv)",
        "pre": {
            "priv": "Your condition here"
        }
    }
},
{
    "kretprobe:qlogicfas408_disable_ints": {
        "description": "Description of the function",
        "proto" :"void qlogicfas408_disable_ints(struct qlogicfas408_priv  priv)",
        "pre": {
            "priv": "!=null",
        },
    }
},
{
    "kprobe:qlogicfas408_disable_ints": {
        "description": "Disables interrupts for the qlogicfas408 device.",
        "proto" :"void qlogicfas408_disable_ints(struct qlogicfas408_priv  priv)",
        "pre": {
            "priv": "!=null"
        },
    }
},
{
    "kretprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device. Returns partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.",
        "proto" :"unsigned char *(*scsi_bios_ptable)(struct block_device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:scsi_bios_ptable": {
        "description": "Read PC partition table out of first sector of device. Reads the first sector from the device and returns %0x42 bytes starting at offset %0x1be. Returns: partition table in kmalloc(GFP_KERNEL) memory, or NULL on error.",
        "proto" :"unsigned char *(*scsi_bios_ptable)(struct block_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:scsi_partsize": {
        "description": "Parse cylindersheadssectors from PC partition table. Determine the BIOS mappinggeometry used to create the partition table, storing the results in @geom.",
        "proto" :"bool (*scsi_partsize)(struct block_device *bdev, sector_t capacity, int geom[3])",
        "pre": {
            "bdev": "!=null",
            "capacity": ">=0",
            "geom": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:scsi_partsize": {
        "description": "Parse cylindersheadssectors from PC partition table. Determine the BIOS mappinggeometry used to create the partition table, storing the results in @geom.",
        "proto" :"bool (*scsi_partsize)(struct block_device *bdev, sector_t capacity, int geom[3])",
        "pre": {
            "bdev": "!=null",
            "capacity": ">=0",
            "geom": "!=null"
        },
    }
},
{
    "kretprobe:get_unaligned_le32": {
        "description": "Calculate the logical end of a sector.",
        "proto" :"static long (*get_unaligned_le32)(void *start_sect, void *nr_sects)",
        "pre": {
            "start_sect": "!=null",
            "nr_sects": "!=null"
        },
    }
},

{
    "kretprobe:scsi_remove_device": {
        "description": "Handles concurrent removal calls by serializing these and by ignoring the second and later removal attempts. The first call of that function changes the device state into SDEV_DEL.",
        "proto" :"static void (*scsi_remove_device)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        },
    }
},
{
    "kprobe:device_remove_file": {
        "description": "Handles concurrent removal calls by serializing these and by ignoring the second and later removal attempts.",
        "proto" :"static void (*device_remove_file)(struct device *dev, struct device_attribute *attr)",
        "pre": {
            "dev": "!=null",
            "attr": "!=null"
        }
    }
},
{
    "kretprobe:scsi_remove_target": {
        "description": "Remove a target and all its devices.",
        "proto" :"static void (*scsi_remove_target)(struct scsi_target *starget)",
        "pre": {
            "starget": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kprobe:scsi_remove_target": {
        "description": "Remove a target and all its devices. Note: This is slightly racy. It is possible that if the user requests the addition of another device then the target won't be removed.",
        "proto" :"scsi_remove_target(struct scsi_target  starget)",
        "pre": {
            "starget": "!=null",
            "shost": "!=null",
            "flags": "!=null",
            "sdev": "!=null",
            "sdev->channel": "!=null",
            "sdev->id": "!=null",
            "sdev->sdev_state": "in [SDEV_DEL, SDEV_CANCEL]",
            "sdev->sdev_gendev": "!=null",
            "shost->host_lock": "!=null"
        },
    }
},
{
    "kretprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphical chars from an INQUIRY result string. The SCSI spec says that INQUIRY vendor, product, and revision strings must consist entirely of graphic ASCII characters, padded on the right with spaces. Since not all devices obey this rule, we will replace non-graphic or non-ASCII characters with spaces. Exception: a NUL character is interpreted as a string terminator, so all the following characters are set to spaces.",
        "proto" :"void (*scsi_sanitize_inquiry_string)(unsigned char *s, int len)",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:scsi_sanitize_inquiry_string": {
        "description": "Remove non-graphic chars from an INQUIRY result string. The SCSI spec says that INQUIRY vendor, product, and revision strings must consist entirely of graphic ASCII characters, padded on the right with spaces. Since not all devices obey this rule, we will replace non-graphic or non-ASCII characters with spaces. Exception: a NUL character is interpreted as a string terminator, so all the following characters are set to spaces.",
        "proto" :"void (*scsi_sanitize_inquiry_string)(unsigned char *s, int len)",
        "pre": {
            "s": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:__scsi_add_device": {
        "description": "Allocates a target and probes and adds a lun.",
        "proto" :"static long (*__scsi_add_device)(struct Scsi_Host *shost, uint channel, uint id, u64 lun, void *hostdata)",
        "pre": {
            "shost": "!=null",
            "channel": "in [valid range]",
            "id": "in [valid range]",
            "lun": "in [valid range]",
            "hostdata": "!=null or in [valid range]",
        },
    }
},

{
    "kretprobe:scsi_add_device": {
        "description": "Allocates a scsi_target and probes and adds a lun. The target will be destroyed unless scsi_probe_and_add_lun made an underlying device visible.",
        "proto" :"int scsi_add_device(struct Scsi_Host *shost, uint channel, uint id, u64 lun, void *hostdata)",
        "pre": {
            "shost": "!=null",
            "channel": "is a valid channel number",
            "id": "is a valid id",
            "lun": "is a valid lun",
            "hostdata": "can be null or valid pointer"
        },
        "post": {
            "return": "in [-ENODEV, -ENOMEM, 0]"
        }
    }
},
{
    "kprobe:scsi_add_device": {
        "description": "Paired with scsi_alloc_target(). Target will be destroyed unless scsi_probe_and_add_lun made an underlying device visible.",
        "proto" :"int scsi_add_device(struct Scsi_Host *shost, uint channel, uint id, u64 lun, void *hostdata)",
        "pre": {
            "shost": "!=null",
            "channel": "is a valid channel number",
            "id": "is a valid id",
            "lun": "is a valid lun",
            "hostdata": "can be null or valid pointer"
        },
    }
},
{
    "kretprobe:scsi_scan_target": {
        "description": "Scan the SCSI target",
        "proto" :"static void (*scsi_scan_target)(struct device *parent, unsigned int channel, unsigned int id, u64 lun, enum scsi_scan_mode rescan)",
        "pre": {
            "parent": "!=null",
            "channel": "is a valid channel number",
            "id": "is a valid id",
            "lun": "is a valid lun",
            "rescan": "in [SCAN_WILD_CARD, SCAN_NORMAL]"
        },
    }
},
{
    "kprobe:scsi_scan_target": {
        "description": "Scan the SCSI target. Don't scan the host adapter if 'shost->this_id' equals 'id'.",
        "proto" :"static void (*scsi_scan_target)(struct device *parent, unsigned int channel, unsigned int id, u64 lun, enum scsi_scan_mode rescan)",
        "pre": {
            "parent": "!=null",
            "channel": "is a valid channel number",
            "id": "is a valid id",
            "lun": "is a valid lun",
            "rescan": "in [SCAN_WILD_CARD, SCAN_NORMAL, SCAN_QUIET, SCAN_ASYNC]"
        }
    }
},
{
    "kretprobe:scsi_scan_host_selected": {
        "description": "Description of the function goes here",
        "proto" :"static long (*scsi_scan_host_selected)(struct Scsi_Host  shost, unsigned int channel, unsigned int id, u64 lun, enum scsi_scan_mode rescan)",
        "pre": {
            "shost": "!=null",
            "channel": "in [0, shost->max_channel]",
            "id": "in [0, shost->max_id]",
            "lun": "in [0, shost->max_lun]",
            "rescan": "in [SCAN_MODE_1, SCAN_MODE_2, SCAN_MODE_3]"
        },
    }
},

{
    "kretprobe:NCR_700_queuecommand": {
        "description": "Your description here",
        "proto" :"Your prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            ...
        },
    },
    "kretprobe:NCR_700_abort": {
        "description": "Your description here",
        "proto" :"Your prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            ...
        },
    },
    ...
},

{
    "kretprobe:NCR_700_data_residual": {
        "description": "Return residual data count of what's in the chip. It's almost a direct transcription of the algorithm described in the 53c710 guide, except that the DBC and DFIFO registers are only 6 bits wide on a 53c700.",
        "proto": "static inline int NCR_700_data_residual (struct Scsi_Host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:NCR_700_data_residual": {
        "description": "Return residual data count of what's in the chip. It's almost a direct transcription of the algorithm described in the 53c710 guide, except that the DBC and DFIFO registers are only 6 bits wide on a 53c700.",
        "proto": "static inline int (*NCR_700_data_residual)(struct Scsi_Host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:spin_lock_irqsave": {
        "description": "Use the host lock to serialise access to the 53c700 hardware.",
        "proto" :"void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)",
        "pre": {
            "lock": "!=null",
            "flags": "is an unsigned long"
        }
    },
    "kretprobe:NCR_700_readb": {
        "description": "Read a byte from the specified register of the NCR 700 SCSI controller.",
        "proto" :"__u8 NCR_700_readb(struct Scsi_Host *host, int reg)",
        "pre": {
            "host": "!=null",
            "reg": "is an integer"
        }
    }
},
{
    "kprobe:NCR_700_intr": {
        "description": "Description of the function",
        "proto" :"int (*NCR_700_intr)(int irq, void *dev_id)",
        "pre": {
            "irq": "constraints",
            "dev_id": "constraints",
        },
    }
},
{
    "kretprobe:fas216_init_chip": {
        "description": "Initialise FAS216 state after reset",
        "proto" :"static void fas216_init_chip(FAS216_Info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:fas216_init_chip": {
        "description": "Initialise FAS216 state after reset",
        "proto" :"static void fas216_init_chip(FAS216_Info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic. @host: a driver-specific filled-out structure @dev: parent device. Initialise FASNCRAMD SCSI ic. Returns: 0 on success",
        "proto" :"int fas216_add(struct Scsi_Host *host, struct device *dev)",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:fas216_add": {
        "description": "Initialise FASNCRAMD SCSI ic. Returns: 0 on success",
        "proto" :"int fas216_add(struct Scsi_Host *host, struct device *dev)",
        "pre": {
            "host": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process. Returns: 0 on success, else error. Notes: io_request_lock is held, interrupts are disabled.",
        "proto" :"static int fas216_queue_command_internal(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))",
        "pre": {
            "SCpnt": "!=null",
            "done": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:fas216_queue_command_internal": {
        "description": "Queue a command for the adapter to process. Returns: 0 on success, else error. Notes: io_request_lock is held, interrupts are disabled.",
        "proto" :"static int fas216_queue_command_internal(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))",
        "pre": {
            "SCpnt": "!=null",
            "done": "!=null"
        }
    }
},
{
    "kretprobe:fas216_internal_done": {
        "description": "Trigger restart of a waiting thread in fas216_command",
        "proto" :"static void fas216_internal_done(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:fas216_internal_done": {
        "description": "Trigger restart of a waiting thread in fas216_command",
        "proto" :"static void fas216_internal_done(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null",
        },
    }
},
{
    "kretprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "proto" :"irqreturn_t (*fas216_intr)(FAS216_Info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kprobe:fas216_intr": {
        "description": "Handle interrupts from the interface to progress a command",
        "proto" :"irqreturn_t (*fas216_intr)(FAS216_Info *info)",
        "pre": {
            "info": "!=null"
        }
    }
},
{
    "kretprobe:fas216_release": {
        "description": "Release all resources and put everything to bed for FASNCRAMD SCSI ic.",
        "proto": "void (*fas216_release)(struct Scsi_Host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:fas216_release": {
        "description": "Release all resources for FASNCRAMD SCSI ic. A driver-specific filled-out structure. Release all resources and put everything to bed for FASNCRAMD SCSI ic.",
        "proto" :"void (*fas216_release)(struct Scsi_Host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_abort": {
        "description": "Abort this command. Returns: FAILED if unable to abort. Notes: io_request_lock is taken, and irqs are disabled.",
        "proto" :"int fas216_eh_abort(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:fas216_eh_abort": {
        "description": "Abort this command. Returns: FAILED if unable to abort. Notes: io_request_lock is taken, and irqs are disabled",
        "proto" :"int fas216_eh_abort(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command. Returns: FAILED if unable to reset. Notes: We won't be re-entered, so we'll only have one device reset on the go at one time.",
        "proto" :"int fas216_eh_device_reset(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
    }
},
{
    "kprobe:fas216_eh_device_reset": {
        "description": "Reset the device associated with this command. Returns: FAILED if unable to reset. Notes: We won't be re-entered, so we'll only have one device reset on the go at one time.",
        "proto" :"int (*fas216_eh_device_reset)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command. Further commands are blocked. Returns: FAILED if unable to reset.",
        "proto" :"int fas216_eh_bus_reset(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [FAILED, SUCCESS]"
        }
    }
},
{
    "kprobe:fas216_eh_bus_reset": {
        "description": "Reset the bus associated with the command. Further commands are blocked. Returns: FAILED if unable to reset.",
        "proto" :"int (*fas216_eh_bus_reset)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command. Returns: FAILED if unable to reset. Notes: io_request_lock is taken, and irqs are disabled",
        "proto" :"int fas216_eh_host_reset(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
    }
},
{
    "kprobe:fas216_eh_host_reset": {
        "description": "Reset the host associated with this command. Returns: FAILED if unable to reset. Notes: io_request_lock is taken, and irqs are disabled",
        "proto" :"int fas216_eh_host_reset(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_initialise": {
        "description": "Initialise a message queue",
        "proto" :"void (*msgqueue_initialise)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_initialise": {
        "description": "Initialise a message queue",
        "proto" :"void (*msgqueue_initialise)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_free": {
        "description": "Free a queue",
        "proto": "void (*msgqueue_free)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_free": {
        "description": "Free a queue",
        "proto" :"void (*msgqueue_free)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "proto" :"int (*msgqueue_msglength)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:msgqueue_msglength": {
        "description": "Calculate the total length of all messages on the message queue.",
        "proto" :"int (*msgqueue_msglength)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:msgqueue_getmsg": {
        "description": "Return a message from a specific queue.",
        "proto" :"struct message *(*msgqueue_getmsg)(MsgQueue_t *msgq, int msgno)",
        "pre": {
            "msgq": "!=null",
            "msgno": ">=0"
        },
    }
},
{
    "kprobe:msgqueue_getmsg": {
        "description": "Return a message from a specific queue.",
        "proto" :"struct message *(*msgqueue_getmsg)(MsgQueue_t *msgq, int msgno)",
        "pre": {
            "msgq": "!=null",
            "msgno": ">=0"
        }
    }
},
{
    "kretprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "proto" :"int (*msgqueue_addmsg)(MsgQueue_t *msgq, int length, ...)",
        "pre": {
            "msgq": "!=null",
            "length": ">0"
        },
        "post": "!=0"
    }
},
{
    "kprobe:msgqueue_addmsg": {
        "description": "Add a message onto a message queue",
        "proto" :"int (*msgqueue_addmsg)(MsgQueue_t *msgq, int length, ...)",
        "pre": {
            "msgq": "!=null",
            "length": ">0",
        },
    }
},
{
    "kretprobe:msgqueue_flush": {
        "description": "Flush all messages from message queue.",
        "proto": "void (*msgqueue_flush)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kprobe:msgqueue_flush": {
        "description": "Flush all messages from message queue.",
        "proto" :"void (*msgqueue_flush)(MsgQueue_t *msgq)",
        "pre": {
            "msgq": "!=null"
        }
    }
},
{
    "kretprobe:queue_initialise": {
        "description": "Initialise a queue",
        "proto" :"int (*queue_initialise)(Queue_t *queue)",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_initialise": {
        "description": "Initialise a queue",
        "proto" :"int (*queue_initialise)(Queue_t *queue)",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:queue_free": {
        "description": "Free a queue",
        "proto": "void (*queue_free)(Queue_t *queue)",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kprobe:queue_free": {
        "description": "Free a queue",
        "proto" :"static void (*queue_free)(Queue_t *queue)",
        "pre": {
            "queue": "!=null"
        }
    }
},
{
    "kretprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "proto" :"int (*__queue_add)(Queue_t *queue, struct scsi_cmnd *SCpnt, int head)",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "in [0, 1]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:__queue_add": {
        "description": "Add a new command onto a queue, adding REQUEST_SENSE to head.",
        "proto" :"int (*__queue_add)(Queue_t *queue, struct scsi_cmnd *SCpnt, int head)",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null",
            "head": "in [0, 1]"
        },
    }
},

{
    "kprobe:queue_entry": {
        "description": "queue_remove_exclude not updating internal linked list properly (was causing commands to go missing). 30-Aug-2000 RMKUse Linux list handling and spinlocks",
        "proto" :"void (*queue_entry)(struct scsi_cmnd *cmd, struct list_head *list)",
        "pre": {
            "cmd": "!=null",
            "list": "!=null"
        },
    }
},
{
    "kretprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag",
        "proto" :"struct scsi_cmnd *(*queue_remove_tgtluntag)(Queue_t *queue, int target, int lun, int tag)",
        "pre": {
            "queue": "!=null",
            "target": "is an integer",
            "lun": "is an integer",
            "tag": "is an integer"
        },
        "post": {
            "return": "is a struct scsi_cmnd or null"
        }
    }
},
{
    "kprobe:queue_remove_tgtluntag": {
        "description": "Remove a SCSI command from the queue for a specified targetluntag",
        "proto" :"struct scsi_cmnd *(*queue_remove_tgtluntag)(Queue_t *queue, int target, int lun, int tag)",
        "pre": {
            "queue": "!=null",
            "target": "is integer",
            "lun": "is integer",
            "tag": "is integer"
        },
        "post": {
            "return": "is struct scsi_cmnd or null"
        }
    }
},
{
    "kretprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues.",
        "proto": "int (*queue_remove_cmd)(Queue_t *queue, struct scsi_cmnd *SCpnt)",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:queue_remove_cmd": {
        "description": "Remove a specific command from the queues.",
        "proto" :"int (*queue_remove_cmd)(Queue_t *queue, struct scsi_cmnd *SCpnt)",
        "pre": {
            "queue": "!=null",
            "SCpnt": "!=null"
        },
    }
},
{
    "kretprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target.",
        "proto" :"void (*queue_remove_all_target)(Queue_t *queue, int target)",
        "pre": {
            "queue": "!=null",
            "target": ">=0"
        }
    }
},
{
    "kprobe:queue_remove_all_target": {
        "description": "Remove all SCSI commands from the queue for a specified target",
        "proto" :"void (*queue_remove_all_target)(Queue_t *queue, int target)",
        "pre": {
            "queue": "!=null",
            "target": "is an integer"
        }
    }
},
{
    "kretprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "proto" :"int (*queue_probetgtlun)(Queue_t *queue, int target, int lun)",
        "pre": {
            "queue": "!=null",
            "target": ">=0",
            "lun": ">=0"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:queue_probetgtlun": {
        "description": "Check to see if we have a command in the queue for the specified targetlun.",
        "proto" :"int (*queue_probetgtlun)(Queue_t *queue, int target, int lun)",
        "pre": {
            "queue": "!=null",
            "target": "is an integer",
            "lun": "is an integer"
        },
    }
},
{
    "kretprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance @fip: The FCoE controller to initialize @mode: FIP mode to set",
        "proto" :"void (*fcoe_ctlr_init)(struct fcoe_ctlr *fip, enum fip_mode mode)",
        "pre": {
            "fip": "!=null",
            "mode": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_init": {
        "description": "Initialize the FCoE Controller instance",
        "proto" :"void (*fcoe_ctlr_init)(struct fcoe_ctlr *fip, enum fip_mode mode)",
        "pre": {
            "fip": "!=null",
            "mode": "in [valid fip_mode enum values]",
        },
    }
},
{
    "kretprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller. This is called by FCoE drivers before freeing the &fcoe_ctlr. The receive handler will have been deleted before this to guarantee that no more recv_work will be scheduled. The timer routine will simply return once we set FIP_ST_DISABLED. This guarantees that no further timeouts or work will be scheduled.",
        "proto" :"void (*fcoe_ctlr_destroy)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_destroy": {
        "description": "Disable and tear down a FCoE controller. This is called by FCoE drivers before freeing the &fcoe_ctlr. The receive handler will have been deleted before this to guarantee that no more recv_work will be scheduled. The timer routine will simply return once we set FIP_ST_DISABLED. This guarantees that no further timeouts or work will be scheduled.",
        "proto" :"void (*fcoe_ctlr_destroy)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller. Called from the LLD when the network link is ready.",
        "proto" :"void (*fcoe_ctlr_link_up)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_up": {
        "description": "Start FCoE controller. Called from the LLD when the network link is ready.",
        "proto" :"void (*fcoe_ctlr_link_up)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller. Returns non-zero if the link was up and now isn't. Called from the LLD when the network link is not ready. There may be multiple calls while the link is down.",
        "proto" :"int (*fcoe_ctlr_link_down)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_link_down": {
        "description": "Stop a FCoE controller. Returns non-zero if the link was up and now isn't. Called from the LLD when the network link is not ready. There may be multiple calls while the link is down.",
        "proto" :"int (*fcoe_ctlr_link_down)(struct fcoe_ctlr *fip)",
        "pre": {
            "fip": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate. Returns a non-zero error code if the frame should not be sent. Returns zero if the caller should send the frame with FCoE encapsulation. The caller must check that the length is a multiple of 4. The SKB must have enough headroom (28 bytes) and tailroom (8 bytes). The the skb must also be an fc_frame. This is called from the lower-level driver with spinlocks held, so we must not take a mutex here.",
        "proto" :"int fcoe_ctlr_els_send(struct fcoe_ctlr *fip, struct fc_lport *lport, struct sk_buff *skb)",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null && skb->len % 4 == 0 && skb->headroom >= 28 && skb->tailroom >= 8 && is_fc_frame(skb)"
        }
    }
},
{
    "kprobe:fcoe_ctlr_els_send": {
        "description": "Send an ELS frame encapsulated by FIP if appropriate. Returns a non-zero error code if the frame should not be sent. Returns zero if the caller should send the frame with FCoE encapsulation. The caller must check that the length is a multiple of 4. The SKB must have enough headroom (28 bytes) and tailroom (8 bytes). The the skb must also be an fc_frame. This is called from the lower-level driver with spinlocks held, so we must not take a mutex here.",
        "proto" :"int (*fcoe_ctlr_els_send)(struct fcoe_ctlr *fip, struct fc_lport *lport, struct sk_buff *skb)",
        "pre": {
            "fip": "!=null",
            "lport": "!=null",
            "skb": "!=null && is_fc_frame(skb) && skb->len % 4 == 0 && skb_headroom(skb) >= 28 && skb_tailroom(skb) >= 8"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "proto" :"static void fcoe_ctlr_set_state(struct fcoe_ctlr *fip, enum fip_state state)",
        "pre": {
            "fip": "!=null",
            "state": "in [FIP_ST_DISABLED, FIP_ST_LINK_WAIT, FIP_ST_AUTO, FIP_ST_NON_FIP, FIP_ST_ENABLED, FIP_ST_VNMP_START, FIP_ST_VNMP_PROBE1, FIP_ST_VNMP_PROBE2, FIP_ST_VNMP_CLAIM, FIP_ST_VNMP_UP]"
        }
    }
},
{
    "kprobe:fcoe_ctlr_set_state": {
        "description": "Set and do debug printing for the new FIP state.",
        "proto": "static void (*fcoe_ctlr_set_state)(struct fcoe_ctlr *fip, enum fip_state state)",
        "pre": {
            "fip": "!=null",
            "state": "in [FIP_ST_DISABLED, FIP_ST_LINK_WAIT, FIP_ST_AUTO, FIP_ST_NON_FIP, FIP_ST_ENABLED, FIP_ST_VNMP_START, FIP_ST_VNMP_PROBE1, FIP_ST_VNMP_PROBE2, FIP_ST_VNMP_CLAIM, FIP_ST_VNMP_UP]"
        }
    }
},
{
    "kretprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response. The caller has checked that we are waiting for login as indicated by fip->flogi_oxid != FC_XID_UNKNOWN. The caller is responsible for freeing the frame. Fill in the granted_mac address. Return non-zero if the frame should not be delivered to libfc.",
        "proto" :"int (*fcoe_ctlr_recv_flogi)(struct fcoe_ctlr *fip, struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "fip": "!=null && fip->flogi_oxid != FC_XID_UNKNOWN",
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fcoe_ctlr_recv_flogi": {
        "description": "Snoop pre-FIP receipt of FLOGI response. Snoop potential response to FLOGI or even incoming FLOGI. The caller has checked that we are waiting for login as indicated by fip->flogi_oxid != FC_XID_UNKNOWN. The caller is responsible for freeing the frame. Fill in the granted_mac address. Return non-zero if the frame should not be delivered to libfc.",
        "proto" :"int (*fcoe_ctlr_recv_flogi)(struct fcoe_ctlr *fip, struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "fip": "!=null && fip->flogi_oxid != FC_XID_UNKNOWN",
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport @ft: The fcoe transport to be attached. Returns : 0 for success",
        "proto" :"int (*fcoe_transport_attach)(struct fcoe_transport *ft)",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:fcoe_transport_attach": {
        "description": "Attaches an FCoE transport. Returns 0 for success.",
        "proto" :"int (*fcoe_transport_attach)(struct fcoe_transport *ft)",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kretprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport @ft: The fcoe transport to be attached. Returns : 0 for success",
        "proto" :"int (*fcoe_transport_detach)(struct fcoe_transport *ft)",
        "pre": {
            "ft": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:fcoe_transport_detach": {
        "description": "Detaches an FCoE transport @ft: The fcoe transport to be attached. Returns : 0 for success",
        "proto" :"int (*fcoe_transport_detach)(struct fcoe_transport *ft)",
        "pre": {
            "ft": "!=null"
        }
    }
},
{
    "kretprobe:fc_frame_crc_check": {
        "description": "Check the CRC of the frame.",
        "proto" :"static long (*fc_frame_crc_check)(struct fc_frame *fp)",
        "pre": {
            "fp": "!=null"
        },
    }
},
{
    "kprobe:fc_frame_crc_check": {
        "description": "Check the CRC of the frame.",
        "proto" :"static long (*fc_frame_crc_check)(struct fc_frame *fp)",
        "pre": {
            "fp": "!=null && fc_frame_is_linear(fp) == true",
        },
    }
},
{
    "kretprobe:fc_frame_alloc_fill": {
        "description": "Allocates a frame and fills it with payload. The frame is then trimmed to the appropriate size.",
        "proto" :"static struct fc_frame (*fc_frame_alloc_fill)(struct fc_lport *lp, size_t payload_len)",
        "pre": {
            "lp": "!=null",
            "payload_len": ">=0"
        },
    }
},
{
    "kprobe:fc_frame_alloc_fill": {
        "description": "Allocate a frame and fill it with payload. The payload length is rounded up to the nearest multiple of 4. If the frame is successfully allocated, it is filled with zeros and trimmed to the correct size.",
        "proto" :"struct fc_frame* (*fc_frame_alloc_fill)(struct fc_lport* lp, size_t payload_len)",
        "pre": {
            "lp": "!=null",
            "payload_len": ">=0"
        },
    }
},
{
    "kretprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id. The local port to lookup the remote port on. The remote port ID to look up. The reference count of the fc_rport_priv structure is increased by one.",
        "proto" :"struct fc_rport_priv *(*fc_rport_lookup)(const struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": ">=0"
        },
    }
},
{
    "kprobe:fc_rport_lookup": {
        "description": "Lookup a remote port by port_id. The local port to lookup the remote port on. The remote port ID to look up. The reference count of the fc_rport_priv structure is increased by one.",
        "proto" :"struct fc_rport_priv *(*fc_rport_lookup)(const struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": ">=0"
        }
    }
},
{
    "kretprobe:fc_rport_create": {
        "description": "Create a new remote port. The remote port will start in the INIT state.",
        "proto" :"struct fc_rport_priv *(*fc_rport_create)(struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": ">=0"
        },
    }
},
{
    "kprobe:fc_rport_create": {
        "description": "Create a new remote port. The remote port will start in the INIT state.",
        "proto" :"struct fc_rport_priv *(*fc_rport_create)(struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": ">=0",
        },
    }
},
{
    "kretprobe:fc_rport_destroy": {
        "description": "Free a remote port after last reference is released",
        "proto": "void (*fc_rport_destroy)(struct kref *kref)",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_destroy": {
        "description": "Free a remote port after last reference is released.",
        "proto" :"void (*fc_rport_destroy)(struct kref *kref)",
        "pre": {
            "kref": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout. The remote port gets a new timeout value. The new timeout value is in seconds.",
        "proto" :"void (*fc_set_rport_loss_tmo)(struct fc_rport *rport, u32 timeout)",
        "pre": {
            "rport": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:fc_set_rport_loss_tmo": {
        "description": "Set the remote port loss timeout. The remote port gets a new timeout value. The new timeout value is in seconds.",
        "proto" :"void (*fc_set_rport_loss_tmo)(struct fc_rport *rport, u32 timeout)",
        "pre": {
            "rport": "!=null",
            "timeout": ">=0",
        },
    }
},
{
    "kretprobe:fc_rport_login": {
        "description": "Start the remote port login state machine. Initiates the RP state machine. It is called from the LP module. This function will issue the following commands to the N_Port identified by the FC ID provided. - PLOGI - PRLI - RTV. Locking Note: Called without the rport lock held. This function will hold the rport lock, call an _enter_ function and then unlock the rport. This indicates the intent to be logged into the remote port. If it appears we are already logged in, ADISC is used to verify the setup.",
        "proto" :"int (*fc_rport_login)(struct fc_rport_priv *rdata)",
        "pre": {
            "rdata": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_login": {
        "description": "Start the remote port login state machine. Initiates the RP state machine. It is called from the LP module. This function will issue the following commands to the N_Port identified by the FC ID provided. - PLOGI - PRLI - RTV. Called without the rport lock held. This function will hold the rport lock, call an _enter_ function and then unlock the rport. This indicates the intent to be logged into the remote port. If it appears we are already logged in, ADISC is used to verify the setup.",
        "proto" :"int fc_rport_login(struct fc_rport_priv *rdata)",
        "pre": {
            "rdata": "!=null"
        }
    }
},


{
    "kretprobe:fc_rport_recv_req": {
        "description": "Handler for requests. The local port that received the request. The request frame. Reference counting: does not modify kref.",
        "proto" :"void (*fc_rport_recv_req)(struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_recv_req": {
        "description": "Handler for requests. The local port that received the request. The request frame. Reference counting: does not modify kref.",
        "proto" :"void (*fc_rport_recv_req)(struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "proto" :"static void (*fc_rport_flush_queue)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:fc_rport_flush_queue": {
        "description": "Flush the rport_event_queue",
        "proto" :"static void (*fc_rport_flush_queue)(void)",
        "pre": {
            // Here you should specify the preconditions for the function.
            // Since the function does not take any arguments, there might not be any preconditions.
        },
    }
},
{
    "kretprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port",
        "proto" :"void (*fc_rport_terminate_io)(struct fc_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kprobe:fc_rport_terminate_io": {
        "description": "Stop all outstanding IO on a remote port @rport: The remote port whose IO should be terminated",
        "proto" :"void (*fc_rport_terminate_io)(struct fc_rport *rport)",
        "pre": {
            "rport": "!=null"
        }
    }
},
{
    "kretprobe:fc_disc_config": {
        "description": "Configure the discovery layer for a local port. The local port that needs the discovery layer to be configured. Private data structure for users of the discovery layer.",
        "proto" :"void (*fc_disc_config)(struct fc_lport *lport, void *priv)",
        "pre": {
            "lport": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kprobe:fc_disc_config": {
        "description": "Configure the discovery layer for a local port. The local port that needs the discovery layer to be configured. Private data structure for users of the discovery layer.",
        "proto" :"void (*fc_disc_config)(struct fc_lport *lport, void *priv)",
        "pre": {
            "lport": "!=null",
            "priv": "!=null"
        }
    }
},
{
    "kretprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "proto" :"void (*fc_disc_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_disc_init": {
        "description": "Initialize the discovery layer for a local port",
        "proto": "void (*fc_disc_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance. @vport: fc_vport structure from scsi_transport_fc. @privsize: driver private data size to allocate along with the Scsi_Host.",
        "proto" :"struct fc_lport *(*libfc_vport_create)(struct fc_vport *vport, int privsize)",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0"
        }
    }
},
{
    "kprobe:libfc_vport_create": {
        "description": "Create a new NPIV vport instance. @vport: fc_vport structure from scsi_transport_fc. @privsize: driver private data size to allocate along with the Scsi_Host.",
        "proto" :"struct fc_lport *(*libfc_vport_create)(struct fc_vport *vport, int privsize)",
        "pre": {
            "vport": "!=null",
            "privsize": ">=0",
        },
    }
},
{
    "kretprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID. @n_port: Top level N_Port which may have multiple NPIV VN_Ports. @port_id: Fabric ID to find a match for. Returns: matching lport pointer or NULL if there is no match.",
        "proto" :"struct fc_lport *(*fc_vport_id_lookup)(struct fc_lport *n_port, u32 port_id)",
        "pre": {
            "n_port": "!=null",
            "port_id": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:fc_vport_id_lookup": {
        "description": "Find NPIV lport that matches a given fabric ID. Returns matching lport pointer or NULL if there is no match.",
        "proto" :"struct fc_lport *(*fc_vport_id_lookup)(struct fc_lport *n_port, u32 port_id)",
        "pre": {
            "n_port": "!=null",
            "port_id": ">=0"
        },
    }
},
{
    "kretprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port. Must be called with both the N_Port and VN_Port lp_mutex held.",
        "proto" :"static void (*__fc_vport_setlink)(struct fc_lport *n_port, struct fc_lport *vn_port)",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null"
        }
    }
},
{
    "kprobe:__fc_vport_setlink": {
        "description": "Update link and status on a VN_Port. Must be called with both the N_Port and VN_Port lp_mutex held.",
        "proto" :"static void (*__fc_vport_setlink)(struct fc_lport *n_port, struct fc_lport *vn_port)",
        "pre": {
            "n_port": "!=null",
            "vn_port": "!=null"
        },
    }
},
{
    "kretprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "proto" :"static long (*EXPORT_SYMBOL(fc_cpu_mask))(void *mask)",
        "pre": {
            "mask": "!=null"
        },
    }
},
{
    "kprobe:EXPORT_SYMBOL(fc_cpu_mask)": {
        "description": "cpu mask for possible cpus",
        "proto" :"void (*EXPORT_SYMBOL(fc_cpu_mask))(cpumask_t *mask)",
        "pre": {
            "mask": "!=null"
        },
    }
},
{
    "kretprobe:fc_seq_send_locked": {
        "description": "Update sequence count if this frame is carrying multiple FC frames when sequence offload is enabled by LLD.",
        "proto" :"static long (*fc_seq_send_locked)(struct fc_lport  lport, struct fc_seq  sp, struct fc_frame  fp)",
        "pre": {
            "lport": "!=null",
            "sp": "!=null",
            "fp": "!=null"
        },
    }
},
{
    "kprobe:fc_seq_send_locked": {
        "description": "Update sequence count if this frame is carrying multiple FC frames when sequence offload is enabled by LLD.",
        "proto" :"static void (*fc_seq_send_locked)(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "sp": "!=null",
            "fp": "!=null",
            // Add more conditions here based on your understanding of the function
        },
    }
},
{
    "kretprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence @sp: The sequenceexchange to get a new sequence for",
        "proto" :"static struct fc_seq *(*fc_seq_start_next_locked)(struct fc_seq *sp)",
        "pre": {
            "sp": "!=null"
        }
    }
},
{
    "kprobe:fc_seq_start_next_locked": {
        "description": "Allocate a new sequence on the same exchange as the supplied sequence @sp: The sequenceexchange to get a new sequence for",
        "proto" :"static struct fc_seq *(*fc_seq_start_next_locked)(struct fc_seq *sp)",
        "pre": {
            "sp": "!=null"
        }
    }
},


{
    "kretprobe:fc_seq_assign": {
        "description": "fc_seq_release().",
        "proto" :"struct fc_seq *(*fc_seq_assign)(struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},

{
    "kretprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port. If sid is non-zero then reset only the exchanges sent from the local port's FID. If did is non-zero then reset only exchanges destined for the local port's FID.",
        "proto" :"void (*fc_exch_mgr_reset)(struct fc_lport *lport, u32 sid, u32 did)",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        },
    }
},
{
    "kprobe:fc_exch_mgr_reset": {
        "description": "Reset all EMs of a local port. Release all sequences and exchanges. If sid is non-zero then reset only the exchanges sent from the local port's FID. If did is non-zero then reset only exchanges destined for the local port's FID.",
        "proto" :"void (*fc_exch_mgr_reset)(struct fc_lport *lport, u32 sid, u32 did)",
        "pre": {
            "lport": "!=null",
            "sid": ">=0",
            "did": ">=0"
        }
    }
},
{
    "kretprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence. The exchange response handler is set in this routine to resp() function pointer. It can be called in two scenarios: if a timeout occurs or if a response frame is received for the exchange. The fc_frame pointer in response handler will also indicate timeout as error using IS_ERR related macros. The exchange destructor handler is also set in this routine. The destructor handler is invoked by EM layer when exchange is about to free, this can be used by caller to free its resources along with exchange free. The arg is passed back to resp and destructor handler. The timeout value (in msec) for an exchange is set if non zero timer_msec argument is specified. The timer is canceled when it fires or when the exchange is done. The exchange timeout handler is registered by EM layer. The frame pointer with some of the header's fields must be filled before calling this routine, those fields are: routing control, FC port did, FC port sid, FC header type, frame control, parameter or relative offset.",
        "proto" :"struct fc_seq *(*fc_exch_seq_send)(struct fc_lport *lport, struct fc_frame *fp, void (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg), void (*destructor)(struct fc_seq *, void *), void *arg, u32 timer_msec)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null && fp->header_fields_filled",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "can be any value",
            "timer_msec": ">=0"
        }
    }
},
{
    "kprobe:fc_exch_seq_send": {
        "description": "Send a frame using a new exchange and sequence. The exchange response handler and destructor handler are set in this routine. The arg is passed back to resp and destructor handler. The timeout value (in msec) for an exchange is set if non zero timer_msec argument is specified. The frame pointer with some of the header's fields must be filled before calling this routine.",
        "proto" :"struct fc_seq *(*fc_exch_seq_send)(struct fc_lport *lport, struct fc_frame *fp, void (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg), void (*destructor)(struct fc_seq *, void *), void *arg, u32 timer_msec)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null && header_fields_filled",
            "resp": "!=null",
            "destructor": "!=null",
            "arg": "any",
            "timer_msec": ">0",
        },
    }
},
{
    "kretprobe:fc_exch_update_stats": {
        "description": "Update exches stats to lport. @lport: The local port to update exchange manager stats.",
        "proto" :"void (*fc_exch_update_stats)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_update_stats": {
        "description": "Update exches stats to lport",
        "proto" :"void (*fc_exch_update_stats)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null",
        },
    }
},
{
    "kretprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs. The match routine indicates when this EM should be used.",
        "proto" :"struct fc_exch_mgr_anchor *(*fc_exch_mgr_add)(struct fc_lport *lport, struct fc_exch_mgr *mp, bool (*match)(struct fc_frame *))",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_add": {
        "description": "Add an exchange manager to a local port's list of EMs. The match routine indicates when this EM should be used.",
        "proto" :"struct fc_exch_mgr_anchor *(*fc_exch_mgr_add)(struct fc_lport *lport, struct fc_exch_mgr *mp, bool (*match)(struct fc_frame *))",
        "pre": {
            "lport": "!=null",
            "mp": "!=null",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list. @ema: The exchange manager anchor identifying the EM to be deleted.",
        "proto" :"void (*fc_exch_mgr_del)(struct fc_exch_mgr_anchor *ema)",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_del": {
        "description": "Delete an EM from a local port's list. @ema: The exchange manager anchor identifying the EM to be deleted.",
        "proto" :"void (*fc_exch_mgr_del)(struct fc_exch_mgr_anchor *ema)",
        "pre": {
            "ema": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects. Source lport to clone exchange managers from. New lport that takes references to all the exchange managers.",
        "proto" :"int (*fc_exch_mgr_list_clone)(struct fc_lport *src, struct fc_lport *dst)",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_list_clone": {
        "description": "Share all exchange manager objects. Source lport to clone exchange managers from. New lport that takes references to all the exchange managers.",
        "proto" :"int (*fc_exch_mgr_list_clone)(struct fc_lport *src, struct fc_lport *dst)",
        "pre": {
            "src": "!=null",
            "dst": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager. The local port that the new EM will be associated with. The default FC class for new exchanges. The minimum XID for exchanges from the new EM. The maximum XID for exchanges from the new EM. The match routine for the new EM.",
        "proto" :"struct fc_exch_mgr *(*fc_exch_mgr_alloc)(struct fc_lport *lport, enum fc_class class, u16 min_xid, u16 max_xid, bool (*match)(struct fc_frame *))",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_SIMPLE, FC_CLASS_2, FC_CLASS_3, FC_CLASS_4, FC_CLASS_F, FC_CLASS_NONE]",
            "min_xid": ">=0",
            "max_xid": "<=65535",
            "match": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_alloc": {
        "description": "Allocate an exchange manager. The local port that the new EM will be associated with. The default FC class for new exchanges. The minimum XID for exchanges from the new EM. The maximum XID for exchanges from the new EM. The match routine for the new EM.",
        "proto" :"struct fc_exch_mgr *(*fc_exch_mgr_alloc)(struct fc_lport *lport, enum fc_class class, u16 min_xid, u16 max_xid, bool (*match)(struct fc_frame *))",
        "pre": {
            "lport": "!=null",
            "class": "in [FC_CLASS_SIMPLE, FC_CLASS_2, FC_CLASS_3, FC_CLASS_4, FC_CLASS_F, FC_CLASS_NONE]",
            "min_xid": ">=0",
            "max_xid": "<=65535",
            "match": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "proto": "void (*fc_exch_mgr_free)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_mgr_free": {
        "description": "Free all exchange managers on a local port",
        "proto" :"void (*fc_exch_mgr_free)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS. This would be for target mode usually, but could be due to lost FCP transfer ready, confirm or RRQ. We always handle this as an exchange abort, ignoring the parameter.",
        "proto" :"static void (*fc_exch_recv_abts)(struct fc_exch *ep, struct fc_frame *rx_fp)",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_recv_abts": {
        "description": "Handle an incoming ABTS. This would be for target mode usually, but could be due to lost FCP transfer ready, confirm or RRQ. We always handle this as an exchange abort, ignoring the parameter.",
        "proto" :"static void (*fc_exch_recv_abts)(struct fc_exch *ep, struct fc_frame *rx_fp)",
        "pre": {
            "ep": "!=null",
            "rx_fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "proto" :"int (*fc_exch_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_exch_init": {
        "description": "Initialize the exchange layer for a local port",
        "proto" :"int (*fc_exch_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fill_hdr": {
        "description": "fill FC header fields based on request",
        "proto" :"void (*fc_fill_hdr)(struct fc_frame *fp, const struct fc_frame *in_fp, enum fc_rctl r_ctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset)",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "your_condition_here",
            "f_ctl": "your_condition_here",
            "seq_cnt": "your_condition_here",
            "parm_offset": "your_condition_here"
        }
    }
},
{
    "kprobe:fc_fill_hdr": {
        "description": "Fill FC header fields based on request",
        "proto": "void (*fc_fill_hdr)(struct fc_frame *fp, const struct fc_frame *in_fp, enum fc_rctl r_ctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset)",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "any valid enum fc_rctl value",
            "f_ctl": "any valid u32 value",
            "seq_cnt": "any valid u16 value",
            "parm_offset": "any valid u32 value"
        }
    }
},
{
    "kretprobe:fc_fill_reply_hdr": {
        "description": "fill FC reply header fields based on request @fp: reply frame containing header to be filled in @in_fp: request frame containing header to use in filling in reply @r_ctl: R_CTL value for reply @parm_offset: parameter offset value",
        "proto" :"void (*fc_fill_reply_hdr)(struct fc_frame *fp, const struct fc_frame *in_fp, enum fc_rctl r_ctl, u32 parm_offset)",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "in [FC_RCTL_DD_UNSOL_CMD, FC_RCTL_DD_SOL_CMD, FC_RCTL_DD_UNSOL_DATA, FC_RCTL_DD_DATA_DESC, FC_RCTL_DD_SOL_DATA, FC_RCTL_DD_UNSOL_CTL, FC_RCTL_DD_SOL_CTL, FC_RCTL_DD_UNSOL_CMD, FC_RCTL_DD_SOL_CMD, FC_RCTL_ELS_REQ, FC_RCTL_ELS_REP, FC_RCTL_ELS_REP, FC_RCTL_ELS_REQ, FC_RCTL_ELS_REP, FC_RCTL_ELS_REP]",
            "parm_offset": ">=0"
        },
    }
},
{
    "kprobe:fc_fill_reply_hdr": {
        "description": "Fill FC reply header fields based on request. @fp: reply frame containing header to be filled in. @in_fp: request frame containing header to use in filling in reply. @r_ctl: R_CTL value for reply. @parm_offset: parameter offset value.",
        "proto" :"void (*fc_fill_reply_hdr)(struct fc_frame *fp, const struct fc_frame *in_fp, enum fc_rctl r_ctl, u32 parm_offset)",
        "pre": {
            "fp": "!=null",
            "in_fp": "!=null",
            "r_ctl": "!=null",
            "parm_offset": "!=null"
        }
    }
},
{
    "kretprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider. Returns 0 on success, negative error otherwise.",
        "proto" :"int (*fc_fc4_register_provider)(enum fc_fh_type type, struct fc4_prov *prov)",
        "pre": {
            "type": "in [FC_TYPE_FCP, ...]", // Please replace ... with other possible enum values
            "prov": "!=null"
        },
    }
},
{
    "kprobe:fc_fc4_register_provider": {
        "description": "Register FC-4 upper-level provider. Returns 0 on success, negative error otherwise.",
        "proto" :"int (*fc_fc4_register_provider)(enum fc_fh_type type, struct fc4_prov *prov)",
        "pre": {
            "type": "in [FC_TYPE_FCP, ...]",  // Replace ... with other possible enum values
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider. @type: FC-4 type, such as FC_TYPE_FCP @prov: structure describing provider including ops vector.",
        "proto" :"void (*fc_fc4_deregister_provider)(enum fc_fh_type type, struct fc4_prov *prov)",
        "pre": {
            "type": "in [FC_TYPE_FCP, ...]", // Please replace ... with other possible enum values
            "prov": "!=null"
        }
    }
},
{
    "kprobe:fc_fc4_deregister_provider": {
        "description": "Deregister FC-4 upper-level provider. @type: FC-4 type, such as FC_TYPE_FCP @prov: structure describing provider including ops vector.",
        "proto" :"void (*fc_fc4_deregister_provider)(enum fc_fh_type type, struct fc4_prov *prov)",
        "pre": {
            "type": "!=null",
            "prov": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_port_state": {
        "description": "Return the port state of the given Scsi_Host",
        "proto" :"void fc_get_host_port_state(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_port_state": {
        "description": "Return the port state of the given Scsi_Host",
        "proto" :"void (*fc_get_host_port_state)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host @shost: The SCSI host whose port speed is to be determined",
        "proto" :"void (*fc_get_host_speed)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_speed": {
        "description": "Return the speed of the given Scsi_Host",
        "proto" :"void fc_get_host_speed(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics. @shost: The SCSI host whose statistics are to be returned.",
        "proto" :"struct fc_host_statistics *(*fc_get_host_stats)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kprobe:fc_get_host_stats": {
        "description": "Return the Scsi_Host's statistics. @shost: The SCSI host whose statistics are to be returned.",
        "proto" :"struct fc_host_statistics *(*fc_get_host_stats)(struct Scsi_Host *shost)",
        "pre": {
            "shost": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_login": {
        "description": "Start the lport state machine. The local port that should log into the fabric. This function should not be called with the lport lock held.",
        "proto" :"int (*fc_fabric_login)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fabric_login": {
        "description": "Start the lport state machine. The local port should log into the fabric. This function should not be called with the lport lock held.",
        "proto" :"int (*fc_fabric_login)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkup": {
        "description": "Handler for transport linkup events",
        "proto" :"void (*__fc_linkup)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkup": {
        "description": "Handler for transport linkup events. The lport whose link is up.",
        "proto" :"void (*__fc_linkup)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events. @lport: The lport whose link is down",
        "proto" :"void (*__fc_linkdown)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:__fc_linkdown": {
        "description": "Handler for transport linkdown events",
        "proto" :"void (*__fc_linkdown)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric. The local port to logoff the fabric.",
        "proto" :"int (*fc_fabric_logoff)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:fc_fabric_logoff": {
        "description": "Logout of the fabric. The local port to logoff the fabric. Return value: 0 for success, -1 for failure.",
        "proto" :"int (*fc_fabric_logoff)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kretprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport. This is the exit routine for fc_lport instance. It cleans up all the allocated memory and frees up other system resources.",
        "proto" :"int (*fc_lport_destroy)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_destroy": {
        "description": "Unregister a fc_lport. This is the exit routine for fc_lport instance. It cleans up all the allocated memory and frees up other system resources.",
        "proto" :"int (*fc_lport_destroy)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "proto" :"int (*fc_set_mfs)(struct fc_lport *lport, u32 mfs)",
        "pre": {
            "lport": "!=null",
            "mfs": ">=0"
        }
    }
},
{
    "kprobe:fc_set_mfs": {
        "description": "Set the maximum frame size for a local port",
        "proto" :"int (*fc_set_mfs)(struct fc_lport *lport, u32 mfs)",
        "pre": {
            "lport": "!=null",
            "mfs": ">0"
        },
    }
},
{
    "kretprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint. Called by the lower-level driver when transport sets the local port_id. This is used in VN_port to VN_port mode for FCoE, and causes FLOGI and discovery to be skipped.",
        "proto" :"void (*fc_lport_set_local_id)(struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": "is a valid port ID"
        },
    }
},
{
    "kprobe:fc_lport_set_local_id": {
        "description": "Set the local port Port ID for point-to-multipoint. Called by the lower-level driver when transport sets the local port_id. This is used in VN_port to VN_port mode for FCoE, and causes FLOGI and discovery to be skipped.",
        "proto" :"void (*fc_lport_set_local_id)(struct fc_lport *lport, u32 port_id)",
        "pre": {
            "lport": "!=null",
            "port_id": "is a valid u32 value"
        }
    }
},
{
    "kretprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "proto" :"static void (*fc_lport_recv_rlir_req)(struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_recv_rlir_req": {
        "description": "Handle received Registered Link Incident Report.",
        "proto" :"static void (*fc_lport_recv_rlir_req)(struct fc_lport *lport, struct fc_frame *fp)",
        "pre": {
            "lport": "!=null",
            "fp": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_reset": {
        "description": "Reset a local port. This function should not be called with the lport lock held.",
        "proto" :"int (*fc_lport_reset)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_reset": {
        "description": "Reset a local port. This function should not be called with the lport lock held.",
        "proto" :"int (*fc_lport_reset)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request. This function will be called without the lport lock held, but it will lock, call an _enter_ function or fc_lport_error() and then unlock the lport.",
        "proto" :"void (*fc_lport_logo_resp)(struct fc_seq *sp, struct fc_frame *fp, void *lp_arg)",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_logo_resp": {
        "description": "Handle response to LOGO request. This function will be called without the lport lock held, but it will lock, call an _enter_ function or fc_lport_error() and then unlock the lport.",
        "proto" :"void (*fc_lport_logo_resp)(struct fc_seq *sp, struct fc_frame *fp, void *lp_arg)",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request. This function will be called without the lport lock held, but it will lock, call an _enter_ function or fc_lport_error() and then unlock the lport.",
        "proto" :"void (*fc_lport_flogi_resp)(struct fc_seq *sp, struct fc_frame *fp, void *lp_arg)",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_flogi_resp": {
        "description": "Handle response to FLOGI request. This function will be called without the lport lock held, but it will lock, call an _enter_ function or fc_lport_error() and then unlock the lport.",
        "proto" :"void (*fc_lport_flogi_resp)(struct fc_seq *sp, struct fc_frame *fp, void *lp_arg)",
        "pre": {
            "sp": "!=null",
            "fp": "!=null",
            "lp_arg": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_config": {
        "description": "Configure a fc_lport",
        "proto" :"int (*fc_lport_config)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_config": {
        "description": "Configure a fc_lport. @lport: The local port to be configured.",
        "proto" :"int (*fc_lport_config)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "proto" :"int (*fc_lport_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_init": {
        "description": "Initialize the lport layer for a local port",
        "proto" :"int (*fc_lport_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "proto" :"int (*fc_lport_bsg_request)(struct bsg_job *job)",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kprobe:fc_lport_bsg_request": {
        "description": "The common entry point for sending FC Passthrough requests",
        "proto" :"int (*fc_lport_bsg_request)(struct bsg_job *job)",
        "pre": {
            "job": "!=null"
        }
    }
},
{
    "kretprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template. This is the io strategy routine, called by the SCSI layer.",
        "proto" :"int (*fc_queuecommand)(struct Scsi_Host *shost, struct scsi_cmnd *sc_cmd)",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_queuecommand": {
        "description": "The queuecommand function of the SCSI template. This is the io strategy routine, called by the SCSI layer.",
        "proto" :"int (*fc_queuecommand)(struct Scsi_Host *shost, struct scsi_cmnd *sc_cmd)",
        "pre": {
            "shost": "!=null",
            "sc_cmd": "!=null"
        },
    }
},
{
    "kretprobe:fc_eh_abort": {
        "description": "Abort a command. Send an ABTS to the target device and wait for the response.",
        "proto" :"int (*fc_eh_abort)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_abort": {
        "description": "Abort a command. Send an ABTS to the target device and wait for the response.",
        "proto" :"int (*fc_eh_abort)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN. Set from SCSI host template.",
        "proto" :"int (*fc_eh_device_reset)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        },
    }
},
{
    "kprobe:fc_eh_device_reset": {
        "description": "Reset a single LUN. The SCSI command which identifies the device whose LUN is to be reset. Set from SCSI host template.",
        "proto" :"int (*fc_eh_device_reset)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host. @sc_cmd: The SCSI command that identifies the SCSI host to be reset.",
        "proto" :"int (*fc_eh_host_reset)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kprobe:fc_eh_host_reset": {
        "description": "Reset a Scsi_Host. @sc_cmd: The SCSI command that identifies the SCSI host to be reset.",
        "proto" :"int (*fc_eh_host_reset)(struct scsi_cmnd *sc_cmd)",
        "pre": {
            "sc_cmd": "!=null"
        }
    }
},
{
    "kretprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host. Configures queue depth based on host's cmd_per_len. If not set then we use the libfc default.",
        "proto" :"int (*fc_slave_alloc)(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kprobe:fc_slave_alloc": {
        "description": "Configure the queue depth of a Scsi_Host. Configures queue depth based on host's cmd_per_len. If not set then we use the libfc default.",
        "proto" :"int fc_slave_alloc(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},
{
    "kretprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "proto" :"void (*fc_fcp_destroy)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_destroy": {
        "description": "Tear down the FCP layer for a given local port",
        "proto" :"void (*fc_fcp_destroy)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "proto" :"int (*fc_fcp_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_fcp_init": {
        "description": "Initialize the FCP layer for a local port",
        "proto" :"int (*fc_fcp_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame. The local port to send the frame on. The destination ID for the frame. The frame to be sent. The operational code. The callback routine when the response is received. The argument to pass to the response callback routine. The timeout period for the frame (in msecs).",
        "proto" :"struct fc_seq *(*fc_elsct_send)(struct fc_lport *lport, u32 did, struct fc_frame *fp, unsigned int op, void (*resp)(struct fc_seq *, struct fc_frame *, void *), void *arg, u32 timer_msec)",
        "pre": {
            "lport": "!=null",
            "did": ">=0",
            "fp": "!=null",
            "op": ">=0",
            "resp": "!=null",
            "arg": "!=null",
            "timer_msec": ">=0"
        }
    }
},
{
    "kprobe:fc_elsct_send": {
        "description": "Send an ELS or CT frame. The local port to send the frame on. The destination ID for the frame. The frame to be sent. The operational code. The callback routine when the response is received. The argument to pass to the response callback routine. The timeout period for the frame (in msecs).",
        "proto" :"struct fc_seq *(*fc_elsct_send)(struct fc_lport *lport, u32 did, struct fc_frame *fp, unsigned int op, void (*resp)(struct fc_seq *, struct fc_frame *, void *), void *arg, u32 timer_msec)",
        "pre": {
            "lport": "!=null",
            "did": ">=0",
            "fp": "!=null",
            "op": ">=0",
            "resp": "!=null",
            "arg": "can be any value",
            "timer_msec": ">=0"
        }
    }
},
{
    "kretprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer for the local port",
        "proto" :"int (*fc_elsct_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kprobe:fc_elsct_init": {
        "description": "Initialize the ELSCT layer for the local port",
        "proto" :"int (*fc_elsct_init)(struct fc_lport *lport)",
        "pre": {
            "lport": "!=null"
        }
    }
},
{
    "kretprobe:sas_prep_resume_ha": {
        "description": "Clear out any stale link eventsdata from the suspension path",
        "proto" :"static void (*sas_prep_resume_ha)(struct sas_ha_struct *ha)",
        "pre": {
            "ha": "!=null"
        },
    }
},
{
    "kprobe:sas_prep_resume_ha": {
        "description": "Clear out any stale link eventsdata from the suspension path",
        "proto" :"static void (*sas_prep_resume_ha)(struct sas_ha_struct *ha)",
        "pre": {
            "ha": "!=null",
        },
    }
},
{
    "kretprobe:sas_resume_ha": {
        "description": "Deform ports on phys that did not resume. At this point we may be racing the phy coming back (as posted by the lldd). So we post the event and once we are in the libsas context check that the phy remains suspended before tearing it down.",
        "proto" :"static long (*sas_resume_ha)(struct sas_ha_struct *ha, bool drain)",
        "pre": {
            "ha": "!=null",
            "drain": "in [true, false]"
        },
    }
},
{
    "kprobe:sas_resume_ha": {
        "description": "Deform ports on phys that did not resume. At this point we may be racing the phy coming back (as posted by the lldd). So we post the event and once we are in the libsas context check that the phy remains suspended before tearing it down.",
        "proto" :"static void (*sas_resume_ha)(struct sas_ha_struct *ha, bool drain)",
        "pre": {
            "ha": "!=null",
            "drain": "is bool"
        },
    }
},
{
    "kretprobe:sas_suspend_ha": {
        "description": "Flush suspend events while unregistered.",
        "proto" :"void sas_suspend_ha(struct sas_ha_struct *ha)",
        "pre": {
            "ha": "!=null"
        }
    }
},
{
    "kprobe:sas_suspend_ha": {
        "description": "Flush suspend events while unregistered.",
        "proto" :"static void (*sas_suspend_ha)(struct sas_ha_struct *ha)",
        "pre": {
            "ha": "!=null"
        }
    }
},


{
    "kretprobe:qlt_stop_phase1": {
        "description": "This function stops the target for a given host. It requires a mutex lock to sync with qla_tgt_fc_port_[added,deleted]. The lock is needed because we can still get an incoming packet.",
        "proto" :"qlt_stop_phase1(struct qla_tgt  tgt)",
        "pre": {
            "tgt": "!=null",
            "vha": "!=null",
            "ha": "!=null",
            "flags": "is unsigned long",
            "mutex_lock(&ha->optrom_mutex)": "is locked",
            "mutex_lock(&qla_tgt_mutex)": "is locked",
            "tgt->tgt_stop": "is not set",
            "tgt->tgt_stopped": "is not set"
        },
    }
},

{
    "kretprobe:ql_dbg": {
        "description": "Debug function for qla2xxx driver",
        "proto" :"void (*ql_dbg)(enum ql_dbg_level level, struct scsi_qla_host *vha, int32_t msg_code, char *fmt, ...)",
        "pre": {
            "level": "in [ql_dbg_async, ql_dbg_user, ql_dbg_mbx, ql_dbg_disc, ql_dbg_buffer, ql_dbg_io, ql_dbg_tgt, ql_dbg_tgt_mgt, ql_dbg_multiq, ql_dbg_p3p, ql_dbg_init, ql_dbg_timer, ql_dbg_userio, ql_dbg_dpc, ql_dbg_hw, ql_dbg_taskm, ql_dbg_aer, ql_dbg_rio, ql_dbg_mr, ql_dbg_nx2, ql_dbg_fabric, ql_dbg_transport, ql_dbg_nvme]",
            "vha": "!=null",
            "msg_code": "is integer",
            "fmt": "is string"
        }
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Debug function for qla2xxx driver",
        "proto" :"void (*ql_dbg)(int debug_level, struct scsi_qla_host *vha, int32_t to_display, char *fmt, ...)",
        "pre": {
            "debug_level": "in [ql_dbg_async, ql_dbg_tgt_mgt, ...]",
            "vha": "!=null",
            "to_display": "is integer",
            "fmt": "is string"
        }
    }
},
{
    "kretprobe:qlt_xmit_response": {
        "description": "This function seems to handle the transmission of responses in the qla_tgt_cmd context. It checks the state of the firmware, the reset count, and the deletion status of the session. If certain conditions are not met, it sets the state to QLA_TGT_STATE_PROCESSED and returns 0. It also logs debug information and updates counters based on the xmit_type.",
        "proto" :"int qlt_xmit_response(struct qla_tgt_cmd  cmd, int xmit_type, uint8_t scsi_status)",
        "pre": {
            "cmd": "!=null",
            "xmit_type": "in [QLA_TGT_XMIT_STATUS, ...]",
            "scsi_status": "in [0x00, 0x02, 0x04, 0x08, ...]"
        },
        "post": {
            "return": "in [0, ...]"
        }
    }
},
{
    "kprobe:qlt_xmit_response": {
        "description": "Either the port is not online or this request was from previous life, just abort the processing.",
        "proto" :"qlt_xmit_response(struct qla_tgt_cmd  cmd, int xmit_type,uint8_t scsi_status)",
        "pre": {
            "cmd": "!=null",
            "xmit_type": "in [QLA_TGT_XMIT_STATUS, ...]",
            "scsi_status": "in [0x00, 0x02, ...]",
        },
    }
},


{
    "kretprobe:qlt_abort_cmd": {
        "description": "It's normal to see 2 calls in this path: 1) XFER Rdy completion + CMD_T_ABORT 2) TCM TMR - drain_state_list",
        "proto" :"qlt_abort_cmd(struct qla_tgt_cmd  cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->cmd_lock": "!=null",
            "cmd->qpair": "!=null",
            "cmd->atio": "!=null"
        },
    }
},
{
    "kprobe:qlt_abort_cmd": {
        "description": "Aborts a command and sends a termination exchange.",
        "proto" :"void qlt_abort_cmd(struct qla_tgt_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->tgt": "!=null",
            "cmd->se_cmd": "!=null",
            "cmd->aborted": "in [0, 1]",
            "cmd->trc_flags": ">=0",
            "cmd->cmd_lock": "!=null",
            "cmd->qpair": "!=null"
        }
    }
},
{
    "kretprobe:ql_dbg": {
        "description": "Debugging function for qla_target.",
        "proto" :"void ql_dbg(int debug_level, struct scsi_qla_host *vha, int debug_code, const char *fmt, ...)",
        "pre": {
            "debug_level": "in [ql_dbg_tgt_mgt, ...]",
            "vha": "!=null",
            "debug_code": "is integer",
            "fmt": "is string"
        },
    }
},
{
    "kprobe:ql_dbg": {
        "description": "Your description here",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your condition here",
            "arg2": "Your condition here",
            "arg3": "Your condition here",
            "arg4": "Your condition here",
            ...
        },
    }
},
{
    "kretprobe:qlt_lport_register": {
        "description": "Register lport with external module. @target_lport_ptr: pointer for tcm_qla2xxx specific lport data. @phys_wwpn: physical port WWPN. @npiv_wwpn: NPIV WWPN. @npiv_wwnn: NPIV WWNN. @callback: lport initialization callback for tcm_qla2xxx code.",
        "proto" :"int (*qlt_lport_register)(void *target_lport_ptr, u64 phys_wwpn, u64 npiv_wwpn, u64 npiv_wwnn, int (*callback)(struct scsi_qla_host *, void *, u64, u64))",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": ">=0",
            "npiv_wwpn": ">=0",
            "npiv_wwnn": ">=0",
            "callback": "!=null"
        }
    }
},
{
    "kprobe:qlt_lport_register": {
        "description": "Register lport with external module. The lport initialization callback is for tcm_qla2xxx code.",
        "proto" :"int (*qlt_lport_register)(void *target_lport_ptr, u64 phys_wwpn, u64 npiv_wwpn, u64 npiv_wwnn, int (*callback)(struct scsi_qla_host *, void *, u64, u64))",
        "pre": {
            "target_lport_ptr": "!=null",
            "phys_wwpn": ">=0",
            "npiv_wwpn": ">=0",
            "npiv_wwnn": ">=0",
            "callback": "!=null"
        }
    }
},
{
    "kretprobe:qlt_lport_deregister": {
        "description": "Deregister lport",
        "proto" :"void qlt_lport_deregister(struct scsi_qla_host *vha)",
        "pre": {
            "vha": "!=null"
        }
    }
},
{
    "kprobe:qlt_lport_deregister": {
        "description": "Deregister lport",
        "proto" :"void qlt_lport_deregister(struct scsi_qla_host *vha)",
        "pre": {
            "vha": "!=null"
        }
    }
},






{
    "kretprobe:cqhci_resume": {
        "description": "Re-enable is done upon first request",
        "proto" :"static long (*cqhci_resume)(struct mmc_host *mmc)",
        "pre": {
            "mmc": "!=null"
        }
    }
},
{
    "kprobe:cqhci_resume": {
        "description": "Re-enable is done upon first request",
        "proto" :"cqhci_resume(struct mmc_host *mmc)",
        "pre": {
            "mmc": "!=null"
        }
    }
},
{
    "kretprobe:cqhci_irq": {
        "description": "Reads TCN and completes the request.",
        "proto" :"cqhci_irq(struct mmc_host  mmc, u32 intmask, int cmd_error, int data_error)",
        "pre": {
            "mmc": "!=null",
            "intmask": "is u32",
            "cmd_error": "is int",
            "data_error": "is int"
        },
    }
},
{
    "kprobe:cqhci_irq": {
        "description": "Handles the interrupt requests for the Command Queue Host Controller Interface (CQHCI) for MMC (MultiMediaCard) devices.",
        "proto" :"void cqhci_irq(struct mmc_host *mmc, u32 intmask, int cmd_error, int data_error)",
        "pre": {
            "mmc": "!=null",
            "intmask": "is u32",
            "cmd_error": "is int",
            "data_error": "is int"
        },
    }
},


{
    "kretprobe:mmc_request_done": {
        "description": "MMC drivers should call this function when they have completed their processing of a request.",
        "proto" :"void (*mmc_request_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_request_done": {
        "description": "MMC drivers should call this function when they have completed their processing of a request.",
        "proto" :"void (*mmc_request_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
S,
{
    "kprobe:mmc_retune": {
        "description": "Please fill in the description here",
        "proto" :"static int (*mmc_retune)(struct mmc_host *host)",
        "pre": {
            "host": "!=null",
        },
    }
},
{
    "kretprobe:mmc_wait_for_req_done": {
        "description": "Wait for the request to be done.",
        "proto" :"static void (*mmc_wait_for_req_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        },
    }
},
{
    "kprobe:__mmc_start_request": {
        "description": "mmc_wait_for_req_done().",
        "proto" :"static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        },
    }
},
{
    "kretprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request. @host: MMC host to start the request @mrq: request to start. Start the request, re-tuning if needed and it is possible. Returns an error code if the request fails to start or -EBUSY if CQE is busy.",
        "proto" :"int (*mmc_cqe_start_req)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        },
        "post": {
            "return": "in [-EBUSY, 0]"
        }
    }
},
{
    "kprobe:mmc_cqe_start_req": {
        "description": "Start a CQE request. Start the request, re-tuning if needed and it is possible. Returns an error code if the request fails to start or -EBUSY if CQE is busy.",
        "proto" :"int mmc_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "<your_condition>",
            "mrq": "<your_condition>"
        },
    }
},
{
    "kretprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request. CQE drivers should call this function when they have completed their processing of a request.",
        "proto": "void mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_request_done": {
        "description": "CQE has finished processing an MMC request. CQE drivers should call this function when they have completed their processing of a request.",
        "proto" :"void (*mmc_cqe_request_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request @host: MMC host @mrq: MMC request to be processed",
        "proto" :"void (*mmc_cqe_post_req)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kprobe:mmc_cqe_post_req": {
        "description": "CQE post process of a completed MMC request @host: MMC host @mrq: MMC request to be processed",
        "proto" :"void (*mmc_cqe_post_req)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null"
        }
    }
},
{
    "kretprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors. @host: MMC host to recover. Recovery consists of stopping CQE, stopping eMMC, discarding the queue in eMMC, and discarding the queue in CQE. CQE must call mmc_cqe_request_done() on all requests. An error is returned if the eMMC fails to discard its queue.",
        "proto" :"int mmc_cqe_recovery(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:mmc_cqe_recovery": {
        "description": "Recover from CQE errors. @host: MMC host to recover. Recovery consists of stopping CQE, stopping eMMC, discarding the queue in eMMC, and discarding the queue in CQE. CQE must call mmc_cqe_request_done() on all requests. An error is returned if the eMMC fails to discard its queue.",
        "proto" :"int mmc_cqe_recovery(struct mmc_host *host)",
        "pre": {
            "host": "!=null",
        },
    }
},
{
    "kretprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done. mmc_is_req_done() is used with requests that have mrq->cap_cmd_during_tfr = true. mmc_is_req_done() must be called after starting a request and before waiting for it to complete. That is, either in between calls to mmc_start_req(), or after mmc_wait_for_req() and before mmc_wait_for_req_done(). If it is called at other times the result is not meaningful.",
        "proto" :"bool (*mmc_is_req_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null && mrq->cap_cmd_during_tfr == true"
        },
    }
},
{
    "kprobe:mmc_is_req_done": {
        "description": "Determine if a 'cap_cmd_during_tfr' request is done. mmc_is_req_done() is used with requests that have mrq->cap_cmd_during_tfr = true. mmc_is_req_done() must be called after starting a request and before waiting for it to complete. That is, either in between calls to mmc_start_req(), or after mmc_wait_for_req() and before mmc_wait_for_req_done(). If it is called at other times the result is not meaningful.",
        "proto" :"bool (*mmc_is_req_done)(struct mmc_host *host, struct mmc_request *mrq)",
        "pre": {
            "host": "!=null",
            "mrq": "!=null && mrq->cap_cmd_during_tfr == true",
        },
    }
},


{
    "kretprobe:mmc_set_data_timeout": {
        "description": "Set the timeout for a data command. Computes the data timeout parameters according to the correct algorithm given the card type.",
        "proto" :"void (*mmc_set_data_timeout)(struct mmc_data *data, const struct mmc_card *card)",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        }
    }
},
{
    "kprobe:mmc_set_data_timeout": {
        "description": "Set the timeout for a data command. Computes the data timeout parameters according to the correct algorithm given the card type.",
        "proto" :"void (*mmc_set_data_timeout)(struct mmc_data *data, const struct mmc_card *card)",
        "pre": {
            "data": "!=null",
            "card": "!=null"
        }
    }
},
{
    "kretprobe:__mmc_claim_host": {
        "description": "__mmc_claim_host - exclusively claim a host. If @abort is non null and dereference a non-zero value then this will return prematurely with that non-zero value without acquiring the lock. Returns zero with the lock held otherwise.",
        "proto" :"int (*__mmc_claim_host)(struct mmc_host *host, struct mmc_ctx *ctx, atomic_t *abort)",
        "pre": {
            "host": "!=null",
            "ctx": "can be null",
            "abort": "can be null or non-zero"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:__mmc_claim_host": {
        "description": "__mmc_claim_host - exclusively claim a host. Claim a host for a set of operations. If @abort is non null and dereference a non-zero value then this will return prematurely with that non-zero value without acquiring the lock. Returns zero with the lock held otherwise.",
        "proto" :"int (*__mmc_claim_host)(struct mmc_host *host, struct mmc_ctx *ctx, atomic_t *abort)",
        "pre": {
            "host": "!=null",
            "ctx": "can be null",
            "abort": "can be null or non-zero"
        },
    }
},
{
    "kretprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "proto" :"void (*mmc_release_host)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_release_host": {
        "description": "Release a MMC host, allowing others to claim the host for their operations.",
        "proto" :"void (*mmc_release_host)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_detect_change": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "proto" :"void mmc_detect_change(struct mmc_host *host, unsigned long delay, bool cd_irq)",
        "pre": {
            "host": "!=null",
            "delay": ">=0",
            "cd_irq": "in [true, false]"
        },
    }
},
{
    "kprobe:mmc_detect_change": {
        "description": "Prevent system sleep for 5s to allow user space to consume the corresponding uevent. This is especially useful, when CD irq is used as a system wakeup, but doesn't hurt in other cases.",
        "proto" :"void mmc_detect_change(struct mmc_host *host, unsigned long delay, bool cd_irq)",
        "pre": {
            "host": "!=null",
            "delay": ">=0",
            "cd_irq": "in [true, false]"
        },
    }
},
{
    "kretprobe:mmc_erase_timeout": {
        "description": "Determines the erase timeout based on the argument and the card's extended CSD revision. If the argument is MMC_DISCARD_ARG or MMC_TRIM_ARG and the card's ext_csd.rev is 6 or higher, the trim_timeout is used. Otherwise, if the card's ext_csd.erase_group_def is 1, the High Capacity Erase Group Size uses HC timeouts.",
        "proto": "unsigned int mmc_erase_timeout(struct mmc_card *card, unsigned int arg, unsigned int qty)",
        "pre": {
            "card": "!=null",
            "arg": "in [MMC_DISCARD_ARG, MMC_TRIM_ARG]",
            "qty": ">=0"
        }
    }
},
{
    "kprobe:mmc_erase_timeout": {
        "description": "Determines the erase timeout based on the argument and the card's extended CSD revision and erase group definition.",
        "proto" :"static unsigned int (*mmc_erase_timeout)(struct mmc_card *card, unsigned int arg, unsigned int qty)",
        "pre": {
            "card": "!=null",
            "arg": "in [MMC_DISCARD_ARG, MMC_TRIM_ARG]",
            "qty": ">=0",
            "card->ext_csd.rev": ">=0",
            "card->ext_csd.trim_timeout": ">=0",
            "card->ext_csd.hc_erase_timeout": ">=0",
            "card->ext_csd.erase_group_def": "in [0, 1]"
        },
    }
},
{
    "kretprobe:mmc_can_discard": {
        "description": "As there's no way to detect the discard support bit at v4.5, use the sw feature support field.",
        "proto" :"EXPORT_SYMBOL(mmc_can_discard(struct mmc_card *card){ if (card->ext_csd.feature_support & MMC_DISCARD_FEATURE)return 1;return 0;})",
        "pre": {
            "card": "!=null",
            "card->ext_csd.feature_support": "in [MMC_DISCARD_FEATURE]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:mmc_can_discard": {
        "description": "As there's no way to detect the discard support bit at v4.5, use the sw feature support filed.",
        "proto" :"EXPORT_SYMBOL(mmc_can_discard(struct mmc_card *card){ if (card->ext_csd.feature_support & MMC_DISCARD_FEATURE)return 1;return 0;})",
        "pre": {
            "card": "!=null",
            "card->ext_csd.feature_support": "in [your specific conditions]",
            "MMC_DISCARD_FEATURE": "in [your specific conditions]"
        },
    }
},
{
    "kretprobe:mmc_calc_max_discard": {
        "description": "Without erase_group_def set, MMC erase timeout depends on clock frequence which can change. In that case, the best choice is just the preferred erase size.",
        "proto" :"static long (*mmc_calc_max_discard)(struct mmc_card *card)",
        "pre": {
            "card": "!=null"
        },
    }
},
{
    "kprobe:mmc_calc_max_discard": {
        "description": "Without erase_group_def set, MMC erase timeout depends on clock frequence which can change. In that case, the best choice is just the preferred erase size.",
        "proto" :"mmc_calc_max_discard(struct mmc_card  card)",
        "pre": {
            "card": "!=null",
            "card->host": "!=null",
            "card->ext_csd.erase_group_def": "in [0, 1]",
            "card->pref_erase": ">=0",
            "MMC_ERASE_ARG": ">=0"
        },
    }
},
{
    "kretprobe:mmc_hw_reset": {
        "description": "Hard reset the card. This function is only for upper layers, like the block layer or card drivers. You cannot use it in host drivers (struct mmc_card might be gone then).",
        "proto" :"int (*mmc_hw_reset)(struct mmc_card *card)",
        "pre": {
            "card": "!=null"
        },
        "post": {
            "return": "in [0, -errno]"
        }
    }
},
{
    "kprobe:mmc_hw_reset": {
        "description": "Hard reset the card. This function is only for upper layers, like the block layer or card drivers. You cannot use it in host drivers (struct mmc_card might be gone then).",
        "proto" :"int mmc_hw_reset(struct mmc_card *card)",
        "pre": {
            "card": "!=null"
        },
    }
},
{
    "kretprobe:mmc_detect_card_removed": {
        "description": "Check if the card is removed from the host. If the card is removed or the host is not alive, return 1. Otherwise, reschedule a detect work 200ms later.",
        "proto" :"int mmc_detect_card_removed(struct mmc_host *host)",
        "pre": {
            "host": "!=null",
            "host->card": "!=null",
            "host->bus_ops->alive": "!=null",
            "host->ops->get_cd": "!=null"
        },
        "post": {
            "ret": "in [0, 1]"
        }
    }
},

{
    "kretprobe:mmc_card_alternative_gpt_sector": {
        "description": "Your function description here",
        "proto" :"static long (*mmc_card_alternative_gpt_sector)(struct mmc_card *card, sector_t gpt_sector)",
        "pre": {
            "card": "!=null",
            "gpt_sector": "Your condition here",
            "card->ext_csd.rev": ">=3",
            "mmc_card_mmc(card)": "==true",
            "mmc_card_is_blockaddr(card)": "==true",
            "mmc_card_is_removable(card->host)": "==false",
            "card->host->caps2 & MMC_CAP2_ALT_GPT_TEGRA": "!=0"
        },
    }
},
{
    "kprobe:mmc_card_alternative_gpt_sector": {
        "description": "Your function description here",
        "proto" :"static long (*mmc_card_alternative_gpt_sector)(struct mmc_card *card, sector_t gpt_sector)",
        "pre": {
            "card": "Your condition here",
            "gpt_sector": "Your condition here",
        },
    }
},
{
    "kretprobe:mmc_gpiod_request_cd_irq": {
        "description": "Do not use IRQ if the platform prefers to poll, e.g., because that IRQ number is already used by another unit and cannot be shared.",
        "proto" :"static int (*mmc_gpiod_request_cd_irq)(struct mmc_host *host)",
        "pre": {
            "host": "!=null",
            "host->slot.cd_irq": ">=0",
            "host->slot.handler_priv": "!=null",
            "host->slot.handler_priv->cd_gpio": "!=null"
        },
        "post": {
            "irq": ">=0"
        }
    }
},

{
    "kretprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection. Returns zero on success, else an error.",
        "proto" :"int (*mmc_gpiod_request_ro)(struct mmc_host *host, const char *con_id, unsigned int idx, unsigned int debounce)",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "is a valid index",
            "debounce": "is a valid debounce time in microseconds"
        },
    }
},
{
    "kprobe:mmc_gpiod_request_ro": {
        "description": "Request a gpio descriptor for write protection. Returns zero on success, else an error.",
        "proto" :"int (*mmc_gpiod_request_ro)(struct mmc_host *host, const char *con_id, unsigned int idx, unsigned int debounce)",
        "pre": {
            "host": "!=null",
            "con_id": "!=null",
            "idx": "is a valid index in the GPIO consumer",
            "debounce": "is a non-negative integer representing debounce time in microseconds"
        },
    }
},
{
    "kretprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards. @card: MMC card to run BKOPS for. Run background operations synchronously for cards having manual BKOPS enabled and in case it reports urgent BKOPS level.",
        "proto" :"void (*mmc_run_bkops)(struct mmc_card *card)",
        "pre": {
            "card": "!=null"
        }
    }
},
{
    "kprobe:mmc_run_bkops": {
        "description": "Run BKOPS for supported cards. Run background operations synchronously for cards having manual BKOPS enabled and in case it reports urgent BKOPS level.",
        "proto" :"void (*mmc_run_bkops)(struct mmc_card *card)",
        "pre": {
            "card": "!=null && is a supported card && has manual BKOPS enabled"
        }
    }
},
{
    "kretprobe:mmc_register_driver": {
        "description": "Register a media driver @drv: MMC media driver",
        "proto" :"int (*mmc_register_driver)(struct mmc_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_register_driver": {
        "description": "Register a media driver @drv: MMC media driver",
        "proto" :"int (*mmc_register_driver)(struct mmc_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver",
        "proto": "void (*mmc_unregister_driver)(struct mmc_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mmc_unregister_driver": {
        "description": "Unregister a media driver",
        "proto" :"void (*mmc_unregister_driver)(struct mmc_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning. It is not meant for temporarily preventing retuning!",
        "proto" :"void (*mmc_retune_disable)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_retune_disable": {
        "description": "Exit a transfer mode that requires retuning. It is not meant for temporarily preventing retuning!",
        "proto" :"void (*mmc_retune_disable)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages. Parse the 'voltage-ranges' property, returning zero if it is not found, negative errno if the voltage-range specification is invalid, or one if the voltage-range is specified and successfully parsed.",
        "proto" :"int (*mmc_of_parse_voltage)(struct mmc_host *host, u32 *mask)",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        },
    }
},
{
    "kprobe:mmc_of_parse_voltage": {
        "description": "Return mask of supported voltages. Parse the 'voltage-ranges' property, returning zero if it is not found, negative errno if the voltage-range specification is invalid, or one if the voltage-range is specified and successfully parsed.",
        "proto" :"int (*mmc_of_parse_voltage)(struct mmc_host *host, u32 *mask)",
        "pre": {
            "host": "!=null",
            "mask": "!=null"
        }
    }
},
{
    "kretprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure. @extra: sizeof private data structure @dev: pointer to host device model structure Initialise the per-host structure.",
        "proto" :"struct mmc_host *(*mmc_alloc_host)(int extra, struct device *dev)",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:mmc_alloc_host": {
        "description": "Initialise the per-host structure.",
        "proto": "struct mmc_host *(*mmc_alloc_host)(int extra, struct device *dev)",
        "pre": {
            "extra": ">=0",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mmc_add_host": {
        "description": "Initialise host hardware and register the host with the driver model. The host must be prepared to start servicing requests before this function completes.",
        "proto" :"int mmc_add_host(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_add_host": {
        "description": "Initialise host hardware and register the host with the driver model. The host must be prepared to start servicing requests before this function completes.",
        "proto" :"int mmc_add_host(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:mmc_remove_host": {
        "description": "Unregister and remove all cards associated with this host, and power down the MMC bus. No new requests will be issued after this function has returned.",
        "proto" :"void (*mmc_remove_host)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kprobe:mmc_remove_host": {
        "description": "Unregister and remove all cards associated with this host, and power down the MMC bus. No new requests will be issued after this function has returned.",
        "proto" :"void (*mmc_remove_host)(struct mmc_host *host)",
        "pre": {
            "host": "!=null"
        }
    }
},
{
    "kretprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM. The string is taken from a minimal ASCII text descriptor leaf after the immediate entry with @key. The string is zero-terminated. An overlong string is silently truncated such that it and the zero byte fit into @size. Returns strlen(buf) or a negative error code.",
        "proto" :"int (*fw_csr_string)(const u32 *directory, int key, char *buf, size_t size)",
        "pre": {
            "directory": "!=null",
            "key": "is int",
            "buf": "!=null",
            "size": "is size_t && > 0"
        },
    }
},
{
    "kprobe:fw_csr_string": {
        "description": "Reads a string from the configuration ROM. The string is taken from a minimal ASCII text descriptor leaf after the immediate entry with key. The string is zero-terminated. An overlong string is silently truncated such that it and the zero byte fit into size.",
        "proto" :"int (*fw_csr_string)(const u32 *directory, int key, char *buf, size_t size)",
        "pre": {
            "directory": "!=null",
            "key": "is integer",
            "buf": "!=null",
            "size": "is positive integer"
        },
    }
},
{
    "kretprobe:fw_device_enable_phys_dma": {
        "description": "Enables physical DMA for the specified device. The node_id of the device must not be older than the generation.",
        "proto" :"static long (*fw_device_enable_phys_dma)(struct fw_device *device)",
        "pre": {
            "device": "!=null",
            "device->generation": ">= device->node_id"
        }
    }
},
{
    "kprobe:fw_device_enable_phys_dma": {
        "description": "Enables physical DMA for the specified fw_device. The node_id of the device, accessed below, must not be older than generation.",
        "proto" :"static void (*fw_device_enable_phys_dma)(struct fw_device *device)",
        "pre": {
            "device": "!=null",
            "device->generation": ">= device->node_id"
        }
    }
},
{
    "kretprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued. That will call the packet transmission callback which cancels the transaction.",
        "proto" :"if (card->driver->cancel_packet(card, &transaction->packet) == 0) return 0;",
        "pre": {
            "card": "!=null",
            "transaction": "!=null",
            "transaction->packet": "!=null"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:fw_cancel_transaction": {
        "description": "Cancel the packet transmission if it's still queued. That will call the packet transmission callback which cancels the transaction.",
        "proto" :"if (card->driver->cancel_packet(card, &transaction->packet) == 0) return 0;",
        "pre": {
            "card": "!=null",
            "transaction": "!=null",
            "transaction->packet": "!=null",
            "card->driver->cancel_packet": "!=null"
        },
    }
},
{
    "kretprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep. In case of lock requests, specify one of the firewire-core specific %TCODE_ constants instead of %TCODE_LOCK_REQUEST in @tcode. Make sure that the value in @destination_id is not older than the one in @generation. Otherwise the request is in danger to be sent to a wrong node. In case of asynchronous stream packets i.e. %TCODE_STREAM_DATA, the caller needs to synthesize @destination_id with fw_stream_packet_destination_id(). It will contain tag, channel, and sy data instead of a node ID then. The payload buffer at @data is going to be DMA-mapped except in case of @length <= 8 or of local (loopback) requests. Hence make sure that the buffer complies with the restrictions of the streaming DMA mapping API. @payload must not be freed before the @callback is called. In case of request types without payload, @data is NULL and @length is 0. After the transaction is completed successfully or unsuccessfully, the @callback will be called. Among its parameters is the response code which is either one of the rcodes per IEEE 1394 or, in case of internal errors, the firewire-core specific %RCODE_SEND_ERROR. The other firewire-core specific rcodes (%RCODE_CANCELLED, %RCODE_BUSY, %RCODE_GENERATION, %RCODE_NO_ACK) denote transaction timeout, busy responder, stale request generation, or missing ACK respectively. Note some timing corner cases: fw_send_request() may complete much earlier than when the request packet actually hits the wire. On the other hand, transaction completion and hence execution of @callback may happen even before fw_send_request() returns.",
        "proto" :"void __fw_send_request(struct fw_card *card, struct fw_transaction *t, int tcode,int destination_id, int generation, int speed, unsigned long long offset,void *payload, size_t length, union fw_transaction_callback callback,bool with_tstamp, void *callback_data)",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "in [%TCODE_LOCK_REQUEST, %TCODE_STREAM_DATA, ...]",
            "destination_id": "<= generation",
            "generation": ">= destination_id",
            "speed": ">= 0",
            "offset": ">= 0",
            "payload": "!=null || length == 0",
            "length": ">= 0",
            "callback": "!=null",
            "with_tstamp": "is bool",
            "callback_data": "can be any value"
        }
    }
},
{
    "kprobe:__fw_send_request": {
        "description": "fw_run_transaction() in a context that can sleep. In case of lock requests, specify one of the firewire-core specific %TCODE_ constants instead of %TCODE_LOCK_REQUEST in @tcode. Make sure that the value in @destination_id is not older than the one in @generation. Otherwise the request is in danger to be sent to a wrong node. In case of asynchronous stream packets i.e. %TCODE_STREAM_DATA, the caller needs to synthesize @destination_id with fw_stream_packet_destination_id(). It will contain tag, channel, and sy data instead of a node ID then. The payload buffer at @data is going to be DMA-mapped except in case of @length <= 8 or of local (loopback) requests. Hence make sure that the buffer complies with the restrictions of the streaming DMA mapping API. @payload must not be freed before the @callback is called. In case of request types without payload, @data is NULL and @length is 0. After the transaction is completed successfully or unsuccessfully, the @callback will be called. Among its parameters is the response code which is either one of the rcodes per IEEE 1394 or, in case of internal errors, the firewire-core specific %RCODE_SEND_ERROR. The other firewire-core specific rcodes (%RCODE_CANCELLED, %RCODE_BUSY, %RCODE_GENERATION, %RCODE_NO_ACK) denote transaction timeout, busy responder, stale request generation, or missing ACK respectively. Note some timing corner cases: fw_send_request() may complete much earlier than when the request packet actually hits the wire. On the other hand, transaction completion and hence execution of @callback may happen even before fw_send_request() returns.",
        "proto" :"void (*__fw_send_request)(struct fw_card *card, struct fw_transaction *t, int tcode,int destination_id, int generation, int speed, unsigned long long offset,void *payload, size_t length, union fw_transaction_callback callback,bool with_tstamp, void *callback_data)",
        "pre": {
            "card": "!=null",
            "t": "!=null",
            "tcode": "in [%TCODE_LOCK_REQUEST, %TCODE_STREAM_DATA, ...]",
            "destination_id": ">= generation",
            "generation": ">= 0",
            "speed": ">= 0",
            "offset": ">= 0",
            "payload": "!=null || length == 0",
            "length": ">= 0",
            "callback": "!=null",
            "with_tstamp": "is boolean",
            "callback_data": "can be any value"
        },
    }
},
{
    "kretprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests. When a request is received that falls within the specified address range, the specified callback is invoked. The parameters passed to the callback give the details of the particular request. The start offset of the handler's address region is determined by fw_core_add_address_handler() and is returned in handler->offset. Address allocations are exclusive, except for the FCP registers.",
        "proto" :"int (*fw_core_add_address_handler)(struct fw_address_handler *handler, const struct fw_address_region *region)",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "quadlet-aligned",
            "region->end": "quadlet-aligned",
            "handler->length": "quadlet-aligned"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:fw_core_add_address_handler": {
        "description": "Register for incoming requests. When a request is received that falls within the specified address range, the specified callback is invoked. The parameters passed to the callback give the details of the particular request. The start offset of the handler's address region is determined by fw_core_add_address_handler() and is returned in handler->offset. Address allocations are exclusive, except for the FCP registers.",
        "proto" :"int (*fw_core_add_address_handler)(struct fw_address_handler *handler, const struct fw_address_region *region)",
        "pre": {
            "handler": "!=null",
            "region": "!=null",
            "region->start": "is quadlet-aligned",
            "region->end": "is quadlet-aligned",
            "handler->length": "is quadlet-aligned"
        },
    }
},
{
    "kretprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler. When fw_core_remove_address_handler() returns, @handler->callback() is guaranteed to not run on any CPU anymore.",
        "proto" :"void (*fw_core_remove_address_handler)(struct fw_address_handler *handler)",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kprobe:fw_core_remove_address_handler": {
        "description": "Unregister an address handler. When fw_core_remove_address_handler() returns, @handler->callback() is guaranteed to not run on any CPU anymore.",
        "proto" :"static void (*fw_core_remove_address_handler)(struct fw_address_handler *handler)",
        "pre": {
            "handler": "!=null"
        }
    }
},
{
    "kretprobe:fw_send_response": {
        "description": "Submit a response packet into the asynchronous response transmission queue. The @request is going to be released when the transmission successfully finishes later.",
        "proto" :"void (*fw_send_response)(struct fw_card *card, struct fw_request *request, int rcode)",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "in [R_SUCCESS, R_PENDING, R_FAILURE, R_BUSY, R_CANCELLED]"
        }
    }
},
{
    "kprobe:fw_send_response": {
        "description": "Submit a response packet into the asynchronous response transmission queue. The @request is going to be released when the transmission successfully finishes later.",
        "proto" :"void (*fw_send_response)(struct fw_card *card, struct fw_request *request, int rcode)",
        "pre": {
            "card": "!=null",
            "request": "!=null",
            "rcode": "is an integer"
        },
    }
},
{
    "kretprobe:fw_get_request_speed": {
        "description": "Returns speed at which the @request was received",
        "proto" :"int (*fw_get_request_speed)(struct fw_request *request)",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kprobe:fw_get_request_speed": {
        "description": "Returns speed at which the @request was received",
        "proto" :"int (*fw_get_request_speed)(struct fw_request *request)",
        "pre": {
            "request": "!=null"
        }
    }
},
{
    "kretprobe:fw_core_handle_request": {
        "description": "Your function description here",
        "proto" :"static long (*fw_core_handle_request)(struct fw_card *card, struct fw_packet *p)",
        "pre": {
            "card": "!=null",
            "p": "!=null"
        },
    }
},
{
    "kprobe:fw_core_handle_request": {
        "description": "Handles a request to the firmware card. If the request is not pending or complete, or if it is a link internal, it returns. If the request cannot be allocated, it sends a statically allocated busy packet.",
        "proto" :"void fw_core_handle_request(struct fw_card *card, struct fw_packet *p)",
        "pre": {
            "card": "!=null",
            "p": "!=null",
            "p->ack": "in [ACK_PENDING, ACK_COMPLETE]",
            "HEADER_GET_TCODE(p->header[0])": "!=LINK_INTERNAL"
        },
    }
},


{
    "kretprobe:fw_rcode_string": {
        "description": "Convert a firewire result code to an error description.",
        "proto": "const char *(*fw_rcode_string)(int rcode)",
        "pre": {
            "rcode": "is int"
        }
    }
},
{
    "kprobe:fw_rcode_string": {
        "description": "Convert a firewire result code to an error description",
        "proto" :"const char *(*fw_rcode_string)(int rcode)",
        "pre": {
            "rcode": "is an integer"
        }
    }
},
{
    "kretprobe:fw_core_add_descriptor": {
        "description": "Check descriptor is valid; the length of all blocks in the descriptor has to add up to exactly the length of the block.",
        "proto" :"static int (*fw_core_add_descriptor)(struct fw_descriptor *desc)",
        "pre": {
            "desc": "!=null",
            "desc->length": ">=0",
            "desc->data": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:fw_core_add_descriptor": {
        "description": "Check descriptor is valid; the length of all blocks in the descriptor has to add up to exactly the length of the block.",
        "proto" :"static int (*fw_core_add_descriptor)(struct fw_descriptor *desc)",
        "pre": {
            "desc": "!=null",
            "desc->length": ">=0",
            "desc->data": "!=null",
            "desc->data[i]": ">=0 for all i in [0, desc->length)",
            "sum(desc->data[i] >> 16 + 1 for all i in [0, desc->length))": "== desc->length"
        },
    }
},
{
    "kretprobe:fw_schedule_bus_reset": {
        "description": "We don't try hard to sort out requests of long vs. short resets.",
        "proto" :"void (*fw_schedule_bus_reset)(struct fw_card *card, bool delayed, bool short_reset)",
        "pre": {
            "card": "!=null",
            "delayed": "is bool",
            "short_reset": "is bool"
        },
    }
},
{
    "kprobe:fw_schedule_bus_reset": {
        "description": "We don't try hard to sort out requests of long vs. short resets.",
        "proto" :"fw_schedule_bus_reset(struct fw_card *card, bool delayed, bool short_reset)",
        "pre": {
            "card": "!=null",
            "delayed": "is [true, false]",
            "short_reset": "is [true, false]"
        },
    }
},
{
    "kretprobe:dummy_driver.free_iso_context": {
        "description": "Free the iso context of the card driver.",
        "proto" :"void (*free_iso_context)(struct fw_card *card)",
        "pre": {
            "card": "!=null",
            "card->driver": "!=null",
            "card->driver->free_iso_context": "is function pointer"
        }
    }
},
{
    "kprobe:fw_core_remove_card": {
        "description": "Switch off most of the card driver interface.",
        "proto" :"void fw_core_remove_card(struct fw_card *card)",
        "pre": {
            "card": "!=null"
        },
    }
},
{
    "kretprobe:fw_core_handle_bus_reset": {
        "description": "Handles bus reset. If the selfID buffer is not the immediate successor of the previously processed one, we cannot reliably compare the old and new topologies.",
        "proto" :"void fw_core_handle_bus_reset(struct fw_card *card, int node_id, int generation, int self_id_count, u32 *self_ids, bool bm_abdicate)",
        "pre": {
            "card": "!=null",
            "node_id": ">=0",
            "generation": ">=0",
            "self_id_count": ">=0",
            "self_ids": "!=null",
            "bm_abdicate": "in [true, false]"
        }
    }
},
{
    "kprobe:fw_core_handle_bus_reset": {
        "description": "Handles bus reset. If the selfID buffer is not the immediate successor of the previously processed one, we cannot reliably compare the old and new topologies.",
        "proto" :"void fw_core_handle_bus_reset(struct fw_card *card, int node_id, int generation, int self_id_count, u32 *self_ids, bool bm_abdicate)",
        "pre": {
            "card": "!=null",
            "node_id": ">=0",
            "generation": ">=0",
            "self_id_count": ">=0",
            "self_ids": "!=null",
            "bm_abdicate": "in [true, false]"
        }
    }
},
{
    "kretprobe:fw_iso_resource_manage": {
        "description": "Allocate or deallocate a channel and/or bandwidth. This function blocks (sleeps) during communication with the IRM. Allocates or deallocates at most one channel out of channels_mask. channels_mask is a bitfield with MSB for channel 63 and LSB for channel 0. Allocates or deallocates as many bandwidth allocation units as specified. If generation is stale, deallocations succeed but allocations fail with channel = -EAGAIN. If channel allocation fails, no bandwidth will be allocated either. If bandwidth allocation fails, no channel will be allocated either. But deallocations of channel and bandwidth are tried independently of each other's success.",
        "proto" :"void fw_iso_resource_manage(struct fw_card *card, int generation, u64 channels_mask, int *channel, int *bandwidth, bool allocate)",
        "pre": {
            "card": "!=null",
            "generation": ">=0",
            "channels_mask": "is bitmask",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "is boolean"
        },
        "post": {
            "channel": "<0 if no channel was allocated or deallocated",
            "bandwidth": "=0 if no bandwidth was allocated or deallocated",
            "generation": "if stale, deallocations succeed but allocations fail with channel = -EAGAIN",
            "allocate": "if false, no bandwidth or channel will be allocated"
        }
    }
},
{
    "kprobe:fw_iso_resource_manage": {
        "description": "Allocates or deallocates at most one channel out of channels_mask and as many bandwidth allocation units as specified. If generation is stale, deallocations succeed but allocations fail. If channel allocation fails, no bandwidth will be allocated either. If bandwidth allocation fails, no channel will be allocated either. But deallocations of channel and bandwidth are tried independently of each other's success.",
        "proto" :"void fw_iso_resource_manage(struct fw_card *card, int generation, u64 channels_mask, int *channel, int *bandwidth, bool allocate)",
        "pre": {
            "card": "!=null",
            "generation": "is an integer",
            "channels_mask": "is a 64-bit integer",
            "channel": "!=null",
            "bandwidth": "!=null",
            "allocate": "is a boolean"
        },
        "post": {
            "channel": "< 0 if no channel was allocated or deallocated",
            "bandwidth": "= 0 if no bandwidth was allocated or deallocated",
            "channel": "= -EAGAIN if generation is stale and allocation was attempted"
        }
    }
},
{
    "kretprobe:devfreq_get_freq_range": {
        "description": "Get the current freq range. This takes into consideration all constraints.",
        "proto" :"void devfreq_get_freq_range(struct devfreq *devfreq, unsigned long *min_freq, unsigned long *max_freq)",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_get_freq_range": {
        "description": "Get the current freq range. This takes into consideration all constraints.",
        "proto" :"void devfreq_get_freq_range(struct devfreq *devfreq, unsigned long *min_freq, unsigned long *max_freq)",
        "pre": {
            "devfreq": "!=null",
            "min_freq": "!=null",
            "max_freq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior. @devfreq: the devfreq instance. @freq: the update target frequency.",
        "proto": "int devfreq_update_status(struct devfreq *devfreq, unsigned long freq)",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        }
    }
},
{
    "kprobe:devfreq_update_status": {
        "description": "Update statistics of devfreq behavior. @devfreq: the devfreq instance. @freq: the update target frequency.",
        "proto" :"int (*devfreq_update_status)(struct devfreq *devfreq, unsigned long freq)",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        }
    }
},
{
    "kretprobe:devfreq_update_target": {
        "description": "update_devfreq() and devfreq governors.",
        "proto" :"int (*devfreq_update_target)(struct devfreq *devfreq, unsigned long freq)",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        }
    }
},
{
    "kprobe:devfreq_update_target": {
        "description": "update_devfreq() and devfreq governors.",
        "proto" :"int (*devfreq_update_target)(struct devfreq *devfreq, unsigned long freq)",
        "pre": {
            "devfreq": "!=null",
            "freq": ">=0"
        },
    }
},
{
    "kretprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance. Helper function for starting devfreq device load monitoring. By default delayed work based monitoring is supported. Function to be called from governor in response to DEVFREQ_GOV_START event when device is added to devfreq framework.",
        "proto" :"void devfreq_monitor_start(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_start": {
        "description": "Start load monitoring of devfreq instance. Helper function for starting devfreq device load monitoring. By default delayed work based monitoring is supported. Function to be called from governor in response to DEVFREQ_GOV_START event when device is added to devfreq framework.",
        "proto" :"void devfreq_monitor_start(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance. Helper function to stop devfreq device load monitoring. Function to be called from governor in response to DEVFREQ_GOV_STOP event when device is removed from devfreq framework.",
        "proto" :"void devfreq_monitor_stop(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_stop": {
        "description": "Stop load monitoring of a devfreq instance. Helper function to stop devfreq device load monitoring. Function to be called from governor in response to DEVFREQ_GOV_STOP event when device is removed from devfreq framework.",
        "proto" :"void devfreq_monitor_stop(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance. Function to be called from governor in response to DEVFREQ_GOV_SUSPEND event or when polling interval is set to zero. Note: Though this function is same as devfreq_monitor_stop(), intentionally kept separate to provide hooks for collecting transition statistics.",
        "proto" :"void (*devfreq_monitor_suspend)(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_suspend": {
        "description": "Suspend load monitoring of a devfreq instance. Function to be called from governor in response to DEVFREQ_GOV_SUSPEND event or when polling interval is set to zero. Note: Though this function is same as devfreq_monitor_stop(), intentionally kept separate to provide hooks for collecting transition statistics.",
        "proto" :"void (*devfreq_monitor_suspend)(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance. Function to be called from governor in response to DEVFREQ_GOV_RESUME event or when polling interval is set to non-zero.",
        "proto" :"void devfreq_monitor_resume(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_monitor_resume": {
        "description": "Resume load monitoring of a devfreq instance. Function to be called from governor in response to DEVFREQ_GOV_RESUME event or when polling interval is set to non-zero.",
        "proto" :"void devfreq_monitor_resume(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_update_interval": {
        "description": "Helper function to set new load monitoring polling interval. Function to be called from governor in response to DEVFREQ_GOV_UPDATE_INTERVAL event.",
        "proto" :"void devfreq_update_interval(struct devfreq *devfreq, unsigned int *delay)",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},
{
    "kprobe:devfreq_update_interval": {
        "description": "Helper function to set new load monitoring polling interval. Function to be called from governor in response to DEVFREQ_GOV_UPDATE_INTERVAL event.",
        "proto" :"void devfreq_update_interval(struct devfreq *devfreq, unsigned int *delay)",
        "pre": {
            "devfreq": "!=null",
            "delay": "!=null"
        }
    }
},
{
    "kretprobe:try_then_request_governor": {
        "description": "devfreq_add_device) are built as modules. devfreq_list_lock should be held by the caller. Returns the matched governor's pointer or an error pointer.",
        "proto" :"static struct devfreq_governor *try_then_request_governor(const char *name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kprobe:try_then_request_governor": {
        "description": "Returns the matched governor's pointer or an error pointer. devfreq_list_lock should be held by the caller.",
        "proto" :"static struct devfreq_governor *(*try_then_request_governor)(const char *name)",
        "pre": {
            "name": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device. The opposite of devfreq_add_device().",
        "proto" :"int devfreq_remove_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        },
        "post": {
            "devfreq": "==null"
        }
    }
},
{
    "kprobe:devfreq_remove_device": {
        "description": "Remove devfreq feature from a device. The opposite of devfreq_add_device().",
        "proto" :"int devfreq_remove_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        },
    }
},
{
    "kretprobe:devm_devfreq_add_device": {
        "description": "This function manages automatically the memory of devfreq device using device resource management and simplify the free operation for memory of devfreq device.",
        "proto" :"struct devfreq *(*devm_devfreq_add_device)(struct device *dev, struct devfreq_dev_profile *profile, const char *governor_name, void *data)",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        },
    }
},
{
    "kprobe:devm_devfreq_add_device": {
        "description": "This function manages automatically the memory of devfreq device using device resource management and simplify the free operation for memory of devfreq device.",
        "proto" :"struct devfreq *(*devm_devfreq_add_device)(struct device *dev, struct devfreq_dev_profile *profile, const char *governor_name, void *data)",
        "pre": {
            "dev": "!=null",
            "profile": "!=null",
            "governor_name": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device() @dev:the device from which to remove devfreq feature. @devfreq:the devfreq instance to be removed",
        "proto" :"void (*devm_devfreq_remove_device)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_remove_device": {
        "description": "Resource-managed devfreq_remove_device() @dev:the device from which to remove devfreq feature. @devfreq:the devfreq instance to be removed",
        "proto" :"void (*devm_devfreq_remove_device)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device. This function is intended to be called by the pm callbacks (e.g., runtime_suspend, suspend) of the device driver that holds the devfreq.",
        "proto" :"int devfreq_suspend_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_suspend_device": {
        "description": "Suspend devfreq of a device. This function is intended to be called by the pm callbacks (e.g., runtime_suspend, suspend) of the device driver that holds the devfreq.",
        "proto" :"int devfreq_suspend_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device. This function is intended to be called by the pm callbacks (e.g., runtime_resume, resume) of the device driver that holds the devfreq.",
        "proto" :"int devfreq_resume_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_resume_device": {
        "description": "Resume devfreq of a device. This function is intended to be called by the pm callbacks (e.g., runtime_resume, resume) of the device driver that holds the devfreq.",
        "proto" :"int devfreq_resume_device(struct devfreq *devfreq)",
        "pre": {
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_add_governor": {
        "description": "Add devfreq governor @governor:the devfreq governor to be added",
        "proto" :"int devfreq_add_governor(struct devfreq_governor *governor)",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devfreq_add_governor": {
        "description": "Add devfreq governor @governor:the devfreq governor to be added",
        "proto" :"int (*devfreq_add_governor)(struct devfreq_governor *governor)",
        "pre": {
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor. This is a resource-managed variant of devfreq_add_governor().",
        "proto" :"int devm_devfreq_add_governor(struct device *dev, struct devfreq_governor *governor)",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_add_governor": {
        "description": "Add devfreq governor. This is a resource-managed variant of devfreq_add_governor().",
        "proto" :"int (*devm_devfreq_add_governor)(struct device *dev, struct devfreq_governor *governor)",
        "pre": {
            "dev": "!=null",
            "governor": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback. The callers are required to call dev_pm_opp_put() for the returned OPP after use.",
        "proto" :"struct dev_pm_opp *(*devfreq_recommended_opp)(struct device *dev, unsigned long *freq, u32 flags)",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "in [DEVFREQ_FLAG_FAST_HINT, DEVFREQ_FLAG_SLOW_HINT]"
        }
    }
},
{
    "kprobe:devfreq_recommended_opp": {
        "description": "Helper function to get proper OPP for the freq value given to target callback. The callers are required to call dev_pm_opp_put() for the returned OPP after use.",
        "proto" :"struct dev_pm_opp *(*devfreq_recommended_opp)(struct device *dev, unsigned long *freq, u32 flags)",
        "pre": {
            "dev": "!=null",
            "freq": "!=null",
            "flags": "in [DEVFREQ_FLAG_FAST_HINT, DEVFREQ_FLAG_SLOW_HINT, DEVFREQ_FLAG_LEAST_UPPER_BOUND_FREQ, DEVFREQ_FLAG_UPPER_BOUND_FREQ]"
        },
    }
},
{
    "kretprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes. @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object.",
        "proto" :"int (*devfreq_register_opp_notifier)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_register_opp_notifier": {
        "description": "Helper function to get devfreq notified for any changes in the OPP availability changes. @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object.",
        "proto" :"int (*devfreq_register_opp_notifier)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore. At exit() callback of devfreq_dev_profile, this must be included if devfreq_recommended_opp is used.",
        "proto" :"int devfreq_unregister_opp_notifier(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devfreq_unregister_opp_notifier": {
        "description": "Helper function to stop getting devfreq notified for any changes in the OPP availability changes anymore. At exit() callback of devfreq_dev_profile, this must be included if devfreq_recommended_opp is used.",
        "proto" :"int devfreq_unregister_opp_notifier(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier() @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object.",
        "proto" :"int devm_devfreq_register_opp_notifier(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_register_opp_notifier": {
        "description": "Resource-managed devfreq_register_opp_notifier() @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object.",
        "proto" :"int (*devm_devfreq_register_opp_notifier)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kretprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier() @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object.",
        "proto" :"void (*devm_devfreq_unregister_opp_notifier)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_opp_notifier": {
        "description": "Resource-managed devfreq_unregister_opp_notifier()",
        "proto" :"void (*devm_devfreq_unregister_opp_notifier)(struct device *dev, struct devfreq *devfreq)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null"
        },
    }
},
{
    "kretprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq.",
        "proto": "int devfreq_register_notifier(struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devfreq_register_notifier": {
        "description": "Register a driver with devfreq.",
        "proto": "int devfreq_register_notifier(struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq.",
        "proto" :"int (*devfreq_unregister_notifier)(struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        },
    }
},
{
    "kprobe:devfreq_unregister_notifier": {
        "description": "Unregister a driver with devfreq.",
        "proto" :"int (*devfreq_unregister_notifier)(struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kretprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier() @dev:The devfreq user device. (parent of devfreq) @devfreq:The devfreq object. @nb:The notifier block to be unregistered. @list:DEVFREQ_TRANSITION_NOTIFIER.",
        "proto" :"int devm_devfreq_register_notifier(struct device *dev, struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_register_notifier": {
        "description": "Resource-managed devfreq_register_notifier() @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object. @nb: The notifier block to be unregistered. @list: DEVFREQ_TRANSITION_NOTIFIER.",
        "proto" :"int (*devm_devfreq_register_notifier)(struct device *dev, struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER",
        },
    }
},
{
    "kretprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier() @dev: The devfreq user device. (parent of devfreq) @devfreq: The devfreq object. @nb: The notifier block to be unregistered. @list: DEVFREQ_TRANSITION_NOTIFIER.",
        "proto" :"void devm_devfreq_unregister_notifier(struct device *dev, struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER"
        }
    }
},
{
    "kprobe:devm_devfreq_unregister_notifier": {
        "description": "Resource-managed devfreq_unregister_notifier()",
        "proto" :"void devm_devfreq_unregister_notifier(struct device *dev, struct devfreq *devfreq, struct notifier_block *nb, unsigned int list)",
        "pre": {
            "dev": "!=null",
            "devfreq": "!=null",
            "nb": "!=null",
            "list": "==DEVFREQ_TRANSITION_NOTIFIER",
        },
    }
},
{
    "kretprobe:rio_query_mport": {
        "description": "Returns attributes of specified mport through the pointer to attributes data structure.",
        "proto" :"int rio_query_mport(struct rio_mport *port, struct rio_mport_attr *mport_attr)",
        "pre": {
            "port": "!=null",
            "mport_attr": "!=null"
        }
    }
},
{
    "kprobe:rio_query_mport": {
        "description": "Returns attributes of specified mport through the pointer to attributes data structure.",
        "proto" :"int rio_query_mport(struct rio_mport *port, struct rio_mport_attr *mport_attr)",
        "pre": {
            "port": "!=null",
            "mport_attr": "!=null"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU. All locking between SCU accesses is handled for the caller. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_ioread8)(struct intel_scu_ipc_dev *scu, u16 addr, u8 *data)",
        "pre": {
            "scu": "!=null",
            "addr": "is a valid u16 value",
            "data": "!=null"
        },
        "post": {
            "return": "in [0, error code]"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_ioread8": {
        "description": "Read a byte via the SCU. All locking between SCU accesses is handled for the caller. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_ioread8)(struct intel_scu_ipc_dev *scu, u16 addr, u8 *data)",
        "pre": {
            "scu": "!=null",
            "addr": "is valid address",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU. Write a single register. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_iowrite8)(struct intel_scu_ipc_dev *scu, u16 addr, u8 data)",
        "pre": {
            "scu": "!=null",
            "addr": "is valid SCU register address",
            "data": "is valid byte"
        },
    }
},
{
    "kprobe:intel_scu_ipc_dev_iowrite8": {
        "description": "Write a byte via the SCU. Write a single register. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_iowrite8)(struct intel_scu_ipc_dev *scu, u16 addr, u8 data)",
        "pre": {
            "scu": "!=null",
            "addr": "is valid SCU register address",
            "data": "is valid byte value"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. The largest array length permitted by the hardware is 5 items. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_readv)(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data, size_t len)",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": "in [1, 2, 3, 4, 5]"
        },
    }
},
{
    "kprobe:intel_scu_ipc_dev_readv": {
        "description": "Read a set of registers. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. The largest array length permitted by the hardware is 5 items. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_readv)(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data, size_t len)",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": "in [1, 2, 3, 4, 5]"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. The largest array length permitted by the hardware is 5 items. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_writev)(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data, size_t len)",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": "<=5"
        },
    }
},
{
    "kprobe:intel_scu_ipc_dev_writev": {
        "description": "Write a set of registers. Returns %0 on success or an error code. All locking between SCU accesses is handled for the caller. The largest array length permitted by the hardware is 5 items. This function may sleep.",
        "proto" :"int (*intel_scu_ipc_dev_writev)(struct intel_scu_ipc_dev *scu, u16 *addr, u8 *data, size_t len)",
        "pre": {
            "scu": "!=null",
            "addr": "!=null",
            "data": "!=null",
            "len": "in [0, 1, 2, 3, 4, 5]"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_update": {
        "description": "Read-modify-write power control unit register. The first data argument must be register value and second is mask value mask is a bitmap that indicates which bits to update. %0 = masked. Don't modify this bit, %1 = modify this bit. returns %0 on success or an error code. This function may sleep. Locking between SCU accesses is handled for the caller.",
        "proto" :"int (*intel_scu_ipc_dev_update)(struct intel_scu_ipc_dev *scu, u16 addr, u8 data, u8 mask)",
        "pre": {
            "scu": "!=null",
            "addr": "is a valid register address",
            "data": "is a valid bit to update",
            "mask": "is a valid mask of bits to update"
        },
    }
},
{
    "kprobe:intel_scu_ipc_dev_update": {
        "description": "Update a register. Read-modify-write power control unit register. The first data argument must be register value and second is mask value mask is a bitmap that indicates which bits to update. %0 = masked. Don't modify this bit, %1 = modify this bit. returns %0 on success or an error code. This function may sleep. Locking between SCU accesses is handled for the caller.",
        "proto" :"int (*intel_scu_ipc_dev_update)(struct intel_scu_ipc_dev *scu, u16 addr, u8 data, u8 mask)",
        "pre": {
            "scu": "!=null",
            "addr": "is a valid register address",
            "data": "is a valid bit to update",
            "mask": "is a valid mask of bits to update"
        },
    }
},
{
    "kretprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Issue a simple command to the SCU. Do not use this interface if you must then access data as any data values may be overwritten by another SCU access by the time this function returns. This function may sleep. Locking for SCU accesses is handled for the caller.",
        "proto" :"int (*intel_scu_ipc_dev_simple_command)(struct intel_scu_ipc_dev *scu, int cmd, int sub)",
        "pre": {
            "scu": "!=null",
            "cmd": "is integer",
            "sub": "is integer"
        },
    }
},
{
    "kprobe:intel_scu_ipc_dev_simple_command": {
        "description": "Issue a simple command to the SCU. Do not use this interface if you must then access data as any data values may be overwritten by another SCU access by the time this function returns. This function may sleep. Locking for SCU accesses is handled for the caller.",
        "proto" :"int (*intel_scu_ipc_dev_simple_command)(struct intel_scu_ipc_dev *scu, int cmd, int sub)",
        "pre": {
            "scu": "optional",
            "cmd": "!=null",
            "sub": "!=null"
        }
    }
},
{
    "kretprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Issue a command to the SCU which involves data transfers. Do the data copies under the lock but leave it for the caller to interpret.",
        "proto" :"int (*intel_scu_ipc_dev_command_with_size)(struct intel_scu_ipc_dev *scu, int cmd, int sub, const void *in, size_t inlen, size_t size, void *out, size_t outlen)",
        "pre": {
            "scu": "!=null",
            "cmd": "is int",
            "sub": "is int",
            "in": "!=null",
            "inlen": "is size_t",
            "size": "is size_t",
            "out": "!=null",
            "outlen": "is size_t"
        }
    }
},
{
    "kprobe:intel_scu_ipc_dev_command_with_size": {
        "description": "Issue a command to the SCU which involves data transfers. Do the data copies under the lock but leave it for the caller to interpret.",
        "proto" :"int (*intel_scu_ipc_dev_command_with_size)(struct intel_scu_ipc_dev *scu, int cmd, int sub, const void *in, size_t inlen, size_t size, void *out, size_t outlen)",
        "pre": {
            "scu": "!=null",
            "cmd": "is int",
            "sub": "is int",
            "in": "!=null",
            "inlen": "is size_t",
            "size": "is size_t",
            "out": "!=null",
            "outlen": "is size_t"
        },
    }
},
{
    "kretprobe:wmi_driver_unregister": {
        "description": "Unregisters a WMI driver from the WMI bus.",
        "proto" :"void (*wmi_driver_unregister)(struct wmi_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:wmi_driver_unregister": {
        "description": "Unregister a WMI driver from the WMI bus.",
        "proto" :"void (*wmi_driver_unregister)(struct wmi_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:dcdbas_smi_request": {
        "description": "Generate SMI request. Called with smi_data_lock.",
        "proto" :"int (*dcdbas_smi_request)(struct smi_cmd *smi_cmd)",
        "pre": {
            "smi_cmd": "!=null"
        }
    }
},
{
    "kprobe:dcdbas_smi_request": {
        "description": "Generate SMI request. Called with smi_data_lock.",
        "proto" :"int (*dcdbas_smi_request)(struct smi_cmd *smi_cmd)",
        "pre": {
            "smi_cmd": "!=null"
        }
    }
},
{
    "kretprobe:intel_punit_ipc_simple_command": {
        "description": "Send a IPC command to P-Unit when there is no data transaction. Return:IPC error code or 0 on success.",
        "proto" :"int (*intel_punit_ipc_simple_command)(int cmd, int para1, int para2)",
        "pre": {
            "cmd": "is int",
            "para1": "is int",
            "para2": "is int"
        },
        "post": {
            "return": "in [IPC error codes, 0]"
        }
    }
},
{
    "kprobe:intel_punit_ipc_simple_command": {
        "description": "Send a IPC command to P-Unit when there is no data transaction. Return:IPC error code or 0 on success.",
        "proto" :"int (*intel_punit_ipc_simple_command)(int cmd, int para1, int para2)",
        "pre": {
            "cmd": "is an integer",
            "para1": "is an integer and >= 0",
            "para2": "is an integer and >= 0"
        }
    }
},
{
    "kretprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer. This is used by all ChromeOS EC drivers to prepare the outgoing message according to different protocol versions.",
        "proto" :"int cros_ec_prepare_tx(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:cros_ec_prepare_tx": {
        "description": "Prepare an outgoing message in the output buffer. This is used by all ChromeOS EC drivers to prepare the outgoing message according to different protocol versions.",
        "proto" :"int (*cros_ec_prepare_tx)(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kretprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result. This is used by ChromeOS EC drivers to check the ec_msg->result for EC_RES_IN_PROGRESS and to warn about them. The function should not check for furthermore error codes. Otherwise, it would break the ABI.",
        "proto" :"int (*cros_ec_check_result)(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return": "in [-EAGAIN, 0]"
        }
    }
},
{
    "kprobe:cros_ec_check_result": {
        "description": "Check ec_msg->result. This is used by ChromeOS EC drivers to check the ec_msg->result for EC_RES_IN_PROGRESS and to warn about them. The function should not check for furthermore error codes. Otherwise, it would break the ABI.",
        "proto" :"int (*cros_ec_check_result)(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null",
            "msg->result": "in [EC_RES_IN_PROGRESS, 0]"
        },
    }
},
{
    "kretprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "proto": "int cros_ec_query_all(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:cros_ec_query_all": {
        "description": "Query the protocol version supported by the ChromeOS EC.",
        "proto" :"int (*cros_ec_query_all)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:cros_ec_cmd_xfer": {
        "description": "This function is used to transfer a command to the EC and wait for a response. It returns the number of bytes returned by the EC (excluding the header) if the EC command was executed successfully. If the EC communication was successful but the command execution was not, it returns 0 and the result of the command execution is reported in msg->result. If there was an EC communication error, it returns a negative Linux error code.",
        "proto" :"int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return": {
                "type": "int",
                "conditions": [
                    {
                        "condition": ">0",
                        "description": "EC command was executed successfully. The return value is the number of bytes returned by the EC (excluding the header)."
                    },
                    {
                        "condition": "=0",
                        "description": "EC communication was successful. EC command execution results are reported in msg->result. The result will be EC_RES_SUCCESS if the command was executed successfully or report an EC command execution error."
                    },
                    {
                        "condition": "<0",
                        "description": "EC communication error. Return value is the Linux error code."
                    }
                ]
            }
        }
    }
},
{
    "kprobe:cros_ec_cmd_xfer": {
        "description": "This function is used to transfer a command to the EC and get the response. It returns the number of bytes returned by the EC if the command was executed successfully, 0 if the EC communication was successful but the command execution results are reported in msg->result, and a negative Linux error code if there was an EC communication error.",
        "proto" :"int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev, struct cros_ec_command *msg)",
        "pre": {
            "ec_dev": "!=null",
            "msg": "!=null"
        },
        "post": {
            "return": {
                "type": "int",
                "conditions": [
                    ">0 - EC command was executed successfully. The return value is the number of bytes returned by the EC (excluding the header).",
                    "=0 - EC communication was successful. EC command execution results are reported in msg->result. The result will be EC_RES_SUCCESS if the command was executed successfully or report an EC command execution error.",
                    "<0 - EC communication error. Return value is the Linux error code."
                ]
            }
        }
    }
},
{
    "kretprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC. Return: negative error code on errors; 0 for no data; or else number of bytes received (i.e., an event was retrieved successfully). Event types are written out to @ec_dev->event_data.event_type on success.",
        "proto" :"int cros_ec_get_next_event(struct cros_ec_device *ec_dev, bool *wake_event, bool *has_more_events)",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null || ==null",
            "has_more_events": "!=null || ==null"
        },
        "post": {
            "return": "in [-error code, 0, number of bytes received]"
        }
    }
},
{
    "kprobe:cros_ec_get_next_event": {
        "description": "Fetch next event from the ChromeOS EC. Return: negative error code on errors; 0 for no data; or else number of bytes received (i.e., an event was retrieved successfully). Event types are written out to @ec_dev->event_data.event_type on success.",
        "proto" :"int (*cros_ec_get_next_event)(struct cros_ec_device *ec_dev, bool *wake_event, bool *has_more_events)",
        "pre": {
            "ec_dev": "!=null",
            "wake_event": "!=null || ==null",
            "has_more_events": "!=null || ==null"
        },
    }
},
{
    "kretprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "proto" :"static int cros_ec_get_host_event_wake_mask(struct cros_ec_device *ec_dev, uint32_t *mask)",
        "pre": {
            "ec_dev": "!=null",
            "mask": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL, -ENODEV, -EPROTO, -ETIME, -EBUSY]"
        },
        "notes": {
            "locking": "the caller has ec_dev->lock mutex, or the caller knows there is no other command in progress."
        }
    }
},
{
    "kprobe:cros_ec_get_host_event_wake_mask": {
        "description": "Get the mask of host events that cause wake from suspend.",
        "proto" :"static int (*cros_ec_get_host_event_wake_mask)(struct cros_ec_device *ec_dev, uint32_t *mask)",
        "pre": {
            "ec_dev": "!=null",
            "mask": "!=null"
        },
    }
},
{
    "kretprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler. Device with events to process.",
        "proto" :"irqreturn_t (*cros_ec_irq_thread)(int irq, void *data)",
        "pre": {
            "irq": ">=0",
            "data": "!=null"
        },
    }
},
{
    "kprobe:cros_ec_irq_thread": {
        "description": "Bottom half part of the interrupt handler. Device with events to process.",
        "proto" :"irqreturn_t (*cros_ec_irq_thread)(int irq, void *data)",
        "pre": {
            "irq": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info. Allocate a pointer to a new device and then fill in all the fields up to the --private-- marker.",
        "proto" :"int (*cros_ec_register)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:cros_ec_register": {
        "description": "Register a new ChromeOS EC, using the provided info. Before calling this, allocate a pointer to a new device and then fill in all the fields up to the --private-- marker.",
        "proto" :"int (*cros_ec_register)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kretprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC. Call this to deregister a ChromeOS EC, then clean up any private data.",
        "proto" :"void (*cros_ec_unregister)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:cros_ec_unregister": {
        "description": "Remove a ChromeOS EC. Call this to deregister a ChromeOS EC, then clean up any private data.",
        "proto" :"static long (*cros_ec_unregister)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
    }
},
{
    "kretprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device.",
        "proto": "int (*cros_ec_suspend)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:cros_ec_suspend": {
        "description": "Handle a suspend operation for the ChromeOS EC device. This can be called by drivers to handle a suspend event.",
        "proto" :"int (*cros_ec_suspend)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
    }
},
{
    "kretprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device. This can be called by drivers to handle a resume event.",
        "proto" :"int cros_ec_resume(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:cros_ec_resume": {
        "description": "Handle a resume operation for the ChromeOS EC device. This can be called by drivers to handle a resume event.",
        "proto" :"int (*cros_ec_resume)(struct cros_ec_device *ec_dev)",
        "pre": {
            "ec_dev": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read or write bytes to MEC EMI port. The function returns an 8-bit checksum of all bytes read or written.",
        "proto" :"u8 (*cros_ec_lpc_io_bytes_mec)(enum cros_ec_lpc_mec_io_type io_type, unsigned int offset, unsigned int length, u8 *buf)",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": ">=0",
            "length": ">=0",
            "buf": "!=null",
        },
    }
},
{
    "kprobe:cros_ec_lpc_io_bytes_mec": {
        "description": "Read or write bytes to MEC EMI port. Returns 8-bit checksum of all bytes read or written.",
        "proto" :"u8 (*cros_ec_lpc_io_bytes_mec)(enum cros_ec_lpc_mec_io_type io_type, unsigned int offset, unsigned int length, u8 *buf)",
        "pre": {
            "io_type": "in [MEC_IO_READ, MEC_IO_WRITE]",
            "offset": ">=0",
            "length": ">=0",
            "buf": "!=null",
        },
    }
},


{
    "kretprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "proto" :"time64_t (*rtc_tm_to_time64)(struct rtc_time *tm)",
        "pre": {
            "tm": "!=null"
        }
    }
},
{
    "kprobe:rtc_tm_to_time64": {
        "description": "Converts rtc_time to time64_t. Convert Gregorian date to seconds since 01-01-1970 00:00:00.",
        "proto" :"time64_t (*rtc_tm_to_time64)(struct rtc_time *tm)",
        "pre": {
            "tm": "!=null"
        }
    }
},
{
    "kretprobe:ds1685_rtc_poweroff": {
        "description": "Check for a wake-up interrupt. With Vcc applied, this is essentially a second alarm interrupt, except it takes into account the 'date' register in bank1 in addition to the standard three alarm registers.",
        "proto" :"static long (*ds1685_rtc_poweroff)(__u64 ctrl4b, __u64 ctrl4a)",
        "pre": {
            "ctrl4b": "in [RTC_CTRL_4B_WIE, RTC_CTRL_4B_WIE ^ 1]",
            "ctrl4a": "in [RTC_CTRL_4A_WF, RTC_CTRL_4A_WF ^ 1]"
        },
    }
},

{
    "kretprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "proto" :"int (*omap_rtc_power_off_program)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:omap_rtc_power_off_program": {
        "description": "Set the pmic power off sequence. The RTC generates pmic_pwr_enable control, which can be used to control an external PMIC.",
        "proto" :"int (*omap_rtc_power_off_program)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:voidmptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload. Must be called while new IOs are being queued.",
        "proto" :"void (*voidmptscsih_flush_running_cmds)(MPT_SCSI_HOST *hd)",
        "pre": {
            "hd": "!=null"
        }
    }
},
{
    "kprobe:voidmptscsih_flush_running_cmds": {
        "description": "For each command found, search Scsi_Host instance taskQ and reply to OS. Called only if recovering from a FW reload.",
        "proto" :"void (*voidmptscsih_flush_running_cmds)(MPT_SCSI_HOST *hd)",
        "pre": {
            "hd": "!=null"
        }
    }
},


{
    "kretprobe:mptscsih_raid_id_to_num": {
        "description": "This function is used to map the raid id to the number of physical disks.",
        "proto" :"int mptscsih_raid_id_to_num(MPT_ADAPTER ioc, u8 channel, u8 id)",
        "pre": {
            "ioc": "!=null",
            "channel": "is valid channel",
            "id": "is valid id"
        },
        "post": {
            "return": "in [-ENXIO, valid disk number]"
        }
    }
},
{
    "kprobe:mptscsih_raid_id_to_num": {
        "description": "This function...",
        "proto" :"static long (*mptscsih_raid_id_to_num)(MPT_ADAPTER ioc, u8 channel, u8 id)",
        "pre": {
            "ioc": "!=null",
            "channel": "is valid channel",
            "id": "is valid id",
        },
        "loop": {
            "i": "0 <= i < ioc->raid_data.pIocPg3->NumPhysDisks",
            "condition": "(id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) && (channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)"
        }
    }
},

{
    "kprobe:mptscsih_show_info": {
        "description": "Show information about the SCSI host.",
        "proto" :"static long (*mptscsih_show_info)(struct seq_file *m, struct Scsi_Host *host)",
        "pre": {
            "m": "!=null",
            "host": "!=null"
        },
    }
},
{
    "kretprobe:mptscsih_info_scsiio": {
        "description": "Debug print info on reply frame. MPT_DEBUG_REPLY needs to be enabled to obtain this info. Refer to lsimpi.h.",
        "proto" :"static void mptscsih_info_scsiio(MPT_ADAPTER *ioc, struct scsi_cmnd *sc, SCSIIOReply_t * pScsiReply)",
        "pre": {
            "ioc": "!=null",
            "sc": "!=null",
            "pScsiReply": "!=null"
        }
    }
},
{
    "kprobe:mptscsih_info_scsiio": {
        "description": "debug print info on reply frame. MPT_DEBUG_REPLY needs to be enabled to obtain this info. Refer to lsimpi.h.",
        "proto" :"static void mptscsih_info_scsiio(MPT_ADAPTER *ioc, struct scsi_cmnd *sc, SCSIIOReply_t * pScsiReply)",
        "pre": {
            "ioc": "<insert condition here>",
            "sc": "<insert condition here>",
            "pScsiReply": "<insert condition here>"
        },
    }
},
{
    "kretprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine. Create a MPI SCSIIORequest from a linux scsi_cmnd request and send it to the IOC.",
        "proto" :"int (*intmptscsih_qcmd)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "==0"
        }
    }
},
{
    "kprobe:intmptscsih_qcmd": {
        "description": "Primary Fusion MPT SCSI initiator IO start routine. This is the primary SCSI IO start routine. Create a MPI SCSIIORequest from a linux scsi_cmnd request and send it to the IOC.",
        "proto" :"static int (*intmptscsih_qcmd)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:mptscsih_change_queue_depth": {
        "description": "This function will set a devices queue depth",
        "proto" :"static long (*mptscsih_change_queue_depth)(struct scsi_device *sdev, int qdepth)",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kprobe:mptscsih_slave_destroy": {
        "description": "This function destroys a slave device.",
        "proto" :"mptscsih_slave_destroy(struct scsi_device  sdev)",
        "pre": {
            "sdev": "!=null"
        },
    }
},
{
    "kretprobe:mptscsih_slave_configure": {
        "description": "Add a description here",
        "proto" :"mptscsih_slave_configure(struct scsi_device *sdev)",
        "pre": {
            "sdev": "!=null"
        }
    }
},

{
    "kretprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_abort)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:intmptscsih_abort": {
        "description": "Abort linux scsi_cmnd routine, new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_abort)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_dev_reset)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kprobe:intmptscsih_dev_reset": {
        "description": "Perform a SCSI TARGET_RESET! new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_dev_reset)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_bus_reset)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCESS, FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_bus_reset": {
        "description": "Perform a SCSI BUS_RESET!new_eh variant. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_bus_reset)(struct scsi_cmnd * SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        }
    }
},
{
    "kretprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant). This is a linux scsi_host_template.eh_host_reset_handler routine. Returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_host_reset)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null"
        },
        "post": {
            "return": "in [SUCCESS, FAILED]"
        }
    }
},
{
    "kprobe:intmptscsih_host_reset": {
        "description": "Perform a SCSI host adapter RESET (new_eh variant). This function is a linux scsi_host_template.eh_host_reset_handler routine and returns SUCCESS or FAILED.",
        "proto" :"int (*intmptscsih_host_reset)(struct scsi_cmnd *SCpnt)",
        "pre": {
            "SCpnt": "!=null",
        },
    }
},
{
    "kretprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "proto" :"static long (*mptscsih_bios_param)(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int geom[])",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">= 0x200000",
            "geom": "!=null"
        },
    }
},
{
    "kprobe:mptscsih_bios_param": {
        "description": "Handle extended translation size for logical drives > 1Gb",
        "proto" :"static void (*mptscsih_bios_param)(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int geom[])",
        "pre": {
            "sdev": "!=null",
            "bdev": "!=null",
            "capacity": ">= 0x200000",
            "geom": "!=null"
        },
    }
},
{
    "kretprobe:mptscsih_change_queue_depth": {
        "description": "This function will set a devices queue depth. Adding support for new 'change_queue_depth' api.",
        "proto" :"int (*mptscsih_change_queue_depth)(struct scsi_device *sdev, int qdepth)",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0"
        }
    }
},
{
    "kprobe:intmptscsih_change_queue_depth": {
        "description": "This function will set a devices queue depth. Adding support for new 'change_queue_depth' api.",
        "proto" :"int (*intmptscsih_change_queue_depth)(struct scsi_device *sdev, int qdepth)",
        "pre": {
            "sdev": "!=null",
            "qdepth": ">=0",
        },
    }
},
{
    "kretprobe:mpt_raid_phys_disk_get_num_paths": {
        "description": "Returns number paths associated to this phys_num. @ioc: Pointer to a Adapter Structure. @phys_disk_num: io unit unique phys disk num generated by the ioc. Return: returns number paths.",
        "proto" :"int (*mpt_raid_phys_disk_get_num_paths)(MPT_ADAPTER *ioc, u8 phys_disk_num)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": ">=0"
        },
    }
},
{
    "kprobe:mpt_raid_phys_disk_get_num_paths": {
        "description": "Returns number paths associated to this phys_num",
        "proto" :"int (*mpt_raid_phys_disk_get_num_paths)(MPT_ADAPTER *ioc, u8 phys_disk_num)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": "!=null"
        },
    }
},
{
    "kretprobe:mpt_raid_phys_disk_pg1": {
        "description": "Returns phys disk page 1. @ioc: Pointer to a Adapter Structure. @phys_disk_num: io unit unique phys disk num generated by the ioc. @phys_disk: requested payload data returned. Return: 0 on success. -EFAULT if read of config page header fails or data pointer not NULL. -ENOMEM if pci_alloc failed.",
        "proto" :"int (*mpt_raid_phys_disk_pg1)(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage1_t *phys_disk)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": ">=0",
            "phys_disk": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -ENOMEM]"
        }
    }
},
{
    "kprobe:mpt_raid_phys_disk_pg1": {
        "description": "Returns phys disk page 1. @ioc: Pointer to a Adapter Structure. @phys_disk_num: io unit unique phys disk num generated by the ioc. @phys_disk: requested payload data returned. Return: 0 on success. -EFAULT if read of config page header fails or data pointer not NULL. -ENOMEM if pci_alloc failed.",
        "proto" :"int (*mpt_raid_phys_disk_pg1)(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage1_t *phys_disk)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": ">=0",
            "phys_disk": "==null",
        },
    }
},
{
    "kretprobe:mpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management. Returns 0 for SUCCESS or -1 if FAILED. If -1 is returned, then it was not possible to set the flags.",
        "proto" :"int (*mpt_set_taskmgmt_in_progress_flag)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:mpt_set_taskmgmt_in_progress_flag": {
        "description": "Set flags associated with task management. Returns 0 for SUCCESS or -1 if FAILED. If -1 is returned, then it was not possible to set the flags.",
        "proto" :"int (*mpt_set_taskmgmt_in_progress_flag)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management",
        "proto" :"static void (*mpt_clear_taskmgmt_in_progress_flag)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kprobe:mpt_clear_taskmgmt_in_progress_flag": {
        "description": "Clear flags associated with task management",
        "proto" :"static void (*mpt_clear_taskmgmt_in_progress_flag)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panic the kernel. @ioc: Pointer to MPT_ADAPTER structure",
        "proto" :"void __noreturn (*mpt_halt_firmware)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kprobe:mpt_halt_firmware": {
        "description": "Halts the firmware if it is operational and panic the kernel. @ioc: Pointer to MPT_ADAPTER structure",
        "proto" :"void __noreturn (*mpt_halt_firmware)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kretprobe:mptbase_raid_process_event_data": {
        "description": "Description of the function goes here.",
        "proto" :"static void mptbase_raid_process_event_data(MPT_ADAPTER *ioc, MpiEventDataRaid_t * pRaidEventData)",
        "pre": {
            "ioc": "!=null",
            "pRaidEventData": "!=null"
        }
    }
},

{
    "kretprobe:mpt_attach": {
        "description": "Install a PCI intelligent MPT adapter. This routine performs all the steps necessary to bring the IOC of a MPT adapter to a OPERATIONAL state. This includes registering memory regions, registering the interrupt, and allocating request and reply memory pools. This routine also pre-fetches the LAN MAC address of a Fibre Channel MPT adapter. Returns 0 for success, non-zero for failure.",
        "proto" :"int (*mpt_attach)(struct pci_dev *pdev, const struct pci_device_id *id)",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:intmpt_attach": {
        "description": "Install a PCI intelligent MPT adapter. This routine performs all the steps necessary to bring the IOC of a MPT adapter to a OPERATIONAL state. This includes registering memory regions, registering the interrupt, and allocating request and reply memory pools. This routine also pre-fetches the LAN MAC address of a Fibre Channel MPT adapter. Returns 0 for success, non-zero for failure.",
        "proto" :"int (*intmpt_attach)(struct pci_dev *pdev, const struct pci_device_id *id)",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kretprobe:mpt_detach": {
        "description": "Remove a PCI intelligent MPT adapter.",
        "proto": "void (*mpt_detach)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:voidmpt_detach": {
        "description": "Remove a PCI intelligent MPT adapter.",
        "proto": "void (*voidmpt_detach)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:mpt_resume": {
        "description": "Fusion MPT base driver resume routine.",
        "proto" :"int (*mpt_resume)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:intmpt_resume": {
        "description": "Fusion MPT base driver resume routine.",
        "proto" :"int (*intmpt_resume)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine. @pdev: Pointer to pci_dev structure @state: new state to enter",
        "proto" :"int (*intmpt_suspend)(struct pci_dev *pdev, pm_message_t state)",
        "pre": {
            "pdev": "!=null",
            "state": "is a valid pm_message_t state"
        },
    }
},
{
    "kprobe:intmpt_suspend": {
        "description": "Fusion MPT base driver suspend routine. @pdev: Pointer to pci_dev structure @state: new state to enter",
        "proto" :"int (*intmpt_suspend)(struct pci_dev *pdev, pm_message_t state)",
        "pre": {
            "pdev": "!=null",
            "state": "is of type pm_message_t"
        }
    }
},


{
    "kretprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler. This routine is called by a protocol-specific driver (SCSI host, LAN, SCSI target) to register its reply callback routine. Each protocol-specific driver must do this before it will be able to use any IOC resources, such as obtaining request frames.",
        "proto" :"u8 (*u8mpt_register)(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass, char *func_name)",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in [%MPT_DRIVER_CLASS enum values]",
            "func_name": "!=null"
        },
        "post": {
            "return": "in [N,...,7,6,5,...,1] and != MPT_MAX_PROTOCOL_DRIVERS"
        }
    }
},
{
    "kprobe:u8mpt_register": {
        "description": "Register protocol-specific main callback handler. This routine is called by a protocol-specific driver (SCSI host, LAN, SCSI target) to register its reply callback routine. Each protocol-specific driver must do this before it will be able to use any IOC resources, such as obtaining request frames.",
        "proto" :"u8 (*u8mpt_register)(MPT_CALLBACK cbfunc, MPT_DRIVER_CLASS dclass, char *func_name)",
        "pre": {
            "cbfunc": "!=null",
            "dclass": "in MPT_DRIVER_CLASS enum",
            "func_name": "!=null"
        },
        "post": {
            "return": "in range {N,...,7,6,5,...,1} and != MPT_MAX_PROTOCOL_DRIVERS"
        }
    }
},
{
    "kretprobe:mpt_deregister": {
        "description": "Deregister a protocol drivers resources. Each protocol-specific driver should call this routine when its module is unloaded.",
        "proto" :"void (*mpt_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_deregister": {
        "description": "Deregister a protocol drivers resources. Each protocol-specific driver should call this routine when its module is unloaded.",
        "proto" :"void (*mpt_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": ">=0"
        }
    }
},
{
    "kretprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler. This routine can be called by one or more protocol-specific drivers if/when they choose to be notified of MPT events. Returns 0 for success.",
        "proto" :"int (*intmpt_event_register)(u8 cb_idx, MPT_EVHANDLER ev_cbfunc)",
        "pre": {
            "cb_idx": ">=0",
            "ev_cbfunc": "!=null"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:intmpt_event_register": {
        "description": "Register protocol-specific event callback handler. This routine can be called by one or more protocol-specific drivers if/when they choose to be notified of MPT events. Returns 0 for success.",
        "proto" :"int (*intmpt_event_register)(u8 cb_idx, MPT_EVHANDLER ev_cbfunc)",
        "pre": {
            "cb_idx": ">=0",
            "ev_cbfunc": "!=null",
        }
    }
},
{
    "kretprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler. Each protocol-specific driver should call this routine when it does not (or can no longer) handle events, or when its module is unloaded.",
        "proto" :"static void (*mpt_event_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_event_deregister": {
        "description": "Deregister protocol-specific event callback handler. Each protocol-specific driver should call this routine when it does not (or can no longer) handle events, or when its module is unloaded.",
        "proto" :"void (*mpt_event_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kretprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler. This routine can be called by one or more protocol-specific drivers if/when they choose to be notified of IOC resets. Returns 0 for success.",
        "proto" :"int (*intmpt_reset_register)(u8 cb_idx, MPT_RESETHANDLER reset_func)",
        "pre": {
            "cb_idx": ">=0",
            "reset_func": "!=null"
        }
    }
},
{
    "kprobe:intmpt_reset_register": {
        "description": "Register protocol-specific IOC reset handler. This routine can be called by one or more protocol-specific drivers if/when they choose to be notified of IOC resets. Returns 0 for success.",
        "proto" :"int (*intmpt_reset_register)(u8 cb_idx, MPT_RESETHANDLER reset_func)",
        "pre": {
            "cb_idx": ">=0",
            "reset_func": "!=null"
        }
    }
},
{
    "kretprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler. Each protocol-specific driver should call this routine when it does not (or can no longer) handle IOC reset handling, or when its module is unloaded.",
        "proto" :"static void (*mpt_reset_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": "!=null"
        }
    }
},
{
    "kprobe:mpt_reset_deregister": {
        "description": "Deregister protocol-specific IOC reset handler. Each protocol-specific driver should call this routine when it does not (or can no longer) handle IOC reset handling, or when its module is unloaded.",
        "proto" :"void (*mpt_reset_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": ">=0",
        },
    }
},
{
    "kretprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks @dd_cbfunc: driver callbacks struct @cb_idx: MPT protocol driver index",
        "proto" :"static long (*intmpt_device_driver_register)(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx)",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "is a valid index"
        },
    }
},
{
    "kprobe:intmpt_device_driver_register": {
        "description": "Register device driver hooks @dd_cbfunc: driver callbacks struct @cb_idx: MPT protocol driver index",
        "proto" :"int (*intmpt_device_driver_register)(struct mpt_pci_driver * dd_cbfunc, u8 cb_idx)",
        "pre": {
            "dd_cbfunc": "!=null",
            "cb_idx": "in [0, 255]"
        }
    }
},
{
    "kretprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks @cb_idx: MPT protocol driver index",
        "proto" :"static void (*mpt_device_driver_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": ">=0",
        },
    }
},
{
    "kprobe:mpt_device_driver_deregister": {
        "description": "DeRegister device driver hooks @cb_idx: MPT protocol driver index",
        "proto" :"static void (*mpt_device_driver_deregister)(u8 cb_idx)",
        "pre": {
            "cb_idx": ">=0",
        },
    }
},
{
    "kretprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool (of 1024) that are allocated per MPT adapter. Returns pointer to a MPT request frame or %NULL if none are available or IOC is not active.",
        "proto" :"MPT_FRAME_HDR* (*mpt_get_msg_frame)(u8 cb_idx, MPT_ADAPTER *ioc)",
        "pre": {
            "cb_idx": "in [0, 255]",
            "ioc": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:mpt_get_msg_frame": {
        "description": "Obtain an MPT request frame from the pool (of 1024) that are allocated per MPT adapter. Returns pointer to a MPT request frame or %NULL if none are available or IOC is not active.",
        "proto" :"MPT_FRAME_HDR* (*mpt_get_msg_frame)(u8 cb_idx, MPT_ADAPTER *ioc)",
        "pre": {
            "cb_idx": "in [0, 255]",
            "ioc": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame": {
        "description": "This routine posts an MPT request frame to the request post FIFO of a specific MPT adapter.",
        "proto" :"void (*mpt_put_msg_frame)(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)",
        "pre": {
            "cb_idx": "is a valid handle of registered MPT protocol driver",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame": {
        "description": "This routine posts an MPT request frame to the request post FIFO of a specific MPT adapter.",
        "proto" :"void (*mpt_put_msg_frame)(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)",
        "pre": {
            "cb_idx": ">=0",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kretprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame to an IOC using hi-priority request queue. This routine posts an MPT request frame to the request post FIFO of a specific MPT adapter.",
        "proto" :"void (*mpt_put_msg_frame_hi_pri)(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)",
        "pre": {
            "cb_idx": ">=0",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},
{
    "kprobe:mpt_put_msg_frame_hi_pri": {
        "description": "Send a hi-pri protocol-specific MPT request frame to an IOC using hi-priority request queue. This routine posts an MPT request frame to the request post FIFO of a specific MPT adapter.",
        "proto" :"void (*mpt_put_msg_frame_hi_pri)(u8 cb_idx, MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf)",
        "pre": {
            "cb_idx": "is a valid handle of registered MPT protocol driver",
            "ioc": "!=null",
            "mf": "!=null"
        }
    }
},


{
    "kretprobe:mpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method. This routine is used exclusively to send MptScsiTaskMgmt requests since they are required to be sent via doorbell handshake. NOTE: It is the callers responsibility to byte-swap fields in the request which are greater than 1 byte in size. Returns 0 for success, non-zero for failure.",
        "proto" :"int (*mpt_send_handshake_request)(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)",
        "pre": {
            "cb_idx": ">=0",
            "ioc": "!=null",
            "reqBytes": ">0",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, udelay]"
        },
    }
},
{
    "kprobe:mpt_send_handshake_request": {
        "description": "Send MPT request via doorbell handshake method. This routine is used exclusively to send MptScsiTaskMgmt requests since they are required to be sent via doorbell handshake. NOTE: It is the callers responsibility to byte-swap fields in the request which are greater than 1 byte in size. Returns 0 for success, non-zero for failure.",
        "proto" :"int (*mpt_send_handshake_request)(u8 cb_idx, MPT_ADAPTER *ioc, int reqBytes, u32 *req, int sleepFlag)",
        "pre": {
            "cb_idx": ">=0",
            "ioc": "!=null",
            "reqBytes": ">0",
            "req": "!=null",
            "sleepFlag": "in [CAN_SLEEP, udelay]"
        }
    }
},
{
    "kretprobe:mpt_verify_adapter": {
        "description": "Given a unique IOC identifier, set pointer to the associated MPT adapter structure. Returns iocid and sets iocpp if iocid is found. Returns -1 if iocid is not found.",
        "proto" :"int (*mpt_verify_adapter)(int iocid, MPT_ADAPTER **iocpp)",
        "pre": {
            "iocid": ">=0",
            "iocpp": "!=null"
        },
        "post": {
            "return": "in [-1, iocid]"
        }
    }
},
{
    "kprobe:mpt_verify_adapter": {
        "description": "Given a unique IOC identifier, set pointer to the associated MPT adapter structure. Returns iocid and sets iocpp if iocid is found. Returns -1 if iocid is not found.",
        "proto" :"int (*mpt_verify_adapter)(int iocid, MPT_ADAPTER **iocpp)",
        "pre": {
            "iocid": "is an integer",
            "iocpp": "is a pointer to a pointer to MPT_ADAPTER"
        },
        "post": {
            "return": "in [-1, iocid]",
            "iocpp": "!=null if return == iocid"
        }
    }
},






{
    "kretprobe:mpt_remove_dead_ioc_func": {
        "description": "kthread context to remove dead ioc. Return 0 if controller is removed from pci subsystem. Return -1 for other case.",
        "proto" :"static int mpt_remove_dead_ioc_func(void *arg)",
        "pre": {
            "arg": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:mpt_remove_dead_ioc_func": {
        "description": "kthread context to remove dead ioc. Return 0 if controller is removed from pci subsystem. Return -1 for other case.",
        "proto" :"static int (*mpt_remove_dead_ioc_func)(void *arg)",
        "pre": {
            "arg": "!=null"
        },
    }
},
{
    "kretprobe:mpt_findImVolumes": {
        "description": "Check, and possibly reset, the coalescing value",
        "proto" :"static long (*mpt_findImVolumes)(void *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},
{
    "kprobe:mpt_findImVolumes": {
        "description": "Check, and possibly reset, the coalescing value",
        "proto" :"static long (*mpt_findImVolumes)(void *ioc)",
        "pre": {
            "ioc": "!=null",
        },
    }
},
{
    "kretprobe:mpt_alloc_fw_memory": {
        "description": "Allocate firmware memory. If memory has already been allocated, the same (cached) value is returned.",
        "proto" :"int (*mpt_alloc_fw_memory)(MPT_ADAPTER *ioc, int size)",
        "pre": {
            "ioc": "!=null",
            "size": ">0"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:intmpt_alloc_fw_memory": {
        "description": "Allocate firmware memory. If memory has already been allocated, the same (cached) value is returned. Return 0 if successful, or non-zero for failure.",
        "proto" :"int (*intmpt_alloc_fw_memory)(MPT_ADAPTER *ioc, int size)",
        "pre": {
            "ioc": "!=null",
            "size": ">0",
        },
    }
},
{
    "kretprobe:mpt_adapter_dispose": {
        "description": "Free all resources associated with an MPT adapter",
        "proto" :"void (*mpt_adapter_dispose)(MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "your_condition_here"
        }
    }
},
{
    "kprobe:mpt_adapter_dispose": {
        "description": "Free all resources associated with an MPT adapter",
        "proto" :"void (*mpt_adapter_dispose)(struct MPT_ADAPTER *ioc)",
        "pre": {
            "ioc": "!=null"
        }
    }
},


{
    "kretprobe:mpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero. @ioc: Pointer to a Adapter Structure. @phys_disk_num: io unit unique phys disk num generated by the ioc. @phys_disk: requested payload data returned.",
        "proto" :"int (*mpt_raid_phys_disk_pg0)(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage0_t *phys_disk)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": ">=0",
            "phys_disk": "!=null"
        },
        "post": {
            "return": "in [0, -EFAULT, -ENOMEM]"
        }
    }
},
{
    "kprobe:mpt_raid_phys_disk_pg0": {
        "description": "Returns phys disk page zero. If the read of config page header fails or data pointer is not NULL, it returns -EFAULT. If pci_alloc failed, it returns -ENOMEM.",
        "proto" :"int (*mpt_raid_phys_disk_pg0)(MPT_ADAPTER *ioc, u8 phys_disk_num, RaidPhysDiskPage0_t *phys_disk)",
        "pre": {
            "ioc": "!=null",
            "phys_disk_num": ">=0",
            "phys_disk": "!=null"
        },
    }
},
{
    "kretprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver. Any devices matching the id table will automatically be populated and handed off to the driver's specified probe routine.",
        "proto" :"int (*superhyway_register_driver)(struct superhyway_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:superhyway_register_driver": {
        "description": "Register a new SuperHyway driver. Any devices matching the id table will automatically be populated and handed off to the driver's specified probe routine.",
        "proto" :"int superhyway_register_driver(struct superhyway_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_add_device": {
        "description": "This is responsible for adding a new SuperHyway module. This sets up a new struct superhyway_device for the module being added if @sdev == NULL. Devices are initially added in the order that they are scanned (from the top-down of the memory map), and are assigned an ID based on the order that they are added. Any manual addition of a module will thus get the ID after the devices already discovered regardless of where it resides in memory. Further work can and should be done in superhyway_scan_bus(), to be sure that any new modules are properly discovered and subsequently registered.",
        "proto" :"int (*superhyway_add_device)(unsigned long base, struct superhyway_device *sdev, struct superhyway_bus *bus)",
        "pre": {
            "base": "is a valid physical address",
            "sdev": "can be null or a valid pointer to a struct superhyway_device",
            "bus": "is a valid pointer to a struct superhyway_bus"
        }
    }
},
{
    "kprobe:superhyway_add_device": {
        "description": "This is responsible for adding a new SuperHyway module. This sets up a new struct superhyway_device for the module being added if @sdev == NULL. Devices are initially added in the order that they are scanned (from the top-down of the memory map), and are assigned an ID based on the order that they are added. Any manual addition of a module will thus get the ID after the devices already discovered regardless of where it resides in memory. Further work can and should be done in superhyway_scan_bus(), to be sure that any new modules are properly discovered and subsequently registered.",
        "proto" :"int superhyway_add_device(unsigned long base, struct superhyway_device *sdev,  struct superhyway_bus *bus)",
        "pre": {
            "base": ">=0",
            "sdev": "!=null || ==null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver. This cleans up after superhyway_register_driver(), and should be invoked in the exit path of any module drivers.",
        "proto" :"void (*superhyway_unregister_driver)(struct superhyway_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:superhyway_unregister_driver": {
        "description": "Unregister a SuperHyway driver. This cleans up after superhyway_register_driver(), and should be invoked in the exit path of any module drivers.",
        "proto" :"void (*superhyway_unregister_driver)(struct superhyway_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes. Returns 0 on success non-zero value on failure.",
        "proto" :"int (*tc_dwc_g210_config_40_bit)(struct ufs_hba *hba)",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_40_bit": {
        "description": "This function configures Local (host) Synopsys 40-bit TC specific attributes. Returns 0 on success non-zero value on failure.",
        "proto" :"int (*tc_dwc_g210_config_40_bit)(struct ufs_hba *hba)",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kretprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes.",
        "proto" :"int (*tc_dwc_g210_config_20_bit)(struct ufs_hba *hba)",
        "pre": {
            "hba": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:tc_dwc_g210_config_20_bit": {
        "description": "This function configures Local (host) Synopsys 20-bit TC specific attributes. Returns 0 on success non-zero value on failure.",
        "proto" :"int (*tc_dwc_g210_config_20_bit)(struct ufs_hba *hba)",
        "pre": {
            "hba": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence. Returns 0 on success, non-zero value on failure.",
        "proto" :"int (*ufshcd_dwc_link_startup_notify)(struct ufs_hba *hba, enum ufs_notify_change_status status)",
        "pre": {
            "hba": "!=null",
            "status": "in [UFS_NOTIFY_CHANGE_STATUS_SUCCESS, UFS_NOTIFY_CHANGE_STATUS_FAILURE]"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:ufshcd_dwc_link_startup_notify": {
        "description": "UFS Host DWC specific link startup sequence",
        "proto" :"int (*ufshcd_dwc_link_startup_notify)(struct ufs_hba *hba, enum ufs_notify_change_status status)",
        "pre": {
            "hba": "!=null",
            "status": "!=null"
        },
    }
},
{
    "kretprobe:ufshcd_get_local_unipro_ver": {
        "description": "HCI version 1.0 and 1.1 supports UniPro 1.41",
        "proto" :"EXPORT_SYMBOL(ufshcd_get_local_unipro_ver(struct ufs_hba *hba))",
        "pre": {
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "return": "in [UFS_UNIPRO_VER_1_41, UFS_UNIPRO_VER_1_6]"
        }
    }
},
{
    "kprobe:ufshcd_get_local_unipro_ver": {
        "description": "HCI version 1.0 and 1.1 supports UniPro 1.41",
        "proto" :"static long (*ufshcd_get_local_unipro_ver)(struct ufs_hba *hba)",
        "pre": {
            "hba->ufs_version": "<= ufshci_version(1, 1)"
        },
        "post": {
            "if hba->ufs_version <= ufshci_version(1, 1)": "return UFS_UNIPRO_VER_1_41",
            "else": "return UFS_UNIPRO_VER_1_6"
        }
    }
},
{
    "kretprobe:ufshcd_system_suspend": {
        "description": "System suspend callback. Executed before putting the system into a sleep state in which the contents of main memory are preserved.",
        "proto" :"int (*ufshcd_system_suspend)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:ufshcd_system_suspend": {
        "description": "System suspend callback. Executed before putting the system into a sleep state in which the contents of main memory are preserved.",
        "proto" :"int (*ufshcd_system_suspend)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:ufshcd_system_resume": {
        "description": "System resume callback. Executed after waking the system up from a sleep state in which the contents of main memory were preserved.",
        "proto" :"int (*ufshcd_system_resume)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kprobe:ufshcd_system_resume": {
        "description": "System resume callback. Executed after waking the system up from a sleep state in which the contents of main memory were preserved.",
        "proto" :"int (*ufshcd_system_resume)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, non-zero]"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_suspend": {
        "description": "Runtime suspend callback. Check the description of ufshcd_suspend() function for more details. Returns 0 for success and non-zero for failure.",
        "proto" :"int (*ufshcd_runtime_suspend)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ufshcd_runtime_suspend": {
        "description": "Runtime suspend callback. Check the description of ufshcd_suspend() function for more details. Returns 0 for success and non-zero for failure.",
        "proto" :"int (*ufshcd_runtime_suspend)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_runtime_resume": {
        "description": "This function basically brings controller to active state. Following operations are done in this function: 1. Turn on all the controller related clocks 2. Turn ON VCC rail",
        "proto" :"int (*ufshcd_runtime_resume)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:ufshcd_runtime_resume": {
        "description": "This function basically brings controller to active state. Following operations are done in this function: 1. Turn on all the controller related clocks 2. Turn ON VCC rail",
        "proto" :"int (*ufshcd_runtime_resume)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ufshcd_alloc_host": {
        "description": "Allocates and initializes the UFS host controller.",
        "proto" :"static int (*ufshcd_alloc_host)(struct ufs_hba *hba, struct device *dev)",
        "pre": {
            "hba": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kprobe:ufshcd_alloc_host": {
        "description": "Description of the function goes here.",
        "proto" :"static long (*ufshcd_alloc_host)(struct ufs_hba *hba, struct clk_info *clki)",
        "pre": {
            "hba": "!=null",
            "clki": {
                "name": "=='ref_clk'",
                "clk": "!=null",
                "max_freq": ">=0"
            }
        },
    }
},



{
    "kprobe:v4l2_async_nf_register": {
        "description": "Registers a v4l2_async_notifier and initializes the list heads for waiting and done. Locks the list, validates the sub-devices, and attempts to complete the notifier.",
        "proto" :"v4l2_async_nf_register(struct v4l2_async_notifier  notifier)",
        "pre": {
            "notifier": "!=null",
        },
    }
},
{
    "kretprobe:v4l2_async_register_subdev": {
        "description": "No reference taken. The reference is held by the device (struct v4l2_subdev.dev), and async sub-device does not exist independently of the device at any point of time.",
        "proto" :"int v4l2_async_register_subdev(struct v4l2_subdev *sd)",
        "pre": {
            "sd": "!=null"
        }
    }
},
{
    "kprobe:v4l2_async_register_subdev": {
        "description": "No reference taken. The reference is held by the device (struct v4l2_subdev.dev), and async sub-device does not exist independently of the device at any point of time.",
        "proto" :"static long (*v4l2_async_register_subdev)(struct v4l2_subdev *sd)",
        "pre": {
            "sd": "!=null",
            "sd->fwnode": "==null",
            "sd->dev": "!=null"
        },
    }
},
{
    "kretprobe:v4l2_norm_to_name": {
        "description": "This function is used to handle 64 bit comparisons. It is a workaround for the ppc32 architecture, which doesn't have the __ucmpdi2 function. The function iterates over the 'standards' array until it finds a match with 'myid'. It then returns the 'descr' property of the matching standard.",
        "proto" :"static char *(*v4l2_norm_to_name)(v4l2_std_id id, u32 myid, int i, standard[] standards)",
        "pre": {
            "id": "is a valid v4l2_std_id",
            "myid": "is a valid u32 and equals to id",
            "i": "is a valid integer",
            "standards": "is a valid array of standard objects"
        },
    }
},
{
    "kprobe:v4l2_norm_to_name": {
        "description": "This function does...",
        "proto" :"static long (*v4l2_norm_to_name)(v4l2_std_id id, int i)",
        "pre": {
            "id": "!=null",
            "i": ">=0",
        },
    }
},
{
    "kretprobe:v4l2_m2m_schedule_next_job": {
        "description": "v4l2_m2m_buf_done_and_job_finish()",
        "proto" :"static void v4l2_m2m_schedule_next_job(struct v4l2_m2m_dev *m2m_dev, struct v4l2_m2m_ctx *m2m_ctx)",
        "pre": {
            "m2m_dev": "!=null",
            "m2m_ctx": "!=null"
        }
    }
},
{
    "kprobe:v4l2_m2m_schedule_next_job": {
        "description": "v4l2_m2m_buf_done_and_job_finish()",
        "proto" :"static void v4l2_m2m_schedule_next_job(struct v4l2_m2m_dev *m2m_dev, struct v4l2_m2m_ctx *m2m_ctx)",
        "pre": {
            "m2m_dev": "your_condition_here",
            "m2m_ctx": "your_condition_here"
        },
    }
},
{
    "kretprobe:video_device_release_empty": {
        "description": "Do nothing",
        "proto" :"static void (*video_device_release_empty)(struct video_device *vdev)",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:video_device_release_empty": {
        "description": "Do nothing",
        "proto" :"video_device_release_empty(struct video_device vdev)",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "__video_register_device": {
        "description": "A minor value of -1 marks this video device as never having been registered",
        "proto" :"int __video_register_device(struct video_device *vdev, enum vfl_devnode_type type, int nr, int warn_if_nr_in_use, struct module *owner)",
        "pre": {
            "vdev": "!=null",
            "type": "in [enum vfl_devnode_type]",
            "nr": "is integer",
            "warn_if_nr_in_use": "is integer",
            "owner": "!=null"
        },
    }
},
{
    "__video_register_device": {
        "description": "A minor value of -1 marks this video device as never having been registered",
        "proto" :"int __video_register_device(struct video_device *vdev, enum vfl_devnode_type type, int nr, int warn_if_nr_in_use, struct module *owner)",
        "pre": {
            "vdev": "!=null",
            "type": "in [enum vfl_devnode_type]",
            "nr": "is integer",
            "warn_if_nr_in_use": "is integer",
            "owner": "!=null"
        },
    }
},
{
    "kretprobe:video_unregister_device": {
        "description": "Unregister a video4linux device. Future open calls will be met with errors.",
        "proto" :"void (*video_unregister_device)(struct video_device *vdev)",
        "pre": {
            "vdev": "!=null"
        }
    }
},
{
    "kprobe:video_unregister_device": {
        "description": "Unregister a video4linux device. Future open calls will be met with errors.",
        "proto" :"void (*video_unregister_device)(struct video_device *vdev)",
        "pre": {
            "vdev": "!=null"
        }
    }
},


{
    "kretprobe:v4l2_ctrl_type_op_equal": {
        "description": "Compares two v4l2_ctrl_ptr based on the type of v4l2_ctrl. Returns false if they are not equal.",
        "proto" :"bool (*v4l2_ctrl_type_op_equal)(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr ptr1, union v4l2_ctrl_ptr ptr2)",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null"
        },
    }
},
{
    "kprobe:v4l2_ctrl_type_op_equal": {
        "description": "Compares two v4l2_ctrl_ptr based on the type of v4l2_ctrl. Returns false for V4L2_CTRL_TYPE_BUTTON, compares strings for V4L2_CTRL_TYPE_STRING, and uses memcmp for other types.",
        "proto" :"static bool (*v4l2_ctrl_type_op_equal)(const struct v4l2_ctrl *ctrl, union v4l2_ctrl_ptr ptr1, union v4l2_ctrl_ptr ptr2)",
        "pre": {
            "ctrl": "!=null",
            "ptr1": "!=null",
            "ptr2": "!=null"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_handler_free": {
        "description": "Free all nodes in the v4l2_ctrl_handler",
        "proto" :"void v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl)",
        "pre": {
            "hdl": "!=null",
            "hdl->buckets": "!=null"
        },
        "post": {
            "hdl": "==null",
            "hdl->buckets": "==null"
        }
    }
},
{
    "kprobe:list_for_each_entry_safe": {
        "description": "Iterates over a list of given type safely",
        "proto" :"#define list_for_each_entry_safe(pos, n, head, member)",
        "pre": {
            "pos": "!=null",
            "n": "!=null",
            "head": "!=null",
            "member": "is valid member of struct"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_new_std": {
        "description": "Add immediately at the end of the list if the list is empty, or if the last element in the list has a lower ID. This ensures that when elements are added in ascending order the insertion is an O(1) operation.",
        "proto" :"if (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev))",
        "pre": {
            "hdl->ctrl_refs": "!=null",
            "id": ">=0",
            "node2id(hdl->ctrl_refs.prev)": ">=0"
        },
    }
},
{
    "kprobe:v4l2_ctrl_new_std": {
        "description": "Add immediately at the end of the list if the list is empty, or if the last element in the list has a lower ID. This ensures that when elements are added in ascending order the insertion is an O(1) operation.",
        "proto" :"if (list_empty(&hdl->ctrl_refs) || id > node2id(hdl->ctrl_refs.prev))",
        "pre": {
            "hdl": "!=null",
            "id": "is integer",
            "node2id(hdl->ctrl_refs.prev)": "is integer",
        },
    }
},
{
    "kretprobe:v4l2_ctrl_new_std_menu_items": {
        "description": "Should only be called for standard controls without a standard menu.",
        "proto" :"struct v4l2_ctrl* (*v4l2_ctrl_new_std_menu_items)(struct v4l2_ctrl_handler* hdl, const struct v4l2_ctrl_ops* ops, u32 id, u8 _max, u64 mask, u8 _def, const char* const* qmenu)",
        "pre": {
            "hdl": "!=null",
            "ops": "!=null",
            "id": "is valid control id",
            "_max": "is valid maximum value",
            "mask": "is valid mask",
            "_def": "is valid default value",
            "qmenu": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_get_menu": {
        "description": "Get the menu associated with the given id.",
        "proto" :"static struct v4l2_ctrl_menu* (*v4l2_ctrl_get_menu)(u32 id)",
        "pre": {
            "id": ">=0"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_add_handler": {
        "description": "Do nothing if either handler is NULL or if they are the same",
        "proto" :"int (*v4l2_ctrl_add_handler)(struct v4l2_ctrl_handler *hdl, struct v4l2_ctrl_handler *add, bool (*filter)(const struct v4l2_ctrl *ctrl), bool from_other_dev)",
        "pre": {
            "hdl": "!=null && !=add",
            "add": "!=null && !=hdl",
            "filter": "!=null",
            "from_other_dev": "is boolean"
        },
        "post": {
            "return": "in [0, hdl->error]"
        }
    }
},
{
    "kprobe:v4l2_ctrl_add_handler": {
        "description": "Do nothing if either handler is NULL or if they are the same.",
        "proto" :"int v4l2_ctrl_add_handler(struct v4l2_ctrl_handler *hdl, struct v4l2_ctrl_handler *add, bool (*filter)(const struct v4l2_ctrl *ctrl), bool from_other_dev)",
        "pre": {
            "hdl": "!=null && !=add",
            "add": "!=null && !=hdl",
            "filter": "!=null",
            "from_other_dev": "is boolean"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_cluster": {
        "description": "The first control is the master control and it must not be NULL",
        "proto" :"void v4l2_ctrl_cluster(unsigned ncontrols, struct v4l2_ctrl *controls)",
        "pre": {
            "ncontrols": "> 0",
            "controls": "!=null",
            "controls[0]": "!=null"
        }
    }
},

{
    "kretprobe:v4l2_ctrl_activate": {
        "description": "Invert since the actual flag is called 'inactive'",
        "proto" :"bool inactive = !active; bool old; if (ctrl == NULL) return; if (inactive) /* set V4L2_CTRL_FLAG_INACTIVE `",
        "pre": {
            "ctrl": "!=null",
            "active": "is bool",
        },
    }
},
{
    "kprobe:v4l2_ctrl_activate": {
        "description": "Invert since the actual flag is called 'inactive'",
        "proto" :"void v4l2_ctrl_activate(struct v4l2_ctrl *ctrl, bool active)",
        "pre": {
            "ctrl": "!=null",
            "active": "in [true, false]"
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_grab": {
        "description": "Set or clear the V4L2_CTRL_FLAG_GRABBED flag of the v4l2_ctrl structure.",
        "proto" :"static bool (*__v4l2_ctrl_grab)(struct v4l2_ctrl *ctrl, bool grabbed)",
        "pre": {
            "ctrl": "!=null",
            "grabbed": "in [true, false]"
        },
        "post": {
            "old": "in [true, false]"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_grab": {
        "description": "Set or clear the V4L2_CTRL_FLAG_GRABBED flag for a v4l2_ctrl object.",
        "proto" :"static bool (*__v4l2_ctrl_grab)(struct v4l2_ctrl *ctrl, bool grabbed)",
        "pre": {
            "ctrl": "!=null",
            "grabbed": "in [true, false]"
        },
    }
},


{
    "kretprobe:v4l2_g_ext_ctrls_common": {
        "description": "v4l2_g_ext_ctrls_common() with 'which' set to V4L2_CTRL_WHICH_REQUEST_VAL is only called if the request was completed, and in that case p_req_valid is true for all controls.",
        "proto" :"int v4l2_g_ext_ctrls_common(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs, struct video_device *vdev)",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "in [V4L2_CTRL_WHICH_REQUEST_VAL]",
            "p_req_valid": "==true"
        },
    }
},
{
    "kprobe:v4l2_g_ext_ctrls_common": {
        "description": "v4l2_g_ext_ctrls_common() with 'which' set to V4L2_CTRL_WHICH_REQUEST_VAL is only called if the request was completed, and in that case p_req_valid is true for all controls.",
        "proto" :"int v4l2_g_ext_ctrls_common(struct v4l2_ctrl_handler *hdl, struct v4l2_ext_controls *cs, struct video_device *vdev)",
        "pre": {
            "hdl": "!=null",
            "cs": "!=null",
            "vdev": "!=null",
            "which": "==V4L2_CTRL_WHICH_REQUEST_VAL",
            "p_req_valid": "==true"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_g_ctrl": {
        "description": "It's a driver bug if this happens.",
        "proto" :"static long (*v4l2_ctrl_g_ctrl)(struct v4l2_ctrl *ctrl)",
        "pre": {
            "ctrl": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_g_ctrl": {
        "description": "It's a driver bug if this happens.",
        "proto" :"v4l2_ctrl_g_ctrl(struct v4l2_ctrl *ctrl)",
        "pre": {
            "ctrl": "!=null"
        },
    }
},

{
    "kprobe:v4l2_ctrl_g_ctrl_int64": {
        "description": "Get the 64-bit integer control value. It's a driver bug if this happens.",
        "proto": "static long (*v4l2_ctrl_g_ctrl_int64)(struct v4l2_ctrl *ctrl)",
        "pre": {
            "ctrl": {
                "is_ptr": "==false",
                "type": "==V4L2_CTRL_TYPE_INTEGER64"
            }
        },
        "post": {
            "c": {
                "value64": "==0"
            }
        }
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl": {
        "description": "It's a driver bug if this happens.",
        "proto" :"__v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)",
        "pre": {
            "ctrl": "!=null",
            "val": "is_int"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "__v4l2_ctrl_s_ctrl": {
        "description": "Lockdep_assert_held(ctrl->handler->lock); It's a driver bug if this happens.",
        "proto" :"__v4l2_ctrl_s_ctrl(struct v4l2_ctrl *ctrl, s32 val)",
        "pre": {
            "ctrl": "!=null",
            "val": "is_int"
        },
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "It's a driver bug if this happens. The function sets the value of a control.",
        "proto" :"static long (*__v4l2_ctrl_s_ctrl_int64)(struct v4l2_ctrl *ctrl, s64 val)",
        "pre": {
            "ctrl": "!=null",
            "ctrl->is_ptr": "==false",
            "ctrl->type": "==V4L2_CTRL_TYPE_INTEGER64",
            "val": "is s64"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:__v4l2_ctrl_s_ctrl_int64": {
        "description": "This function sets the value of a 64-bit integer control. It's a driver bug if the control is a pointer or if the control type is not V4L2_CTRL_TYPE_INTEGER64.",
        "proto" :"static long (*__v4l2_ctrl_s_ctrl_int64)(struct v4l2_ctrl *ctrl, s64 val)",
        "pre": {
            "ctrl": "!=null",
            "ctrl->is_ptr": "==false",
            "ctrl->type": "==V4L2_CTRL_TYPE_INTEGER64",
            "val": "is s64"
        },
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_string": {
        "description": "Sets the string value of a V4L2 control. It's a driver bug if the control type is not V4L2_CTRL_TYPE_STRING.",
        "proto": "int __v4l2_ctrl_s_ctrl_string(struct v4l2_ctrl *ctrl, const char *s)",
        "pre": {
            "ctrl": "!=null",
            "ctrl->type": "==V4L2_CTRL_TYPE_STRING",
            "s": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "__v4l2_ctrl_s_ctrl_string": {
        "description": "This function is used to set the control string. It's a driver bug if this happens.",
        "proto" :"static long (*__v4l2_ctrl_s_ctrl_string)(struct v4l2_ctrl *ctrl, const char *s)",
        "pre": {
            "ctrl": "!=null",
            "s": "!=null",
            "ctrl->type": "==V4L2_CTRL_TYPE_STRING",
            "ctrl->handler->lock": "is held"
        },
    }
},
{
    "kretprobe:__v4l2_ctrl_s_ctrl_compound": {
        "description": "This function is used to set the control compound. It's a driver bug if the control type does not match the expected type.",
        "proto": "int __v4l2_ctrl_s_ctrl_compound(struct v4l2_ctrl *ctrl, enum v4l2_ctrl_type type, const void *p)",
        "pre": {
            "ctrl": "!=null",
            "type": "in [V4L2_CTRL_TYPE_INTEGER, V4L2_CTRL_TYPE_BOOLEAN, V4L2_CTRL_TYPE_MENU, V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_INTEGER64, V4L2_CTRL_TYPE_CTRL_CLASS, V4L2_CTRL_TYPE_STRING, V4L2_CTRL_TYPE_BITMASK, V4L2_CTRL_TYPE_INTEGER_MENU]",
            "p": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "__v4l2_ctrl_s_ctrl_compound": {
        "description": "It's a driver bug if this happens.",
        "proto" :"__v4l2_ctrl_s_ctrl_compound(struct v4l2_ctrl *ctrl, enum v4l2_ctrl_type type, const void *p)",
        "pre": {
            "ctrl": "!=null",
            "type": "in [V4L2_CTRL_TYPE_INTEGER, V4L2_CTRL_TYPE_BOOLEAN, V4L2_CTRL_TYPE_MENU, V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_INTEGER64, V4L2_CTRL_TYPE_CTRL_CLASS, V4L2_CTRL_TYPE_STRING, V4L2_CTRL_TYPE_BITMASK, V4L2_CTRL_TYPE_INTEGER_MENU]",
            "p": "!=null"
        },
    }
},
{
    "kretprobe:v4l2_query_ext_ctrl": {
        "description": "Query extended control of v4l2.",
        "proto" :"static long (*v4l2_query_ext_ctrl)(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)",
        "pre": {
            "hdl": "!=null",
            "qc": "!=null",
            "qc->id": "in [V4L2_CTRL_FLAG_NEXT_CTRL, V4L2_CTRL_FLAG_NEXT_COMPOUND]",
            "hdl->ctrl_refs": "!=empty"
        },
    }
},
{
    "kprobe:v4l2_query_ext_ctrl": {
        "description": "This function is used to query extended control.",
        "proto" :"int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)",
        "pre": {
            "hdl": "!=null",
            "qc": "!=null",
            "qc->id": "in [V4L2_CTRL_FLAG_NEXT_CTRL, V4L2_CTRL_FLAG_NEXT_COMPOUND]",
            "hdl->ctrl_refs": "!=empty"
        },
    }
},
{
    "kretprobe:v4l2_querymenu": {
        "description": "This function is not fully described in the provided helper doc. Please provide more information.",
        "proto" :"v4l2_querymenu(struct v4l2_ctrl_handler  hdl, struct v4l2_querymenu  qm)",
        "pre": {
            "hdl": "!=null",
            "qm": "!=null"
        }
    }
},
{
    "kprobe:v4l2_querymenu": {
        "description": "This function is not well documented, but it seems to be related to querying a menu in a v4l2 control handler.",
        "proto": "v4l2_querymenu(struct v4l2_ctrl_handler  hdl, struct v4l2_querymenu  qm)",
        "pre": {
            "hdl": "!=null",
            "qm": "!=null",
            "qm->index": "is a valid index",
            "qm->id": "is a valid id",
            "ctrl": "!=null",
            "ctrl->type": "is a valid type"
        }
    }
},
{
    "kretprobe:v4l2_ctrl_get_name": {
        "description": "Get the name of the control corresponding to *id*.",
        "proto" :"static char* (*v4l2_ctrl_get_name)(u32 id)",
        "pre": {
            "id": "in [0, 4294967295]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:v4l2_ctrl_get_name": {
        "description": "Get the name of the control associated with the given id.",
        "proto" :"static char* (*v4l2_ctrl_get_name)(u32 id)",
        "pre": {
            "id": "is u32"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_fill": {
        "description": "Fill the v4l2 control structure based on the control id.",
        "proto" :"v4l2_ctrl_fill(u32 id, const char name, enum v4l2_ctrl_type type, s64 min, s64 max, u64 step, s64 def, u32 flags)",
        "pre": {
            "id": "in [V4L2_CID_AUDIO_MUTE, V4L2_CID_AUDIO_LOUDNESS, V4L2_CID_AUTO_WHITE_BALANCE, V4L2_CID_AUTOGAIN, V4L2_CID_HFLIP, V4L2_CID_VFLIP, V4L2_CID_HUE_AUTO, V4L2_CID_CHROMA_AGC, V4L2_CID_COLOR_KILLER, V4L2_CID_AUTOBRIGHTNESS, V4L2_CID_MPEG_AUDIO_MUTE, V4L2_CID_MPEG_VIDEO_MUTE, V4L2_CID_MPEG_VIDEO_GOP_CLOSURE, V4L2_CID_MPEG_VIDEO_PULLDOWN, V4L2_CID_EXPOSURE_AUTO_PRIORITY, V4L2_CID_FOCUS_AUTO, V4L2_CID_PRIVACY, V4L2_CID_AUDIO_LIMITER_ENABLED, V4L2_CID_AUDIO_COMPRESSION_ENABLED, V4L2_CID_PILOT_TONE_ENABLED, V4L2_CID_ILLUMINATORS_1, V4L2_CID_ILLUMINATORS_2, V4L2_CID_FLASH_STROBE_STATUS, V4L2_CID_FLASH_CHARGE, V4L2_CID_FLASH_READY, V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER, V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE, V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE, V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE, V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE, V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM, V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE, V4L2_CID_MPEG_VIDEO_MPEG4_QPEL, V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER, V4L2_CID_MPEG_VIDEO_AU_DELIMITER, V4L2_CID_WIDE_DYNAMIC_RANGE, V4L2_CID_IMAGE_STABILIZATION, V4L2_CID_RDS_RECEPTION, V4L2_CID_RF_TUNER_LNA_GAIN_AUTO, V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, V4L2_CID_RF_TUNER_IF_GAIN_AUTO, V4L2_CID_RF_TUNER_BANDWIDTH_AUTO, V4L2_CID_RF_TUNER_PLL_LOCK, V4L2_CID_RDS_TX_MONO_STEREO, V4L2_CID_RDS_TX_ARTIFICIAL_HEAD, V4L2_CID_RDS_TX_COMPRESSED, V4L2_CID_RDS_TX_DYNAMIC_PTY, V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT, V4L2_CID_RDS_TX_TRAFFIC_PROGRAM, V4L2_CID_RDS_TX_MUSIC_SPEECH, V4L2_CID_RDS_TX_ALT_FREQS_ENABLE, V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT, V4L2_CID_RDS_RX_TRAFFIC_PROGRAM, V4L2_CID_RDS_RX_MUSIC_SPEECH]",
            "name": "!=null",
            "type": "in [V4L2_CTRL_TYPE_BOOLEAN, V4L2_CTRL_TYPE_INTEGER, V4L2_CTRL_TYPE_BUTTON, V4L2_CTRL_TYPE_MENU, V4L2_CTRL_TYPE_INTEGER_MENU, V4L2_CTRL_TYPE_STRING, V4L2_CTRL_TYPE_CTRL_CLASS]",
            "min": ">=0",
            "max": ">=min",
            "step": ">=0",
            "def": ">=0",
            "flags": "in [V4L2_CTRL_FLAG_MODIFY_LAYOUT, V4L2_CTRL_FLAG_EXECUTE_ON_WRITE, V4L2_CTRL_FLAG_WRITE_ONLY]"
        }
    }
},
{
    "kprobe:v4l2_ctrl_fill": {
        "description": "Fill the v4l2 control based on the id.",
        "proto" :"v4l2_ctrl_fill(u32 id, const char name, enum v4l2_ctrl_type type, s64 min, s64 max, u64 step, s64 def, u32 flags)",
        "pre": {
            "id": "in [V4L2_CID_AUDIO_MUTE, V4L2_CID_AUDIO_LOUDNESS, ...]",
            "name": "!=null",
            "type": "in [V4L2_CTRL_TYPE_BOOLEAN, V4L2_CTRL_TYPE_INTEGER, ...]",
            "min": ">=0",
            "max": ">=min",
            "step": ">=1",
            "def": ">=0",
            "flags": "in [V4L2_CTRL_FLAG_MODIFY_LAYOUT, V4L2_CTRL_FLAG_EXECUTE_ON_WRITE, ...]",
        },
    }
},
{
    "kretprobe:v4l2_ctrl_request_complete": {
        "description": "Could not allocate a control handler object to store the completed state in. So return ENOMEM to indicate that there was an out-of-memory error.",
        "proto" :"static long (*v4l2_ctrl_request_complete)(void *new_hdl, void *hdl, void *req)",
        "pre": {
            "new_hdl": "!=null",
            "hdl": "!=null",
            "req": "!=null"
        },
        "post": {
            "return": "in [-ENOMEM]"
        }
    }
},
{
    "kprobe:v4l2_ctrl_request_complete": {
        "description": "Could not allocate a control handler object to store the completed state in. So return ENOMEM to indicate that there was an out-of-memory error.",
        "proto" :"static long (*v4l2_ctrl_request_complete)(void *new_hdl, void *hdl, void *req, int ret)",
        "pre": {
            "new_hdl": "!=null",
            "hdl": "!=null",
            "req": "!=null",
            "ret": "in [0, -ENOMEM]"
        },
    }
},
{
    "kretprobe:v4l2_ctrl_request_setup": {
        "description": "Setup the control request for a media request. If the request or main handler is null, or the request state is not MEDIA_REQUEST_STATE_QUEUED, it returns 0 or -EBUSY. It is valid if nothing was found, meaning the request doesn't have any controls and wants to leave the controls unchanged.",
        "proto": "int v4l2_ctrl_request_setup(struct media_request *req, struct v4l2_ctrl_handler *main_hdl)",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null"
        },
        "post": {
            "return": "in [0, -EBUSY]",
            "req->state": "== MEDIA_REQUEST_STATE_QUEUED"
        }
    }
},
{
    "kprobe:v4l2_ctrl_request_setup": {
        "description": "Setup the control request for a media request. If the request or the main handler is null, or if the request state is not queued, or if the object is not found or completed, it returns 0 or -EBUSY. It is valid if nothing was found, meaning that this request doesn't have any controls and wants to leave the controls unchanged.",
        "proto" :"static int (*v4l2_ctrl_request_setup)(struct media_request *req, struct v4l2_ctrl_handler *main_hdl)",
        "pre": {
            "req": "!=null",
            "main_hdl": "!=null",
            "req->state": "== MEDIA_REQUEST_STATE_QUEUED",
            "obj": "!=null && !obj->completed"
        },
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate and zero-initialize memory of size *sizeof(struct s5h1409_state)*. If allocation fails, return NULL and go to error.",
        "proto" :"struct s5h1409_state *state = kzalloc(sizeof(struct s5h1409_state), GFP_KERNEL)",
        "pre": {
            "sizeof(struct s5h1409_state)": "> 0",
            "GFP_KERNEL": "is defined"
        },
        "post": {
            "state": "!=null || ==null"
        }
    }
},
{
    "kprobe:s5h1409_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"s5h1409_attach(const struct s5h1409_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:zl10036_read_status_reg": {
        "description": "Reads the status register of the zl10036 device. Returns a negative value if an error occurs.",
        "proto" :"int (*zl10036_read_status_reg)(struct zl10036_state *state)",
        "pre": {
            "state": "!=null"
        },
        "post": {
            "ret": "< 0"
        }
    }
},
{
    "kprobe:zl10036_read_status_reg": {
        "description": "Reads a status register from a zl10036_state object.",
        "proto" :"int (*zl10036_read_status_reg)(struct zl10036_state *state)",
        "pre": {
            "state": "!=null"
        },
    }
},
{
    "kretprobe:cx24120_attach": {
        "description": "Attach a Conexant cx24120cx24118 - DVBSS2 Satellite demodtuner. Allocate memory for cx24120_state and setup the state.",
        "proto" :"static long (*cx24120_attach)(const struct cx24120_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kprobe:cx24120_attach": {
        "description": "Attach a Conexant cx24120/cx24118 - DVB-S2 Satellite demod/tuner. Allocate memory for cx24120_state and setup the state.",
        "proto" :"static struct cx24120_state* (*cx24120_attach)(const struct cx24120_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kretprobe:cx24123_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct cx24123_state *(*cx24123_attach)(const struct cx24123_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory and set the memory to zero. Size is determined by the first parameter, and flags are determined by the second parameter.",
        "proto": "void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        }
    }
},
{
    "kretprobe:lg2160_attach": {
        "description": "Attach the LG2160 device and initialize the state.",
        "proto" :"lg2160_attach(const struct lg2160_config *config, struct i2c_adapter *i2c_adap)",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:lg2160_attach": {
        "description": "Attach the LG2160 device and initialize the state.",
        "proto" :"lg2160_attach(const struct lg2160_config  config,   struct i2c_adapter  i2c_adap)",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        },
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"void *(*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory and initialize it to zero.",
        "proto" :"void *(*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:cx22702_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct cx22702_state* (*cx22702_attach)(const struct cx22702_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:cx22702_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct cx22702_state* (*cx22702_attach)(const struct cx22702_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate and zero-initialize memory for the internal state.",
        "proto" :"static void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:tda10023_attach": {
        "description": "Attach the tda10023 device. Allocate memory for the internal state.",
        "proto" :"static struct tda10023_state* (*tda10023_attach)(const struct tda10023_config* config, struct i2c_adapter* i2c, u8 pwm)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "in [0, 255]"
        },
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:nxt6000_attach": {
        "description": "Attach a nxt6000 device and allocate memory for the internal state.",
        "proto" :"nxt6000_attach(const struct nxt6000_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocates the memory and initializes it to zero. If the allocation fails, it returns NULL.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "s5h1411_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"s5h1411_attach(const struct s5h1411_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory and initialize it to zero. If the allocation fails, return NULL.",
        "proto" :"void *(*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"tda10046_attach(const struct tda1004x_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:tda10046_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"tda10046_attach(const struct tda1004x_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kretprobe:lgs8gxx_read_reg": {
        "description": "Read a register from a device.",
        "proto" :"int (*lgs8gxx_read_reg)(struct lgs8gxx_state *priv, int reg, u8 *data)",
        "pre": {
            "priv": "!=null",
            "reg": "==0",
            "data": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:lgs8gxx_read_reg": {
        "description": "Read a register from a device.",
        "proto" :"int (*lgs8gxx_read_reg)(struct lgs8gxx_state *priv, int reg, u8 *data)",
        "pre": {
            "priv": "!=null",
            "reg": "==0",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:dib9000_fw_pid_filter_ctrl": {
        "description": "postpone the pid filtering cmd",
        "proto" :"static long (*dib9000_fw_pid_filter_ctrl)(struct dvb_frontend *fe, u8 onoff)",
        "pre": {
            "fe": "!=null",
            "onoff": "in [0, 1]"
        },
    }
},
{
    "kprobe:dib9000_fw_pid_filter_ctrl": {
        "description": "Postpone the pid filtering cmd",
        "proto" :"static int (*dib9000_fw_pid_filter_ctrl)(struct dvb_frontend *fe, u8 onoff)",
        "pre": {
            "fe": "!=null",
            "onoff": "in [0, 1]"
        }
    }
},
{
    "kretprobe:dib9000_i2c_enumeration": {
        "description": "Performs I2C enumeration for dib9000 devices.",
        "proto": "int dib9000_i2c_enumeration(struct i2c_adapter i2c, int no_of_demods, u8 default_addr, u8 first_addr)",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "in [0, 255]",
            "first_addr": "in [0, 255]"
        },
        "post": {
            "ret": "in [-ENOMEM, 0]"
        }
    }
},



{
    "kretprobe:dibx000_reset_i2c_master": {
        "description": "Initialize the i2c-master by closing the gate",
        "proto" :"static void (*dibx000_reset_i2c_master)(struct dibx000_i2c_master mst)",
        "pre": {
            "mst": "!=null"
        }
    }
},
{
    "kprobe:dibx000_reset_i2c_master": {
        "description": "Initialize the i2c-master by closing the gate",
        "proto" :"static void (*dibx000_reset_i2c_master)(struct dibx000_i2c_master mst)",
        "pre": {
            "mst": "!=null"
        }
    }
},
{
    "kretprobe:dibx000_init_i2c_master": {
        "description": "Initialize the i2c-master by closing the gate.",
        "proto" :"dibx000_init_i2c_master(struct dibx000_i2c_master  mst, u16 device_rev,struct i2c_adapter  i2c_adap, u8 i2c_addr)",
        "pre": {
            "mst": "!=null",
            "device_rev": "in [DIB7000P, DIB8000]",
            "i2c_adap": "!=null",
            "i2c_addr": ">=0 && <=255",
        },
    }
},
{
    "kprobe:dibx000_init_i2c_master": {
        "description": "Initialize the i2c-master by closing the gate.",
        "proto" :"dibx000_init_i2c_master(struct dibx000_i2c_master  mst, u16 device_rev,struct i2c_adapter  i2c_adap, u8 i2c_addr)",
        "pre": {
            "mst": "!=null",
            "device_rev": "in [DIB7000P, DIB8000]",
            "i2c_adap": "!=null",
            "i2c_addr": ">=0 && <=255",
        },
    }
},
{
    "kretprobe:l64781_attach": {
        "description": "Attach the l64781 device and initialize the internal state.",
        "proto" :"static long (*l64781_attach)(const struct l64781_config  config,   struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory and return a pointer to that memory. The memory is set to zero. If the allocation fails, it returns NULL.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": "sizeof(struct l64781_state)",
            "flags": "GFP_KERNEL"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static long (*stv0367ter_attach)(const struct stv0367_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "ter_state": "!=null"
        }
    }
},
{
    "kprobe:stv0367ter_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0367ter_attach(const struct stv0367_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "ter_state": "!=null"
        }
    }
},
{
    "kretprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0367cab_attach(const struct stv0367_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "cab_state": "!=null"
        }
    }
},
{
    "kprobe:stv0367cab_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0367cab_attach(const struct stv0367_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "cab_state": "!=null"
        }
    }
},
{
    "kretprobe:stv0367ddb_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static long (*stv0367ddb_attach)(const struct stv0367_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null",
            "ter_state": "!=null",
            "cab_state": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocates the memory and zero initializes it. If the allocation fails, it returns NULL.",
        "proto": "void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"sp887x_attach(const struct sp887x_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "sp887x_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"sp887x_attach(const struct sp887x_config  config,   struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state.",
        "proto" :"static long (*m88rs2000_attach)(const struct m88rs2000_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:m88rs2000_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"m88rs2000_attach(const struct m88rs2000_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:stb6000_attach": {
        "description": "Attach a device to a DVB frontend.",
        "proto": "struct dvb_frontend* (*stb6000_attach)(struct dvb_frontend* fe, int addr, struct i2c_adapter* i2c)",
        "pre": {
            "fe": "!=null",
            "addr": "is valid i2c address",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null implies fe->tuner_priv !=null and fe->ops.tuner_ops == stb6000_tuner_ops"
        }
    }
},
{
    "kprobe:stb6000_attach": {
        "description": "Attach a device to the i2c bus.",
        "proto" :"static struct dvb_frontend* (*stb6000_attach)(struct dvb_frontend *fe, int addr, struct i2c_adapter *i2c)",
        "pre": {
            "fe": "!=null",
            "addr": "is valid i2c address",
            "i2c": "!=null",
        },
    }
},
{
    "kretprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct stv0297_state* (*stv0297_attach)(const struct stv0297_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:stv0297_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0297_attach(const struct stv0297_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:cx24113_agc_callback": {
        "description": "This function only works with the current CX24123 implementation.",
        "proto" :"static void (*cx24113_agc_callback)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null"
        }
    }
},

{
    "kretprobe:cx24113_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct cx24113_state *(*cx24113_attach)(struct dvb_frontend *fe, const struct cx24113_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:ds3000_attach": {
        "description": "Allocate memory for the internal state",
        "proto": "static struct ds3000_state* (*ds3000_attach)(const struct ds3000_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:cx24116_attach": {
        "description": "Attach a cx24116 demodulator to the given i2c adapter with the given configuration.",
        "proto": "struct cx24116_state *(*cx24116_attach)(const struct cx24116_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},

{
    "kretprobe:isl6405_attach": {
        "description": "Attach the isl6405 device to the dvb_frontend, with the given i2c_adapter, i2c_addr, override_set, and override_clear. Returns NULL if the isl6405 device cannot be allocated.",
        "proto" :"static struct isl6405* (*isl6405_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c, u8 i2c_addr, u8 override_set, u8 override_clear)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "is valid i2c address",
            "override_set": "is valid override set",
            "override_clear": "is valid override clear"
        },
    }
},
{
    "kprobe:isl6405_attach": {
        "description": "Attach the isl6405 device to the dvb_frontend, with the given i2c_adapter, i2c_addr, override_set, and override_clear.",
        "proto" :"isl6405_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, u8 i2c_addr, u8 override_set, u8 override_clear)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "is valid i2c address",
            "override_set": "is valid override set",
            "override_clear": "is valid override clear"
        },
    }
},
{
    "kretprobe:tda10048_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct tda10048_state* (*tda10048_attach)(const struct tda10048_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},


{
    "kprobe:kzalloc": {
        "description": "Allocate memory and initialize it to zero. If allocation fails, it goes to error.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": "sizeof(struct cx24110_state)",
            "flags": "GFP_KERNEL",
        },
    }
},
{
    "kretprobe:stv6110_attach": {
        "description": "Attach the STV6110 tuner to the given DVB frontend, with the provided configuration and I2C adapter.",
        "proto": "struct dvb_frontend *(*stv6110_attach)(struct dvb_frontend *fe, const struct stv6110_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null",
            "config->i2c_address": "!=null",
            "config->mclk": "!=null",
            "config->clk_div": "!=null",
            "config->gain": "!=null"
        },
        "post": {
            "fe": "!=null",
            "fe->ops.i2c_gate_ctrl": "!=null",
            "fe->ops.tuner_ops": "!=null",
            "fe->tuner_priv": "!=null",
            "ret": "==1",
            "priv": "!=null",
            "priv->i2c_address": "==config->i2c_address",
            "priv->i2c": "==i2c",
            "priv->mclk": "==config->mclk",
            "priv->clk_div": "==config->clk_div",
            "priv->gain": "==config->gain"
        }
    }
},

{
    "kretprobe:kzalloc": {
        "description": "Allocate memory and set the memory to zero. Size is determined by the first parameter and flags by the second parameter.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory and zero it out.",
        "proto" :"void *(*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:kmalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static void* (*kmalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "sizeof(struct s5h1432_state)",
            "flags": "GFP_KERNEL"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:dib3000mc_i2c_enumeration": {
        "description": "This function is used for i2c enumeration of dib3000mc.",
        "proto" :"static int (*dib3000mc_i2c_enumeration)(struct i2c_adapter  i2c, int no_of_demods, u8 default_addr, struct dib3000mc_config cfg[])",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "is valid u8",
            "cfg": "!=null"
        },
    }
},
{
    "kprobe:dib3000mc_i2c_enumeration": {
        "description": "This function enumerates the i2c addresses for dib3000mc devices.",
        "proto" :"static int (*dib3000mc_i2c_enumeration)(struct i2c_adapter  i2c, int no_of_demods, u8 default_addr, struct dib3000mc_config cfg[])",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "is valid u8",
            "cfg": "!=null",
        },
    }
},
{
    "kretprobe:dib0090_pwm_gain_reset": {
        "description": "Reset the AGC and set the default baseband config",
        "proto" :"static void (*dib0090_pwm_gain_reset)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null"
        }
    }
},
{
    "kprobe:dib0090_pwm_gain_reset": {
        "description": "Reset the PWM gain of the DIB0090 frontend.",
        "proto" :"static void (*dib0090_pwm_gain_reset)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null"
        }
    }
},

{
    "kprobe:dib0090_gain_control": {
        "description": "Description of the function",
        "proto" :"static long (*dib0090_gain_control)(struct dvb_frontend  fe)",
        "pre": {
            "fe": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:or51211_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct or51211_state* (*or51211_attach)(const struct or51211_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct or51211_state* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "== sizeof(struct or51211_state)",
            "flags": "== GFP_KERNEL",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:zl10039_attach": {
        "description": "Attach a zl10039 tuner to the given DVB frontend structure. Open i2c gate.",
        "proto" :"static struct dvb_frontend* (*zl10039_attach)(struct dvb_frontend* fe, u8 i2c_addr, struct i2c_adapter* i2c)",
        "pre": {
            "fe": "!=null",
            "i2c_addr": "is valid i2c address",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:zl10039_attach": {
        "description": "Attach a zl10039 tuner to the given DVB frontend, with the specified I2C address and adapter. The function also opens the I2C gate.",
        "proto" :"static struct dvb_frontend* (*zl10039_attach)(struct dvb_frontend* fe, u8 i2c_addr, struct i2c_adapter* i2c)",
        "pre": {
            "fe": "!=null",
            "i2c_addr": "is valid I2C address",
            "i2c": "!=null",
        },
    }
},
{
    "kretprobe:usleep_range": {
        "description": "This function will sleep between min and max microseconds.",
        "proto" :"static unsigned int (*usleep_range)(unsigned int min, unsigned int max)",
        "pre": {
            "min": ">=0",
            "max": ">=min"
        },
    }
},
{
    "kprobe:usleep_range": {
        "description": "Pauses execution for a time within the range specified by `min` and `max`. The time is specified in microseconds.",
        "proto" :"int (*usleep_range)(unsigned long min, unsigned long max)",
        "pre": {
            "min": ">=0",
            "max": ">=min",
        },
    }
},
{
    "kretprobe:stv090x_attach": {
        "description": "Attach the stv090x device.",
        "proto" :"int (*stv090x_attach)(struct stv090x_config *config, struct i2c_adapter *i2c, enum stv090x_demodulator demod)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "demod": "in [STV090X_SINGLE, STV090X_DUAL]",
        },
    }
},

{
    "kretprobe:ves1x93_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"ves1x93_attach(const struct ves1x93_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory for the internal state.",
        "proto" :"static struct ves1x93_state* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "== sizeof(struct ves1x93_state)",
            "flags": "== GFP_KERNEL",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:stb0899_attach": {
        "description": "Attach the stb0899 device and initialize the state.",
        "proto" :"static struct dvb_frontend* (*stb0899_attach)(struct stb0899_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:stb0899_attach": {
        "description": "Attach the stb0899 device. Allocate memory for the state, set the state's verbose, config, i2c, frontend.ops, and frontend.demodulator_priv properties. Use configured inversion as default.",
        "proto" :"static struct dvb_frontend* (*stb0899_attach)(struct stb0899_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},

{
    "kprobe:lgdt3306a_attach": {
        "description": "Attach a lgdt3306a device.",
        "proto" :"lgdt3306a_attach(const struct lgdt3306a_config  config, struct i2c_adapter  i2c_adap)",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null"
        },
    }
},
{
    "kretprobe:dvb_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct dvb_dummy_fe_state* (*dvb_dummy_fe_qam_attach)(void)",
        "pre": {},
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocates the size of the specified structure and returns a pointer to the allocated memory.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory and set the memory to zero. Size is determined by the first parameter, and flags by the second parameter.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct ec100_state* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "sizeof(struct ec100_state)",
            "flags": "GFP_KERNEL",
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:au8522_attach": {
        "description": "Add your function description here",
        "proto" :"au8522_attach(const struct au8522_config  config,   struct i2c_adapter  i2c)",
        "pre": {
            "config": "Add your condition here",
            "i2c": "Add your condition here"
        },
    }
},


{
    "kprobe:kzalloc": {
        "description": "Allocate memory and zero it out.",
        "proto" :"void *(*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct or51132_state* (*or51132_attach)(const struct or51132_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:or51132_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"or51132_attach(const struct or51132_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:dib7000m_i2c_enumeration": {
        "description": "Enumerates the i2c addresses for dib7000m devices.",
        "proto" :"static long (*dib7000m_i2c_enumeration)(struct i2c_adapter i2c, int no_of_demods, u8 default_addr, struct dib7000m_config cfg[])",
        "pre": {
            "i2c": "!=null",
            "no_of_demods": ">=0",
            "default_addr": "is valid i2c address",
            "cfg": "!=null"
        },
    }
},

{
    "kretprobe:lnbp22_attach": {
        "description": "Attach the lnbp22 to the dvb_frontend and i2c_adapter, and initialize it with default configuration.",
        "proto" :"static struct lnbp22* (*lnbp22_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},


{
    "kprobe:kzalloc": {
        "description": "Allocates and zeros memory.",
        "proto" :"void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory and set the memory to zero. Size is determined by the first parameter, and flags by the second parameter.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "nxt200x_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"nxt200x_attach(const struct nxt200x_config  config,   struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:ascot2e_attach": {
        "description": "Attach the ascot2e device to the DVB frontend.",
        "proto" :"static struct ascot2e_priv* (*ascot2e_attach)(struct dvb_frontend* fe, const struct ascot2e_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},


{
    "kprobe:drxk_attach": {
        "description": "Attach a DRXK demodulator device.",
        "proto": "int drxk_attach(const struct drxk_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state->uio_mask": "config->antenna_gpio"
        }
    }
},
{
    "kretprobe:dib0070_wbd_offset": {
        "description": "This function seems to be related to offset calibration. It appears to involve a loop that iterates from 6 to 8, and some operations on the 'state' object. However, the exact purpose and behavior of the function are unclear from the provided text.",
        "proto" :"static long (*dib0070_wbd_offset)(struct dib0070_state *state, struct dvb_frontend *fe)",
        "pre": {
            "state": "!=null",
            "fe": "!=null"
        },
    }
},
{
    "kprobe:dib0070_wbd_offset": {
        "description": "This function seems to be related to offset calibration, but the exact details are unclear due to the malformed function.",
        "proto" :"static long (*dib0070_wbd_offset)(struct dib0070_state *state, struct dvb_frontend *fe)",
        "pre": {
            "state": "!=null",
            "fe": "!=null"
        },
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate memory and zero it out.",
        "proto": "void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:tda10086_attach": {
        "description": "Attach a tda10086 device and allocate memory for the internal state.",
        "proto" :"static struct tda10086_state* (*tda10086_attach)(const struct tda10086_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kretprobe:drxd_attach": {
        "description": "Attach a DRXD device and initialize it.",
        "proto": "drxd_attach(const struct drxd_config  config, void  priv, struct i2c_adapter  i2c, struct device  dev)",
        "pre": {
            "config": "!=null",
            "priv": "!=null",
            "i2c": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:drxd_attach": {
        "description": "This function initializes the drxd_state structure and performs some initial setup.",
        "proto" :"drxd_attach(const struct drxd_config  config, void  priv, struct i2c_adapter  i2c, struct device  dev)",
        "pre": {
            "config": "!=null",
            "priv": "can be null",
            "i2c": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:lgdt3305_attach": {
        "description": "Your function description here",
        "proto" :"lgdt3305_attach(const struct lgdt3305_config  config, struct i2c_adapter  i2c_adap)",
        "pre": {
            "config": "Your condition here",
            "i2c_adap": "Your condition here"
        },
        "post": {
            "state": "Your condition here",
            "ret": "Your condition here",
            "val": "Your condition here"
        }
    }
},
{
    "kprobe:lgdt3305_attach": {
        "description": "Attach the LGDT3305 demodulator",
        "proto" :"lgdt3305_attach(const struct lgdt3305_config *config, struct i2c_adapter *i2c_adap)",
        "pre": {
            "config": "!=null",
            "i2c_adap": "!=null",
        },
    }
},
{
    "kretprobe:atbm8830_read_reg": {
        "description": "Reads the register value of the ATBM8830 chip.",
        "proto" :"int (*atbm8830_read_reg)(struct atbm_state *priv, int REG_CHIP_ID, u8 *data)",
        "pre": {
            "priv": "!=null",
            "REG_CHIP_ID": "is constant",
            "data": "!=null"
        },
    }
},
{
    "kprobe:atbm8830_read_reg": {
        "description": "Reads a register value from a chip.",
        "proto" :"int (*atbm8830_read_reg)(struct atbm_state *priv, int REG_CHIP_ID, u8 *data)",
        "pre": {
            "priv": "!=null",
            "REG_CHIP_ID": "is valid register id",
            "data": "!=null"
        },
    }
},
{
    "kretprobe:ves1820_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct ves1820_state* (*ves1820_attach)(const struct ves1820_config* config, struct i2c_adapter* i2c, u8 pwm)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "in [0, 255]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ves1820_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"ves1820_attach(const struct ves1820_config  config,    struct i2c_adapter  i2c,    u8 pwm)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "pwm": "in [0, 255]"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:kzalloc": {
        "description": "Allocate and zero-initialize memory of size *sizeof(struct tda10021_state)*. If allocation fails, go to error.",
        "proto" :"static void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL]"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct tda10021_state* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "==sizeof(struct tda10021_state)",
            "flags": "==GFP_KERNEL",
        },
    }
},
{
    "kretprobe:isl6421_attach": {
        "description": "Attach the isl6421 device to the dvb_frontend, with the given i2c_adapter, i2c_addr, override_set, override_clear, and override_tone. Returns NULL if the device cannot be allocated.",
        "proto" :"static struct isl6421* (*isl6421_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c, u8 i2c_addr, u8 override_set, u8 override_clear, bool override_tone)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "is valid i2c address",
            "override_set": "is valid u8 value",
            "override_clear": "is valid u8 value",
            "override_tone": "is valid bool value"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:isl6421_attach": {
        "description": "Attach the isl6421 device to the dvb_frontend, with the given i2c_adapter, i2c_addr, override_set, override_clear, and override_tone. Returns NULL if the isl6421 device cannot be allocated.",
        "proto" :"struct isl6421* (*isl6421_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c, u8 i2c_addr, u8 override_set, u8 override_clear, bool override_tone)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "i2c_addr": "is valid i2c address",
            "override_set": "is valid override_set value",
            "override_clear": "is valid override_clear value",
            "override_tone": "is valid boolean"
        },
    }
},
{
    "kretprobe:s921_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct s921_state *(*s921_attach)(const struct s921_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:s921_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct s921_state *(*s921_attach)(const struct s921_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        }
    }
},
{
    "kretprobe:ts2020_attach": {
        "description": "This is only used by ts2020_probe() so can be on the stack",
        "proto" :"ts2020_attach(struct dvb_frontend  fe,const struct ts2020_config  config,struct i2c_adapter  i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kprobe:memcpy": {
        "description": "Copies the values of 'sizeof(pdata)' bytes from the location pointed by 'config' to the memory block pointed by '&pdata'.",
        "proto" :"void *memcpy(void *dest, const void *src, size_t n)",
        "pre": {
            "dest": "!=null",
            "src": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kretprobe:dib3000mb_attach": {
        "description": "Attach a DIB3000 device and allocate memory for the internal state.",
        "proto" :"static struct dib3000_state* (*dib3000mb_attach)(const struct dib3000_config* config, struct i2c_adapter* i2c, struct dib_fe_xfer_ops* xfer_ops)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:dib3000mb_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"dib3000mb_attach(const struct dib3000_config  config, struct i2c_adapter  i2c, struct dib_fe_xfer_ops  xfer_ops)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null",
            "xfer_ops": "!=null"
        },
    }
},
{
    "kretprobe:isl6423_attach": {
        "description": "Attach the isl6423 device to the dvb_frontend. Allocate memory for the isl6423 device and set its configuration, i2c adapter, and sec_priv of the frontend.",
        "proto" :"struct isl6423_dev* (*isl6423_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c, const struct isl6423_config* config)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "config": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},

{
    "kretprobe:kzalloc_cx22700_state": {
        "description": "Allocate memory for the internal state of a cx22700 device.",
        "proto" :"static struct cx22700_state* (*kzalloc_cx22700_state)(size_t size, gfp_t flags)",
        "pre": {
            "size": "== sizeof(struct cx22700_state)",
            "flags": "== GFP_KERNEL"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:cx22700_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct cx22700_state* (*cx22700_attach)(const struct cx22700_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:mt352_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"mt352_attach(const struct mt352_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocates the memory of a given size and initializes it to zero.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:au8522_i2c_gate_ctrl": {
        "description": "Manages the gate based on the operational mode and the enable flag.",
        "proto" :"int au8522_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)",
        "pre": {
            "fe": "!=null",
            "enable": "in [0, 1]"
        },
    }
},
{
    "kprobe:au8522_i2c_gate_ctrl": {
        "description": "We're being asked to manage the gate even though we're not in digital mode. This can occur if we get switched over to analog mode before the dvb_frontend kernel thread has completely shutdown",
        "proto" :"au8522_i2c_gate_ctrl(struct dvb_frontend  fe, int enable)",
        "pre": {
            "fe": "!=null",
            "enable": "in [0, 1]"
        },
    }
},
{
    "kretprobe:au8522_led_ctrl": {
        "description": "Controls an LED based on the provided state and led parameters. Bails out if it can't control an LED.",
        "proto" :"int au8522_led_ctrl(struct au8522_state *state, int led)",
        "pre": {
            "state": "!=null",
            "state->config.led_cfg": "!=null",
            "state->config.led_cfg->gpio_leds": "!=null",
            "state->config.led_cfg->num_led_states": ">0",
            "state->config.led_cfg->led_states": "!=null",
            "led": ">=0"
        },
    }
},
{
    "kprobe:au8522_led_ctrl": {
        "description": "Bail out if we can't control an LED.",
        "proto" :"static int (*au8522_led_ctrl)(struct au8522_state *state, int led)",
        "pre": {
            "state": "!=null",
            "state->config.led_cfg": "!=null",
            "led_config->gpio_leds": "!=null",
            "led_config->num_led_states": ">0",
            "led_config->led_states": "!=null",
            "led": ">=0"
        },
    }
},
{
    "kretprobe:au8522_init": {
        "description": "Clear out any state associated with the digital side of the chip, so that when it gets powered back up it won't think that it is already tuned.",
        "proto" :"static long (*au8522_init)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null"
        },
        "post": {
            "state->current_frequency": "==0",
            "state->current_modulation": "==VSB_8",
            "au8522_writereg(state, 0xa4, 1 << 5)": "==0",
            "au8522_i2c_gate_ctrl(fe, 1)": "==0",
            "return": "==0"
        }
    }
},
{
    "kprobe:au8522_init": {
        "description": "Clear out any state associated with the digital side of the chip, so that when it gets powered back up it won't think that it is already tuned.",
        "proto" :"static long (*au8522_init)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null",
            "fe->demodulator_priv": "!=null",
            "state->operational_mode": "== AU8522_DIGITAL_MODE",
            "state->current_frequency": "== 0",
            "state->current_modulation": "== VSB_8",
            "au8522_writereg(state, 0xa4, 1 << 5)": "== 0",
            "au8522_i2c_gate_ctrl(fe, 1)": "== 0"
        },
    }
},
{
    "kretprobe:au8522_sleep": {
        "description": "Only power down if the digital side is currently using the chip",
        "proto" :"static void (*au8522_sleep)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null",
            "fe->demodulator_priv": "!=null",
            "fe->demodulator_priv->operational_mode": "in [AU8522_ANALOG_MODE, AU8522_DIGITAL_MODE]"
        },
    }
},
{
    "kprobe:au8522_sleep": {
        "description": "Only power down if the digital side is currently using the chip",
        "proto" :"static void (*au8522_sleep)(struct dvb_frontend *fe)",
        "pre": {
            "fe": "!=null",
            "fe->demodulator_priv": "!=null",
            "fe->demodulator_priv->operational_mode": "in [AU8522_ANALOG_MODE, AU8522_DIGITAL_MODE]"
        },
    }
},
{
    "kretprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"zl10353_attach(const struct zl10353_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:zl10353_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct zl10353_state* (*zl10353_attach)(const struct zl10353_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0299_attach(const struct stv0299_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:stv0299_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0299_attach(const struct stv0299_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:tda8083_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"tda8083_attach(const struct tda8083_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocates memory for the internal state.",
        "proto" :"static struct tda8083_state* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
    }
},
{
    "kretprobe:stb6100_attach": {
        "description": "Attach the STB6100 tuner to the DVB frontend.",
        "proto" :"static struct dvb_frontend* (*stb6100_attach)(struct dvb_frontend *fe, const struct stb6100_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:stb6100_attach": {
        "description": "Attach the STB6100 tuner to the DVB frontend.",
        "proto" :"static struct dvb_frontend* (*stb6100_attach)(struct dvb_frontend *fe, const struct stb6100_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "fe": "!=null",
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kretprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0288_attach(const struct stv0288_config  config,    struct i2c_adapter  i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
    }
},
{
    "kprobe:stv0288_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"stv0288_attach(const struct stv0288_config *config, struct i2c_adapter *i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "state": "!=null"
        }
    }
},
{
    "kretprobe:s5h1420_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct s5h1420_state* (*s5h1420_attach)(const struct s5h1420_config* config, struct i2c_adapter* i2c)",
        "pre": {
            "config": "!=null",
            "i2c": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:s5h1420_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"struct s5h1420_state *state = kzalloc(sizeof(struct s5h1420_state), GFP_KERNEL);u8 i;if (state == NULL)goto error;",
        "pre": {
            "state": "!=null",
            "i": "is u8",
        },
    }
},

{
    "kprobe:drx39xxj_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static long (*drx39xxj_attach)(struct i2c_adapter *i2c)",
        "pre": {
            "i2c": "!=null",
            "state": "==null",
            "demod_addr": "==null",
            "demod_comm_attr": "==null",
            "demod_ext_attr": "==null",
            "demod": "==null",
            "p": "undefined",
            "result": "undefined"
        },
    }
},
{
    "kretprobe:fimc_find_remote_sensor": {
        "description": "Find the remote sensor for a given media entity.",
        "proto" :"static struct v4l2_subdev* (*fimc_find_remote_sensor)(struct media_entity *entity)",
        "pre": {
            "entity": "!=null",
            "entity->pads": "!=null",
            "pad->flags": "in [MEDIA_PAD_FL_SINK]",
            "pad->entity": "!=null",
            "is_media_entity_v4l2_subdev(pad->entity)": "==true",
            "sd->grp_id": "in [GRP_ID_FIMC_IS_SENSOR, GRP_ID_SENSOR]"
        },
    }
},
{
    "kprobe:fimc_find_remote_sensor": {
        "description": "PLACEHOLDER_DESCRIPTION",
        "proto" :"static long (*fimc_find_remote_sensor)(struct media_entity *entity)",
        "pre": {
            "entity": "!=null",
        },
    }
},
{
    "kretprobe:mtk_vcodec_wait_for_done_ctx": {
        "description": "Wait for the completion of a command within a specified timeout period.",
        "proto" :"static long (*mtk_vcodec_wait_for_done_ctx)(struct mtk_vcodec_ctx *ctx, int command, unsigned int timeout_ms, unsigned int hw_id)",
        "pre": {
            "ctx": "!=null",
            "command": "is integer",
            "timeout_ms": "is unsigned integer",
            "hw_id": "is unsigned integer"
        },
    }
},
{
    "kprobe:mtk_vcodec_wait_for_done_ctx": {
        "description": "Wait for a specific condition to be met within a given timeout period.",
        "proto" :"static long (*mtk_vcodec_wait_for_done_ctx)(struct mtk_vcodec_ctx ctx, int command, unsigned int timeout_ms, unsigned int hw_id)",
        "pre": {
            "ctx": "!=null",
            "command": "is integer",
            "timeout_ms": "is unsigned integer",
            "hw_id": "is unsigned integer"
        },
    }
},

{
    "kprobe:vdoa_device_run": {
        "description": "Sets up hardware registers for a video device.",
        "proto": "void vdoa_device_run(struct vdoa_ctx *ctx, dma_addr_t dst, dma_addr_t src)",
        "pre": {
            "ctx": "!=null",
            "dst": "valid memory address",
            "src": "valid memory address",
            "ctx->vdoa": "!=null",
            "ctx->q_data[V4L2_M2M_SRC]->pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12, V4L2_PIX_FMT_NV21]",
            "ctx->q_data[V4L2_M2M_DST]->pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12, V4L2_PIX_FMT_NV21]"
        }
    }
},
{
    "kretprobe:vdoa_context_configure": {
        "description": "Configure the context for VDOA (Video Data Order Adapter). If no context is passed, only check if the format is valid.",
        "proto": "int vdoa_context_configure(struct vdoa_ctx *ctx, unsigned int width, unsigned int height, u32 pixelformat)",
        "pre": {
            "ctx": "!=null",
            "width": "in [16, 8192] and width % 16 == 0",
            "height": "in [16, 4096] and height % 16 == 0",
            "pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12]"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:vdoa_context_configure": {
        "description": "Configures the context for VDOA (Video Data Order Adapter).",
        "proto": "int (*vdoa_context_configure)(struct vdoa_ctx *ctx, unsigned int width, unsigned int height, u32 pixelformat)",
        "pre": {
            "ctx": "!=null",
            "width": ">=16 && <=8192 && %16==0",
            "height": ">=16 && <=4096 && %16==0",
            "pixelformat": "in [V4L2_PIX_FMT_YUYV, V4L2_PIX_FMT_NV12]"
        }
    }
},

{
    "kprobe:vpdma_dump_regs": {
        "description": "Dumping registers of only group0 and group3, because VPE channels lie within group0 and group3 registers",
        "proto" :"static void (*vpdma_dump_regs)(struct vpdma_data *vpdma)",
        "pre": {
            "vpdma": "!=null"
        },
        "DUMPREG": {
            "INT_CHAN_STAT(0)": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CHAN_MASK(0)": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CHAN_STAT(3)": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CHAN_MASK(3)": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CLIENT0_STAT": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CLIENT0_MASK": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CLIENT1_STAT": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_CLIENT1_MASK": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_LIST0_STAT": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            },
            "INT_LIST0_MASK": {
                "description": "Your description here",
                "pre": {
                    "Your conditions here"
                }
            }
        }
    }
},
{
    "kretprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list, the user of this list will append configuration, control and data descriptors to this list, this list will be submitted to VPDMA. VPDMA's list parser will go through each descriptor and perform the required DMA operations.",
        "proto" :"int vpdma_create_desc_list(struct vpdma_desc_list *list, size_t size, int type)",
        "pre": {
            "list": "!=null",
            "size": ">0",
            "type": "in [VPDMA_LIST_TYPE_NORMAL, VPDMA_LIST_TYPE_OTHERS]"
        },
    }
},
{
    "kprobe:vpdma_create_desc_list": {
        "description": "Create a descriptor list, the user of this list will append configuration, control and data descriptors to this list, this list will be submitted to VPDMA. VPDMA's list parser will go through each descriptor and perform the required DMA operations.",
        "proto" :"int (*vpdma_create_desc_list)(struct vpdma_desc_list *list, size_t size, int type)",
        "pre": {
            "list": "!=null",
            "size": ">0",
            "type": "in [VPDMA_LIST_TYPE_NORMAL, VPDMA_LIST_TYPE_OTHERS]"
        },
    }
},
{
    "kretprobe:vpdma_update_dma_addr": {
        "description": "Calculate write address from the offset of write_dtd from start of the list->buf",
        "proto" :"void vpdma_update_dma_addr(struct vpdma_data *vpdma, struct vpdma_desc_list *list, dma_addr_t dma_addr, void *write_dtd, int drop, int idx)",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "in [0, 1]",
            "idx": ">=0"
        },
    }
},
{
    "kprobe:vpdma_update_dma_addr": {
        "description": "Calculate write address from the offset of write_dtd from start of the list->buf",
        "proto" :"vpdma_update_dma_addr(struct vpdma_data  vpdma,struct vpdma_desc_list  list, dma_addr_t dma_addr,void  write_dtd, int drop, int idx)",
        "pre": {
            "vpdma": "!=null",
            "list": "!=null",
            "dma_addr": "!=null",
            "write_dtd": "!=null",
            "drop": "is int",
            "idx": "is int"
        },
    }
},
{
    "kretprobe:sc_set_hs_coeffs": {
        "description": "Your function description here.",
        "proto" :"sc_set_hs_coeffs(struct sc_data  sc, void  addr, unsigned int src_w,unsigned int dst_w)",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "is a positive integer",
            "dst_w": "is a positive integer",
        },
    }
},
{
    "kprobe:sc_set_hs_coeffs": {
        "description": "This function appears to be related to image scaling. It calculates the scaling coefficients based on the source and destination widths.",
        "proto": "void sc_set_hs_coeffs(struct sc_data sc, void *addr, unsigned int src_w, unsigned int dst_w)",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_w": "is a positive integer",
            "dst_w": "is a positive integer"
        }
    }
},
{
    "kretprobe:sc_set_vs_coeffs": {
        "description": "This function seems to set vertical scaler coefficients, but the exact details are unclear due to the malformed function.",
        "proto" :"static long (*sc_set_vs_coeffs)(struct sc_data sc, void addr, unsigned int src_h, unsigned int dst_h)",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "is a positive integer",
            "dst_h": "is a positive integer"
        },
    }
},
{
    "kprobe:sc_set_vs_coeffs": {
        "description": "This function sets the vertical scaler coefficients. The exact behavior depends on the relationship between the source and destination heights.",
        "proto" :"static void (*sc_set_vs_coeffs)(struct sc_data *sc, void *addr, unsigned int src_h, unsigned int dst_h)",
        "pre": {
            "sc": "!=null",
            "addr": "!=null",
            "src_h": "is a valid height",
            "dst_h": "is a valid height"
        },
    }
},

{
    "kprobe:sc_config_scaler": {
        "description": "Description of the function goes here",
        "proto" :"static long (*sc_config_scaler)(struct sc_data *sc, u32 sc_reg0, u32 sc_reg8, u32 sc_reg17, unsigned int src_w, unsigned int src_h, unsigned int dst_w, unsigned int dst_h)",
        "pre": {
            "sc": "!=null",
            "sc_reg0": "constraint goes here",
            "sc_reg8": "constraint goes here",
            "sc_reg17": "constraint goes here",
            "src_w": "constraint goes here",
            "src_h": "constraint goes here",
            "dst_w": "constraint goes here",
            "dst_h": "constraint goes here"
        },
    }
},
{
    "kretprobe:vpif_set_video_params": {
        "description": "This function is used to set video parameters in VPIF register",
        "proto" :"int (*vpif_set_video_params)(struct vpif_params *vpifparams, u8 channel_id)",
        "pre": {
            "vpifparams": "!=null",
            "channel_id": "in [0, 255]"
        }
    }
},
{
    "kprobe:vpif_set_video_params": {
        "description": "This function is used to set video parameters in VPIF register.",
        "proto" :"int (*vpif_set_video_params)(struct vpif_params *vpifparams, u8 channel_id)",
        "pre": {
            "vpifparams": "!=null",
            "channel_id": "in [0, 255]"
        }
    }
},
{
    "kretprobe:cx18_claim_stream": {
        "description": "Nothing should ever try to directly claim the IDX stream.",
        "proto" :"cx18_claim_stream(struct cx18_open_id  id, int type)",
        "pre": {
            "id": "!=null",
            "type": "!= CX18_ENC_STREAM_TYPE_IDX"
        }
    }
},
{
    "kprobe:cx18_claim_stream": {
        "description": "Nothing should ever try to directly claim the IDX stream.",
        "proto" :"cx18_claim_stream(struct cx18_open_id  id, int type)",
        "pre": {
            "id": "!=null",
            "type": "in [CX18_ENC_STREAM_TYPE_IDX, ...]",
        },
    }
},
{
    "kretprobe:cx18_release_stream": {
        "description": "The IDX stream is only used internally, and can only be indirectly unclaimed by unclaiming the MPG stream.",
        "proto" :"static void (*cx18_release_stream)(struct cx18_stream *s, struct cx18 *cx, struct cx18_stream *s_assoc)",
        "pre": {
            "s": "!=null",
            "cx": "!=null",
            "s_assoc": "!=null"
        },
    }
},
{
    "kprobe:cx18_release_stream": {
        "description": "The IDX stream is only used internally, and can only be indirectly unclaimed by unclaiming the MPG stream.",
        "proto" :"static void (*cx18_release_stream)(struct cx18_stream *s)",
        "pre": {
            "s": "!=null",
            "s->type": "in [CX18_ENC_STREAM_TYPE_IDX, CX18_ENC_STREAM_TYPE_VBI]",
            "s->s_flags": "has_bit_set(CX18_F_S_INTERNAL_USE)"
        }
    }
},
{
    "kretprobe:cx18_start_v4l2_encode_stream": {
        "description": "Starts the encoder stream based on the stream type.",
        "proto" :"int cx18_start_v4l2_encode_stream(struct cx18_stream *s)",
        "pre": {
            "s": "!=null",
            "s->type": "in [CX18_ENC_STREAM_TYPE_MPG, CX18_ENC_STREAM_TYPE_IDX, CX18_ENC_STREAM_TYPE_TS, CX18_ENC_STREAM_TYPE_YUV, CX18_ENC_STREAM_TYPE_PCM, CX18_ENC_STREAM_TYPE_VBI]"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:cx18_start_v4l2_encode_stream": {
        "description": "Starts the encoder stream based on the stream type.",
        "proto" :"int cx18_start_v4l2_encode_stream(struct cx18_stream *s)",
        "pre": {
            "s": "!=null",
            "s->type": "in [CX18_ENC_STREAM_TYPE_MPG, CX18_ENC_STREAM_TYPE_IDX, CX18_ENC_STREAM_TYPE_TS, CX18_ENC_STREAM_TYPE_YUV, CX18_ENC_STREAM_TYPE_PCM, CX18_ENC_STREAM_TYPE_VBI]",
        },
    }
},
{
    "kretprobe:cx18_stop_v4l2_encode_stream": {
        "description": "This function assumes that you are allowed to stop the capture and that we are actually capturing.",
        "proto" :"int cx18_stop_v4l2_encode_stream(struct cx18_stream  s, int gop_end)",
        "pre": {
            "s": "!=null",
            "gop_end": "is integer"
        },
    }
},
{
    "kprobe:cx18_stop_v4l2_encode_stream": {
        "description": "This function assumes that you are allowed to stop the capture and that we are actually capturing.",
        "proto" :"int cx18_stop_v4l2_encode_stream(struct cx18_stream  s, int gop_end)",
        "pre": {
            "s": "!=null",
            "gop_end": "is integer",
        },
    }
},
{
    "kretprobe:cx88_risc_buffer": {
        "description": "Estimate risc mem: worst case is one write per page border + one write per scan line + syncs + jump (all 2 dwords). Padding can cause next bpl to start close to a page border. First DMA region may be smaller than PAGE_SIZE.",
        "proto" :"cx88_risc_buffer(struct pci_dev  pci, struct cx88_riscmem  risc, struct scatterlist  sglist, unsigned int top_offset, unsigned int bottom_offset, unsigned int bpl, unsigned int padding, unsigned int lines)",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "top_offset": "!=UNSET",
            "bottom_offset": "!=UNSET",
            "bpl": ">=0",
            "padding": ">=0",
            "lines": ">=0"
        },
    }
},
{
    "kprobe:cx88_risc_buffer": {
        "description": "Estimate RISC memory, allocate memory for instructions, and check if the memory allocation was successful.",
        "proto" :"cx88_risc_buffer(struct pci_dev  pci, struct cx88_riscmem  risc, struct scatterlist  sglist, unsigned int top_offset, unsigned int bottom_offset, unsigned int bpl, unsigned int padding, unsigned int lines)",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "top_offset": "in [UNSET, PAGE_SIZE]",
            "bottom_offset": "in [UNSET, PAGE_SIZE]",
            "bpl": ">0",
            "padding": ">=0",
            "lines": ">0"
        },
    }
},

{
    "kprobe:cx88_risc_databuffer": {
        "description": "Estimate risc mem: worst case is one write per page border + one write per scan line + syncs + jump (all 2 dwords). Here there is no padding and no sync. First DMA region may be smaller than PAGE_SIZE.",
        "proto" :"cx88_risc_databuffer(struct pci_dev  pci, struct cx88_riscmem  risc, struct scatterlist  sglist, unsigned int bpl, unsigned int lines, unsigned int lpi)",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": ">=0",
            "lines": ">=0",
            "lpi": ">=0"
        },
    }
},


{
    "kretprobe:cx88_sram_channel_setup": {
        "description": "Your function description here",
        "proto" :"static long (*cx88_sram_channel_setup)(struct cx88_core *core, const struct sram_channel *ch, unsigned int bpl, u32 risc)",
        "pre": {
            "core": "!=null",
            "ch": "!=null",
            "bpl": ">=0",
            "risc": ">=0",
        },
    }
},

{
    "kretprobe:cx_write": {
        "description": "Stop DMA transfers by disabling RISC controller + IRQs",
        "proto" :"static void (*cx_write)(MO_DEV_CNTRL2, 0)",
        "pre": {
            "MO_DEV_CNTRL2": "!=null",
            "0": "is constant"
        },
    }
},
{
    "kprobe:cx_write": {
        "description": "Stop DMA transfers by disabling RISC controller + IRQs",
        "proto" :"static void (*cx_write)(int MO_DEV_CNTRL2, int value)",
        "pre": {
            "MO_DEV_CNTRL2": "is a valid device control register",
            "value": "==0",
        },
    }
},


{
    "kretprobe:cx88_set_scale": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1 here",
            "param2": "Your condition for param2 here",
            "param3": "Your condition for param3 here",
            "...": "Add more parameters as needed"
        },
    }
},



{
    "kretprobe:cx88_vdev_init": {
        "description": "The dev pointer of v4l2_device is NULL, instead we set the video_device dev_parent pointer to the correct PCI bus device. This driver is a rare example where there is one v4l2_device, but the video nodes have different parent (PCI) devices.",
        "proto" :"void cx88_vdev_init(struct cx88_core *core, struct pci_dev *pci, struct video_device *vfd, const struct video_device *template_, const char *type)",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null"
        },
    }
},
{
    "kprobe:cx88_vdev_init": {
        "description": "The dev pointer of v4l2_device is NULL, instead we set the video_device dev_parent pointer to the correct PCI bus device. This driver is a rare example where there is one v4l2_device, but the video nodes have different parent (PCI) devices.",
        "proto" :"void cx88_vdev_init(struct cx88_core *core, struct pci_dev *pci, struct video_device *vfd, const struct video_device *template_, const char *type)",
        "pre": {
            "core": "!=null",
            "pci": "!=null",
            "vfd": "!=null",
            "template_": "!=null",
            "type": "!=null"
        },
    }
},


{
    "kretprobe:cx8802_buf_queue": {
        "description": "Add jump to start",
        "proto" :"static void (*cx8802_buf_queue)(struct cx8802_dev *dev, struct cx88_buffer *buf)",
        "pre": {
            "dev": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:cx8802_buf_queue": {
        "description": "Add jump to start",
        "proto" :"void cx8802_buf_queue(struct cx8802_dev *dev, struct cx88_buffer *buf)",
        "pre": {
            "dev": "!=null",
            "buf": "!=null"
        },
        "operations": {
            "buf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 8)": {
                "pre": {
                    "buf->risc.cpu[1]": "can be assigned",
                    "buf->risc.dma": "!=null"
                }
            },
            "buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC)": {
                "pre": {
                    "buf->risc.jmp[0]": "can be assigned"
                }
            },
            "buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 8)": {
                "pre": {
                    "buf->risc.jmp[1]": "can be assigned",
                    "buf->risc.dma": "!=null"
                }
            },
            "if (list_empty(&cx88q->active))": {
                "pre": {
                    "cx88q->active": "is a valid list"
                }
            }
        }
    }
},
{
    "kretprobe:cx8802_register_driver": {
        "description": "Register a cx8802 driver, check if the driver is valid, and bring up a new struct for each driver instance.",
        "proto" :"int (*cx8802_register_driver)(struct cx8802_driver *drv)",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},

{
    "kretprobe:cx8802_unregister_driver": {
        "description": "Unregister the cx8802 driver, only unregister the correct driver type.",
        "proto" :"static int (*cx8802_unregister_driver)(struct cx8802_driver *drv)",
        "pre": {
            "drv": "!=null",
            "drv->type_id": "in [CX88_MPEG_DVB, BLACKBIRD]",
            "drv->hw_access": "in [CX8802_DRVCTL_SHARED, CX8802_DRVCTL_EXCLUSIVE]"
        },
        "post": {
            "err": "==0"
        }
    }
},

{
    "kretprobe:set_audio_standard_A2": {
        "description": "Set the audio standard to A2.",
        "proto" :"void set_audio_standard_A2(struct cx88_core *core, int mode)",
        "pre": {
            "core": "!=null",
            "mode": "==EN_A2_FORCE_MONO1",
        },
    }
},

{
    "kretprobe:cx88_get_stereo": {
        "description": "Get the stereo mode and pilot signal of the cx88 core.",
        "proto" :"static void (*cx88_get_stereo)(struct cx88_core *core, struct v4l2_tuner *t)",
        "pre": {
            "core": "!=null",
            "t": "!=null"
        }
    }
},
{
    "kprobe:cx88_get_stereo": {
        "description": "Get the stereo mode and pilot signal of the cx88 core.",
        "proto" :"static void cx88_get_stereo(struct cx88_core  core, struct v4l2_tuner  t)",
        "pre": {
            "core": "!=null",
            "t": "!=null"
        },
    }
},
{
    "kretprobe:set_audio_standard_A2": {
        "description": "Description of the function",
        "proto" :"static long (*set_audio_standard_A2)(type1 core, type2 EN_A2_FORCE_MONO1)",
        "pre": {
            "core": "!=null",
            "EN_A2_FORCE_MONO1": "!=null"
        }
    }
},
{
    "kprobe:cx88_set_stereo": {
        "description": "Sets the stereo mode for the cx88 core.",
        "proto" :"static void (*cx88_set_stereo)(struct cx88_core *core, u32 mode, int manual)",
        "pre": {
            "core": "!=null",
            "mode": "in [V4L2_TUNER_MODE_MONO, V4L2_TUNER_MODE_LANG1, V4L2_TUNER_MODE_LANG2, V4L2_TUNER_MODE_STEREO, V4L2_TUNER_MODE_LANG1_LANG2]",
            "manual": "is boolean",
        },
    }
},


{
    "kretprobe:cx_write": {
        "description": "Write a value to a specific IO port.",
        "proto" :"void cx_write(int MO_DDSCFG_IO, int value)",
        "pre": {
            "MO_DDSCFG_IO": "==5",
            "value": ">=0",
        },
    }
},

{
    "kretprobe:cx88_video_mux": {
        "description": "Please fill in the description here",
        "proto" :"static void cx88_video_mux(struct cx88_core *core, unsigned int input)",
        "pre": {
            "core": "!=null",
            "input": "Please fill in the condition for input here"
        }
    }
},
{
    "kprobe:cx88_video_mux": {
        "description": "Description of the function",
        "proto" :"static long (*cx88_video_mux)(struct cx88_core *core, unsigned int input)",
        "pre": {
            "core": "!=null",
            "input": "!=null",
            // Add other preconditions here
        },
        "post": {
            // Add postconditions here
        }
    }
},
{
    "kretprobe:cx88_set_freq": {
        "description": "When changing channels it is required to reset TVAUDIO",
        "proto" :"static long (*cx88_set_freq)(struct cx88_core *core, const struct v4l2_frequency *f)",
        "pre": {
            "core": "!=null",
            "f": "!=null",
            "core->board.tuner_type": "!=UNSET",
            "f->tuner": "==0"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:cx88_set_freq": {
        "description": "When changing channels it is required to reset TVAUDIO",
        "proto" :"static long (*cx88_set_freq)(struct cx88_core core, const struct v4l2_frequency f)",
        "pre": {
            "core": "!=null",
            "f": "!=null",
            "core->board.tuner_type": "!= UNSET",
            "f->tuner": "== 0"
        },
    }
},
{
    "kretprobe:cx88_dsp_detect_stereo_sap": {
        "description": "If audio RDS fifo is disabled, we can't read the samples",
        "proto" :"cx88_dsp_detect_stereo_sap(struct cx88_core  core)",
        "pre": {
            "core": "!=null"
        }
    }
},
{
    "kprobe:cx88_dsp_detect_stereo_sap": {
        "description": "If audio RDS fifo is disabled, we can't read the samples",
        "proto" :"cx88_dsp_detect_stereo_sap(struct cx88_core  core)",
        "pre": {
            "core": "!=null",
        },
    }
},
{
    "kretprobe:ivtv_start_v4l2_encode_stream": {
        "description": "Starts the encoder stream and checks if the output mode is set to OUT_PASSTHROUGH.",
        "proto" :"int ivtv_start_v4l2_encode_stream(struct ivtv_stream *s)",
        "pre": {
            "s": "!=null",
            "s->itv": "!=null",
            "s->itv->output_mode": "in [OUT_PASSTHROUGH, OTHER_MODES]",
        },
        "post": {
            "return": "in [-EINVAL, OTHER_POSSIBLE_RETURN_VALUES]"
        }
    }
},
{
    "kprobe:ivtv_start_v4l2_encode_stream": {
        "description": "Starts the encoder stream",
        "proto" :"int ivtv_start_v4l2_encode_stream(struct ivtv_stream *s)",
        "pre": {
            "s": "!=null",
            "s->itv": "!=null",
            "s->itv->output_mode": "in [OUT_PASSTHROUGH, ...]" // other possible values need to be filled in
        },
    }
},


{
    "kretprobe:ivtv_claim_stream": {
        "description": "Claims a stream if it has not been claimed yet.",
        "proto" :"static int (*ivtv_claim_stream)(struct ivtv_open_id *id, int type)",
        "pre": {
            "id": "!=null",
            "type": "in [valid stream types]",
            "id->itv": "!=null",
            "id->itv->streams[type]": "!=null",
            "id->fh": "!=null",
            "id->itv->streams[type]->fh": "!=null"
        },
    }
},
{
    "kprobe:ivtv_claim_stream": {
        "description": "Claims a stream if it has not been claimed yet.",
        "proto" :"static int (*ivtv_claim_stream)(struct ivtv_open_id *id, int type)",
        "pre": {
            "id": "!=null",
            "type": "in [valid stream types]",
            "id->fh": "!=null",
            "id->itv": "!=null",
            "id->itv->streams[type]": "!=null",
            "id->itv->streams[type]->fh": "!=null"
        },
    }
},
{
    "kretprobe:ivtv_release_stream": {
        "description": "Releases a stream if it is not in use internally.",
        "proto" :"static void (*ivtv_release_stream)(struct ivtv_stream *s)",
        "pre": {
            "s": "!=null",
            "s->itv": "!=null",
            "s->type": "in [IVTV_DEC_STREAM_TYPE_VBI, IVTV_ENC_STREAM_TYPE_VBI]",
            "s->s_flags": "bitwise_and(IVTV_F_S_INTERNAL_USE) == 0"
        },
    }
},
{
    "kprobe:ivtv_release_stream": {
        "description": "Releases a stream if it is not in use internally.",
        "proto" :"static void (*ivtv_release_stream)(struct ivtv_stream *s)",
        "pre": {
            "s": "!=null",
            "s->itv": "!=null",
            "s->type": "in [IVTV_DEC_STREAM_TYPE_VBI, IVTV_ENC_STREAM_TYPE_VBI]",
            "s->s_flags": "bit set [IVTV_F_S_INTERNAL_USE]"
        },
    }
},


{
    "kretprobe:ivtv_setup_pci": {
        "description": "PCI Device Setup",
        "proto" :"static int (*ivtv_setup_pci)(struct ivtv *itv, struct pci_dev *pdev, const struct pci_device_id *pci_id)",
        "pre": {
            "itv": "!=null",
            "pdev": "!=null",
            "pci_id": "!=null"
        },
        "post": {
            "retval": "in [-EIO, -ENXIO]"
        }
    }
},
{
    "kprobe:ivtv_setup_pci": {
        "description": "PCI Device Setup",
        "proto" :"static int (*ivtv_setup_pci)(struct ivtv *itv, struct pci_dev *pdev, const struct pci_device_id *pci_id)",
        "pre": {
            "itv": "!=null",
            "pdev": "!=null",
            "pci_id": "!=null"
        },
    }
},


{
    "kretprobe:ivtv_init_on_first_open": {
        "description": "Needed to call ioctls later",
        "proto" :"static long (*ivtv_init_on_first_open)(struct ivtv itv)",
        "pre": {
            "itv": "!=null"
        }
    }
},
{
    "kprobe:ivtv_init_on_first_open": {
        "description": "Needed to call ioctls later",
        "proto" :"static long (*ivtv_init_on_first_open)(struct ivtv *itv)",
        "pre": {
            "itv": "!=null",
        },
    }
},
{
    "kretprobe:cx25821_set_gpiopin_direction": {
        "description": "Set the direction of the GPIO pin on the cx25821 device.",
        "proto" :"static void (*cx25821_set_gpiopin_direction)(struct cx25821_dev *dev, int pin_number, int pin_logic_value)",
        "pre": {
            "dev": "!=null",
            "pin_number": "<47 && >=0",
            "pin_logic_value": "in [0, 1]"
        },
        "post": {
            "return": "in [void]"
        }
    }
},
{
    "kprobe:cx25821_set_gpiopin_direction": {
        "description": "Set the direction of the GPIO pin on the cx25821 device.",
        "proto" :"static void (*cx25821_set_gpiopin_direction)(struct cx25821_dev *dev, int pin_number, int pin_logic_value)",
        "pre": {
            "dev": "!=null",
            "pin_number": "in [0, 46]",
            "pin_logic_value": "in [0, 1]"
        },
    }
},
{
    "kretprobe:cx25821_sram_channel_setup_audio": {
        "description": "This function sets up the audio channel for the cx25821 device.",
        "proto" :"static long (*cx25821_sram_channel_setup_audio)(struct cx25821_dev *dev, const struct sram_channel *ch, unsigned int bpl, u32 risc)",
        "pre": {
            "dev": "!=null",
            "ch": "!=null",
            "bpl": ">=0",
            "risc": ">=0"
        },
    }
},

{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            "[parameter3]": "[condition3]",
            "[parameter4]": "[condition4]",
        },
    }
},
{
    "kprobe:cx25821_sram_channel_dump_audio": {
        "description": "This function dumps the status of the dma Audio channel.",
        "proto" :"void cx25821_sram_channel_dump_audio(struct cx25821_dev *dev, const struct sram_channel *ch)",
        "pre": {
            "dev": "!=null",
            "ch": "!=null"
        },
    }
},

{
    "kprobe:cx25821_dev_unregister": {
        "description": "Unregister the cx25821 device and release the memory region associated with it. Also, free up the memory upstream for certain channels.",
        "proto" :"static void (*cx25821_dev_unregister)(struct cx25821_dev *dev)",
        "pre": {
            "dev": "!=null",
            "dev->base_io_addr": "!=null",
            "i": "in [0, MAX_VID_CAP_CHANNEL_NUM - 1]",
            "SRAM_CH08": "audio channel"
        },
    }
},

{
    "kprobe:cx25821_risc_databuffer_audio": {
        "description": "Estimate risc mem: worst case is one write per page border + one write per scan line + syncs + jump (all 2 dwords). Here there is no padding and no sync. First DMA region may be smaller than PAGE_SIZE.",
        "proto" :"cx25821_risc_databuffer_audio(struct pci_dev  pci,  struct cx25821_riscmem  risc,  struct scatterlist  sglist,  unsigned int bpl,  unsigned int lines, unsigned int lpi)",
        "pre": {
            "pci": "!=null",
            "risc": "!=null",
            "sglist": "!=null",
            "bpl": ">=0",
            "lines": ">=0",
            "lpi": ">=0"
        },
    }
},
{
    "kretprobe:altera_ci_init": {
        "description": "Initializes the Altera CI with the given configuration and CI number.",
        "proto" :"altera_ci_init(struct altera_ci_config  config, int ci_nr)",
        "pre": {
            "config": "!=null",
            "ci_nr": ">=0"
        },
    }
},

{
    "kretprobe:dst_attach": {
        "description": "Check if the ASIC is there",
        "proto" :"static int (*dst_attach)(struct dst_state *state, struct dvb_adapter *dvb_adapter)",
        "pre": {
            "state": "!=null",
            "dvb_adapter": "!=null"
        },
    }
},
{
    "kprobe:dst_attach": {
        "description": "Check if the ASIC is there",
        "proto" :"static int (*dst_attach)(struct dst_state *state, struct dvb_adapter *dvb_adapter)",
        "pre": {
            "state": "!=null",
            "dvb_adapter": "!=null"
        },
        "post": {
            "dst_probe(state)": "< 0"
        }
    }
},


{
    "kretprobe:bt878_start": {
        "description": "Complete the writing of the risc dma program now we have the card specifics.",
        "proto" :"static long (*bt878_start)(struct bt878 bt, u32 controlreg, u32 op_sync_orin, u32 irq_err_ignore)",
        "pre": {
            "bt": "!=null",
            "controlreg": "in [0x1b, 0x1f]",
            "op_sync_orin": "!=null",
            "irq_err_ignore": "!=null"
        },
    }
},

{
    "kretprobe:sof_ipc3_do_rx_work": {
        "description": "Process the received message and check its type.",
        "proto" :"static void (*sof_ipc3_do_rx_work)(struct snd_sof_dev *sdev, struct sof_ipc_cmd_hdr *hdr, void *msg_buf)",
        "pre": {
            "sdev": "!=null",
            "hdr": "!=null",
            "msg_buf": "!=null",
            "hdr->size": ">= sizeof(hdr) && <= SOF_IPC_MSG_MAX_SIZE",
            "cmd": "in [SOF_GLB_TYPE_MASK]"
        },
    }
},

{
    "kretprobe:ddbridge_dummy_fe_qam_attach": {
        "description": "Allocate memory for the internal state",
        "proto" :"static struct ddbridge_dummy_fe_state* (*ddbridge_dummy_fe_qam_attach)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static void* (*kzalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "sizeof(struct ddbridge_dummy_fe_state)",
            "flags": "GFP_KERNEL",
        },
        "post": {
            "state": "!=null"
        }
    }
},


{
    "kretprobe:media_device_for_each_entity": {
        "description": "Iterates over each entity in a media device.",
        "proto" :"static void (*media_device_for_each_entity)(struct media_entity *entity, struct media_device *dev->media_dev)",
        "pre": {
            "entity": "!=null",
            "dev->media_dev": "!=null"
        }
    }
},



{
    "kretprobe:saa7134_buffer_queue": {
        "description": "Description of the function goes here",
        "proto" :"int saa7134_buffer_queue(struct saa7134_dev *dev, struct saa7134_dmaqueue *q, struct saa7134_buf *buf)",
        "pre": {
            "dev": "!=null",
            "q": "!=null",
            "buf": "!=null"
        }
    }
},
{
    "kprobe:saa7134_buffer_queue": {
        "description": "Description of the function goes here",
        "proto" :"int (*saa7134_buffer_queue)(struct saa7134_dev *dev, struct saa7134_dmaqueue *q, struct saa7134_buf *buf)",
        "pre": {
            "dev": "!=null",
            "q": "!=null",
            "buf": "!=null"
        }
    }
},


{
    "kretprobe:card": {
        "description": "Checks if the device has a GPIO mask set.",
        "proto" :"static int (*card)(struct device *dev)",
        "pre": {
            "dev": "!=null",
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:if (0 != card(dev).gpiomask)": {
        "description": "Description of the function goes here",
        "proto" :"Prototype of the function goes here",
        "pre": {
            "dev": "!=null",
            "gpiomask": "!=0",
        },
    }
},
{
    "kretprobe:saa7134_tvaudio_setmute": {
        "description": "Find the exact tv audio norm",
        "proto" :"static long (*saa7134_tvaudio_setmute)(void *dev)",
        "pre": {
            "dev": "!=null",
        },
    }
},
{
    "kprobe:saa7134_tvaudio_setmute": {
        "description": "Find the exact tv audio norm and set mute.",
        "proto" :"static void (*saa7134_tvaudio_setmute)(struct saa7134_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},



{
    "kprobe:snd_tea575x_s_hw_freq_seek": {
        "description": "This function seeks the hardware frequency. It checks if the band of the snd_tea575x object is not equal to the current index i.",
        "proto" :"int snd_tea575x_s_hw_freq_seek(struct file  file, struct snd_tea575x  tea,const struct v4l2_hw_freq_seek  a)",
        "pre": {
            "i": "in [0, ARRAY_SIZE(bands)-1]",
            "tea->band": "in [0, ARRAY_SIZE(bands)-1]",
            "condition": "i != tea->band"
        },
    }
},
{
    "kretprobe:snd_tea575x_hw_init": {
        "description": "Initializes the snd_tea575x hardware. If the device cannot or does not know how to read the data back, it sets cannot_read_data to true.",
        "proto" :"static void (*snd_tea575x_hw_init)(struct snd_tea575x *tea)",
        "pre": {
            "tea": "!=null",
            "tea->cannot_read_data": "==false"
        },
    }
},
{
    "kprobe:snd_tea575x_hw_init": {
        "description": "Initializes the snd_tea575x hardware. Sets mute to true. Not all devices can or know how to read the data back. Such devices can set cannot_read_data to true.",
        "proto" :"void snd_tea575x_hw_init(struct snd_tea575x *tea)",
        "pre": {
            "tea": "!=null",
            "tea->cannot_read_data": "in [true, false]"
        }
    }
},
{
    "kretprobe:snd_tea575x_init": {
        "description": "Initializes the snd_tea575x structure and sets up the video device. Disables hw_freq_seek if cannot_read_data is true.",
        "proto" :"int snd_tea575x_init(struct snd_tea575x *tea, struct module *owner)",
        "pre": {
            "tea": "!=null",
            "owner": "!=null",
            "tea->cannot_read_data": "in [true, false]",
            "tea->cannot_mute": "in [true, false]"
        },
    }
},
{
    "kprobe:snd_tea575x_init": {
        "description": "Initializes the snd_tea575x structure and sets up the video device. Disables hw_freq_seek if cannot_read_data is true.",
        "proto" :"int snd_tea575x_init(struct snd_tea575x *tea, struct module *owner)",
        "pre": {
            "tea": "!=null",
            "owner": "!=null",
            "tea->cannot_read_data": "in [true, false]",
            "tea->cannot_mute": "in [true, false]"
        },
    }
},
{
    "kretprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Manchester modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using Manchester (bi-phase) modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto": "int ir_raw_gen_manchester(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_manchester *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kprobe:ir_raw_gen_manchester": {
        "description": "Encode data with Manchester (bi-phase) modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Manchester modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using Manchester (bi-phase) modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto" :"int ir_raw_gen_manchester(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_manchester *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Pulse distance modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using pulse-distance modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto" :"int ir_raw_gen_pd(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_pd *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">=0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        },
    }
},
{
    "kprobe:ir_raw_gen_pd": {
        "description": "Encode data to raw events with pulse-distance modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Pulse distance modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using pulse-distance modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto" :"int ir_raw_gen_pd(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_pd *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Pulse distance modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using space-distance modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto": "int ir_raw_gen_pl(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_pl *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kprobe:ir_raw_gen_pl": {
        "description": "Encode data to raw events with pulse-length modulation. @ev:Pointer to pointer to next free event. @ev is incremented for each raw event filled. @max:Maximum number of raw events to fill. @timings:Pulse distance modulation timings. @n:Number of bits of data. @data:Data bits to encode. Encodes the @n least significant bits of @data using space-distance modulation with the timing characteristics described by @timings, writing up to @max raw IR events using the @ev pointer. Returns:0 on success. -ENOBUFS if there isn't enough space in the array to fit the full encoded data. In this case all @max events will have been written.",
        "proto" :"int ir_raw_gen_pl(struct ir_raw_event **ev, unsigned int max, const struct ir_raw_timings_pl *timings, unsigned int n, u64 data)",
        "pre": {
            "ev": "!=null",
            "max": ">0",
            "timings": "!=null",
            "n": ">=0",
            "data": ">=0"
        }
    }
},
{
    "kretprobe:ir_raw_encode_scancode": {
        "description": "Attempts to encode the scancode as raw events. Returns: The number of events written. -ENOBUFS if there isn't enough space in the array to fit the encoding. In this case all @max events will have been written. -EINVAL if the scancode is ambiguous or invalid, or if no compatible encoder was found.",
        "proto" :"int ir_raw_encode_scancode(enum rc_proto protocol, u32 scancode, struct ir_raw_event *events, unsigned int max)",
        "pre": {
            "protocol": "!=null",
            "scancode": "!=null",
            "events": "!=null",
            "max": "> 0"
        },
    }
},
{
    "kprobe:ir_raw_encode_scancode": {
        "description": "Attempts to encode the scancode as raw events. Returns: The number of events written. -ENOBUFS if there isn't enough space in the array to fit the encoding. In this case all @max events will have been written. -EINVAL if the scancode is ambiguous or invalid, or if no compatible encoder was found.",
        "proto" :"int (*ir_raw_encode_scancode)(enum rc_proto protocol, u32 scancode, struct ir_raw_event *events, unsigned int max)",
        "pre": {
            "protocol": "in [RC_PROTO_UNKNOWN, RC_PROTO_OTHER, RC_PROTO_RC5, RC_PROTO_RC5X_20, RC_PROTO_RC5_SZ, RC_PROTO_RC6_MCE, RC_PROTO_RC6_6A_20, RC_PROTO_RC6_6A_24, RC_PROTO_RC6_6A_32, RC_PROTO_RC6_6A_36, RC_PROTO_RC6_6A_40, RC_PROTO_JVC, RC_PROTO_SONY12, RC_PROTO_SONY15, RC_PROTO_SONY20, RC_PROTO_NECX, RC_PROTO_SANYO, RC_PROTO_MCIR_2, RC_PROTO_RC6_0, RC_PROTO_SHARP, RC_PROTO_XMP]",
            "scancode": ">=0",
            "events": "!=null",
            "max": ">0"
        }
    }
},
{
    "kretprobe:ir_raw_encode_carrier": {
        "description": "Attempts to find the carrier for the specified protocol. Returns the carrier in Hz. Returns -EINVAL if the protocol is invalid, or if no compatible encoder was found.",
        "proto" :"int (*ir_raw_encode_carrier)(enum rc_proto protocol)",
        "pre": {
            "protocol": "in [RC_PROTO_UNKNOWN, RC_PROTO_OTHER, RC_PROTO_RC5, RC_PROTO_RC5X_1, RC_PROTO_RC5_SZ, RC_PROTO_RC6_0, RC_PROTO_RC6_6A_20, RC_PROTO_RC6_6A_24, RC_PROTO_RC6_6A_32, RC_PROTO_RC6_MCE, RC_PROTO_JVC, RC_PROTO_SONY12, RC_PROTO_SONY15, RC_PROTO_SONY20, RC_PROTO_NECX, RC_PROTO_SANYO, RC_PROTO_MCIR_2, RC_PROTO_RCMM32]"
        },
        "post": {
            "return": "in [0, INT_MAX] or == -EINVAL"
        }
    }
},
{
    "kprobe:ir_raw_encode_carrier": {
        "description": "Attempts to find the carrier for the specified protocol. Returns the carrier in Hz. Returns -EINVAL if the protocol is invalid, or if no compatible encoder was found.",
        "proto" :"int (*ir_raw_encode_carrier)(enum rc_proto protocol)",
        "pre": {
            "protocol": "in [RC_PROTO_UNKNOWN, RC_PROTO_OTHER, RC_PROTO_RC5, RC_PROTO_RC5X_1, RC_PROTO_RC5_SZ, RC_PROTO_RC6_0, RC_PROTO_RC6_6A_20, RC_PROTO_RC6_6A_24, RC_PROTO_RC6_6A_32, RC_PROTO_RC6_MCE, RC_PROTO_JVC, RC_PROTO_SONY12, RC_PROTO_SONY15, RC_PROTO_SONY20, RC_PROTO_NECX, RC_PROTO_SANYO, RC_PROTO_MCIR_2, RC_PROTO_RCMM32, RC_PROTO_RCMM24, RC_PROTO_RCMM12, RC_PROTO_XMP]"
        },
        "post": {
            "return": "in [carrier frequency in Hz, -EINVAL]"
        }
    }
},
{
    "kretprobe:usb_cypress_writemem": {
        "description": "Write data to the specified memory address of the Cypress device.",
        "proto" :"int usb_cypress_writemem(struct usb_device *udev, int cs_reg, void *data, int size)",
        "pre": {
            "udev": "!=null",
            "cs_reg": ">=0",
            "data": "!=null",
            "size": "==1"
        },
        "post": {
            "ret": "==1"
        }
    }
},
{
    "kprobe:usb_cypress_writemem": {
        "description": "Write data to a specific memory location in the Cypress USB device.",
        "proto" :"int (*usb_cypress_writemem)(struct usb_device *udev, int cs_reg, void *data, int size)",
        "pre": {
            "udev": "!=null",
            "cs_reg": ">=0",
            "data": "!=null",
            "size": "==1"
        },
    }
},
{
    "kretprobe:tveeprom_hauppauge_analog": {
        "description": "The hauppauge eeprom format is tagged. In our (ivtv) case we're interested in the following: tuner type, tuner fmts, radio, audio proc, decoder proc, model, revision, serial#, # of inputsoutputs.",
        "proto" :"tveeprom_hauppauge_analog(struct tveeprom  tvee, unsigned char  eeprom_data)",
        "pre": {
            "tvee": "!=null",
            "eeprom_data": "!=null"
        },
    }
},
{
    "kprobe:tveeprom_hauppauge_analog": {
        "description": "Process the Hauppauge EEPROM format for analog TV tuners.",
        "proto" :"static long (*tveeprom_hauppauge_analog)(struct tveeprom tvee, unsigned char eeprom_data)",
        "pre": {
            "tvee": "!=null",
            "eeprom_data": "!=null"
        },
        "post": {
            "i": ">=0",
            "j": ">=0",
            "len": ">=0",
            "done": "in [0, 1]",
            "beenhere": "in [0, 1]",
            "tag": ">=0",
            "start": ">=0",
            "tuner1": ">=0",
            "t_format1": ">=0",
            "audioic": ">=-1",
            "t_name1": "!=null",
            "t_fmt_name1": "!=null"
        }
    }
},
{
    "kretprobe:cx2341x_ctrl_query": {
        "description": "Description of the function",
        "proto" :"int cx2341x_ctrl_query(const struct cx2341x_mpeg_params *params, struct v4l2_queryctrl *qctrl)",
        "pre": {
            "params": "!=null",
            "qctrl": "!=null"
        },
    }
},
{
    "kprobe:cx2341x_ctrl_query": {
        "description": "Description of the function goes here.",
        "proto" :"int cx2341x_ctrl_query(const struct cx2341x_mpeg_params *params, struct v4l2_queryctrl *qctrl)",
        "pre": {
            "params": "!=null",
            "qctrl": "!=null"
        },
    }
},
{
    "kretprobe:cx2341x_update": {
        "description": "Update function for cx2341x",
        "proto" :"static int (*cx2341x_update)(void *priv, cx2341x_mbox_func func, const struct cx2341x_mpeg_params *old, const struct cx2341x_mpeg_params *new)",
        "pre": {
            "priv": "!=null",
            "func": "!=null",
            "old": "!=null",
            "new": "!=null"
        },
    }
},

{
    "kretprobe:cx2341x_log_status": {
        "description": "Logs the status of the cx2341x MPEG parameters.",
        "proto" :"void cx2341x_log_status(const struct cx2341x_mpeg_params *p, const char *prefix)",
        "pre": {
            "p": "!=null",
            "prefix": "!=null"
        }
    }
},
{
    "kprobe:cx2341x_log_status": {
        "description": "Logs the status of the cx2341x MPEG parameters.",
        "proto" :"void cx2341x_log_status(const struct cx2341x_mpeg_params *p, const char *prefix)",
        "pre": {
            "p": "!=null",
            "prefix": "!=null"
        }
    }
},


{
    "kretprobe:ttpci_eeprom_parse_mac": {
        "description": "Parse the MAC address from the EEPROM of a Technotrend device.",
        "proto" :"int ttpci_eeprom_parse_mac(struct i2c_adapter *adapter, u8 *proposed_mac)",
        "pre": {
            "adapter": "!=null",
            "proposed_mac": "!=null"
        },
        "post": {
            "return": "in [-ENODEV, 0]"
        }
    }
},
{
    "kprobe:ttpci_eeprom_parse_mac": {
        "description": "Parse the MAC address from the EEPROM.",
        "proto" :"static int (*ttpci_eeprom_parse_mac)(struct i2c_adapter *adapter, u8 *proposed_mac)",
        "pre": {
            "adapter": "!=null",
            "proposed_mac": "!=null"
        },
    }
},
{
    "kretprobe:flexcop_pid_feed_control": {
        "description": "Controls the feed of PIDs in a Flexcop device. Adjusts the feed count based on the onoff parameter. Also adjusts the extra feed count if the index of dvbdmxfeed is greater than or equal to max_pid_filter.",
        "proto" :"flexcop_pid_feed_control(struct flexcop_device *fc, struct dvb_demux_feed *dvbdmxfeed, int onoff)",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "in [0, 1]",
            "dvbdmxfeed->index": "< max_pid_filter",
            "fc->extra_feedcount": ">= 0",
            "fc->skip_6_hw_pid_filter": "in [0, 1]",
            "fc->has_32_hw_pid_filter": "in [0, 1]"
        },
        "post": {
            "fc->feedcount": "onoff ? fc->feedcount + 1 : fc->feedcount - 1",
            "fc->extra_feedcount": "dvbdmxfeed->index >= max_pid_filter ? fc->extra_feedcount + (onoff ? 1 : -1) : fc->extra_feedcount"
        }
    }
},
{
    "kprobe:flexcop_pid_feed_control": {
        "description": "Controls the feed of PIDs in a Flexcop device.",
        "proto" :"static void (*flexcop_pid_feed_control)(struct flexcop_device *fc, struct dvb_demux_feed *dvbdmxfeed, int onoff)",
        "pre": {
            "fc": "!=null",
            "dvbdmxfeed": "!=null",
            "onoff": "in [0, 1]",
            "dvbdmxfeed->index": "< max_pid_filter",
            "fc->extra_feedcount": ">= -1 && <= 1",
            "max_pid_filter": ">= 0"
        },
    }
},


{
    "kretprobe:flexcop_i2c_request": {
        "description": "flexcop_i2c_request is a function that handles I2C requests for the FlexCop device. It takes in several parameters including a flexcop_i2c_adapter struct, an operation type, a chip address, a start address, a buffer, and a size. The function then performs the requested operation on the I2C bus.",
        "proto" :"flexcop_i2c_request(struct flexcop_i2c_adapter  i2c,flexcop_access_op_t op, u8 chipaddr,u8 start_addr, u8  buf, u16 size)",
        "pre": {
            "i2c": "!=null",
            "op": "==FC_WRITE",
            "len": "==0",
            "i2c->no_base_addr": "==true",
            "chipaddr": "is valid chip address",
            "start_addr": "is valid start address",
            "buf": "is valid buffer",
            "size": "is valid size"
        },
    }
},
{
    "kprobe:flexcop_i2c_request": {
        "description": "flexcop_i2c_request is a function that handles I2C requests. It takes in parameters such as the I2C adapter, operation type, chip address, start address, buffer, and size. It checks if the I2C adapter has no base address, the size is 0, and the operation is a write operation.",
        "proto" :"static int (*flexcop_i2c_request)(struct flexcop_i2c_adapter *i2c, flexcop_access_op_t op, u8 chipaddr, u8 start_addr, u8 buf, u16 size)",
        "pre": {
            "i2c->no_base_addr": "==true",
            "len": "==0",
            "op": "==FC_WRITE"
        },
    }
},
{
    "kretprobe:flexcop_i2c_init": {
        "description": "Initialize the i2c of the flexcop device. The EEProm is accessed via i2c, so this function must be called before doing EEProm stuff.",
        "proto" :"int (*flexcop_i2c_init)(struct flexcop_device *fc)",
        "pre": {
            "fc": "!=null"
        },
        "post": {
            "ret": "in [0, error_codes]"
        }
    }
},
{
    "kprobe:flexcop_i2c_init": {
        "description": "Initialize the i2c for the flexcop device. The EEProm is accessed via i2c, so this has to be done before doing EEProm stuff.",
        "proto" :"static int (*flexcop_i2c_init)(struct flexcop_device *fc)",
        "pre": {
            "fc": "!=null",
        },
    }
},
{
    "kretprobe:vb2_buffer_in_use": {
        "description": "Checks if the buffer is in use. If num_users() has not been provided, call_memop will return 0, apparently nobody cares about this case anyway. If num_users() returns more than 1, we are not the only user of the plane's memory.",
        "proto" :"int vb2_buffer_in_use(struct vb2_queue *q, struct vb2_buffer *vb)",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "vb->num_planes": ">=0",
            "vb->planes[plane].mem_priv": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:vb2_buffer_in_use": {
        "description": "Checks if the buffer is in use. If num_users() returns more than 1, we are not the only user of the plane's memory.",
        "proto" :"EXPORT_SYMBOL(vb2_buffer_in_use(struct vb2_queue  q, struct vb2_buffer  vb))",
        "pre": {
            "q": "!=null",
            "vb": "!=null",
            "num_planes": ">=0",
            "mem_priv": "!=null",
            "num_users": ">=0"
        },
    }
},
{
    "kretprobe:vb2_verify_memory_type": {
        "description": "Make sure all the required memory ops for given memory type are available.",
        "proto": "int vb2_verify_memory_type(struct vb2_queue *q, enum vb2_memory memory, unsigned int type)",
        "pre": {
            "q": "!=null",
            "memory": "in [VB2_MEMORY_MMAP, VB2_MEMORY_USERPTR, VB2_MEMORY_DMABUF]",
            "type": "==q->type"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:vb2_verify_memory_type": {
        "description": "Make sure all the required memory ops for given memory type are available.",
        "proto" :"static int (*vb2_verify_memory_type)(struct vb2_queue *q, enum vb2_memory memory, unsigned int type)",
        "pre": {
            "q": "!=null",
            "memory": "==VB2_MEMORY_MMAP",
            "type": "==q->type",
            "__verify_mmap_ops(q)": "==true"
        },
    }
},
{
    "kretprobe:vb2_dvb_register_adapter": {
        "description": "Bring up the adapter",
        "proto" :"static long (*vb2_dvb_register_adapter)(f, module, adapter_priv, device, mdev, fe->dvb.name, adapter_nr, mfe_shared)",
        "pre": {
            "f": "!=null",
            "module": "!=null",
            "adapter_priv": "!=null",
            "device": "!=null",
            "mdev": "!=null",
            "fe->dvb.name": "!=null",
            "adapter_nr": "in [possible values]",
            "mfe_shared": "in [possible values]"
        },
    }
},
{
    "kprobe:vb2_dvb_register_adapter": {
        "description": "Bring up the adapter",
        "proto" :"static long (*vb2_dvb_register_adapter)(f, module, adapter_priv, device, mdev, fe->dvb.name, adapter_nr, mfe_shared)",
        "pre": {
            "f": "!=null",
            "module": "!=null",
            "adapter_priv": "!=null",
            "device": "!=null",
            "mdev": "!=null",
            "fe->dvb.name": "!=null",
            "adapter_nr": "!=null",
            "mfe_shared": "!=null"
        },
    }
},

{
    "kprobe:dvb_frontend_detach": {
        "description": "Detach a frontend from a DVB device.",
        "proto" :"static void (*dvb_frontend_detach)(struct dvb_frontend *frontend)",
        "pre": {
            "frontend": "!=null"
        }
    },
    "kprobe:list_del": {
        "description": "Remove a list entry.",
        "proto" :"static void (*list_del)(struct list_head *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:vb2_querybuf": {
        "description": "Query video buffer information. Should be called from vidioc_querybuf ioctl handler in driver. This function will verify the passed v4l2_buffer structure and fill the relevant information for the userspace. The return values from this function are intended to be directly returned from vidioc_querybuf handler in driver.",
        "proto" :"int (*vb2_querybuf)(struct vb2_queue *q, struct v4l2_buffer *b)",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kprobe:vb2_querybuf": {
        "description": "Query video buffer information. Should be called from vidioc_querybuf ioctl handler in driver. This function will verify the passed v4l2_buffer structure and fill the relevant information for the userspace. The return values from this function are intended to be directly returned from vidioc_querybuf handler in driver.",
        "proto" :"int (*vb2_querybuf)(struct vb2_queue *q, struct v4l2_buffer *b)",
        "pre": {
            "q": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:vb2_create_framevec": {
        "description": "This function allocates and fills in a vector with pfns corresponding to virtual address range passed in arguments. If pfns have corresponding pages, page references are also grabbed to pin pages in memory. The function returns pointer to the vector on success and error pointer in case of failure. Returned vector needs to be freed via vb2_destroy_pfnvec().",
        "proto": "struct frame_vector *(*vb2_create_framevec)(unsigned long start, unsigned long length, bool write)",
        "pre": {
            "start": ">=0",
            "length": ">0",
            "write": "in [true, false]"
        }
    }
},
{
    "kprobe:vb2_create_framevec": {
        "description": "This function allocates and fills in a vector with pfns corresponding to virtual address range passed in arguments. If pfns have corresponding pages, page references are also grabbed to pin pages in memory. The function returns pointer to the vector on success and error pointer in case of failure. Returned vector needs to be freed via vb2_destroy_pfnvec().",
        "proto" :"struct frame_vector *(*vb2_create_framevec)(unsigned long start, unsigned long length, bool write)",
        "pre": {
            "start": ">=0",
            "length": ">0",
            "write": "in [true, false]"
        }
    }
},
{
    "kretprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns. This releases references to all pages in the vector @vec (if corresponding pfns are backed by pages) and frees the passed vector.",
        "proto" :"void (*vb2_destroy_framevec)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:vb2_destroy_framevec": {
        "description": "Release vector of mapped pfns. This releases references to all pages in the vector @vec (if corresponding pfns are backed by pages) and frees the passed vector.",
        "proto" :"void (*vb2_destroy_framevec)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:get_vaddr_frames": {
        "description": "This function maps virtual addresses from @start and fills @vec structure with page frame numbers or page pointers to corresponding pages. If @start belongs to a normal vma, the function grabs reference to each of the pages to pin them in memory. If @start belongs to VM_IO | VM_PFNMAP vma, we don't touch page structures and the caller must make sure pfns aren't reused for anything else while he is using them. The function returns number of pages mapped which may be less than @nr_frames. When the function isn't able to map a single page, it returns error. This function takes care of grabbing mmap_lock as necessary.",
        "proto" :"int get_vaddr_frames(unsigned long start, unsigned int nr_frames, bool write, struct frame_vector *vec)",
        "pre": {
            "start": ">=0",
            "nr_frames": ">0",
            "write": "in [true, false]",
            "vec": "!=null"
        },
    }
},
{
    "kprobe:get_vaddr_frames": {
        "description": "This function maps virtual addresses from @start and fills @vec structure with page frame numbers or page pointers to corresponding pages. If @start belongs to a normal vma, the function grabs reference to each of the pages to pin them in memory. If @start belongs to VM_IO | VM_PFNMAP vma, we don't touch page structures and the caller must make sure pfns aren't reused for anything else while he is using them. The function returns number of pages mapped which may be less than @nr_frames. When the function isn't able to map a single page, it returns error. This function takes care of grabbing mmap_lock as necessary.",
        "proto" :"int (*get_vaddr_frames)(unsigned long start, unsigned int nr_frames, bool write, struct frame_vector *vec)",
        "pre": {
            "start": "is valid user address",
            "nr_frames": "is valid number of pages",
            "write": "is boolean",
            "vec": "!=null & has space for at least nr_frames entries"
        },
    }
},
{
    "kretprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them. We also invalidate the frame vector so that it is prepared for the next call into get_vaddr_frames().",
        "proto" :"void (*put_vaddr_frames)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:put_vaddr_frames": {
        "description": "Drop references to pages if get_vaddr_frames() acquired them. We also invalidate the frame vector so that it is prepared for the next call into get_vaddr_frames().",
        "proto" :"void (*put_vaddr_frames)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pages": {
        "description": "Convert @vec to contain array of page pointers. If the conversion is successful, return 0. Otherwise return an error. Note that we do not grab page references for the page structures.",
        "proto" :"int (*frame_vector_to_pages)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        },
        "post": {
            "return": "in [0, error]"
        }
    }
},
{
    "kprobe:frame_vector_to_pages": {
        "description": "Convert frame vector to contain page pointers. If the conversion is successful, return 0. Otherwise return an error. Note that we do not grab page references for the page structures.",
        "proto" :"int (*frame_vector_to_pages)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_to_pfns": {
        "description": "Convert @vec to contain array of pfns.",
        "proto" :"void (*frame_vector_to_pfns)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_to_pfns": {
        "description": "Convert frame vector to contain array of pfns.",
        "proto" :"void (*frame_vector_to_pfns)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:frame_vector_create": {
        "description": "Allocate and initialize struct pinned_pfns to be able to hold @nr_pfns pfns.",
        "proto" :"struct frame_vector *(*frame_vector_create)(unsigned int nr_frames)",
        "pre": {
            "nr_frames": "> 0"
        },
    }
},
{
    "kprobe:frame_vector_create": {
        "description": "Allocate & initialize structure for pinned pfns. @nr_frames: number of pfns slots we should reserve. Allocate and initialize struct pinned_pfns to be able to hold @nr_pfns pfns.",
        "proto" :"struct frame_vector *(*frame_vector_create)(unsigned int nr_frames)",
        "pre": {
            "nr_frames": "> 0"
        }
    }
},
{
    "kretprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector. Free structure allocated by frame_vector_create() to carry frames.",
        "proto" :"void (*frame_vector_destroy)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kprobe:frame_vector_destroy": {
        "description": "Free memory allocated to carry frame vector. Free structure allocated by frame_vector_create() to carry frames.",
        "proto" :"static void (*frame_vector_destroy)(struct frame_vector *vec)",
        "pre": {
            "vec": "!=null"
        }
    }
},
{
    "kretprobe:af9005_rc_decode": {
        "description": "Description of the function goes here",
        "proto" :"static long (*af9005_rc_decode)(struct dvb_usb_device *d, u8 *data, int len, u32 *event, int *state)",
        "pre": {
            "d": "!=null",
            "data": "!=null",
            "len": ">=6",
            "event": "!=null",
            "state": "!=null"
        },
    }
},
{
    "kprobe:af9005_rc_decode": {
        "description": "Decodes the remote control data for the AF9005 DVB USB device.",
        "proto" :"static int (*af9005_rc_decode)(struct dvb_usb_device *d, u8 *data, int len, u32 *event, int *state)",
        "pre": {
            "d": "!=null",
            "data": "!=null && len >= 6",
            "len": ">=6",
            "event": "!=null",
            "state": "!=null"
        },
    }
},
{
    "kretprobe:dibusb_dib3000mc_tuner_attach": {
        "description": "First IF calibration for Liteon Sticks",
        "proto" :"dibusb_dib3000mc_tuner_attach(struct dvb_usb_adapter  adap)",
        "pre": {
            "adap": "!=null",
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:dvb_attach": {
        "description": "Attach a DVB device. If the device is not found, return -ENOMEM.",
        "proto" :"static void* (*dvb_attach)(void* (*dvb_pll_attach)(void), void* fe, int hex, struct i2c_adapter* tun_i2c, const char* DVB_PLL_ENV57H1XD5)",
        "pre": {
            "dvb_pll_attach": "!=null",
            "fe": "!=null",
            "hex": "==0x60",
            "tun_i2c": "!=null",
            "DVB_PLL_ENV57H1XD5": "!=null"
        },
    }
},
{
    "kretprobe:usb_cypress_load_firmware": {
        "description": "Load firmware into the USB device using the Cypress method.",
        "proto" :"static int (*usb_cypress_load_firmware)(struct usb_device *udev, const struct firmware *fw, int type)",
        "pre": {
            "udev": "!=null",
            "fw": "!=null",
            "type": "in [type1, type2, type3]", // replace with actual types
        },
    }
},


{
    "kprobe:usb_cypress_writemem": {
        "description": "Writes data to a specific memory address in the Cypress USB device.",
        "proto" :"static int (*usb_cypress_writemem)(struct usb_device *udev, __u16 addr, __u8 *buf, __u16 len)",
        "pre": {
            "udev": "!=null",
            "addr": "is valid memory address",
            "buf": "!=null",
            "len": "is positive integer",
        },
    }
},
{
    "kretprobe:dvb_usb_nec_rc_key_to_event": {
        "description": "Match the raw key code.",
        "proto" :"static long (*dvb_usb_nec_rc_key_to_event)(struct dvb_usb_device *d, u8 keybuf[5], u32 *event, int *state)",
        "pre": {
            "d": "!=null",
            "keybuf": "!=null",
            "event": "!=null",
            "state": "!=null"
        },
        "post": {
            "event": "==0",
            "state": "==REMOTE_NO_KEY_PRESSED"
        }
    }
},
{
    "kprobe:dvb_usb_nec_rc_key_to_event": {
        "description": "Match the raw key code.",
        "proto" :"static void (*dvb_usb_nec_rc_key_to_event)(struct dvb_usb_device *d, u8 keybuf[5], u32 *event, int *state)",
        "pre": {
            "d": "!=null",
            "keybuf": "!=null",
            "event": "!=null",
            "state": "!=null",
            "keybuf[0]": "in [DVB_USB_RC_NEC_EMPTY, DVB_USB_RC_NEC_KEY_PRESSED]",
            "keybuf[1]": "!=null",
            "keybuf[2]": "!=null",
            "keybuf[3]": "!=null",
            "keybuf[4]": "!=null",
            "state": "in [REMOTE_NO_KEY_PRESSED]"
        },
    }
},
{
    "kretprobe:dvb_usb_generic_rw": {
        "description": "This function is used for generic read/write operations on a DVB USB device. It sends a bulk message and checks for errors.",
        "proto": "int dvb_usb_generic_rw(struct dvb_usb_device *d, u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen, int delay_ms)",
        "pre": {
            "d": "!=null",
            "wbuf": "!=null",
            "wlen": ">0",
            "rbuf": "!=null",
            "rlen": ">0",
            "delay_ms": ">=0"
        },
        "post": {
            "ret": "==0",
            "rbuf": "!=null",
            "rlen": ">0"
        }
    }
},
{
    "kprobe:dvb_usb_generic_rw": {
        "description": "This function is used for generic read/write operations on a DVB USB device. It locks the device, sends a bulk message, checks for errors, and returns the result.",
        "proto" :"static int dvb_usb_generic_rw(struct dvb_usb_device *d, u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen, int delay_ms)",
        "pre": {
            "d": "!=null",
            "wbuf": "!=null",
            "wlen": ">0",
            "delay_ms": ">=0"
        },
        "post": {
            "ret": "in [-ENOMEM, -EINVAL, 0]",
            "rbuf": "!=null when ret == 0",
            "rlen": ">0 when ret == 0"
        }
    }
},
{
    "kretprobe:go7007_register_encoder": {
        "description": "Registers a new encoder.",
        "proto": "int go7007_register_encoder(struct go7007 *go, unsigned num_i2c_devs)",
        "pre": {
            "go": "!=null",
            "num_i2c_devs": ">=0"
        }
    }
},
{
    "kprobe:go7007_register_encoder": {
        "description": "Register a new encoder for the go7007 device.",
        "proto" :"int (*go7007_register_encoder)(struct go7007 *go, unsigned num_i2c_devs)",
        "pre": {
            "go": "!=null",
            "num_i2c_devs": ">=0"
        },
    }
},
{
    "kretprobe:go7007_parse_video_stream": {
        "description": "Parses the video stream.",
        "proto" :"go7007_parse_video_stream(struct go7007 go, u8 buf, int length)",
        "pre": {
            "go": "!=null",
            "buf": "!=null",
            "length": ">=0",
        },
    }
},
{
    "kprobe:go7007_parse_video_stream": {
        "description": "Parses the video stream of the go7007 structure.",
        "proto" :"void go7007_parse_video_stream(struct go7007 *go, u8 *buf, int length)",
        "pre": {
            "go": "!=null",
            "buf": "!=null",
            "length": ">0",
        },
    }
},

{
    "kprobe:dvb_usbv2_probe": {
        "description": "Probes a DVB USB device.",
        "proto" :"int dvb_usbv2_probe(struct usb_interface *intf, const struct usb_device_id *id)",
        "pre": {
            "intf": "!=null",
            "id": "!=null"
        },
    }
},
{
    "kretprobe:bpf_map_lookup_elem": {
        "description": "Look up the value associated with *key* in *map*.",
        "proto" :"static void *(*bpf_map_lookup_elem)(void *map, const void *key)",
        "pre": {
            "map": "!=null",
            "key": "!=null"
        },
    }
},

{
    "kretprobe:dvb_usbv2_resume_common": {
        "description": "Resumes the DVB USB device and starts the remote controller poll.",
        "proto" :"static int (*dvb_usbv2_resume_common)(struct dvb_usb_device *d)",
        "pre": {
            "d": "!=null",
            "d->udev": "!=null",
            "d->udev->dev": "!=null",
            "d->adapter": "!=null",
            "d->adapter[i].dvb_adap.priv": "!=null",
            "d->adapter[i].active_fe": "in [0, MAX_NO_OF_ADAPTER_PER_DEVICE-1]",
            "d->adapter[i].fe[active_fe]": "!=null"
        },
    }
},
{
    "kprobe:dvb_usbv2_resume_common": {
        "description": "Resume USB streaming for a DVB USB device.",
        "proto" :"static int (*dvb_usbv2_resume_common)(struct dvb_usb_device *d)",
        "pre": {
            "d": "!=null",
            "d->udev": "!=null",
            "d->udev->dev": "!=null",
            "d->adapter[i].dvb_adap.priv": "!=null",
            "d->adapter[i].active_fe": "!= -1",
            "d->adapter[i].fe[active_fe]": "!=null"
        },
    }
},
{
    "kretprobe:gspca_expo_autogain": {
        "description": "If we are of a multiple of deadzone, do multiple steps to reach the desired lumination fast (with the risk of a slight overshoot)",
        "proto" :"gspca_expo_autogain(struct gspca_dev  gspca_dev,int avg_lum,int desired_avg_lum,int deadzone,int gain_knee,int exposure_knee)",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "is integer",
            "desired_avg_lum": "is integer",
            "deadzone": "is integer",
            "gain_knee": "is integer",
            "exposure_knee": "is integer"
        },
    }
},
{
    "kprobe:gspca_expo_autogain": {
        "description": "If we are of a multiple of deadzone, do multiple steps to reach the desired lumination fast (with the risk of a slight overshoot)",
        "proto" :"gspca_expo_autogain(struct gspca_dev  gspca_dev,int avg_lum,int desired_avg_lum,int deadzone,int gain_knee,int exposure_knee)",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "is integer",
            "desired_avg_lum": "is integer",
            "deadzone": "is integer",
            "gain_knee": "is integer",
            "exposure_knee": "is integer"
        },
    }
},
{
    "kretprobe:gspca_coarse_grained_expo_autogain": {
        "description": "If we are of a multiple of deadzone, do multiple steps to reach the desired lumination fast (with the risk of a slight overshoot)",
        "proto" :"gspca_coarse_grained_expo_autogain(struct gspca_dev  gspca_dev,int avg_lum,int desired_avg_lum,int deadzone)",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "is integer",
            "desired_avg_lum": "is integer",
            "deadzone": "is integer"
        }
    }
},
{
    "kprobe:gspca_coarse_grained_expo_autogain": {
        "description": "If we are of a multiple of deadzone, do multiple steps to reach the desired lumination fast (with the risk of a slight overshoot)",
        "proto" :"gspca_coarse_grained_expo_autogain(struct gspca_dev  gspca_dev,int avg_lum,int desired_avg_lum,int deadzone)",
        "pre": {
            "gspca_dev": "!=null",
            "avg_lum": "is integer",
            "desired_avg_lum": "is integer",
            "deadzone": "is integer"
        },
    }
},
{
    "kretprobe:gspca_frame_add": {
        "description": "Add a frame to the gspca device. If there is no queued buffer, discard the whole frame.",
        "proto" :"static void (*gspca_frame_add)(struct gspca_dev *gspca_dev, enum gspca_packet_type packet_type, const u8 *data, int len)",
        "pre": {
            "gspca_dev": "!=null",
            "packet_type": "in [FIRST_PACKET, NEXT_PACKET, LAST_PACKET]",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "buf": "==null"
        }
    }
},
{
    "kprobe:gspca_frame_add": {
        "description": "Add a frame to the gspca device. If there is no queued buffer, discard the whole frame.",
        "proto" :"static void (*gspca_frame_add)(struct gspca_dev *gspca_dev, enum gspca_packet_type packet_type, const u8 *data, int len)",
        "pre": {
            "gspca_dev": "!=null",
            "packet_type": "in [FIRST_PACKET, NEXT_PACKET, LAST_PACKET]",
            "data": "!=null",
            "len": ">=0",
            "buf": "==null"
        },
    }
},

{
    "kprobe:gspca_dev_probe2": {
        "description": "Create the device",
        "proto" :"gspca_dev_probe2(struct usb_interface  intf,const struct usb_device_id  id,const struct sd_desc  sd_desc,int dev_size,struct module  module)",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "sd_desc": "!=null",
            "dev_size": ">= sizeof *gspca_dev",
            "module": "!=null",
        },
    }
},
{
    "kretprobe:v4l2_device_put": {
        "description": "Disconnects the v4l2 device and releases the resources.",
        "proto" :"static void (*v4l2_device_put)(struct v4l2_device *v4l2_dev)",
        "pre": {
            "v4l2_dev": "!=null"
        }
    }
},
{
    "kprobe:gspca_disconnect": {
        "description": "Disconnects a gspca device.",
        "proto": "void (*gspca_disconnect)(struct usb_interface *intf)",
        "pre": {
            "intf": "!=null"
        }
    }
},
{
    "kretprobe:gspca_suspend": {
        "description": "This function suspends the gspca device.",
        "proto" :"gspca_suspend(struct usb_interface  intf, pm_message_t message)",
        "pre": {
            "intf": "!=null",
            "message": "!=null"
        },
    }
},
{
    "kprobe:gspca_suspend": {
        "description": "This function suspends the gspca device, destroys the urb, and locks the usb.",
        "proto" :"gspca_suspend(struct usb_interface  intf, pm_message_t message)",
        "pre": {
            "intf": "!=null",
            "message": "!=null",
            "gspca_dev": "!=null && gspca_dev->usb_err == 0 && gspca_dev->frozen == 1",
            "gspca_dev->usb_lock": "is locked",
            "gspca_dev->sd_desc->stopN": "!=null",
            "gspca_dev->sd_desc->stop0": "!=null",
            "gspca_dev->queue": "vb2_start_streaming_called(&gspca_dev->queue) == false"
        },
    }
},
{
    "kretprobe:gspca_resume": {
        "description": "Description of the function's behavior and purpose",
        "proto" :"gspca_resume(struct usb_interface  intf)",
        "pre": {
            "intf": "!=null",
            "gspca_dev": "!=null",
            "streaming": "in [0, 1]",
            "ret": "==0",
            "gspca_dev->usb_lock": "locked",
            "gspca_dev->frozen": "==0",
            "gspca_dev->usb_err": "==0",
            "gspca_dev->sd_desc->init": "called"
        },
        "post": {
            "ret": "constraints on the return value"
        }
    }
},

{
    "kretprobe:kmalloc": {
        "description": "Allocate memory for the internal state",
        "proto" :"static void* (*kmalloc)(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kmalloc": {
        "description": "Allocates 'size' bytes of memory, and returns a pointer to the allocated memory. Returns NULL if the allocation fails.",
        "proto": "void *kmalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": "> 0",
            "flags": "in [GFP_KERNEL, GFP_ATOMIC, ...]"
        },
        "post": {
            "return": "!=null"
        }
    },
    "ttusbdecfe_dvbs_attach": {
        "description": "Allocates memory for the internal state",
        "proto": "struct ttusbdecfe_state *ttusbdecfe_dvbs_attach(const struct ttusbdecfe_config config)",
        "pre": {
            "config": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:mt2060_readreg": {
        "description": "Reads a register from a device and stores the value in *id*. Returns 0 on success, non-zero on failure.",
        "proto" :"int (*mt2060_readreg)(struct mt2060_priv *priv, int REG_PART_REV, u8 *id)",
        "pre": {
            "priv": "!=null",
            "REG_PART_REV": "is constant",
            "id": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:mt2060_attach": {
        "description": "Attach the MT2060 tuner driver to the DVB frontend.",
        "proto" :"static struct dvb_frontend* (*mt2060_attach)(struct dvb_frontend* fe, struct i2c_adapter* i2c, struct mt2060_config* cfg, u16 if1)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null",
            "if1": "is a valid frequency"
        },
    }
},
{
    "kretprobe:fc0012_readreg": {
        "description": "Reads a register from the fc0012 device.",
        "proto" :"int (*fc0012_readreg)(struct fc0012_priv *priv, __u8 reg, __u8 *val)",
        "pre": {
            "priv": "!=null",
            "reg": "is valid register address",
            "val": "!=null"
        },
        "post": {
            "ret": "< 0 if error, >= 0 otherwise",
            "val": "contains the value read from the register if ret >= 0"
        }
    }
},
{
    "kprobe:fc0012_readreg": {
        "description": "Read a register from a device.",
        "proto" :"int (*fc0012_readreg)(struct fc0012_priv *priv, __u8 reg, __u8 *val)",
        "pre": {
            "priv": "!=null",
            "reg": "in [0x00, 0xFF]",
            "val": "!=null"
        },
    },
    "kprobe:dev_dbg": {
        "description": "Print debug messages.",
        "proto" :"void (*dev_dbg)(const struct device *dev, const char *format, ...)",
        "pre": {
            "dev": "!=null",
            "format": "!=null"
        },
    }
},
{
    "kretprobe:mc44s803_readreg": {
        "description": "Reads a register from the mc44s803 device.",
        "proto": "int (*mc44s803_readreg)(struct mc44s803_priv *priv, u32 reg, u32 *val)",
        "pre": {
            "priv": "!=null",
            "reg": "in [MC44S803_REG_ID]",
            "val": "!=null"
        },
        "post": {
            "ret": "==0",
            "val": "!=null"
        }
    },
    "kretprobe:MC44S803_REG_MS": {
        "description": "Extracts the ID from the register value.",
        "proto": "u8 (*MC44S803_REG_MS)(u32 reg, u8 id)",
        "pre": {
            "reg": "!=null",
            "id": "in [MC44S803_ID]"
        },
        "post": {
            "id": "==0x14"
        }
    }
},
{
    "kprobe:mc44s803_readreg": {
        "description": "Reads a register from the MC44S803 and checks the ID. If the ID is not 0x14, it goes to error.",
        "proto" :"static int (*mc44s803_readreg)(struct mc44s803_priv *priv, u32 reg, u32 *value)",
        "pre": {
            "priv": "!=null",
            "reg": "in [MC44S803_REG_ID]",
            "value": "!=null"
        },
    },
    "kprobe:MC44S803_REG_MS": {
        "description": "Extracts the ID from the register value.",
        "proto" :"static u8 (*MC44S803_REG_MS)(u32 reg, u8 id)",
        "pre": {
            "reg": "!=null",
            "id": "in [MC44S803_ID]"
        },
    }
},

{
    "kprobe:xc4000_attach": {
        "description": "Attach a xc4000 device.",
        "proto" :"static int (*xc4000_attach)(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct xc4000_config *cfg)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        },
    }
},

{
    "kprobe:mxl5005s_attach": {
        "description": "Attach a MXL5005S device with a given configuration.",
        "proto": "int (*mxl5005s_attach)(struct mxl5005s_device *dev, const struct mxl5005s_config *config)",
        "pre": {
            "dev": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kretprobe:qt1010_attach": {
        "description": "Try to detect tuner chip. Probably this is not correct register.",
        "proto" :"qt1010_attach(struct dvb_frontend  fe,    struct i2c_adapter  i2c,    struct qt1010_config  cfg)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        },
    }
},
{
    "kprobe:qt1010_attach": {
        "description": "Try to detect tuner chip. Probably this is not correct register.",
        "proto" :"qt1010_attach(struct dvb_frontend  fe,    struct i2c_adapter  i2c,    struct qt1010_config  cfg)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        },
    }
},
{
    "kretprobe:xc5000_attach": {
        "description": "Attach a xc5000 device.",
        "proto" :"static int (*xc5000_attach)(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct xc5000_config *cfg)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        },
    }
},
{
    "kprobe:xc5000_attach": {
        "description": "Attach a xc5000 tuner to a dvb frontend.",
        "proto" :"static int (*xc5000_attach)(struct dvb_frontend *fe, struct i2c_adapter *i2c, const struct xc5000_config *cfg)",
        "pre": {
            "fe": "!=null",
            "i2c": "!=null",
            "cfg": "!=null"
        },
    }
},
{
    "kretprobe:def_regs": {
        "description": "Description of what the function does",
        "proto" :"static u8 (*def_regs)(int n, int *arr)",
        "pre": {
            "n": ">=0",
            "arr": "!=null",
        },
        "post": "!=null"
    }
},


{
    "kprobe:bpf_tuner_update": {
        "description": "Update the mode of a tuner.",
        "proto" :"static long (*bpf_tuner_update)(void *tuner, __u64 mode)",
        "pre": {
            "tuner": "!=null",
            "mode": "in [MODE_ANALOG, MODE_DIGITAL]",
        },
    }
},
{
    "kretprobe:fc0013_rc_cal_add": {
        "description": "Add your function description here",
        "proto" :"fc0013_rc_cal_add(struct dvb_frontend  fe, int rc_val)",
        "pre": {
            "fe": "!=null",
            "rc_val": "Add your constraints here"
        }
    }
},
{
    "kprobe:fc0013_rc_cal_add": {
        "description": "Add or update the value of the entry associated to *fe* in *rc_val* with *priv*.",
        "proto" :"static long (*fc0013_rc_cal_add)(struct dvb_frontend *fe, int rc_val)",
        "pre": {
            "fe": "!=null",
            "rc_val": "is an integer",
        },
    }
},





{
    "kprobe:dvb_frontend_get;sema_init;init_waitqueue_head;init_waitqueue_head;mutex_init;dvb_register_device": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "fe": "Constraints for fe",
            "fepriv": "Constraints for fepriv",
            "dvb": "Constraints for dvb",
            "ret": "Constraints for ret",
            "...": "Other constraints"
        },
    }
},
{
    "kretprobe:intlog2": {
        "description": "Returns the base 2 logarithm of *value*. The result is incorrect if *value* is 0 (log2(0) is undefined).",
        "proto" :"static int (*intlog2)(u32 value)",
        "pre": {
            "value": "!=0"
        },
    }
},
{
    "kprobe:intlog2": {
        "description": "Returns the base 2 logarithm of *value*. The result is incorrect if *value* is 0 (log2(0) is undefined).",
        "proto" :"static int (*intlog2)(u32 value)",
        "pre": {
            "value": "!=0",
        },
    }
},
{
    "kretprobe:intlog10": {
        "description": "Returns the base 10 logarithm of *value*. The function will return a wrong result if *value* is 0 because log10(0) is undefined.",
        "proto" :"static u64 (*intlog10)(u32 value)",
        "pre": {
            "value": "> 0"
        },
    }
},
{
    "kprobe:intlog10": {
        "description": "Returns the base 10 logarithm of *value*. Incorrect result if *value* is 0 (log10(0) is undefined).",
        "proto" :"static u64 (*intlog10)(u32 value)",
        "pre": {
            "value": "!=0"
        }
    }
},


{
    "kretprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},

{
    "kretprobe:dvb_register_adapter": {
        "description": "Registers a DVB adapter. The adapter number is checked to be within the range of 0 to DVB_MAX_ADAPTERS. If the adapter number is free, it is used.",
        "proto" :"static int (*dvb_register_adapter)(struct dvb_adapter *adap, const char *name, struct module *module, struct device *device, short *adapter_nums)",
        "pre": {
            "adap": "!=null",
            "name": "!=null",
            "module": "!=null",
            "device": "!=null",
            "adapter_nums": "!=null",
            "num": "in [0, DVB_MAX_ADAPTERS)"
        },
    }
},
{
    "kprobe:dvb_register_adapter": {
        "description": "Register a DVB adapter. If the adapter number is within the range of 0 to DVB_MAX_ADAPTERS, use the one the driver asked for.",
        "proto" :"static int (*dvb_register_adapter)(struct dvb_adapter *adap, const char *name, struct module *module, struct device *device, short *adapter_nums)",
        "pre": {
            "adap": "!=null",
            "name": "!=null",
            "module": "!=null",
            "device": "!=null",
            "adapter_nums": "!=null",
            "adapter_nums[i]": ">=0 && < DVB_MAX_ADAPTERS"
        },
    }
},
{
    "kretprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "proto": "void (*dvb_ca_en50221_camchange_irq)(struct dvb_ca_en50221 *pubca, int slot, int change_type)",
        "pre": {
            "pubca": "!=null",
            "slot": ">=0",
            "change_type": "in [DVB_CA_CAMCHANGE_INSERTED, DVB_CA_CAMCHANGE_REMOVED]"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camchange_irq": {
        "description": "A CAMCHANGE IRQ has occurred.",
        "proto" :"void (*dvb_ca_en50221_camchange_irq)(struct dvb_ca_en50221 *pubca, int slot, int change_type)",
        "pre": {
            "pubca": "!=null",
            "slot": "!=null",
            "change_type": "in range of DVB_CA_CAMCHANGE_ values",
        },
    }
},
{
    "kretprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred.",
        "proto" :"void (*dvb_ca_en50221_camready_irq)(struct dvb_ca_en50221 *pubca, int slot)",
        "pre": {
            "pubca": "!=null",
            "slot": ">=0"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_camready_irq": {
        "description": "A CAMREADY IRQ has occurred. @pubca: CA instance. @slot: Slot concerned.",
        "proto" :"void (*dvb_ca_en50221_camready_irq)(struct dvb_ca_en50221 *pubca, int slot)",
        "pre": {
            "pubca": "!=null",
            "slot": "is integer"
        }
    }
},
{
    "kretprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred.",
        "proto" :"void (*dvb_ca_en50221_frda_irq)(struct dvb_ca_en50221 *pubca, int slot)",
        "pre": {
            "pubca": "!=null",
            "slot": ">=0"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_frda_irq": {
        "description": "An FR or DA IRQ has occurred. @pubca: CA instance. @slot: Slot concerned.",
        "proto" :"void (*dvb_ca_en50221_frda_irq)(struct dvb_ca_en50221 *pubca, int slot)",
        "pre": {
            "pubca": "!=null",
            "slot": ">=0",
        },
    }
},
{
    "kretprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device. DVB adapter to attach the new CA device to. The dvb_ca instance. Flags describing the CA device (DVB_CA_FLAG_ ). Number of slots supported. Return: 0 on success, nonzero on failure",
        "proto" :"int (*dvb_ca_en50221_init)(struct dvb_adapter *dvb_adapter, struct dvb_ca_en50221 *pubca, int flags, int slot_count)",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "in [DVB_CA_FLAG_]",
            "slot_count": ">=0"
        },
        "post": {
            "return": "in [0, nonzero]"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_init": {
        "description": "Initialise a new DVB CA EN50221 interface device. DVB adapter to attach the new CA device to. The dvb_ca instance. Flags describing the CA device (DVB_CA_FLAG_ ). Number of slots supported. Return: 0 on success, nonzero on failure",
        "proto" :"int (*dvb_ca_en50221_init)(struct dvb_adapter *dvb_adapter, struct dvb_ca_en50221 *pubca, int flags, int slot_count)",
        "pre": {
            "dvb_adapter": "!=null",
            "pubca": "!=null",
            "flags": "in [DVB_CA_FLAG_]",
            "slot_count": ">=0"
        },
    }
},
{
    "kretprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "proto" :"void (*dvb_ca_en50221_release)(struct dvb_ca_en50221 *pubca)",
        "pre": {
            "pubca": "!=null"
        }
    }
},
{
    "kprobe:dvb_ca_en50221_release": {
        "description": "Release a DVB CA EN50221 interface device.",
        "proto" :"void (*dvb_ca_en50221_release)(struct dvb_ca_en50221 *pubca)",
        "pre": {
            "pubca": "!=null"
        }
    }
},
{
    "kretprobe:dvb_ringbuffer_avail": {
        "description": "This function returns the available space in the ringbuffer. It is used after dvb_ringbuffer_read(), dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(), or dvb_ringbuffer_reset().",
        "proto" :"ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)",
        "pre": {
            "rbuf": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:dvb_ringbuffer_avail": {
        "description": "This function calculates the available space in the ring buffer.",
        "proto" :"ssize_t (*dvb_ringbuffer_avail)(struct dvb_ringbuffer *rbuf)",
        "pre": {
            "rbuf": "!=null",
        },
    }
},
{
    "kretprobe:dvb_ringbuffer_free": {
        "description": "dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset() for memory barriers also see Documentationcore-apicircular-buffers.rst",
        "proto" :"ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)",
        "pre": {
            "rbuf": "your_condition_here"
        }
    }
},

{
    "kretprobe:dvb_ringbuffer_avail": {
        "description": "smp_load_acquire() to load write pointer on reader side. This pairs with smp_store_release() in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()",
        "proto" :"ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)",
        "pre": {
            "rbuf": "!=null"
        },
    }
},
{
    "kprobe:dvb_ringbuffer_avail": {
        "description": "smp_load_acquire() to load write pointer on reader side. This pairs with smp_store_release() in dvb_ringbuffer_write(), dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()",
        "proto" :"ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)",
        "pre": {
            "rbuf": "!=null"
        },
    }
},
{
    "kretprobe:smp_store_release": {
        "description": "Update the read pointer to ensure that buf is not overwritten until read is complete. This pairs with READ_ONCE() in dvb_ringbuffer_free().",
        "proto" :"void smp_store_release(volatile void *p, T v)",
        "pre": {
            "p": "!=null",
            "v": "is an integer"
        }
    }
},
{
    "kprobe:smp_store_release": {
        "description": "Update the read pointer to ensure that buf is not overwritten until read is complete. This pairs with READ_ONCE() in dvb_ringbuffer_free().",
        "proto" :"void smp_store_release(volatile void *p, unsigned long v)",
        "pre": {
            "p": "!=null",
            "v": "is 0"
        }
    }
},
{
    "kretprobe:dvb_dmx_swfilter_section_new": {
        "description": "This function checks if the first and last byte of the section buffer are not equal to 0xff. If they are not, it means the section padding is not done correctly with 0xff bytes.",
        "proto" :"static void (*dvb_dmx_swfilter_section_new)(struct dvb_demux_feed *feed)",
        "pre": {
            "feed": "!=null",
            "sec->secbuf[0]": "in [0x00, 0xfe]",
            "sec->secbuf[n - 1]": "in [0x00, 0xfe]"
        }
    }
},
{
    "kprobe:dvb_dmx_swfilter_section_new": {
        "description": "This function checks if the first and last byte of the section buffer are not equal to 0xff. If either the first or last byte is not equal to 0xff, the function returns true.",
        "proto" :"static void (*dvb_dmx_swfilter_section_new)(struct dvb_demux_feed *feed)",
        "pre": {
            "feed": "!=null",
            "sec->secbuf[0]": "!=0xff",
            "sec->secbuf[n - 1]": "!=0xff"
        }
    }
},
{
    "kretprobe:isac_rme_irq": {
        "description": "The function description goes here.",
        "proto" :"static long (*isac_rme_irq)(struct isac_hw *isac)",
        "pre": {
            "isac": "!=null"
        },
    }
},
{
    "kprobe:isac_rme_irq": {
        "description": "Description of the function",
        "proto" :"static long (*isac_rme_irq)(struct isac_hw *isac, u8 val)",
        "pre": {
            "isac": "!=null",
            "val": "in [0x00, 0xFF]"
        },
    }
},
{
    "kretprobe:mISDNipac_irq": {
        "description": "Your function description here",
        "proto" :"static long (*mISDNipac_irq)(struct ipac_hw  ipac, int maxloop)",
        "pre": {
            "ipac": "!=null",
            "maxloop": ">=0",
        },
    }
},
{
    "kprobe:mISDNipac_irq": {
        "description": "Handles the interrupt requests for the IPAC hardware.",
        "proto" :"void mISDNipac_irq(struct ipac_hw *ipac, int maxloop)",
        "pre": {
            "ipac": "!=null",
            "maxloop": ">=0",
        },
    }
},
{
    "kretprobe:mISDNipac_init": {
        "description": "Initializes the mISDNipac.",
        "proto" :"mISDNipac_init(struct ipac_hw  ipac, void  hw)",
        "pre": {
            "ipac": "!=null",
            "hw": "!=null"
        },
    }
},
{
    "kprobe:mISDNipac_init": {
        "description": "Provide a brief description of the function here.",
        "proto" :"mISDNipac_init(struct ipac_hw  ipac, void  hw)",
        "pre": {
            "ipac": "!=null",
            "hw": "!=null"
        },
    }
},
{
    "kretprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream. The source buffer is scanned for valid HDLC frames looking for flags (01111110) to indicate the start of a frame. If the start of the frame is found, the bit stuffing is removed (0 after 5 1's). When a new flag is found, the complete frame has been received and the CRC is checked. If a valid frame is found, the function returns the frame length excluding the CRC with the bit HDLC_END_OF_FRAME set. If the beginning of a valid frame is found, the function returns the length. If a framing error is found (too many 1s and not a flag) the function returns the length with the bit HDLC_FRAMING_ERROR set. If a CRC error is found the function returns the length with the bit HDLC_CRC_ERROR set. If the frame length exceeds the destination buffer size, the function returns the length with the bit HDLC_LENGTH_ERROR set.",
        "proto" :"int isdnhdlc_decode(struct isdnhdlc_vars *hdlc, const u8 *src, int slen, int *count, u8 *dst, int dsize)",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kprobe:isdnhdlc_decode": {
        "description": "Decodes HDLC frames from a transparent bit stream. The source buffer is scanned for valid HDLC frames looking for flags (01111110) to indicate the start of a frame. If the start of the frame is found, the bit stuffing is removed (0 after 5 1's). When a new flag is found, the complete frame has been received and the CRC is checked. If a valid frame is found, the function returns the frame length excluding the CRC with the bit HDLC_END_OF_FRAME set. If the beginning of a valid frame is found, the function returns the length. If a framing error is found (too many 1s and not a flag) the function returns the length with the bit HDLC_FRAMING_ERROR set. If a CRC error is found the function returns the length with the bit HDLC_CRC_ERROR set. If the frame length exceeds the destination buffer size, the function returns the length with the bit HDLC_LENGTH_ERROR set.",
        "proto" :"int isdnhdlc_decode(struct isdnhdlc_vars *hdlc, const u8 *src, int slen, int *count, u8 *dst, int dsize)",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        }
    }
},
{
    "kretprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream. The bit stream starts with a beginning flag (01111110). After that each byte is added to the bit stream with bit stuffing added (0 after 5 1's). When the last byte has been removed from the source buffer, the CRC (2 bytes is added) and the frame terminates with the ending flag. For the dchannel, the idle character (all 1's) is also added at the end. If this function is called with empty source buffer (slen=0), flags or idle character will be generated.",
        "proto" :"int isdnhdlc_encode(struct isdnhdlc_vars *hdlc, const u8 *src, u16 slen, int *count, u8 *dst, int dsize)",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:isdnhdlc_encode": {
        "description": "Encodes HDLC frames to a transparent bit stream. The bit stream starts with a beginning flag (01111110). After that each byte is added to the bit stream with bit stuffing added (0 after 5 1's). When the last byte has been removed from the source buffer, the CRC (2 bytes is added) and the frame terminates with the ending flag. For the dchannel, the idle character (all 1's) is also added at the end. If this function is called with empty source buffer (slen=0), flags or idle character will be generated.",
        "proto" :"int isdnhdlc_encode(struct isdnhdlc_vars *hdlc, const u8 *src, u16 slen, int *count, u8 *dst, int dsize)",
        "pre": {
            "hdlc": "!=null",
            "src": "!=null",
            "slen": ">=0",
            "count": "!=null",
            "dst": "!=null",
            "dsize": ">=0"
        },
    }
},
{
    "kretprobe:capi_ctr_handle_message": {
        "description": "Handle incoming CAPI message. Called by hardware driver to pass a CAPI message to the application.",
        "proto" :"void (*capi_ctr_handle_message)(struct capi_ctr *ctr, u16 appl, struct sk_buff *skb)",
        "pre": {
            "ctr": "!=null",
            "appl": "is a valid application ID",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_handle_message": {
        "description": "Handle incoming CAPI message. Called by hardware driver to pass a CAPI message to the application.",
        "proto" :"void (*capi_ctr_handle_message)(struct capi_ctr *ctr, u16 appl, struct sk_buff *skb)",
        "pre": {
            "ctr": "!=null",
            "appl": "is a valid application ID",
            "skb": "!=null",
        },
    }
},
{
    "kretprobe:capi_ctr_ready": {
        "description": "Called by hardware driver to signal that the controller is up and running.",
        "proto" :"void (*capi_ctr_ready)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_ready": {
        "description": "Called by hardware driver to signal that the controller is up and running.",
        "proto" :"void (*capi_ctr_ready)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready. Called by hardware driver to signal that the controller is down and unavailable for use.",
        "proto" :"void (*capi_ctr_down)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kprobe:capi_ctr_down": {
        "description": "Signal CAPI controller not ready. Called by hardware driver to signal that the controller is down and unavailable for use.",
        "proto" :"void (*capi_ctr_down)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        }
    }
},
{
    "kretprobe:attach_capi_ctr": {
        "description": "Register a controller with the CAPI subsystem. Called by hardware driver to register a controller.",
        "proto": "int (*attach_capi_ctr)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:attach_capi_ctr": {
        "description": "Called by hardware driver to register a controller with the CAPI subsystem.",
        "proto" :"int (*attach_capi_ctr)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kretprobe:detach_capi_ctr": {
        "description": "Called by hardware driver to remove the registration of a controller with the CAPI subsystem.",
        "proto" :"int (*detach_capi_ctr)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:detach_capi_ctr": {
        "description": "Called by hardware driver to remove the registration of a controller with the CAPI subsystem.",
        "proto" :"int (*detach_capi_ctr)(struct capi_ctr *ctr)",
        "pre": {
            "ctr": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kretprobe:mISDN_ctrl_bchannel": {
        "description": "Performs different operations based on the value of `cq->op`.",
        "proto" :"int mISDN_ctrl_bchannel(struct bchannel *bch, struct mISDN_ctrl_req *cq)",
        "pre": {
            "bch": "!=null",
            "cq": "!=null"
        },
        "post": {
            "MISDN_CTRL_RX_OFF": {
                "bch->dropcnt": "==0",
                "cq->p2": ">=0"
            },
            // other cases...
        }
    }
},

{
    "kretprobe:recv_Dchannel": {
        "description": "At least 2 for sapi tei",
        "proto" :"static long (*recv_Dchannel)(struct dchannel *dch)",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->len": ">=2"
        },
    }
},
{
    "kprobe:recv_Dchannel": {
        "description": "At least 2 for sapi tei",
        "proto" :"static void (*recv_Dchannel)(struct dchannel *dch)",
        "pre": {
            "dch": "!=null",
            "dch->rx_skb": "!=null",
            "dch->rx_skb->len": ">=2",
        },
    }
},
{
    "kretprobe:recv_Echannel": {
        "description": "Your function description here",
        "proto" :"static long (*recv_Echannel)(struct dchannel *ech, struct dchannel *dch)",
        "pre": {
            "ech": "!=null",
            "dch": "!=null"
        }
    }
},
{
    "kprobe:recv_Echannel": {
        "description": "Receives Echannel data, processes it, and queues it for further handling.",
        "proto" :"static void (*recv_Echannel)(struct dchannel *ech, struct dchannel *dch)",
        "pre": {
            "ech": "!=null",
            "dch": "!=null",
            "ech->rx_skb->len": ">=2"
        },
    }
},
{
    "kretprobe:recv_Bchannel": {
        "description": "If allocation did fail upper functions still may call us",
        "proto" :"void recv_Bchannel(struct bchannel *bch, unsigned int id, bool force)",
        "pre": {
            "bch": "!=null",
            "bch->rx_skb": "!=null",
            "bch->rx_skb->len": ">0",
            "id": "is unsigned int",
            "force": "is bool"
        },
    }
},
{
    "kprobe:recv_Bchannel": {
        "description": "If allocation did fail upper functions still may call us",
        "proto" :"static void (*recv_Bchannel)(struct bchannel *bch, unsigned int id, bool force)",
        "pre": {
            "bch": "!=null",
            "bch->rx_skb": "!=null",
            "bch->rx_skb->len": "> 0",
            "id": "is unsigned int",
            "force": "is bool"
        },
    }
},


{
    "kretprobe:bchannel_senddata": {
        "description": "Check oversize of the sk_buff structure.",
        "proto": "static long (*bchannel_senddata)(struct bchannel *ch, struct sk_buff *skb)",
        "pre": {
            "ch": "!=null",
            "skb": "!=null",
            "skb->len": "<=0"
        }
    }
},
{
    "kprobe:bchannel_senddata": {
        "description": "Check oversize of the sk_buff structure.",
        "proto": "static long (*bchannel_senddata)(struct bchannel *ch, struct sk_buff *skb)",
        "pre": {
            "ch": "!=null",
            "skb": {
                "!=null": {
                    "len": "<=0"
                }
            }
        }
    }
},


{
    "kretprobe:mISDN_clock_get": {
        "description": "The signed short value counts the number of samples since. Time since last clock event is added.",
        "proto" :"static short (*mISDN_clock_get)(void)",
        "pre": {},
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:mISDN_clock_get": {
        "description": "The signed short value counts the number of samples since. Time since last clock event is added.",
        "proto" :"static short (*mISDN_clock_get)(void)",
        "pre": {},
    }
},
{
    "kretprobe:mISDN_unregister_device": {
        "description": "Unregister a mISDN device.",
        "proto" :"void mISDN_unregister_device(struct mISDNdevice *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kretprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own 'apm get power status' function.",
        "proto" :"void (*apm_get_power_status)(struct apm_power_info *) = __apm_get_power_status;EXPORT_SYMBOL(apm_get_power_status)",
        "pre": {
            "apm_power_info": "!=null"
        }
    }
},
{
    "kprobe:apm_get_power_status": {
        "description": "This allows machines to provide their own 'apm get power status' function.",
        "proto" :"void (*apm_get_power_status)(struct apm_power_info *) = __apm_get_power_status;EXPORT_SYMBOL(apm_get_power_status)",
        "pre": {
            "struct apm_power_info *": "!=null",
        },
    }
},
{
    "kretprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and ultimately take the appropriate action. Only a subset of events are handled: APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND.",
        "proto" :"void (*apm_queue_event)(apm_event_t event)",
        "pre": {
            "event": "in [APM_LOW_BATTERY, APM_POWER_STATUS_CHANGE, APM_USER_SUSPEND, APM_SYS_SUSPEND, APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kprobe:apm_queue_event": {
        "description": "Queue an APM event for kapmd to process and ultimately take the appropriate action. Only a subset of events are handled.",
        "proto": "void (*apm_queue_event)(apm_event_t event)",
        "pre": {
            "event": "in [%APM_LOW_BATTERY, %APM_POWER_STATUS_CHANGE, %APM_USER_SUSPEND, %APM_SYS_SUSPEND, %APM_CRITICAL_SUSPEND]"
        }
    }
},
{
    "kretprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel. If the minor number is set to %MISC_DYNAMIC_MINOR a minor number is assigned and placed in the minor field of the structure. For other cases the minor number requested is used. The structure passed is linked into the kernel and may not be destroyed until it has been unregistered. By default, an open() syscall to the device sets file->private_data to point to the structure. Drivers don't need open in fops for this. A zero is returned on success and a negative errno code for failure.",
        "proto" :"int (*misc_register)(struct miscdevice *misc)",
        "pre": {
            "misc": "!=null"
        },
        "post": {
            "return": "in [0, negative errno codes]"
        }
    }
},
{
    "kprobe:misc_register": {
        "description": "Register a miscellaneous device with the kernel. If the minor number is set to %MISC_DYNAMIC_MINOR a minor number is assigned and placed in the minor field of the structure. For other cases the minor number requested is used. The structure passed is linked into the kernel and may not be destroyed until it has been unregistered. By default, an open() syscall to the device sets file->private_data to point to the structure. Drivers don't need open in fops for this. A zero is returned on success and a negative errno code for failure.",
        "proto" :"int (*misc_register)(struct miscdevice *misc)",
        "pre": {
            "misc": "!=null"
        },
        "post": {
            "return": "in [0, negative errno code]"
        }
    }
},
{
    "kretprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "proto" :"void (*misc_deregister)(struct miscdevice *misc)",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kprobe:misc_deregister": {
        "description": "Unregister a miscellaneous device that was previously successfully registered with misc_register().",
        "proto" :"void (*misc_deregister)(struct miscdevice *misc)",
        "pre": {
            "misc": "!=null"
        }
    }
},
{
    "kretprobe:gpio_dump": {
        "description": "Dumps the current settings of the GPIO",
        "proto" :"void (*gpio_dump)(struct nsc_gpio_ops *amp, unsigned m)",
        "pre": {
            "amp": "!=null",
            "m": "is a valid GPIO pin number"
        }
    }
},
{
    "kprobe:nsc_gpio_write": {
        "description": "Writes to a GPIO pin on the NSC (National Semiconductor Corporation) device.",
        "proto" :"int (*nsc_gpio_write)(struct file *file, const char __user *data, size_t len, loff_t *ppos)",
        "pre": {
            "file": "!=null",
            "data": "!=null",
            "len": ">0",
            "ppos": "!=null"
        },
    }
},
{
    "kretprobe:nsc_gpio_read": {
        "description": "Reads the value of a GPIO pin.",
        "proto" :"nsc_gpio_read(struct file  file, char __user   buf,      size_t len, loff_t   ppos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "ppos": ">=0"
        }
    },
    "kretprobe:nsc_gpio_write": {
        "description": "Writes a value to a GPIO pin.",
        "proto" :"nsc_gpio_write(struct file  file, char __user   buf,      size_t len, loff_t   ppos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": ">=0",
            "ppos": ">=0"
        }
    }
},
{
    "kprobe:nsc_gpio_read": {
        "description": "Reads a value from the GPIO and writes it to the user space buffer.",
        "proto": "nsc_gpio_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)",
        "pre": {
            "file": "!=null",
            "buf": "!=null",
            "len": ">0",
            "ppos": "!=null"
        }
    }
},
{
    "kretprobe:nsc_gpio_dump": {
        "description": "Retrieve current config without changing it",
        "proto" :"u32 config = amp->gpio_config(index, ~0, 0);/* user requested via 'v' command, so its INFO */",
        "pre": {
            "amp": "!=null",
            "index": ">=0",
            // Add more conditions here based on your understanding of the function
        },
    }
},
{
    "kprobe:nsc_gpio_dump": {
        "description": "Retrieve current config without changing it",
        "proto" :"u32 config = (*amp->gpio_config)(unsigned index, u32 arg2, u32 arg3)",
        "pre": {
            "amp": "!=null",
            "index": "is a valid index",
            "arg2": "= ~0",
            "arg3": "= 0",
        },
    }
},
{
    "kretprobe:try_to_generate_entropy": {
        "description": "Wait for the input pool to be seeded and thus guaranteed to supply cryptographically secure random numbers. This applies to: the /dev/urandom device, the get_random_bytes function, and the get_random_",
        "proto" :"static void try_to_generate_entropy(void)",
        "pre": {}
    }
},
{
    "kprobe:try_to_generate_entropy": {
        "description": "Wait for the input pool to be seeded and thus guaranteed to supply cryptographically secure random numbers. This applies to: the /dev/urandom device, the get_random_bytes function, and the get_random_",
        "proto" :"static void try_to_generate_entropy(void)"
    }
},
{
    "kretprobe:rng_is_initialized": {
        "description": "get_random_bytes function, and the get_random_{u8, u16, u32, u64, long} family of functions. Returns: true if the input pool has been seeded. false if the input pool has not been seeded.",
        "proto" :"bool rng_is_initialized(void)",
        "pre": {},
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rng_is_initialized": {
        "description": "get_random_bytes function, and the get_random_{u8, u16, u32, u64, long} family of functions. Returns: true if the input pool has been seeded. false if the input pool has not been seeded.",
        "proto" :"bool rng_is_initialized(void)",
        "pre": {},
    }
},
{
    "kretprobe:__get_random_u32_below": {
        "description": "This is the slow path for variable ceil. It is still fast, most of the time, by doing traditional reciprocal multiplication and opportunistically comparing the lower half to ceil itself, before falling back to computing a larger bound, and then rejecting samples whose lower half would indicate a range indivisible by ceil. The use of `-ceil % ceil` is analogous to `2^32 % ceil`, but is computable in 32-bits.",
        "proto" :"static u32 (*__get_random_u32_below)(u32 ceil)",
        "pre": {
            "ceil": "your condition here",
        },
    }
},
{
    "kprobe:__get_random_u32_below": {
        "description": "This is the slow path for variable ceil. It is still fast, most of the time, by doing traditional reciprocal multiplication and opportunistically comparing the lower half to ceil itself, before falling back to computing a larger bound, and then rejecting samples whose lower half would indicate a range indivisible by ceil. The use of `-ceil % ceil` is analogous to `2^32 % ceil`, but is computable in 32-bits.",
        "proto" :"static u32 (*__get_random_u32_below)(u32 ceil)",
        "pre": {
            "ceil": ">=0",
        },
    }
},
{
    "kretprobe:add_device_randomness": {
        "description": "Adds data to the input pool that is likely to differ between two devices (or possibly even per boot).",
        "proto" :"void add_device_randomness(const void *buf, size_t len)",
        "pre": {
            "buf": "!=null",
            "len": ">0",
        },
    }
},
{
    "kprobe:add_device_randomness": {
        "description": "Adds data to the input pool that is likely to differ between two devices (or possibly even per boot).",
        "proto" :"void add_device_randomness(const void  buf, size_t len)",
        "pre": {
            "buf": "!=null",
            "len": ">=0",
        },
    }
},
{
    "kretprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer. It is the only function that can be called when the backend is not owned by the caller. (So it can free memory on client death.)",
        "proto" :"void (*agp_free_memory)(struct agp_memory *curr)",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kprobe:agp_free_memory": {
        "description": "Free memory associated with an agp_memory pointer. It is the only function that can be called when the backend is not owned by the caller. (So it can free memory on client death.)",
        "proto" :"void (*agp_free_memory)(struct agp_memory *curr)",
        "pre": {
            "curr": "!=null"
        }
    }
},
{
    "kretprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type. Every agp bridge device will allow you to allocate AGP_NORMAL_MEMORY which maps to physical ram. Any other type is device dependent. It returns NULL whenever memory is unavailable.",
        "proto" :"struct agp_memory *(*agp_allocate_memory)(struct agp_bridge_data *bridge, size_t page_count, u32 type)",
        "pre": {
            "bridge": "!=null",
            "page_count": ">0",
            "type": "in [AGP_NORMAL_MEMORY, DEVICE_DEPENDENT]"
        },
    }
},
{
    "kprobe:agp_allocate_memory": {
        "description": "Allocate a group of pages of a certain type. Every agp bridge device will allow you to allocate AGP_NORMAL_MEMORY which maps to physical ram. Any other type is device dependent. It returns NULL whenever memory is unavailable.",
        "proto" :"struct agp_memory *(*agp_allocate_memory)(struct agp_bridge_data *bridge, size_t page_count, u32 type)",
        "pre": {
            "bridge": "!=null",
            "page_count": ">0",
            "type": "in [AGP_NORMAL_MEMORY, device-dependent]"
        },
    }
},
{
    "kretprobe:agp_copy_info": {
        "description": "This function copies information about the agp bridge device and the state of the agp backend into an agp_kern_info pointer.",
        "proto" :"int agp_copy_info(struct agp_bridge_data *bridge, struct agp_kern_info *info)",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kprobe:agp_copy_info": {
        "description": "This function copies information about the agp bridge device and the state of the agp backend into an agp_kern_info pointer.",
        "proto" :"int (*agp_copy_info)(struct agp_bridge_data *bridge, struct agp_kern_info *info)",
        "pre": {
            "bridge": "!=null",
            "info": "!=null"
        }
    }
},
{
    "kretprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT.",
        "proto" :"int agp_bind_memory(struct agp_memory *curr, off_t pg_start)",
        "pre": {
            "curr": "!=null",
            "pg_start": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, -EBUSY]"
        }
    }
},
{
    "kprobe:agp_bind_memory": {
        "description": "Bind an agp_memory structure into the GATT. It returns -EINVAL if the pointer == NULL. It returns -EBUSY if the area of the table requested is already in use.",
        "proto" :"int agp_bind_memory(struct agp_memory *curr, off_t pg_start)",
        "pre": {
            "curr": "!=null",
            "pg_start": ">=0"
        },
    }
},
{
    "kretprobe:agp_collect_device_status": {
        "description": "Determine correct agp_cmd from various agp_stat's. This function will hunt for an AGP graphics card, and try to match the requested mode to the capabilities of both the bridge and the card.",
        "proto" :"u32 (*agp_collect_device_status)(struct agp_bridge_data *bridge, u32 requested_mode, u32 bridge_agpstat)",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "is a valid agp_stat from userspace",
            "bridge_agpstat": "is a valid current agp_stat from AGP bridge"
        }
    }
},
{
    "kprobe:agp_collect_device_status": {
        "description": "This function will hunt for an AGP graphics card, and try to match the requested mode to the capabilities of both the bridge and the card.",
        "proto" :"u32 (*agp_collect_device_status)(struct agp_bridge_data *bridge, u32 requested_mode, u32 bridge_agpstat)",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "is u32",
            "bridge_agpstat": "is u32"
        }
    }
},
{
    "kretprobe:get_agp_version": {
        "description": "Exit early if already set by errata workarounds.",
        "proto" :"static long (*get_agp_version)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null"
        },
    }
},
{
    "kprobe:get_agp_version": {
        "description": "Exit early if already set by errata workarounds.",
        "proto" :"void get_agp_version(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null",
            "bridge->major_version": "==0",
            "bridge->dev": "!=null",
            "bridge->capndx": ">=0",
            "ncapid": "is a valid u32 value",
            "AGP_MAJOR_VERSION_SHIFT": "is a valid shift value",
            "AGP_MINOR_VERSION_SHIFT": "is a valid shift value"
        },
    }
},
{
    "kretprobe:agp_generic_enable": {
        "description": "Enable the AGP bridge with the requested mode. If the bridge status is 0, something bad happened.",
        "proto": "static long (*agp_generic_enable)(struct agp_bridge_data *bridge, u32 requested_mode)",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "is a valid mode"
        }
    }
},
{
    "kprobe:agp_generic_enable": {
        "description": "Enable the AGP bridge with the requested mode. If the bridge status is 0, something bad happened.",
        "proto": "static void (*agp_generic_enable)(struct agp_bridge_data *bridge, u32 requested_mode)",
        "pre": {
            "bridge": "!=null",
            "requested_mode": "is a valid mode"
        }
    }
},
{
    "kretprobe:agp_generic_create_gatt_table": {
        "description": "The generic routines can't handle 2 level gatt's",
        "proto" :"static long (*agp_generic_create_gatt_table)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:agp_generic_create_gatt_table": {
        "description": "The generic routines can't handle 2 level gatt's",
        "proto" :"static long (*agp_generic_create_gatt_table)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null",
            "bridge->driver->size_type": "in [LVL2_APER_SIZE, FIXED_APER_SIZE]",
            "bridge->aperture_size_idx": "is integer",
            "bridge->current_size": "is valid size",
        },
    }
},
{
    "kretprobe:agp_generic_free_gatt_table": {
        "description": "The generic routines can't deal with 2 level gatt's",
        "proto" :"static void (*agp_generic_free_gatt_table)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kprobe:agp_generic_free_gatt_table": {
        "description": "The generic routines can't deal with 2 level gatt's. Do not worry about freeing memory, because if this is called, then all agp memory is deallocated and removed from the table.",
        "proto" :"static void (*agp_generic_free_gatt_table)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null",
            "bridge->current_size": "!=null",
            "bridge->driver->size_type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]"
        }
    }
},
{
    "kretprobe:agp_generic_insert_memory": {
        "description": "The generic routines can't deal with 2 level gatt's",
        "proto" :"int agp_generic_insert_memory(struct agp_memory *mem, off_t pg_start, int type)",
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]"
        },
    }
},
{
    "kprobe:agp_generic_insert_memory": {
        "description": "The generic routines can't deal with 2 level gatt's",
        "proto" :"static int (*agp_generic_insert_memory)(struct agp_memory *mem, off_t pg_start, int type)",
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "in [U8_APER_SIZE, U16_APER_SIZE, U32_APER_SIZE, FIXED_APER_SIZE, LVL2_APER_SIZE]"
        },
    }
},
{
    "kretprobe:agp_generic_remove_memory": {
        "description": "Remove memory from the AGP bridge. Returns -EINVAL if the bridge is null, the page count is not zero, the type does not match the memory's type, the page start plus the page count is greater than the number of entries or less than the page start, or the mask type is not zero.",
        "proto" :"int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)",
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "in [mem->type]",
            "mem->page_count": "==0 || (pg_start + mem->page_count) <= agp_num_entries() && (pg_start + mem->page_count) > pg_start",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "==0"
        },
    }
},
{
    "kprobe:agp_generic_remove_memory": {
        "description": "Removes memory from the AGP aperture. Returns -EINVAL if the bridge is null, the page count is not zero, the type does not match the memory's type, the page start plus the page count is greater than the number of entries or less than the page start, or the mask type is not zero.",
        "proto" :"int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)",
        "pre": {
            "mem": "!=null",
            "pg_start": ">=0",
            "type": "==mem->type",
            "pg_start + mem->page_count": "<=agp_num_entries() && >pg_start",
            "bridge->driver->agp_type_to_mask_type(bridge, type)": "==0"
        },
    }
},
{
    "kretprobe:agp_return_size": {
        "description": "This function returns the size of the AGP. The exact behavior is not clear from the provided documentation.",
        "proto" :"static int agp_return_size(void)",
        "pre": {},
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:agp_return_size": {
        "description": "Description of the function",
        "proto" :"static int agp_return_size(void *bridge)",
        "pre": {
            "bridge": "!=null",
        },
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocates pages for the AGP bridge and memory, needs gart address.",
        "proto" :"static long (*agp_generic_alloc_pages)(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">0",
            "page": "!=null"
        },
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocates pages for the AGP memory and maps them into the AGP GART (Graphics Address Remapping Table).",
        "proto" :"static int (*agp_generic_alloc_pages)(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">0",
        },
    }
},
{
    "kretprobe:agp_generic_alloc_pages": {
        "description": "Allocates pages for AGP memory and maps them into AGP space.",
        "proto" :"static long (*agp_generic_alloc_pages)(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">0",
        },
    }
},
{
    "kprobe:agp_generic_alloc_pages": {
        "description": "Allocates pages for the AGP memory and maps them into the AGP GART (Graphics Address Remapping Table).",
        "proto" :"static long (*agp_generic_alloc_pages)(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)",
        "pre": {
            "bridge": "!=null",
            "mem": "!=null",
            "num_pages": ">0",
        },
    }
},
{
    "kretprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "proto": "void (*agp_enable)(struct agp_bridge_data *bridge, u32 mode)",
        "pre": {
            "bridge": "!=null",
            "mode": "is a valid u32 value"
        }
    }
},
{
    "kprobe:agp_enable": {
        "description": "Initialise the agp point-to-point connection.",
        "proto" :"void (*agp_enable)(struct agp_bridge_data *bridge, u32 mode)",
        "pre": {
            "bridge": "!=null",
            "mode": "is a valid u32 value"
        }
    }
},
{
    "kretprobe:agp_generic_mask_memory": {
        "description": "Memory type is ignored in the generic routine",
        "proto" :"static long (*agp_generic_mask_memory)(struct agp_bridge_data *bridge, dma_addr_t addr, int type)",
        "pre": {
            "bridge": "!=null",
            "addr": "is valid dma_addr_t",
            "type": "is valid int"
        },
    }
},
{
    "kprobe:agp_generic_mask_memory": {
        "description": "Memory type is ignored in the generic routine",
        "proto" :"static long (*agp_generic_mask_memory)(struct agp_bridge_data *bridge, dma_addr_t addr, int type)",
        "pre": {
            "bridge": "!=null",
            "addr": "is valid dma_addr_t",
            "type": "is valid int",
        },
    }
},
{
    "kretprobe:pci_write_config_word": {
        "description": "Set aperture size",
        "proto" :"void pci_write_config_word(struct pci_dev *dev, int where, u16 val)",
        "pre": {
            "dev": "!=null",
            "where": ">=0",
            "val": ">=0"
        }
    }
},

{
    "kretprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend. @pdev: the PCI device",
        "proto" :"struct agp_bridge_data *(*agp_backend_acquire)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:agp_backend_acquire": {
        "description": "Attempt to acquire an agp backend. @pdev: the PCI device",
        "proto" :"struct agp_bridge_data *(*agp_backend_acquire)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null",
        },
    }
},
{
    "kretprobe:agp_backend_release": {
        "description": "Release the lock on the agp backend. The caller must insure that the graphics aperture translation table is ready for use by another entity. (Ensure that all memory it bound is unbound.)",
        "proto" :"void (*agp_backend_release)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null"
        },
        "post": {
            "bridge": "lock_released && memory_unbound"
        }
    }
},
{
    "kprobe:agp_backend_release": {
        "description": "Release the lock on the agp backend. The caller must insure that the graphics aperture translation table is ready for use by another entity. (Ensure that all memory it bound is unbound.)",
        "proto" :"void (*agp_backend_release)(struct agp_bridge_data *bridge)",
        "pre": {
            "bridge": "!=null"
        }
    }
},
{
    "kretprobe:agp_alloc_bridge": {
        "description": "agp_alloc_bridge and agp_generic_find_bridge need to be updated",
        "proto" :"struct agp_bridge_data *(*agp_alloc_bridge)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:agp_alloc_bridge": {
        "description": "Allocates a new agp_bridge_data structure.",
        "proto" :"struct agp_bridge_data *(*agp_alloc_bridge)(void)",
        "pre": {},
        "post": {
            "return": "!=null"
        }
    }
},


{
    "kretprobe:intel_gmch_enable_gtt": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition for param1 here",
            "param2": "Your condition for param2 here",
            "param3": "Your condition for param3 here",
            "param4": "Your condition for param4 here",
        },
    }
},
{
    "kprobe:intel_gmch_enable_gtt": {
        "description": "On the resume path we may be adjusting the PGTBL value, so be paranoid and flush all chipset write buffers...",
        "proto" :"void intel_gmch_enable_gtt(void)",
        "pre": {
            "INTEL_GTT_GEN": ">= 2",
            "intel_private.bridge_dev": "!=null",
            "I830_GMCH_CTRL": "!=null",
            "gmch_ctrl": "!=null",
            "intel_private.pcidev->dev": "!=null",
            "intel_private.registers": "!=null",
            "GFX_FLSH_CNTL": "!=null",
            "I810_PGETBL_CTL": "!=null",
            "intel_private.PGETBL_save": "!=null",
            "HAS_PGTBL_EN": "!=null",
            "I810_PGETBL_ENABLED": "!=null"
        },
    }
},
{
    "kretprobe:intel_gmch_gtt_insert_sg_entries": {
        "description": "Please fill in the description here.",
        "proto" :"static long (*intel_gmch_gtt_insert_sg_entries)(struct sg_table *st, unsigned int pg_start, unsigned int flags)",
        "pre": {
            "st": "Please fill in the condition here.",
            "pg_start": "Please fill in the condition here.",
            "flags": "Please fill in the condition here."
        },
    }
},
{
    "kprobe:intel_gmch_gtt_insert_sg_entries": {
        "description": "Please fill in the description here.",
        "proto" :"static long (*intel_gmch_gtt_insert_sg_entries)(struct sg_table *st, unsigned int pg_start, unsigned int flags)",
        "pre": {
            "st": "!=null",
            "pg_start": "Please fill in the condition here.",
            "flags": "Please fill in the condition here.",
        },
    }
},
{
    "kretprobe:intel_gmch_probe": {
        "description": "Can be called from the fake agp driver but also directly from drmi915.ko. Hence we need to check whether everything is set up already.",
        "proto" :"intel_gmch_probe(struct pci_dev  bridge_pdev, struct pci_dev  gpu_pdev, struct agp_bridge_data  bridge)",
        "pre": {
            "bridge_pdev": "!=null",
            "gpu_pdev": "!=null",
            "bridge": "!=null"
        },
    }
},

{
    "kretprobe:kobject_put": {
        "description": "Decrements the reference count of the kobject. When the reference count reaches 0, the kobject's ktype's release function is called to free its memory.",
        "proto" :"void kobject_put(struct kobject *kobj)",
        "pre": {
            "kobj": "!=null"
        }
    }
},
{
    "kprobe:xillybus_init_chrdev": {
        "description": "Initializes a character device for the Xillybus driver.",
        "proto" :"int xillybus_init_chrdev(struct device *dev, const struct file_operations *fops, struct module *owner, void *private_data, unsigned char idt, unsigned int len, int num_nodes, const char *prefix, bool enumerate)",
        "pre": {
            "dev": "!=null",
            "fops": "!=null",
            "owner": "!=null",
            "private_data": "!=null",
            "idt": "in [0, 255]",
            "len": ">=0",
            "num_nodes": ">=0",
            "prefix": "!=null",
            "enumerate": "in [true, false]"
        },
    }
},
{
    "kretprobe:xillybus_isr": {
        "description": "xillybus_isr assumes the interrupt is allocated exclusively to it, which is the natural case MSI and several other hardware-oriented interrupts. Sharing is not allowed.",
        "proto" :"irqreturn_t (*xillybus_isr)(int irq, void *data)",
        "pre": {
            "irq": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kprobe:xillybus_isr": {
        "description": "xillybus_isr assumes the interrupt is allocated exclusively to it, which is the natural case MSI and several other hardware-oriented interrupts. Sharing is not allowed.",
        "proto" :"irqreturn_t (*xillybus_isr)(int irq, void *data)",
        "pre": {
            "irq": ">=0",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:xillybus_endpoint_discovery": {
        "description": "The bogus IDT is used during bootstrap for allocating the initial message buffer, and then the message buffer and space for the IDT itself. The initial message buffer is of a single page's size, but it's soon replaced with a more modest one (and memory is freed).",
        "proto" :"xillybus_endpoint_discovery(struct xilly_endpoint  endpoint)",
        "pre": {
            "endpoint": "!=null",
        },
    }
},

{
    "kretprobe:flush_workqueue": {
        "description": "Flushing is done upon endpoint release to prevent access to memory just about to be released. This makes the quiesce complete.",
        "proto" :"static long (*flush_workqueue)(struct xilly_endpoint *endpoint)",
        "pre": {
            "endpoint": "???",
        },
    }
},
{
    "kprobe:flush_workqueue": {
        "description": "Flushing is done upon endpoint release to prevent access to memory just about to be released. This makes the quiesce complete.",
        "proto" :"void flush_workqueue(struct workqueue_struct *wq)",
        "pre": {
            "wq": "!=null",
        },
    },
    "kprobe:xillybus_endpoint_remove": {
        "description": "Removes an endpoint and cleans up associated character devices. Quiesces the endpoint.",
        "proto" :"void xillybus_endpoint_remove(struct xilly_endpoint *endpoint)",
        "pre": {
            "endpoint": "!=null",
        },
    }
},

{
    "kprobe:ipmi_addr_src_to_str": {
        "description": "Converts the ipmi_addr_src enum to a string representation.",
        "proto" :"static char *(*ipmi_addr_src_to_str)(enum ipmi_addr_src src)",
        "pre": {
            "src": "in [0, SI_LAST-1]"
        },
    }
},
{
    "kretprobe:ipmi_smi_watcher_register": {
        "description": "Make sure the driver is actually initialized, this handles problems with initialization order.",
        "proto" :"static long (*ipmi_smi_watcher_register)(struct ipmi_smi_watcher *watcher)",
        "pre": {
            "watcher": "!=null"
        },
    }
},
{
    "kprobe:ipmi_smi_watcher_register": {
        "description": "Make sure the driver is actually initialized, this handles problems with initialization order.",
        "proto" :"static int (*ipmi_smi_watcher_register)(struct ipmi_smi_watcher *watcher)",
        "pre": {
            "watcher": "!=null",
        },
    }
},

{
    "kprobe:ipmi_create_user": {
        "description": "Create a new IPMI user.",
        "proto" :"int (*ipmi_create_user)(unsigned int if_num, const struct ipmi_user_hndl *handler, void *handler_data, struct ipmi_user *user)",
        "pre": {
            "if_num": ">=0",
            "handler": "!=null",
            "handler_data": "can be any value",
            "user": "!=null",
        },
    }
},
{
    "kretprobe:ipmi_get_smi_info": {
        "description": "Get the SMI info for the given interface number and data structure.",
        "proto" :"int ipmi_get_smi_info(int if_num, struct ipmi_smi_info *data)",
        "pre": {
            "if_num": ">=0",
            "data": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -ENOTTY, 0]"
        }
    }
},
{
    "kprobe:ipmi_get_smi_info": {
        "description": "Get the SMI info for the given interface number. If not found, return an error.",
        "proto" :"int ipmi_get_smi_info(int if_num, struct ipmi_smi_info *data)",
        "pre": {
            "if_num": ">=0",
            "data": "!=null",
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:ipmi_destroy_user": {
        "description": "The user has already been cleaned up, just make sure nothing is using it and return.",
        "proto" :"static long (*ipmi_destroy_user)(struct ipmi_user *user)",
        "pre": {
            "user": "!=null",
        },
    }
},
{
    "kretprobe:ipmi_set_gets_events": {
        "description": "Set or get events for a specific user. If the user already gets events equal to the value, it will go out. If the value is true, it will increase the event_waiters, otherwise, it will decrease the event_waiters. If another thread is delivering events for this, let it handle any new events.",
        "proto" :"int ipmi_set_gets_events(struct ipmi_user user, bool val)",
        "pre": {
            "user": "!=null",
            "val": "in [true, false]"
        },
    }
},

{
    "kretprobe:is_cmd_rcvr_exclusive": {
        "description": "Make sure the command/netfn is not already registered.",
        "proto" :"static int (*is_cmd_rcvr_exclusive)(struct ipmi_smi *intf, unsigned char netfn, unsigned char cmd, unsigned int chans)",
        "pre": {
            "intf": "!=null",
            "netfn": "is an unsigned char",
            "cmd": "is an unsigned char",
            "chans": "is an unsigned int"
        },
    }
},
{
    "kprobe:ipmi_register_for_cmd": {
        "description": "Register a command for a specific user, netfn, cmd, and chans. Make sure the command/netfn is not already registered.",
        "proto" :"static int (*ipmi_register_for_cmd)(struct ipmi_user *user, unsigned char netfn, unsigned char cmd, unsigned int chans)",
        "pre": {
            "user": "!=null",
            "netfn": "is unsigned char",
            "cmd": "is unsigned char",
            "chans": "is unsigned int",
        },
    }
},
{
    "kretprobe:__bmc_get_device_id": {
        "description": "ipmi_add_smi(), this will always return good data;",
        "proto" :"static int __bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc, struct ipmi_device_id *id, bool *guid_set, guid_t *guid, int intf_num)",
        "pre": {
            "intf": "!=null",
            "bmc": "!=null",
            "id": "!=null",
            "guid_set": "!=null",
            "guid": "!=null",
            "intf_num": ">=0"
        },
    }
},
{
    "kprobe:__bmc_get_device_id": {
        "description": "ipmi_add_smi(), this will always return good data;",
        "proto" :"static int __bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc, struct ipmi_device_id *id, bool *guid_set, guid_t *guid, int intf_num)",
        "pre": {
            "intf": "!=null",
            "bmc": "!=null",
            "id": "!=null",
            "guid_set": "!=null",
            "guid": "!=null",
            "intf_num": ">=0",
        },
    }
},


{
    "kretprobe:run_to_completion": {
        "description": "Description of the function goes here",
        "proto" :"int run_to_completion = intf->run_to_completion;/* * To preserve message order, we keep a queue and deliver from * a tasklet. `",
        "pre": {
            "intf": "!=null",
            "msg": "!=null",
            "flags": "in [FLAG1, FLAG2, FLAG3]",
        },
    }
},
{
    "kprobe:ipmi_smi_msg_received": {
        "description": "Description of the function",
        "proto" :"int ipmi_smi_msg_received(struct ipmi_smi *intf, struct ipmi_smi_msg *msg)",
        "pre": {
            "intf": "!=null",
            "msg": "!=null"
        },
    }
},
{
    "kretprobe:ipmi_alloc_smi_msg": {
        "description": "The put happens when the message is freed.",
        "proto" :"static long (*ipmi_alloc_smi_msg)(void *smi_msg, bool supplied_recv, void *recv_msg, int rv, void *intf, void *user)",
        "pre": {
            "smi_msg": "!=null",
            "supplied_recv": "is boolean",
            "recv_msg": "!=null",
            "rv": "is integer",
            "intf": "!=null",
            "user": "!=null"
        },
    }
},
{
    "kprobe:kref_get": {
        "description": "The put happens when the message is freed.",
        "proto" :"static long (*kref_get)(struct kref *kref)",
        "pre": {
            "kref": "!=null",
        },
    },
    "kprobe:recv_msg->msgid": {
        "description": "Store the message to send in the receive message so timeout responses can get the proper response data.",
        "proto" :"static long (*recv_msg->msgid)(int msgid)",
        "pre": {
            "msgid": ">=0",
        },
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex pointed by &intf->cmd_rcvrs_mutex.",
        "proto" :"static long (*mutex_lock)(struct mutex *lock)",
        "pre": {
            "lock": "!=null",
        },
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex pointed by &intf->cmd_rcvrs_mutex.",
        "proto" :"void mutex_lock(struct mutex *lock)",
        "pre": {
            "lock": "!=null"
        }
    }
},
{
    "kretprobe:platform_device_alloc": {
        "description": "Allocates a platform device. Returns a pointer to the device, or NULL if the allocation fails.",
        "proto": "struct platform_device *(*platform_device_alloc)(const char *name, unsigned int inst)",
        "pre": {
            "name": "!=null",
            "inst": "is a valid instance identifier"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:platform_device_alloc": {
        "description": "Allocates a platform device with a specific name and instance number.",
        "proto" :"struct platform_device *(*platform_device_alloc)(const char *name, unsigned int inst)",
        "pre": {
            "name": "!=null",
            "inst": "is a valid instance number"
        },
        "post": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:st33zp24_probe": {
        "description": "Probes the st33zp24 device. Allocates a TPM chip, sets various parameters, and optionally adds driver GPIOs if the device has an ACPI companion. Returns an error code if any step fails.",
        "proto": "int st33zp24_probe(void phy_id, const struct st33zp24_phy_ops ops, struct device dev, int irq)",
        "pre": {
            "phy_id": "!=null",
            "ops": "!=null",
            "dev": "!=null",
            "irq": "is valid interrupt number"
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},

{
    "kretprobe:bbc_i2c_readb": {
        "description": "This function reads a byte from the specified offset of the I2C device.",
        "proto" :"int bbc_i2c_readb(struct bbc_i2c_client *client, unsigned char byte, int off)",
        "pre": {
            "client": "!=null",
            "client->bp": "!=null",
            "client->address": "is valid I2C address",
            "byte": "is valid byte value",
            "off": "is valid offset"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:bbc_i2c_readb": {
        "description": "This function reads a byte from the I2C bus.",
        "proto" :"static int (*bbc_i2c_readb)(struct bbc_i2c_client *client, unsigned char *byte, int off)",
        "pre": {
            "client": "!=null",
            "byte": "!=null",
            "off": ">=0",
            "client->bp": "!=null",
            "client->address": "in [0x00, 0xFF]",
            "client->bus": "in [0x00, 0xFF]",
            "bp->i2c_bussel_reg": "can be null",
            "bp->i2c_control_regs": "!=null",
            "I2C_PCF_START": "is a constant",
            "I2C_PCF_STOP": "is a constant",
            "I2C_PCF_LRB": "is a constant",
            "wait_for_pin": "is a function"
        },
    }
},
{
    "kretprobe:dma_request_channel": {
        "description": "Requests an exclusive channel. Once a channel is allocated a reference is taken against its corresponding driver to disable removal. Each device has a channels list, which runs unlocked but is never modified once the device is registered, it's just setup by the driver.",
        "proto" :"static long (*dma_request_channel)(void *device)",
        "pre": {
            "device": "!=null"
        },
    }
},
{
    "kprobe:dma_request_channel": {
        "description": "Requests an exclusive channel. Once a channel is allocated a reference is taken against its corresponding driver to disable removal. Each device has a channels list, which runs unlocked but is never modified once the device is registered, it's just setup by the driver.",
        "proto" :"static struct dma_chan *(*dma_request_channel)(dma_cap_mask_t mask, dma_filter_fn fn, void *fn_param)",
        "pre": {
            "mask": "!=null",
            "fn": "!=null",
            "fn_param": "!=null"
        },
    }
},
{
    "kretprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels",
        "proto" :"static void (*dma_issue_pending_all)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:dma_issue_pending_all": {
        "description": "Flush all pending operations across all channels.",
        "proto": "static void (*dma_issue_pending_all)(void)",
        "pre": {}
    }
},
{
    "kretprobe:dmaengine_put": {
        "description": "Let DMA drivers be removed when ref_count == 0",
        "proto" :"void (*dmaengine_put)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:dmaengine_put": {
        "description": "Let DMA drivers be removed when ref_count == 0.",
        "proto": "static void (*dmaengine_put)(void)",
        "pre": {}
    }
},
{
    "kretprobe:dma_async_device_register": {
        "description": "dma_async_device_unregister() is called and no further references are taken.",
        "proto" :"int dma_async_device_register(struct dma_device *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:dma_async_device_register": {
        "description": "dma_async_device_unregister() is called and no further references are taken.",
        "proto" :"int dma_async_device_register(struct dma_device *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found. The operation is managed and will be undone on driver detach.",
        "proto" :"int (*dmaenginem_async_device_register)(struct dma_device *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:dmaenginem_async_device_register": {
        "description": "Registers DMA devices found. The operation is managed and will be undone on driver detach.",
        "proto" :"int (*dmaenginem_async_device_register)(struct dma_device *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kretprobe:iowrite32": {
        "description": "Writes a 32 bit value to the specified memory address.",
        "proto" :"void iowrite32(u32 value, void __iomem *addr)",
        "pre": {
            "value": "is u32",
            "addr": "!=null"
        },
    },
    "kretprobe:mcf_edma_remove": {
        "description": "Removes the eDMA engine from the platform device.",
        "proto" :"int mcf_edma_remove(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null"
        },
    }
},
{
    "kprobe:iowrite32": {
        "description": "Writes a 32 bit value to the specified memory address.",
        "proto" :"void iowrite32(u32 value, void __iomem *addr)",
        "pre": {
            "value": "is u32",
            "addr": "!=null",
        },
    },
    "kprobe:mcf_edma_remove": {
        "description": "Removes the eDMA engine from the platform device.",
        "proto" :"int mcf_edma_remove(struct platform_device *pdev)",
        "pre": {
            "pdev": "!=null",
        },
    }
},
{
    "kretprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "proto" :"void (*xdma_disable_user_irq)(struct platform_device *pdev, u32 irq_num)",
        "pre": {
            "pdev": "!=null",
            "irq_num": ">=0"
        }
    }
},
{
    "kprobe:xdma_disable_user_irq": {
        "description": "Disable user interrupt",
        "proto" :"void (*xdma_disable_user_irq)(struct platform_device *pdev, u32 irq_num)",
        "pre": {
            "pdev": "!=null",
            "irq_num": "is a valid system IRQ number"
        }
    }
},
{
    "kretprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "proto" :"int (*xdma_enable_user_irq)(struct platform_device *pdev, u32 irq_num)",
        "pre": {
            "pdev": "!=null",
            "irq_num": ">=0"
        }
    }
},
{
    "kprobe:xdma_enable_user_irq": {
        "description": "Enable user logic interrupt",
        "proto" :"int (*xdma_enable_user_irq)(struct platform_device *pdev, u32 irq_num)",
        "pre": {
            "pdev": "!=null",
            "irq_num": ">=0"
        }
    }
},
{
    "kretprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number. The system IRQ number allocated for the given wire index.",
        "proto" :"int xdma_get_user_irq(struct platform_device *pdev, u32 user_irq_index)",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "is a valid index"
        },
    }
},
{
    "kprobe:xdma_get_user_irq": {
        "description": "Get system IRQ number for the given wire index.",
        "proto" :"int (*xdma_get_user_irq)(struct platform_device *pdev, u32 user_irq_index)",
        "pre": {
            "pdev": "!=null",
            "user_irq_index": "is a valid index"
        }
    }
},
{
    "kretprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel. Run-time configuration for Axi VDMA, supports: halt the channel, configure interrupt coalescing and inter-packet delay threshold, startstop parking, enable genlock.",
        "proto" :"int (*xilinx_vdma_channel_set_config)(struct dma_chan *dchan, struct xilinx_vdma_config *cfg)",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        },
        "post": {
            "return": "in [0, error_value]"
        }
    }
},
{
    "kprobe:xilinx_vdma_channel_set_config": {
        "description": "Configure VDMA channel. Run-time configuration for Axi VDMA, supports: halt the channel, configure interrupt coalescing and inter-packet delay threshold, startstop parking, enable genlock.",
        "proto" :"int (*xilinx_vdma_channel_set_config)(struct dma_chan *dchan, struct xilinx_vdma_config *cfg)",
        "pre": {
            "dchan": "!=null",
            "cfg": "!=null"
        },
        "post": {
            "return": "in [0, error_value]"
        }
    }
},
{
    "kretprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "proto" :"shdma_chan_filter(struct dma_chan  chan, void  arg)",
        "pre": {
            "chan": "!=null",
            "arg": "!=null"
        }
    }
},
{
    "kprobe:shdma_chan_filter": {
        "description": "Only support channels handled by this driver.",
        "proto" :"shdma_chan_filter(struct dma_chan  chan, void  arg)",
        "pre": {
            "chan": "!=null",
            "arg": "!=null",
            "chan->device->device_alloc_chan_resources": "!=shdma_alloc_chan_resources",
            "schan": "to_shdma_chan(chan)",
            "sdev": "to_shdma_dev(chan->device)",
            "slave_id": "(long)arg"
        },
    }
},

{
    "kprobe:shdma_for_each_chan": {
        "description": "Reset all channels",
        "proto" :"static void (*shdma_for_each_chan)(struct shdma_chan *schan, struct shdma_dev *sdev, int i)",
        "pre": {
            "schan": "!=null",
            "sdev": "!=null",
            "i": ">=0",
        },
    }
},

{
    "kprobe:shdma_chan_probe": {
        "description": "Initializes a shdma_chan structure and associates it with a shdma_dev structure.",
        "proto": "void shdma_chan_probe(struct shdma_dev *sdev, struct shdma_chan *schan, int id)",
        "pre": {
            "sdev": "!=null",
            "schan": "!=null",
            "id": ">=0"
        }
    }
},
{
    "kretprobe:shdma_init": {
        "description": "Require all call-backs for now, they can trivially be made optional later as required.",
        "proto": "int shdma_init(struct device *dev, struct shdma_dev *sdev, int chan_num)",
        "pre": {
            "dev": "!=null",
            "sdev": {
                "ops": "!=null",
                "desc_size": ">0",
                "ops->embedded_desc": "!=null",
                "ops->start_xfer": "!=null",
                "ops->setup_xfer": "!=null",
                "ops->set_slave": "!=null",
                "ops->desc_setup": "!=null",
                "ops->slave_addr": "!=null",
                "ops->channel_busy": "!=null",
                "ops->halt_channel": "!=null",
                "ops->desc_completed": "!=null"
            },
            "chan_num": ">=0"
        },
        "post": {
            "sdev->schan": "!=null",
            "&dma_dev->channels": "list is initialized"
        }
    }
},
{
    "kprobe:shdma_init": {
        "description": "Require all call-backs for now, they can trivially be made optional later as required.",
        "proto" :"static long (*shdma_init)(struct device *dev, struct shdma_dev *sdev, int chan_num)",
        "pre": {
            "dev": "!=null",
            "sdev": {
                "ops": "!=null",
                "desc_size": ">0",
                "ops->embedded_desc": "!=null",
                "ops->start_xfer": "!=null",
                "ops->setup_xfer": "!=null",
                "ops->set_slave": "!=null",
                "ops->desc_setup": "!=null",
                "ops->slave_addr": "!=null",
                "ops->channel_busy": "!=null",
                "ops->halt_channel": "!=null",
                "ops->desc_completed": "!=null"
            },
            "chan_num": ">=0"
        },
    }
},
{
    "kretprobe:pci_match_id": {
        "description": "Used by a driver to check whether a PCI device is in its list of supported devices. Returns the matching pci_device_id structure or %NULL if there is no match. Deprecated; don't use this as it will not catch any dynamic IDs that a driver might want to check for.",
        "proto" :"const struct pci_device_id *(*pci_match_id)(const struct pci_device_id *ids, struct pci_dev *dev)",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kprobe:pci_match_id": {
        "description": "Used by a driver to check whether a PCI device is in its list of supported devices. Returns the matching pci_device_id structure or %NULL if there is no match. Deprecated; don't use this as it will not catch any dynamic IDs that a driver might want to check for.",
        "proto" :"const struct pci_device_id *(*pci_match_id)(const struct pci_device_id *ids, struct pci_dev *dev)",
        "pre": {
            "ids": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__pci_register_driver": {
        "description": "Adds the driver structure to the list of registered drivers. Returns a negative value on error, otherwise 0. If no error occurred, the driver remains registered even if no device was claimed during registration.",
        "proto" :"int (*__pci_register_driver)(struct pci_driver *drv, struct module *owner, const char *mod_name)",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        },
        "post": {
            "return": "in [-inf, 0]"
        }
    }
},
{
    "kprobe:__pci_register_driver": {
        "description": "Adds the driver structure to the list of registered drivers. Returns a negative value on error, otherwise 0. If no error occurred, the driver remains registered even if no device was claimed during registration.",
        "proto" :"int (*__pci_register_driver)(struct pci_driver *drv, struct module *owner, const char *mod_name)",
        "pre": {
            "drv": "!=null",
            "owner": "!=null",
            "mod_name": "!=null"
        },
    }
},
{
    "kretprobe:pci_unregister_driver": {
        "description": "Unregister a PCI driver. Deletes the driver structure from the list of registered PCI drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto": "void (*pci_unregister_driver)(struct pci_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:pci_unregister_driver": {
        "description": "Unregister a pci driver. Deletes the driver structure from the list of registered PCI drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void (*pci_unregister_driver)(struct pci_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device. Returns the appropriate pci_driver structure or %NULL if there is no registered driver for the device.",
        "proto" :"struct pci_driver *(*pci_dev_driver)(const struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:pci_dev_driver": {
        "description": "Get the pci_driver of a device. Returns the appropriate pci_driver structure or %NULL if there is no registered driver for the device.",
        "proto" :"struct pci_driver *(*pci_dev_driver)(const struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kprobe:pm_runtime_put_sync": {
        "description": "If the device is still on, set the power state as 'unknown', since it might change by the next time we load the driver.",
        "proto" :"static void (*pm_runtime_put_sync)(struct device *dev)",
        "pre": {
            "dev": "!=null && is_on(dev)"
        },
    }
},
{
    "kretprobe:pci_unregister_driver": {
        "description": "Deletes the driver structure from the list of registered PCI drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void pci_unregister_driver(struct pci_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "__pci_register_driver": {
        "description": "register with core",
        "proto" :"static long (*__pci_register_driver)(struct pci_driver *drv)",
        "pre": {
            "drv": "!=null",
        },
    },
    "pci_unregister_driver": {
        "description": "unregister a pci driver",
        "proto" :"static long (*pci_unregister_driver)(struct pci_driver *drv)",
        "pre": {
            "drv": "!=null",
        },
    }
},
{
    "kretprobe:pci_fixup_device": {
        "description": "Fixes up the PCI devices based on the fixup pass provided.",
        "proto" :"void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)",
        "pre": {
            "pass": "in [pci_fixup_early, pci_fixup_header, pci_fixup_final, pci_fixup_enable, pci_fixup_resume, pci_fixup_resume_early, pci_fixup_suspend, pci_fixup_suspend_late]",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_fixup_device": {
        "description": "This function applies various fixups to the PCI device based on the fixup pass stage.",
        "proto" :"void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)",
        "pre": {
            "pass": "in [pci_fixup_early, pci_fixup_header, pci_fixup_final, pci_fixup_enable, pci_fixup_resume, pci_fixup_resume_early, pci_fixup_suspend, pci_fixup_suspend_late]",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_claim_resource": {
        "description": "Claims a PCI resource. If the resource has a shadow copy in RAM, the PCI device doesn't respond to the shadow range, so we don't need to claim it, and upstream bridges don't need to route the range to the device.",
        "proto": "int pci_claim_resource(struct pci_dev *dev, int resource)",
        "pre": {
            "dev": "!=null",
            "resource": "is an integer"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:pci_claim_resource": {
        "description": "Claims a PCI resource. If the resource has a shadow copy in RAM, the PCI device doesn't respond to the shadow range, so we don't need to claim it, and upstream bridges don't need to route the range to the device.",
        "proto" :"pci_claim_resource(struct pci_dev  dev, int resource)",
        "pre": {
            "dev": "!=null",
            "resource": "is valid resource index",
            "res": "is &dev->resource[resource]",
            "root": "is pci_find_parent_resource(dev, res)",
            "flags": "in [IORESOURCE_UNSET, IORESOURCE_ROM_SHADOW]"
        },
    }
},
{
    "kretprobe:pci_assign_resource": {
        "description": "Assigns a resource to a PCI device. First, it tries exact prefetching match. Even if a 64-bit prefetchable bridge window is below 4GB, it can't put a 32-bit prefetchable resource in it because pbus_size_mem() assumes a 64-bit window will contain no 32-bit resources. If we assign things differently than they were sized, not everything will fit.",
        "proto" :"int pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev, int resno, resource_size_t size, resource_size_t align)",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "resno": ">=0",
            "size": ">0",
            "align": ">0"
        },
        "post": {
            "ret": "in [0, -EBUSY, -EINVAL, -ENOSPC, -ENOMEM]"
        }
    }
},
{
    "kprobe:pci_assign_resource": {
        "description": "Assigns a resource to a PCI device. First, it tries an exact prefetching match. Even if a 64-bit prefetchable bridge window is below 4GB, it can't put a 32-bit prefetchable resource in it because pbus_size_mem() assumes a 64-bit window will contain no 32-bit resources. If we assign things differently than they were sized, not everything will fit.",
        "proto" :"int pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev, int resno, resource_size_t size, resource_size_t align)",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "resno": ">=0",
            "size": ">=0",
            "align": ">=0",
            "res->flags": "in [IORESOURCE_IO, IORESOURCE_MEM]",
            "min": "in [PCIBIOS_MIN_IO, PCIBIOS_MIN_MEM]"
        },
    }
},


{
    "kretprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge. If it's a bridge, configure it and scan the bus behind it. For CardBus bridges, we don't scan behind as the devices will be handled by the bridge driver itself. We need to process bridges in two passes -- first we scan those already configured by the BIOS and after we are done with all of them, we proceed to assigning numbers to the remaining buses in order to avoid overlaps between old and new bus numbers.",
        "proto": "static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,  int max, unsigned int available_buses,  int pass)",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": ">=0",
            "available_buses": ">=0",
            "pass": "in [0, 1]"
        },
    }
},
{
    "kprobe:pci_scan_bridge_extend": {
        "description": "Scan buses behind a bridge. If it's a bridge, configure it and scan the bus behind it. For CardBus bridges, we don't scan behind as the devices will be handled by the bridge driver itself. We need to process bridges in two passes -- first we scan those already configured by the BIOS and after we are done with all of them, we proceed to assigning numbers to the remaining buses in order to avoid overlaps between old and new bus numbers.",
        "proto" :"static int (*pci_scan_bridge_extend)(struct pci_bus *bus, struct pci_dev *dev, int max, unsigned int available_buses, int pass)",
        "pre": {
            "bus": "!=null",
            "dev": "!=null",
            "max": ">=0",
            "available_buses": ">=0",
            "pass": "in [0, 1]"
        },
    }
},
{
    "kretprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable. Returns true if the device has enabled relaxed ordering attribute.",
        "proto" :"bool (*pcie_relaxed_ordering_enabled)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcie_relaxed_ordering_enabled": {
        "description": "Probe for PCIe relaxed ordering enable. Returns true if the device has enabled relaxed ordering attribute.",
        "proto" :"bool (*pcie_relaxed_ordering_enabled)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_read_dev_vendor_id": {
        "description": "Certain IDT switches have an issue where they improperly trigger ACS Source Validation errors on completions for config reads.",
        "proto" :"static long (*pci_bus_read_dev_vendor_id)(struct pci_bus *bus, int devfn, u32 l, int timeout)",
        "pre": {
            "bus": "!=null",
            "devfn": "is a valid device function number",
            "l": "is a valid u32 value",
            "timeout": "is a valid timeout value"
        },
    }
},
{
    "kprobe:pci_bus_read_dev_vendor_id": {
        "description": "Certain IDT switches have an issue where they improperly trigger ACS Source Validation errors on completions for config reads.",
        "proto" :"static long (*pci_bus_read_dev_vendor_id)(struct pci_bus *bus, int devfn, u32 l, int timeout)",
        "pre": {
            "bus": "!=null",
            "devfn": "is an integer",
            "l": "is a u32",
            "timeout": "is an integer",
        },
    }
},
{
    "kretprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on the specified PCI bus for devices, adding discovered devices to the @bus->devices list. New devices will not have is_added set. Returns the number of new devices found.",
        "proto" :"int pci_scan_slot(struct pci_bus *bus, int devfn)",
        "pre": {
            "bus": "!=null",
            "devfn": ">=0"
        },
    }
},
{
    "kprobe:pci_scan_slot": {
        "description": "Scan a PCI slot on the specified PCI bus for devices, adding discovered devices to the @bus->devices list. New devices will not have is_added set. Returns the number of new devices found.",
        "proto" :"int (*pci_scan_slot)(struct pci_bus *bus, int devfn)",
        "pre": {
            "bus": "!=null",
            "devfn": ">=0"
        }
    }
},
{
    "kretprobe:pci_has_flag": {
        "description": "Check if the PCI device has a specific flag set.",
        "proto" :"static int (*pci_has_flag)(int flag)",
        "pre": {
            "flag": "in [PCI_PROBE_ONLY, ...]",
        },
    }
},
{
    "kprobe:pci_has_flag": {
        "description": "Check if the PCI device has the PCI_PROBE_ONLY flag set.",
        "proto" :"static int (*pci_has_flag)(enum pci_flags flag)",
        "pre": {
            "flag": "in [PCI_PROBE_ONLY]"
        }
    }
},
{
    "kretprobe:pci_read_vpd_any": {
        "description": "Unknown. Please provide a clear description.",
        "proto" :"int pci_read_vpd_any(struct pci_dev *dev, int off, size_t len, void *buf)",
        "pre": {
            "dev": "!=null",
            "off": ">=0",
            "len": "==2",
            "buf": "!=null"
        },
    }
},
{
    "kprobe:pci_read_vpd_any": {
        "description": "Large Resource Data Type Tag",
        "proto" :"int pci_read_vpd_any(struct pci_dev *dev, int off, size_t len, void *buf)",
        "pre": {
            "dev": "!=null",
            "off": ">=0",
            "len": ">=0",
            "buf": "!=null"
        },
    }
},

{
    "kprobe:pci_vpd_find_tag": {
        "description": "Look for LRDT tags only, end tag is the only SRDT tag.",
        "proto": "static int pci_vpd_find_tag(const u8 buf, unsigned int len, u8 rdt, unsigned int size)",
        "pre": {
            "i": ">=0",
            "PCI_VPD_LRDT_TAG_SIZE": "constant",
            "len": ">=0",
            "buf": "!=null",
            "PCI_VPD_LRDT": "constant"
        },
        "loop": {
            "condition": "i + PCI_VPD_LRDT_TAG_SIZE <= len && buf[i] & PCI_VPD_LRDT"
        }
    }
},
{
    "kretprobe:vga_remove_vgacon": {
        "description": "Deactivate vga console. Unbind and unregister vgacon in case pdev is the default vga device. Can be called by gpu drivers on initialization to make sure vga register access done by vgacon will not disturb the device.",
        "proto" :"#if !defined(CONFIG_VGA_CONSOLE)int vga_remove_vgacon(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:vga_remove_vgacon": {
        "description": "Deactivate vga console. Unbind and unregister vgacon in case pdev is the default vga device. Can be called by gpu drivers on initialization to make sure vga register access done by vgacon will not disturb the device.",
        "proto" :"#if !defined(CONFIG_VGA_CONSOLE)int (*vga_remove_vgacon)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:vga_default_device": {
        "description": "Please provide a description for the function here.",
        "proto" :"struct pci_dev *(*vga_default_device)(void)",
        "pre": {
            // Here you can specify the preconditions for the function.
            // Since the function does not take any parameters, there might not be any preconditions.
        },
        "post": {
            // Here you can specify the postconditions for the function.
            // For example, if the function should never return null, you can specify "!=null".
        }
    }
},
{
    "kprobe:vga_default_device": {
        "description": "Please provide a description for this function",
        "proto" :"struct pci_dev *(*vga_default_device)(void)",
        "pre": {
            // Here you should specify the preconditions for this function.
            // As it does not take any arguments, there might not be any preconditions.
        },
    }
},
{
    "kretprobe:vga_put": {
        "description": "Update our counters, and account for equivalent legacy resources if we decode them",
        "proto" :"void vga_put(struct vga_device *vgadev, unsigned int rsrc)",
        "pre": {
            "vgadev": "!=null",
            "rsrc": "in [VGA_RSRC_NORMAL_IO, ...]" // replace ... with other possible values
        },
        "post": {
            "vgadev->locks": "==old_locks", // replace old_locks with the initial value of vgadev->locks
            "vgadev->io_norm_cnt": ">0"
        }
    }
},
{
    "kprobe:vga_put": {
        "description": "Update our counters, and account for equivalent legacy resources if we decode them.",
        "proto" :"void vga_put(struct vga_device *vgadev, unsigned int rsrc)",
        "pre": {
            "vgadev": "!=null",
            "rsrc": "in [VGA_RSRC_NORMAL_IO, ...]" // Please replace ... with other possible values of rsrc
        },
    }
},
{
    "kretprobe:vga_set_legacy_decoding": {
        "description": "Set the legacy decoding for a VGA device. Don't let userspace futz with kernel driver decodes.",
        "proto" :"static void (*vga_set_legacy_decoding)(struct pci_dev *pdev, unsigned int decodes, bool userspace)",
        "pre": {
            "pdev": "!=null",
            "decodes": "in [VGA_RSRC_LEGACY_MASK]",
            "userspace": "in [true, false]"
        },
    }
},

{
    "kretprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client. Clients have two callback mechanisms they can use. @set_decode callback: If a client can disable its GPU VGA resource, it will get a callback from this to set the encodedecode state. Rationale: we cannot disable VGA decode resources unconditionally some single GPU laptops seem to require ACPI or BIOS access to the VGA registers to control things like backlights etc. Hopefully newer multi-GPU laptops do something saner, and desktops won't have any special ACPI for this. The driver will get a callback when VGA arbitration is first used by userspace since some older X servers have issues. This function does not check whether a client for @pdev has been registered already. To unregister just call vga_client_unregister().",
        "proto" :"int vga_client_register(struct pci_dev *pdev, unsigned int (*set_decode)(struct pci_dev *pdev, bool decode))",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        },
        "post": {
            "return": "in [0, -1]"
        }
    }
},
{
    "kprobe:vga_client_register": {
        "description": "Register or unregister a VGA arbitration client. Clients have two callback mechanisms they can use. The driver will get a callback when VGA arbitration is first used by userspace since some older X servers have issues. This function does not check whether a client for @pdev has been registered already. To unregister just call vga_client_unregister().",
        "proto" :"int (*vga_client_register)(struct pci_dev *pdev, unsigned int (*set_decode)(struct pci_dev *pdev, bool decode))",
        "pre": {
            "pdev": "!=null",
            "set_decode": "!=null"
        },
    }
},
{
    "kretprobe:pci_bus_alloc_resource": {
        "description": "Given the PCI bus a device resides on, the size, minimum address, alignment and type, try to find an acceptable resource allocation for a specific device resource.",
        "proto" :"int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res, resource_size_t size, resource_size_t align, resource_size_t min, unsigned long type_mask, resource_size_t (*alignf)(void *,  const struct resource *,  resource_size_t,  resource_size_t), void *alignf_data)",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": ">0",
            "align": ">=1",
            "min": ">=0",
            "type_mask": "in [IORESOURCE_IO, IORESOURCE_MEM, IORESOURCE_PREFETCH, IORESOURCE_READONLY, IORESOURCE_CACHEABLE, IORESOURCE_RANGELENGTH, IORESOURCE_SHADOWABLE]",
            "alignf": "!=null",
            "alignf_data": "!=null"
        },
    }
},
{
    "kprobe:pci_bus_alloc_resource": {
        "description": "Given the PCI bus a device resides on, the size, minimum address, alignment and type, try to find an acceptable resource allocation for a specific device resource.",
        "proto" :"int (*pci_bus_alloc_resource)(struct pci_bus *bus, struct resource *res, resource_size_t size, resource_size_t align, resource_size_t min, unsigned long type_mask, resource_size_t (*alignf)(void *,  const struct resource *,  resource_size_t,  resource_size_t), void *alignf_data)",
        "pre": {
            "bus": "!=null",
            "res": "!=null",
            "size": ">0",
            "align": ">=0",
            "min": ">=0",
            "type_mask": "in [IORESOURCE_IO, IORESOURCE_MEM, IORESOURCE_PREFETCH, IORESOURCE_READONLY, IORESOURCE_CACHEABLE, IORESOURCE_RANGELENGTH, IORESOURCE_SHADOWABLE]",
            "alignf": "!=null",
            "alignf_data": "!=null"
        },
    }
},
{
    "kretprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "proto" :"void (*pci_bus_add_devices)(const struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_add_devices": {
        "description": "Start driver for PCI devices and add some sysfs entries.",
        "proto" :"void (*pci_bus_add_devices)(const struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_map_rom": {
        "description": "Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS copy will be returned instead of the actual ROM.",
        "proto" :"void __iomem *(*pci_map_rom)(struct pci_dev *pdev, size_t *size)",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pci_map_rom": {
        "description": "Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS copy will be returned instead of the actual ROM.",
        "proto" :"void __iomem *(*pci_map_rom)(struct pci_dev *pdev, size_t *size)",
        "pre": {
            "pdev": "!=null",
            "size": "!=null"
        },
    }
},
{
    "kretprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space. Remove a mapping of a previously mapped ROM.",
        "proto": "void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_rom": {
        "description": "Unmap the ROM from kernel space. Remove a mapping of a previously mapped ROM.",
        "proto": "void (*pci_unmap_rom)(struct pci_dev *pdev, void __iomem *rom)",
        "pre": {
            "pdev": "!=null",
            "rom": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_bus": {
        "description": "Given a PCI bus number and domain number, the desired PCI bus is located in the global list of PCI buses. If the bus is found, a pointer to its data structure is returned. If no bus is found, %NULL is returned.",
        "proto" :"struct pci_bus *(*pci_find_bus)(int domain, int busnr)",
        "pre": {
            "domain": ">=0",
            "busnr": ">=0"
        },
        "post": {
            "return": "in [valid pci_bus pointer, null]"
        }
    }
},
{
    "kprobe:pci_find_bus": {
        "description": "Given a PCI bus number and domain number, the desired PCI bus is located in the global list of PCI buses. If the bus is found, a pointer to its data structure is returned. If no bus is found, %NULL is returned.",
        "proto" :"struct pci_bus *(*pci_find_bus)(int domain, int busnr)",
        "pre": {
            "domain": ">=0",
            "busnr": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list.",
        "proto" :"struct pci_bus *(*pci_find_next_bus)(const struct pci_bus *from)",
        "pre": {
            "from": "can be null or a valid pointer to struct pci_bus"
        },
        "post": {
            "return": "can be null or a valid pointer to struct pci_bus"
        }
    }
},
{
    "kprobe:pci_find_next_bus": {
        "description": "Begin or continue searching for a PCI bus. Iterates through the list of known PCI buses. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list.",
        "proto" :"struct pci_bus *(*pci_find_next_bus)(const struct pci_bus *from)",
        "pre": {
            "from": "can be null or a valid pointer to struct pci_bus"
        },
    }
},
{
    "kretprobe:pci_get_slot": {
        "description": "Given a PCI bus and slot/function number, the desired PCI device is located in the list of PCI devices. If the device is found, its reference count is increased and this function returns a pointer to its data structure. The caller must decrement the reference count by calling pci_dev_put(). If no device is found, %NULL is returned.",
        "proto" :"struct pci_dev *(*pci_get_slot)(struct pci_bus *bus, unsigned int devfn)",
        "pre": {
            "bus": "!=null",
            "devfn": "is a valid encoding of the number of PCI slot and the logical device number within that slot in case of multi-function devices"
        },
        "post": {
            "return": "!=null if the device is found, else ==null"
        }
    }
},
{
    "kprobe:pci_get_slot": {
        "description": "Locate PCI device for a given PCI slot. If the device is found, its reference count is increased and this function returns a pointer to its data structure. The caller must decrement the reference count by calling pci_dev_put(). If no device is found, %NULL is returned.",
        "proto" :"struct pci_dev *(*pci_get_slot)(struct pci_bus *bus, unsigned int devfn)",
        "pre": {
            "bus": "!=null",
            "devfn": "is unsigned int"
        },
    }
},
{
    "kretprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bus, and slot. If the device is found, its reference count is increased and this function returns a pointer to its data structure. The caller must decrement the reference count by calling pci_dev_put(). If no device is found, %NULL is returned.",
        "proto" :"struct pci_dev *(*pci_get_domain_bus_and_slot)(int domain, unsigned int bus, unsigned int devfn)",
        "pre": {
            "domain": ">=0",
            "bus": ">=0",
            "devfn": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:pci_get_domain_bus_and_slot": {
        "description": "Locate PCI device for a given PCI domain (segment), bus, and slot. If the device is found, its reference count is increased and this function returns a pointer to its data structure. The caller must decrement the reference count by calling pci_dev_put(). If no device is found, %NULL is returned.",
        "proto" :"struct pci_dev *(*pci_get_domain_bus_and_slot)(int domain, unsigned int bus, unsigned int devfn)",
        "pre": {
            "domain": ">=0",
            "bus": ">=0",
            "devfn": ">=0",
        },
    }
},
{
    "kretprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendorsubvendordevicesubdevice id. If a PCI device is found with a matching @vendor, @device, @ss_vendor and @ss_device, a pointer to its device structure is returned, and the reference count to the device is incremented. Otherwise, %NULL is returned. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list. The reference count for @from is always decremented if it is not %NULL.",
        "proto" :"struct pci_dev *(*pci_get_subsys)(unsigned int vendor, unsigned int device, unsigned int ss_vendor, unsigned int ss_device, struct pci_dev *from)",
        "pre": {
            "vendor": "in [0, 65535] or == PCI_ANY_ID",
            "device": "in [0, 65535] or == PCI_ANY_ID",
            "ss_vendor": "in [0, 65535] or == PCI_ANY_ID",
            "ss_device": "in [0, 65535] or == PCI_ANY_ID",
            "from": "==null or !=null"
        }
    }
},
{
    "kprobe:pci_get_subsys": {
        "description": "Begin or continue searching for a PCI device by vendorsubvendordevicesubdevice id. If a PCI device is found with a matching @vendor, @device, @ss_vendor and @ss_device, a pointer to its device structure is returned, and the reference count to the device is incremented. Otherwise, %NULL is returned. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list. The reference count for @from is always decremented if it is not %NULL.",
        "proto" :"struct pci_dev *(*pci_get_subsys)(unsigned int vendor, unsigned int device, unsigned int ss_vendor, unsigned int ss_device, struct pci_dev *from)",
        "pre": {
            "vendor": "in [0, 65535] or == PCI_ANY_ID",
            "device": "in [0, 65535] or == PCI_ANY_ID",
            "ss_vendor": "in [0, 65535] or == PCI_ANY_ID",
            "ss_device": "in [0, 65535] or == PCI_ANY_ID",
            "from": "==null or !=null and type == struct pci_dev*"
        }
    }
},
{
    "kretprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendordevice id. If a PCI device is found with a matching @vendor and @device, the reference count to the device is incremented and a pointer to its device structure is returned. Otherwise, %NULL is returned. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list. The reference count for @from is always decremented if it is not %NULL.",
        "proto" :"struct pci_dev *(*pci_get_device)(unsigned int vendor, unsigned int device, struct pci_dev *from)",
        "pre": {
            "vendor": "in [0, 65535] or == PCI_ANY_ID",
            "device": "in [0, 65535] or == PCI_ANY_ID",
            "from": "==null or valid pointer"
        },
        "post": {
            "return": "==null or valid pointer"
        }
    }
},
{
    "kprobe:pci_get_device": {
        "description": "Begin or continue searching for a PCI device by vendordevice id. If a PCI device is found with a matching @vendor and @device, the reference count to the device is incremented and a pointer to its device structure is returned. Otherwise, %NULL is returned. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list. The reference count for @from is always decremented if it is not %NULL.",
        "proto" :"struct pci_dev *(*pci_get_device)(unsigned int vendor, unsigned int device, struct pci_dev *from)",
        "pre": {
            "vendor": "in [0x0000, 0xFFFF] or == PCI_ANY_ID",
            "device": "in [0x0000, 0xFFFF] or == PCI_ANY_ID",
            "from": "==null or valid pointer to struct pci_dev"
        },
    }
},
{
    "kretprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class. If a PCI device is found with a matching class, the reference count to the device is incremented and a pointer to its device structure is returned. Otherwise, %NULL is returned. A new search is initiated by passing %NULL as the @from argument. Otherwise if @from is not %NULL, searches continue from next device on the global list. The reference count for @from is always decremented if it is not %NULL.",
        "proto" :"struct pci_dev *(*pci_get_class)(unsigned int class, struct pci_dev *from)",
        "pre": {
            "class": "unsigned int",
            "from": "struct pci_dev * or null"
        },
        "post": {
            "return": "struct pci_dev * or null"
        }
    }
},
{
    "kprobe:pci_get_class": {
        "description": "Begin or continue searching for a PCI device by class. If a PCI device is found with a matching class, the reference count to the device is incremented and a pointer to its device structure is returned. Otherwise, NULL is returned. A new search is initiated by passing NULL as the from argument. Otherwise if from is not NULL, searches continue from next device on the global list. The reference count for from is always decremented if it is not NULL.",
        "proto" :"struct pci_dev *(*pci_get_class)(unsigned int class, struct pci_dev *from)",
        "pre": {
            "class": "is unsigned int",
            "from": "is struct pci_dev * or NULL"
        },
    }
},
{
    "kretprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not. @ids: A pointer to a null terminated list of struct pci_device_id structures that describe the type of PCI device the caller is trying to find. Obvious fact: You do not have a reference to any device that might be found by this function, so if that device is removed from the system right after this function is finished, the value will be stale. Use this function to find devices that are usually built into a system, or for a general hint as to if another device happens to be present at this specific moment in time.",
        "proto" :"int (*pci_dev_present)(const struct pci_device_id *ids)",
        "pre": {
            "ids": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_dev_present": {
        "description": "Returns 1 if device matching the device list is present, 0 if not. The input is a pointer to a null-terminated list of struct pci_device_id structures. The function is used to find devices that are usually built into a system, or for a general hint as to if another device happens to be present at this specific moment in time.",
        "proto" :"int (*pci_dev_present)(const struct pci_device_id *ids)",
        "pre": {
            "ids": "!=null"
        }
    }
},
{
    "kretprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device. This call allocates interrupt resources and enables the interrupt line and IRQ handling. From the point this call is made @handler and @thread_fn may be invoked. All interrupts requested using this function might be shared. @dev_id must not be NULL and must be globally unique.",
        "proto" :"int pci_request_irq(struct pci_dev *dev, unsigned int nr, irq_handler_t handler, irq_handler_t thread_fn, void *dev_id, const char *fmt, ...)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null || thread_fn != null",
            "thread_fn": "!=null || handler != null",
            "dev_id": "!=null",
            "fmt": "!=null"
        }
    }
},
{
    "kprobe:pci_request_irq": {
        "description": "Allocate an interrupt line for a PCI device. This call allocates interrupt resources and enables the interrupt line and IRQ handling. From the point this call is made @handler and @thread_fn may be invoked. All interrupts requested using this function might be shared. @dev_id must not be NULL and must be globally unique.",
        "proto" :"int pci_request_irq(struct pci_dev *dev, unsigned int nr, irq_handler_t handler,irq_handler_t thread_fn, void *dev_id, const char *fmt, ...)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "handler": "!=null || (handler==null && thread_fn!=null)",
            "thread_fn": "can be null",
            "dev_id": "!=null",
            "fmt": "!=null",
        },
    }
},
{
    "kretprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq. The handler is removed and if the interrupt line is no longer in use by any driver it is disabled. The caller must ensure the interrupt is disabled on the device before calling this function. The function does not return until any executing interrupts for this IRQ have completed. This function must not be called from interrupt context.",
        "proto" :"void (*pci_free_irq)(struct pci_dev *dev, unsigned int nr, void *dev_id)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:pci_free_irq": {
        "description": "Free an interrupt allocated with pci_request_irq. The handler is removed and if the interrupt line is no longer in use by any driver it is disabled. The caller must ensure the interrupt is disabled on the device before calling this function. The function does not return until any executing interrupts for this IRQ have completed. This function must not be called from interrupt context.",
        "proto" :"void (*pci_free_irq)(struct pci_dev *dev, unsigned int nr, void *dev_id)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0",
            "dev_id": "!=null"
        }
    }
},
{
    "kretprobe:pci_setup_cardbus": {
        "description": "Description of the function",
        "proto" :"static long (*pci_setup_cardbus)(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null",
            // Add other preconditions here
        },
        // Add postconditions here if any
    }
},
{
    "kprobe:pci_setup_cardbus": {
        "description": "Description of the function",
        "proto" :"static long (*pci_setup_cardbus)(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:pci_bus_size_bridges": {
        "description": "Size the bridges of a PCI bus.",
        "proto" :"void pci_bus_size_bridges(struct pci_bus *bus, struct list_head *realloc_head)",
        "pre": {
            "bus": "!=null",
            "realloc_head": "!=null"
        }
    }
},
{
    "kprobe:pci_is_root_bus": {
        "description": "Check if the given bus is a root bus.",
        "proto" :"int pci_is_root_bus(struct pci_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus @bus:pci bus struct @ops:new raw operations. Return previous raw operations.",
        "proto" :"struct pci_ops *(*pci_bus_set_ops)(struct pci_bus *bus, struct pci_ops *ops)",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:pci_bus_set_ops": {
        "description": "Set raw operations of pci bus. Return previous raw operations.",
        "proto" :"struct pci_ops *(*pci_bus_set_ops)(struct pci_bus *bus, struct pci_ops *ops)",
        "pre": {
            "bus": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:pci_read_config_word": {
        "description": "Reads a word from the PCI configuration space of a device. Resets 'val' to 0 if pci_read_config_word() fails; it may have been written as 0xFFFF (PCI_ERROR_RESPONSE) if the config read failed on PCI.",
        "proto": "int pci_read_config_word(struct pci_dev *dev, int where, u16 *val)",
        "pre": {
            "dev": "!=null",
            "where": "is valid PCI config space offset",
            "val": "!=null"
        },
        "post": {
            "val": "in [0, 0xFFFF] or (if pci_read_config_word() fails) == 0",
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:pci_read_config_word": {
        "description": "Reads a word from the PCI configuration space of a device. Resets *val* to 0 if the function fails; it may have been written as 0xFFFF (PCI_ERROR_RESPONSE) if the config read failed on PCI.",
        "proto" :"int pci_read_config_word(struct pci_dev *dev, int where, u16 *val)",
        "pre": {
            "dev": "!=null",
            "where": ">=0",
            "val": "!=null"
        },
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Reads a dword (32 bits) from the specified position in the PCI Express capability structure of the given device. Resets val to 0 if pci_read_config_dword() fails; it may have been written as 0xFFFFFFFF (PCI_ERROR_RESPONSE) if the config read failed on PCI.",
        "proto" :"int pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)",
        "pre": {
            "dev": "!=null",
            "pos": "is integer and pos % 4 == 0",
            "val": "!=null"
        },
        "post": {
            "val": "if (ret) *val == 0 else *val != 0xFFFFFFFF",
            "return": "if (pos & 3) return == PCIBIOS_BAD_REGISTER_NUMBER else return == 0"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Reads a dword (32 bits) from the specified position in the PCI Express capability structure of the given device. If the position is not a multiple of 4, returns PCIBIOS_BAD_REGISTER_NUMBER. If pci_read_config_dword() fails, resets val to 0.",
        "proto" :"int pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)",
        "pre": {
            "dev": "!=null",
            "pos": "is integer and pos % 4 == 0",
            "val": "is pointer"
        },
        "post": {
            "val": "if (ret) *val == 0 else *val == PCI_EXP_SLTSTA_PDS"
        }
    }
},
{
    "kretprobe:pcie_capability_read_dword": {
        "description": "Reads a dword from the PCI Express capability structure of a device. Resets val to 0 if pci_read_config_dword() fails; it may have been written as 0xFFFFFFFF (PCI_ERROR_RESPONSE) if the config read failed on PCI.",
        "proto" :"int pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)",
        "pre": {
            "dev": "!=null",
            "pos": ">=0",
            "val": "!=null"
        },
        "post": {
            "*val": "in [0, 0xFFFFFFFF]"
        }
    },
    "kretprobe:pcie_capability_write_word": {
        "description": "Writes a word to the PCI Express capability structure of a device.",
        "proto" :"int pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val)",
        "pre": {
            "dev": "!=null",
            "pos": ">=0",
            "val": "in [0, 0xFFFF]"
        }
    }
},
{
    "kprobe:pcie_capability_read_dword": {
        "description": "Reads a dword from the PCI Express capability structure of a device. Resets val to 0 if pci_read_config_dword() fails; it may have been written as 0xFFFFFFFF (PCI_ERROR_RESPONSE) if the config read failed on PCI.",
        "proto" :"int pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)",
        "pre": {
            "dev": "!=null",
            "pos": "in [PCI_EXP_DEVCAP, PCI_EXP_DEVCTL, PCI_EXP_DEVSTA, PCI_EXP_LNKCAP, PCI_EXP_LNKCTL, PCI_EXP_LNKSTA, PCI_EXP_SLTCAP, PCI_EXP_SLTCTL, PCI_EXP_SLTSTA, PCI_EXP_RTCTL, PCI_EXP_RTCAP, PCI_EXP_RTSTA, PCI_EXP_DEVCAP2, PCI_EXP_DEVCTL2, PCI_EXP_LNKCTL2, PCI_EXP_LNKSTA2, PCI_EXP_SLTCTL2, PCI_EXP_SLTSTA2]",
            "val": "!=null"
        },
    }
},
{
    "kretprobe:pci_find_capability": {
        "description": "Tell if a device supports a given PCI capability. Returns the address of the requested capability structure within the device's PCI configuration space or 0 in case the device does not support it.",
        "proto" :"u8 (*pci_find_capability)(struct pci_dev *dev, int cap)",
        "pre": {
            "dev": "!=null",
            "cap": "in [%PCI_CAP_ID_PM, %PCI_CAP_ID_AGP, %PCI_CAP_ID_VPD, %PCI_CAP_ID_SLOTID, %PCI_CAP_ID_MSI, %PCI_CAP_ID_CHSWP, %PCI_CAP_ID_PCIX, %PCI_CAP_ID_EXP]"
        },
    }
},
{
    "kprobe:pci_find_capability": {
        "description": "Tell if a device supports a given PCI capability. Returns the address of the requested capability structure within the device's PCI configuration space or 0 in case the device does not support it.",
        "proto" :"u8 (*pci_find_capability)(struct pci_dev *dev, int cap)",
        "pre": {
            "dev": "!=null",
            "cap": "in [%PCI_CAP_ID_PM, %PCI_CAP_ID_AGP, %PCI_CAP_ID_VPD, %PCI_CAP_ID_SLOTID, %PCI_CAP_ID_MSI, %PCI_CAP_ID_CHSWP, %PCI_CAP_ID_PCIX, %PCI_CAP_ID_EXP]"
        }
    }
},
{
    "kretprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities. Like pci_find_capability() but works for PCI devices that do not have a pci_dev structure set up yet. Returns the address of the requested capability structure within the device's PCI configuration space or 0 in case the device does not support it.",
        "proto" :"u8 (*pci_bus_find_capability)(struct pci_bus *bus, unsigned int devfn, int cap)",
        "pre": {
            "bus": "!=null",
            "devfn": ">=0",
            "cap": ">=0"
        }
    }
},
{
    "kprobe:pci_bus_find_capability": {
        "description": "Query for devices' capabilities. Like pci_find_capability() but works for PCI devices that do not have a pci_dev structure set up yet. Returns the address of the requested capability structure within the device's PCI configuration space or 0 in case the device does not support it.",
        "proto" :"u8 (*pci_bus_find_capability)(struct pci_bus *bus, unsigned int devfn, int cap)",
        "pre": {
            "bus": "!=null",
            "devfn": "is a valid PCI device function number",
            "cap": "is a valid capability code"
        },
    }
},
{
    "kretprobe:pci_find_parent_resource": {
        "description": "For given resource region of given device, return the resource region of parent bus the given region is contained in.",
        "proto" :"struct resource *(*pci_find_parent_resource)(const struct pci_dev *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:pci_find_parent_resource": {
        "description": "For given resource region of given device, return the resource region of parent bus the given region is contained in.",
        "proto" :"struct resource *(*pci_find_parent_resource)(const struct pci_dev *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_find_resource": {
        "description": "Goes over standard PCI resources (BARs) and checks if the given resource is partially or fully contained in any of them. In that case the matching resource is returned, %NULL otherwise.",
        "proto" :"struct resource *(*pci_find_resource)(struct pci_dev *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:pci_find_resource": {
        "description": "Goes over standard PCI resources (BARs) and checks if the given resource is partially or fully contained in any of them. In that case the matching resource is returned, %NULL otherwise.",
        "proto" :"struct resource *(*pci_find_resource)(struct pci_dev *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        }
    }
},
{
    "kretprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it. The power state is read from the PMCSR register, which however is inaccessible in D3cold. The platform firmware is therefore queried first to detect accessibility of the register. In case the platform firmware reports an incorrect state or the device isn't power manageable by the platform at all, we try to detect D3cold by testing accessibility of the vendor ID in config space.",
        "proto" :"void (*pci_update_current_state)(struct pci_dev *dev, pci_power_t state)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]"
        }
    }
},
{
    "kprobe:pci_update_current_state": {
        "description": "Read power state of given device and cache it. The power state is read from the PMCSR register, which however is inaccessible in D3cold. The platform firmware is therefore queried first to detect accessibility of the register. In case the platform firmware reports an incorrect state or the device isn't power manageable by the platform at all, we try to detect D3cold by testing accessibility of the vendor ID in config space.",
        "proto" :"void (*pci_update_current_state)(struct pci_dev *dev, pci_power_t state)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_POWER_D0, PCI_POWER_D1, PCI_POWER_D2, PCI_POWER_D3hot, PCI_POWER_D3cold]",
        },
    }
},
{
    "kretprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending",
        "proto": "int (*pci_save_state)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_save_state": {
        "description": "Save the PCI configuration space of a device before suspending",
        "proto" :"int (*pci_save_state)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_set_full_power_state": {
        "description": "pci_restore_state() is going to be called right after a power state change to D0, it is more efficient to use pci_power_up() directly instead of this function.",
        "proto" :"static int (*pci_set_full_power_state)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_set_full_power_state": {
        "description": "This function is used to change the power state to D0. pci_restore_state() is going to be called right after a power state change to D0, it is more efficient to use pci_power_up() directly instead of this function.",
        "proto" :"static int (*pci_set_full_power_state)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_reenable_device": {
        "description": "Resume abandoned device",
        "proto" :"int pci_reenable_device(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_reenable_device": {
        "description": "Resume abandoned device. This function is a backend of pci_default_resume() and is not supposed to be called by normal code, write proper resume handler and use it instead.",
        "proto" :"int pci_reenable_device(struct pci_dev *dev)",
        "pre": {
            "dev": "unknown"
        },
    }
},
{
    "kretprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space. Ask low-level code to enable IO resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "proto" :"int (*pci_enable_device_io)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_io": {
        "description": "Initialize a device for use with IO space. Initialize device before it's used by a driver. Ask low-level code to enable IO resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "proto" :"int (*pci_enable_device_io)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space. Ask low-level code to enable Memory resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "proto" :"int (*pci_enable_device_mem)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_enable_device_mem": {
        "description": "Initialize a device for use with Memory space. Ask low-level code to enable Memory resources. Wake up the device if it was suspended. Beware, this function can fail.",
        "proto" :"int (*pci_enable_device_mem)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device().",
        "proto" :"int pcim_enable_device(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pcim_enable_device": {
        "description": "Managed pci_enable_device()",
        "proto" :"int pcim_enable_device(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_pin_device": {
        "description": "Pin managed PCI device. Pinned device won't be disabled on driver detach. @pdev must have been enabled with pcim_enable_device().",
        "proto" :"void (*pcim_pin_device)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null && enabled with pcim_enable_device()"
        }
    }
},
{
    "kprobe:pcim_pin_device": {
        "description": "Pin managed PCI device. Pinned device won't be disabled on driver detach. @pdev must have been enabled with pcim_enable_device().",
        "proto" :"void (*pcim_pin_device)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null && enabled with pcim_enable_device()"
        },
    }
},
{
    "kretprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#.",
        "proto": "bool (*pci_pme_capable)(struct pci_dev *dev, pci_power_t state)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]"
        }
    }
},
{
    "kprobe:pci_pme_capable": {
        "description": "Check the capability of PCI device to generate PME#.",
        "proto" :"bool (*pci_pme_capable)(struct pci_dev *dev, pci_power_t state)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]"
        },
    }
},
{
    "kretprobe:pci_pme_active": {
        "description": "Clear PME_Status by writing 1 to it and enable PME#",
        "proto" :"void pci_pme_active(struct pci_dev *dev, bool enable)",
        "pre": {
            "dev": "!=null",
            "enable": "is boolean"
        }
    }
},
{
    "kprobe:pci_pme_active": {
        "description": "Clear PME_Status by writing 1 to it and enable PME#",
        "proto" :"void pci_pme_active(struct pci_dev *dev, bool enable)",
        "pre": {
            "dev": "!=null",
            "enable": "is boolean"
        },
    }
},
{
    "kretprobe:__pci_enable_wake": {
        "description": "Enable PCI device as wakeup event source. This enables the device as a wakeup event source, or disables it. When such events involves platform-specific hooks, those hooks are called automatically by this routine. Devices with legacy power management (no standard PCI PM capabilities) always require such platform hooks.",
        "proto": "static int __pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]",
            "enable": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EINVAL, -EPLATFORM]"
        }
    }
},
{
    "kprobe:__pci_enable_wake": {
        "description": "Enable PCI device as wakeup event source. This enables the device as a wakeup event source, or disables it. When such events involves platform-specific hooks, those hooks are called automatically by this routine. Devices with legacy power management (no standard PCI PM capabilities) always require such platform hooks.",
        "proto" :"static int (*__pci_enable_wake)(struct pci_dev *dev, pci_power_t state, bool enable)",
        "pre": {
            "dev": "!=null",
            "state": "in [PCI_D0, PCI_D1, PCI_D2, PCI_D3hot, PCI_D3cold]",
            "enable": "in [true, false]"
        },
        "post": {
            "return": "in [0, -EINVAL, -EPLATFORM]"
        }
    }
},
{
    "kretprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold. Many drivers want the device to wake up the system from D3_hot or D3_cold and this function allows them to set that up cleanly - pci_enable_wake() should not be called twice in a row to enable wake-up due to PCI PM vs ACPI ordering constraints. This function only returns error code if the device is not allowed to wake up the system from sleep or it is not capable of generating PME# from both D3_hot and D3_cold and the platform is unable to enable wake-up power for it.",
        "proto" :"int pci_wake_from_d3(struct pci_dev *dev, bool enable)",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kprobe:pci_wake_from_d3": {
        "description": "Enable or disable device to wake up from D3_hot or D3_cold. Many drivers want the device to wake up the system from D3_hot or D3_cold and this function allows them to set that up cleanly - pci_enable_wake() should not be called twice in a row to enable wake-up due to PCI PM vs ACPI ordering constraints. This function only returns error code if the device is not allowed to wake up the system from sleep or it is not capable of generating PME# from both D3_hot and D3_cold and the platform is unable to enable wake-up power for it.",
        "proto" :"int (*pci_wake_from_d3)(struct pci_dev *dev, bool enable)",
        "pre": {
            "dev": "!=null",
            "enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state. Choose the power state appropriate for the device depending on whether it can wake up the system and/or is power manageable by the platform (PCI_D3hot is the default) and put the device into that state.",
        "proto" :"int (*pci_prepare_to_sleep)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kprobe:pci_prepare_to_sleep": {
        "description": "Prepare PCI device for system-wide transition into a sleep state. Choose the power state appropriate for the device depending on whether it can wake up the system and/or is power manageable by the platform (PCI_D3hot is the default) and put the device into that state.",
        "proto" :"int (*pci_prepare_to_sleep)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state. Disable device's system wake-up capability and put it into D0.",
        "proto" :"int (*pci_back_from_sleep)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_back_from_sleep": {
        "description": "Turn PCI device on during system-wide transition into working state. Disable device's system wake-up capability and put it into D0.",
        "proto" :"int (*pci_back_from_sleep)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_rebar_get_possible_sizes": {
        "description": "Get the possible sizes of a resizable BAR as bitmask defined in the spec (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.",
        "proto" :"u32 (*pci_rebar_get_possible_sizes)(struct pci_dev *pdev, int bar)",
        "pre": {
            "pdev": "!=null",
            "bar": "in [0, 19]"
        },
    }
},
{
    "kprobe:pci_rebar_get_possible_sizes": {
        "description": "Get the possible sizes of a resizable BAR as bitmask defined in the spec (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.",
        "proto" :"u32 (*pci_rebar_get_possible_sizes)(struct pci_dev *pdev, int bar)",
        "pre": {
            "pdev": "!=null",
            "bar": "is integer"
        },
    }
},
{
    "kretprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port. Return 0 if all upstream bridges support AtomicOp routing, egress blocking is disabled on all upstream ports, and the root port supports the requested completion capabilities (32-bit, 64-bit andor 128-bit AtomicOp completion), or negative otherwise.",
        "proto" :"int (*pci_enable_atomic_ops_to_root)(struct pci_dev *dev, u32 cap_mask)",
        "pre": {
            "dev": "!=null",
            "cap_mask": "in [PCI_EXP_DEVCAP2_ATOMIC_COMP32, PCI_EXP_DEVCAP2_ATOMIC_COMP64, PCI_EXP_DEVCAP2_ATOMIC_COMP128]"
        },
    }
},
{
    "kprobe:pci_enable_atomic_ops_to_root": {
        "description": "Enable AtomicOp requests to root port. Return 0 if all upstream bridges support AtomicOp routing, egress blocking is disabled on all upstream ports, and the root port supports the requested completion capabilities (32-bit, 64-bit andor 128-bit AtomicOp completion), or negative otherwise.",
        "proto" :"int (*pci_enable_atomic_ops_to_root)(struct pci_dev *dev, u32 cap_mask)",
        "pre": {
            "dev": "!=null",
            "cap_mask": "in [PCI_EXP_DEVCAP2_ATOMIC_COMP32, PCI_EXP_DEVCAP2_ATOMIC_COMP64, PCI_EXP_DEVCAP2_ATOMIC_COMP128]"
        }
    }
},
{
    "kretprobe:pci_release_region": {
        "description": "Releases the PCI IO and memory resources previously reserved by a successful call to pci_request_region(). Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_region)(struct pci_dev *pdev, int bar)",
        "pre": {
            "pdev": "!=null",
            "bar": "is a valid BAR number"
        }
    }
},
{
    "kprobe:pci_release_region": {
        "description": "Releases the PCI IO and memory resources previously reserved by a successful call to pci_request_region(). Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_region)(struct pci_dev *pdev, int bar)",
        "pre": {
            "pdev": "!=null",
            "bar": "is an integer and >= 0"
        }
    }
},
{
    "kretprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources previously reserved. Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_selected_regions)(struct pci_dev *pdev, int bars)",
        "pre": {
            "pdev": "!=null",
            "bars": "is a bitmask"
        },
    }
},
{
    "kprobe:pci_release_selected_regions": {
        "description": "Release selected PCI IO and memory resources previously reserved. Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_selected_regions)(struct pci_dev *pdev, int bars)",
        "pre": {
            "pdev": "!=null",
            "bars": "is bitmask"
        },
    }
},
{
    "kretprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources",
        "proto" :"int pci_request_selected_regions(struct pci_dev *pdev, int bars, const char *res_name)",
        "pre": {
            "pdev": "!=null",
            "bars": "is integer",
            "res_name": "!=null"
        },
    }
},
{
    "kprobe:pci_request_selected_regions": {
        "description": "Reserve selected PCI IO and memory resources",
        "proto" :"int (*pci_request_selected_regions)(struct pci_dev *pdev, int bars, const char *res_name)",
        "pre": {
            "pdev": "!=null",
            "bars": "is an integer bitmask",
            "res_name": "!=null"
        },
    }
},
{
    "kretprobe:pci_release_regions": {
        "description": "Releases all PCI IO and memory resources previously reserved by a successful call to pci_request_regions(). Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_regions)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:pci_release_regions": {
        "description": "Releases all PCI IO and memory resources previously reserved by a successful call to pci_request_regions(). Call this function only after all use of the PCI regions has ceased.",
        "proto" :"void (*pci_release_regions)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null && previously reserved by pci_request_regions() && no longer in use"
        }
    }
},
{
    "kretprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources. Mark all PCI regions associated with PCI device @pdev as being reserved by owner @res_name. Do not access any address inside the PCI regions unless this call returns successfully. pci_request_regions_exclusive() will mark the region so that devmem and the sysfs MMIO access will not be allowed. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int (*pci_request_regions_exclusive)(struct pci_dev *pdev, const char *res_name)",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        },
        "post": {
            "return": "in [0, EBUSY]"
        }
    }
},
{
    "kprobe:pci_request_regions_exclusive": {
        "description": "Reserve PCI IO and memory resources. Mark all PCI regions associated with PCI device @pdev as being reserved by owner @res_name. Do not access any address inside the PCI regions unless this call returns successfully. pci_request_regions_exclusive() will mark the region so that devmem and the sysfs MMIO access will not be allowed. Returns 0 on success, or %EBUSY on error. A warning message is also printed on failure.",
        "proto" :"int (*pci_request_regions_exclusive)(struct pci_dev *pdev, const char *res_name)",
        "pre": {
            "pdev": "!=null",
            "res_name": "!=null"
        },
    }
},
{
    "kretprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space described by the @res and the CPU physical address @phys_addr into virtual address space. Only architectures that have memory mapped IO functions defined (and the PCI_IOBASE value defined) should call this function.",
        "proto" :"#ifndef pci_remap_iospaceint pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)",
        "pre": {
            "res": "!=null",
            "phys_addr": ">=0"
        }
    }
},
{
    "kprobe:pci_remap_iospace": {
        "description": "Remap the memory mapped IO space described by the @res and the CPU physical address @phys_addr into virtual address space. Only architectures that have memory mapped IO functions defined (and the PCI_IOBASE value defined) should call this function.",
        "proto" :"#ifndef pci_remap_iospaceint pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)",
        "pre": {
            "res": "!=null",
            "phys_addr": ">=0"
        }
    }
},
{
    "kretprobe:pci_unmap_iospace": {
        "description": "Unmap the CPU virtual address @res from virtual address space. Only architectures that have memory mapped IO functions defined (and the PCI_IOBASE value defined) should call this function.",
        "proto" :"void (*pci_unmap_iospace)(struct resource *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kprobe:pci_unmap_iospace": {
        "description": "Unmap the CPU virtual address @res from virtual address space. Only architectures that have memory mapped IO functions defined (and the PCI_IOBASE value defined) should call this function.",
        "proto" :"void (*pci_unmap_iospace)(struct resource *res)",
        "pre": {
            "res": "!=null"
        }
    }
},
{
    "kretprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach. Generic device to remap IO address for. Resource describing the IO space. Physical address of range to be mapped.",
        "proto" :"int (*devm_pci_remap_iospace)(struct device *dev, const struct resource *res, phys_addr_t phys_addr)",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": ">=0"
        },
    }
},
{
    "kprobe:devm_pci_remap_iospace": {
        "description": "Managed pci_remap_iospace(). Map is automatically unmapped on driver detach.",
        "proto" :"int devm_pci_remap_iospace(struct device *dev, const struct resource *res, phys_addr_t phys_addr)",
        "pre": {
            "dev": "!=null",
            "res": "!=null",
            "phys_addr": ">=0",
        },
    }
},
{
    "kretprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_pci_remap_cfgspace)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfgspace": {
        "description": "Managed pci_remap_cfgspace(). Map is automatically unmapped on driver detach.",
        "proto" :"void __iomem *(*devm_pci_remap_cfgspace)(struct device *dev, resource_size_t offset, resource_size_t size)",
        "pre": {
            "dev": "!=null",
            "offset": ">=0",
            "size": ">0",
        },
    }
},
{
    "kretprobe:devm_pci_remap_cfg_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI configuration space memory attributes are guaranteed. All operations are managed and will be undone on driver detach. Returns a pointer to the remapped memory or an ERR_PTR() encoded error code on failure.",
        "proto" :"void __iomem *(*devm_pci_remap_cfg_resource)(struct device *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:devm_pci_remap_cfg_resource": {
        "description": "Checks that a resource is a valid memory region, requests the memory region and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI configuration space memory attributes are guaranteed. All operations are managed and will be undone on driver detach.",
        "proto" :"void __iomem *(*devm_pci_remap_cfg_resource)(struct device *dev, struct resource *res)",
        "pre": {
            "dev": "!=null",
            "res": "!=null"
        },
        "post": {
            "return": "!=null || is_ERR_ptr(return)"
        }
    }
},

{
    "kprobe:pci_update_current_state": {
        "description": "Description of the function",
        "proto" :"Function prototype",
        "pre": {
            "dev": "Preconditions for dev",
            "dev->current_state": "Preconditions for dev->current_state",
            "dev->enable_cnt": "Preconditions for dev->enable_cnt",
        },
    }
},
{
    "kretprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "proto" :"void (*pci_clear_master)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_clear_master": {
        "description": "Disables bus-mastering for device dev.",
        "proto" :"void (*pci_clear_master)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_set_cacheline_size": {
        "description": "Sets the cache line size of the PCI device represented by *dev*. Returns an appropriate -ERRNO error value on error, or zero for success.",
        "proto" :"int (*pci_set_cacheline_size)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-ERRNO, 0]"
        }
    }
},
{
    "kprobe:pci_set_cacheline_size": {
        "description": "Originally copied from driversnetacenic.c. Copyright 1998-2001 by Jes Sorensen, <jes@trained-monkey.org>. RETURNS: An appropriate -ERRNO error value on error, or zero for success.",
        "proto" :"int pci_set_cacheline_size(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi(). Managed pci_set_mwi(). Returns an appropriate -ERRNO error value on error, or zero for success.",
        "proto" :"int (*pcim_set_mwi)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-MAX_ERRNO, 0]"
        }
    }
},
{
    "kprobe:pcim_set_mwi": {
        "description": "A device-managed pci_set_mwi(). Managed pci_set_mwi(). Returns an appropriate -ERRNO error value on error, or zero for success.",
        "proto" :"int pcim_set_mwi(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction for a given PCI device. Returns an appropriate -ERRNO error value on error, or zero for success.",
        "proto" :"int (*pci_try_set_mwi)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-ERRNO, 0]"
        }
    }
},
{
    "kprobe:pci_try_set_mwi": {
        "description": "Enables memory-write-invalidate PCI transaction for a given PCI device. Callers are not required to check the return value.",
        "proto" :"int pci_try_set_mwi(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-ERRNO, 0]"
        }
    }
},
{
    "kretprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction. Operate on the PCI device. Return 0 if transaction is pending, 1 otherwise.",
        "proto" :"int (*pci_wait_for_pending_transaction)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:pci_wait_for_pending_transaction": {
        "description": "Wait for pending transaction. Operates on the PCI device. Returns 0 if transaction is pending, 1 otherwise.",
        "proto" :"int (*pci_wait_for_pending_transaction)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_max_mmrbc": {
        "description": "Get PCI-X maximum designed memory read byte count. Returns mmrbc: maximum designed memory read count in bytes or appropriate error value.",
        "proto" :"int (*pcix_get_max_mmrbc)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcix_get_max_mmrbc": {
        "description": "Get PCI-X maximum designed memory read byte count for a specific PCI device.",
        "proto" :"int (*pcix_get_max_mmrbc)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_get_mmrbc": {
        "description": "Get PCI-X maximum memory read byte count. Returns mmrbc: maximum memory read count in bytes or appropriate error value.",
        "proto" :"int (*pcix_get_mmrbc)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcix_get_mmrbc": {
        "description": "Get PCI-X maximum memory read byte count. Returns mmrbc: maximum memory read count in bytes or appropriate error value.",
        "proto" :"int (*pcix_get_mmrbc)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count. If possible sets maximum memory read byte count, some bridges have errata that prevent this.",
        "proto" :"int (*pcix_set_mmrbc)(struct pci_dev *dev, int mmrbc)",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcix_set_mmrbc": {
        "description": "Set PCI-X maximum memory read byte count. If possible sets maximum memory read byte count, some bridges have errata that prevent this.",
        "proto" :"int (*pcix_set_mmrbc)(struct pci_dev *dev, int mmrbc)",
        "pre": {
            "dev": "!=null",
            "mmrbc": "in [512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_readrq": {
        "description": "Get PCI Express read request size. Returns maximum memory read request in bytes or appropriate error value.",
        "proto" :"int (*pcie_get_readrq)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pcie_get_readrq": {
        "description": "Get PCI Express read request size. Returns maximum memory read request in bytes or appropriate error value.",
        "proto" :"int (*pcie_get_readrq)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request. If possible sets maximum memory read request in bytes.",
        "proto" :"int (*pcie_set_readrq)(struct pci_dev *dev, int rq)",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_readrq": {
        "description": "Set PCI Express maximum memory read request. If possible sets maximum memory read request in bytes.",
        "proto" :"int (*pcie_set_readrq)(struct pci_dev *dev, int rq)",
        "pre": {
            "dev": "!=null",
            "rq": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_get_mps": {
        "description": "Get the PCI Express maximum payload size.",
        "proto" :"int pcie_get_mps(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:pcie_get_mps": {
        "description": "Get PCI Express maximum payload size",
        "proto" :"int pcie_get_mps(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size. If possible sets maximum payload size.",
        "proto" :"int (*pcie_set_mps)(struct pci_dev *dev, int mps)",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kprobe:pcie_set_mps": {
        "description": "Set PCI Express maximum payload size",
        "proto": "int (*pcie_set_mps)(struct pci_dev *dev, int mps)",
        "pre": {
            "dev": "!=null",
            "mps": "in [128, 256, 512, 1024, 2048, 4096]"
        }
    }
},
{
    "kretprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation. Walk up the PCI device chain and find the point where the minimum bandwidth is available. Return the bandwidth available there and (if limiting_dev, speed, and width pointers are supplied) information about that point. The bandwidth returned is in Mbs, i.e., megabitssecond of raw bandwidth.",
        "proto" :"u32 (*pcie_bandwidth_available)(struct pci_dev *dev, struct pci_dev **limiting_dev, enum pci_bus_speed *speed, enum pcie_link_width *width)",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        }
    }
},
{
    "kprobe:pcie_bandwidth_available": {
        "description": "Determine minimum link settings of a PCIe device and its bandwidth limitation. Walk up the PCI device chain and find the point where the minimum bandwidth is available. Return the bandwidth available there and (if limiting_dev, speed, and width pointers are supplied) information about that point. The bandwidth returned is in Mbs, i.e., megabitssecond of raw bandwidth.",
        "proto" :"u32 (*pcie_bandwidth_available)(struct pci_dev *dev, struct pci_dev **limiting_dev, enum pci_bus_speed *speed, enum pcie_link_width *width)",
        "pre": {
            "dev": "!=null",
            "limiting_dev": "!=null",
            "speed": "!=null",
            "width": "!=null"
        },
    }
},
{
    "kretprobe:pcie_get_speed_cap": {
        "description": "If the port supports active link reporting we now check whether the link is active and if not bail out early with the assumption that the device is not present anymore.",
        "proto" :"static long (*pcie_get_speed_cap)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
    },
    "kretprobe:pci_dev_wait": {
        "description": "Wait for the device to be ready after reset.",
        "proto" :"static long (*pci_dev_wait)(struct pci_dev *child, enum pci_reset_type reset_type, unsigned long delay)",
        "pre": {
            "child": "!=null",
            "reset_type": "in [PCI_RESET_TYPE_HOT, PCI_RESET_TYPE_WARM, PCI_RESET_TYPE_COLD]",
            "delay": ">=0"
        },
    }
},
{
    "kprobe:pcie_get_speed_cap": {
        "description": "If the port supports active link reporting we now check whether the link is active and if not bail out early with the assumption that the device is not present anymore.",
        "proto" :"static long (*pcie_get_speed_cap)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null",
        },
    },
    "kprobe:pci_dev_wait": {
        "description": "Waits for a specified delay. If the device is not present anymore, it returns 0.",
        "proto" :"static long (*pci_dev_wait)(struct pci_dev *child, int reset_type, int delay)",
        "pre": {
            "child": "!=null",
            "reset_type": "in [RESET_TYPE_1, RESET_TYPE_2, RESET_TYPE_3]", // replace with actual reset types
            "delay": ">=0",
        },
    },
    "kprobe:pcie_wait_for_link_delay": {
        "description": "Waits for a specified delay for the link. If the link is not active, it returns false.",
        "proto" :"static bool (*pcie_wait_for_link_delay)(struct pci_dev *dev, bool active, int delay)",
        "pre": {
            "dev": "!=null",
            "active": "in [true, false]",
            "delay": ">=0",
        },
    }
},
{
    "kretprobe:pcie_get_width_cap": {
        "description": "Query the PCI device width capability. Return the maximum link width supported by the device.",
        "proto" :"enum pcie_link_width (*pcie_get_width_cap)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [PCIE_LNK_WIDTH_RESV, PCIE_LNK_X1, PCIE_LNK_X2, PCIE_LNK_X4, PCIE_LNK_X8, PCIE_LNK_X12, PCIE_LNK_X16, PCIE_LNK_X32]"
        }
    }
},
{
    "kprobe:pcie_get_width_cap": {
        "description": "Query the PCI device width capability. Return the maximum link width supported by the device.",
        "proto" :"enum pcie_link_width (*pcie_get_width_cap)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__pcie_print_link_status": {
        "description": "Report the PCI device's link speed and width. If the available bandwidth at the device is less than the device is capable of, report the device's maximum possible bandwidth and the upstream link that limits its performance. If @verbose, always print the available bandwidth, even if the device isn't constrained.",
        "proto" :"void (*__pcie_print_link_status)(struct pci_dev *dev, bool verbose)",
        "pre": {
            "dev": "!=null",
            "verbose": "in [true, false]"
        }
    }
},
{
    "kprobe:__pcie_print_link_status": {
        "description": "Report the PCI device's link speed and width. If the available bandwidth at the device is less than the device is capable of, report the device's maximum possible bandwidth and the upstream link that limits its performance. If @verbose, always print the available bandwidth, even if the device isn't constrained.",
        "proto" :"static void (*__pcie_print_link_status)(struct pci_dev *dev, bool verbose)",
        "pre": {
            "dev": "your precondition here",
            "verbose": "your precondition here"
        },
    }
},
{
    "kretprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource. This helper routine makes bar mask from the type of resource.",
        "proto" :"int pci_select_bars(struct pci_dev *dev, unsigned long flags)",
        "pre": {
            "dev": "!=null",
            "flags": "unsigned long"
        },
    }
},
{
    "kprobe:pci_select_bars": {
        "description": "Make BAR mask from the type of resource. This helper routine makes bar mask from the type of resource.",
        "proto" :"int (*pci_select_bars)(struct pci_dev *dev, unsigned long flags)",
        "pre": {
            "dev": "!=null",
            "flags": "unsigned long"
        },
    }
},
{
    "kretprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device and any children. Inform the drivers that the device has been removed. Also remove any subordinate buses and children in a depth-first manner. For each device we remove, delete the device structure from the device lists, remove the proc entry, and notify userspace (sbinhotplug).",
        "proto" :"void (*pci_stop_and_remove_bus_device)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_stop_and_remove_bus_device": {
        "description": "Remove a PCI device from the device lists, informing the drivers that the device has been removed. We also remove any subordinate buses and children in a depth-first manner. For each device we remove, delete the device structure from the device lists, remove the proc entry, and notify userspace (sbinhotplug).",
        "proto" :"void (*pci_stop_and_remove_bus_device)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},

{
    "kprobe:dma_alloc_coherent": {
        "description": "Please fill in the description here",
        "proto" :"void* (*dma_alloc_coherent)(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t gfp)",
        "pre": {
            "dev": "!=null",
            "size": ">=0",
            "dma_handle": "!=null",
            "gfp": "in [GFP_KERNEL, ...]" // Please fill in the other possible gfp_t flags
        },
    }
},
{
    "kretprobe:iproc_pcie_setup_ob": {
        "description": "Translate the AXI address to the internal address used by the iProc PCIe core before programming the OARR",
        "proto" :"int iproc_pcie_setup_ob(struct iproc_pcie pcie, u64 axi_addr, u64 pci_addr, resource_size_t size)",
        "pre": {
            "pcie": "!=null",
            "axi_addr": ">= pcie->ob->axi_offset",
            "pci_addr": "!=null",
            "size": ">=0"
        },
    }
},

{
    "kretprobe:pci_disable_link_state": {
        "description": "A driver requested that ASPM be disabled on this device, but if we don't have permission to manage ASPM (e.g., on ACPI systems we have to observe the FADT ACPI_FADT_NO_ASPM bit and the _OSC method), we can't honor that request. Windows has a similar mechanism using 'PciASPMOptOut', which is also ignored in this situation.",
        "proto": "int pci_disable_link_state(struct pci_dev *pdev, int state, bool sem)",
        "pre": {
            "pdev": "!=null",
            "state": "is int",
            "sem": "is bool"
        },
        "post": {
            "aspm_disabled": "in [true, false]"
        }
    }
},
{
    "kprobe:pci_disable_link_state": {
        "description": "A driver requested that ASPM be disabled on this device, but if we don't have permission to manage ASPM (e.g., on ACPI systems we have to observe the FADT ACPI_FADT_NO_ASPM bit and the _OSC method), we can't honor that request. Windows has a similar mechanism using 'PciASPMOptOut', which is also ignored in this situation.",
        "proto" :"int pci_disable_link_state(struct pci_dev *pdev, int state, bool aspm_disabled)",
        "pre": {
            "pdev": "!=null",
            "state": "is integer",
            "aspm_disabled": "is boolean"
        },
    }
},
{
    "kretprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states. Note that if the BIOS didn't grant ASPM control to the OS, this does nothing because we can't touch the LNKCTL register. Also note that this does not enable states disabled by pci_disable_link_state(). Return 0 or a negative errno.",
        "proto" :"int (*pci_enable_link_state)(struct pci_dev *pdev, int state)",
        "pre": {
            "pdev": "!=null",
            "state": "in [ASPM_STATE_L0S, ASPM_STATE_L1, ASPM_STATE_ALL]"
        },
    }
},
{
    "kprobe:pci_enable_link_state": {
        "description": "Clear and set the default device link state so that the link may be allowed to enter the specified states. Note that if the BIOS didn't grant ASPM control to the OS, this does nothing because we can't touch the LNKCTL register. Also note that this does not enable states disabled by pci_disable_link_state(). Return 0 or a negative errno.",
        "proto" :"int (*pci_enable_link_state)(struct pci_dev *pdev, int state)",
        "pre": {
            "pdev": "!=null",
            "state": "is integer"
        }
    }
},
{
    "kretprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "proto" :"static int (__pci_enable_ptm)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:__pci_enable_ptm": {
        "description": "Enable PTM in the Control register if possible",
        "proto" :"static int (__pci_enable_ptm)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "proto" :"void (*pci_disable_ptm)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:pci_disable_ptm": {
        "description": "Disable Precision Time Measurement for @dev.",
        "proto" :"void (*pci_disable_ptm)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware. @pdev: the pci_dev of the bridge that has a hotplug controller",
        "proto" :"int (*acpi_get_hp_hw_control_from_firmware)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kprobe:acpi_get_hp_hw_control_from_firmware": {
        "description": "Attempt to take hotplug control from firmware.",
        "proto" :"int (*acpi_get_hp_hw_control_from_firmware)(struct pci_dev *pdev)",
        "pre": {
            "pdev": "!=null"
        }
    }
},
{
    "kretprobe:pci_enable_msi": {
        "description": "Enable Message Signaled Interrupts (MSI) for a PCI device. Should be used with pci_free_irq_vectors(). Returns 0 on success, errno otherwise.",
        "proto" :"int pci_enable_msi(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, errno]"
        }
    }
},
{
    "kprobe:pci_enable_msi": {
        "description": "Enable Message Signaled Interrupts (MSI) for a PCI device. Should be used with pci_free_irq_vectors(). Returns 0 on success, errno otherwise.",
        "proto" :"int (*pci_enable_msi)(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device. Returns number of MSI-X interrupt vectors available on this device (i.e., the device's MSI-X capability structure 'table size'), -EINVAL if the device is not MSI-X capable, other errnos otherwise.",
        "proto" :"int pci_msix_vec_count(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null && dev->msi_enabled"
        },
        "post": {
            "return": ">= -EINVAL"
        }
    }
},
{
    "kprobe:pci_msix_vec_count": {
        "description": "Get number of MSI-X interrupt vectors on device. Returns number of MSI-X interrupt vectors available on this device (i.e., the device's MSI-X capability structure 'table size'), -EINVAL if the device is not MSI-X capable, other errnos otherwise.",
        "proto" :"int pci_msix_vec_count(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null && msi_enabled"
        },
    }
},
{
    "kretprobe:pci_enable_msix_range": {
        "description": "Allocates MSI-X vectors for the device and saves the Linux IRQ numbers in the 'vector' field of the @entries array elements. Returns the number of MSI-X vectors allocated, which might be smaller than @maxvecs. Returns -ENOSPC if less than @minvecs interrupt vectors are available. Returns -EINVAL if one of the passed @entries members 'entry' field was invalid or a duplicate, or if plain MSI interrupts mode was enabled on the device. Returns other errnos otherwise. NOTE: The newer pci_alloc_irq_vectors()  pci_free_irq_vectors() API pair should, in general, be used instead.",
        "proto" :"int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,  int minvec, int maxvec)",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">minvec"
        },
        "post": {
            "return": "in [number of MSI-X vectors allocated, -ENOSPC, -EINVAL, other errnos]"
        }
    }
},
{
    "kprobe:pci_enable_msix_range": {
        "description": "Allocates MSI-X vectors and saves Linux IRQ numbers for such allocated vectors back in the @entries array elements' 'vector' field. Returns number of MSI-X vectors allocated (which might be smaller than @maxvecs). Returns -ENOSPC if less than @minvecs interrupt vectors are available. Returns -EINVAL if one of the passed @entries members 'entry' field was invalid or a duplicate, or if plain MSI interrupts mode was earlier enabled on device. Returns other errnos otherwise. NOTE: The newer pci_alloc_irq_vectors()  pci_free_irq_vectors() API pair should, in general, be used instead.",
        "proto" :"int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,  int minvec, int maxvec)",
        "pre": {
            "dev": "!=null",
            "entries": "!=null",
            "minvec": ">=0",
            "maxvec": ">minvec",
        },
    }
},
{
    "kretprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "proto" :"int (*pci_alloc_irq_vectors_affinity)(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags, struct irq_affinity *affd)",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "in [PCI_IRQ_LEGACY, PCI_IRQ_MSI, PCI_IRQ_MSIX, PCI_IRQ_AFFINITY, PCI_IRQ_ALL_TYPES, PCI_IRQ_NOSUPPORT]",
            "affd": "!=null || ==null",
        },
    }
},
{
    "kprobe:pci_alloc_irq_vectors_affinity": {
        "description": "Allocate multiple device interrupt vectors with affinity requirements.",
        "proto" :"int (*pci_alloc_irq_vectors_affinity)(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags, struct irq_affinity *affd)",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=1",
            "max_vecs": ">=min_vecs",
            "flags": "in [PCI_IRQ_LEGACY, PCI_IRQ_MSI, PCI_IRQ_MSIX, PCI_IRQ_AFFINITY, PCI_IRQ_ALL_TYPES, PCI_IRQ_NOSUPPORT]",
            "affd": "!=null || ==null",
        },
    }
},
{
    "kretprobe:pci_alloc_irq_vectors": {
        "description": "Get the Linux IRQ number to be passed to request_threaded_irq(). The driver must call pci_free_irq_vectors() on cleanup. Return: number of allocated vectors (which might be smaller than max_vecs), -ENOSPC if less than min_vecs interrupt vectors are available, other errnos otherwise.",
        "proto" :"int pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,  unsigned int max_vecs, unsigned int flags)",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">=min_vecs",
            "flags": ">=0"
        },
        "post": {
            "return": ">=-ENOSPC"
        }
    }
},
{
    "kprobe:pci_alloc_irq_vectors": {
        "description": "Get the Linux IRQ number to be passed to request_threaded_irq(). The driver must call pci_free_irq_vectors() on cleanup. Return: number of allocated vectors (which might be smaller than @max_vecs), -ENOSPC if less than @min_vecs interrupt vectors are available, other errnos otherwise.",
        "proto" :"int (*pci_alloc_irq_vectors)(struct pci_dev *dev, unsigned int min_vecs, unsigned int max_vecs, unsigned int flags)",
        "pre": {
            "dev": "!=null",
            "min_vecs": ">=0",
            "max_vecs": ">min_vecs",
            "flags": ">=0",
        },
    }
},
{
    "kretprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity. Return: MSIMSI-X vector affinity, NULL if @nr is out of range or if the MSI(-X) vector was allocated without explicit affinity requirements (e.g., by pci_enable_msi(), pci_enable_msix_range(), or pci_alloc_irq_vectors() without the %PCI_IRQ_AFFINITY flag). Return a generic set of CPU IDs representing all possible CPUs available during system boot if the device is in legacy INTx mode.",
        "proto" :"const struct cpumask *(*pci_irq_get_affinity)(struct pci_dev *dev, int nr)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        },
        "post": {
            "return": "!=null || (nr is out of range || MSI(-X) vector was allocated without explicit affinity requirements || device is in legacy INTx mode)"
        }
    }
},
{
    "kprobe:pci_irq_get_affinity": {
        "description": "Get a device interrupt vector affinity. Returns MSIMSI-X vector affinity, NULL if @nr is out of range or if the MSI(-X) vector was allocated without explicit affinity requirements (e.g., by pci_enable_msi(), pci_enable_msix_range(), or pci_alloc_irq_vectors() without the %PCI_IRQ_AFFINITY flag). Returns a generic set of CPU IDs representing all possible CPUs available during system boot if the device is in legacy INTx mode.",
        "proto" :"const struct cpumask *(*pci_irq_get_affinity)(struct pci_dev *dev, int nr)",
        "pre": {
            "dev": "!=null",
            "nr": ">=0"
        },
    }
},
{
    "kretprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send. This function returns the number of MSI vectors a device requested via Multiple Message Capable register. It returns a negative errno if the device is not capable sending MSI interrupts. Otherwise, the call succeeds and returns a power of two, up to a maximum of 2^5 (32), according to the MSI specification.",
        "proto" :"int pci_msi_vec_count(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-errno, 1, 2, 4, 8, 16, 32]"
        }
    }
},
{
    "kprobe:pci_msi_vec_count": {
        "description": "Return the number of MSI vectors a device can send. It returns a negative errno if the device is not capable sending MSI interrupts. Otherwise, the call succeeds and returns a power of two, up to a maximum of 2^5 (32), according to the MSI specification.",
        "proto" :"int pci_msi_vec_count(struct pci_dev *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [-errno, 2^5]"
        }
    }
},
{
    "kretprobe:pci_msi_mask_irq": {
        "description": "Generic IRQ chip callback to mask PCI MSI interrupts",
        "proto": "void (*pci_msi_mask_irq)(struct irq_data *data)",
        "pre": {
            "data": "!=null"
        }
    }
},
{
    "kprobe:pci_msi_mask_irq": {
        "description": "Generic IRQ chip callback to mask PCI MSI interrupts",
        "proto" :"void (*pci_msi_mask_irq)(struct irq_data *data)",
        "pre": {
            "data": "!=null",
            // Add more conditions here based on your understanding of the function
        },
    }
},


{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:bcma_core_pci_pcibios_map_irq": {
        "description": "This is not a device on the PCI-core bridge.",
        "proto" :"bcma_core_pci_pcibios_map_irq(const struct pci_dev  dev)",
        "pre": {
            "dev": "!=null",
            "dev->bus": "!=null",
            "dev->bus->ops": "!=null",
            "dev->bus->ops->read": "==bcma_core_pci_hostmode_read_config"
        },
    }
},
{
    "kretprobe:dio_register_driver": {
        "description": "Adds the driver structure to the list of registered drivers. Returns zero or a negative error value.",
        "proto" :"int dio_register_driver(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:dio_register_driver": {
        "description": "Register a new DIO driver. Adds the driver structure to the list of registered drivers. Returns zero or a negative error value.",
        "proto" :"int dio_register_driver(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver. Deletes the driver structure from the list of registered DIO drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void (*dio_unregister_driver)(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver. Deletes the driver structure from the list of registered DIO drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"void (*dio_unregister_driver)(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:dio_unregister_driver": {
        "description": "Unregister a DIO driver. Deletes the driver structure from the list of registered DIO drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"static long (*dio_unregister_driver)(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null"
        },
    }
},
{
    "kprobe:dio_unregister_driver": {
        "description": "Deletes the driver structure from the list of registered DIO drivers, gives it a chance to clean up by calling its remove() function for each device it was responsible for, and marks those devices as driverless.",
        "proto" :"static long (*dio_unregister_driver)(struct dio_driver *drv)",
        "pre": {
            "drv": "!=null",
        },
    }
},
{
    "kretprobe:devm_extcon_register_notifier": {
        "description": "This function manages automatically the notifier of extcon device using device resource management and simplify the control of unregistering the notifier of extcon device. Note that the second parameter given to the callback of nb (val) is 'old_state', not the current state. The current state can be retrieved by looking at the third parameter (edev pointer)'s state value. Returns 0 if success or negative error number if failure.",
        "proto" :"int devm_extcon_register_notifier(struct device *dev, struct extcon_dev *edev, unsigned int id, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "is a unique identifier",
            "nb": "!=null"
        },
    }
},
{
    "kprobe:devm_extcon_register_notifier": {
        "description": "This function manages automatically the notifier of extcon device using device resource management and simplify the control of unregistering the notifier of extcon device. Note that the second parameter given to the callback of nb (val) is 'old_state', not the current state. The current state can be retrieved by looking at the third parameter (edev pointer)'s state value. Returns 0 if success or negative error number if failure.",
        "proto" :"int devm_extcon_register_notifier(struct device *dev, struct extcon_dev *edev, unsigned int id, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "is a unique identifier",
            "nb": "!=null"
        },
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier() @dev:the device owning the extcon device being created @edev:the extcon device @id:the unique id among the extcon enumeration @nb:a notifier block to be registered",
        "proto" :"void devm_extcon_unregister_notifier(struct device *dev, struct extcon_dev *edev, unsigned int id, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "is a unique identifier",
            "nb": "!=null",
        },
    }
},
{
    "kprobe:devm_extcon_unregister_notifier": {
        "description": "Resource-managed extcon_unregister_notifier() @dev:the device owning the extcon device being created @edev:the extcon device @id:the unique id among the extcon enumeration @nb:a notifier block to be registered",
        "proto" :"void (*devm_extcon_unregister_notifier)(struct device *dev, struct extcon_dev *edev, unsigned int id, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "id": "is a unique identifier",
            "nb": "!=null",
        },
    }
},
{
    "kretprobe:devm_extcon_register_notifier_all": {
        "description": "This function manages automatically the notifier of extcon device using device resource management and simplify the control of unregistering the notifier of extcon device. To get more information, refer that function.",
        "proto" :"int devm_extcon_register_notifier_all(struct device *dev, struct extcon_dev *edev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:devm_extcon_register_notifier_all": {
        "description": "This function manages automatically the notifier of extcon device using device resource management and simplify the control of unregistering the notifier of extcon device. To get more information, refer that function. Returns 0 if success or negative error number if failure.",
        "proto" :"int (*devm_extcon_register_notifier_all)(struct device *dev, struct extcon_dev *edev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all() @dev:the device owning the extcon device being created @edev:the extcon device @nb:a notifier block to be registered",
        "proto" :"void devm_extcon_unregister_notifier_all(struct device *dev, struct extcon_dev *edev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:devm_extcon_unregister_notifier_all": {
        "description": "Resource-managed extcon_unregister_notifier_all() @dev:the device owning the extcon device being created @edev:the extcon device @nb:a notifier block to be registered",
        "proto" :"void (*devm_extcon_unregister_notifier_all)(struct device *dev, struct extcon_dev *edev, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "edev": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kretprobe:dmi_check_system": {
        "description": "Check system DMI data. All non-null elements of the list must match their slot's (field index's) data (i.e., each list string must be a substring of the specified DMI slot's string data) to be considered a successful match. Walk the blacklist table running matching functions until someone returns non zero or we hit the end. Callback function is called for each successful match. Returns the number of matches. dmi_setup must be called before this function is called.",
        "proto" :"int (*dmi_check_system)(const struct dmi_system_id *list)",
        "pre": {
            "list": "!=null"
        }
    }
},
{
    "kprobe:dmi_check_system": {
        "description": "Check system DMI data. All non-null elements of the list must match their slot's data to be considered a successful match. Walk the blacklist table running matching functions until someone returns non zero or we hit the end. Callback function is called for each successful match. Returns the number of matches.",
        "proto" :"int (*dmi_check_system)(const struct dmi_system_id *list)",
        "pre": {
            "list": "!=null"
        },
    }
},
{
    "kretprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data. All non-null elements of the list must match their slot's (field index's) data (i.e., each list string must be a substring of the specified DMI slot's string data) to be considered a successful match. Walk the blacklist table until the first match is found. Return the pointer to the matching entry or NULL if there's no match. dmi_setup must be called before this function is called.",
        "proto" :"const struct dmi_system_id *(*dmi_first_match)(const struct dmi_system_id *list)",
        "pre": {
            "list": "!=null"
        },
        "post": {
            "return": "in [pointer to matching entry, null]"
        }
    }
},
{
    "kprobe:dmi_first_match": {
        "description": "Find dmi_system_id structure matching system DMI data. Walk the blacklist table until the first match is found. Return the pointer to the matching entry or NULL if there's no match.",
        "proto" :"const struct dmi_system_id *(*dmi_first_match)(const struct dmi_system_id *list)",
        "pre": {
            "list": "!=null"
        },
    }
},
{
    "kretprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image. Any SMBIOS header must start 16 bytes before the DMI header, so take a 32 byte buffer and check for DMI at offset 16 and SMBIOS at offset 0. If the DMI header is present, set dmi_ver accordingly (SMBIOS takes precedence) and return 0. Otherwise return 1.",
        "proto" :"static int __init dmi_present(const u8 *buf)",
        "pre": {
            "buf": "!=null"
        }
    }
},
{
    "kprobe:dmi_present": {
        "description": "Check for DMISMBIOS headers in the system firmware image. Any SMBIOS header must start 16 bytes before the DMI header, so take a 32 byte buffer and check for DMI at offset 16 and SMBIOS at offset 0. If the DMI header is present, set dmi_ver accordingly (SMBIOS takes precedence) and return 0. Otherwise return 1.",
        "proto" :"static int __init dmi_present(const u8 *buf)",
        "pre": {
            "buf": "!=null",
        },
    }
},
{
    "kretprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "proto" :"int (*dmi_name_in_vendors)(const char *str)",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kprobe:dmi_name_in_vendors": {
        "description": "Check if string is in the DMI system or board vendor name",
        "proto" :"int (*dmi_name_in_vendors)(const char *str)",
        "pre": {
            "str": "!=null"
        }
    }
},
{
    "kretprobe:dmi_save_oem_strings_devices": {
        "description": "Your function description here",
        "proto" :"static void (*dmi_save_oem_strings_devices)(const struct dmi_header *dm)",
        "pre": {
            "dm": "!=null"
        }
    }
},

{
    "kretprobe:dmi_get_date": {
        "description": "Parse a DMI date. The date field is assumed to be in the form resembling [mm[dd]]yy[yy] and the result is stored in the out parameters any or all of which can be omitted. If the field doesn't exist, all out parameters are set to zero and false is returned. Otherwise, true is returned with any invalid part of date set to zero. On return, year, month and day are guaranteed to be in the range of [0,9999], [0,12] and [0,31] respectively.",
        "proto" :"bool (*dmi_get_date)(int field, int *yearp, int *monthp, int *dayp)",
        "pre": {
            "field": "in [0,9999]",
            "yearp": "!=null",
            "monthp": "!=null",
            "dayp": "!=null"
        },
        "post": {
            "yearp": "in [0,9999]",
            "monthp": "in [0,12]",
            "dayp": "in [0,31]",
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:dmi_get_date": {
        "description": "Parse a DMI date. The date field is assumed to be in the form resembling [mm[dd]]yy[yy] and the result is stored in the out parameters any or all of which can be omitted. If the field doesn't exist, all out parameters are set to zero and false is returned. Otherwise, true is returned with any invalid part of date set to zero. On return, year, month and day are guaranteed to be in the range of [0,9999], [0,12] and [0,31] respectively.",
        "proto" :"bool (*dmi_get_date)(int field, int *yearp, int *monthp, int *dayp)",
        "pre": {
            "field": "in [enum dmi_field]",
            "yearp": "!=null",
            "monthp": "!=null",
            "dayp": "!=null"
        },
        "post": {
            "yearp": "in [0,9999]",
            "monthp": "in [0,12]",
            "dayp": "in [0,31]"
        }
    }
},
{
    "kretprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field. Returns year on success, -ENXIO if DMI is not selected, or a different negative error code if DMI field is not present or not parseable.",
        "proto" :"int dmi_get_bios_year(void)",
        "pre": {},
        "post": {
            "return": "in [year, -ENXIO, negative error code]"
        }
    }
},
{
    "kprobe:dmi_get_bios_year": {
        "description": "Get a year out of DMI_BIOS_DATE field. Returns year on success, -ENXIO if DMI is not selected, or a different negative error code if DMI field is not present or not parseable.",
        "proto" :"int dmi_get_bios_year(void)",
        "pre": {},
        "post": {
            "return": "in [year, -ENXIO, negative error code]"
        }
    }
},
{
    "kretprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus. Entry point function for the cpus. Set the Linux entry point for the SCM to transfer control to when coming out of a power down. CPU power down may be executed on cpuidle or hotplug.",
        "proto" :"int (*qcom_scm_set_warm_boot_addr)(void *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_warm_boot_addr": {
        "description": "Set the warm boot address for all cpus. Set the Linux entry point for the SCM to transfer control to when coming out of a power down. CPU power down may be executed on cpuidle or hotplug.",
        "proto" :"int (*qcom_scm_set_warm_boot_addr)(void *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all cpus. @entry: Entry point function for the cpus",
        "proto" :"int (*qcom_scm_set_cold_boot_addr)(void *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_set_cold_boot_addr": {
        "description": "Set the cold boot address for all CPUs. @entry: Entry point function for the CPUs.",
        "proto" :"int (*qcom_scm_set_cold_boot_addr)(void *entry)",
        "pre": {
            "entry": "!=null"
        }
    }
},
{
    "kretprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu. If there was a pending interrupt, the control would return from this function, otherwise, the cpu jumps to the warm boot entry point set for this cpu upon reset.",
        "proto" :"static void (*qcom_scm_cpu_power_down)(u32 flags)",
        "pre": {
            "flags": "is u32"
        }
    }
},
{
    "kprobe:qcom_scm_cpu_power_down": {
        "description": "Power down the cpu. If there was a pending interrupt, the control would return from this function, otherwise, the cpu jumps to the warm boot entry point set for this cpu upon reset.",
        "proto" :"static void (*qcom_scm_cpu_power_down)(u32 flags)",
        "pre": {
            "flags": ">=0",
        },
    }
},
{
    "kretprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata. Upon successful return, the PAS metadata context (@ctx) will be used to track the metadata allocation, this needs to be released by invoking qcom_scm_pas_metadata_release() by the caller.",
        "proto" :"int qcom_scm_pas_init_image(u32 peripheral, const void *metadata, size_t size, struct qcom_scm_pas_metadata *ctx)",
        "pre": {
            "peripheral": "is a valid peripheral id",
            "metadata": "!=null",
            "size": "is the size of the metadata",
            "ctx": "!=null"
        },
        "post": {
            "return": "in [0, error codes]"
        }
    }
},
{
    "kprobe:qcom_scm_pas_init_image": {
        "description": "Initialize peripheral authentication service state machine for a given peripheral, using the metadata. Upon successful return, the PAS metadata context (@ctx) will be used to track the metadata allocation, this needs to be released by invoking qcom_scm_pas_metadata_release() by the caller.",
        "proto" :"int (*qcom_scm_pas_init_image)(u32 peripheral, const void *metadata, size_t size, struct qcom_scm_pas_metadata *ctx)",
        "pre": {
            "peripheral": "is a valid peripheral id",
            "metadata": "!=null, pointer to memory containing ELF header, program header table and optional blob of data used for authenticating the metadata and the rest of the firmware",
            "size": "is the size of the metadata",
            "ctx": "optional metadata context"
        },
    }
},
{
    "kretprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading",
        "proto" :"int (*qcom_scm_pas_mem_setup)(u32 peripheral, phys_addr_t addr, phys_addr_t size)",
        "pre": {
            "peripheral": ">=0",
            "addr": "!=null",
            "size": ">0"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:qcom_scm_pas_mem_setup": {
        "description": "Prepare the memory related to a given peripheral for firmware loading. Returns 0 on success.",
        "proto" :"int (*qcom_scm_pas_mem_setup)(u32 peripheral, phys_addr_t addr, phys_addr_t size)",
        "pre": {
            "peripheral": "is a valid peripheral id",
            "addr": "is a valid start address of memory area to prepare",
            "size": "is a valid size of the memory area to prepare",
        },
    }
},
{
    "kretprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor",
        "proto" :"int (*qcom_scm_pas_auth_and_reset)(u32 peripheral)",
        "pre": {
            "peripheral": ">=0"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:qcom_scm_pas_auth_and_reset": {
        "description": "Authenticate the given peripheral firmware and reset the remote processor",
        "proto" :"int (*qcom_scm_pas_auth_and_reset)(u32 peripheral)",
        "pre": {
            "peripheral": "> 0"
        },
    }
},
{
    "kretprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor. Returns 0 on success.",
        "proto" :"int (*qcom_scm_pas_shutdown)(u32 peripheral)",
        "pre": {
            "peripheral": ">=0"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:qcom_scm_pas_shutdown": {
        "description": "Shut down the remote processor. Returns 0 on success.",
        "proto" :"int (*qcom_scm_pas_shutdown)(u32 peripheral)",
        "pre": {
            "peripheral": ">=0"
        }
    }
},
{
    "kretprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral. Returns true if PAS is supported for this peripheral, otherwise false.",
        "proto" :"bool (*qcom_scm_pas_supported)(u32 peripheral)",
        "pre": {
            "peripheral": ">=0"
        },
    }
},
{
    "kprobe:qcom_scm_pas_supported": {
        "description": "Check if the peripheral authentication service is available for the given peripheral",
        "proto" :"bool (*qcom_scm_pas_supported)(u32 peripheral)",
        "pre": {
            "peripheral": "is a valid peripheral id"
        },
    }
},
{
    "kretprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface. Return true if restore-cfg interface is supported, false if not.",
        "proto" :"bool (*qcom_scm_restore_sec_cfg_available)(void)",
        "pre": {
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_restore_sec_cfg_available": {
        "description": "Check if secure environment supports restore security config interface. Return true if restore-cfg interface is supported, false if not.",
        "proto" :"bool (*qcom_scm_restore_sec_cfg_available)(void)",
        "pre": {}
    }
},
{
    "kretprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table. If the page table has been initialized already, ignore the error.",
        "proto" :"static long (*qcom_scm_iommu_secure_ptbl_init)(u64 addr, u32 size, u32 spare)",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        },
        "post": {
            "ret": "in [-EPERM, 0]"
        }
    }
},
{
    "kprobe:qcom_scm_iommu_secure_ptbl_init": {
        "description": "Initialize the secure page table. If the page table has been initialized already, ignore the error.",
        "proto" :"static long (*qcom_scm_iommu_secure_ptbl_init)(u64 addr, u32 size, u32 spare)",
        "pre": {
            "addr": "!=null",
            "size": "!=null",
            "spare": "!=null"
        },
    }
},
{
    "kretprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership. Return negative errno on failure or 0 on success with @srcvm updated.",
        "proto" :"int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz, u64 *srcvm, const struct qcom_scm_vmperm *newvm, unsigned int dest_cnt)",
        "pre": {
            "mem_addr": "!=null",
            "mem_sz": ">0",
            "srcvm": "!=null",
            "newvm": "!=null",
            "dest_cnt": ">=0"
        },
    }
},
{
    "kprobe:qcom_scm_assign_mem": {
        "description": "Make a secure call to reassign memory ownership.",
        "proto" :"int qcom_scm_assign_mem(phys_addr_t mem_addr, size_t mem_sz, u64 *srcvm, const struct qcom_scm_vmperm *newvm, unsigned int dest_cnt)",
        "pre": {
            "mem_addr": "!=null",
            "mem_sz": ">0",
            "srcvm": "!=null",
            "newvm": "!=null",
            "dest_cnt": ">=0"
        },
    }
},
{
    "kretprobe:qcom_scm_ocmem_lock_available": {
        "description": "is OCMEM lockunlock interface available",
        "proto" :"bool (*qcom_scm_ocmem_lock_available)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:qcom_scm_ocmem_lock_available": {
        "description": "is OCMEM lockunlock interface available",
        "proto" :"bool (*qcom_scm_ocmem_lock_available)(void)",
        "pre": {}
    }
},
{
    "kretprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "proto" :"int (*qcom_scm_ocmem_unlock)(enum qcom_scm_ocmem_client id, u32 offset, u32 size)",
        "pre": {
            "id": "in [valid qcom_scm_ocmem_client enum values]",
            "offset": ">=0",
            "size": ">0",
        },
    }
},
{
    "kprobe:qcom_scm_ocmem_unlock": {
        "description": "Call OCMEM unlock interface to release an OCMEM region from the specified initiator.",
        "proto" :"int (*qcom_scm_ocmem_unlock)(enum qcom_scm_ocmem_client id, u32 offset, u32 size)",
        "pre": {
            "id": "in range of enum qcom_scm_ocmem_client",
            "offset": "!=null",
            "size": "!=null"
        },
    }
},
{
    "kretprobe:qcom_scm_ice_available": {
        "description": "qcom_scm_ice_set_key() are available.",
        "proto" :"bool (*qcom_scm_ice_available)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:qcom_scm_ice_available": {
        "description": "qcom_scm_ice_set_key() are available.",
        "proto" :"bool (*qcom_scm_ice_available)(void)",
        "pre": {}
    }
},
{
    "kretprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP. Return true if HDCP is supported, false if not.",
        "proto" :"bool (*qcom_scm_hdcp_available)(void)",
        "pre": {},
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_available": {
        "description": "Check if secure environment supports HDCP. Return true if HDCP is supported, false if not.",
        "proto" :"bool (*qcom_scm_hdcp_available)(void)",
        "pre": {},
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request. Write HDCP register(s) through SCM.",
        "proto" :"int (*qcom_scm_hdcp_req)(struct qcom_scm_hdcp_req *req, u32 req_cnt, u32 *resp)",
        "pre": {
            "req": "!=null",
            "req_cnt": ">=0",
            "resp": "!=null"
        }
    }
},
{
    "kprobe:qcom_scm_hdcp_req": {
        "description": "Send HDCP request. Write HDCP register(s) through SCM.",
        "proto" :"int (*qcom_scm_hdcp_req)(struct qcom_scm_hdcp_req *req, u32 req_cnt, u32 *resp)",
        "pre": {
            "req": "!=null",
            "req_cnt": ">=0",
            "resp": "!=null"
        }
    }
},

{
    "kprobe:qcom_scm_iommu_set_pt_format": {
        "description": "Set the page table format for the given security ID and context number.",
        "proto" :"static long (*qcom_scm_iommu_set_pt_format)(u32 sec_id, u32 ctx_num, u32 pt_fmt)",
        "pre": {
            "sec_id": ">=0",
            "ctx_num": ">=0",
            "pt_fmt": "in [0, 1]",
        },
    }
},
{
    "kretprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "proto" :"bool (*qcom_scm_is_available)(void)",
        "pre": {
        },
    }
},
{
    "kprobe:qcom_scm_is_available": {
        "description": "Checks if SCM is available",
        "proto" :"bool (*qcom_scm_is_available)(void)",
        "pre": {}
    }
},
{
    "kretprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware. Uses an OP-TEE call to start a secure boot process. Returns 0 on success, negative errno otherwise.",
        "proto" :"int tee_bnxt_fw_load(void)",
        "pre": {
        },
        "post": {
            "return": "in [0, negative errno]"
        }
    }
},
{
    "kprobe:tee_bnxt_fw_load": {
        "description": "Load the bnxt firmware. Uses an OP-TEE call to start a secure boot process. Returns 0 on success, negative errno otherwise.",
        "proto" :"int (*tee_bnxt_fw_load)(void)",
        "pre": {}
    }
},
{
    "kretprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory. Uses an OP-TEE call to copy coredump.",
        "proto" :"int (*tee_bnxt_copy_coredump)(void *buf, u32 offset, u32 size)",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        },
        "post": {
            "return": "in [-errno, 0]"
        }
    }
},
{
    "kprobe:tee_bnxt_copy_coredump": {
        "description": "Copy coredump from the allocated memory. Uses an OP-TEE call to copy coredump.",
        "proto" :"int (*tee_bnxt_copy_coredump)(void *buf, u32 offset, u32 size)",
        "pre": {
            "buf": "!=null",
            "offset": ">=0",
            "size": ">=0"
        },
    }
},
{
    "kretprobe:bcm47xx_nvram_getenv": {
        "description": "Look for name=value and return value",
        "proto" :"static int (*bcm47xx_nvram_getenv)(const char *name, char *val, size_t val_len)",
        "pre": {
            "name": "!=null",
            "val": "!=null",
            "val_len": ">0",
        },
    }
},
{
    "kprobe:bcm47xx_nvram_getenv": {
        "description": "Look for name=value and return value",
        "proto" :"static int (*bcm47xx_nvram_getenv)(const char *name, char *val, size_t val_len)",
        "pre": {
            "name": "!=null",
            "val": "!=null",
            "val_len": ">0",
        },
    }
},
{
    "kretprobe:bcm47xx_nvram_gpio_pin": {
        "description": "This function retrieves the value of a specific GPIO pin from the NVRAM.",
        "proto" :"static int (*bcm47xx_nvram_gpio_pin)(const char *name)",
        "pre": {
            "name": "!=null"
        },
    }
},
{
    "kprobe:bcm47xx_nvram_gpio_pin": {
        "description": "This function seems to be related to GPIO pin configuration in NVRAM of bcm47xx devices. However, the exact functionality is not clear from the provided information.",
        "proto" :"int bcm47xx_nvram_gpio_pin(const char *name)",
        "pre": {
            "name": "!=null",
        },
    }
},
{
    "kretprobe:tegra_ivc_read_get_next_frame": {
        "description": "Order observation of ivc->rx.position potentially indicating new data before data read.",
        "proto" :"tegra_ivc_read_get_next_frame(struct tegra_ivc  ivc, struct iosys_map  map)",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kprobe:tegra_ivc_read_get_next_frame": {
        "description": "Order observation of ivc->rx.position potentially indicating new data before data read.",
        "proto" :"int tegra_ivc_read_get_next_frame(struct tegra_ivc *ivc, struct iosys_map *map)",
        "pre": {
            "ivc": "!=null",
            "map": "!=null"
        }
    }
},
{
    "kretprobe:tegra_ivc_read_advance": {
        "description": "No read barriers or synchronization here: the caller is expected to have already observed the channel non-empty. This check is just to catch programming errors.",
        "proto" :"tegra_ivc_read_advance(struct tegra_ivc  ivc)",
        "pre": {
            "ivc": "!=null"
        },
        "post": {
            "err": "< 0"
        }
    }
},
{
    "kprobe:tegra_ivc_read_advance": {
        "description": "No read barriers or synchronization here: the caller is expected to have already observed the channel non-empty. This check is just to catch programming errors.",
        "proto" :"tegra_ivc_read_advance(struct tegra_ivc  ivc)",
        "pre": {
            "ivc": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:tegra_ivc_write_advance": {
        "description": "Order any possible stores to the frame before update of ivc->tx.position.",
        "proto" :"tegra_ivc_write_advance(struct tegra_ivc  ivc)",
        "pre": {
            "ivc": "!=null",
            // Add other conditions here based on your understanding of the function
        },
    }
},
{
    "kprobe:tegra_ivc_write_advance": {
        "description": "Order any possible stores to the frame before update of ivc->tx.position.",
        "proto" :"tegra_ivc_write_advance(struct tegra_ivc  ivc)",
        "pre": {
            "ivc": "!=null",
            // Add other preconditions here based on your understanding of the function
        },
    }
},

{
    "kprobe:tegra_ivc_notified": {
        "description": "The description of the function goes here.",
        "proto" :"int (*tegra_ivc_notified)(struct tegra_ivc *ivc)",
        "pre": {
            "ivc": "!=null"
        }
    }
},
{
    "kretprobe:tegra_ivc_init": {
        "description": "Initializes the tegra_ivc with the given parameters. All sizes that can be returned by communication functions should fit in an int.",
        "proto": "int tegra_ivc_init(struct tegra_ivc *ivc, struct device *peer, const struct iosys_map *rx, dma_addr_t rx_phys, const struct iosys_map *tx, dma_addr_t tx_phys, unsigned int num_frames, size_t frame_size, void (*notify)(struct tegra_ivc *ivc, void *data), void *data)",
        "pre": {
            "ivc": "!=null",
            "notify": "!=null",
            "rx": "!=null",
            "tx": "!=null",
            "frame_size": "<= INT_MAX",
            "num_frames": ">= 0",
            "rx_phys": ">= 0",
            "tx_phys": ">= 0",
            "data": "can be null or non-null"
        },
        "post": {
            "return": "in [-E2BIG, -EINVAL, 0]"
        }
    }
},
{
    "kprobe:tegra_ivc_init": {
        "description": "Initializes the tegra_ivc with the given parameters. All sizes that can be returned by communication functions should fit in an int.",
        "proto" :"static int (*tegra_ivc_init)(struct tegra_ivc *ivc, struct device *peer, const struct iosys_map *rx, dma_addr_t rx_phys, const struct iosys_map *tx, dma_addr_t tx_phys, unsigned int num_frames, size_t frame_size, void (*notify)(struct tegra_ivc *ivc, void *data), void *data)",
        "pre": {
            "ivc": "!=null",
            "notify": "!=null",
            "rx": "!=null",
            "tx": "!=null",
            "num_frames": ">=0",
            "frame_size": "<=INT_MAX",
            "rx_phys": ">=0",
            "tx_phys": ">=0",
            "data": "can be null or non-null"
        },
    }
},
{
    "kretprobe:meson_sm_call": {
        "description": "Generic SMC32 call to the secure-monitor",
        "proto": "int meson_sm_call(struct meson_sm_firmware *fw, unsigned int cmd_index, u32 *ret, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "cmd_index": ">=0",
            "ret": "!=null",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        },
        "post": {
            "return": "in [0, negative value]"
        }
    }
},
{
    "kprobe:meson_sm_call": {
        "description": "Generic SMC32 call to the secure-monitor",
        "proto": "int (*meson_sm_call)(struct meson_sm_firmware *fw, unsigned int cmd_index, u32 *ret, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "cmd_index": ">=0",
            "ret": "!=null",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        }
    }
},
{
    "kretprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor. When 0 is returned there is no guarantee about the amount of data read and bsize bytes are copied in buffer.",
        "proto" :"int meson_sm_call_read(struct meson_sm_firmware *fw, void *buffer, unsigned int bsize, unsigned int cmd_index, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">=0",
            "cmd_index": ">=0",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        },
    }
},
{
    "kprobe:meson_sm_call_read": {
        "description": "Retrieve data from secure-monitor. Returns size of read data on success, a negative value on error. When 0 is returned there is no guarantee about the amount of data read and bsize bytes are copied in buffer.",
        "proto" :"int (*meson_sm_call_read)(struct meson_sm_firmware *fw, void *buffer, unsigned int bsize, unsigned int cmd_index, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "bsize": ">0",
            "cmd_index": ">=0",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        }
    }
},
{
    "kretprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor. Returns size of sent data on success, a negative value on error.",
        "proto" :"int meson_sm_call_write(struct meson_sm_firmware *fw, void *buffer, unsigned int size, unsigned int cmd_index, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">0",
            "cmd_index": ">=0",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        }
    }
},
{
    "kprobe:meson_sm_call_write": {
        "description": "Send data to secure-monitor",
        "proto" :"int (*meson_sm_call_write)(struct meson_sm_firmware *fw, void *buffer, unsigned int size, unsigned int cmd_index, u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4)",
        "pre": {
            "fw": "!=null",
            "buffer": "!=null",
            "size": ">0",
            "cmd_index": ">=0",
            "arg0": "is u32",
            "arg1": "is u32",
            "arg2": "is u32",
            "arg3": "is u32",
            "arg4": "is u32"
        },
    }
},
{
    "kretprobe:efi_function": {
        "description": "Description of the function",
        "proto" :"static long (*efi_function)(void *param1, const void *param2, const void *param3, __u64 flags)",
        "pre": {
            "param1": "!=null",
            "param2": "!=null",
            "param3": "!=null",
            "flags": "in [FLAG1, FLAG2, FLAG3]",
        },
    }
},

{
    "kretprobe:imx_scu_call_rpc": {
        "description": "This function is used to call the SCU firmware APIs. It sends a message and waits for a response if have_resp is true. The response status is stored in hdr->func field.",
        "proto": "int imx_scu_call_rpc(struct imx_sc_ipc *sc_ipc, void *msg, bool have_resp)",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "in [true, false]"
        },
        "post": {
            "ret": "in [-EINVAL, -ETIMEDOUT, >=0]"
        }
    }
},
{
    "kprobe:imx_scu_call_rpc": {
        "description": "This function is used to call the SCU firmware APIs. It sends a message and waits for a response if have_resp is true. The response status is stored in the hdr->func field.",
        "proto" :"int (*imx_scu_call_rpc)(struct imx_sc_ipc *sc_ipc, void *msg, bool have_resp)",
        "pre": {
            "sc_ipc": "!=null",
            "msg": "!=null",
            "have_resp": "in [true, false]"
        },
        "post": {
            "ret": "in [-EINVAL, -ETIMEDOUT, >=0]"
        }
    }
},
{
    "kretprobe:imx_sc_rm_is_resource_owned": {
        "description": "SCU firmware only returns value 0 or 1 for resource owned check which means not owned or owned. So it is always successful.",
        "proto" :"imx_sc_rm_is_resource_owned(struct imx_sc_ipc  ipc, u16 resource)",
        "pre": {
            "ipc": "!=null",
            "resource": "is u16"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:imx_sc_rm_is_resource_owned": {
        "description": "SCU firmware only returns value 0 or 1 for resource owned check which means not owned or owned. So it is always successful.",
        "proto" :"imx_sc_rm_is_resource_owned(struct imx_sc_ipc  ipc, u16 resource)",
        "pre": {
            "ipc": "!=null",
            "resource": "is u16"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kretprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP). Returns non-negative value for success, negative value for error.",
        "proto" :"int (*imx_dsp_ring_doorbell)(struct imx_dsp_ipc *ipc, unsigned int idx)",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        },
        "post": {
            "return": ">=-1"
        }
    }
},
{
    "kprobe:imx_dsp_ring_doorbell": {
        "description": "Triggers an interrupt on the other side (DSP). Returns non-negative value for success, negative value for error.",
        "proto" :"int (*imx_dsp_ring_doorbell)(struct imx_dsp_ipc *ipc, unsigned int idx)",
        "pre": {
            "ipc": "!=null",
            "idx": ">=0"
        }
    }
},
B,

{
    "kretprobe:w1_register_family": {
        "description": "Register a device family driver @newf:family to register",
        "proto" :"int (*w1_register_family)(struct w1_family *newf)",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kprobe:w1_register_family": {
        "description": "Register a device family driver",
        "proto" :"int (*w1_register_family)(struct w1_family *newf)",
        "pre": {
            "newf": "!=null"
        }
    }
},
{
    "kretprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "proto" :"void (*w1_unregister_family)(struct w1_family *fent)",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kprobe:w1_unregister_family": {
        "description": "Unregister a device family driver",
        "proto" :"void (*w1_unregister_family)(struct w1_family *fent)",
        "pre": {
            "fent": "!=null"
        }
    }
},
{
    "kretprobe:w1_add_master_device": {
        "description": "Registers a new master device",
        "proto" :"int w1_add_master_device(struct w1_bus_master *master)",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kprobe:w1_add_master_device": {
        "description": "Registers a new master device.",
        "proto" :"int (*w1_add_master_device)(struct w1_bus_master *master)",
        "pre": {
            "master": "!=null"
        }
    }
},
{
    "kretprobe:atomic_set": {
        "description": "Sets the value of &dev->refcnt to 1.",
        "proto" :"void atomic_set(atomic_t *v, int i)",
        "pre": {
            "v": "!=null",
            "i": "==1"
        },
    }
},
{
    "kprobe:atomic_set": {
        "description": "Sets the value of &dev->refcnt to 1.",
        "proto" :"void atomic_set(atomic_t *v, int i)",
        "pre": {
            "v": "!=null",
            "i": "==1"
        }
    }
},
{
    "kretprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver. Create WDM usb class character device and associate it with intf without binding, allowing another driver to manage the interface. The subdriver will manage the given interrupt endpoint exclusively and will issue control requests referring to the given intf. It will otherwise avoid interferring, and in particular not do usb_set_intfdatausb_get_intfdata on intf. The return value is a pointer to the subdriver's struct usb_driver. The registering driver is responsible for calling this subdriver's disconnect, suspend, resume, pre_reset and post_reset methods from its own.",
        "proto" :"struct usb_driver *(*usb_cdc_wdm_register)(struct usb_interface *intf, struct usb_endpoint_descriptor *ep, int bufsize, enum wwan_port_type type, int (*manage_power)(struct usb_interface *, int))",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">0",
            "type": "in [MBIM, QMI, ...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kprobe:usb_cdc_wdm_register": {
        "description": "Register a WDM subdriver. Create WDM usb class character device and associate it with intf without binding, allowing another driver to manage the interface. The subdriver will manage the given interrupt endpoint exclusively and will issue control requests referring to the given intf. It will otherwise avoid interferring, and in particular not do usb_set_intfdatausb_get_intfdata on intf. The return value is a pointer to the subdriver's struct usb_driver. The registering driver is responsible for calling this subdriver's disconnect, suspend, resume, pre_reset and post_reset methods from its own.",
        "proto" :"struct usb_driver *(*usb_cdc_wdm_register)(struct usb_interface *intf, struct usb_endpoint_descriptor *ep, int bufsize, enum wwan_port_type type, int (*manage_power)(struct usb_interface *, int))",
        "pre": {
            "intf": "!=null",
            "ep": "!=null",
            "bufsize": ">0",
            "type": "in [MBIM, QMI, ...]",
            "manage_power": "!=null"
        }
    }
},
{
    "kretprobe:cdc_parse_cdc_header": {
        "description": "This evaluates the extra headers present in CDC devices which bind the interfaces for data and control and provide details about the capabilities of the device.",
        "proto" :"int (*cdc_parse_cdc_header)(struct usb_cdc_parsed_header *hdr, struct usb_interface *intf, u8 *buffer, int buflen)",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, buflen]"
        }
    }
},
{
    "kprobe:cdc_parse_cdc_header": {
        "description": "This evaluates the extra headers present in CDC devices which bind the interfaces for data and control and provide details about the capabilities of the device.",
        "proto" :"int (*cdc_parse_cdc_header)(struct usb_cdc_parsed_header *hdr, struct usb_interface *intf, u8 *buffer, int buflen)",
        "pre": {
            "hdr": "!=null",
            "intf": "!=null",
            "buffer": "!=null",
            "buflen": ">=0"
        },
        "post": {
            "return": "in [-EINVAL, buflen]"
        }
    }
},
{
    "kretprobe:usb_serial_suspend": {
        "description": "Suspend a USB serial interface. If called more than once, return 0. serial->type->suspend() must return 0 in system sleep context, otherwise, the resume callback has to recover the device from previous suspend failure.",
        "proto": "int usb_serial_suspend(struct usb_interface *intf, pm_message_t message)",
        "pre": {
            "intf": "!=null",
            "message": "is valid pm_message_t"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:usb_serial_suspend": {
        "description": "Suspend when called for first sibling interface",
        "proto": "static int (*usb_serial_suspend)(struct usb_interface *intf, pm_message_t message)",
        "pre": {
            "intf": "!=null",
            "message": "is valid pm_message_t"
        }
    }
},
{
    "kretprobe:usb_serial_resume": {
        "description": "Resume when called for last sibling interface",
        "proto" :"static int (*usb_serial_resume)(struct usb_interface *intf)",
        "pre": {
            "intf": "!=null"
        }
    }
},
{
    "kprobe:usb_serial_resume": {
        "description": "Resume when called for last sibling interface",
        "proto" :"static int (*usb_serial_resume)(struct usb_interface *intf)",
        "pre": {
            "intf": "!=null"
        }
    }
},
{
    "kretprobe:usb_wwan_dtr_rts": {
        "description": "This function sets the rts_state and dtr_state of the portdata to 'on' and sends setup to the port.",
        "proto" :"void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)",
        "pre": {
            "port": "!=null",
            "on": "in [0, 1]"
        },
    }
},
{
    "kprobe:usb_wwan_dtr_rts": {
        "description": "This function sets the rts_state and dtr_state of the portdata to 'on' and sends setup through the port.",
        "proto" :"void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)",
        "pre": {
            "port": "!=null",
            "on": "is an integer"
        },
    }
},

{
    "kprobe:usb_wwan_tiocmset": {
        "description": "Set or clear the RTS and DTR states of a USB serial port. If the 'use_send_setup' field of the interface data is not set, return -EINVAL.",
        "proto" :"int usb_wwan_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)",
        "pre": {
            "tty": "!=null",
            "set": "in [TIOCM_RTS, TIOCM_DTR]",
            "clear": "in [TIOCM_RTS, TIOCM_DTR]",
            "tty->driver_data": "!=null",
            "usb_get_serial_port_data(tty->driver_data)": "!=null",
            "usb_get_serial_data(tty->driver_data->serial)": "!=null",
            "usb_get_serial_data(tty->driver_data->serial)->use_send_setup": "==1"
        },
    }
},
{
    "kretprobe:usb_wwan_write": {
        "description": "Writes data to the USB WWAN port.",
        "proto" :"static int (*usb_wwan_write)(struct tty_struct *tty, struct usb_serial_port *port, const unsigned char *buf, int count)",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
        },
    }
},
{
    "kprobe:usb_wwan_write": {
        "description": "Writes data to the USB WWAN port.",
        "proto" :"static int (*usb_wwan_write)(struct tty_struct *tty, struct usb_serial_port *port, const unsigned char *buf, int count)",
        "pre": {
            "tty": "!=null",
            "port": "!=null",
            "buf": "!=null",
            "count": ">=0",
        },
    }
},





{
    "kprobe:usb_wwan_close": {
        "description": "Need to take susp_lock to make sure port is not already being resumed, but no need to hold it due to the tty-port initialized flag.",
        "proto" :"void usb_wwan_close(struct usb_serial_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:gemini_sata_bridge_enabled": {
        "description": "In muxmode 2 and 3 one of the ATA controllers is actually not connected to any SATA bridge.",
        "proto" :"bool (*gemini_sata_bridge_enabled)(struct sata_gemini *sg, bool is_ata1)",
        "pre": {
            "sg": "!=null",
            "is_ata1": "is bool"
        },
        "post": {
            "sg->muxmode": "in [GEMINI_MUXMODE_2, GEMINI_MUXMODE_3]",
            "sg->sata_bridge": "!=null"
        }
    }
},

{
    "kretprobe:gemini_sata_start_bridge": {
        "description": "Starts the Gemini SATA bridge. Do not keep clocking a bridge that is not online.",
        "proto" :"int (*gemini_sata_start_bridge)(struct sata_gemini *sg, unsigned int bridge)",
        "pre": {
            "sg": "!=null",
            "bridge": "in [0, 1]"
        },
        "post": {
            "ret": "in [0, 1]"
        }
    }
},
{
    "kprobe:gemini_sata_start_bridge": {
        "description": "Starts the Gemini SATA bridge. If the bridge is not online, it will not keep clocking.",
        "proto" :"int gemini_sata_start_bridge(struct sata_gemini *sg, unsigned int bridge)",
        "pre": {
            "sg": "!=null",
            "bridge": "in [0, 1]"
        },
    }
},


{
    "kretprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine. In the libata object model there is a 1:1 mapping of ata_port to shost, so host fields can be directly manipulated under ap->lock, in the libsas case we need to hold a lock at the ha->level to coordinate these events.",
        "proto" :"void (*ata_std_end_eh)(struct ata_port *ap)",
        "pre": {
            "ap": "!=null"
        }
    }
},
{
    "kprobe:ata_std_end_eh": {
        "description": "Non-libsas ata_ports complete eh with this common routine. In the libata object model there is a 1:1 mapping of ata_port to shost, so host fields can be directly manipulated under ap->lock, in the libsas case we need to hold a lock at the ha->level to coordinate these events.",
        "proto" :"void ata_std_end_eh(struct ata_port *ap)",
        "pre": {
            "ap": "Your condition here"
        }
    }
},
{
    "kretprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading. The caller must make sure that this function is not running concurrently for the same indio_dev more than once. Any events that are submitted before iio_device_register() has successfully completed will be silently discarded.",
        "proto" :"int iio_push_event(struct iio_dev *indio_dev, u64 ev_code, s64 timestamp)",
        "pre": {
            "indio_dev": "!=null",
            "ev_code": "is a valid event code",
            "timestamp": "is a valid timestamp"
        },
    }
},
{
    "kprobe:iio_push_event": {
        "description": "Try to add event to the list for userspace reading. The caller must make sure that this function is not running concurrently for the same indio_dev more than once. Any events that are submitted before iio_device_register() has successfully completed will be silently discarded.",
        "proto" :"int (*iio_push_event)(struct iio_dev *indio_dev, u64 ev_code, s64 timestamp)",
        "pre": {
            "indio_dev": "!=null && obtained from iio_device_alloc() && not concurrently used in iio_push_event",
            "ev_code": "any",
            "timestamp": "any"
        },
    }
},
{
    "kretprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "proto" :"int (*iio_device_set_clock)(struct iio_dev *indio_dev, clockid_t clock_id)",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "in [CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID, CLOCK_MONOTONIC_RAW, CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME, CLOCK_REALTIME_ALARM, CLOCK_BOOTTIME_ALARM]"
        },
    }
},
{
    "kprobe:iio_device_set_clock": {
        "description": "Set current timestamping clock for the device",
        "proto" :"int (*iio_device_set_clock)(struct iio_dev *indio_dev, clockid_t clock_id)",
        "pre": {
            "indio_dev": "!=null",
            "clock_id": "in [CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID, CLOCK_MONOTONIC_RAW, CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME, CLOCK_REALTIME_ALARM, CLOCK_BOOTTIME_ALARM, CLOCK_SGI_CYCLE, CLOCK_TAI]"
        },
    }
},
{
    "kretprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "proto": "clockid_t (*iio_device_get_clock)(const struct iio_dev *indio_dev)",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_get_clock": {
        "description": "Retrieve current timestamping clock for the device",
        "proto" :"clockid_t (*iio_device_get_clock)(const struct iio_dev *indio_dev)",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "proto" :"s64 (*iio_get_time_ns)(const struct iio_dev *indio_dev)",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kprobe:iio_get_time_ns": {
        "description": "Utility function to get a time stamp for events etc.",
        "proto": "s64 (*iio_get_time_ns)(const struct iio_dev *indio_dev)",
        "pre": {
            "indio_dev": "!=null"
        }
    }
},
{
    "kretprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property. If device is assigned no mounting matrix property, a default 3x3 identity matrix will be filled in.",
        "proto" :"int (*iio_read_mount_matrix)(struct device *dev, struct iio_mount_matrix *matrix)",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kprobe:iio_read_mount_matrix": {
        "description": "Retrieve iio device mounting matrix from device 'mount-matrix' property. If device is assigned no mounting matrix property, a default 3x3 identity matrix will be filled in.",
        "proto" :"int (*iio_read_mount_matrix)(struct device *dev, struct iio_mount_matrix *matrix)",
        "pre": {
            "dev": "!=null",
            "matrix": "!=null"
        },
        "post": {
            "return": "in [0, negative error code]"
        }
    }
},
{
    "kretprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver. @parent:Parent device. @sizeof_priv:Space to allocate for private structure.",
        "proto" :"struct iio_dev *(*iio_device_alloc)(struct device *parent, int sizeof_priv)",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kprobe:iio_device_alloc": {
        "description": "Allocate an iio_dev from a driver. @parent:Parent device. @sizeof_priv:Space to allocate for private structure.",
        "proto" :"struct iio_dev *(*iio_device_alloc)(struct device *parent, int sizeof_priv)",
        "pre": {
            "parent": "!=null",
            "sizeof_priv": ">=0",
        },
    }
},
{
    "kretprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver",
        "proto": "void iio_device_free(struct iio_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:iio_device_free": {
        "description": "Free an iio_dev from a driver",
        "proto": "void (*iio_device_free)(struct iio_dev *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:__iio_device_register": {
        "description": "If the calling driver did not initialize firmware node, do it here",
        "proto" :"__iio_device_register(struct iio_dev  indio_dev, struct module  this_mod)",
        "pre": {
            "indio_dev": "!=null",
            "this_mod": "!=null",
            "indio_dev->info": "!=null"
        },
    }
},


{
    "kprobe:iio_read_channel_ext_info": {
        "description": "Provide a description here...",
        "proto" :"static ssize_t (*iio_read_channel_ext_info)(struct device *dev, struct device_attribute *attr, char *buf)",
        "pre": {
            "dev": "!=null",
            "attr": "!=null",
            "buf": "!=null"
        },
    }
},
{
    "kretprobe:iio_trigger_register": {
        "description": "Register a new IIO trigger and set the name used for the sysfs directory etc.",
        "proto" :"int iio_trigger_register(struct iio_trigger *trig_info)",
        "pre": {
            "trig_info": "!=null",
        },
        "post": {
            "trig_info->id": ">=0",
            "ret": "in [0, error code]"
        }
    }
},

{
    "kretprobe:iio_trigger_unregister": {
        "description": "Unregister the iio_trigger. This involves removing it from the iio_trigger_list, and freeing its id.",
        "proto" :"void iio_trigger_unregister(struct iio_trigger *trig_info)",
        "pre": {
            "trig_info": "!=null"
        },
        "post": {
            "trig_info->list": "not in iio_trigger_list",
            "trig_info->id": "freed"
        }
    }
},
{
    "kprobe:iio_trigger_unregister": {
        "description": "Unregister the iio_trigger. This involves locking the iio_trigger_list_lock, removing the trigger from the list, unlocking the list, and freeing the id associated with the trigger.",
        "proto" :"void iio_trigger_unregister(struct iio_trigger *trig_info)",
        "pre": {
            "trig_info": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers. This function should only be called from a hard IRQ context.",
        "proto" :"void (*iio_trigger_poll)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll": {
        "description": "Call the IRQ trigger handler of the consumers. This function should only be called from a hard IRQ context.",
        "proto" :"void (*iio_trigger_poll)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers. This function should only be called from a kernel thread context.",
        "proto" :"void (*iio_trigger_poll_nested)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kprobe:iio_trigger_poll_nested": {
        "description": "Call the threaded trigger handler of the consumers. This function should only be called from a kernel thread context.",
        "proto" :"static void (*iio_trigger_poll_nested)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        }
    }
},
{
    "kretprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger. If the trigger name format includes format specifiers, the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.",
        "proto" :"struct iio_trigger *(__iio_trigger_alloc)(struct device *parent, struct module *this_mod, const char *fmt, ...)",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:__iio_trigger_alloc": {
        "description": "Allocate a trigger. If the trigger name format includes format specifiers, the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.",
        "proto" :"struct iio_trigger *(__iio_trigger_alloc)(struct device *parent, struct module *this_mod, const char *fmt, ...)",
        "pre": {
            "parent": "!=null",
            "this_mod": "!=null",
            "fmt": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device. This function can be used as the validate_device callback for triggers that can only be attached to their own device.",
        "proto" :"int (*iio_trigger_validate_own_device)(struct iio_trigger *trig, struct iio_dev *indio_dev)",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
        "post": {
            "return": "in [0, -EINVAL]"
        }
    }
},
{
    "kprobe:iio_trigger_validate_own_device": {
        "description": "Check if a trigger and IIO device belong to the same device. This function can be used as the validate_device callback for triggers that can only be attached to their own device. Returns 0 if both the trigger and the IIO device belong to the same device, -EINVAL otherwise.",
        "proto" :"int (*iio_trigger_validate_own_device)(struct iio_trigger *trig, struct iio_dev *indio_dev)",
        "pre": {
            "trig": "!=null",
            "indio_dev": "!=null"
        },
    }
},
{
    "kretprobe:iio_triggered_event_setup": {
        "description": "iio_triggered_event_cleanup().",
        "proto" :"int iio_triggered_event_setup(struct iio_dev *indio_dev, irqreturn_t (*h)(int irq, void *p), irqreturn_t (*thread)(int irq, void *p))",
        "pre": {
            "indio_dev": "!=null",
            "h": "!=null",
            "thread": "!=null"
        }
    }
},
{
    "kprobe:iio_triggered_event_setup": {
        "description": "Sets up a triggered event for the given IIO device.",
        "proto" :"int iio_triggered_event_setup(struct iio_dev *indio_dev, irqreturn_t (*h)(int irq, void *p), irqreturn_t (*thread)(int irq, void *p))",
        "pre": {
            "indio_dev": "!=null",
            "h": "!=null",
            "thread": "!=null"
        },
    }
},
{
    "kretprobe:iio_triggered_buffer_setup_ext": {
        "description": "iio_triggered_buffer_cleanup().",
        "proto" :"int iio_triggered_buffer_setup_ext(struct iio_dev *indio_dev,irqreturn_t (*h)(int irq, void *p),irqreturn_t (*thread)(int irq, void *p),enum iio_buffer_direction direction,const struct iio_buffer_setup_ops *setup_ops,const struct iio_dev_attr **buffer_attrs)",
        "pre": {
            "indio_dev": "!=null",
            "h": "!=null",
            "thread": "!=null",
            "direction": "in [IIO_DEVICE_DIRECTION_IN, IIO_DEVICE_DIRECTION_OUT]",
            "setup_ops": "!=null",
            "buffer_attrs": "!=null"
        }
    }
},

{
    "kretprobe:qcom_vadc_map_voltage_temp": {
        "description": "This function maps voltage to temperature using the provided points. It interpolates linearly between points if the input is not exactly on a point.",
        "proto" :"static int qcom_vadc_map_voltage_temp(const struct vadc_map_pt *pts, u32 tablesize, s32 input, int *output)",
        "pre": {
            "pts": "!=null",
            "tablesize": ">0",
            "input": "is a valid input voltage",
            "output": "!=null"
        },
    }
},
{
    "kprobe:qcom_vadc_map_voltage_temp": {
        "description": "This function maps voltage to temperature using the provided table. It interpolates linearly between table entries.",
        "proto" :"static int (*qcom_vadc_map_voltage_temp)(const struct vadc_map_pt *pts, u32 tablesize, s32 input, int *output)",
        "pre": {
            "pts": "!=null",
            "tablesize": ">0",
            "input": "is integer",
            "output": "!=null"
        },
    }
},
{
    "kretprobe:is_stm32_lptim_trigger": {
        "description": "Return true if the trigger is a valid STM32 IIO Low-Power Timer Trigger, otherwise return false.",
        "proto" :"bool (*is_stm32_lptim_trigger)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:is_stm32_lptim_trigger": {
        "description": "Return true if the trigger is a valid STM32 IIO Low-Power Timer Trigger, otherwise return false.",
        "proto" :"bool (*is_stm32_lptim_trigger)(struct iio_trigger *trig)",
        "pre": {
            "trig": "!=null"
        }
    }
},


{
    "kretprobe:amba_driver_register": {
        "description": "Register an AMBA device driver with the Linux device model core. If devices pre-exist, the drivers probe function will be called.",
        "proto" :"int amba_driver_register(struct amba_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:amba_driver_register": {
        "description": "Register an AMBA device driver with the Linux device model core. If devices pre-exist, the drivers probe function will be called.",
        "proto" :"int amba_driver_register(struct amba_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver. The device model will call the drivers remove function for each device the driver is currently handling.",
        "proto" :"void (*amba_driver_unregister)(struct amba_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:amba_driver_unregister": {
        "description": "Remove an AMBA device driver. The device model will call the drivers remove function for each device the device driver is currently handling.",
        "proto" :"void (*amba_driver_unregister)(struct amba_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:amba_device_register": {
        "description": "Setup the AMBA device, reading the cell ID if present. Claim the resource, and register the AMBA device with the Linux device manager.",
        "proto" :"int amba_device_register(struct amba_device *dev, struct resource *parent)",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        }
    }
},
{
    "kprobe:amba_device_register": {
        "description": "Setup the AMBA device, reading the cell ID if present. Claim the resource, and register the AMBA device with the Linux device manager.",
        "proto" :"int (*amba_device_register)(struct amba_device *dev, struct resource *parent)",
        "pre": {
            "dev": "!=null",
            "parent": "!=null"
        },
    }
},
{
    "kretprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device. Remove the specified AMBA device from the Linux device manager. All files associated with this object will be destroyed, and device drivers notified that the device has been removed. The AMBA device's resources including the amba_device structure will be freed once all references to it have been dropped.",
        "proto" :"void (*amba_device_unregister)(struct amba_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_device_unregister": {
        "description": "Unregister an AMBA device. Remove the specified AMBA device from the Linux device manager. All files associated with this object will be destroyed, and device drivers notified that the device has been removed. The AMBA device's resources including the amba_device structure will be freed once all references to it have been dropped.",
        "proto" :"void (*amba_device_unregister)(struct amba_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:amba_request_regions": {
        "description": "Request all mem regions associated with device @dev: amba_device structure for device @name: name, or NULL to use driver name",
        "proto" :"int (*amba_request_regions)(struct amba_device *dev, const char *name)",
        "pre": {
            "dev": "!=null",
            "name": "!=null || ==driver_name",
        },
    }
},
{
    "kprobe:amba_request_regions": {
        "description": "Request all mem regions associated with device @dev: amba_device structure for device @name: name, or NULL to use driver name",
        "proto" :"int (*amba_request_regions)(struct amba_device *dev, const char *name)",
        "pre": {
            "dev": "!=null",
            "name": "!=null || ==null"
        },
    }
},
{
    "kretprobe:amba_release_regions": {
        "description": "Release mem regions associated with device @dev: amba_device structure for device. Release regions claimed by a successful call to amba_request_regions.",
        "proto" :"void (*amba_release_regions)(struct amba_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:amba_release_regions": {
        "description": "Release mem regions associated with device @dev: amba_device structure for device. Release regions claimed by a successful call to amba_request_regions.",
        "proto" :"void (*amba_release_regions)(struct amba_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:ntb_msi_init": {
        "description": "Initialize the MSI context. This function must be called before any other ntb_msi function. It initializes the context for MSI operations and maps the peer memory windows. This function reserves the last N outbound memory windows (where N is the number of peers).",
        "proto" :"int ntb_msi_init(struct ntb_dev *ntb, void (*desc_changed)(void *ctx))",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kprobe:ntb_msi_init": {
        "description": "Initialize the MSI context. This function must be called before any other ntb_msi function. It initializes the context for MSI operations and maps the peer memory windows. This function reserves the last N outbound memory windows (where N is the number of peers).",
        "proto" :"int ntb_msi_init(struct ntb_dev *ntb, void (*desc_changed)(void *ctx))",
        "pre": {
            "ntb": "!=null",
            "desc_changed": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kretprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows. This function sets up the required inbound memory windows. It should be called from a work function after a link up event. Over the entire network, this function will reserves the last N inbound memory windows for each peer (where N is the number of peers). ntb_msi_init() must be called before this function.",
        "proto" :"int (*ntb_msi_setup_mws)(struct ntb_dev *ntb)",
        "pre": {
            "ntb": "!=null"
        },
        "post": {
            "return": "in [0, negative numbers]"
        }
    }
},
{
    "kprobe:ntb_msi_setup_mws": {
        "description": "Initialize the MSI inbound memory windows. This function sets up the required inbound memory windows. It should be called from a work function after a link up event. Over the entire network, this function will reserves the last N inbound memory windows for each peer (where N is the number of peers). ntb_msi_init() must be called before this function.",
        "proto" :"int ntb_msi_setup_mws(struct ntb_dev *ntb)",
        "pre": {
            "ntb": "!=null"
        },
    }
},
{
    "kretprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows. This function tears down the resources used by ntb_msi_setup_mws().",
        "proto" :"void (*ntb_msi_clear_mws)(struct ntb_dev *ntb)",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kprobe:ntb_msi_clear_mws": {
        "description": "Clear all inbound memory windows. This function tears down the resources used by ntb_msi_setup_mws().",
        "proto" :"void (*ntb_msi_clear_mws)(struct ntb_dev *ntb)",
        "pre": {
            "ntb": "!=null"
        }
    }
},
{
    "kretprobe:ntbm_msi_request_threaded_irq": {
        "description": "This function assigns an interrupt handler to an unused MSI interrupt and returns the descriptor used to trigger it. The descriptor can then be sent to a peer to trigger the interrupt. The interrupt resource is managed with devres so it will be automatically freed when the NTB device is torn down. If an IRQ allocated with this function needs to be freed separately, ntbm_free_irq() must be used. Return: IRQ number assigned on success, otherwise a negative error number.",
        "proto" :"int ntbm_msi_request_threaded_irq(struct ntb_dev *ntb, irq_handler_t handler,  irq_handler_t thread_fn,  const char *name, void *dev_id,  struct ntb_msi_desc *msi_desc)",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "!=null || ==null",
            "name": "!=null || ==null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_request_threaded_irq": {
        "description": "This function assigns an interrupt handler to an unused MSI interrupt and returns the descriptor used to trigger it. The descriptor can then be sent to a peer to trigger the interrupt. The interrupt resource is managed with devres so it will be automatically freed when the NTB device is torn down. If an IRQ allocated with this function needs to be freed separately, ntbm_free_irq() must be used.",
        "proto" :"int (*ntbm_msi_request_threaded_irq)(struct ntb_dev *ntb, irq_handler_t handler,  irq_handler_t thread_fn,  const char *name, void *dev_id,  struct ntb_msi_desc *msi_desc)",
        "pre": {
            "ntb": "!=null",
            "handler": "!=null",
            "thread_fn": "can be null",
            "name": "can be null",
            "dev_id": "!=null",
            "msi_desc": "!=null"
        },
    }
},
{
    "kretprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt. This function should be used to manually free IRQs allocated with ntbm_request_[threaded_]irq().",
        "proto" :"void (*ntbm_msi_free_irq)(struct ntb_dev *ntb, unsigned int irq, void *dev_id)",
        "pre": {
            "ntb": "!=null",
            "irq": "is a valid interrupt line",
            "dev_id": "!=null"
        }
    }
},
{
    "kprobe:ntbm_msi_free_irq": {
        "description": "Free an interrupt. This function should be used to manually free IRQs allocated with ntbm_request_[threaded_]irq().",
        "proto" :"void (*ntbm_msi_free_irq)(struct ntb_dev *ntb, unsigned int irq, void *dev_id)",
        "pre": {
            "ntb": "!=null",
            "irq": "is a valid interrupt line number",
            "dev_id": "!=null"
        },
    }
},
{
    "kretprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer. It requires the descriptor structure to have been passed from that peer by some other means.",
        "proto" :"int ntb_msi_peer_trigger(struct ntb_dev *ntb, int peer, struct ntb_msi_desc *desc)",
        "pre": {
            "ntb": "!=null",
            "peer": ">=0",
            "desc": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kprobe:ntb_msi_peer_trigger": {
        "description": "Trigger an interrupt handler on a peer. This function requires the descriptor structure to have been passed from that peer by some other means.",
        "proto" :"int (*ntb_msi_peer_trigger)(struct ntb_dev *ntb, int peer, struct ntb_msi_desc *desc)",
        "pre": {
            "ntb": "!=null",
            "peer": "is integer",
            "desc": "!=null"
        },
    }
},
{
    "kretprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt. This function allows using DMA engines to trigger an interrupt (for example, trigger an interrupt to process the data after sending it). To trigger the interrupt, write @desc.data to the address returned in @msi_addr.",
        "proto" :"int ntb_msi_peer_addr(struct ntb_dev *ntb, int peer, struct ntb_msi_desc *desc, phys_addr_t *msi_addr)",
        "pre": {
            "ntb": "!=null",
            "peer": ">=0",
            "desc": "!=null",
            "msi_addr": "!=null"
        },
        "post": {
            "return": "in [0, negative number]"
        }
    }
},
{
    "kprobe:ntb_msi_peer_addr": {
        "description": "Get the DMA address to trigger a peer's MSI interrupt. This function allows using DMA engines to trigger an interrupt (for example, trigger an interrupt to process the data after sending it). To trigger the interrupt, write @desc.data to the address returned in @msi_addr.",
        "proto" :"int (*ntb_msi_peer_addr)(struct ntb_dev *ntb, int peer, struct ntb_msi_desc *desc, phys_addr_t *msi_addr)",
        "pre": {
            "ntb": "!=null",
            "peer": ">=0",
            "desc": "!=null",
            "msi_addr": "!=null"
        },
    }
},
{
    "kretprobe:tty_register_ldisc": {
        "description": "Installs a new line discipline into the kernel. The discipline is set up as unreferenced and then made available to the kernel from this point onwards.",
        "proto" :"int (*tty_register_ldisc)(struct tty_ldisc_ops *new_ldisc)",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_register_ldisc": {
        "description": "Installs a new line discipline into the kernel. The discipline is set up as unreferenced and then made available to the kernel from this point onwards.",
        "proto" :"int (*tty_register_ldisc)(struct tty_ldisc_ops *new_ldisc)",
        "pre": {
            "new_ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline. Remove a line discipline from the kernel providing it is not currently in use. Locking: takes %tty_ldiscs_lock to guard against ldisc races.",
        "proto" :"void (*tty_unregister_ldisc)(struct tty_ldisc_ops *ldisc)",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kprobe:tty_unregister_ldisc": {
        "description": "Unload a line discipline. Remove a line discipline from the kernel providing it is not currently in use. Locking: takes %tty_ldiscs_lock to guard against ldisc races.",
        "proto" :"void (*tty_unregister_ldisc)(struct tty_ldisc_ops *ldisc)",
        "pre": {
            "ldisc": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_init": {
        "description": "Initializes the state of struct tty_port. When a port was initialized using this function, one has to destroy the port by tty_port_destroy(). Either indirectly by using &tty_port refcounting (tty_port_put()) or directly if refcounting is not used.",
        "proto" :"void (*tty_port_init)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_init": {
        "description": "Initializes the state of struct tty_port. When a port was initialized using this function, one has to destroy the port by tty_port_destroy(). Either indirectly by using &tty_port refcounting (tty_port_put()) or directly if refcounting is not used.",
        "proto" :"void tty_port_init(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_alloc_xmit_buf": {
        "description": "We may sleep in get_zeroed_page()",
        "proto" :"static long (*tty_port_alloc_xmit_buf)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        },
        "post": {
            "port->buf_mutex": "locked",
            "port->xmit_buf": "==null"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Locks the mutex associated with the port's buffer.",
        "proto": "void mutex_lock(struct mutex *lock)",
        "pre": {
            "lock": "!=null"
        }
    },
    "kprobe:tty_port_alloc_xmit_buf": {
        "description": "Allocates a transmit buffer for the tty port. May sleep in get_zeroed_page().",
        "proto": "int tty_port_alloc_xmit_buf(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    },
    "kprobe:port_xmit_buf": {
        "description": "Checks if the port's transmit buffer is NULL.",
        "proto": "if (port->xmit_buf == NULL)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_tty_set": {
        "description": "Associate the port and tty pair. Manages any internal refcounts. Pass %NULL to deassociate a port.",
        "proto" :"void (*tty_port_tty_set)(struct tty_port *port, struct tty_struct *tty)",
        "pre": {
            "port": "!=null",
            "tty": "can be null"
        }
    }
},
{
    "kprobe:tty_port_tty_set": {
        "description": "Set the tty of a port. Associate the port and tty pair. Manages any internal refcounts. Pass %NULL to deassociate a port.",
        "proto" :"void (*tty_port_tty_set)(struct tty_port *port, struct tty_struct *tty)",
        "pre": {
            "port": "!=null",
            "tty": "can be null"
        },
    }
},
{
    "kretprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized. It lowers DTRRTS if @tty has HUPCL set and invokes @port->ops->shutdown().",
        "proto" :"static void tty_port_shutdown(struct tty_port *port, struct tty_struct *tty)",
        "pre": {
            "port": "!=null",
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_port_shutdown": {
        "description": "Shutdown the device if it was initialized (note consoles remain functioning). It lowers DTRRTS (if @tty has HUPCL set) and invokes @port->ops->shutdown().",
        "proto" :"static void (*tty_port_shutdown)(struct tty_port *port, struct tty_struct *tty)",
        "pre": {
            "port": "!=null",
            "tty": "!=null && tty->termios->c_cflag & HUPCL"
        }
    }
},
{
    "kretprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "proto" :"bool (*tty_port_carrier_raised)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_carrier_raised": {
        "description": "Wrapper for the carrier detect logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "proto" :"bool (*tty_port_carrier_raised)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_raise_dtr_rts": {
        "description": "Wrapper for the DTRRTS raise logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "proto" :"void (*tty_port_raise_dtr_rts)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_raise_dtr_rts": {
        "description": "Wrapper for the DTRRTS raise logic. For the moment this is used to hide some internal details. This will eventually become entirely internal to the tty port.",
        "proto" :"void (*tty_port_raise_dtr_rts)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference. Caller holds tty lock.",
        "proto" :"void tty_port_hangup(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_port_hangup": {
        "description": "Perform port level tty hangup flag and count changes. Drop the tty reference. Caller holds tty lock.",
        "proto" :"void tty_port_hangup(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_block_til_ready": {
        "description": "Implement the core POSIXSuS tty behaviour when opening a tty device. Handles hangup (both before and during), non blocking open, rtsdtrdcd, signals, port flags and counts. The passed @port must implement the @port->ops->carrier_raised method if it can do carrier detect and the @port->ops->dtr_rts method if it supports software management of these lines. Note that the dtrrts raise is done each iteration as a hangup may have previously dropped them while we wait. Caller holds tty lock. Note: May drop and reacquire tty lock when blocking, so @tty and @port may have changed state (eg., may have been hung up).",
        "proto" :"int tty_port_block_til_ready(struct tty_port *port,struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null || ==null"
        },
    }
},
{
    "kprobe:tty_port_block_til_ready": {
        "description": "Handles the core POSIXSuS tty behaviour when opening a tty device. It handles hangup (both before and during), non blocking open, rtsdtrdcd, signals, port flags and counts. The passed @port must implement the @port->ops->carrier_raised method if it can do carrier detect and the @port->ops->dtr_rts method if it supports software management of these lines.",
        "proto" :"int (*tty_port_block_til_ready)(struct tty_port *port, struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null && port->ops->carrier_raised !=null && port->ops->dtr_rts !=null",
            "tty": "!=null",
            "filp": "can be null"
        },
    }
},
{
    "kretprobe:tty_port_close_start": {
        "description": "Locking: Caller holds tty lock. Return: 1 if this is the last close, otherwise 0",
        "proto" :"int (*tty_port_close_start)(struct tty_port *port, struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:tty_port_close_start": {
        "description": "Locking: Caller holds tty lock. Return: 1 if this is the last close, otherwise 0",
        "proto" :"int (*tty_port_close_start)(struct tty_port *port, struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kretprobe:tty_port_open": {
        "description": "Generic tty->ops->open handler. It activates the devices using @port->ops->activate if not active already. And waits for the device to be ready using tty_port_block_til_ready() (e.g. raises DTRCTS and waits for carrier). Note that @port->ops->shutdown is not called when @port->ops->activate returns an error (on the contrary, @tty->ops->close is). Locking: Caller holds tty lock. Note: may drop and reacquire tty lock (in tty_port_block_til_ready()) so @tty and @port may have changed state (eg., may be hung up now).",
        "proto" :"int tty_port_open(struct tty_port *port, struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        }
    }
},
{
    "kprobe:tty_port_open": {
        "description": "Generic tty->ops->open handler. It activates the devices using @port->ops->activate if not active already. And waits for the device to be ready using tty_port_block_til_ready() (e.g. raises DTRCTS and waits for carrier).",
        "proto" :"int tty_port_open(struct tty_port *port, struct tty_struct *tty, struct file *filp)",
        "pre": {
            "port": "!=null",
            "tty": "!=null",
            "filp": "!=null"
        },
    }
},
{
    "kretprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes. If we try to write to, or set the state of, a terminal and we're not in the foreground, send a SIGTTOU. If the signal is blocked or ignored, go ahead and perform the operation. (POSIX 7.2)",
        "proto" :"int __tty_check_change(struct tty_struct *tty, int sig)",
        "pre": {
            "tty": "!=null",
            "sig": "in [SIGTTOU, SIGTTIN, SIGSTOP, SIGCONT, SIGCHLD, SIGWINCH, SIGURG, SIGIO, SIGINFO, SIGPWR, SIGSYS, SIGEMT, SIGSTKFLT, SIGUNUSED]"
        },
    }
},
{
    "kprobe:__tty_check_change": {
        "description": "Check for POSIX terminal changes. If we try to write to, or set the state of, a terminal and we're not in the foreground, send a SIGTTOU. If the signal is blocked or ignored, go ahead and perform the operation. (POSIX 7.2)",
        "proto" :"int (*__tty_check_change)(struct tty_struct *tty, int sig)",
        "pre": {
            "tty": "!=null",
            "sig": "in [SIGTTOU, SIGTTIN, SIGINT, SIGQUIT, SIGSTOP, SIGCONT, SIGCHLD, SIGWINCH, SIGIO, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGPOLL, SIGSYS, SIGTRAP, SIGBUS, SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGSTKFLT, SIGCLD, SIGPWR, SIGUNUSED]"
        },
    }
},
{
    "kretprobe:set_termios": {
        "description": "Set the termios structure.",
        "proto" :"static long (*set_termios)(struct termios *termios)",
        "pre": {
            "termios": "!=null",
            "termios->c_iflag": "in [ICRNL, IXON]",
            "termios->c_oflag": "in [OPOST, ONLCR]",
            "termios->c_cflag": "in [B38400, CS8, CREAD, HUPCL]",
            "termios->c_lflag": "in [ISIG, ICANON, ECHO, ECHOE, ECHOK, ECHOCTL, ECHOKE, IEXTEN]",
            "termios->c_cc": "=INIT_C_CC",
            "termios->c_ispeed": "=38400",
            "termios->c_ospeed": "=38400"
        },
    }
},

{
    "kretprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space. Locking: none",
        "proto" :"const char *(*tty_name)(const struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_name": {
        "description": "Convert a tty structure into a name. The name reflects the kernel naming policy and if udev is in use may not reflect user space. Locking: none",
        "proto" :"const char *(*tty_name)(const struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:__tty_hangup": {
        "description": "Actual handler for hangup events. This can be called by a 'kworker' kernel thread. That is process synchronous but doesn't hold any locks, so we need to make sure we have the appropriate locks for what we're doing. The hangup event clears any pending redirections onto the hung up device. It ensures future writes will error and it does the needed line discipline hangup and signal delivery. The tty object itself remains intact.",
        "proto": "static void (*__tty_hangup)(struct tty_struct *tty, int exit_session)",
        "pre": {
            "tty": "!=null",
            "exit_session": "in [0, 1]"
        }
    }
},
{
    "kprobe:__tty_hangup": {
        "description": "Actual handler for hangup events. This can be called by a 'kworker' kernel thread. That is process synchronous but doesn't hold any locks, so we need to make sure we have the appropriate locks for what we're doing. The hangup event clears any pending redirections onto the hung up device. It ensures future writes will error and it does the needed line discipline hangup and signal delivery. The tty object itself remains intact.",
        "proto": "static void (*__tty_hangup)(struct tty_struct *tty, int exit_session)",
        "pre": {
            "tty": "!=null",
            "exit_session": "is integer"
        }
    }
},
{
    "kretprobe:tty_vhangup": {
        "description": "The user has asked via system call for the terminal to be hung up. We do this synchronously so that when the syscall returns the process is complete. That guarantee is necessary for security reasons.",
        "proto" :"void tty_vhangup(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_vhangup": {
        "description": "The user has asked via system call for the terminal to be hung up. We do this synchronously so that when the syscall returns the process is complete. That guarantee is necessary for security reasons.",
        "proto" :"void (*tty_vhangup)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "proto" :"int (*tty_hung_up_p)(struct file *filp)",
        "pre": {
            "filp": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:tty_hung_up_p": {
        "description": "Check if the tty has been subject to a vhangup or a carrier loss.",
        "proto" :"int (*tty_hung_up_p)(struct file *filp)",
        "pre": {
            "filp": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kretprobe:stop_tty": {
        "description": "Propagate flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method. This functionality is used by both the line disciplines for halting incoming flow and by the driver. It may therefore be called from any context, may be under the tty %atomic_write_lock but not always. Locking: flow.lock",
        "proto" :"void stop_tty(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "!=true",
            "tty->ops->stop": "!=null"
        },
    }
},
{
    "kprobe:stop_tty": {
        "description": "Propagate flow control to the driver. May be called on an already stopped device and will not re-call the &tty_driver->stop() method. This functionality is used by both the line disciplines for halting incoming flow and by the driver. It may therefore be called from any context, may be under the tty %atomic_write_lock but not always.",
        "proto": "void stop_tty(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "is boolean",
            "tty->ops->stop": "is function or null"
        }
    }
},
{
    "kretprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible. If @tty was previously stopped and is now being started, the &tty_driver->start() method is invoked and the line discipline woken.",
        "proto" :"void (*start_tty)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "in [true, false]",
            "tty->flow.tco_stopped": "in [true, false]",
            "tty->ops->start": "can be null",
        },
    }
},
{
    "kprobe:start_tty": {
        "description": "Start a tty that has been stopped if at all possible. If @tty was previously stopped and is now being started, the &tty_driver->start() method is invoked and the line discipline woken.",
        "proto" :"void (*start_tty)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null",
            "tty->flow.stopped": "in [true, false]",
            "tty->flow.tco_stopped": "in [true, false]",
            "tty->ops->start": "can be null"
        },
    }
},
{
    "kretprobe:cons_filp": {
        "description": "The description of the function goes here",
        "proto" :"The function prototype goes here",
        "pre": {
            "cons_filp": "!=null"
        },
    }
},
{
    "kprobe:cons_filp": {
        "description": "Checks if the cons_filp pointer is not null and performs operations if it is not null.",
        "proto" :"static void (*cons_filp)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null",
            "cons_filp": "!=null"
        },
    }
},
{
    "kretprobe:tty_do_resize": {
        "description": "Update the termios variables and send the necessary signals to perform a terminal resize correctly.",
        "proto" :"int (*tty_do_resize)(struct tty_struct *tty, struct winsize *ws)",
        "pre": {
            "tty": "!=null",
            "ws": "!=null"
        }
    }
},
{
    "kprobe:tty_do_resize": {
        "description": "Update the termios variables and send the necessary signals to perform a terminal resize correctly.",
        "proto" :"int tty_do_resize(struct tty_struct *tty, struct winsize *ws)",
        "pre": {
            "tty": "!=null",
            "ws": "!=null"
        }
    }
},
{
    "kretprobe:do_SAK": {
        "description": "do_SAK() into process context. Less stack use in devfs functions. alloc_tty_struct() always uses kmalloc() -- Andrew Morton <andrewm@uow.edu.eu> 17Mar01",
        "proto" :"static long (*do_SAK)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:bpf_map_update_elem": {
        "description": "Add or update the value of the entry associated to *key* in *map* with *value*.",
        "proto" :"static long (*bpf_map_update_elem)(void *map, const void *key, const void *value, __u64 flags)",
        "pre": {
            "map": "!=null",
            "key": "!=null",
            "value": "!=null",
            "flags": "in [BPF_NOEXIST, BPF_EXIST, BPF_ANY]",
        },
    }
},
{
    "kretprobe:tty_register_device": {
        "description": "Register a tty device. This call is required to be made to register an individual tty device if the tty driver's flags have the %TTY_DRIVER_DYNAMIC_DEV bit set. If that bit is not set, this function should not be called by a tty driver.",
        "proto": "struct device *(*tty_register_device)(struct tty_driver *driver, unsigned index, struct device *device)",
        "pre": {
            "driver": "!=null",
            "index": "is a valid index in the tty driver",
            "device": "can be null or a valid struct device"
        },
        "post": {
            "return": "is a pointer to the struct device for this tty device or ERR_PTR(-EFOO) on error"
        }
    }
},
{
    "kprobe:tty_register_device": {
        "description": "Register a tty device. This call is required to be made to register an individual tty device if the tty driver's flags have the %TTY_DRIVER_DYNAMIC_DEV bit set. If that bit is not set, this function should not be called by a tty driver.",
        "proto" :"struct device *(*tty_register_device)(struct tty_driver *driver, unsigned index, struct device *device)",
        "pre": {
            "driver": "!=null",
            "index": "is a valid index in the tty driver",
            "device": "can be null or a valid struct device"
        },
        "post": {
            "return": "is a pointer to the struct device for this tty device or ERR_PTR(-EFOO) on error"
        }
    }
},
{
    "kretprobe:tty_unregister_device": {
        "description": "Unregister a tty device. This function must be called when the tty device is gone.",
        "proto": "void tty_unregister_device(struct tty_driver *driver, unsigned index)",
        "pre": {
            "driver": "!=null",
            "index": "is a valid index in the range of the tty driver"
        }
    }
},
{
    "kprobe:tty_unregister_device": {
        "description": "Unregister a tty device. This function must be called when the tty device is gone.",
        "proto" :"void tty_unregister_device(struct tty_driver *driver, unsigned index)",
        "pre": {
            "driver": "!=null",  // You may need to adjust this constraint
            "index": ">=0",  // You may need to adjust this constraint
        },
    }
},
{
    "kretprobe:__tty_alloc_driver": {
        "description": "__tty_alloc_driver -- allocate tty driver. @lines: count of lines this driver can handle at most. @owner: module which is responsible for this driver. @flags: some of %TTY_DRIVER_ flags, will be set in driver->flags. This should not be called directly, some of the provided macros should be used instead. Use IS_ERR() and friends on @retval.",
        "proto" :"struct tty_driver *(__tty_alloc_driver)(unsigned int lines, struct module *owner, unsigned long flags)",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [%TTY_DRIVER_REAL_RAW, %TTY_DRIVER_DYNAMIC_DEV, %TTY_DRIVER_HARDWARE_BREAK, %TTY_DRIVER_RESET_TERMIOS, %TTY_DRIVER_UNNUMBERED_NODE]"
        }
    }
},
{
    "kprobe:__tty_alloc_driver": {
        "description": "__tty_alloc_driver -- allocate tty driver. @lines: count of lines this driver can handle at most. @owner: module which is responsible for this driver. @flags: some of %TTY_DRIVER_ flags, will be set in driver->flags. This should not be called directly, some of the provided macros should be used instead. Use IS_ERR() and friends on @retval.",
        "proto" :"struct tty_driver *(*__tty_alloc_driver)(unsigned int lines, struct module *owner, unsigned long flags)",
        "pre": {
            "lines": ">=0",
            "owner": "!=null",
            "flags": "in [%TTY_DRIVER_REAL_RAW, %TTY_DRIVER_DYNAMIC_DEV, %TTY_DRIVER_UNNUMBERED_NODE]"
        },
    }
},
{
    "kretprobe:init_work": {
        "description": "Initialize a work item.",
        "proto" :"void (*init_work)(struct work_struct *work, work_func_t func)",
        "pre": {
            "work": "!=null",
            "func": "!=null"
        }
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here.",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your condition for arg1",
            "arg2": "Your condition for arg2",
            "arg3": "Your condition for arg3",
            "arg4": "Your condition for arg4",
        },
    }
},
{
    "kretprobe:tty_register_driver": {
        "description": "Called by a tty driver to register itself.",
        "proto" :"int tty_register_driver(struct tty_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_register_driver": {
        "description": "Called by a tty driver to register itself.",
        "proto" :"int (*tty_register_driver)(struct tty_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver. The final put will destroy and free up the driver.",
        "proto": "void tty_driver_kref_put(struct tty_driver *driver)",
        "pre": {
            "driver": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_kref_put": {
        "description": "Drop a reference to a tty driver. The final put will destroy and free up the driver.",
        "proto" :"void tty_driver_kref_put(struct tty_driver *driver)",
        "pre": {
            "driver": "!=null"
        },
    }
},


{
    "kretprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed. This should be called with the termios lock held if this termios is a terminal termios structure. Device drivers can call this function but should use ->c_[io]speed directly as they are updated.",
        "proto" :"speed_t (*tty_termios_baud_rate)(const struct ktermios *termios)",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_baud_rate": {
        "description": "Convert termios baud rate data into a speed. This should be called with the termios lock held if this termios is a terminal termios structure. Device drivers can call this function but should use ->c_[io]speed directly as they are updated. Locking: none",
        "proto" :"speed_t (*tty_termios_baud_rate)(const struct ktermios *termios)",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed. This should be called with the termios lock held if this termios is a terminal termios structure. Device drivers can call this function but should use ->c_[io]speed directly as they are updated. Locking: none",
        "proto" :"speed_t (*tty_termios_input_baud_rate)(const struct ktermios *termios)",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_input_baud_rate": {
        "description": "Convert termios baud rate data into a speed. This should be called with the termios lock held if this termios is a terminal termios structure. Device drivers can call this function but should use ->c_[io]speed directly as they are updated. Locking: none",
        "proto" :"speed_t (*tty_termios_input_baud_rate)(const struct ktermios *termios)",
        "pre": {
            "termios": "!=null"
        }
    }
},
{
    "kretprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue. If no private method is supplied there is assumed to be no queue on the device.",
        "proto" :"unsigned int (*tty_chars_in_buffer)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_chars_in_buffer": {
        "description": "Return the number of bytes of data in the device private output queue. If no private method is supplied there is assumed to be no queue on the device.",
        "proto" :"unsigned int (*tty_chars_in_buffer)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        },
    }
},
{
    "kretprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time. The result should be treated as a guarantee and the driver cannot offer a value it later shrinks by more than the number of bytes written. If no method is provided 2K is always returned and data may be lost as there will be no flow control.",
        "proto" :"unsigned int (*tty_write_room)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:tty_write_room": {
        "description": "Return the number of bytes that can be queued to this device at the present time. The result should be treated as a guarantee and the driver cannot offer a value it later shrinks by more than the number of bytes written. If no method is provided 2K is always returned and data may be lost as there will be no flow control.",
        "proto" :"unsigned int (*tty_write_room)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device. If no method is provided then either the buffer cannot be hardware flushed or there is no buffer driver side.",
        "proto" :"void (*tty_driver_flush_buffer)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_driver_flush_buffer": {
        "description": "Discard the internal output buffer for this device. If no method is provided then either the buffer cannot be hardware flushed or there is no buffer driver side.",
        "proto" :"void (*tty_driver_flush_buffer)(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack. Takes the termios rwsem to protect against parallel throttleunthrottle and also to ensure the driver can consistently reference its own termios data at this point when implementing software flow control. Drivers should however remember that the stack can issue a throttle, then change flow control method, then unthrottle.",
        "proto" :"void tty_unthrottle(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kprobe:tty_unthrottle": {
        "description": "Indicate that a tty may continue transmitting data down the stack. Takes the termios rwsem to protect against parallel throttleunthrottle and also to ensure the driver can consistently reference its own termios data at this point when implementing software flow control. Drivers should however remember that the stack can issue a throttle, then change flow control method, then unthrottle.",
        "proto" :"void tty_unthrottle(struct tty_struct *tty)",
        "pre": {
            "tty": "!=null"
        }
    }
},
{
    "kretprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "proto" :"void (*tty_wait_until_sent)(struct tty_struct *tty, long timeout)",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0"
        }
    }
},
{
    "kprobe:tty_wait_until_sent": {
        "description": "Wait for characters pending in a tty driver to hit the wire, or for a timeout to occur (eg due to flow control).",
        "proto" :"void (*tty_wait_until_sent)(struct tty_struct *tty, long timeout)",
        "pre": {
            "tty": "!=null",
            "timeout": ">=0",
        },
    }
},
{
    "kretprobe:tty_termios_copy_hw": {
        "description": "Propagate the hardware specific terminal setting bits from the old termios structure to the new one. This is used in cases where the hardware does not support reconfiguration or as a helper in some cases where only minimal reconfiguration is supported.",
        "proto" :"void tty_termios_copy_hw(struct ktermios *new, const struct ktermios *old)",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kprobe:tty_termios_copy_hw": {
        "description": "Propagate the hardware specific terminal setting bits from the old termios structure to the new one. This is used in cases where the hardware does not support reconfiguration or as a helper in some cases where only minimal reconfiguration is supported.",
        "proto" :"void (*tty_termios_copy_hw)(struct ktermios *new, const struct ktermios *old)",
        "pre": {
            "new": "!=null",
            "old": "!=null"
        }
    }
},
{
    "kretprobe:tty_termios_hw_change": {
        "description": "Check if any of the bits that affect a dumb device have changed between the two termios structures, or a speed change is needed.",
        "proto" :"bool tty_termios_hw_change(const struct ktermios *a, const struct ktermios *b)",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:tty_termios_hw_change": {
        "description": "Check if any of the bits that affect a dumb device have changed between the two termios structures, or a speed change is needed.",
        "proto" :"bool tty_termios_hw_change(const struct ktermios *a, const struct ktermios *b)",
        "pre": {
            "a": "!=null",
            "b": "!=null"
        }
    }
},
{
    "kretprobe:n_tty_ioctl_helper": {
        "description": "Handle different cases based on the `cmd` and `arg` parameters.",
        "proto" :"int n_tty_ioctl_helper(struct tty_struct *tty, unsigned int cmd, unsigned long arg)",
        "pre": {
            "tty": "!=null",
            "cmd": "in [TCXONC, TCFLSH, ...]", // Replace ... with other possible cmd values
            "arg": "in [TCOOFF, TCOON, TCIOFF, TCION, ...]" // Replace ... with other possible arg values
        }
    }
},
{
    "kprobe:n_tty_ioctl_helper": {
        "description": "Handle different ioctl commands for a tty device.",
        "proto": "int (*n_tty_ioctl_helper)(struct tty_struct *tty, unsigned int cmd, unsigned long arg)",
        "pre": {
            "tty": "!=null",
            "cmd": "in [TCXONC, TCFLSH, ...]",
            "arg": "in [TCOOFF, TCOON, TCIOFF, TCION, ...]"
        }
    }
},
{
    "kretprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Queue a series of bytes to the tty buffering. All the characters passed are marked with the supplied flag. Returns: the number added.",
        "proto" :"int (*tty_insert_flip_string_fixed_flag)(struct tty_port *port, const unsigned char *chars, char flag, size_t size)",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "is char",
            "size": ">=0"
        },
    }
},
{
    "kprobe:tty_insert_flip_string_fixed_flag": {
        "description": "Queue a series of bytes to the tty buffering. All the characters passed are marked with the supplied flag.",
        "proto" :"int (*tty_insert_flip_string_fixed_flag)(struct tty_port *port, const unsigned char *chars, char flag, size_t size)",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flag": "is a valid flag",
            "size": ">=0",
        },
    }
},
{
    "kretprobe:tty_insert_flip_string_flags": {
        "description": "Queue a series of bytes to the tty buffering. For each character the flags array indicates the status of the character.",
        "proto" :"int (*tty_insert_flip_string_flags)(struct tty_port *port, const unsigned char *chars, const char *flags, size_t size)",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kprobe:tty_insert_flip_string_flags": {
        "description": "Queue a series of bytes to the tty buffering. For each character the flags array indicates the status of the character.",
        "proto" :"int (*tty_insert_flip_string_flags)(struct tty_port *port, const unsigned char *chars, const char *flags, size_t size)",
        "pre": {
            "port": "!=null",
            "chars": "!=null",
            "flags": "!=null",
            "size": ">=0"
        },
    }
},
{
    "kretprobe:__tty_insert_flip_char": {
        "description": "Queue a single byte @ch to the tty buffering, with an optional flag. This is the slow path of tty_insert_flip_char().",
        "proto" :"int __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag)",
        "pre": {
            "port": "!=null",
            "ch": "is a single byte",
            "flag": "is a single byte"
        },
    }
},
{
    "kprobe:__tty_insert_flip_char": {
        "description": "Queue a single byte @ch to the tty buffering, with an optional flag. This is the slow path of tty_insert_flip_char().",
        "proto" :"int (*__tty_insert_flip_char)(struct tty_port *port, unsigned char ch, char flag)",
        "pre": {
            "port": "!=null",
            "ch": "is unsigned char",
            "flag": "is char",
        },
    }
},
{
    "kretprobe:tty_flip_buffer_push": {
        "description": "Queue a push of the terminal flip buffers to the line discipline. Can be called from IRQatomic context. In the event of the queue being busy for flipping the work will be held off and retried later.",
        "proto" :"void (*tty_flip_buffer_push)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:tty_flip_buffer_push": {
        "description": "Queue a push of the terminal flip buffers to the line discipline. Can be called from IRQatomic context. In the event of the queue being busy for flipping the work will be held off and retried later.",
        "proto" :"void (*tty_flip_buffer_push)(struct tty_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kretprobe:handle_sysrq": {
        "description": "Handle the sysrq key operation. Raise the apparent loglevel to maximum so that the sysrq header is shown to provide the user with positive feedback. We do not simply emit this at KERN_EMERG as that would change message routing in the consumers of prockmsg.",
        "proto" :"void handle_sysrq(int key, bool check_mask)",
        "pre": {
            "key": "is integer",
            "check_mask": "is boolean"
        },
    }
},
{
    "kprobe:handle_sysrq": {
        "description": "Handles a sysrq key press.",
        "proto" :"void handle_sysrq(int key, bool check_mask)",
        "pre": {
            "key": "is integer",
            "check_mask": "is boolean",
        },
    }
},


{
    "kretprobe:redraw_screen": {
        "description": "Redraws the screen based on the provided vc_data and switch condition.",
        "proto" :"static long (*redraw_screen)(struct vc_data *vc, int is_switch)",
        "pre": {
            "vc": "!=null",
            "is_switch": "in [0, 1]",
        },
    }
},
{
    "kprobe:redraw_screen": {
        "description": "Provide a brief description of the function here.",
        "proto" :"redraw_screen(struct vc_data  vc, int is_switch)",
        "pre": {
            "vc": "Provide the constraints for vc here",
            "is_switch": "Provide the constraints for is_switch here"
        },
    }
},
{
    "kretprobe:resize_screen": {
        "description": "This function is being called here to cover the case where the userspace calls the FBIOPUT_VSCREENINFO twice, passing the same fb_var_screeninfo containing the fields yresxres equal to a number non-multiple of vc_font.height and yres_virtualxres_virtual equal to number lesser than the vc_font.height and yresxres. In the second call, the struct fb_var_screeninfo isn't being modified by the underlying driver because of the if above, and this causes the fbcon_display->vrows to become negative and it eventually leads to out-of-bound access by the imageblit function. To give the correct values to the struct and to not have to deal with possible errors from the code below, we call the resize_screen here as well.",
        "proto" :"static long (*resize_screen)(vc, new_cols, new_rows, user)",
        "pre": {
            "vc": "!=null",
            "new_cols": "<=VC_MAXCOL",
            "new_rows": "<=VC_MAXROW",
            "user": "!=null"
        },
        "post": {
            "return": "in [-EINVAL, -ENOMEM, 0]"
        }
    }
},

{
    "kretprobe:con_is_bound": {
        "description": "Checks if the console switch is bound. If not, it initializes the console driver flag. If the console driver map matches the console switch, it releases the module and sets the map to NULL. If the default console switch is not bound, it starts up the default console switch, sets the console back flag to CON_DRIVER_FLAG_INIT, and restores the default driver if vgacon changes it to dummycon.",
        "proto" :"static int (*con_is_bound)(struct consw *csw)",
        "pre": {
            "csw": "!=null"
        },
    }
},
{
    "kprobe:conswitchp = defconsw;}if (!con_is_bound(csw))con_driver->flag &= ~CON_DRIVER_FLAG_INIT;/* ignore return value, binding should not fail": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "param1": "Your condition here",
            "param2": "Your condition here",
            "param3": "Your condition here",
            "param4": "Your condition here",
        },
    }
},


{
    "kretprobe:give_up_console": {
        "description": "give_up_console is a wrapper to unregister_con_driver. It will only work if driver is fully unbound.",
        "proto" :"void (*give_up_console)(const struct consw *csw)",
        "pre": {
            "csw": "!=null"
        }
    }
},
{
    "kprobe:give_up_console": {
        "description": "give_up_console is a wrapper to unregister_con_driver. It will only work if driver is fully unbound.",
        "proto" :"void (*give_up_console)(const struct consw *csw)",
        "pre": {
            "csw": "!=null"
        }
    }
},


{
    "kretprobe:do_unblank_screen": {
        "description": "This should now always be called from a 'sane' (read: can schedule) context for the sake of the low level drivers, except in the special case of oops_in_progress",
        "proto" :"static long (*do_unblank_screen)(int leaving_gfx, struct vc_data *vc)",
        "pre": {
            "leaving_gfx": "is an integer",
            "vc": "!=null",
        },
    }
},
{
    "kprobe:do_unblank_screen": {
        "description": "This should now always be called from a 'sane' (read: can schedule) context for the sake of the low level drivers, except in the special case of oops_in_progress",
        "proto" :"static void (*do_unblank_screen)(int leaving_gfx)",
        "pre": {
            "leaving_gfx": "is an integer"
        },
    }
},
{
    "kretprobe:con_set_default_unimap": {
        "description": "Set default unicode map @vc: the console we are updating. Loads the unimap for the hardware font, as defined in uni_hash.tbl. The representation used was the most compact I could come up with. This routine is executed at video setup, and when the PIO_FONTRESET ioctl is called. The caller must hold the console lock.",
        "proto" :"int (*con_set_default_unimap)(struct vc_data *vc)",
        "pre": {
            "vc": "!=null"
        }
    }
},
{
    "kprobe:con_set_default_unimap": {
        "description": "Set default unicode map @vc: the console we are updating. Loads the unimap for the hardware font, as defined in uni_hash.tbl. The representation used was the most compact I could come up with. This routine is executed at video setup, and when the PIO_FONTRESET ioctl is called. The caller must hold the console lock.",
        "proto" :"int (*con_set_default_unimap)(struct vc_data *vc)",
        "pre": {
            "vc": "!=null"
        }
    }
},
{
    "kretprobe:con_copy_unimap": {
        "description": "Copy unimap between two vts @dst_vc: target @src_vc: source. The caller must hold the console lock when invoking this method.",
        "proto" :"int (*con_copy_unimap)(struct vc_data *dst_vc, struct vc_data *src_vc)",
        "pre": {
            "dst_vc": "!=null",
            "src_vc": "!=null"
        },
    }
},
{
    "kprobe:con_copy_unimap": {
        "description": "Copy unimap between two vts @dst_vc: target @src_vc: source. The caller must hold the console lock when invoking this method.",
        "proto" :"int (*con_copy_unimap)(struct vc_data *dst_vc, struct vc_data *src_vc)",
        "pre": {
            "dst_vc": "!=null",
            "src_vc": "!=null",
            "console lock": "held by caller"
        },
    }
},

{
    "kprobe:sunserial_register_minors": {
        "description": "Register the driver on the first call",
        "proto" :"sunserial_register_minors(struct uart_driver *drv, int count)",
        "pre": {
            "drv": "!=null",
            "count": ">=0",
            "drv->nr": ">=0"
        },
    }
},
{
    "kretprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate of a SunCore mouse. If a break signal is detected and less than 8 normal signals have been received, the function will return 1 to indicate that another baud rate should be tried.",
        "proto" :"static int suncore_mouse_baud_detection(unsigned char ch, int is_break)",
        "pre": {
            "ch": "is an unsigned char",
            "is_break": "is an integer"
        },
        "post": {
            "return": "if (mouse_got_break && ctr < 8) return 1; else return 0;"
        }
    }
},
{
    "kprobe:suncore_mouse_baud_detection": {
        "description": "Detects the baud rate of a SunCore mouse. If a break signal is detected and less than 8 normal bytes have been processed, the function will return 1 to indicate that another baud rate should be tried.",
        "proto" :"static int suncore_mouse_baud_detection(unsigned char ch, int is_break)",
        "pre": {
            "ch": "is an unsigned char",
            "is_break": "is an integer"
        },
        "post": {
            "return": "if (mouse_got_break && ctr < 8) return 1"
        }
    }
},
{
    "kretprobe:uart_write_wakeup": {
        "description": "This routine is used by the interrupt handler to schedule processing in the software interrupt portion of the driver. A driver is expected to call this function when the number of characters in the transmit buffer have dropped below a threshold. Locking: @port->lock should be held",
        "proto" :"void (*uart_write_wakeup)(struct uart_port *port)",
        "pre": {
            "port": "!=null"
        }
    }
},
{
    "kprobe:uart_write_wakeup": {
        "description": "This routine is used by the interrupt handler to schedule processing in the software interrupt portion of the driver. A driver is expected to call this function when the number of characters in the transmit buffer have dropped below a threshold. Locking: @port->lock should be held",
        "proto" :"void uart_write_wakeup(struct uart_port *port)",
        "pre": {
            "port": "!=null",
            // Add other conditions here based on your understanding of the function
        },
    }
},
{
    "kretprobe:uart_update_timeout": {
        "description": "Set the @port frame timing information from which the FIFO timeout value is derived. The @cflag value should reflect the actual hardware settings as number of bits, parity, stop bits and baud rate is taken into account here.",
        "proto" :"void (*uart_update_timeout)(struct uart_port *port, unsigned int cflag, unsigned int baud)",
        "pre": {
            "port": "!=null",
            "cflag": "is a valid termios cflag value",
            "baud": "is a valid baud rate"
        },
    }
},
{
    "kprobe:uart_update_timeout": {
        "description": "Set the @port frame timing information from which the FIFO timeout value is derived. The @cflag value should reflect the actual hardware settings as number of bits, parity, stop bits and baud rate is taken into account here.",
        "proto" :"void (*uart_update_timeout)(struct uart_port *port, unsigned int cflag, unsigned int baud)",
        "pre": {
            "port": "!=null",
            "cflag": "is a valid termios cflag value",
            "baud": "is a valid baud rate"
        },
    }
},
{
    "kretprobe:uart_get_baud_rate": {
        "description": "Return baud rate for a particular port. Decode the termios structure into a numeric baud rate, taking account of the magic 38400 baud rate (with spd_ flags), and mapping the %B0 rate to 9600 baud. If the new baud rate is invalid, try the @old termios setting. If it's still invalid, we try 9600 baud. The @termios structure is updated to reflect the baud rate we're actually going to be using. Don't do this for the case where B0 is requested ('hang up').",
        "proto" :"unsigned int (*uart_get_baud_rate)(struct uart_port *port, struct ktermios *termios, const struct ktermios *old, unsigned int min, unsigned int max)",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null || ==null",
            "min": ">=0",
            "max": ">=min"
        },
    }
},
{
    "kprobe:uart_get_baud_rate": {
        "description": "Decode the termios structure into a numeric baud rate, taking account of the magic 38400 baud rate (with spd_ flags), and mapping the %B0 rate to 9600 baud. If the new baud rate is invalid, try the @old termios setting. If it's still invalid, we try 9600 baud. The @termios structure is updated to reflect the baud rate we're actually going to be using. Don't do this for the case where B0 is requested ('hang up').",
        "proto" :"unsigned int (*uart_get_baud_rate)(struct uart_port *port, struct ktermios *termios, const struct ktermios *old, unsigned int min, unsigned int max)",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "can be null",
            "min": "is a positive integer",
            "max": "is a positive integer and >= min",
        },
    }
},
{
    "kretprobe:uart_get_divisor": {
        "description": "Calculate the divisor (baud_base / baud) for the specified baud, appropriately rounded. If 38400 baud and custom divisor is selected, return the custom divisor instead.",
        "proto" :"unsigned int (*uart_get_divisor)(struct uart_port *port, unsigned int baud)",
        "pre": {
            "port": "!=null",
            "baud": ">=0"
        }
    }
},
{
    "kprobe:uart_get_divisor": {
        "description": "Calculate the divisor (baud_base  baud) for the specified @baud, appropriately rounded. If 38400 baud and custom divisor is selected, return the custom divisor instead.",
        "proto" :"unsigned int (*uart_get_divisor)(struct uart_port *port, unsigned int baud)",
        "pre": {
            "port": "!=null",
            "baud": ">=0"
        }
    }
},
{
    "kretprobe:uart_suspend_port": {
        "description": "This function suspends a UART port. If the console is not suspending, it does nothing except stop_rx to prevent any asynchronous data over RX line. However, it ensures that we will be able to Re-start_rx later.",
        "proto" :"static int (*uart_suspend_port)(struct uart_driver *drv, struct uart_port *uport)",
        "pre": {
            "drv": "!=null",
            "uport": "!=null",
            "drv->state": "!=null",
            "uport->line": ">=0",
            "port": "!=null",
            "port->mutex": "!=null",
            "uport->dev": "!=null",
            "uport->irq": ">=0"
        },
    }
},
{
    "kprobe:uart_suspend_port": {
        "description": "Suspend the UART port. If the console is not suspending, stop_rx to prevent any asynchronous data over RX line. Ensure that we will be able to Re-start_rx later.",
        "proto" :"static int (*uart_suspend_port)(struct uart_driver *drv, struct uart_port *uport)",
        "pre": {
            "drv": "!=null",
            "uport": "!=null",
            "drv->state": "!=null",
            "uport->line": "is valid line number",
            "uport->dev": "!=null",
            "uport->irq": "is valid irq number",
            "port->mutex": "is not locked"
        },
    }
},
{
    "kretprobe:uart_resume_port": {
        "description": "Re-enable the console device after suspending.",
        "proto" :"uart_resume_port(struct uart_driver  drv, struct uart_port  uport)",
        "pre": {
            "drv": "your_condition_here",
            "uport": "your_condition_here"
        },
    }
},
{
    "kprobe:uart_console": {
        "description": "Check if the uart_port is a console.",
        "proto" :"int (*uart_console)(struct uart_port *uport)",
        "pre": {
            "uport": "!=null"
        }
    }
},
{
    "kretprobe:uart_register_driver": {
        "description": "Register a uart driver with the core driver. We in turn register with the tty layer, and initialise the core driver per-port state. We have a proc file in procttydriver which is named after the normal driver. drv->port should be %NULL, and the per-port structures should be registered using uart_add_one_port() after this call has succeeded.",
        "proto" :"int (*uart_register_driver)(struct uart_driver *drv)",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        },
        "post": {
            "drv->port": "registered using uart_add_one_port()"
        }
    }
},
{
    "kprobe:uart_register_driver": {
        "description": "Register a uart driver with the core driver. We in turn register with the tty layer, and initialise the core driver per-port state. We have a proc file in procttydriver which is named after the normal driver. @drv->port should be %NULL, and the per-port structures should be registered using uart_add_one_port() after this call has succeeded.",
        "proto" :"int (*uart_register_driver)(struct uart_driver *drv)",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        },
        "post": {
            "drv": "registered with uart_add_one_port()"
        }
    }
},
{
    "kretprobe:uart_unregister_driver": {
        "description": "Remove a driver from the uart core layer. The low level driver must have removed all its ports via the uart_remove_one_port() if it registered them with uart_add_one_port(). (I.e. drv->port is %NULL.)",
        "proto" :"void (*uart_unregister_driver)(struct uart_driver *drv)",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        },
    }
},
{
    "kprobe:uart_unregister_driver": {
        "description": "Remove all references to a driver from the core driver. The low level driver must have removed all its ports via the uart_remove_one_port() if it registered them with uart_add_one_port(). (I.e. @drv->port is %NULL.)",
        "proto" :"void (*uart_unregister_driver)(struct uart_driver *drv)",
        "pre": {
            "drv": "!=null",
            "drv->port": "==null"
        }
    }
},
{
    "kretprobe:uart_match_port": {
        "description": "This utility function can be used to determine whether two uart_port structures describe the same port.",
        "proto" :"bool (*uart_match_port)(const struct uart_port *port1, const struct uart_port *port2)",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:uart_match_port": {
        "description": "This utility function can be used to determine whether two uart_port structures describe the same port.",
        "proto" :"bool (*uart_match_port)(const struct uart_port *port1, const struct uart_port *port2)",
        "pre": {
            "port1": "!=null",
            "port2": "!=null"
        },
    }
},
{
    "kretprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "proto" :"void (*serial8250_suspend_port)(int line)",
        "pre": {
            "line": ">=0"
        }
    }
},
{
    "kprobe:serial8250_suspend_port": {
        "description": "Suspend one serial port.",
        "proto" :"void (*serial8250_suspend_port)(int line)",
        "pre": {
            "line": ">=0",
        },
    }
},
{
    "kretprobe:serial8250_resume_port": {
        "description": "Resume one serial port.",
        "proto" :"void (*serial8250_resume_port)(int line)",
        "pre": {
            "line": ">=0"
        }
    }
},
{
    "kprobe:serial8250_resume_port": {
        "description": "Resume one serial port",
        "proto": "void (*serial8250_resume_port)(int line)",
        "pre": {
            "line": ">=0"
        }
    }
},

{
    "kprobe:serial8250_register_8250_port": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "param1": "Constraint for param1",
            "param2": "Constraint for param2",
            "param3": "Constraint for param3",
            "param4": "Constraint for param4",
        },
    }
},

{
    "kprobe:serial8250_register_8250_port": {
        "description": "This function allows for 16x50 serial ports to be configured at run-time, to support PCMCIA modems and PCI multiport cards.",
        "proto" :"static struct platform_device *serial8250_isa_devs;",
        "pre": {
            // Constraints for the function parameters should be here
        },
    },
    "kprobe:serial8250_unregister_port": {
        "description": "This function allows for 16x50 serial ports to be unregistered.",
        "proto" :"static struct platform_device *serial8250_isa_devs;",
        "pre": {
            // Constraints for the function parameters should be here
        },
    }
},
{
    "kretprobe:serial8250_do_set_termios": {
        "description": "Set termios for the serial8250 port. This function computes the LCR, gets the baud rate, and gets the divisor with interrupts disabled.",
        "proto" :"void serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios, const struct ktermios *old)",
        "pre": {
            "port": "!=null",
            "termios": "!=null",
            "old": "!=null"
        },
        "post": {
            "port->lock": "locked",
            "up->lcr": "!=null"
        }
    }
},
{
    "kprobe:serial8250_do_set_termios": {
        "description": "Your function description here",
        "proto" :"static long (*serial8250_do_set_termios)(struct uart_port *port, struct ktermios *termios, const struct ktermios *old)",
        "pre": {
            "port": "Your condition here",
            "termios": "Your condition here",
            "old": "Your condition here"
        },
    }
},
{
    "kretprobe:convert_ifc_address": {
        "description": "Convert the base address of the memory bank.",
        "proto" :"unsigned int (*convert_ifc_address)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kprobe:convert_ifc_address": {
        "description": "Convert the base address of the memory bank.",
        "proto" :"unsigned int (*convert_ifc_address)(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kretprobe:fsl_ifc_find": {
        "description": "This function walks IFC banks comparing 'Base address' field of the CSPR registers with the supplied addr_base argument. When bases match this function returns bank number (starting with 0), otherwise it returns appropriate errno value.",
        "proto" :"int fsl_ifc_find(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "!=null"
        }
    }
},
{
    "kprobe:fsl_ifc_find": {
        "description": "This function walks IFC banks comparing 'Base address' field of the CSPR registers with the supplied addr_base argument. When bases match this function returns bank number (starting with 0), otherwise it returns appropriate errno value.",
        "proto" :"int fsl_ifc_find(phys_addr_t addr_base)",
        "pre": {
            "addr_base": "any"
        }
    }
},
{
    "kretprobe:of_get_min_tck": {
        "description": "Populates the lpddr2_min_tck structure by extracting data from device tree node. Returns a pointer to the populated structure. If any error in populating the structure, returns default min timings provided by JEDEC.",
        "proto" :"const struct lpddr2_min_tck *(*of_get_min_tck)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:of_get_min_tck": {
        "description": "Populates the lpddr2_min_tck structure by extracting data from device tree node. Returns a pointer to the populated structure. If any error in populating the structure, returns default min timings provided by JEDEC.",
        "proto" :"const struct lpddr2_min_tck *(*of_get_min_tck)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:of_get_ddr_timings": {
        "description": "Populates lpddr2_timings structure by extracting data from device tree node. Returns pointer to populated structure. If any error while populating, returns default timings provided by JEDEC.",
        "proto" :"const struct lpddr2_timings *(*of_get_ddr_timings)(struct device_node *np_ddr, struct device *dev, u32 device_type, u32 *nr_frequencies)",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "in [LPDDR2_S2, LPDDR2_S4]",
            "nr_frequencies": "!=null"
        },
    }
},
{
    "kprobe:of_get_ddr_timings": {
        "description": "Extracts the ddr timings and updates no of frequencies available. Populates lpddr2_timings structure by extracting data from device tree node. Returns pointer to populated structure. If any error while populating, returns default timings provided by JEDEC.",
        "proto" :"const struct lpddr2_timings *(*of_get_ddr_timings)(struct device_node *np_ddr, struct device *dev, u32 device_type, u32 *nr_frequencies)",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "in [LPDDR2 S2, LPDDR2 S4]",
            "nr_frequencies": "!=null",
        },
    }
},
{
    "kretprobe:of_lpddr3_get_min_tck": {
        "description": "Populates the lpddr3_min_tck structure by extracting data from device tree node. Returns a pointer to the populated structure. If any error in populating the structure, returns NULL.",
        "proto" :"const struct lpddr3_min_tck *(*of_lpddr3_get_min_tck)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_min_tck": {
        "description": "Populates the lpddr3_min_tck structure by extracting data from device tree node. Returns a pointer to the populated structure. If any error in populating the structure, returns NULL.",
        "proto" :"const struct lpddr3_min_tck *(*of_lpddr3_get_min_tck)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:of_lpddr3_get_ddr_timings": {
        "description": "Populates lpddr3_timings structure by extracting data from device tree node. Returns pointer to populated structure. If any error while populating, returns NULL.",
        "proto" :"const struct lpddr3_timings* (*of_lpddr3_get_ddr_timings)(struct device_node *np_ddr, struct device *dev, u32 device_type, u32 *nr_frequencies)",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "in [DDR_TYPE_LPDDR3, DDR_TYPE_LPDDR4, DDR_TYPE_DDR3, DDR_TYPE_DDR4]",
            "nr_frequencies": "!=null"
        }
    }
},
{
    "kprobe:of_lpddr3_get_ddr_timings": {
        "description": "Extracts the lpddr3 timings and updates no of frequencies available. Populates lpddr3_timings structure by extracting data from device tree node. Returns pointer to populated structure. If any error while populating, returns NULL.",
        "proto" :"const struct lpddr3_timings* (*of_lpddr3_get_ddr_timings)(struct device_node *np_ddr, struct device *dev, u32 device_type, u32 *nr_frequencies)",
        "pre": {
            "np_ddr": "!=null",
            "dev": "!=null",
            "device_type": "is a valid ddr type",
            "nr_frequencies": "!=null",
        },
    }
},
{
    "kretprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip. Populates lpddr2_info structure by extracting data from device tree node. Returns pointer to populated structure. If error happened while populating, returns NULL. If property is missing in a device-tree, then the corresponding value is set to -ENOENT.",
        "proto" :"const struct lpddr2_info* (*of_lpddr2_get_info)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        },
        "post": {
            "return": "!=null || ==null",
            "missing_property": "== -ENOENT"
        }
    }
},
{
    "kprobe:of_lpddr2_get_info": {
        "description": "Extracts information about the lpddr2 chip. Populates lpddr2_info structure by extracting data from device tree node. Returns pointer to populated structure. If error happened while populating, returns NULL. If property is missing in a device-tree, then the corresponding value is set to -ENOENT.",
        "proto" :"const struct lpddr2_info* (*of_lpddr2_get_info)(struct device_node *np, struct device *dev)",
        "pre": {
            "np": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of unique banks referenced by a device. The device must be a child of the NEMC. Unique here means that a device that references the same bank multiple times in its 'reg' property will only count once.",
        "proto" :"unsigned int (*jz4780_nemc_num_banks)(struct device *dev)",
        "pre": {
            "dev": "!=null && isChildOfNEMC(dev)"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:jz4780_nemc_num_banks": {
        "description": "Count the number of unique NEMC banks referred to by the specified NEMC child device. Unique here means that a device that references the same bank multiple times in its 'reg' property will only count once.",
        "proto" :"unsigned int (*jz4780_nemc_num_banks)(struct device *dev)",
        "pre": {
            "dev": "!=null && isChildOfNEMC(dev)"
        }
    }
},
{
    "kretprobe:jz4780_nemc_set_type": {
        "description": "Set the type of device connected to a bank.",
        "proto" :"void (*jz4780_nemc_set_type)(struct device *dev, unsigned int bank, enum jz4780_nemc_bank_type type)",
        "pre": {
            "dev": "!=null",
            "bank": "is a valid bank number",
            "type": "is a valid jz4780_nemc_bank_type enum value"
        }
    }
},
{
    "kprobe:jz4780_nemc_set_type": {
        "description": "Set the type of device connected to a bank.",
        "proto" :"void (*jz4780_nemc_set_type)(struct device *dev, unsigned int bank, enum jz4780_nemc_bank_type type)",
        "pre": {
            "dev": "!=null",
            "bank": "is a valid bank number",
            "type": "is a valid jz4780_nemc_bank_type enum value",
        },
    }
},
{
    "kretprobe:jz4780_nemc_assert": {
        "description": "(De-)asserts the chip enable pin for the NAND device connected to the specified bank.",
        "proto" :"static void (*jz4780_nemc_assert)(struct device *dev, unsigned int bank, bool assert)",
        "pre": {
            "dev": "!=null",
            "bank": "is a valid bank number",
            "assert": "is a boolean"
        },
    }
},
{
    "kprobe:jz4780_nemc_assert": {
        "description": "(De-)asserts the chip enable pin for the NAND device connected to the specified bank.",
        "proto" :"void (*jz4780_nemc_assert)(struct device *dev, unsigned int bank, bool assert)",
        "pre": {
            "dev": "!=null",
            "bank": "is a valid bank number",
            "assert": "is a boolean value"
        }
    }
},




{
    "kretprobe:gpmc_cs_request": {
        "description": "Request a chip-select, align the memory, adjust the resource if the chip-select is enabled, and allocate the resource if necessary. Disable CS while changing base address and size mask.",
        "proto" :"int gpmc_cs_request(int cs, unsigned long size, unsigned long  base)",
        "pre": {
            "cs": "in [0, gpmc_cs_num-1]",
            "size": ">= 0",
            "base": ">= 0"
        },
        "post": {
            "return": "in [-ENODEV, -ENOMEM, -EBUSY, 0]"
        }
    }
},
{
    "kprobe:gpmc_cs_request": {
        "description": "Request a GPMC chip-select",
        "proto" :"int gpmc_cs_request(int cs, unsigned long size, unsigned long base)",
        "pre": {
            "cs": "< gpmc_cs_num",
            "size": "<= (1 << GPMC_SECTION_SHIFT)",
            "base": "any"
        },
    }
},
{
    "kretprobe:gpmc_configure": {
        "description": "Write request to configure gpmc. Returns the status of the operation.",
        "proto": "int (*gpmc_configure)(int cmd, int wval)",
        "pre": {
            "cmd": "is int",
            "wval": "is int"
        }
    }
},
{
    "kprobe:gpmc_configure": {
        "description": "Write request to configure gpmc",
        "proto" :"int (*gpmc_configure)(int cmd, int wval)",
        "pre": {
            "cmd": "is int",
            "wval": "is int"
        },
    }
},
{
    "kretprobe:vfio_info_cap_add": {
        "description": "vfio_info_cap_shift() should be called to fixup the next offsets prior to copying to the user buffer.",
        "proto" :"struct vfio_info_cap_header *(*vfio_info_cap_add)(struct vfio_info_cap *caps, size_t size, u16 id, u16 version)",
        "pre": {
            "caps": "!=null",
            "size": ">0",
            "id": ">=0",
            "version": ">=0"
        },
    }
},
{
    "kprobe:vfio_info_cap_add": {
        "description": "vfio_info_cap_shift() should be called to fixup the next offsets prior to copying to the user buffer.",
        "proto" :"struct vfio_info_cap_header *(*vfio_info_cap_add)(struct vfio_info_cap *caps, size_t size, u16 id, u16 version)",
        "pre": {
            "caps": "!=null",
            "size": ">0",
            "id": ">=0",
            "version": ">=0"
        }
    }
},
{
    "kretprobe:vfio_pin_pages": {
        "description": "group->container cannot change while a vfio device is open",
        "proto" :"if (!pages || !npage || WARN_ON(!vfio_assert_device_open(device)))return -EINVAL;if (vfio_device_has_container(device))return vfio_device_container_pin_pages(device, iova, npage, prot, pages);if (device->iommufd_access)",
        "pre": {
            "device": "!=null",
            "iova": "!=null",
            "npage": ">0",
            "prot": ">=0",
            "pages": "!=null",
            "device->iommufd_access": "!=null",
            "vfio_assert_device_open(device)": "==true",
            "vfio_device_has_container(device)": "==true",
            "vfio_device_container_pin_pages(device, iova, npage, prot, pages)": "==0"
        },
    }
},
{
    "kprobe:vfio_pin_pages": {
        "description": "group->container cannot change while a vfio device is open",
        "proto" :"vfio_pin_pages(struct vfio_device *device, dma_addr_t iova, int npage, int prot, struct page *pages)",
        "pre": {
            "device": "!=null && device->iommufd_access == false && vfio_device_has_container(device) == false",
            "iova": "!=null",
            "npage": ">0",
            "prot": ">=0",
            "pages": "!=null"
        }
    }
},
{
    "kretprobe:vfio_dma_rw": {
        "description": "VFIO historically tries to auto-detect a kthread",
        "proto": "long (*vfio_dma_rw)(struct vfio_device *device, dma_addr_t iova, void *data, size_t len, bool write)",
        "pre": {
            "device": "!=null",
            "iova": "<=ULONG_MAX",
            "data": "!=null",
            "len": ">0",
            "write": "in [true, false]"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:vfio_dma_rw": {
        "description": "VFIO historically tries to auto-detect a kthread.",
        "proto" :"vfio_dma_rw(struct vfio_device  device, dma_addr_t iova, void  data,size_t len, bool write)",
        "pre": {
            "device": "!=null",
            "iova": "<= ULONG_MAX",
            "data": "!=null",
            "len": "> 0",
            "write": "in [true, false]",
            "vfio_assert_device_open(device)": "== true",
            "vfio_device_has_container(device)": "== false",
            "device->iommufd_access": "!=null"
        },
    }
},
{
    "kretprobe:mdev_register_parent": {
        "description": "mdev_unregister_parent(). Returns a negative value on error, otherwise 0.",
        "proto" :"int mdev_register_parent(struct mdev_parent *parent, struct device *dev, struct mdev_driver *mdev_driver, struct mdev_type **types, unsigned int nr_types)",
        "pre": {
            "parent": "!=null",
            "dev": "!=null",
            "mdev_driver": "!=null",
            "types": "!=null",
            "nr_types": ">=0"
        },
    }
},
{
    "kprobe:mdev_register_parent": {
        "description": "mdev_unregister_parent(). Returns a negative value on error, otherwise 0.",
        "proto" :"int mdev_register_parent(struct mdev_parent *parent, struct device *dev, struct mdev_driver *mdev_driver, struct mdev_type **types, unsigned int nr_types)",
        "pre": {
            "parent": "!=null",
            "dev": "!=null",
            "mdev_driver": "!=null",
            "types": "!=null",
            "nr_types": ">=0"
        },
    }
},
{
    "kretprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver. Returns a negative value on error, otherwise 0.",
        "proto" :"int mdev_register_driver(struct mdev_driver *drv)",
        "pre": {
            "drv": "!=null"
        },
        "post": {
            "return": "in [-inf, 0]"
        }
    }
},
{
    "kprobe:mdev_register_driver": {
        "description": "Register a new MDEV driver. Returns a negative value on error, otherwise 0.",
        "proto" :"int (*mdev_register_driver)(struct mdev_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:mdev_unregister_driver": {
        "description": "Unregister MDEV driver @drv: the driver to unregister",
        "proto" :"void (*mdev_unregister_driver)(struct mdev_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdev_unregister_driver": {
        "description": "Unregister MDEV driver",
        "proto" :"void (*mdev_unregister_driver)(struct mdev_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:pps_register_source": {
        "description": "Add a new PPS source in the system. The new source is described by info's fields and it will have, as default PPS parameters, the ones specified into default_params. The function returns, in case of success, the PPS device. Otherwise ERR_PTR(errno).",
        "proto" :"struct pps_device *(*pps_register_source)(struct pps_source_info *info, int default_params)",
        "pre": {
            "info": "!=null",
            "default_params": "is int"
        },
    }
},
{
    "kprobe:pps_register_source": {
        "description": "Add a new PPS source in the system. The new source is described by info's fields and it will have, as default PPS parameters, the ones specified into default_params. The function returns, in case of success, the PPS device. Otherwise ERR_PTR(errno).",
        "proto" :"struct pps_device *(*pps_register_source)(struct pps_source_info *info, int default_params)",
        "pre": {
            "info": "!=null",
            "default_params": "is an integer"
        },
    }
},
{
    "kretprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system.",
        "proto": "void (*pps_unregister_source)(struct pps_device *pps)",
        "pre": {
            "pps": "!=null"
        }
    }
},
{
    "kprobe:pps_unregister_source": {
        "description": "Remove a PPS source from the system.",
        "proto": "void (*pps_unregister_source)(struct pps_device *pps)",
        "pre": {
            "pps": "!=null"
        }
    }
},



{
    "kprobe:wake_up_all": {
        "description": "To wakeup any blocking writers",
        "proto" :"static long (*wake_up_all)(struct qcom_glink *glink)",
        "pre": {
            "glink": "!=null"
        },
    }
},
{
    "kretprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "The default endpoint is released by the rpmsg core",
        "proto" :"static void (*rpmsg_chrdev_eptdev_destroy)(struct device *dev, void *data)",
        "pre": {
            "dev": "!=null",
            "data": "!=null"
        },
    }
},
{
    "kprobe:rpmsg_chrdev_eptdev_destroy": {
        "description": "The default endpoint is released by the rpmsg core",
        "proto" :"static void (*rpmsg_chrdev_eptdev_destroy)(struct device *dev, void *data)",
        "pre": {
            "dev": "!=null",
            "data": "!=null",
            "eptdev->ept_lock": "locked",
            "eptdev->rpdev": "==null",
            "eptdev->ept": "!=null"
        },
    }
},
{
    "kretprobe:qcom_smd_register_edge": {
        "description": "Register an edge based on a device_node. Returns an edge reference, or negative ERR_PTR() on failure.",
        "proto" :"struct qcom_smd_edge *(*qcom_smd_register_edge)(struct device *parent, struct device_node *node)",
        "pre": {
            "parent": "!=null",
            "node": "!=null"
        },
        "post": {
            "return": "!=null || is negative ERR_PTR()"
        }
    }
},
{
    "kprobe:qcom_smd_register_edge": {
        "description": "Register an edge based on a device_node. Returns an edge reference, or negative ERR_PTR() on failure.",
        "proto" :"struct qcom_smd_edge *(*qcom_smd_register_edge)(struct device *parent, struct device_node *node)",
        "pre": {
            "parent": "!=null",
            "node": "!=null"
        },
    }
},
{
    "kretprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children. Edge reference acquired from qcom_smd_register_edge.",
        "proto" :"void (*qcom_smd_unregister_edge)(struct qcom_smd_edge *edge)",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kprobe:qcom_smd_unregister_edge": {
        "description": "Release an edge and its children. Edge reference acquired from qcom_smd_register_edge.",
        "proto" :"static void (*qcom_smd_unregister_edge)(struct qcom_smd_edge *edge)",
        "pre": {
            "edge": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info. Return a pointer to the new rpmsg device on success, or NULL on error.",
        "proto" :"struct rpmsg_device *(*rpmsg_create_channel)(struct rpmsg_device *rpdev, struct rpmsg_channel_info *chinfo)",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_channel": {
        "description": "Create a new rpmsg channel using its name and address info.",
        "proto" :"struct rpmsg_device *(*rpmsg_create_channel)(struct rpmsg_device *rpdev, struct rpmsg_channel_info *chinfo)",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "proto" :"int (*rpmsg_release_channel)(struct rpmsg_device *rpdev, struct rpmsg_channel_info *chinfo)",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        },
        "post": {
            "return": "in [0, appropriate error value]"
        }
    }
},
{
    "kprobe:rpmsg_release_channel": {
        "description": "Release a rpmsg channel using its name and address info.",
        "proto" :"int (*rpmsg_release_channel)(struct rpmsg_device *rpdev, struct rpmsg_channel_info *chinfo)",
        "pre": {
            "rpdev": "!=null",
            "chinfo": "!=null"
        },
        "post": {
            "return": "in [0, appropriate error value]"
        }
    }
},
{
    "kretprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint. Bind a callback, and possibly some private data too, to an rpmsg address. If @addr is RPMSG_ADDR_ANY, then rpmsg_create_ept will dynamically assign them an available rpmsg address.",
        "proto" :"struct rpmsg_endpoint *(*rpmsg_create_ept)(struct rpmsg_device *rpdev, rpmsg_rx_cb_t cb, void *priv, struct rpmsg_channel_info chinfo)",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "can be null",
            "chinfo": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_create_ept": {
        "description": "Create a new rpmsg_endpoint. Bind a callback, and possibly some private data too, to an rpmsg address. If @addr is RPMSG_ADDR_ANY, then rpmsg_create_ept will dynamically assign them an available rpmsg address.",
        "proto" :"struct rpmsg_endpoint *(*rpmsg_create_ept)(struct rpmsg_device *rpdev, rpmsg_rx_cb_t cb, void *priv, struct rpmsg_channel_info chinfo)",
        "pre": {
            "rpdev": "!=null",
            "cb": "!=null",
            "priv": "can be null",
            "chinfo": "!=null"
        },
    }
},
{
    "kretprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint. Should be used by drivers to destroy an rpmsg endpoint previously created with rpmsg_create_ept(). As with other types of 'free', NULL is a valid parameter.",
        "proto" :"void (*rpmsg_destroy_ept)(struct rpmsg_endpoint *ept)",
        "pre": {
            "ept": "is rpmsg_endpoint pointer or null"
        }
    }
},
{
    "kprobe:rpmsg_destroy_ept": {
        "description": "Destroy an existing rpmsg endpoint. Should be used by drivers to destroy an rpmsg endpoint previously created with rpmsg_create_ept(). NULL is a valid parameter.",
        "proto" :"void (*rpmsg_destroy_ept)(struct rpmsg_endpoint *ept)",
        "pre": {
            "ept": "in [NULL, rpmsg_endpoint]"
        }
    }
},
{
    "kretprobe:rpmsg_send": {
        "description": "This function sends @data of length @len on the @ept endpoint. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address and its associated rpmsg device destination addresses. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now).",
        "proto" :"int rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:rpmsg_send": {
        "description": "This function sends @data of length @len on the @ept endpoint. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address and its associated rpmsg device destination addresses. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now).",
        "proto" :"int rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kretprobe:rpmsg_sendto": {
        "description": "This function sends @data of length @len to the remote @dst address. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now).",
        "proto" :"int rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">0",
            "dst": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:rpmsg_sendto": {
        "description": "This function sends @data of length @len to the remote @dst address. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now).",
        "proto" :"int rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">0",
            "dst": ">=0"
        },
    }
},
{
    "kretprobe:rpmsg_send_offchannel": {
        "description": "This function sends @data of length @len to the remote @dst address, and uses @src as the source address. The message will be sent to the remote processor which the @ept endpoint belongs to. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now). Return: 0 on success and an appropriate error value on failure.",
        "proto" :"int rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "src": ">=0",
            "dst": ">=0",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ERESTARTSYS]"
        }
    }
},
{
    "kprobe:rpmsg_send_offchannel": {
        "description": "This function sends @data of length @len to the remote @dst address, and uses @src as the source address. The message will be sent to the remote processor which the @ept endpoint belongs to. In case there are no TX buffers available, the function will block until one becomes available, or a timeout of 15 seconds elapses. When the latter happens, -ERESTARTSYS is returned. Can only be called from process context (for now). Return: 0 on success and an appropriate error value on failure.",
        "proto" :"int rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "src": "is u32",
            "dst": "is u32",
            "data": "!=null",
            "len": "is int and >=0"
        },
    }
},
{
    "kretprobe:rpmsg_trysend": {
        "description": "This function sends @data of length @len on the @ept endpoint. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source and its associated rpdev's address as destination. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:rpmsg_trysend": {
        "description": "Send a message across to the remote processor. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source and its associated rpdev's address as destination. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int (*rpmsg_trysend)(struct rpmsg_endpoint *ept, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">=0"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kretprobe:rpmsg_trysendto": {
        "description": "This function sends @data of length @len to the remote @dst address. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">0",
            "dst": ">=0"
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:rpmsg_trysendto": {
        "description": "Send a message across to the remote processor, specify dst. This function sends @data of length @len to the remote @dst address. The message will be sent to the remote processor which the @ept endpoint belongs to, using @ept's address as source. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)",
        "pre": {
            "ept": "!=null",
            "data": "!=null",
            "len": ">0",
            "dst": ">=0"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kretprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers. @ept:the rpmsg endpoint @filp:file for poll_wait() @wait:poll_table for poll_wait() Return: mask representing the current state of the endpoint's send buffers",
        "proto" :"__poll_t (*rpmsg_poll)(struct rpmsg_endpoint *ept, struct file *filp, poll_table *wait)",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_poll": {
        "description": "Poll the endpoint's send buffers. Return: mask representing the current state of the endpoint's send buffers.",
        "proto" :"__poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp, poll_table *wait)",
        "pre": {
            "ept": "!=null",
            "filp": "!=null",
            "wait": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_trysend_offchannel": {
        "description": "This function sends @data of length @len to the remote @dst address, and uses @src as the source address. The message will be sent to the remote processor which the @ept endpoint belongs to. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "src": "is a valid u32 value",
            "dst": "is a valid u32 value",
            "data": "!=null",
            "len": "is a valid integer and >= 0"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:rpmsg_trysend_offchannel": {
        "description": "This function sends @data of length @len to the remote @dst address, and uses @src as the source address. The message will be sent to the remote processor which the @ept endpoint belongs to. In case there are no TX buffers available, the function will immediately return -ENOMEM without waiting until one becomes available. Can only be called from process context (for now).",
        "proto" :"int rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst, void *data, int len)",
        "pre": {
            "ept": "!=null",
            "src": ">=0",
            "dst": ">=0",
            "data": "!=null",
            "len": ">=0"
        },
    }
},
{
    "kretprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message.",
        "proto" :"ssize_t (*rpmsg_get_mtu)(struct rpmsg_endpoint *ept)",
        "pre": {
            "ept": "!=null"
        },
        "post": {
            "return": ">=0"
        }
    }
},
{
    "kprobe:rpmsg_get_mtu": {
        "description": "Get maximum transmission buffer size for sending message. This function returns maximum buffer size available for a single outgoing message.",
        "proto" :"ssize_t (*rpmsg_get_mtu)(struct rpmsg_endpoint *ept)",
        "pre": {
            "ept": "!=null"
        },
    }
},
{
    "kretprobe:rpmsg_register_device_override": {
        "description": "rpmsg_register_device()",
        "proto" :"int rpmsg_register_device_override(struct rpmsg_device *rpdev, const char *driver_override)",
        "pre": {
            "rpdev": "!=null",
            "driver_override": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_register_device_override": {
        "description": "rpmsg_register_device()",
        "proto" :"int rpmsg_register_device_override(struct rpmsg_device *rpdev, const char *driver_override)",
        "pre": {
            "rpdev": "!=null",
            "driver_override": "!=null"
        }
    }
},
{
    "kretprobe:__register_rpmsg_driver": {
        "description": "__register_rpmsg_driver() - register an rpmsg driver with the rpmsg bus. @rpdrv: pointer to a struct rpmsg_driver. @owner: owning module driver. Return: 0 on success, and an appropriate error value on failure.",
        "proto" :"int (*__register_rpmsg_driver)(struct rpmsg_driver *rpdrv, struct module *owner)",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        },
        "post": {
            "return": "in [0, appropriate error value]"
        }
    }
},
{
    "kprobe:__register_rpmsg_driver": {
        "description": "__register_rpmsg_driver() - register an rpmsg driver with the rpmsg bus. @rpdrv: pointer to a struct rpmsg_driver. @owner: owning module driver. Return: 0 on success, and an appropriate error value on failure.",
        "proto" :"int (*__register_rpmsg_driver)(struct rpmsg_driver *rpdrv, struct module *owner)",
        "pre": {
            "rpdrv": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus. Return: 0 on success, and an appropriate error value on failure.",
        "proto" :"void (*unregister_rpmsg_driver)(struct rpmsg_driver *rpdrv)",
        "pre": {
            "rpdrv": "!=null"
        },
        "post": {
            "return": "in [0, appropriate error value]"
        }
    }
},
{
    "kprobe:unregister_rpmsg_driver": {
        "description": "Unregister an rpmsg driver from the rpmsg bus. Returns 0 on success, and an appropriate error value on failure.",
        "proto" :"void (*unregister_rpmsg_driver)(struct rpmsg_driver *rpdrv)",
        "pre": {
            "rpdrv": "!=null"
        }
    }
},
{
    "kretprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev. rpdev is a prepared rpmsg_device to be used for creating endpoints.",
        "proto" :"int rpmsg_ns_register_device(struct rpmsg_device *rpdev)",
        "pre": {
            "rpdev": "!=null"
        }
    }
},
{
    "kprobe:rpmsg_ns_register_device": {
        "description": "Register name service device based on rpdev. This function wraps rpmsg_register_device() preparing the rpdev for use as basis for the rpmsg name service device.",
        "proto" :"int (*rpmsg_ns_register_device)(struct rpmsg_device *rpdev)",
        "pre": {
            "rpdev": "!=null"
        }
    }
},


{
    "kretprobe:mii_link_ok": {
        "description": "Returns 1 if the MII reports link status upok, 0 otherwise.",
        "proto" :"int (*mii_link_ok)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:mii_link_ok": {
        "description": "Returns 1 if the MII reports link status upok, 0 otherwise.",
        "proto" :"int (*mii_link_ok)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface. Returns 0 on success, negative on error.",
        "proto" :"int (*mii_nway_restart)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:mii_nway_restart": {
        "description": "Restart NWay (autonegotiation) for this interface. Returns 0 on success, negative on error.",
        "proto" :"int (*mii_nway_restart)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd. The @ecmd parameter is expected to have been cleared before calling mii_ethtool_gset().",
        "proto" :"void (*mii_ethtool_gset)(struct mii_if_info *mii, struct ethtool_cmd *ecmd)",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null && ==cleared"
        }
    }
},
{
    "kprobe:mii_ethtool_gset": {
        "description": "Get settings that are specified in @ecmd. The @ecmd parameter is expected to have been cleared before calling mii_ethtool_gset().",
        "proto" :"void (*mii_ethtool_gset)(struct mii_if_info *mii, struct ethtool_cmd *ecmd)",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null && is_cleared"
        }
    }
},
{
    "kretprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd. The @cmd parameter is expected to have been cleared before calling mii_ethtool_get_link_ksettings().",
        "proto" :"void mii_ethtool_get_link_ksettings(struct mii_if_info *mii, struct ethtool_link_ksettings *cmd)",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kprobe:mii_ethtool_get_link_ksettings": {
        "description": "Get settings that are specified in @cmd. The @cmd parameter is expected to have been cleared before calling mii_ethtool_get_link_ksettings().",
        "proto" :"void mii_ethtool_get_link_ksettings(struct mii_if_info *mii, struct ethtool_link_ksettings *cmd)",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null && ==cleared"
        },
    }
},
{
    "kretprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd. Returns 0 for success, negative on error.",
        "proto" :"int (*mii_ethtool_sset)(struct mii_if_info *mii, struct ethtool_cmd *ecmd)",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:mii_ethtool_sset": {
        "description": "Set settings that are specified in @ecmd. Returns 0 for success, negative on error.",
        "proto" :"int mii_ethtool_sset(struct mii_if_info *mii, struct ethtool_cmd *ecmd)",
        "pre": {
            "mii": "!=null",
            "ecmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in @cmd. @mii: MII interfaces. @cmd: requested ethtool_link_ksettings. Returns 0 for success, negative on error.",
        "proto" :"int mii_ethtool_set_link_ksettings(struct mii_if_info *mii, const struct ethtool_link_ksettings *cmd)",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:mii_ethtool_set_link_ksettings": {
        "description": "Set settings that are specified in @cmd. Returns 0 for success, negative on error.",
        "proto" :"int (*mii_ethtool_set_link_ksettings)(struct mii_if_info *mii, const struct ethtool_link_ksettings *cmd)",
        "pre": {
            "mii": "!=null",
            "cmd": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_link": {
        "description": "Check MII link status. If the link status changed (previous != current), call netif_carrier_on() if current link status is Up or call netif_carrier_off() if current link status is Down.",
        "proto" :"void (*mii_check_link)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_link": {
        "description": "Check MII link status. If the link status changed (previous != current), call netif_carrier_on() if current link status is Up or call netif_carrier_off() if current link status is Down.",
        "proto" :"void (*mii_check_link)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:mii_check_media": {
        "description": "Check the MII interface for a carrierspeedduplex change. Returns 1 if the duplex mode changed, 0 if not. If the media type is forced, always returns 0.",
        "proto" :"unsigned int (*mii_check_media)(struct mii_if_info *mii, unsigned int ok_to_print, unsigned int init_media)",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "in [0, 1]",
            "init_media": "in [0, 1]"
        },
    }
},
{
    "kprobe:mii_check_media": {
        "description": "Check the MII interface for a carrierspeedduplex change. Returns 1 if the duplex mode changed, 0 if not. If the media type is forced, always returns 0.",
        "proto" :"unsigned int (*mii_check_media)(struct mii_if_info *mii, unsigned int ok_to_print, unsigned int init_media)",
        "pre": {
            "mii": "!=null",
            "ok_to_print": "in [0, 1]",
            "init_media": "in [0, 1]"
        }
    }
},
{
    "kretprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces",
        "proto" :"int (*mii_check_gmii_support)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kprobe:mii_check_gmii_support": {
        "description": "Check if the MII supports Gb interfaces",
        "proto" :"int (*mii_check_gmii_support)(struct mii_if_info *mii)",
        "pre": {
            "mii": "!=null"
        }
    }
},
{
    "kretprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface. Returns 0 on success, negative on error.",
        "proto" :"int (*generic_mii_ioctl)(struct mii_if_info *mii_if, struct mii_ioctl_data *mii_data, int cmd, unsigned int *duplex_chg_out)",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "is a valid MII ioctl command",
            "duplex_chg_out": "!=null"
        },
    }
},
{
    "kprobe:generic_mii_ioctl": {
        "description": "Main MII ioctl interface. Returns 0 on success, negative on error.",
        "proto" :"int (*generic_mii_ioctl)(struct mii_if_info *mii_if, struct mii_ioctl_data *mii_data, int cmd, unsigned int *duplex_chg_out)",
        "pre": {
            "mii_if": "!=null",
            "mii_data": "!=null",
            "cmd": "is a valid MII ioctl command",
            "duplex_chg_out": "!=null",
        },
    }
},
{
    "kretprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device. The found settings are set for the device to be used later in the device probing. Returns 0 if no settings found, 1 if they are.",
        "proto" :"int (*netdev_boot_setup_check)(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:netdev_boot_setup_check": {
        "description": "Check boot time settings for the device. The found settings are set for the device to be used later in the device probing. Returns 0 if no settings found, 1 if they are.",
        "proto" :"int netdev_boot_setup_check(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device. This sets @prtad and @mmds in the MDIO interface if successful. Returns 0 on success, negative on error.",
        "proto" :"int mdio45_probe(struct mdio_if_info *mdio, int prtad)",
        "pre": {
            "mdio": "!=null",
            "prtad": ">=0"
        },
    }
},
{
    "kprobe:mdio45_probe": {
        "description": "Probe for an MDIO (clause 45) device. This sets @prtad and @mmds in the MDIO interface if successful. Returns 0 on success, negative on error.",
        "proto" :"int mdio45_probe(struct mdio_if_info *mdio, int prtad)",
        "pre": {
            "mdio": "!=null",
            "prtad": ">=0 && <=255"
        }
    }
},
{
    "kretprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register. This debounces changes: it does not write the register if the flag already has the proper value. Returns 0 on success, negative on error.",
        "proto" :"int mdio_set_flag(const struct mdio_if_info *mdio, int prtad, int devad, u16 addr, int mask, bool sense)",
        "pre": {
            "mdio": "!=null",
            "prtad": ">=0",
            "devad": ">=0",
            "addr": ">=0",
            "mask": "is single bit set",
            "sense": "in [true, false]"
        },
    }
},
{
    "kprobe:mdio_set_flag": {
        "description": "Set or clear flag in an MDIO register. This debounces changes: it does not write the register if the flag already has the proper value. Returns 0 on success, negative on error.",
        "proto" :"int (*mdio_set_flag)(const struct mdio_if_info *mdio, int prtad, int devad, u16 addr, int mask, bool sense)",
        "pre": {
            "mdio": "!=null",
            "prtad": ">=0",
            "devad": ">=0",
            "addr": ">=0",
            "mask": "is single bit set",
            "sense": "in [true, false]"
        },
    }
},
{
    "kretprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise. @mmd_mask is normally @mdio->mmds, but if loopback is enabled the MMDs being bypassed should be excluded from the mask.",
        "proto" :"int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmd_mask)",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": ">=0"
        },
    }
},
{
    "kprobe:mdio45_links_ok": {
        "description": "Returns 1 if the PHY reports link status upOK, 0 otherwise. @mmd_mask is normally @mdio->mmds, but if loopback is enabled the MMDs being bypassed should be excluded from the mask.",
        "proto" :"int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmd_mask)",
        "pre": {
            "mdio": "!=null",
            "mmd_mask": "is a valid mask"
        },
    }
},
{
    "kretprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface. Returns 0 on success, negative on error.",
        "proto": "int (*mdio45_nway_restart)(const struct mdio_if_info *mdio)",
        "pre": {
            "mdio": "!=null"
        },
        "post": {
            "return": "in [0, negative]"
        }
    }
},
{
    "kprobe:mdio45_nway_restart": {
        "description": "Restart auto-negotiation for this interface. Returns 0 on success, negative on error.",
        "proto" :"int (*mdio45_nway_restart)(const struct mdio_if_info *mdio)",
        "pre": {
            "mdio": "!=null"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_gset_npage": {
        "description": "Get settings for ETHTOOL_GSET. The @ecmd parameter is expected to have been cleared before calling mdio45_ethtool_gset_npage(). Since the CSRs for auto-negotiation using next pages are not fully standardised, this function does not attempt to decode them. The caller must pass them in.",
        "proto" :"void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio, struct ethtool_cmd *ecmd, u32 npage_adv, u32 npage_lpa)",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": ">=0",
            "npage_lpa": ">=0"
        }
    }
},
{
    "kprobe:mdio45_ethtool_gset_npage": {
        "description": "Get settings for ETHTOOL_GSET. The @ecmd parameter is expected to have been cleared before calling mdio45_ethtool_gset_npage(). Since the CSRs for auto-negotiation using next pages are not fully standardised, this function does not attempt to decode them. The caller must pass them in.",
        "proto" :"void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio, struct ethtool_cmd *ecmd, u32 npage_adv, u32 npage_lpa)",
        "pre": {
            "mdio": "!=null",
            "ecmd": "!=null",
            "npage_adv": ">=0",
            "npage_lpa": ">=0"
        }
    }
},
{
    "kretprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "Get settings for ETHTOOL_GLINKSETTINGS. The @cmd parameter is expected to have been cleared before calling mdio45_ethtool_ksettings_get_npage(). Since the CSRs for auto-negotiation using next pages are not fully standardised, this function does not attempt to decode them. The caller must pass them in.",
        "proto" :"void mdio45_ethtool_ksettings_get_npage(const struct mdio_if_info *mdio, struct ethtool_link_ksettings *cmd, u32 npage_adv, u32 npage_lpa)",
        "pre": {
            "mdio": "!=null",
            "cmd": "!=null",
            "npage_adv": ">=0",
            "npage_lpa": ">=0"
        }
    }
},
{
    "kprobe:mdio45_ethtool_ksettings_get_npage": {
        "description": "Get settings for ETHTOOL_GLINKSETTINGS. The @cmd parameter is expected to have been cleared before calling mdio45_ethtool_ksettings_get_npage(). Since the CSRs for auto-negotiation using next pages are not fully standardised, this function does not attempt to decode them. The caller must pass them in.",
        "proto" :"void mdio45_ethtool_ksettings_get_npage(const struct mdio_if_info *mdio,struct ethtool_link_ksettings *cmd,u32 npage_adv, u32 npage_lpa)",
        "pre": {
            "mdio": "!=null",
            "cmd": "==null",
            "npage_adv": ">=0",
            "npage_lpa": ">=0"
        }
    }
},
{
    "kretprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs. Returns 0 on success, negative on error.",
        "proto": "int mdio_mii_ioctl(const struct mdio_if_info *mdio, struct mii_ioctl_data *mii_data, int cmd)",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "is a valid MII ioctl command"
        }
    }
},
{
    "kprobe:mdio_mii_ioctl": {
        "description": "MII ioctl interface for MDIO (clause 22 or 45) PHYs. Returns 0 on success, negative on error.",
        "proto" :"int mdio_mii_ioctl(const struct mdio_if_info *mdio, struct mii_ioctl_data *mii_data, int cmd)",
        "pre": {
            "mdio": "!=null",
            "mii_data": "!=null",
            "cmd": "in [MII_READ_COMMAND, MII_WRITE_COMMAND, ...]" // replace with actual command values
        },
    }
},
{
    "kretprobe:sungem_phy_probe": {
        "description": "We do not reset the mii_phy structure as the driver may re-probe the PHY regularly",
        "proto" :"sungem_phy_probe(struct mii_phy  phy, int mii_id)",
        "pre": {
            "phy": "!=null",
            "mii_id": "is an integer",
        },
    }
},

{
    "kretprobe:hdlcdrv_receiver": {
        "description": "Your function description here",
        "proto" :"static long (*hdlcdrv_receiver)(struct net_device *dev, struct hdlcdrv_state *s)",
        "pre": {
            "dev": "!=null",
            "s": "!=null && s->magic == HDLCDRV_MAGIC",
        },
    }
},
{
    "kprobe:hdlcdrv_receiver": {
        "description": "Handles the reception of data in the HDLC driver.",
        "proto" :"void hdlcdrv_receiver(struct net_device *dev, struct hdlcdrv_state *s)",
        "pre": {
            "dev": "!=null",
            "s": "!=null && s->magic == HDLCDRV_MAGIC",
        },
    }
},
{
    "kretprobe:hdlcdrv_transmitter": {
        "description": "Transmits the HDLC frame. The function checks if the packet length is within the valid range. If not, it returns.",
        "proto" :"void hdlcdrv_transmitter(struct net_device *dev, struct hdlcdrv_state *s)",
        "pre": {
            "dev": "!=null",
            "s": "!=null && s->magic == HDLCDRV_MAGIC",
            "pkt_len": ">=2 && <HDLCDRV_MAXFLEN"
        },
    }
},
{
    "kprobe:hdlcdrv_transmitter": {
        "description": "Transmits data using the HDLC protocol.",
        "proto" :"static void hdlcdrv_transmitter(struct net_device *dev, struct hdlcdrv_state *s)",
        "pre": {
            "dev": "!=null",
            "s": "!=null && s->magic == HDLCDRV_MAGIC",
            "s->hdlctx.in_hdlc_tx": "==0",
            "s->hdlctx.numbits": "<16",
            "s->hdlctx.tx_state": "in [0, 1]",
            "s->skb": "!=null",
            "pkt_len": ">=2 && <HDLCDRV_MAXFLEN"
        },
    }
},
{
    "kretprobe:hdlcdrv_arbitrate": {
        "description": "Arbitrates the HDLC driver state.",
        "proto" :"void hdlcdrv_arbitrate(struct net_device *dev, struct hdlcdrv_state *s)",
        "pre": {
            "dev": "!=null",
            "s": "!=null && s->magic == HDLCDRV_MAGIC && !s->hdlctx.ptt && s->skb != null"
        },
    }
},

{
    "kretprobe:hdlcdrv_register": {
        "description": "Register a new hdlc device with the specified parameters.",
        "proto" :"static int (*hdlcdrv_register)(const struct hdlcdrv_ops *ops, unsigned int privsize, const char *ifname, unsigned int baseaddr, unsigned int irq, unsigned int dma)",
        "pre": {
            "ops": "!=null",
            "privsize": ">=sizeof(struct hdlcdrv_state)",
            "ifname": "!=null",
            "baseaddr": "is valid base address",
            "irq": "is valid irq",
            "dma": "is valid dma"
        },
        "post": {
            "err": "<0 indicates failure, >=0 indicates success"
        }
    }
},
{
    "kprobe:hdlcdrv_register": {
        "description": "Register a new hdlcdrv device with the specified parameters.",
        "proto" :"static int (*hdlcdrv_register)(const struct hdlcdrv_ops *ops, unsigned int privsize, const char *ifname, unsigned int baseaddr, unsigned int irq, unsigned int dma)",
        "pre": {
            "ops": "!=null",
            "privsize": ">=sizeof(struct hdlcdrv_state)",
            "ifname": "!=null",
            "baseaddr": "is valid base address",
            "irq": "is valid irq",
            "dma": "is valid dma"
        },
        "post": {
            "dev->base_addr": "==baseaddr",
            "dev->irq": "==irq",
            "dev->dma": "==dma",
            "err": "<0 indicates failure, >=0 indicates success"
        }
    }
},

{
    "kprobe:hdlcdrv_receiver": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "arg1": "Constraint for arg1",
            "arg2": "Constraint for arg2",
            ...
        },
    },
    "kprobe:hdlcdrv_transmitter": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "arg1": "Constraint for arg1",
            "arg2": "Constraint for arg2",
            ...
        },
    },
    "kprobe:hdlcdrv_arbitrate": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "arg1": "Constraint for arg1",
            "arg2": "Constraint for arg2",
            ...
        },
    },
    "kprobe:hdlcdrv_register": {
        "description": "Description of the function",
        "proto" :"Prototype of the function",
        "pre": {
            "arg1": "Constraint for arg1",
            "arg2": "Constraint for arg2",
            ...
        },
    },
    "kprobe:hdlcdrv_unregister": {
        "description": "Unregister the net device and free the net device",
        "proto" :"void hdlcdrv_unregister(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for specified net.",
        "proto" :"int (*ppp_register_net_channel)(struct net *net, struct ppp_channel *chan)",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        }
    }
},
{
    "kprobe:ppp_register_net_channel": {
        "description": "Create a new, unattached ppp channel for specified net.",
        "proto" :"int (*ppp_register_net_channel)(struct net *net, struct ppp_channel *chan)",
        "pre": {
            "net": "!=null",
            "chan": "!=null"
        },
    }
},
{
    "kretprobe:ppp_unregister_channel": {
        "description": "Unregisters a PPP channel. This ensures that we have returned from any calls into the channel's start_xmit or ioctl routine before we proceed.",
        "proto" :"static void (*ppp_unregister_channel)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        },
    }
},
{
    "kprobe:ppp_unregister_channel": {
        "description": "Unregister a PPP channel. This ensures that we have returned from any calls into the channel's start_xmit or ioctl routine before we proceed.",
        "proto" :"void (*ppp_unregister_channel)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "proto" :"int ppp_unit_number(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        },
    }
},
{
    "kprobe:ppp_unit_number": {
        "description": "Return the PPP unit number to which a channel is connected.",
        "proto" :"int (*ppp_unit_number)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:ppp_dev_name": {
        "description": "Return the PPP device interface name of a channel.",
        "proto" :"char *(*ppp_dev_name)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        },
    }
},
{
    "kprobe:ppp_dev_name": {
        "description": "Return the PPP device interface name of a channel.",
        "proto" :"char *(*ppp_dev_name)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "proto" :"static long (*voidppp_unregister_channel)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kprobe:voidppp_unregister_channel": {
        "description": "Disconnect a channel from the generic layer. This must be called in process context.",
        "proto" :"void (*voidppp_unregister_channel)(struct ppp_channel *chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},
{
    "kretprobe:ppp_bridge_channels": {
        "description": "ppp_input on one channel is redirected to the other's ops->start_xmit handler. In order to safely bridge channels we must reject channels which are already part of a bridge instance, or which form part of an existing unit. Once successfully bridged, each channel holds a reference on the other to prevent it being freed while the bridge is extant.",
        "proto" :"static int (*ppp_bridge_channels)(struct channel *pch, struct channel *pchb)",
        "pre": {
            "pch": "!=null && !part_of_existing_bridge && !part_of_existing_unit",
            "pchb": "!=null && !part_of_existing_bridge && !part_of_existing_unit"
        }
    }
},
{
    "kprobe:ppp_bridge_channels": {
        "description": "ppp_input on one channel is redirected to the other's ops->start_xmit handler. In order to safely bridge channels we must reject channels which are already part of a bridge instance, or which form part of an existing unit. Once successfully bridged, each channel holds a reference on the other to prevent it being freed while the bridge is extant.",
        "proto" :"static int (*ppp_bridge_channels)(struct channel *pch, struct channel *pchb)",
        "pre": {
            "pch": "!=null && !part of a bridge instance && !form part of an existing unit",
            "pchb": "!=null && !part of a bridge instance && !form part of an existing unit"
        }
    }
},
{
    "kretprobe:ppp_input_error": {
        "description": "Process a received frame. The receive side of the ppp unit is locked.",
        "proto" :"static void (*ppp_input_error)(struct ppp_channel *chan, int code)",
        "pre": {
            "chan": "!=null",
            "code": "is an integer"
        }
    }
},
{
    "kprobe:ppp_input_error": {
        "description": "Process a received frame. The receive side of the ppp unit is locked.",
        "proto" :"static void (*ppp_input_error)(struct ppp_channel *chan, int code)",
        "pre": {
            "chan": "!=null",
            "code": "is integer",
        },
    }
},
{
    "kretprobe:ppp_output_wakeup": {
        "description": "Compression control.",
        "proto" :"ppp_output_wakeup(struct ppp_channel  chan)",
        "pre": {
            "chan": "!=null"
        }
    }
},

{
    "kretprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "proto" :"void (*voidppp_unregister_compressor)(struct compressor *cp)",
        "pre": {
            "cp": "!=null"
        }
    }
},
{
    "kprobe:voidppp_unregister_compressor": {
        "description": "Unregister a compressor",
        "proto" :"voidppp_unregister_compressor(struct compressor *cp)",
        "pre": {
            "cp": "!=null"
        }
    }
},
{
    "kretprobe:find_compressor": {
        "description": "Find a compressor based on its type.",
        "proto" :"static struct compressor *(*find_compressor)(int type)",
        "pre": {
            "type": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:find_compressor": {
        "description": "Find a compressor.",
        "proto" :"static struct compressor *(*find_compressor)(int type)",
        "pre": {
            "type": ">=0"
        },
    }
},
{
    "kretprobe:pppox_unbind_sock": {
        "description": "Clear connection to ppp device, if attached.",
        "proto" :"static void (*pppox_unbind_sock)(struct sock *sk)",
        "pre": {
            "sk": "!=null"
        }
    }
},
{
    "kprobe:pppox_unbind_sock": {
        "description": "Clear connection to ppp device, if attached.",
        "proto" :"static void (*pppox_unbind_sock)(struct sock *sk)",
        "pre": {
            "sk": "!=null",
            "sk->sk_state": "in [PPPOX_BOUND, PPPOX_CONNECTED]"
        }
    }
},
{
    "kretprobe:vsc73xx_probe": {
        "description": "Probe function for vsc73xx. Release reset, if any.",
        "proto" :"int vsc73xx_probe(struct vsc73xx *vsc)",
        "pre": {
            "vsc": "!=null",
        },
        "post": {
            "vsc->reset": "!=ERR_PTR"
        }
    }
},
{
    "kprobe:vsc73xx_probe": {
        "description": "Release reset, if any",
        "proto" :"static int (*vsc73xx_probe)(struct vsc73xx *vsc)",
        "pre": {
            "vsc": "!=null",
        },
        "post": {
            "vsc->reset": "!=null || ==ERR_PTR(-EINVAL)",
        }
    }
},
{
    "kretprobe:lan9303_probe_reset_gpio": {
        "description": "This function is used to reset the GPIO of the lan9303 chip. It first tries to get the optional reset GPIO. If it fails, it returns the error. If the reset GPIO is not defined, it logs a debug message and returns 0. It then sets the reset duration to 200. If a device node is provided, it reads the reset duration from the device node. If not, it logs a debug message indicating that the reset duration defaults to 200 ms. A sane reset duration should not be longer than 1s.",
        "proto" :"int lan9303_probe_reset_gpio(struct lan9303 *chip, struct device_node *np)",
        "pre": {
            "chip": "!=null",
            "np": "can be null"
        },
        "post": {
            "chip->reset_gpio": "!=null or ==null",
            "chip->reset_duration": "<=1000"
        }
    }
},
{
    "kprobe:lan9303_probe_reset_gpio": {
        "description": "This function is used to reset the GPIO of the LAN9303 chip. It first tries to get the optional reset GPIO. If it fails, it returns the error. If the reset GPIO is not defined, it logs a debug message and returns 0. It then sets the reset duration to 200. If a device node is provided, it reads the reset duration from the device node. Otherwise, it logs a debug message indicating that the reset duration defaults to 200 ms. A sane reset duration should not be longer than 1s.",
        "proto" :"int lan9303_probe_reset_gpio(struct lan9303 *chip, struct device_node *np)",
        "pre": {
            "chip": "!=null",
            "np": "can be null",
            "chip->reset_gpio": "can be null or valid GPIO",
            "chip->reset_duration": ">=0 and <=1000",
        },
    }
},
{
    "kretprobe:lan9303_remove": {
        "description": "Shut down the device and unregister the switch. Assert reset to the whole device to prevent it from doing anything.",
        "proto" :"static int (*lan9303_remove)(struct lan9303 *chip)",
        "pre": {
            "chip": "!=null",
            // Add other parameters and their conditions here
        },
    }
},

{
    "kretprobe:ksz_switch_register": {
        "description": "Your function description here",
        "proto" :"static long (*ksz_switch_register)(struct ksz_device *dev)",
        "pre": {
            "dev": "!=null",
            // Add other preconditions here
        },
        "post": {
            // Add postconditions here
        }
    }
},

{
    "kretprobe:ksz_switch_remove": {
        "description": "Remove a ksz_switch device and stop the timer.",
        "proto" :"static void (*ksz_switch_remove)(struct ksz_device *dev)",
        "pre": {
            "dev": "!=null",
            "dev->mib_read_interval": "!=0",
        },
    }
},
{
    "kprobe:ksz_switch_remove": {
        "description": "Remove the ksz_switch and stop the timer.",
        "proto" :"static void (*ksz_switch_remove)(struct ksz_device *dev)",
        "pre": {
            "dev": "!=null",
            "dev->mib_read_interval": "!=null"
        }
    }
},
{
    "kretprobe:b53_for_each_port": {
        "description": "Enable the IMP port to be in the same VLAN as the other ports on a per-port basis such that we only have Port i and IMP in the same VLAN.",
        "proto" :"b53_for_each_port(struct b53_device *dev, unsigned int i)",
        "pre": {
            "dev": "!=null",
            "i": ">=0"
        }
    }
},
{
    "kprobe:b53_for_each_port": {
        "description": "Enable the IMP port to be in the same VLAN as the other ports on a per-port basis such that we only have Port i and IMP in the same VLAN.",
        "proto" :"b53_for_each_port(struct b53_device *dev, unsigned int i)",
        "pre": {
            "dev": "!=null",
            "i": "is a valid port number",
        },
    }
},
{
    "kretprobe:b53_enable_port": {
        "description": "Enable a port on a B53 device. If the port is a user port, set unicast and multicast flooding, disable learning, and enable interrupts if supported. If the port is a member of a bridge, restore its membership prior to bringing down this port.",
        "proto": "int (*b53_enable_port)(struct dsa_switch *ds, int port, struct phy_device *phy)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "phy": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},

{
    "kretprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "proto" :"void b53_disable_port(struct dsa_switch *ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": ">=0"
        }
    }
},
{
    "kprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "proto" :"void (*b53_disable_port)(struct dsa_switch *ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": ">=0"
        },
    }
},
{
    "kretprobe:b53_brcm_hdr_setup": {
        "description": "Setup Broadcom header for a specific port on a DSA switch",
        "proto" :"static void (*b53_brcm_hdr_setup)(struct dsa_switch *ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": "is integer"
        },
    }
},
{
    "kprobe:b53_brcm_hdr_setup": {
        "description": "Description of the function",
        "proto" :"static void (*b53_brcm_hdr_setup)(struct dsa_switch *ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": "is an integer",
        },
    }
},
{
    "kretprobe:b53_configure_vlan": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "dev": "Your conditions for dev here",
            "ds": "Your conditions for ds here",
            "vl": "Your conditions for vl here",
            "v": "Your conditions for v here",
            "i": "Your conditions for i here",
            "def_vid": "Your conditions for def_vid here",
            "vid": "Your conditions for vid here"
        },
    }
},
{
    "kprobe:b53_configure_vlan": {
        "description": "Your function description here",
        "proto" :"static long (*b53_configure_vlan)(struct dsa_switch *ds)",
        "pre": {
            "ds": "!=null",
            "dev": "!=null",
            "vl": "!=null",
            "v": "!=null",
            "i": "is integer",
            "def_vid": "is integer",
            "vid": "is integer",
        },
    }
},
{
    "kretprobe:b53_fdb_add": {
        "description": "5325 and 5365 require some more massaging, but could be supported eventually",
        "proto" :"static long (*b53_fdb_add)(struct dsa_switch ds, int port, const unsigned char addr, u16 vid, struct dsa_db db)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "addr": "!=null",
            "vid": ">=0",
            "db": "!=null"
        },
    }
},
{
    "kprobe:b53_fdb_add": {
        "description": "5325 and 5365 require some more massaging, but could be supported eventually",
        "proto" :"static long (*b53_fdb_add)(struct dsa_switch ds, int port, const unsigned char addr, u16 vid, struct dsa_db db)",
        "pre": {
            "ds": "!=null",
            "port": "is integer",
            "addr": "!=null",
            "vid": "is u16",
            "db": "!=null"
        },
    }
},


{
    "kretprobe:b53_mdb_add": {
        "description": "5325 and 5365 require some more massaging, but could be supported eventually",
        "proto" :"b53_mdb_add(struct dsa_switch ds, int port, const struct switchdev_obj_port_mdb mdb, struct dsa_db db)",
        "pre": {
            "ds": "!=null",
            "port": "is integer",
            "mdb": "!=null",
            "db": "!=null"
        },
        "post": {
            "return": "in [-EOPNOTSUPP, 0]"
        }
    }
},
{
    "kprobe:b53_mdb_add": {
        "description": "5325 and 5365 require some more massaging, but could be supported eventually",
        "proto" :"int (*b53_mdb_add)(struct dsa_switch *ds, int port, const struct switchdev_obj_port_mdb *mdb, struct dsa_db *db)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "mdb": "!=null",
            "db": "!=null",
            "priv": "!=null && (is5325(priv) || is5365(priv)) == false"
        },
    }
},
{
    "kretprobe:b53_br_join": {
        "description": "On 7278, port 7 which connects to the ASP should only receive traffic from matching CFP rules.",
        "proto" :"if (dev->chip_id == BCM7278_DEVICE_ID && port == 7) return -EINVAL;",
        "pre": {
            "dev->chip_id": "== BCM7278_DEVICE_ID",
            "port": "== 7"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kprobe:b53_br_join": {
        "description": "On 7278, port 7 which connects to the ASP should only receive traffic from matching CFP rules.",
        "proto" :"b53_br_join(struct dsa_switch ds, int port, struct dsa_bridge bridge, bool tx_fwd_offload, struct netlink_ext_ack extack)",
        "pre": {
            "ds": "!=null",
            "port": "in [0, 1, 2, 3, 4, 5, 6, 7]",
            "bridge": "!=null",
            "tx_fwd_offload": "is boolean",
            "extack": "!=null",
            "dev->chip_id": "== BCM7278_DEVICE_ID",
            "port": "== 7"
        },
        "post": {
            "return": "== -EINVAL"
        }
    }
},
{
    "kretprobe:b53_br_leave": {
        "description": "This function handles the process of a port leaving a bridge in a B53 switch.",
        "proto" :"void b53_br_leave(struct dsa_switch *ds, int port, struct dsa_bridge *bridge)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "bridge": "!=null"
        },
    }
},
{
    "kprobe:b53_br_leave": {
        "description": "Description of the function",
        "proto" :"static long (*b53_br_leave)(struct dsa_switch  ds, int port, struct dsa_bridge bridge)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "bridge": "!=null",
        },
    }
},
{
    "kretprobe:b53_get_tag_protocol": {
        "description": "Older models require a different 6 byte tag",
        "proto" :"b53_get_tag_protocol(struct dsa_switch ds, int port, enum dsa_tag_protocol mprot)",
        "pre": {
            "ds": "!=null",
            "port": "is a valid port number",
            "mprot": "is a valid dsa_tag_protocol enum value"
        },
    }
},
{
    "kprobe:b53_get_tag_protocol": {
        "description": "Older models require a different 6 byte tag",
        "proto" :"static long (*b53_get_tag_protocol)(struct dsa_switch ds, int port, enum dsa_tag_protocol mprot)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
            "mprot": "in [DSA_TAG_PROTO_NONE, DSA_TAG_PROTO_BRCM, DSA_TAG_PROTO_BRCM_PREPEND]"
        },
    }
},
{
    "kretprobe:b53_mirror_del": {
        "description": "Update the desired ingress/egress register",
        "proto" :"static void (*b53_mirror_del)(struct dsa_switch *ds, int port, struct dsa_mall_mirror_tc_entry *mirror)",
        "pre": {
            "ds": "!=null",
            "port": "in [range]",
            "mirror": "!=null"
        },
    }
},
{
    "kprobe:b53_mirror_del": {
        "description": "Update the desired ingress/egress register",
        "proto" :"static void (*b53_mirror_del)(struct dsa_switch *ds, int port, struct dsa_mall_mirror_tc_entry *mirror)",
        "pre": {
            "ds": "!=null",
            "port": "is valid port number",
            "mirror": "!=null",
        },
    }
},
{
    "kretprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "proto" :"void b53_disable_port(struct dsa_switch *ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": ">=0"
        }
    }
},
{
    "kprobe:b53_disable_port": {
        "description": "Disable TxRx for the port",
        "proto" :"void (*b53_disable_port)(struct dsa_switch ds, int port)",
        "pre": {
            "ds": "!=null",
            "port": ">=0",
        },
    }
},
{
    "kretprobe:__set_bit": {
        "description": "Set a bit in the supported interfaces of the config.",
        "proto" :"void __set_bit(int PHY_INTERFACE_MODE_GMII, struct phylink_config *config)",
        "pre": {
            "PHY_INTERFACE_MODE_GMII": "in [0, 1, 2, 3, 4, 5]",
            "config": "!=null",
        },
    }
},

{
    "kretprobe:b53_switch_alloc": {
        "description": "DSA handle the case were multiple bridges span the same switch device and different VLAN awareness settings are requested, which would be breaking filtering semantics for any of the other bridge devices. (not hardware supported)",
        "proto" :"b53_switch_alloc(struct device *base, const struct b53_io_ops *ops, void *priv)",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:b53_switch_alloc": {
        "description": "Allocates a switch device and initializes it. Returns NULL if allocation fails.",
        "proto" :"struct dsa_switch *(*b53_switch_alloc)(struct device *base, const struct b53_io_ops *ops, void *priv)",
        "pre": {
            "base": "!=null",
            "ops": "!=null",
            "priv": "can be null"
        },
    }
},
{
    "kretprobe:b53_switch_detect": {
        "description": "Detects the switch type of a B53 device.",
        "proto" :"int (*b53_switch_detect)(struct b53_device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "dev->chip_id": "in [BCM5325_DEVICE_ID, BCM5365_DEVICE_ID, BCM5389_DEVICE_ID, BCM5395_DEVICE_ID, BCM5397_DEVICE_ID, BCM5398_DEVICE_ID, id32]",
            "ret": "in [0, 1]"
        }
    }
},
{
    "kprobe:b53_switch_detect": {
        "description": "Your description here",
        "proto" :"b53_switch_detect(struct b53_device *dev)",
        "pre": {
            "dev": "!=null",
            // Add other conditions here
        },
    }
},
{
    "kretprobe:b53_serdes_phylink_get_caps": {
        "description": "Get the capabilities of the serdes phylink.",
        "proto" :"static void (*b53_serdes_phylink_get_caps)(struct b53_device *dev, int port, struct phylink_config *config)",
        "pre": {
            "dev": "!=null",
            "port": ">=0",
            "config": "!=null"
        },
    }
},
{
    "kprobe:b53_serdes_phylink_get_caps": {
        "description": "Get the capabilities of the serdes phylink.",
        "proto" :"static void (*b53_serdes_phylink_get_caps)(struct b53_device *dev, int port, struct phylink_config *config)",
        "pre": {
            "dev": "!=null",
            "port": "in [0, 1]",
            "config": "!=null"
        },
    }
},
{
    "kretprobe:mt76_wcid_key_setup": {
        "description": "Setup the key for a specific wireless client identifier (wcid) on a specific device (dev).",
        "proto" :"static void (*mt76_wcid_key_setup)(struct mt76_dev *dev, struct mt76_wcid *wcid, struct ieee80211_key_conf *key)",
        "pre": {
            "dev": "!=null",
            "wcid": "!=null",
            "key": "!=null && key->cipher == WLAN_CIPHER_SUITE_CCMP",
        },
        "post": {
            "wcid->rx_check_pn": "==true"
        }
    }
},


{
    "kprobe:rsi_config_wowlan": {
        "description": "Config WoWLAN to device",
        "proto" :"rsi_config_wowlan(struct rsi_hw  adapter, struct cfg80211_wowlan  wowlan)",
        "pre": {
            "adapter": "!=null",
            "wowlan": "!=null"
        },
    }
},
{
    "kretprobe:brcmu_pktq_init": {
        "description": "Initialize a packet queue. 'pq' is variable size; only zero out what's requested.",
        "proto" :"void brcmu_pktq_init(struct pktq *pq, int num_prec, int max_len)",
        "pre": {
            "pq": "!=null",
            "num_prec": ">=0",
            "max_len": ">=0"
        },
        "post": {
            "pq->num_prec": "==num_prec",
            "pq->max": "==max_len"
        }
    }
},
{
    "kprobe:brcmu_pktq_init": {
        "description": "Initialize a packet queue. pq is variable size; only zero out what's requested.",
        "proto" :"void brcmu_pktq_init(struct pktq *pq, int num_prec, int max_len)",
        "pre": {
            "pq": "!=null",
            "num_prec": ">=0",
            "max_len": ">=0"
        },
    }
},
{
    "kretprobe:ath_hw_setbssidmask": {
        "description": "Filter out bssids we listen. BSSID masking is a method used by AR5212 and newer hardware to inform PCU which bits of the interface's MAC address should be looked at when trying to decide which packets to ACK.",
        "proto": "void (*ath_hw_setbssidmask)(struct ath_common *common)",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kprobe:ath_hw_setbssidmask": {
        "description": "Filter out BSSIDs we listen to by creating a BSSID mask.",
        "proto": "void ath_hw_setbssidmask(struct ath_common *common)",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kretprobe:ath_hw_cycle_counters_update": {
        "description": "Common function to update cycle counters. This function is used to update all cycle counters in one place. It has to be called while holding common->cc_lock!",
        "proto" :"void (*ath_hw_cycle_counters_update)(struct ath_common *common)",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kprobe:ath_hw_cycle_counters_update": {
        "description": "Common function to update cycle counters. This function is used to update all cycle counters in one place. It has to be called while holding common->cc_lock!",
        "proto" :"void (*ath_hw_cycle_counters_update)(struct ath_common *common)",
        "pre": {
            "common": "!=null"
        }
    }
},
{
    "kretprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address in the hardware key table. If the MAC address is NULL or the entry is out of range, the function returns false. Otherwise, it sets the MAC address and returns true.",
        "proto": "bool (*ath_hw_keysetmac)(struct ath_common *common, u16 entry, const u8 *mac)",
        "pre": {
            "common": "!=null",
            "entry": "< common->keymax",
            "mac": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:ath_hw_keysetmac": {
        "description": "Sets the MAC address for a given key entry. AR_KEYTABLE_VALID indicates that the address is a unicast address, which must match the transmitter address for decrypting frames. Not setting this bit allows the hardware to use the key for multicast frame decryption.",
        "proto" :"bool (*ath_hw_keysetmac)(struct ath_common *common, u16 entry, const u8 *mac)",
        "pre": {
            "common": "!=null",
            "entry": "< common->keymax",
            "mac": "!=null"
        },
        "post": {
            "unicast_flag": "in [0, AR_KEYTABLE_VALID]",
            "macLo": "is valid u32",
            "macHi": "is valid u32"
        }
    }
},
{
    "kretprobe:ath_key_config": {
        "description": "This function configures the key for the ath device.",
        "proto" :"static int (*ath_key_config)(struct ath_common *common, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key)",
        "pre": {
            "common": "!=null",
            "vif": "!=null",
            "sta": "!=null",
            "key": "!=null"
        },
        "post": {
            "return": "in [-EOPNOTSUPP, -EIO, 0]"
        }
    }
},
{
    "kprobe:ath_key_config": {
        "description": "Configures the key for the ath device.",
        "proto" :"int ath_key_config(struct ath_common *common, struct ieee80211_vif *vif, struct ieee80211_sta *sta, struct ieee80211_key_conf *key)",
        "pre": {
            "common": "!=null",
            "vif": "!=null",
            "sta": "!=null",
            "key": "!=null && key->cipher in [0, WLAN_CIPHER_SUITE_WEP40, WLAN_CIPHER_SUITE_WEP104, WLAN_CIPHER_SUITE_TKIP, WLAN_CIPHER_SUITE_CCMP] && key->keylen >= 0",
        },
    }
},
{
    "kretprobe:ath_key_delete": {
        "description": "Leave CCMP and TKIP (main key) configured to avoid disabling encryption for potentially pending frames already in a TXQ with the keyix pointing to this key entry. Instead, only clear the MAC address to prevent RX processing from using this key cache entry.",
        "proto" :"static void (*ath_key_delete)(struct ath_common *common, u8 hw_key_idx)",
        "pre": {
            "common": "!=null",
            "hw_key_idx": "in [0, IEEE80211_WEP_NKID-1]"
        },
    }
},
{
    "kprobe:ath_key_delete": {
        "description": "Leave CCMP and TKIP (main key) configured to avoid disabling encryption for potentially pending frames already in a TXQ with the keyix pointing to this key entry. Instead, only clear the MAC address to prevent RX processing from using this key cache entry.",
        "proto" :"static void (*ath_key_delete)(struct ath_common *common, u8 hw_key_idx)",
        "pre": {
            "common": "!=null",
            "hw_key_idx": "in [0, 255]",
        },
    }
},
{
    "kretprobe:ath_is_49ghz_allowed": {
        "description": "This function checks if 4.9GHz is allowed for the given regulatory domain.",
        "proto" :"static bool (*ath_is_49ghz_allowed)(u16 regdomain)",
        "pre": {
            "regdomain": "is a valid regulatory domain code"
        },
    }
},
{
    "kprobe:ath_is_49ghz_allowed": {
        "description": "Check if 4.9GHz is allowed for the given regdomain.",
        "proto" :"static bool (*ath_is_49ghz_allowed)(u16 regdomain)",
        "pre": {
            "regdomain": "in [MKK9_MKKC, ...]" // replace ... with other possible values
        },
    }
},
{
    "kretprobe:ath_reg_apply_radar_flags": {
        "description": "This would happen when we have sent a custom regulatory request a world regulatory domain and the scheduler hasn't yet processed any pending requests in the queue.",
        "proto" :"void ath_reg_apply_radar_flags(struct wiphy *wiphy, struct ath_regulatory *reg)",
        "pre": {
            "wiphy": "!=null",
            "reg": "!=null"
        },
    }
},
{
    "kprobe:ath_reg_apply_radar_flags": {
        "description": "This function applies radar flags when a custom regulatory request has been sent and the scheduler hasn't yet processed any pending requests in the queue.",
        "proto" :"void ath_reg_apply_radar_flags(struct wiphy *wiphy, struct ath_regulatory *reg)",
        "pre": {
            "wiphy": "!=null",
            "reg": "!=null"
        },
    }
},
{
    "kretprobe:ath_regd_init": {
        "description": "This is a set of common rules used by our world regulatory domains. We have 12 world regulatory domains. To save space we consolidate the regulatory domains in 5 structures by frequency and change the flags on our reg_notifier() on a case by case basis.",
        "proto" :"ath_regd_init(struct ath_regulatory  reg)",
        "pre": {
            "reg": "!=null"
        }
    }
},
{
    "kprobe:ath_regd_init": {
        "description": "This is a set of common rules used by our world regulatory domains. We have 12 world regulatory domains. To save space we consolidate the regulatory domains in 5 structures by frequency and change the flags on our reg_notifier() on a case by case basis.",
        "proto" :"ath_regd_init(struct ath_regulatory  reg)",
        "pre": {
            "reg": "!=null",
        },
    }
},

{
    "kprobe:ath_rxbuf_alloc": {
        "description": "Cache-line-align. This is important (for the 5210 at least) as not doing so causes bogus data in rx'd frames.",
        "proto" :"ath_rxbuf_alloc(struct ath_common  common,u32 len,gfp_t gfp_mask)",
        "pre": {
            "common": "!=null",
            "len": ">=3849 && <=4096",
            "gfp_mask": "!=null",
        },
    }
},


{
    "kretprobe:ath6kl_core_init": {
        "description": "Initializes the ath6kl core. It attaches the appropriate HTC type, creates a singlethread workqueue, initializes the BMI, and turns on power to get hardware (target) version.",
        "proto" :"int ath6kl_core_init(struct ath6kl *ar, enum ath6kl_htc_type htc_type)",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]"
        },
        "post": {
            "ret": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:ath6kl_core_init": {
        "description": "Initializes the ath6kl core. Turns on power to get hardware (target) version and leaves power on deliberately as we will boot the hardware anyway within few seconds.",
        "proto" :"int ath6kl_core_init(struct ath6kl *ar, enum ath6kl_htc_type htc_type)",
        "pre": {
            "ar": "!=null",
            "htc_type": "in [ATH6KL_HTC_TYPE_MBOX, ATH6KL_HTC_TYPE_PIPE]",
        },
    }
},

{
    "kprobe:ath6kl_core_create": {
        "description": "Create an ath6kl core with specific configurations.",
        "proto" :"static struct ath6kl *(*ath6kl_core_create)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "ar": "!=null",
            "ar->p2p": "in [0, 1]",
            "ar->dev": "==dev",
            "ar->vif_max": "==1",
            "ar->max_norm_iface": "==1",
            "ar->tx_pwr": "==0",
            "ar->intra_bss": "==1",
            "ar->lrssi_roam_threshold": "==DEF_LRSSI_ROAM_THRESHOLD",
            "ar->state": "==ATH6KL_STATE_OFF",
            "ar->sta_list": "all elements are 0"
        }
    }
},
{
    "kretprobe:trace_ath6kl_log_dbg_dump": {
        "description": "Prints debug information if the debug mask matches. Tracing code doesn't like null strings.",
        "proto" :"void trace_ath6kl_log_dbg_dump(enum ATH6K_DEBUG_MASK mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "mask": "in [ATH6K_DEBUG_MASK]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kprobe:ath6kl_dbg_dump": {
        "description": "Prints debug information if the debug mask matches. The tracing code doesn't like null strings.",
        "proto" :"void ath6kl_dbg_dump(enum ATH6K_DEBUG_MASK mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "mask": "in [ATH6K_DEBUG_MASK values]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0",
        },
    }
},


{
    "kretprobe:ath6kl_cfg80211_suspend": {
        "description": "Suspend the ath6kl device with given mode and wowlan configuration. Flush all non control pkts in TX path.",
        "proto" :"static int (*ath6kl_cfg80211_suspend)(struct ath6kl *ar, enum ath6kl_cfg_suspend_mode mode, struct cfg80211_wowlan *wow)",
        "pre": {
            "ar": "!=null",
            "mode": "in [ATH6KL_CFG_SUSPEND_WOW]",
            "wow": "!=null"
        },
    }
},


{
    "kprobe:ath9k_cmn_beacon_config_sta": {
        "description": "No need to configure beacon if we are not associated",
        "proto" :"void ath9k_cmn_beacon_config_sta(struct ath_hw *ah, struct ath_beacon_config *conf, struct ath9k_beacon_state *bs)",
        "pre": {
            "ah": "!=null",
            "conf": "!=null",
            "bs": "!=null",
            "common": "!=null",
            "ATH_OP_PRIM_STA_VIF": "in [0, 1]",
            "common->op_flags": "!=null"
        },
    }
},

{
    "kprobe:ath9k_cmn_beacon_config_ap": {
        "description": "Please fill in the description here",
        "proto" :"static void (*ath9k_cmn_beacon_config_ap)(struct ath_hw *ah, struct ath_beacon_config *conf, unsigned int bc_buf)",
        "pre": {
            "ah": "!=null",
            "conf": "!=null",
            "bc_buf": "Please fill in the condition here",
        },
    }
},
{
    "kretprobe:ath9k_hw_btcoex_init_scheme": {
        "description": "Check if BTCOEX is globally disabled.",
        "proto" :"static void (*ath9k_hw_btcoex_init_scheme)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "common->btcoex_enabled": "in [true, false]"
        }
    }
},

{
    "kretprobe:ath9k_hw_btcoex_init_2wire": {
        "description": "Connect bt_active to baseband",
        "proto" :"void ath9k_hw_btcoex_init_2wire(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null",
            "AR_GPIO_INPUT_EN_VAL(ah)": "!=null",
            "AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_DEF": "!=null",
            "AR_GPIO_INPUT_EN_VAL_BT_FREQUENCY_DEF": "!=null",
            "AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB": "!=null"
        },
    }
},
{
    "kprobe:ath9k_hw_btcoex_init_2wire": {
        "description": "connect bt_active to baseband",
        "proto" :"static void (*ath9k_hw_btcoex_init_2wire)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:REG_SET_BIT": {
        "description": "Sets a bit in a register. Used in the ath9k_hw_btcoex_init_3wire function for initializing 3-wire Bluetooth coexistence.",
        "proto" :"void REG_SET_BIT(struct ath_hw *ah, int AR_GPIO_INPUT_EN_VAL(struct ath_hw *ah), int AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB | AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB)",
        "pre": {
            "ah": "!=null",
            "AR_GPIO_INPUT_EN_VAL(ah)": "is valid register",
            "AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB | AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB": "is valid bit mask"
        },
    }
},
{
    "kprobe:REG_SET_BIT": {
        "description": "Sets a specific bit in the register of the given hardware.",
        "proto" :"void REG_SET_BIT(struct ath_hw *ah, int AR_GPIO_INPUT_EN_VAL(struct ath_hw *ah), int AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB | AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB)",
        "pre": {
            "ah": "!=null",
            "AR_GPIO_INPUT_EN_VAL(struct ath_hw *ah)": "is valid register",
            "AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB | AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB": "is valid bit mask"
        },
    }
},
{
    "kretprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for btcoex hardware.",
        "proto" :"static void (*ath9k_hw_btcoex_set_weight)(struct ath_hw *ah, u32 bt_weight, u32 wlan_weight, enum ath_stomp_type stomp_type)",
        "pre": {
            "ah": "!=null",
            "bt_weight": "is a valid u32 value",
            "wlan_weight": "is a valid u32 value",
            "stomp_type": "is a valid enum ath_stomp_type value"
        }
    }
},
{
    "kprobe:ath9k_hw_btcoex_set_weight": {
        "description": "Set the weight for bt and wlan, and the stomp type.",
        "proto" :"static void (*ath9k_hw_btcoex_set_weight)(struct ath_hw *ah, u32 bt_weight, u32 wlan_weight, enum ath_stomp_type stomp_type)",
        "pre": {
            "ah": "!=null",
            "bt_weight": "is u32",
            "wlan_weight": "is u32",
            "stomp_type": "is enum ath_stomp_type",
        },
    }
},
{
    "kretprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "proto" :"static long (*ath9k_hw_gpio_request_out)(struct ath_hw *ah, int btcoex_hw->wlanactive_gpio, const char *label, int mux)",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": "is valid GPIO port",
            "label": "!=null && == 'ath9k-wlanactive'",
            "mux": "== AR_GPIO_OUTPUT_MUX_AS_TX_FRAME"
        }
    }
},
{
    "kprobe:ath9k_hw_gpio_request_out": {
        "description": "Configure the desired GPIO port for TX_FRAME output",
        "proto" :"static long (*ath9k_hw_gpio_request_out)(struct ath_hw *ah, int btcoex_hw->wlanactive_gpio, const char *label, u8 gpio_function)",
        "pre": {
            "ah": "!=null",
            "btcoex_hw->wlanactive_gpio": ">=0",
            "label": "!=null",
            "gpio_function": "in [AR_GPIO_OUTPUT_MUX_AS_TX_FRAME]"
        },
    }
},
{
    "kretprobe:ath9k_hw_btcoex_bt_stomp": {
        "description": "Configures appropriate weight based on stomp type.",
        "proto" :"void (*ath9k_hw_btcoex_bt_stomp)(struct ath_hw *ah, enum ath_stomp_type stomp_type)",
        "pre": {
            "ah": "!=null",
            "stomp_type": "in [ATH_BTCOEX_STOMP_NONE, ATH_BTCOEX_STOMP_ALL, ATH_BTCOEX_STOMP_LOW, ATH_BTCOEX_STOMP_HIGH]"
        }
    }
},

{
    "kretprobe:ar9003_paprd_enable": {
        "description": "3 bits for modalHeader5G.papdRateMaskHt20 is used for sub-band disabling of PAPRD. 5G band is divided into 3 sub-bands -- upper, middle, lower. If bit 30 of modalHeader5G.papdRateMaskHt20 is set -- disable PAPRD for upper band 5GHz. If bit 29 of modalHeader5G.papdRateMaskHt20 is set -- disable PAPRD for middle band 5GHz. If bit 28 of modalHeader5G.papdRateMaskHt20 is set -- disable PAPRD for lower band 5GHz.",
        "proto" :"static void (*ar9003_paprd_enable)(struct ath_hw *ah, bool val)",
        "pre": {
            "ah": "!=null",
            "val": "is bool"
        },
    }
},
{
    "kprobe:ar9003_paprd_enable": {
        "description": "Enables or disables PAPRD for different 5GHz bands based on the bits set in modalHeader5G.papdRateMaskHt20. The 5G band is divided into 3 sub-bands -- upper, middle, lower. If bit 30 of modalHeader5G.papdRateMaskHt20 is set, it disables PAPRD for upper band 5GHz. If bit 29 of modalHeader5G.papdRateMaskHt20 is set, it disables PAPRD for middle band 5GHz. If bit 28 of modalHeader5G.papdRateMaskHt20 is set, it disables PAPRD for lower band 5GHz.",
        "proto" :"static void (*ar9003_paprd_enable)(struct ath_hw *ah, bool val)",
        "pre": {
            "ah": "!=null",
            "val": "is boolean",
            "ah->curchan": "!=null",
            "IS_CHAN_2GHZ(ah->curchan)": "is boolean",
            "modalHeader5G.papdRateMaskHt20": "is 3-bit integer"
        },
    }
},
{
    "kretprobe:ar9003_paprd_populate_single_table": {
        "description": "Populates a single table for the ar9003 paprd.",
        "proto" :"void ar9003_paprd_populate_single_table(struct ath_hw *ah, struct ath9k_hw_cal_data *caldata, int chain)",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null",
            "chain": "in [0, 1, 2]"
        },
    }
},
{
    "kprobe:ar9003_paprd_populate_single_table": {
        "description": "Populates a single table for the ar9003 paprd.",
        "proto" :"void ar9003_paprd_populate_single_table(struct ath_hw *ah, struct ath9k_hw_cal_data *caldata, int chain)",
        "pre": {
            "ah": "!=null",
            "caldata": "!=null",
            "chain": "in [0, 1, 2]"
        },
        "post": {
            "REG_RMW_FIELD": {
                "ah": "!=null",
                "AR_PHY_PAPRD_CTRL1_B2": "is valid register",
                "AR_PHY_PAPRD_CTRL1_PAPRD_POWER_AT_AM2AM_CAL": "is valid field",
                "training_power": "is valid power value"
            }
        }
    }
},
{
    "kretprobe:ar9003_paprd_is_done": {
        "description": "Checks if the training is done and if the agc2_pwr is within the ideal range. If not, retraining is done.",
        "proto" :"int ar9003_paprd_is_done(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "paprd_done": "in [0, 1]",
            "agc2_pwr": ">= PAPRD_IDEAL_AGC2_PWR_RANGE"
        }
    }
},
{
    "kprobe:ar9003_paprd_is_done": {
        "description": "Checks if the training is done. If the training is done, it checks if the agc2_pwr is within the ideal range. If not, retraining is done.",
        "proto" :"ar9003_paprd_is_done(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "paprd_done": "in [0, 1]",
            "agc2_pwr": ">= PAPRD_IDEAL_AGC2_PWR_RANGE if paprd_done == 1"
        }
    }
},

{
    "kprobe:ath9k_hw_loadnf": {
        "description": "Description of the function",
        "proto" :"Function prototype",
        "pre": {
            "ah": "Constraints for ah",
            "chan": "Constraints for chan",
            "h": "Constraints for h",
            "i": "Constraints for i",
            "j": "Constraints for j",
            "chainmask": "Constraints for chainmask",
            "common": "Constraints for common",
            "default_nf": "Constraints for default_nf",
            "bb_agc_ctl": "Constraints for bb_agc_ctl",
            "nfval": "Constraints for nfval"
        },
    }
},
{
    "kretprobe:ath9k_hw_bstuck_nfcal": {
        "description": "If beacons are stuck, the most likely cause is interference. Triggering a noise floor calibration at this point helps the hardware adapt to a noisy environment much faster. To ensure that we recover from stuck beacons quickly, let the baseband update the internal NF value itself, similar to what is being done after a full reset.",
        "proto" :"void ath9k_hw_bstuck_nfcal(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},
{
    "kprobe:ath9k_hw_bstuck_nfcal": {
        "description": "If beacons are stuck, the most likely cause is interference. Triggering a noise floor calibration at this point helps the hardware adapt to a noisy environment much faster. To ensure that we recover from stuck beacons quickly, let the baseband update the internal NF value itself, similar to what is being done after a full reset.",
        "proto" :"static void (*ath9k_hw_bstuck_nfcal)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null",
        },
    }
},
{
    "kretprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "proto" :"bool (*ar9003_hw_bb_watchdog_check)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_hw_bb_watchdog_check": {
        "description": "Returns true if a chip reset is required.",
        "proto" :"bool (*ar9003_hw_bb_watchdog_check)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},

{
    "kprobe:ar9003_hw_disable_phy_restart": {
        "description": "While receiving unsupported rate frame rx state machine gets into a state 0xb and if phy_restart happens in that state, BB would go hang. If RXSM is in 0xb state after first bb panic, ensure to disable the phy_restart.",
        "proto" :"void ar9003_hw_disable_phy_restart(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null",
            "ah->bb_watchdog_last_status": "in [AR_PHY_WATCHDOG_RX_OFDM_SM]",
            "ah->bb_hang_rx_ofdm": "in [0, 1]"
        },
    }
},
{
    "kretprobe:ath9k_hw_updatetxtriglevel": {
        "description": "Adjusts the frame trigger level. The frame trigger level specifies the minimum number of bytes, in units of 64 bytes, that must be DMA'ed into the PCU TX FIFO before the PCU will initiate sending the frame on the air. This can mean we initiate transmit before a full frame is on the PCU TX FIFO. Resets to 0x1 (meaning 64 bytes or a full frame, whichever occurs first). Caution must be taken to ensure to set the frame trigger level based on the DMA request size.",
        "proto" :"bool (*ath9k_hw_updatetxtriglevel)(struct ath_hw *ah, bool bIncTrigLevel)",
        "pre": {
            "ah": "!=null",
            "bIncTrigLevel": "in [true, false]"
        },
    }
},
{
    "kprobe:ath9k_hw_updatetxtriglevel": {
        "description": "Adjusts the frame trigger level. The frame trigger level specifies the minimum number of bytes, in units of 64 bytes, that must be DMA'ed into the PCU TX FIFO before the PCU will initiate sending the frame on the air. This can mean we initiate transmit before a full frame is on the PCU TX FIFO. Resets to 0x1 (meaning 64 bytes or a full frame, whichever occurs first). Caution must be taken to ensure to set the frame trigger level based on the DMA request size.",
        "proto" :"bool (*ath9k_hw_updatetxtriglevel)(struct ath_hw *ah, bool bIncTrigLevel)",
        "pre": {
            "ah": "!=null",
            "bIncTrigLevel": "in [true, false]"
        }
    }
},


{
    "kretprobe:ath9k_hw_resettxqueue": {
        "description": "Resets the TX queue in the ath9k hardware.",
        "proto": "bool (*ath9k_hw_resettxqueue)(struct ath_hw *ah, u32 q)",
        "pre": {
            "ah": "!=null",
            "q": "is a valid queue index"
        },
        "post": {
            "return": "is a boolean indicating success or failure of the operation"
        }
    }
},
{
    "kprobe:ath9k_hw_resettxqueue": {
        "description": "Resets the transmit queue for the given hardware and queue index.",
        "proto" :"bool (*ath9k_hw_resettxqueue)(struct ath_hw *ah, u32 q)",
        "pre": {
            "ah": "!=null",
            "q": ">=0"
        },
    }
},


{
    "kretprobe:ath9k_hw_stopdmarecv": {
        "description": "Stop DMA receive in ath9k hardware.",
        "proto" :"static void (*ath9k_hw_stopdmarecv)(struct ath_hw *ah, bool reset)",
        "pre": {
            "ah": "!=null",
            "reset": "in [true, false]"
        }
    }
},
{
    "kprobe:ath9k_hw_stopdmarecv": {
        "description": "Stops the DMA receive process.",
        "proto" :"static void (*ath9k_hw_stopdmarecv)(struct ath_hw *ah, bool reset)",
        "pre": {
            "ah": "!=null",
            "reset": "is bool"
        }
    }
},
{
    "kretprobe:ath9k_hw_init_config": {
        "description": "Initializes the configuration of the ath9k hardware. This includes setting various parameters such as beacon response times, whether to ignore external CCA, whether to use analog shift registers, and whether to use interrupt mitigation. It also sets the power level for the PLL if the hardware revision is 9462 or 9565. Serialization is used for PCI devices on non-uniprocessor systems to prevent concurrent reads/writes.",
        "proto" :"static void (*ath9k_hw_init_config)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath9k_hw_init_config": {
        "description": "This function initializes the configuration of the ath9k hardware. It sets various configuration parameters and checks for specific hardware revisions. It also handles serialization for certain devices to prevent concurrent reads/writes.",
        "proto" :"void ath9k_hw_init_config(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},

{
    "kprobe:ath9k_hw_init_global_settings": {
        "description": "Initializes global settings for the ath9k hardware.",
        "proto" :"void ath9k_hw_init_global_settings(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},
{
    "kretprobe:check_alive": {
        "description": "Check if chip failed to wake up",
        "proto" :"bool (*check_alive)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},





{
    "kretprobe:ath9k_hw_set_sta_beacon_timers": {
        "description": "Description of the function goes here",
        "proto" :"static long (*ath9k_hw_set_sta_beacon_timers)(struct ath_hw *ah, const struct ath9k_beacon_state *bs)",
        "pre": {
            "ah": "!=null",
            "bs": "!=null",
        },
    }
},

{
    "kretprobe:ath9k_hw_reset": {
        "description": "Resets the hardware represented by *ah*.",
        "proto" :"static long (*ath9k_hw_reset)(void *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},
{
    "kprobe:your_function_name": {
        "description": "Your function description here",
        "proto" :"Your function prototype here",
        "pre": {
            "arg1": "Your condition for arg1",
            "arg2": "Your condition for arg2",
            "arg3": "Your condition for arg3",
            "arg4": "Your condition for arg4",
        },
    }
},
{
    "kretprobe:[function name]": {
        "description": "[Function description]",
        "proto" :"[Function prototype]",
        "pre": {
            "[param1]": "[constraints]",
            "[param2]": "[constraints]",
            "[param3]": "[constraints]",
            "[param4]": "[constraints]",
        },
    }
},




{
    "kprobe:ath9k_hw_init_desc": {
        "description": "Initializes the descriptor of the ath9k hardware.",
        "proto" :"static void ath9k_hw_init_desc(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},




{
    "kretprobe:ath_gen_timer_alloc": {
        "description": "Allocate a hardware generic timer slot.",
        "proto": "struct ath_gen_timer *(*ath_gen_timer_alloc)(struct ath_hw *ah, void (*trigger)(void), void (*overflow)(void), void *arg, u8 timer_index)",
        "pre": {
            "ah": "!=null",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index": "in [AR_FIRST_NDP_TIMER, ATH_MAX_GEN_TIMER)"
        },
        "post": {
            "timer_table->timers[timer_index]": "!=null",
            "timer->index": "=timer_index",
            "timer->trigger": "=trigger",
            "timer->overflow": "=overflow",
            "timer->arg": "=arg",
            "timer_table->tsf2_enabled": "!=true if timer_index > AR_FIRST_NDP_TIMER"
        }
    }
},
{
    "kprobe:ath_gen_timer_alloc": {
        "description": "Allocate a hardware generic timer slot.",
        "proto": "struct ath_gen_timer_alloc(struct ath_hw *ah, void (*trigger)(void), void (*overflow)(void), void *arg, u8 timer_index)",
        "pre": {
            "ah": "!=null",
            "trigger": "!=null",
            "overflow": "!=null",
            "arg": "!=null",
            "timer_index": "in [AR_FIRST_NDP_TIMER, ATH_MAX_GEN_TIMER)"
        },
        "post": {
            "timer_table->timers[timer_index]": "!=null",
            "timer->index": "=timer_index",
            "timer->trigger": "=trigger",
            "timer->overflow": "=overflow",
            "timer->arg": "=arg",
            "timer_table->tsf2_enabled": "!=null if timer_index > AR_FIRST_NDP_TIMER"
        }
    }
},

{
    "kprobe:ath9k_hw_gen_timer_stop": {
        "description": "Clear generic timer enable bits.",
        "proto" :"void ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)",
        "pre": {
            "ah": "!=null",
            "timer": "!=null"
        }
    }
},
{
    "kretprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "proto" :"static void (*ath_gen_timer_free)(struct ath_hw *ah, struct ath_gen_timer *timer)",
        "pre": {
            "ah": "!=null",
            "timer": "!=null"
        },
    }
},
{
    "kprobe:ath_gen_timer_free": {
        "description": "Free the hardware generic timer slot.",
        "proto" :"static void (*ath_gen_timer_free)(struct ath_hw *ah, struct ath_gen_timer *timer)",
        "pre": {
            "ah": "!=null",
            "timer": "!=null"
        }
    }
},
{
    "kretprobe:ath_gen_timer_isr": {
        "description": "Get hardware generic timer interrupt status",
        "proto" :"void ath_gen_timer_isr(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null",
            "ah->intr_gen_timer_trigger": "is valid"
        },
        "post": {
            "trigger_mask": "is valid"
        }
    }
},
{
    "kprobe:ath_gen_timer_isr": {
        "description": "Get hardware generic timer interrupt status.",
        "proto" :"static void (*ath_gen_timer_isr)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        },
    }
},
{
    "kretprobe:ath9k_hw_name": {
        "description": "Chipsets >= AR9280 are single-chip",
        "proto" :"static void (*ath9k_hw_name)(struct ath_hw *ah, char *hw_name, size_t len)",
        "pre": {
            "ah": "!=null",
            "hw_name": "!=null",
            "len": "> 0"
        },
    }
},
{
    "kprobe:ath9k_hw_name": {
        "description": "ath9k_hw_name is a function in the ath9k driver. It takes a struct ath_hw pointer, a char pointer for hw_name, and a size_t len as arguments. It checks if the chipset is AR9280 or later.",
        "proto" :"void ath9k_hw_name(struct ath_hw *ah, char *hw_name, size_t len)",
        "pre": {
            "ah": "!=null",
            "hw_name": "!=null",
            "len": ">=0",
            "chipsets": ">=AR9280"
        },
    }
},
{
    "kretprobe:ath9k_cmn_setup_ht_cap": {
        "description": "Set up supported mcs set",
        "proto" :"void ath9k_cmn_setup_ht_cap(struct ath_hw *ah, struct ieee80211_sta_ht_cap *ht_info)",
        "pre": {
            "ah": "!=null",
            "ht_info": "!=null"
        },
        "post": {
            "ht_info->ht_supported": "==true",
            "ht_info->cap": "in [IEEE80211_HT_CAP_SUP_WIDTH_20_40, IEEE80211_HT_CAP_SM_PS, IEEE80211_HT_CAP_SGI_40, IEEE80211_HT_CAP_DSSSCCK40, IEEE80211_HT_CAP_LDPC_CODING, IEEE80211_HT_CAP_SGI_20]",
            "ht_info->ampdu_factor": "==IEEE80211_HT_MAX_AMPDU_64K",
            "ht_info->ampdu_density": "==IEEE80211_HT_MPDU_DENSITY_8",
            "max_streams": "in [1, 2, 3]",
            "tx_streams": "in [1, 2, 3]",
            "rx_streams": "in [1, 2, 3]"
        }
    }
},
{
    "kprobe:ath9k_cmn_setup_ht_cap": {
        "description": "Set up supported mcs set",
        "proto" :"void ath9k_cmn_setup_ht_cap(struct ath_hw *ah, struct ieee80211_sta_ht_cap *ht_info)",
        "pre": {
            "ah": "!=null",
            "ht_info": "!=null",
            "ah->caps.hw_caps": "in [ATH9K_HW_CAP_LDPC, ATH9K_HW_CAP_SGI_20, ...]",
            "ht_info->ht_supported": "==true",
            "ht_info->cap": "in [IEEE80211_HT_CAP_SUP_WIDTH_20_40, IEEE80211_HT_CAP_SM_PS, IEEE80211_HT_CAP_SGI_40, IEEE80211_HT_CAP_DSSSCCK40, ...]",
            "ht_info->ampdu_factor": "==IEEE80211_HT_MAX_AMPDU_64K",
            "ht_info->ampdu_density": "==IEEE80211_HT_MPDU_DENSITY_8",
            "max_streams": "in [1, 2, 3]",
            "tx_streams": "in [1, 2, 3]",
            "rx_streams": "in [1, 2, 3]"
        },
    }
},


{
    "kretprobe:ath9k_cmn_rx_accept": {
        "description": "Description of the function",
        "proto" :"static long (*ath9k_cmn_rx_accept)(struct ath_common  common, struct ieee80211_hdr  hdr, struct ieee80211_rx_status  rxs, struct ath_rx_status  rx_stats, bool  decrypt_error, unsigned int rxfilter)",
        "pre": {
            "common": "!=null",
            "hdr": "!=null",
            "rxs": "!=null",
            "rx_stats": "!=null",
            "decrypt_error": "is boolean",
            "rxfilter": "is unsigned int"
        },
    }
},
{
    "kprobe:ath9k_cmn_rx_accept": {
        "description": "Accepts a received packet based on various conditions.",
        "proto" :"static bool (*ath9k_cmn_rx_accept)(struct ath_common *common, struct ieee80211_hdr *hdr, struct ieee80211_rx_status *rxs, struct ath_rx_status *rx_stats, bool decrypt_error, unsigned int rxfilter)",
        "pre": {
            "common": "!=null",
            "hdr": "!=null",
            "rxs": "!=null",
            "rx_stats": "!=null",
            "rx_stats->rs_keyix": "!= ATH9K_RXKEYIX_INVALID",
            "test_bit(rx_stats->rs_keyix, common->ccmp_keymap)": "== true",
            "test_bit(rx_stats->rs_keyix, common->tkip_keymap)": "== true",
            "decrypt_error": "is boolean",
            "rxfilter": "is unsigned int"
        },
    }
},
{
    "kretprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "See if any padding is done by the hw and remove it.",
        "proto" :"static void (*ath9k_cmn_rx_skb_postprocess)(struct ath_common *common, struct sk_buff *skb, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs, bool decrypt_error)",
        "pre": {
            "common": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "decrypt_error": "in [true, false]"
        }
    }
},
{
    "kprobe:ath9k_cmn_rx_skb_postprocess": {
        "description": "Your description here",
        "proto" :"static void (*ath9k_cmn_rx_skb_postprocess)(struct ath_common *common, struct sk_buff *skb, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs, bool decrypt_error)",
        "pre": {
            "common": "Your condition here",
            "skb": "Your condition here",
            "rx_stats": "Your condition here",
            "rxs": "Your condition here",
            "decrypt_error": "Your condition here"
        },
    }
},
{
    "kretprobe:ath9k_cmn_process_rate": {
        "description": "Process the rate of ath9k.",
        "proto" :"static void (*ath9k_cmn_process_rate)(struct ath_common *common, struct ieee80211_hw *hw, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs)",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null"
        },
    }
},
{
    "kprobe:ath9k_cmn_process_rate": {
        "description": "Process the rate of ath9k",
        "proto" :"void ath9k_cmn_process_rate(struct ath_common *common, struct ieee80211_hw *hw, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs)",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null"
        },
    }
},
{
    "kretprobe:ath9k_cmn_process_rssi": {
        "description": "RSSI is not available for subframes in an A-MPDU.",
        "proto" :"void ath9k_cmn_process_rssi(struct ath_common *common, struct ieee80211_hw *hw, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs)",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null"
        },
    }
},
{
    "kprobe:ath9k_cmn_process_rssi": {
        "description": "RSSI is not available for subframes in an A-MPDU.",
        "proto" :"void ath9k_cmn_process_rssi(struct ath_common *common, struct ieee80211_hw *hw, struct ath_rx_status *rx_stats, struct ieee80211_rx_status *rxs)",
        "pre": {
            "common": "!=null",
            "hw": "!=null",
            "rx_stats": "!=null",
            "rxs": "!=null",
            "rx_stats->rs_moreaggr": "in [0, 1]"
        },
    }
},
{
    "kretprobe:ath9k_cmn_update_txpow": {
        "description": "Please provide a description for this function.",
        "proto" :"void ath9k_cmn_update_txpow(struct ath_hw *ah, u16 cur_txpow, u16 new_txpow, u16 txpower)",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "Please provide constraints for this parameter.",
            "new_txpow": "Please provide constraints for this parameter.",
            "txpower": "Please provide constraints for this parameter."
        },
    }
},
{
    "kprobe:ath9k_cmn_update_txpow": {
        "description": "Updates the transmit power. If the current channel is set and the power limit is not equal to the new transmit power, the transmit power limit is set to the new value. The value is read back in case it is clamped.",
        "proto": "void ath9k_cmn_update_txpow(struct ath_hw *ah, u16 cur_txpow, u16 new_txpow, u16 *txpower)",
        "pre": {
            "ah": "!=null",
            "cur_txpow": "is u16",
            "new_txpow": "is u16",
            "txpower": "!=null"
        }
    }
},


{
    "kretprobe:ath9k_hw_wow_wakeup": {
        "description": "Read the WoW status register to know the wakeup reason.",
        "proto" :"static long (*ath9k_hw_wow_wakeup)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},

{
    "kretprobe:ath9k_hw_wow_enable": {
        "description": "Set the power states appropriately and enable PME. Set and clear WOW_PME_CLEAR for the chip to generate next wow signal.",
        "proto" :"static long (*ath9k_hw_wow_enable)(struct ath_hw *ah, u32 pattern_enable)",
        "pre": {
            "ah": "!=null",
            "pattern_enable": "your_condition_here"
        },
    }
},
{
    "kprobe:ath9k_hw_wow_enable": {
        "description": "Set the power states appropriately and enable PME. Set and clear WOW_PME_CLEAR for the chip to generate next wow signal.",
        "proto" :"static long (*ath9k_hw_wow_enable)(struct ath_hw  ah, u32 pattern_enable)",
        "pre": {
            "ah": "!=null",
            "pattern_enable": "in [AR_PMCTRL_HOST_PME_EN, AR_PMCTRL_PWR_PM_CTRL_ENA, AR_PMCTRL_AUX_PWR_DET, AR_PMCTRL_WOW_PME_CLR]",
        },
    }
},
{
    "kretprobe:ath_dynack_sample_tx_ts": {
        "description": "status timestamp sampling method",
        "proto" :"void (*ath_dynack_sample_tx_ts)(struct ath_hw *ah, struct sk_buff *skb, struct ath_tx_status *ts, struct ieee80211_sta *sta)",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_sample_tx_ts": {
        "description": "status timestamp sampling method",
        "proto" :"void (*ath_dynack_sample_tx_ts)(struct ath_hw *ah, struct sk_buff *skb, struct ath_tx_status *ts, struct ieee80211_sta *sta)",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": "!=null",
            "sta": "!=null"
        },
    }
},
{
    "kretprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method @ah: ath hw @skb: socket buffer @ts: rx timestamp",
        "proto" :"void (*ath_dynack_sample_ack_ts)(struct ath_hw *ah, struct sk_buff *skb, u32 ts)",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": ">=0",
        },
    }
},
{
    "kprobe:ath_dynack_sample_ack_ts": {
        "description": "ACK timestamp sampling method",
        "proto" :"void (*ath_dynack_sample_ack_ts)(struct ath_hw *ah, struct sk_buff *skb, u32 ts)",
        "pre": {
            "ah": "!=null",
            "skb": "!=null",
            "ts": ">=0",
        },
    }
},
{
    "kretprobe:ath_dynack_node_init": {
        "description": "Init ath_node related info",
        "proto" :"void (*ath_dynack_node_init)(struct ath_hw *ah, struct ath_node *an)",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_init": {
        "description": "Init ath_node related info",
        "proto" :"void (*ath_dynack_node_init)(struct ath_hw *ah, struct ath_node *an)",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_node_deinit": {
        "description": "Deinit ath_node related info",
        "proto" :"void (*ath_dynack_node_deinit)(struct ath_hw *ah, struct ath_node *an)",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_node_deinit": {
        "description": "Deinit ath_node related info",
        "proto" :"void (*ath_dynack_node_deinit)(struct ath_hw *ah, struct ath_node *an)",
        "pre": {
            "ah": "!=null",
            "an": "!=null"
        }
    }
},
{
    "kretprobe:ath_dynack_reset": {
        "description": "Reset dynack processing @ah: ath hw",
        "proto" :"void (*ath_dynack_reset)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ath_dynack_reset": {
        "description": "Reset dynack processing",
        "proto": "void (*ath_dynack_reset)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_mci_get_interrupt": {
        "description": "Clean int bits after the values are read.",
        "proto" :"void ar9003_mci_get_interrupt(struct ath_hw *ah, u32 raw_intr, u32 rx_msg_intr)",
        "pre": {
            "ah": "!=null",
            "raw_intr": "is u32",
            "rx_msg_intr": "is u32"
        },
    }
},
{
    "kprobe:ar9003_mci_get_interrupt": {
        "description": "Reads the values of raw_intr and rx_msg_intr from the mci structure, then cleans the int bits.",
        "proto" :"void ar9003_mci_get_interrupt(struct ath_hw *ah, u32 *raw_intr, u32 *rx_msg_intr)",
        "pre": {
            "ah": "!=null",
            "raw_intr": "!=null",
            "rx_msg_intr": "!=null"
        },
    }
},
{
    "kretprobe:ar9003_mci_send_message": {
        "description": "Placeholder description for ar9003_mci_send_message",
        "proto" :"static long (*ar9003_mci_send_message)(struct ath_hw *ah, u32 MCI_GPM, u32 zero, u32 *payload, u32 sixteen, bool wait_done, bool true)",
        "pre": {
            "ah": "!=null",
            "MCI_GPM": "Placeholder constraint",
            "zero": "==0",
            "payload": "!=null",
            "sixteen": "==16",
            "wait_done": "Placeholder constraint",
            "true": "==true"
        }
    }
},
{
    "kprobe:ar9003_mci_send_message": {
        "description": "Sends a message with a specific id, flag, payload, length, and two boolean parameters: wait_done and need_flush.",
        "proto" :"static long (*ar9003_mci_send_message)(struct ath_hw *ah, u32 id, u32 flag, void *payload, u32 len, bool wait_done, bool need_flush)",
        "pre": {
            "ah": "!=null",
            "id": ">=0",
            "flag": ">=0",
            "payload": "!=null",
            "len": ">=0",
            "wait_done": "in [true, false]",
            "need_flush": "in [true, false]"
        }
    }
},
{
    "kretprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "proto" :"void ar9003_mci_cleanup(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kprobe:ar9003_mci_cleanup": {
        "description": "Turn off MCI and Jupiter mode.",
        "proto" :"static void (*ar9003_mci_cleanup)(struct ath_hw *ah)",
        "pre": {
            "ah": "!=null"
        }
    }
},
{
    "kretprobe:ar9003_mci_get_interrupt": {
        "description": "This function gets the interrupt status of the MCI.",
        "proto": "void ar9003_mci_get_interrupt(struct ath_hw *ah, u32 raw_intr, u32 rx_msg_intr)",
        "pre": {
            "ah": "!=null",
            "raw_intr": ">=0",
            "rx_msg_intr": ">=0"
        }
    }
},
{
    "kprobe:ar9003_mci_get_interrupt": {
        "description": "Description of the function goes here.",
        "proto" :"void ar9003_mci_get_interrupt(struct ath_hw *ah, u32 raw_intr, u32 rx_msg_intr)",
        "pre": {
            "ah": "!=null",
            "raw_intr": "constraint goes here",
            "rx_msg_intr": "constraint goes here"
        },
    }
},

{
    "kprobe:ar9003_mci_get_next_gpm_offset": {
        "description": "Check if it's cal_grant. When we're waiting for cal_grant in reset routine, it's possible that BT sends out cal_request at the same time. Since BT's calibration doesn't happen that often, we'll let BT completes calibration then we continue to wait for cal_grant from BT. Orginal: Wait BT_CAL_GRANT. New: Receive BT_CAL_REQ -> send WLAN_CAL_GRANT->wait BT_CAL_DONE -> Wait BT_CAL_GRANT.",
        "proto" :"static long (*ar9003_mci_get_next_gpm_offset)(void *ah, const void *more_data)",
        "pre": {
            "ah": "!=null",
            "more_data": "!=null",
            "gpm_type": "== MCI_GPM_BT_CAL_GRANT",
            "recv_type": "== MCI_GPM_BT_CAL_REQ"
        },
    }
},
{
    "kretprobe:ath_cmn_process_fft": {
        "description": "AR9280 and before report via ATH9K_PHYERR_RADAR, AR93xx and newer via ATH9K_PHYERR_SPECTRAL. Haven't seen ATH9K_PHYERR_FALSE_RADAR_EXT yet, but this is supposed to be possible as well.",
        "proto" :"ath_cmn_process_fft(struct ath_spec_scan_priv  spec_priv, struct ieee80211_hdr  hdr, struct ath_rx_status  rs, u64 tsf)",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": "!=null",
            "tsf": "is a valid timestamp",
            "rs->rs_phyerr": "in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:ath_cmn_process_fft": {
        "description": "Process FFT for spectral scan. AR9280 and before report via ATH9K_PHYERR_RADAR, AR93xx and newer via ATH9K_PHYERR_SPECTRAL. Haven't seen ATH9K_PHYERR_FALSE_RADAR_EXT yet, but this is supposed to be possible as well.",
        "proto": "void ath_cmn_process_fft(struct ath_spec_scan_priv spec_priv, struct ieee80211_hdr hdr, struct ath_rx_status rs, u64 tsf)",
        "pre": {
            "spec_priv": "!=null",
            "hdr": "!=null",
            "rs": "!=null",
            "tsf": "is a valid timestamp",
            "rs->rs_phyerr": "in [ATH9K_PHYERR_RADAR, ATH9K_PHYERR_FALSE_RADAR_EXT, ATH9K_PHYERR_SPECTRAL]",
            "rs->rs_datalen": "is a valid data length",
            "spec_priv->ah": "!=null",
            "spec_priv->ah->curchan->chan->center_freq": "is a valid frequency"
        }
    }
},
{
    "kretprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "This function triggers the spectral scan. If the spectral scan is not enabled or not implemented on the hardware, the function will return without doing anything. Otherwise, it wakes up the power save operations, gets the current RX filter, and sets a new RX filter with additional flags for PHYRADAR and PHYERR.",
        "proto" :"static void (*ath9k_cmn_spectral_scan_trigger)(struct ath_common *common, struct ath_spec_scan_priv *spec_priv)",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "spec_priv->spec_config.enabled": "==true",
            "ath9k_hw_ops(spec_priv->ah)->spectral_scan_trigger": "!=null",
            "ath_ps_ops(common)->wakeup": "!=null",
            "ath9k_hw_getrxfilter(spec_priv->ah)": "!=null",
            "ath9k_hw_setrxfilter(spec_priv->ah, rxfilter | ATH9K_RX_FILTER_PHYRADAR | ATH9K_RX_FILTER_PHYERR)": "!=null"
        }
    }
},
{
    "kprobe:ath9k_cmn_spectral_scan_trigger": {
        "description": "Description of the function",
        "proto" :"ath9k_cmn_spectral_scan_trigger(struct ath_common  common, struct ath_spec_scan_priv  spec_priv)",
        "pre": {
            "common": "Condition for common",
            "spec_priv": "Condition for spec_priv",
        },
    }
},
{
    "kretprobe:ath9k_cmn_spectral_scan_config": {
        "description": "Configures the spectral scan.",
        "proto" :"int ath9k_cmn_spectral_scan_config(struct ath_common *common, struct ath_spec_scan_priv *spec_priv, enum spectral_mode spectral_mode)",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spectral_mode": "in [SPECTRAL_DISABLED, SPECTRAL_BACKGROUND, SPECTRAL_CHANSCAN, SPECTRAL_MANUAL]",
        },
    }
},
{
    "kprobe:ath9k_cmn_spectral_scan_config": {
        "description": "Configures the spectral scan.",
        "proto" :"int (*ath9k_cmn_spectral_scan_config)(struct ath_common *common, struct ath_spec_scan_priv *spec_priv, enum spectral_mode spectral_mode)",
        "pre": {
            "common": "!=null",
            "spec_priv": "!=null",
            "spec_priv->ah": "!=null",
            "spectral_mode": "in [SPECTRAL_DISABLED, SPECTRAL_BACKGROUND, SPECTRAL_CHANSCAN, SPECTRAL_MANUAL]"
        },
    }
},
{
    "kretprobe:ath11k_ce_get_shadow_config": {
        "description": "Get the shadow configuration of the ath11k. If the hardware doesn't support shadow registers, the function will return. If the shadow is not configured yet, it will be configured now. Non-CE srngs are configured firstly, then all CE srngs.",
        "proto" :"static void (*ath11k_ce_get_shadow_config)(struct ath11k_base *ab, u32 shadow_cfg, u32 shadow_cfg_len)",
        "pre": {
            "ab": "!=null",
            "shadow_cfg": "is a valid u32 value",
            "shadow_cfg_len": "is a valid u32 value"
        },
    }
},
{
    "kprobe:ath11k_ce_get_shadow_config": {
        "description": "Get the shadow configuration for the ath11k wireless driver. If the shadow configuration length is not zero, return immediately. Otherwise, configure the non-CE srngs first, then all CE srngs.",
        "proto" :"void ath11k_ce_get_shadow_config(struct ath11k_base *ab, u32 shadow_cfg, u32 shadow_cfg_len)",
        "pre": {
            "ab": "!=null",
            "shadow_cfg": "can be any u32 value",
            "shadow_cfg_len": "can be any u32 value"
        },
    }
},


{
    "kretprobe:ath11k_ce_alloc_pipes": {
        "description": "PLACEHOLDER_DESCRIPTION",
        "proto" :"static long (*ath11k_ce_alloc_pipes)(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null",
        },
    }
},

{
    "kretprobe:ath11k_core_get_single_pdev": {
        "description": "Get the single pdev from the ath11k_base structure. Only valid for chips that support single pdev.",
        "proto" :"struct ath11k_pdev *(*ath11k_core_get_single_pdev)(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null && ab->hw_params.supports_suspend == true"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:ath11k_core_get_single_pdev": {
        "description": "Get the single pdev from the ath11k_base structure. Only valid for chips that support single_pdev_only.",
        "proto" :"struct ath11k_pdev *(*ath11k_core_get_single_pdev)(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null && ab->hw_params.supports_suspend == true"
        },
    }
},
{
    "kretprobe:ath11k_core_resume": {
        "description": "Resumes the ath11k core. Only supports single pdev chips and the first pdev is valid.",
        "proto" :"int ath11k_core_resume(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.supports_suspend": "==true"
        },
        "post": {
            "return": "in [-EOPNOTSUPP, 0]"
        }
    }
},




{
    "kprobe:ath11k_dp_service_srng": {
        "description": "TODO: Provide a description for the function",
        "proto" :"ath11k_dp_service_srng(struct ath11k_base  ab,   struct ath11k_ext_irq_grp  irq_grp,   int budget)",
        "pre": {
            "ab": "!=null",
            "irq_grp": "!=null",
            "budget": ">=0",
        },
    }
},
{
    "kretprobe:ath11k_debugfs_soc_destroy": {
        "description": "Removes a debugfs directory and sets a pointer to NULL.",
        "proto" :"void ath11k_debugfs_soc_destroy(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null"
        },
    }
},
{
    "kprobe:ath11k_debugfs_soc_destroy": {
        "description": "Removes the debugfs_soc recursively from the ath11k_base structure and sets it to NULL. The ath11k directory is not removed on purpose, even if it would be empty. This simplifies the directory handling and it's a minor cosmetic issue to leave an empty ath11k directory to debugfs.",
        "proto" :"void ath11k_debugfs_soc_destroy(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null"
        }
    }
},
{
    "kretprobe:trace_ath11k_log_dbg_dump": {
        "description": "This function is used for debugging. It dumps the debug information based on the provided parameters.",
        "proto" :"void trace_ath11k_log_dbg_dump(struct ath11k_base *ab, enum ath11k_debug_mask mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "ab": "!=null",
            "mask": "in [ATH11K_DBG_BOOT, ATH11K_DBG_WMI, ATH11K_DBG_HTT, ATH11K_DBG_MAC, ATH11K_DBG_PCI, ATH11K_DBG_ANY]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">0"
        }
    }
},
{
    "kprobe:trace_ath11k_log_dbg_dump": {
        "description": "This function is used for debugging. It dumps the debug information into the kernel log. The function takes a base structure, a debug mask, a message, a prefix, a buffer, and a length as input. It then formats and prints the buffer content to the kernel log. The tracing code doesn't like null strings.",
        "proto" :"void trace_ath11k_log_dbg_dump(struct ath11k_base *ab, enum ath11k_debug_mask mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "ab": "!=null",
            "mask": "is an enum of type ath11k_debug_mask",
            "msg": "can be null, if null, an empty string is used",
            "prefix": "can be null, if null, an empty string is used",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:ath11k_pcic_write32": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto" :"void ath11k_pcic_write32(struct ath11k_base *ab, u32 offset, u32 value)",
        "pre": {
            "ab": "!=null",
            "offset": ">=0",
            "value": ">=0"
        },
        "post": {
            "ret": "in [0, 1]",
            "wakeup_required": "in [true, false]"
        }
    }
},
{
    "kprobe:ath11k_pcic_write32": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto" :"void ath11k_pcic_write32(struct ath11k_base *ab, u32 offset, u32 value)",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START",
            "value": "can be any u32 value"
        },
    }
},
{
    "kretprobe:ath11k_pcic_read32": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto": "u32 ath11k_pcic_read32(struct ath11k_base *ab, u32 offset)",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START && <= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        },
        "post": {
            "val": "!=null"
        }
    }
},
{
    "kprobe:ath11k_pcic_read32": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto" :"u32 ath11k_pcic_read32(struct ath11k_base *ab, u32 offset)",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START && <= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        },
    }
},
{
    "kretprobe:ath11k_pcic_read": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto": "u32 ath11k_pcic_read32(struct ath11k_base *ab, u32 offset)",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START && <= ATH11K_PCI_ACCESS_ALWAYS_OFF"
        },
        "post": {
            "val": "!=null",
            "ret": "==0",
            "wakeup_required": "== test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags)"
        }
    }
},
{
    "kprobe:ath11k_pcic_read32": {
        "description": "For offset beyond BAR + 4K - 32, may need to wakeup the device to access.",
        "proto" :"u32 ath11k_pcic_read32(struct ath11k_base  ab, u32 offset)",
        "pre": {
            "ab": "!=null",
            "offset": ">= ATH11K_PCI_WINDOW_START"
        },
    }
},
{
    "kretprobe:ath11k_pcic_ext_irq_enable": {
        "description": "In case of one MSI vector, we handle irq enabledisable in a uniform way since we only have one irq.",
        "proto" :"void ath11k_pcic_ext_irq_enable(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null"
        }
    }
},
{
    "kprobe:ath11k_pcic_ext_irq_enable": {
        "description": "In case of one MSI vector, we handle irq enabledisable in a uniform way since we only have one irq.",
        "proto" :"void ath11k_pcic_ext_irq_enable(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null"
        },
    }
},
{
    "kretprobe:ath11k_pcic_config_irq": {
        "description": "Configure CE irqs",
        "proto" :"int ath11k_pcic_config_irq(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null",
        },
    }
},
{
    "kprobe:ath11k_pcic_config_irq": {
        "description": "Configures CE irqs",
        "proto" :"int ath11k_pcic_config_irq(struct ath11k_base *ab)",
        "pre": {
            "ab": "!=null",
            "ab->hw_params.ce_count": ">=0",
            "ab->dev_flags": "is valid flag"
        },
    }
},
{
    "kretprobe:ath11k_pcic_register_pci_ops": {
        "description": "Return error if mandatory pci_ops callbacks are missing.",
        "proto" :"static long (*ath11k_pcic_register_pci_ops)(struct ath11k_base *ab, const struct ath11k_pci_ops *pci_ops)",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "pci_ops->get_msi_irq": "!=null",
            "pci_ops->window_write32": "!=null",
            "pci_ops->window_read32": "!=null"
        },
    }
},
{
    "kprobe:ath11k_pcic_register_pci_ops": {
        "description": "Return error if mandatory pci_ops callbacks are missing.",
        "proto" :"ath11k_pcic_register_pci_ops(struct ath11k_base  ab, const struct ath11k_pci_ops  pci_ops)",
        "pre": {
            "ab": "!=null",
            "pci_ops": "!=null",
            "pci_ops->get_msi_irq": "!=null",
            "pci_ops->window_write32": "!=null",
            "pci_ops->window_read32": "!=null"
        },
    }
},
{
    "kretprobe:ath10k_ce_send_nolock": {
        "description": "This function sends data without locking the CE pipe. It checks if the nbytes is more than the maximum source size, warns if it is, and checks if the ring delta is less than or equal to 0. If it is, it sets the return value to -ENOSR and exits. It then sets the descriptor flags based on the transfer_id and flags passed to it. It sets the address, nbytes, and flags of the sdesc, copies it to desc, and updates the per_transfer_context at the write_index.",
        "proto" :"void ath10k_ce_send_nolock(struct ath10k_ce_pipe ce_state, void per_transfer_context, dma_addr_t buffer, unsigned int nbytes, unsigned int transfer_id, unsigned int flags)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": "in [CE_SEND_FLAG_GATHER, CE_SEND_FLAG_BYTE_SWAP]"
        },
    }
},
{
    "kprobe:ath10k_ce_send_nolock": {
        "description": "This function sends data without locking the CE pipe. It checks if the nbytes is more than the maximum source size, warns if it is, and checks if the ring delta is less than or equal to 0. If it is, it sets the return value to -ENOSR and exits. It then sets the descriptor flags based on the transfer_id and flags passed to the function. It also sets the address, nbytes, and flags of the sdesc. The descriptor is then set to sdesc. The per_transfer_context at the write_index of the source ring is then set to the per_transfer_context passed to the function.",
        "proto" :"ath10k_ce_send_nolock(struct ath10k_ce_pipe  ce_state,  void  per_transfer_context,  dma_addr_t buffer,  unsigned int nbytes,  unsigned int transfer_id,  unsigned int flags)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": ">=0",
        },
    }
},

{
    "__ath10k_ce_send_revert": {
        "description": "This function must be called only if there is an incomplete scatter-gather transfer (before index register is updated) that needs to be cleaned up.",
        "proto" :"__ath10k_ce_send_revert(struct ath10k_ce_pipe  pipe)",
        "pre": {
            "pipe": "!=null",
            // Add other preconditions here
        },
        // Add postconditions here if any
    }
},
{
    "kretprobe:_ath10k_ce_send_nolock": {
        "description": "ath10k_ce_send. The caller takes responsibility for any needed locking.",
        "proto" :"static int _ath10k_ce_send_nolock(struct ath10k_ce_pipe *ce_state, void *per_transfer_context, dma_addr_t buffer, unsigned int nbytes, unsigned int transfer_id, unsigned int flags)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kprobe:_ath10k_ce_send_nolock": {
        "description": "ath10k_ce_send. The caller takes responsibility for any needed locking.",
        "proto" :"static int (*_ath10k_ce_send_nolock)(struct ath10k_ce_pipe *ce_state, void *per_transfer_context, dma_addr_t buffer, unsigned int nbytes, unsigned int transfer_id, unsigned int flags)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_context": "!=null",
            "buffer": "!=null",
            "nbytes": ">=0",
            "transfer_id": ">=0",
            "flags": ">=0"
        }
    }
},
{
    "kretprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "proto" :"ath10k_ce_rx_update_write_idx(struct ath10k_ce_pipe  pipe, u32 nentries)",
        "pre": {
            "pipe": "your_condition_here",
            "nentries": "your_condition_here"
        }
    }
},
{
    "kprobe:ath10k_ce_rx_update_write_idx": {
        "description": "Prevent CE ring stuck issue that will occur when ring is full. Make sure that write index is 1 less than read index.",
        "proto" :"ath10k_ce_rx_update_write_idx(struct ath10k_ce_pipe  pipe, u32 nentries)",
        "pre": {
            "pipe": "!=null",
            "nentries": ">=0",
            "pipe->ar": "!=null",
            "pipe->dest_ring": "!=null",
            "pipe->ctrl_addr": ">=0",
            "pipe->dest_ring->nentries_mask": ">=0",
            "pipe->dest_ring->write_index": ">=0",
        },
    }
},
{
    "kretprobe:ath10k_ce_rx_post_buf": {
        "description": "Description of the function goes here.",
        "proto" :"static int (*ath10k_ce_rx_post_buf)(struct ath10k_ce_pipe *pipe, void *ctx, dma_addr_t paddr)",
        "pre": {
            "pipe": "!=null",
            "ctx": "!=null",
            "paddr": "!=null"
        },
    }
},

{
    "kretprobe:ath10k_ce_completed_recv_next_nolock": {
        "description": "Copy in one go for performance reasons",
        "proto" :"static long (*ath10k_ce_completed_recv_next_nolock)(struct ath10k_ce_pipe *ce_state, void *per_transfer_contextp, unsigned int *nbytesp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        },
        "post": {
            "nbytes": "==0"
        }
    }
},
{
    "kprobe:ath10k_ce_completed_recv_next_nolock": {
        "description": "Copy in one go for performance reasons",
        "proto" :"static long (*ath10k_ce_completed_recv_next_nolock)(struct ath10k_ce_pipe *ce_state, void *per_transfer_contextp, unsigned int *nbytesp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        },
    }
},
{
    "kretprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "ath10k_ce_completed_recv_next. The caller takes responsibility for any necessary locking.",
        "proto" :"static int _ath10k_ce_completed_recv_next_nolock(struct ath10k_ce_pipe *ce_state, void **per_transfer_contextp, unsigned int *nbytesp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_recv_next_nolock": {
        "description": "ath10k_ce_completed_recv_next. The caller takes responsibility for any necessary locking.",
        "proto" :"static int (*_ath10k_ce_completed_recv_next_nolock)(struct ath10k_ce_pipe *ce_state, void **per_transfer_contextp, unsigned int *nbytesp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null",
            "nbytesp": "!=null"
        },
    }
},

{
    "kprobe:ath10k_ce_revoke_recv_next": {
        "description": "Return data from completed destination descriptor",
        "proto" :"ath10k_ce_revoke_recv_next(struct ath10k_ce_pipe  ce_state, void   per_transfer_contextp, dma_addr_t  bufferp)",
        "pre": {
            "ce_state": "your_constraint_here",
            "per_transfer_contextp": "your_constraint_here",
            "bufferp": "your_constraint_here"
        },
    }
},
{
    "kretprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "The SW completion index has caught up with the cached version of the HW completion index. Update the cached HW completion index to see whether the SW has really caught up to the HW, or if the cached value of the HW index has become stale.",
        "proto" :"static long (*ath10k_ce_completed_send_next_nolock)(struct ath10k_ce_pipe ce_state, void per_transfer_contextp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        },
    }
},
{
    "kprobe:ath10k_ce_completed_send_next_nolock": {
        "description": "Your description here",
        "proto" :"static long (*ath10k_ce_completed_send_next_nolock)(struct ath10k_ce_pipe  ce_state, void   per_transfer_contextp)",
        "pre": {
            "ce_state": "Your condition here",
            "per_transfer_contextp": "Your condition here",
        },
    }
},
{
    "kretprobe:ath10k_ce_cancel_send_next": {
        "description": "Cancel the next send operation in the ath10k_ce_pipe. The function extracts the descriptor data if the write index is not equal to the sw_index. If per_transfer_contextp is not null, it is updated with the value at the sw_index of the per_transfer_context array in the src_ring.",
        "proto" :"int (*ath10k_ce_cancel_send_next)(struct ath10k_ce_pipe *ce_state, void *per_transfer_contextp, dma_addr_t *bufferp, unsigned int *nbytesp, unsigned int *transfer_idp)",
        "pre": {
            "ce_state": "!=null",
            "ce_state->src_ring": "!=null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null"
        },
        "post": {
            "src_ring->per_transfer_context[sw_index]": "==null"
        }
    }
},
{
    "kprobe:ath10k_ce_cancel_send_next": {
        "description": "Cancel the next send operation in the CE pipe.",
        "proto": "int (*ath10k_ce_cancel_send_next)(struct ath10k_ce_pipe *ce_state, void *per_transfer_contextp, dma_addr_t *bufferp, unsigned int *nbytesp, unsigned int *transfer_idp)",
        "pre": {
            "ce_state": "!=null",
            "ce_state->src_ring": "!=null",
            "ce_state->ar": "!=null",
            "ce_state->ops": "!=null",
            "ce_state->ops->ce_extract_desc_data": "!=null",
            "per_transfer_contextp": "can be null",
            "bufferp": "!=null",
            "nbytesp": "!=null",
            "transfer_idp": "!=null",
            "ce_state->src_ring->nentries_mask": "is a valid unsigned int",
            "ce_state->src_ring->sw_index": "is a valid unsigned int",
            "ce_state->src_ring->write_index": "is a valid unsigned int"
        }
    }
},
{
    "kretprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "ath10k_ce_completed_send_next. The caller takes responsibility for any necessary locking.",
        "proto" :"static int _ath10k_ce_completed_send_next_nolock(struct ath10k_ce_pipe *ce_state, void **per_transfer_contextp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        }
    }
},
{
    "kprobe:_ath10k_ce_completed_send_next_nolock": {
        "description": "ath10k_ce_completed_send_next. The caller takes responsibility for any necessary locking.",
        "proto" :"static int (*_ath10k_ce_completed_send_next_nolock)(struct ath10k_ce_pipe *ce_state, void **per_transfer_contextp)",
        "pre": {
            "ce_state": "!=null",
            "per_transfer_contextp": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_per_engine_service": {
        "description": "Clear before handling Misc CE interrupts are not being handled, but still need to be cleared. NOTE: When the last copy engine interrupt is cleared the hardware will go to sleep. Once this happens any access to the CE registers can cause a hardware fault.",
        "proto" :"ath10k_ce_per_engine_service(struct ath10k  ar, unsigned int ce_id)",
        "pre": {
            "ar": "!=null",
            "ce_id": ">=0",
        },
    }
},
{
    "kprobe:ath10k_ce_per_engine_service": {
        "description": "Clear before handling Misc CE interrupts are not being handled, but still need to be cleared. NOTE: When the last copy engine interrupt is cleared the hardware will go to sleep. Once this happens any access to the CE registers can cause a hardware fault.",
        "proto" :"ath10k_ce_per_engine_service(struct ath10k  ar, unsigned int ce_id)",
        "pre": {
            "ar": "Your condition here",
            "ce_id": "Your condition here"
        },
    }
},

{
    "kprobe:ath10k_ce_per_engine_service_any": {
        "description": "Handles the Copy Engine (CE) interrupts for a given ath10k device.",
        "proto" :"void ath10k_ce_per_engine_service_any(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engine that are not using polling mode.",
        "proto" :"void ath10k_ce_enable_interrupts(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:ath10k_ce_enable_interrupts": {
        "description": "Enable interrupts for copy engine that are not using polling mode.",
        "proto" :"void ath10k_ce_enable_interrupts(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        }
    }
},


{
    "kretprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "proto" :"void ath10k_htc_notify_tx_completion(struct ath10k_htc_ep *ep, struct sk_buff *skb)",
        "pre": {
            "ep": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:ath10k_htc_notify_tx_completion": {
        "description": "A corner case where the copy completion is reaching to host but still copy engine is processing it due to which host unmaps corresponding memory and causes SMMU fault, hence as workaround adding delay the unmapping memory to avoid SMMU faults.",
        "proto" :"void ath10k_htc_notify_tx_completion(struct ath10k_htc_ep *ep, struct sk_buff *skb)",
        "pre": {
            "ep": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kretprobe:ath10k_htc_tx_completion_handler": {
        "description": "This function needs a description.",
        "proto" :"ath10k_htc_tx_completion_handler(struct ath10k  ar, struct sk_buff  skb)",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:ath10k_htc_tx_completion_handler": {
        "description": "Handles the completion of a transmission in the ath10k driver.",
        "proto" :"ath10k_htc_tx_completion_handler(struct ath10k  ar, struct sk_buff  skb)",
        "pre": {
            "ar": "!=null",
            "skb": "!=null"
        },
    }
},
{
    "kretprobe:ath10k_htc_process_trailer": {
        "description": "Processes the trailer of the HTC.",
        "proto" :"static long (*ath10k_htc_process_trailer)(struct ath10k_htc *htc, u8 *buffer, int length, enum ath10k_htc_ep_id src_eid, void *next_lookaheads, int next_lookaheads_len)",
        "pre": {
            "htc": "!=null",
            "buffer": "!=null",
            "length": ">=0",
            "src_eid": "in [enum ath10k_htc_ep_id values]",
            "next_lookaheads": "!=null",
            "next_lookaheads_len": ">=0"
        }
    }
},
{
    "kprobe:ath10k_warn": {
        "description": "Warns about invalid record length in the buffer.",
        "proto" :"void (*ath10k_warn)(struct ath10k *ar, const char *fmt, record->hdr.len)",
        "pre": {
            "ar": "!=null",
            "fmt": "== 'Invalid record length: %d\\n'",
            "record->hdr.len": "<= length"
        },
    },
    "kprobe:ath10k_htc_process_trailer": {
        "description": "Processes the trailer of HTC.",
        "proto" :"int (*ath10k_htc_process_trailer)(struct ath10k_htc *htc, u8 *buffer, int length, enum ath10k_htc_ep_id src_eid, void *next_lookaheads, int next_lookaheads_len)",
        "pre": {
            "htc": "!=null",
            "buffer": "!=null",
            "length": "> 0",
            "src_eid": "in [ATH10K_HTC_EP_UNUSED, ATH10K_HTC_EP_1, ATH10K_HTC_EP_2, ATH10K_HTC_EP_3, ATH10K_HTC_EP_4, ATH10K_HTC_EP_COUNT]",
            "next_lookaheads": "!=null",
            "next_lookaheads_len": ">= 0"
        },
    }
},
{
    "kretprobe:ath10k_htc_rx_completion_handler": {
        "description": "Handles the completion of the HTC RX operation.",
        "proto" :"void ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb)",
        "pre": {
            "ar": "!=null",
            "skb": "!=null",
            "hdr->flags": "!=null & contains ATH10K_HTC_FLAG_TRAILER_PRESENT"
        },
    }
},
{
    "kprobe:ath10k_htc_rx_completion_handler": {
        "description": "Handles the reception of a packet. Checks if a trailer is present in the packet.",
        "proto" :"void ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb)",
        "pre": {
            "ar": "!=null",
            "skb": "!=null",
            "hdr": "!=null",
            "hdr->flags": "in [0, ATH10K_HTC_FLAG_TRAILER_PRESENT]",
            "trailer_present": "in [false, true]"
        },
        "post": {
            "trailer_present": "= (hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT) != 0"
        }
    }
},
{
    "kretprobe:ath10k_core_create_board_name": {
        "description": "Description of the function goes here",
        "proto" :"static int (*ath10k_core_create_board_name)(struct ath10k *ar, char *boardname, size_t boardname_len, bool variant, bool chip_id)",
        "pre": {
            "ar": "!=null",
            "boardname": "!=null",
            "boardname_len": ">=0",
            "variant": "in [true, false]",
            "chip_id": "in [true, false]"
        },
    }
},
{
    "kprobe:ath10k_core_create_board_name": {
        "description": "Description of the function goes here",
        "proto" :"static long (*ath10k_core_create_board_name)(struct ath10k *ar, char *boardname, size_t boardname_len, bool variant, bool chip_id)",
        "pre": {
            "ar": "!=null",
            "boardname": "!=null",
            "boardname_len": "in [0, 100]",
            "variant": "in [true, false]",
            "chip_id": "in [true, false]"
        },
    }
},
{
    "kretprobe:ath10k_core_stop": {
        "description": "Try to suspend target",
        "proto" :"void ath10k_core_stop(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        },
    }
},
{
    "kprobe:ath10k_core_stop": {
        "description": "Try to suspend target",
        "proto" :"ath10k_core_stop(struct ath10k  ar)",
        "pre": {
            "ar": "!=null",
            "ar->state": "not in [ATH10K_STATE_RESTARTING, ATH10K_STATE_UTF]",
            "ar->id.bmi_ids_valid": "==false"
        },
    }
},
{
    "kretprobe:set_bit": {
        "description": "Sets a bit in the device flags.",
        "proto" :"void set_bit(int nr, volatile unsigned long *addr)",
        "pre": {
            "nr": "ATH10K_FLAG_PEER_STATS",
            "addr": "&ar->dev_flags"
        }
    },
    "kretprobe:ath10k_core_probe_fw": {
        "description": "Probes the firmware of the device.",
        "proto" :"int ath10k_core_probe_fw(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        }
    }
},

{
    "kretprobe:ath10k_spectral_destroy": {
        "description": "Stop spectral before unregistering from mac80211 to remove the relayfs debugfs file cleanly. Otherwise the parent debugfs tree would be already be free'd recursively, leading to a double free.",
        "proto" :"void ath10k_spectral_destroy(struct ath10k *ar)",
        "pre": {
            "ar": "!=null"
        }
    }
},
{
    "kprobe:ath10k_core_unregister": {
        "description": "Unregister the core. Stop spectral before unregistering from mac80211 to remove the relayfs debugfs file cleanly. Otherwise the parent debugfs tree would be already be free'd recursively, leading to a double free.",
        "proto" :"void ath10k_core_unregister(struct ath10k *ar)",
        "pre": {
            "ar": "!=null",
        },
    }
},
{
    "kretprobe:ath10k_core_create_board_name": {
        "description": "Creates a board name for the ath10k core.",
        "proto" :"ath10k_core_create_board_name(struct ath10k  ar, char  name, size_t name_len, bool with_variant, bool with_chip_id)",
        "pre": {
            "ar": "!=null",
            "name": "!=null",
            "name_len": ">0",
            "with_variant": "in [true, false]",
            "with_chip_id": "in [true, false]"
        },
    }
},

{
    "kretprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k",
        "proto" :"void trace_ath10k_log_dbg_dump(struct ath10k *ar, enum ath10k_debug_mask mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "ar": "!=null",
            "mask": "is of type enum ath10k_debug_mask",
            "msg": "is of type const char",
            "prefix": "is of type const char",
            "buf": "!=null",
            "len": "is of type size_t"
        }
    }
},
{
    "kprobe:trace_ath10k_log_dbg_dump": {
        "description": "Debug dump function for ath10k",
        "proto" :"void trace_ath10k_log_dbg_dump(struct ath10k *ar, enum ath10k_debug_mask mask, const char *msg, const char *prefix, const void *buf, size_t len)",
        "pre": {
            "ar": "!=null",
            "mask": "in [enum ath10k_debug_mask]",
            "msg": "!=null",
            "prefix": "!=null",
            "buf": "!=null",
            "len": ">=0"
        }
    }
},
{
    "kretprobe:calculate_size": {
        "description": "Calculate the size by adding the product of the region table size and the size of struct ath10k_dump_ram_data_hdr to the existing size. Ensure the result is aligned to 16 bytes for debug message print out.",
        "proto" :"static long (*calculate_size)(struct ath10k_hw *hw)",
        "pre": {
            "hw": "!=null",
            "hw->region_table.size": ">=0",
            "sizeof(struct ath10k_dump_ram_data_hdr)": "is constant and >0"
        },
    }
},


{
    "kprobe:ath10k_coredump_new": {
        "description": "This function generates a new coredump for the ath10k driver.",
        "proto" :"static struct ath10k_fw_crash_data* (*ath10k_coredump_new)(struct ath10k* ar)",
        "pre": {
            "ar": "!=null",
            "ar->coredump.fw_crash_data": "!=null",
            "ar->dump_mutex": "is held",
            "ath10k_coredump_mask": "==0"
        },
    }
},
{
    "kretprobe:dev_kfree_skb_any": {
        "description": "Free the indication buffer",
        "proto" :"static void (*dev_kfree_skb_any)(struct sk_buff *skb)",
        "pre": {
            "skb": "!=null"
        }
    },
    "kretprobe:ath10k_get_legacy_rate_idx": {
        "description": "Get the legacy rate index",
        "proto" :"static s8 (*ath10k_get_legacy_rate_idx)(struct ath10k *ar, u8 rate)",
        "pre": {
            "ar": "!=null",
            "rate": "in [valid range of rates]"
        }
    }
},
{
    "kprobe:dev_kfree_skb_any": {
        "description": "Free the skb buffer",
        "proto" :"static void (*dev_kfree_skb_any)(struct sk_buff *skb)",
        "pre": {
            "skb": "!=null"
        }
    },
    "kprobe:ath10k_get_legacy_rate_idx": {
        "description": "Get the legacy rate index",
        "proto" :"static inline s8 (*ath10k_get_legacy_rate_idx)(struct ath10k *ar, u8 rate)",
        "pre": {
            "ar": "!=null",
            "rate": "in [valid range of rates]"
        }
    }
},


{
    "kretprobe:try_module_get": {
        "description": "Attempts to get a module and returns a boolean indicating success or failure.",
        "proto" :"bool (*try_module_get)(struct module *module)",
        "pre": {
            "module": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},

{
    "kretprobe:il_update_stats": {
        "description": "il_update_stats function records all the MGMT, CTRL and DATA packets for both TX and RX. Use debugfs to display the rxrx_stats.",
        "proto" :"void (*il_update_stats)(struct il_priv *il, bool is_tx, __le16 fc, u16 len)",
        "pre": {
            "il": "!=null",
            "is_tx": "in [true, false]",
            "fc": ">=0",
            "len": ">=0"
        }
    }
},
{
    "kprobe:il_update_stats": {
        "description": "il_update_stats function records all the MGMT, CTRL and DATA packets for both TX and Rx. Use debugfs to display the rxrx_stats.",
        "proto" :"void (*il_update_stats)(struct il_priv *il, bool is_tx, __le16 fc, u16 len)",
        "pre": {
            "il": "!=null",
            "is_tx": "in [true, false]",
            "fc": "is __le16",
            "len": "is u16"
        },
    }
},
{
    "kretprobe:il_poll_bit": {
        "description": "This function is not fully described. Please provide a full description.",
        "proto" :"static int (*il_poll_bit)(struct il_priv *il, u32 addr, u32 bits, u32 mask, int timeout)",
        "pre": {
            "il": "!=null",
            "addr": "is a valid address",
            "bits": "is a valid bit pattern",
            "mask": "is a valid mask",
            "timeout": ">=0",
        },
    }
},

{
    "kretprobe:il_send_cmd_sync": {
        "description": "A synchronous command can not have a callback set.",
        "proto" :"il_send_cmd_sync(struct il_priv  il, struct il_host_cmd  cmd)",
        "pre": {
            "il": "!=null",
            "cmd": "!=null && !(cmd->flags & CMD_ASYNC)",
        },
    }
},
{
    "kprobe:il_send_cmd_sync": {
        "description": "A synchronous command can not have a callback set.",
        "proto" :"il_send_cmd_sync(struct il_priv *il, struct il_host_cmd *cmd)",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd->flags": "!=CMD_ASYNC"
        },
    }
},
{
    "kretprobe:il_send_cmd_async": {
        "description": "An asynchronous command can not expect an SKB to be set.",
        "proto" :"int il_send_cmd_async(struct il_priv *il, struct il_host_cmd *cmd)",
        "pre": {
            "cmd": "!=null",
            "cmd->flags": "!(CMD_WANT_SKB)"
        },
    }
},
{
    "kprobe:il_send_cmd_async": {
        "description": "An asynchronous command can not expect an SKB to be set.",
        "proto" :"int (*il_send_cmd_async)(struct il_priv *il, struct il_host_cmd *cmd)",
        "pre": {
            "il": "!=null",
            "cmd": "!=null",
            "cmd->flags": "not in [CMD_WANT_SKB]"
        }
    }
},
{
    "kretprobe:il_eeprom_init": {
        "description": "Load the EEPROM contents from adapter into il->eeprom. This routine uses the non-debug IO access functions.",
        "proto" :"static int (*il_eeprom_init)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_eeprom_init": {
        "description": "Load the EEPROM contents from adapter into il->eeprom. This routine uses the non-debug IO access functions.",
        "proto" :"intil_eeprom_init(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_eeprom_free": {
        "description": "Reset chip to save power until we load uCode during 'up'.",
        "proto" :"void il_eeprom_free(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_eeprom_free": {
        "description": "Reset chip to save power until we load uCode during 'up'.",
        "proto": "void il_eeprom_free(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},

{
    "kprobe:intil_init_channel_map": {
        "description": "Set up driver's info for all possible channels",
        "proto" :"int (*intil_init_channel_map)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_free_channel_map": {
        "description": "Undo allocations in il_init_channel_map",
        "proto" :"void (*il_free_channel_map)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:voidil_free_channel_map": {
        "description": "Undo allocations in il_init_channel_map",
        "proto" :"void (*voidil_free_channel_map)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "proto" :"int (*il_scan_cancel)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_scan_cancel": {
        "description": "Cancel any currently executing HW scan",
        "proto" :"static int (*il_scan_cancel)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan. @ms: amount of time to wait (in milliseconds) for scan to abort.",
        "proto" :"static long (*il_scan_cancel_timeout)(struct il_priv *il, unsigned long ms)",
        "pre": {
            "il": "!=null",
            "ms": ">=0"
        }
    }
},
{
    "kprobe:il_scan_cancel_timeout": {
        "description": "Cancel any currently executing HW scan. @ms: amount of time to wait (in milliseconds) for scan to abort.",
        "proto" :"int (*il_scan_cancel_timeout)(struct il_priv *il, unsigned long ms)",
        "pre": {
            "il": "!=null",
            "ms": ">=0",
        },
    }
},
{
    "kretprobe:il_hdl_scan": {
        "description": "Description of il_hdl_scan",
        "proto" :"Function prototype of il_hdl_scan",
        "pre": {
            "param1": "Condition for param1",
            "param2": "Condition for param2",
            ...
        },
    },
    "kretprobe:il_hdl_scan_start": {
        "description": "Description of il_hdl_scan_start",
        "proto" :"Function prototype of il_hdl_scan_start",
        "pre": {
            "param1": "Condition for param1",
            "param2": "Condition for param2",
            ...
        },
    },
    "kretprobe:il_hdl_scan_results": {
        "description": "Description of il_hdl_scan_results",
        "proto" :"Function prototype of il_hdl_scan_results",
        "pre": {
            "param1": "Condition for param1",
            "param2": "Condition for param2",
            ...
        },
    },
    "kretprobe:il_hdl_scan_complete": {
        "description": "Description of il_hdl_scan_complete",
        "proto" :"Function prototype of il_hdl_scan_complete",
        "pre": {
            "param1": "Condition for param1",
            "param2": "Condition for param2",
            ...
        },
    }
},
{
    "kprobe:il_setup_rx_scan_handlers": {
        "description": "scan handlers",
        "proto" :"void (*il_setup_rx_scan_handlers)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_get_passive_dwell_time": {
        "description": "If we're associated, we clamp the maximum passive dwell time to be 98% of the smallest beacon interval (minus 2 channel tune time)",
        "proto" :"il_get_passive_dwell_time(struct il_priv il, enum nl80211_band band, struct ieee80211_vif vif)",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, ...]",
            "vif": "!=null"
        },
    }
},
{
    "kprobe:il_get_passive_dwell_time": {
        "description": "If we're associated, we clamp the maximum passive dwell time to be 98% of the smallest beacon interval (minus 2 channel tune time)",
        "proto" :"il_get_passive_dwell_time(struct il_priv il, enum nl80211_band band, struct ieee80211_vif vif)",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        },
    }
},
{
    "kretprobe:il_mac_hw_scan": {
        "description": "Initiates a hardware scan. Returns -EINVAL if no channels are provided, -EAGAIN if a scan is already in progress.",
        "proto" :"il_mac_hw_scan(struct ieee80211_hw  hw, struct ieee80211_vif  vif, struct ieee80211_scan_request  hw_req)",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "hw_req->req->n_channels": "> 0",
            "il->status": "!= S_SCANNING"
        },
    }
},
{
    "kprobe:il_mac_hw_scan": {
        "description": "Initiates a hardware scan. Returns -EINVAL if no channels are specified, -EAGAIN if a scan is already in progress.",
        "proto": "static long (*il_mac_hw_scan)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_scan_request *hw_req)",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw_req": "!=null",
            "hw_req->req->n_channels": "!=0",
            "il->status & S_SCANNING": "==0"
        }
    }
},
{
    "kretprobe:u16il_fill_probe_req": {
        "description": "il_fill_probe_req - fill in all required fields and IE for probe request",
        "proto" :"u16 (*il_fill_probe_req)(struct il_priv *il, struct ieee80211_mgmt *frame, const u8 *ta, const u8 *ies, int ie_len, int left)",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": ">=0",
            "left": ">=0"
        }
    }
},
{
    "kprobe:u16il_fill_probe_req": {
        "description": "il_fill_probe_req - fill in all required fields and IE for probe request",
        "proto" :"static u16 (*u16il_fill_probe_req)(struct il_priv *il, struct ieee80211_mgmt *frame,  const u8 *ta, const u8 *ies, int ie_len, int left)",
        "pre": {
            "il": "!=null",
            "frame": "!=null",
            "ta": "!=null",
            "ies": "!=null",
            "ie_len": ">=0",
            "left": ">=0"
        },
    }
},
{
    "kretprobe:il_add_station_common": {
        "description": "il_add_station_common - ",
        "proto" :"int (*il_add_station_common)(struct il_priv *il, const u8 *addr, bool is_ap, struct ieee80211_sta *sta, u8 *sta_id_r)",
        "pre": {
            "il": "!=null",
            "addr": "!=null",
            "is_ap": "in [true, false]",
            "sta": "!=null",
            "sta_id_r": "!=null"
        }
    }
},
{
    "kprobe:il_add_station_common": {
        "description": "il_add_station_common - ",
        "proto" :"int (*il_add_station_common)(struct il_priv *il, const u8 *addr, bool is_ap, struct ieee80211_sta *sta, u8 *sta_id_r)",
        "pre": {
            "il": "!=null",
            "addr": "!=null",
            "is_ap": "in [true, false]",
            "sta": "!=null",
            "sta_id_r": "!=null",
        },
    }
},
{
    "kretprobe:il_clear_ucode_stations": {
        "description": "This function clears all the bits in the driver indicating which stations are active in the ucode. Call when something other than explicit station management would cause this in the ucode, e.g. unassociated RXON.",
        "proto" :"void (*il_clear_ucode_stations)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:voidil_clear_ucode_stations": {
        "description": "This function clears all the bits in the driver indicating which stations are active in the ucode. Call when something other than explicit station management would cause this in the ucode, e.g. unassociated RXON.",
        "proto" :"void (*voidil_clear_ucode_stations)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:voidil_restore_stations": {
        "description": "Restore driver known stations to device. All stations considered active by driver, but not present in ucode, is restored. Function sleeps.",
        "proto" :"void (*voidil_restore_stations)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        },
    }
},

{
    "kretprobe:il_is_lq_table_valid": {
        "description": "Test one aspect of LQ cmd for validity. It sometimes happens when a HT rate has been in use and we loose connectivity with AP then mac80211 will first tell us that the current channel is not HT anymore before removing the station. In such a scenario the RXON flags will be updated to indicate we are not communicating HT anymore, but the LQ command may still contain HT rates. Test for this to prevent driver from sending LQ command between the time RXON flags are updated and when LQ command is updated.",
        "proto" :"static bool (*il_is_lq_table_valid)(struct il_priv *il, struct il_link_quality_cmd *lq)",
        "pre": {
            "il": "!=null",
            "lq": "!=null"
        }
    }
},
{
    "kprobe:il_is_lq_table_valid": {
        "description": "Test one aspect of LQ cmd for validity. It sometimes happens when a HT rate has been in use and we loose connectivity with AP then mac80211 will first tell us that the current channel is not HT anymore before removing the station. In such a scenario the RXON flags will be updated to indicate we are not communicating HT anymore, but the LQ command may still contain HT rates. Test for this to prevent driver from sending LQ command between the time RXON flags are updated and when LQ command is updated.",
        "proto" :"static bool (*il_is_lq_table_valid)(struct il_priv *il, struct il_link_quality_cmd *lq)",
        "pre": {
            "il": "!=null",
            "lq": "!=null"
        }
    }
},
{
    "kretprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "proto" :"static long (*intil_rx_queue_space)(const struct il_rx_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kprobe:intil_rx_queue_space": {
        "description": "Return number of free slots available in queue.",
        "proto" :"static int (*intil_rx_queue_space)(const struct il_rx_queue *q)",
        "pre": {
            "q": "!=null"
        }
    }
},
{
    "kretprobe:voidil_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "proto" :"void (*voidil_rx_queue_update_write_ptr)(struct il_priv *il, struct il_rx_queue *q)",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},
{
    "kprobe:il_rx_queue_update_write_ptr": {
        "description": "Update the write pointer for the RX queue",
        "proto" :"void (*il_rx_queue_update_write_ptr)(struct il_priv *il, struct il_rx_queue *q)",
        "pre": {
            "il": "!=null",
            "q": "!=null"
        }
    }
},



{
    "kprobe:bpf_decrypt_res": {
        "description": "Decrypts the result based on the filter flags and frame control. Returns 0 if the filter flags include RXON_FILTER_DIS_DECRYPT_MSK or if the frame control does not include IEEE80211_FCTL_PROTECTED.",
        "proto" :"static long (*bpf_decrypt_res)(struct il_priv *il, struct ieee80211_hdr *hdr, u32 decrypt_res, struct ieee80211_rx_status *stats)",
        "pre": {
            "il": "!=null",
            "hdr": "!=null",
            "decrypt_res": "is a valid u32",
            "stats": "!=null",
        },
    }
},
{
    "kretprobe:il_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "proto" :"void (*il_txq_update_write_ptr)(struct il_priv *il, struct il_tx_queue *txq)",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kprobe:voidil_txq_update_write_ptr": {
        "description": "Send new write idx to hardware",
        "proto" :"void (*voidil_txq_update_write_ptr)(struct il_priv *il, struct il_tx_queue *txq)",
        "pre": {
            "il": "!=null",
            "txq": "!=null"
        }
    }
},
{
    "kretprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "proto" :"void (*il_tx_queue_unmap)(struct il_priv *il, int txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        }
    }
},
{
    "kprobe:il_tx_queue_unmap": {
        "description": "Unmap any remaining DMA mappings and free skb's",
        "proto" :"void (*il_tx_queue_unmap)(struct il_priv *il, int txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        }
    }
},
{
    "kretprobe:il_tx_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "proto" :"void (*il_tx_queue_free)(struct il_priv *il, int txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        },
    }
},
{
    "kprobe:il_tx_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "proto" :"void (*il_tx_queue_free)(struct il_priv *il, int txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0"
        }
    }
},
{
    "kretprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue",
        "proto" :"void (*il_cmd_queue_unmap)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_cmd_queue_unmap": {
        "description": "Unmap any remaining DMA mappings from command queue",
        "proto" :"void (*il_cmd_queue_unmap)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "proto" :"void (*il_cmd_queue_free)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:voidil_cmd_queue_free": {
        "description": "Deallocate DMA queue. Empty queue by removing and destroying all BD's. Free all buffers. 0-fill, but do not free 'txq' descriptor structure.",
        "proto" :"void (*voidil_cmd_queue_free)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_queue_space": {
        "description": "Calculate the space in the queue. Keep some reserve to not confuse empty and full situations.",
        "proto" :"int il_queue_space(const struct il_queue *q)",
        "pre": {
            "q": "!=null",
            "q->read_ptr": ">= q->write_ptr",
            "q->n_bd": "is integer",
            "q->n_win": "is integer"
        },
        "post": {
            "return": ">= 0"
        }
    }
},
{
    "kprobe:il_queue_space": {
        "description": "Calculates the space in the queue by subtracting the write pointer from the read pointer. Adjusts the result based on the values of n_bd and n_win to avoid confusion between empty and full situations.",
        "proto" :"int il_queue_space(const struct il_queue *q)",
        "pre": {
            "q": "!=null",
            "q->read_ptr": ">= q->write_ptr",
            "q->write_ptr": ">= 0",
            "q->n_bd": ">= 0",
            "q->n_win": ">= 0"
        }
    }
},
{
    "kretprobe:il_tx_queue_init": {
        "description": "Allocate and initialize one txcmd queue",
        "proto" :"intil_tx_queue_init(struct il_priv *il, u32 txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0",
        },
    }
},
{
    "kprobe:il_tx_queue_init": {
        "description": "Allocate and initialize one txcmd queue",
        "proto" :"intil_tx_queue_init(struct il_priv *il, u32 txq_id)",
        "pre": {
            "il": "!=null",
            "txq_id": ">=0",
        },
    }
},


{
    "kretprobe:il_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them. If an Rx buffer has an async callback associated with it the callback will be executed. The attached skb (if present) will only be freed if the callback returns 1.",
        "proto" :"void (*il_tx_cmd_complete)(struct il_priv *il, struct il_rx_buf *rxb)",
        "pre": {
            "il": "!=null",
            "rxb": "!=null"
        }
    }
},
{
    "kprobe:voidil_tx_cmd_complete": {
        "description": "Pull unused buffers off the queue and reclaim them. If an Rx buffer has an async callback associated with it the callback will be executed. The attached skb (if present) will only be freed if the callback returns 1.",
        "proto" :"voidil_tx_cmd_complete(struct il_priv *il, struct il_rx_buf *rxb)",
        "pre": {
            "il": "!=null",
            "rxb": "!=null"
        },
    }
},
{
    "kretprobe:il_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "proto" :"intil_init_geos(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:il_init_geos": {
        "description": "Initialize mac80211's geochannel info based from eeprom",
        "proto" :"static int (*il_init_geos)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:il_free_geos": {
        "description": "il_free_geos - undo allocations in il_init_geos",
        "proto" :"void (*il_free_geos)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:voidil_free_geos": {
        "description": "il_free_geos - undo allocations in il_init_geos",
        "proto" :"void (*voidil_free_geos)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},

{
    "kprobe:u8il_prep_station": {
        "description": "Prepare station information for addition. Should be called with sta_lock held.",
        "proto" :"u8il_prep_station(struct il_priv *il, const u8 *addr, bool is_ap,struct ieee80211_sta *sta)",
        "pre": {
            "il": "!=null",
            "addr": "!=null",
            "is_ap": "is boolean",
            "sta": "!=null",
        },
    }
},
{
    "kretprobe:il_send_rxon_timing": {
        "description": "This function is used to send rxon timing.",
        "proto" :"il_send_rxon_timing(struct il_priv  il)",
        "pre": {
            "il": "!=null",
            "il->vif": "!=null",
            "il->hw->conf": "!=null",
            "il->mutex": "is locked",
            "il->timing": "is memset to 0",
            "il->timing.timestamp": "is set to cpu_to_le64(il->timestamp)",
            "il->timing.listen_interval": "is set to cpu_to_le16(conf->listen_interval)",
            "beacon_int": "is set to vif ? vif->bss_conf.beacon_int : 0",
            "il->timing.atim_win": "is set to 0",
            "il->timing.beacon_interval": "is set to cpu_to_le16(beacon_int)",
            "tsf": "is set to il->timestamp"
        },
    }
},

{
    "kretprobe:il_check_rxon_cmd": {
        "description": "Checks the RXON command for errors and ensures basic rates 6Mbps and 1Mbps are supported.",
        "proto" :"static bool (*il_check_rxon_cmd)(struct il_priv *il)",
        "pre": {
            "il": "!=null",
            "il->staging": "!=null",
            "rxon->ofdm_basic_rates": "in [RATE_6M_MASK, RATE_1M_MASK]",
            "rxon->cck_basic_rates": "in [RATE_6M_MASK, RATE_1M_MASK]",
            "rxon->flags": "in [RXON_FLG_BAND_24G_MSK, RXON_FLG_TGJ_NARROW_BAND_MSK, RXON_FLG_RADAR_DETECT_MSK, RXON_FLG_SHORT_SLOT_MSK, RXON_FLG_CCK_MSK]",
            "rxon->node_addr[0]": "!=null",
            "rxon->bssid_addr[0]": "!=null"
        },
    }
},
{
    "kprobe:il_check_rxon_cmd": {
        "description": "Checks the RXON command for various conditions and sets an error flag if any condition is not met.",
        "proto" :"il_check_rxon_cmd(struct il_priv  il)",
        "pre": {
            "il": "!=null",
            "il->staging": "!=null",
            "rxon->flags": "in [RXON_FLG_BAND_24G_MSK, RXON_FLG_TGJ_NARROW_BAND_MSK, RXON_FLG_RADAR_DETECT_MSK, RXON_FLG_SHORT_SLOT_MSK, RXON_FLG_CCK_MSK]",
            "rxon->node_addr[0]": "!=null",
            "rxon->bssid_addr[0]": "!=null",
            "rxon->ofdm_basic_rates": "!=null",
            "rxon->cck_basic_rates": "!=null",
            "RATE_6M_MASK": "!=null",
            "RATE_1M_MASK": "!=null"
        },
    }
},
{
    "kretprobe:il_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed. If the RXON structure is changing enough to require a new tune, or is clearing the RXON_FILTER_ASSOC_MSK, then return 1 to indicate that a new tune (full RXON command, rather than RXON_ASSOC cmd) is required.",
        "proto" :"static int (*il_full_rxon_required)(struct il_priv *il)",
        "pre": {
            "il": "your_condition_here"
        }
    }
},
{
    "kprobe:intil_full_rxon_required": {
        "description": "Check if full RXON (vs RXON_ASSOC) cmd is needed. staging_rxon is compared to active_rxon. If the RXON structure is changing enough to require a new tune, or is clearing the RXON_FILTER_ASSOC_MSK, then return 1 to indicate that a new tune (full RXON command, rather than RXON_ASSOC cmd) is required.",
        "proto" :"intil_full_rxon_required(struct il_priv *il)",
        "pre": {
            "il": "!=null",
        },
    }
},
{
    "kretprobe:il_get_lowest_plcp": {
        "description": "Assign the lowest rate -- should really get this from the beacon skb from mac80211.",
        "proto" :"static long (*il_get_lowest_plcp)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        },
        "post": {
            "return": "in [RATE_1M_PLCP, RATE_6M_PLCP]"
        }
    }
},
{
    "kprobe:il_get_lowest_plcp": {
        "description": "Assign the lowest rate -- should really get this from the beacon skb from mac80211.",
        "proto" :"static long (*il_get_lowest_plcp)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        },
    }
},
{
    "kretprobe:il_set_rxon_ht": {
        "description": "Clear the HT channel mode before set the mode.",
        "proto" :"void il_set_rxon_ht(struct il_priv *il, struct il_ht_config *ht_conf)",
        "pre": {
            "il": "!=null",
            "ht_conf": "!=null"
        }
    }
},

{
    "kretprobe:il_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON. Does not commit to the hardware; it sets appropriate bit fields in the staging RXON flag structure based on the ch->band.",
        "proto" :"static long (*il_set_rxon_channel)(struct il_priv *il, struct ieee80211_channel *ch)",
        "pre": {
            "il": "!=null",
            "ch": "!=null"
        }
    }
},
{
    "kprobe:il_set_rxon_channel": {
        "description": "Set the band and channel values in staging RXON. Does not commit to the hardware; it sets appropriate bit fields in the staging RXON flag structure based on the ch->band.",
        "proto" :"intil_set_rxon_channel(struct il_priv *il, struct ieee80211_channel *ch)",
        "pre": {
            "il": "!=null",
            "ch": "!=null"
        }
    }
},
{
    "kretprobe:il_set_flags_for_band": {
        "description": "Sets flags for the band.",
        "proto" :"void il_set_flags_for_band(struct il_priv *il, enum nl80211_band band, struct ieee80211_vif *vif)",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_5GHZ, !NL80211_BAND_5GHZ]",
            "vif": "!=null"
        }
    }
},
{
    "kprobe:il_set_flags_for_band": {
        "description": "Sets flags for the band. If the band is NL80211_BAND_5GHZ, it sets the RXON_FLG_SHORT_SLOT_MSK flag and clears the RXON_FLG_BAND_24G_MSK, RXON_FLG_AUTO_DETECT_MSK, and RXON_FLG_CCK_MSK flags. Otherwise, it sets the RXON_FLG_BAND_24G_MSK, RXON_FLG_AUTO_DETECT_MSK, RXON_FLG_CCK_MSK flags and clears the RXON_FLG_SHORT_SLOT_MSK flag.",
        "proto" :"void il_set_flags_for_band(struct il_priv *il, enum nl80211_band band, struct ieee80211_vif *vif)",
        "pre": {
            "il": "!=null",
            "band": "in [NL80211_BAND_2GHZ, NL80211_BAND_5GHZ]",
            "vif": "!=null"
        },
    }
},


{
    "kretprobe:il_irq_handle_error": {
        "description": "Called for HW or SW error interrupt from card",
        "proto" :"void (*il_irq_handle_error)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:voidil_irq_handle_error": {
        "description": "Called for HW or SW error interrupt from card.",
        "proto" :"void (*voidil_irq_handle_error)(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kretprobe:_il_apm_stop_master": {
        "description": "Stop device's busmaster DMA activity",
        "proto" :"void _il_apm_stop_master(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},
{
    "kprobe:_il_apm_stop_master": {
        "description": "Stop device's busmaster DMA activity",
        "proto" :"void _il_apm_stop_master(struct il_priv *il)",
        "pre": {
            "il": "!=null"
        }
    }
},

{
    "kprobe:il_init_band_reference": {
        "description": "Initialize band reference.",
        "proto": "static void (*il_init_band_reference)(const struct il_priv  il, int eep_band, int  eeprom_ch_count, const struct il_eeprom_channel   eeprom_ch_info, const u8   eeprom_ch_idx)",
        "pre": {
            "il": "!=null",
            "eep_band": "in [1, 2]",
            "eeprom_ch_count": ">=0",
            "eeprom_ch_info": "!=null",
            "eeprom_ch_idx": ">=0",
        },
    }
},


{
    "kretprobe:voidil_sta_ucode_activate": {
        "description": "Description of the function goes here",
        "proto" :"static voidil_sta_ucode_activate(struct il_priv *il, u8 sta_id)",
        "pre": {
            "il": "!=null",
            "sta_id": "is a valid sta_id"
        }
    }
},
{
    "kprobe:voidil_sta_ucode_activate": {
        "description": "Description of the function goes here",
        "proto" :"static voidil_sta_ucode_activate(struct il_priv *il, u8 sta_id)",
        "pre": {
            "il": "!=null",
            "sta_id": "is a valid u8 value",
        },
    }
},
{
    "kretprobe:il_mac_add_interface": {
        "description": "Add an interface to the device. If the device is not ready or multiple virtual interfaces are not supported, it will return an error. On hardware reset, the same interface has to be added again.",
        "proto": "int il_mac_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "hw->priv": "!=null",
            "vif->type": "in [types of ieee80211_vif]",
            "vif->addr": "!=null",
            "il->mutex": "!=null",
            "il_is_ready_rf(il)": "==true"
        },
        "post": {
            "err": "in [-EINVAL, 0]",
            "reset": "in [true, false]"
        }
    }
},
{
    "kprobe:il_mac_add_interface": {
        "description": "We do not support multiple virtual interfaces, but on hardware reset we have to add the same interface again.",
        "proto" :"il_mac_add_interface(struct ieee80211_hw  hw, struct ieee80211_vif  vif)",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "il": "!=null && il->vif !=null",
            "reset": "is a boolean"
        },
        "post": {
            "reset": "equals (il->vif == vif)",
            "if condition": "il->vif && !reset"
        }
    }
},
{
    "kretprobe:il_force_reset": {
        "description": "Force a reset on the device. If the request is from an external source, always perform the request. If the request is from an internal source, check the firmware restart module parameter before performing the firmware reload.",
        "proto" :"static long (*il_force_reset)(struct il_priv *il, bool external)",
        "pre": {
            "il": "!=null",
            "external": "in [true, false]",
            "il->cfg->mod_params->restart_fw": "in [true, false]"
        },
    }
},
{
    "kprobe:il_force_reset": {
        "description": "Force reset the il_priv structure. If the request is from external (ex: debugfs), always perform the request regardless of the module parameter setting. If the request is from internal (uCode error or driver detect failure), then fw_restart module parameter needs to be checked before performing firmware reload.",
        "proto" :"il_force_reset(struct il_priv *il, bool external)",
        "pre": {
            "il": "!=null",
            "external": "is bool"
        },
    }
},



{
    "kprobe:il_bg_watchdog": {
        "description": "Monitor and check for stuck cmd queue",
        "proto" :"void il_bg_watchdog(struct timer_list  t)",
        "pre": {
            "il": "!=null",
            "il->cmd_queue": "!=null"
        }
    }
},
{
    "kretprobe:intil_mac_config": {
        "description": "mac80211 config callback",
        "proto" :"static long (*intil_mac_config)(struct ieee80211_hw *hw, u32 changed)",
        "pre": {
            "hw": "!=null",
            "changed": "!=null"
        }
    }
},
{
    "kprobe:intil_mac_config": {
        "description": "mac80211 config callback",
        "proto" :"int (*intil_mac_config)(struct ieee80211_hw *hw, u32 changed)",
        "pre": {
            "hw": "!=null",
            "changed": "is u32"
        }
    }
},
{
    "kretprobe:dev_consume_skb_irq": {
        "description": "Consume the skb buffer in an interrupt context.",
        "proto" :"void (*dev_consume_skb_irq)(struct sk_buff *skb)",
        "pre": {
            "skb": "!=null"
        }
    }
},

{
    "kretprobe:il_mac_bss_info_changed": {
        "description": "This function handles changes in the BSS configuration.",
        "proto" :"static void (*il_mac_bss_info_changed)(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_bss_conf *bss_conf, u64 changes)",
        "pre": {
            "hw": "!=null",
            "vif": "!=null",
            "bss_conf": "!=null",
            "changes": "in [BSS_CHANGED_QOS, BSS_CHANGED_BEACON_ENABLED, ...]",
        },
    }
},



{
    "kretprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "proto" :"void (*il_tx_cmd_protection)(struct il_priv *il, struct ieee80211_tx_info *info, __le16 fc, __le32 *tx_flags)",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        }
    }
},
{
    "kprobe:il_tx_cmd_protection": {
        "description": "Set rtscts. 3945 and 4965 only share this function.",
        "proto" :"void (*il_tx_cmd_protection)(struct il_priv *il, struct ieee80211_tx_info *info, __le16 fc, __le32 *tx_flags)",
        "pre": {
            "il": "!=null",
            "info": "!=null",
            "fc": "!=null",
            "tx_flags": "!=null"
        },
    }
},
{
    "kretprobe:libipw_wx_set_encodeext": {
        "description": "This function sets the encoding extension for a libipw device.",
        "proto" :"int libipw_wx_set_encodeext(struct libipw_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "idx": "in [1, WEP_KEYS]",
            "ext->ext_flags": "in [IW_ENCODE_EXT_GROUP_KEY, ...]",
            "ext->alg": "in [IW_ENCODE_ALG_WEP, ...]"
        },
    }
},
{
    "kprobe:libipw_wx_get_encode": {
        "description": "Get the encoding information of the libipw device.",
        "proto": "int libipw_wx_get_encode(struct libipw_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *keybuf)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "keybuf": "!=null"
        }
    },
    "kprobe:libipw_wx_set_encodeext": {
        "description": "Set the encoding extension of the libipw device.",
        "proto": "int libipw_wx_set_encodeext(struct libipw_device *ieee, struct iw_request_info *info, union iwreq_data *wrqu, char *extra)",
        "pre": {
            "ieee": "!=null",
            "info": "!=null",
            "wrqu": "!=null",
            "extra": "!=null",
            "idx": "in [0, WEP_KEYS-1]",
            "ext->ext_flags": "in [IW_ENCODE_EXT_GROUP_KEY, ...]"
        }
    }
},
{
    "kretprobe:libipw_xmit": {
        "description": "Transmit a packet.",
        "proto" :"static long (*libipw_xmit)(struct sk_buff *skb, struct net_device *dev)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kprobe:libipw_xmit": {
        "description": "Transmit a packet with the libipw device.",
        "proto" :"static int (*libipw_xmit)(struct sk_buff *skb, struct net_device *dev)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:libipw_xmit": {
        "description": "Please provide a description for this function.",
        "proto" :"netdev_tx_t (*libipw_xmit)(struct sk_buff *skb, struct net_device *dev)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kprobe:libipw_xmit": {
        "description": "Placeholder description for libipw_xmit",
        "proto" :"netdev_tx_t libipw_xmit(struct sk_buff *skb, struct net_device *dev)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null"
        }
    }
},
{
    "kretprobe:libipw_freq_to_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "proto" :"static long (*libipw_freq_to_channel)(struct libipw_device *ieee, u32 freq)",
        "pre": {
            "ieee": "!=null",
            "freq": ">=2400 && <=2500 || >=4900 && <=5900",
        },
    },
    "kretprobe:libipw_set_geo": {
        "description": "Set the geography map for the device",
        "proto" :"static void (*libipw_set_geo)(struct libipw_device *ieee, const struct libipw_geo *geo)",
        "pre": {
            "ieee": "!=null",
            "geo": "!=null",
        },
    }
},
{
    "kprobe:libipw_freq_to_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "proto" :"libipw_freq_to_channel(struct libipw_device ieee, u32 freq)",
        "pre": {
            "ieee": "!=null",
            "freq": "!=null",
            // Add other preconditions here
        },
    },
    "kprobe:libipw_set_geo": {
        "description": "Description of libipw_set_geo function",
        "proto" :"void libipw_set_geo(struct libipw_device *ieee, const struct libipw_geo *geo)",
        "pre": {
            "ieee": "!=null",
            "geo": "!=null",
            // Add other preconditions here
        },
    }
},
{
    "kretprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "proto" :"static long (*libipw_is_valid_channel)(struct libipw_device *ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": "!=null",
            // Add more conditions here
        },
    }
},
{
    "kprobe:libipw_is_valid_channel": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "proto" :"libipw_is_valid_channel(struct libipw_device *ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": "in [valid channel range]",
            "ieee->geo.bg_channels": ">=0",
            "ieee->geo.a_channels": ">=0",
            "ieee->freq_band": "in [LIBIPW_24GHZ_BAND, other valid bands]"
        },
    }
},
{
    "kretprobe:libipw_channel_to_freq": {
        "description": "Driver needs to initialize the geography map before using these helper functions",
        "proto" :"struct libipw_channel (*libipw_channel_to_freq)(struct libipw_device *ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": "!=null"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:libipw_channel_to_freq": {
        "description": "Driver needs to initialize the geography map before using these helper functions.",
        "proto" :"struct libipw_channel *(*libipw_channel_to_freq)(struct libipw_device *ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": ">=0"
        }
    }
},
{
    "kretprobe:libipw_channel_to_index": {
        "description": "Driver needs to initialize the geography map before using these helper functions.",
        "proto" :"static long (*libipw_channel_to_index)(struct libipw_device * ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": "in [valid channel range]",
            "ieee->geo.bg_channels": ">=0",
            "ieee->geo.a_channels": ">=0",
            "ieee->freq_band": "in [LIBIPW_24GHZ_BAND, LIBIPW_52GHZ_BAND]",
            "ieee->geo.bg[i].channel": "in [valid channel range]",
            "ieee->geo.a[i].channel": "in [valid channel range]"
        },
    }
},
{
    "kprobe:libipw_channel_to_index": {
        "description": "Driver needs to initialize the geography map before using these helper functions.",
        "proto" :"static int (*libipw_channel_to_index)(struct libipw_device *ieee, u8 channel)",
        "pre": {
            "ieee": "!=null",
            "channel": "!=null",
            // Add more conditions here
        },
    }
},
{
    "kretprobe:alloc_libipw": {
        "description": "Allocates a new libipw_device and initializes it. If monitor is not set, it also initializes the wiphy structure.",
        "proto" :"int alloc_libipw(int sizeof_priv, int monitor)",
        "pre": {
            "sizeof_priv": ">= sizeof(struct libipw_device)",
            "monitor": "in [0, 1]"
        },
        "post": {
            "return": "in [0, -ENOMEM]"
        }
    }
},
{
    "kprobe:wiphy_new": {
        "description": "Create a new wiphy for the wireless device.",
        "proto" :"struct wiphy *(*wiphy_new)(const struct wiphy_ops *ops, int sizeof_priv)",
        "pre": {
            "ops": "!=null",
            "sizeof_priv": ">=0",
        },
    }
},
{
    "kretprobe:free_libipw": {
        "description": "Free cfg80211 resources and libipw networks, and clear crypt_info.",
        "proto" :"void free_libipw(struct net_device *dev, int monitor)",
        "pre": {
            "dev": "!=null",
            "monitor": "is int"
        }
    }
},
{
    "kprobe:free_libipw": {
        "description": "Free cfg80211 resources and libipw networks, and clear crypt_info.",
        "proto" :"void free_libipw(struct net_device *dev, int monitor)",
        "pre": {
            "dev": "!=null",
            "monitor": "is int"
        }
    }
},
{
    "kretprobe:ether_addr_equal": {
        "description": "Checks if the addresses are equal.",
        "proto" :"static bool (*ether_addr_equal)(const u8 *addr1, const u8 *addr2)",
        "pre": {
            "addr1": "!=null",
            "addr2": "!=null"
        }
    },
    "kretprobe:IEEE80211_FCTL_TODS": {
        "description": "Checks if the frame is to DS.",
        "proto" :"static bool (*IEEE80211_FCTL_TODS)(u16 fc)",
        "pre": {
            "fc": "is a valid frame control field"
        }
    },
    "kretprobe:IEEE80211_FCTL_FROMDS": {
        "description": "Checks if the frame is from DS.",
        "proto" :"static bool (*IEEE80211_FCTL_FROMDS)(u16 fc)",
        "pre": {
            "fc": "is a valid frame control field"
        }
    }
},
{
    "kprobe:libipw_rx_mgt": {
        "description": "Description of the function goes here.",
        "proto" :"static long (*libipw_rx_mgt)(void *ieee, void *hdr, void *stats)",
        "pre": {
            "ieee": "!=null",
            "hdr": "!=null",
            "stats": "!=null"
        },
    }
},
{
    "kretprobe:libipw_frag_cache_find": {
        "description": "Please provide the correct description",
        "proto" :"static struct libipw_frag_entry *libipw_frag_cache_find(struct libipw_device *ieee, unsigned int seq, unsigned int frag, u8 * src, u8 * dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "src": "!=null",
            "dst": "!=null"
        },
    }
},
{
    "kprobe:libipw_frag_cache_find": {
        "description": "To be provided",
        "proto" :"static struct libipw_frag_entry *(*libipw_frag_cache_find)(struct libipw_device *ieee, unsigned int seq, unsigned int frag, u8 * src, u8 * dst)",
        "pre": {
            "ieee": "!=null",
            "seq": ">=0",
            "frag": ">=0",
            "src": "!=null",
            "dst": "!=null"
        },
    }
},
{
    "kretprobe:wlcore_tx_complete": {
        "description": "Read the tx results from the chipset.",
        "proto" :"static int (*wlcore_tx_complete)(struct wl1271 *wl)",
        "pre": {
            "wl": "!=null"
        },
    }
},
{
    "kprobe:wlcore_tx_complete": {
        "description": "Read the tx results from the chipset",
        "proto" :"wlcore_tx_complete(struct wl1271  wl)",
        "pre": {
            "wl": "!=null",
            "wl->target_mem_map": "!=null",
            "wl->tx_res_if": "!=null",
            "le32_to_cpu(memmap->tx_result)": ">=0",
            "sizeof(*wl->tx_res_if)": ">0",
            "false": "==false"
        },
    }
},
{
    "kretprobe:orinoco_stop": {
        "description": "This function is used to stop the Orinoco network device. It doesn't use orinoco_lock() because it needs to be able to close the interface even if hw_unavailable is set (e.g. as we're released after a PC Card removal).",
        "proto" :"orinoco_stop(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kprobe:orinoco_stop": {
        "description": "We mustn't use orinoco_lock() here, because we need to be able to close the interface even if hw_unavailable is set (e.g. as we're released after a PC Card removal)",
        "proto" :"orinoco_stop(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},


{
    "kretprobe:orinoco_change_mtu": {
        "description": "Change the MTU (Maximum Transmission Unit) of the network device. The new MTU should not exceed the buffer size of the network interface card (NIC) after accounting for encapsulation overhead and header length.",
        "proto" :"int orinoco_change_mtu(struct net_device *dev, int new_mtu)",
        "pre": {
            "dev": "!=null",
            "new_mtu": ">=0",
            "priv": "!=null",
            "priv->nicbuf_size": "> (new_mtu + ENCAPS_OVERHEAD + sizeof(struct ieee80211_hdr) + ETH_HLEN)"
        },
        "post": {
            "return": "in [-EINVAL, 0]"
        }
    }
},
{
    "kprobe:orinoco_change_mtu": {
        "description": "Change the MTU (Maximum Transmission Unit) of the network device. The new MTU value should not exceed the buffer size of the network interface card (NIC) after accounting for encapsulation overhead and the size of the IEEE 802.11 header.",
        "proto": "int orinoco_change_mtu(struct net_device *dev, int new_mtu)",
        "pre": {
            "dev": "!=null",
            "new_mtu": "> 0 && <= (priv->nicbuf_size - ETH_HLEN - ENCAPS_OVERHEAD - sizeof(struct ieee80211_hdr))"
        }
    }
},
{
    "kretprobe:orinoco_process_xmit_skb": {
        "description": "Process the transmit skb, encapsulate Ethernet-II frames.",
        "proto" :"void orinoco_process_xmit_skb(struct sk_buff *skb, struct net_device *dev, struct orinoco_private *priv, int tx_control, u8 *mic_buf)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "priv": "!=null",
            "tx_control": "is int",
            "mic_buf": "!=null"
        },
        "post": {
            "ntohs(eh->h_proto)": "> ETH_DATA_LEN"
        }
    }
},
{
    "kprobe:orinoco_process_xmit_skb": {
        "description": "Encapsulate Ethernet-II frames",
        "proto" :"static void (*orinoco_process_xmit_skb)(struct sk_buff *skb, struct net_device *dev, struct orinoco_private *priv, int tx_control, u8 mic_buf)",
        "pre": {
            "skb": "!=null",
            "dev": "!=null",
            "priv": "!=null",
            "tx_control": "is int",
            "mic_buf": "is u8",
            "eh->h_proto": "ntohs(eh->h_proto) > ETH_DATA_LEN"
        },
    }
},
{
    "kretprobe:__orinoco_ev_rx": {
        "description": "Handle frames in monitor mode",
        "proto" :"void __orinoco_ev_rx(struct net_device *dev, struct hermes *hw)",
        "pre": {
            "dev": "!=null",
            "hw": "!=null"
        },
        "post": {
            "priv->iw_mode": "==NL80211_IFTYPE_MONITOR"
        }
    }
},
{
    "__orinoco_ev_rx": {
        "description": "Handle frames in monitor mode",
        "proto": "void __orinoco_ev_rx(struct net_device *dev, struct hermes *hw)",
        "pre": {
            "dev": "!=null",
            "hw": "!=null",
            "priv": "!=null",
            "priv->iw_mode": "==NL80211_IFTYPE_MONITOR"
        }
    }
},



{
    "kprobe:/* jiffies value the last time we were called */": {
        "description": "This is a placeholder for the function description.",
        "proto" :"This is a placeholder for the function prototype",
        "pre": {
            "arg1": "This is a placeholder for the first argument constraint",
            "arg2": "This is a placeholder for the second argument constraint",
            "...": "...",
        },
    }
},
{
    "kretprobe:alloc_orinocodev": {
        "description": "Initialize the firmware",
        "proto" :"void (*alloc_orinocodev)(void *priv)",
        "pre": {
            "priv": "!=null"
        },
        "post": {
            "priv->nicbuf_size": "== IEEE80211_MAX_FRAME_LEN + ETH_HLEN"
        }
    }
},

{
    "kretprobe:orinoco_if_add": {
        "description": "Add an interface for the Orinoco wireless device.",
        "proto" :"int (*orinoco_if_add)(struct orinoco_private *priv, unsigned long base_addr, unsigned int irq, const struct net_device_ops *ops)",
        "pre": {
            "priv": "!=null",
            "base_addr": ">=0",
            "irq": ">=0",
            "ops": "!=null"
        },
    }
},
{
    "kprobe:orinoco_if_add": {
        "description": "Add an interface for the Orinoco driver",
        "proto" :"int (*orinoco_if_add)(struct orinoco_private *priv, unsigned long base_addr, unsigned int irq, const struct net_device_ops *ops)",
        "pre": {
            "priv": "!=null",
            "base_addr": ">=0",
            "irq": ">=0",
            "ops": "!=null",
        },
    }
},




{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[constraints]",
            "[param2]": "[constraints]",
            "[param3]": "[constraints]",
            "[param4]": "[constraints]",
        },
    }
},




{
    "kprobe:hostap_ap_tx_cb": {
        "description": "This function is a callback for hostap_ap_tx. It checks the firmware version of the station and applies a workaround if necessary. It is called only as a tasklet (software IRQ).",
        "proto" :"static void hostap_ap_tx_cb(struct sk_buff *skb, int ok, void *data)",
        "pre": {
            "skb": "!=null",
            "ok": "is integer",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:hostap_handle_sta_tx_exc": {
        "description": "Handle the transmission exception for a station in a hostap context.",
        "proto" :"void hostap_handle_sta_tx_exc(local_info_t *local, struct sk_buff *skb)",
        "pre": {
            "local": "!=null",
            "skb": "!=null"
        },
        "post": {
            "old": ">=0",
            "rate": ">=0"
        }
    }
},
{
    "kprobe:hostap_handle_sta_tx_exc": {
        "description": "Handles the transmission exception for a station.",
        "proto" :"void hostap_handle_sta_tx_exc(local_info_t *local, struct sk_buff *skb)",
        "pre": {
            "local": "!=null",
            "skb": "!=null"
        },
    }
},




{
    "kretprobe:hostap_set_string": {
        "description": "Set a string to the network device with a specific rid. The string is stored in a buffer with a length prefix and a little endian 16 bit word.",
        "proto" :"static int (*hostap_set_string)(struct net_device *dev, int rid, const char *val)",
        "pre": {
            "dev": "!=null",
            "rid": "is integer",
            "val": "!=null && length <= MAX_SSID_LEN"
        },
        "post": {
            "return": "in [-1, 0]"
        }
    }
},
{
    "kprobe:hostap_set_string": {
        "description": "Set a string to the network device with a specific rid. The string is stored in a buffer with a specific length. If the length of the string is greater than MAX_SSID_LEN, the function will return -1.",
        "proto" :"static int (*hostap_set_string)(struct net_device *dev, int rid, const char *val)",
        "pre": {
            "dev": "!=null",
            "rid": "is a valid rid",
            "val": "!=null && strlen(val) <= MAX_SSID_LEN"
        },
    }
},
{
    "kretprobe:hostap_set_encryption": {
        "description": "Sets the encryption for the local host.",
        "proto" :"void hostap_set_encryption(local_info_t *local)",
        "pre": {
            "local": "!=null"
        }
    }
},

{
    "kretprobe:hostap_set_auth_algs": {
        "description": "At least STA fw v0.6.2 seems to have issues with cnfAuthentication set to include both Open and Shared Key flags. It tries to use Shared Key authentication in that case even if WEP keys are not configured.. STA fw v0.7.6 is able to handle such configuration, but it is unknown when this was fixed between 0.6.2 .. 0.7.6.",
        "proto" :"hostap_set_auth_algs(local_info_t  local)",
        "pre": {
            "local": "!=null",
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "in [PRISM2_AUTH_OPEN, PRISM2_AUTH_SHARED_KEY]",
            "hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)": "==0"
        },
    }
},
{
    "kprobe:hostap_set_auth_algs": {
        "description": "At least STA fw v0.6.2 seems to have issues with cnfAuthentication set to include both Open and Shared Key flags. It tries to use Shared Key authentication in that case even if WEP keys are not configured.. STA fw v0.7.6 is able to handle such configuration, but it is unknown when this was fixed between 0.6.2 .. 0.7.6.",
        "proto" :"hostap_set_auth_algs(local_info_t  local)",
        "pre": {
            "local": "!=null",
            "local->sta_fw_ver": "< PRISM2_FW_VER(0,7,0)",
            "val": "in [PRISM2_AUTH_OPEN, PRISM2_AUTH_SHARED_KEY]",
            "hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)": "== 0"
        },
    }
},


{
    "kretprobe:hostap_80211_get_hdrlen": {
        "description": "Returns the header length of the 802.11 frame based on the frame control field *fc*. If the frame is a data frame and has an Addr4 field, the header length is 30.",
        "proto" :"static int (*hostap_80211_get_hdrlen)(__le16 fc)",
        "pre": {
            "fc": "!=null"
        },
        "post": {
            "return": "in [10, 16, 24, 30]"
        }
    }
},
{
    "kprobe:hostap_80211_get_hdrlen": {
        "description": "Returns the header length of the 802.11 frame based on the frame control field and the presence of Addr4.",
        "proto" :"static int (*hostap_80211_get_hdrlen)(__le16 fc)",
        "pre": {
            "fc": "!=null"
        },
    }
},
{
    "kretprobe:hostap_remove_interface": {
        "description": "Removes the interface from the list if 'remove_from_list' is true. If 'rtnl_locked' is true, it unregisters the netdevice 'dev'. If 'dev->needs_free_netdev' is true, the device data, including private data, will be freed when the device is removed.",
        "proto": "void hostap_remove_interface(struct net_device *dev, int rtnl_locked, int remove_from_list)",
        "pre": {
            "dev": "!=null",
            "rtnl_locked": "in [0, 1]",
            "remove_from_list": "in [0, 1]"
        },
        "post": {
            "dev->needs_free_netdev": "implies (dev->data == null)"
        }
    }
},

{
    "kretprobe:hostap_set_multicast_list": {
        "description": "Set the multicast list for the given network device. If the device is in promiscuous mode or accepts all multicast traffic, an error message is printed.",
        "proto" :"static void (*hostap_set_multicast_list)(struct net_device *dev)",
        "pre": {
            "dev": "!=null",
            "dev->flags": "in [IFF_ALLMULTI, IFF_PROMISC]"
        },
    },
    "kretprobe:hostap_set_multicast_list_queue": {
        "description": "Set the multicast list for the given network device in a queue. If the device is in promiscuous mode or accepts all multicast traffic, an error message is printed.",
        "proto" :"static void (*hostap_set_multicast_list_queue)(struct work_struct *work)",
        "pre": {
            "work": "!=null",
            "local->is_promisc": "in [0, 1]"
        },
    }
},
{
    "kprobe:hostap_set_multicast_list": {
        "description": "Description of the function",
        "proto" :"Function prototype",
        "pre": {
            "dev": "!=null",
            "work": "!=null",
            "local": "!=null",
            "iface": "!=null",
            "flags": "in [IFF_ALLMULTI, IFF_PROMISC]",
        },
    }
},
{
    "kretprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "proto" :"int prism2_rx_80211(struct net_device *dev, struct sk_buff *skb, struct hostap_80211_rx_status *rx_stats, int type)",
        "pre": {
            "dev": "!=null",
            "skb": "!=null && skb->len >= 2 && skb->len >= IEEE80211_DATA_HDR3_LEN",
            "rx_stats": "!=null",
            "type": "is integer"
        },
    }
},
{
    "kprobe:prism2_rx_80211": {
        "description": "Send RX frame to netif with 802.11 (and possible prism) header. Called from hardware or software IRQ context.",
        "proto" :"int (*prism2_rx_80211)(struct net_device *dev, struct sk_buff *skb, struct hostap_80211_rx_status *rx_stats, int type)",
        "pre": {
            "dev": "!=null",
            "skb": "!=null",
            "rx_stats": "!=null",
            "type": "is integer"
        },
    }
},


{
    "kretprobe:hostap_info_process": {
        "description": "Process the hostap information.",
        "proto" :"void hostap_info_process(local_info_t local, struct sk_buff skb, struct hfa384x_info_frame info, unsigned char buf, int left, int i)",
        "pre": {
            "local": "!=null",
            "skb": "!=null",
            "info": "!=null",
            "buf": "!=null",
            "left": ">=0",
            "i": ">=0"
        },
    }
},
{
    "kprobe:hostap_info_process": {
        "description": "Process information in the hostap.",
        "proto" :"void hostap_info_process(local_info_t local, struct sk_buff skb)",
        "pre": {
            "local": "!=null",
            "skb": "!=null",
            "skb->data": "!=null",
            "skb->len": ">= sizeof(*info)"
        },
    }
},
{
    "kretprobe:spin_lock_bh": {
        "description": "Acquire the spinlock and disable bottom halves",
        "proto" :"void spin_lock_bh(spinlock_t *lock);",
        "pre": {
            "lock": "!=null"
        }
    }
},


{
    "kprobe:init_atmel_card": {
        "description": "Create the network device object.",
        "proto" :"init_atmel_card(unsigned short irq, unsigned long port, const AtmelFWType fw_type, struct device sys_dev, int ( card_present)(void ), void card)",
        "pre": {
            "irq": "is a valid interrupt request number",
            "port": "is a valid port number",
            "fw_type": "is a valid AtmelFWType",
            "sys_dev": "!=null",
            "card_present": "is a function pointer",
            "card": "!=null",
        },
    }
},
{
    "kretprobe:stop_atmel_card": {
        "description": "Put a brick on it...",
        "proto" :"void stop_atmel_card(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:stop_atmel_card": {
        "description": "Put a brick on it...",
        "proto" :"stop_atmel_card(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:rtw_phy_read_rf_sipi": {
        "description": "Reads RF SIPI",
        "proto" :"rtw_phy_read_rf_sipi(struct rtw_dev  rtwdev, enum rtw_rf_path rf_path, u32 addr, u32 mask)",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [RF_PATH_A, RF_PATH_B, RF_PATH_C, RF_PATH_D]",
            "addr": "in [0x00, 0xFF]",
            "mask": "!=null"
        },
    }
},
{
    "kprobe:rtw_phy_read_rf_sipi": {
        "description": "Reads from a specific address in a Realtek wireless device.",
        "proto" :"rtw_phy_read_rf_sipi(struct rtw_dev  rtwdev, enum rtw_rf_path rf_path, u32 addr, u32 mask)",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [RF_PATH_A, RF_PATH_B, RF_PATH_C, RF_PATH_D]",
            "addr": "in [0x00, 0xFF]",
            "mask": "is a valid mask"
        },
    }
},
{
    "kretprobe:rtw_phy_set_tx_power_level_by_path": {
        "description": "Set the tx power level by path. Do not need cck rates if we are not in 2.4G.",
        "proto" :"void rtw_phy_set_tx_power_level_by_path(struct rtw_dev *rtwdev, u8 ch, u8 path)",
        "pre": {
            "rtwdev": "!=null",
            "ch": "is valid channel",
            "path": "is valid path"
        }
    }
},
{
    "kprobe:rtw_phy_set_tx_power_level_by_path": {
        "description": "Do not need cck rates if we are not in 2.4G",
        "proto" :"static void (*rtw_phy_set_tx_power_level_by_path)(struct rtw_dev *rtwdev, u8 ch, u8 path)",
        "pre": {
            "rtwdev": "!=null",
            "ch": "is valid channel",
            "path": "is valid path",
        },
    }
},






{
    "kretprobe:rtw_power_mode_change": {
        "description": "Toggle to request power mode, others remain 0",
        "proto" :"rtw_power_mode_change(struct rtw_dev  rtwdev, bool enter)",
        "pre": {
            "rtwdev": "!=null",
            "enter": "is bool"
        }
    }
},
{
    "kprobe:rtw_power_mode_change": {
        "description": "Toggle to request power mode, others remain 0",
        "proto" :"static void (*rtw_power_mode_change)(struct rtw_dev *rtwdev, bool enter)",
        "pre": {
            "rtwdev": "!=null",
            "enter": "is bool"
        },
    }
},
{
    "kretprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "This function handles the command from firmware in an interrupt-safe way.",
        "proto": "void rtw_fw_c2h_cmd_rx_irqsafe(struct rtw_dev *rtwdev, u32 pkt_offset, struct sk_buff *skb)",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": ">=0",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:rtw_fw_c2h_cmd_rx_irqsafe": {
        "description": "This function handles the C2H command received in an interrupt-safe manner.",
        "proto" :"rtw_fw_c2h_cmd_rx_irqsafe(struct rtw_dev *rtwdev, u32 pkt_offset, struct sk_buff *skb)",
        "pre": {
            "rtwdev": "!=null",
            "pkt_offset": ">=0",
            "skb": "!=null"
        },
    }
},
{
    "kretprobe:rtw_tx_report_enqueue": {
        "description": "Pass sn to tx report handler through driver data.",
        "proto" :"void rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn)",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "sn": "is a valid u8 value"
        }
    }
},
{
    "kprobe:rtw_tx_report_enqueue": {
        "description": "Pass sn to tx report handler through driver data",
        "proto" :"void rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn)",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "sn": "is u8",
            "rtwdev->tx_report": "!=null",
            "skb->status.status_driver_data": "!=null"
        },
    }
},


{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[parameter1]": "[condition1]",
            "[parameter2]": "[condition2]",
            "[parameter3]": "[condition3]",
            "[parameter4]": "[condition4]",
        },
    }
},
{
    "kprobe:rtw_pci_probe": {
        "description": "Description of the function",
        "proto" :"static long (*rtw_pci_probe)(struct pci_dev  pdev,  const struct pci_device_id  id)",
        "pre": {
            "pdev": "!=null",
            "id": "!=null",
            // Add other preconditions here
        },
        "post": {
            // Add postconditions here
        }
    }
},
{
    "kretprobe:[function name]": {
        "description": "[function description]",
        "proto" :"[function prototype]",
        "pre": {
            "[param1]": "[condition1]",
            "[param2]": "[condition2]",
            "[param3]": "[condition3]",
            "[param4]": "[condition4]",
        },
    }
},
{
    "kprobe:rtw_ops_tx": {
        "description": "Transmit operation for Realtek wireless device",
        "proto" :"static void rtw_ops_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control, struct sk_buff *skb)",
        "pre": {
            "hw": "!=null",
            "control": "!=null",
            "skb": "!=null"
        }
    },
    "kprobe:rtw_ops_wake_tx_queue": {
        "description": "Wake transmit queue operation for Realtek wireless device",
        "proto" :"static void rtw_ops_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *txq)",
        "pre": {
            "hw": "!=null",
            "txq": "!=null"
        }
    }
},

{
    "kprobe:rtw_coex_write_scbd": {
        "description": "Writes to the score board of the coex structure. For 8822b, scbd[10] is CQDDR on. For 8822c, scbd[10] is no fix 2M.",
        "proto" :"void rtw_coex_write_scbd(struct rtw_dev *rtwdev, u16 bitpos, bool set)",
        "pre": {
            "rtwdev": "!=null",
            "rtwdev->chip": "!=null",
            "rtwdev->coex": "!=null",
            "rtwdev->coex->stat": "!=null",
            "bitpos": "in [COEX_SCBD_FIX2M, ...]",
            "set": "is boolean"
        },
        "post": {
            "if (!chip->new_scbd10_def && (bitpos & COEX_SCBD_FIX2M))": {
                "chip->new_scbd10_def": "==false",
                "bitpos & COEX_SCBD_FIX2M": "!=0"
            }
        }
    }
},


{
    "kretprobe:rtw89_phy_write_rf": {
        "description": "Writes to the RF register of the RTW89 device. The function takes in the device, the RF path, the address, the mask, and the data to be written. It checks if the RF path is supported, and if not, it returns false. If the RF path is supported, it writes the data to the direct address and returns true.",
        "proto": "bool (*rtw89_phy_write_rf)(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path, u32 addr, u32 mask, u32 data)",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [RTW89_RF_PATH_A, RTW89_RF_PATH_B]",
            "addr": "in [0x00, 0xFF]",
            "mask": "in [0x00, RFREG_MASK]",
            "data": "any"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:rtw89_phy_write_rf": {
        "description": "Writes to the RF register of the RTW89 device. The function takes in the device, RF path, address, mask, and data as parameters. It checks if the RF path is supported, calculates the direct address, applies the mask to the data, and writes it to the direct address. A delay is added to ensure the write operation completes properly.",
        "proto" :"static bool (*rtw89_phy_write_rf)(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path, u32 addr, u32 mask, u32 data)",
        "pre": {
            "rtwdev": "!=null",
            "rf_path": "in [supported rf paths]",
            "addr": "in [0x00, 0xFF]",
            "mask": "in [RFREG_MASK]",
            "data": "any"
        },
    }
},
{
    "kretprobe:rtw89_phy_write32_idx": {
        "description": "This function seems to write data to a specific address with a mask and an index. More details are needed for a precise description.",
        "proto" :"void rtw89_phy_write32_idx(struct rtw89_dev *rtwdev, u32 addr, u32 mask, u32 data, enum rtw89_phy_idx phy_idx)",
        "pre": {
            "rtwdev": "!=null",
            "addr": ">=0",
            "mask": ">=0",
            "data": ">=0",
            "phy_idx": "in [RTW89_PHY_0, RTW89_PHY_1, RTW89_PHY_2, RTW89_PHY_3]" // Assuming these are the possible values for rtw89_phy_idx
        }
    }
},
{
    "kprobe:rtw89_phy_write32_idx": {
        "description": "Description needed",
        "proto" :"void rtw89_phy_write32_idx(struct rtw89_dev *rtwdev, u32 addr, u32 mask, u32 data, enum rtw89_phy_idx phy_idx)",
        "pre": {
            "rtwdev": "!=null",
            "addr": "Condition needed",
            "mask": "Condition needed",
            "data": "Condition needed",
            "phy_idx": "Condition needed"
        },
    }
},
{
    "kretprobe:rtw89_core_query_rxdesc": {
        "description": "This function queries the RX descriptor.",
        "proto": "void rtw89_core_query_rxdesc(struct rtw89_dev rtwdev, struct rtw89_rx_desc_info desc_info, u8 data, u32 data_offset)",
        "pre": {
            "rtwdev": "!=null",
            "desc_info": "!=null",
            "data": "!=null",
            "data_offset": ">=0"
        },
        "post": {
            "drv_info_len": "desc_info->drv_info_size << 3"
        }
    }
},
{
    "kprobe:rtw89_core_query_rxdesc": {
        "description": "Your function description here",
        "proto" :"static long (*rtw89_core_query_rxdesc)(struct rtw89_dev  rtwdev, struct rtw89_rx_desc_info  desc_info, u8  data, u32 data_offset)",
        "pre": {
            "rtwdev": "Your condition here",
            "desc_info": "Your condition here",
            "data": "Your condition here",
            "data_offset": "Your condition here"
        },
    }
},
{
    "kretprobe:rtw89_core_rx_process_mac_ppdu": {
        "description": "Process the MAC PPDU received.",
        "proto" :"static void rtw89_core_rx_process_mac_ppdu(struct rtw89_dev rtwdev, struct sk_buff skb, struct rtw89_rx_phy_ppdu phy_ppdu)",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "phy_ppdu": "!=null"
        },
    }
},
{
    "kprobe:rtw89_core_rx_process_mac_ppdu": {
        "description": "Description of the function",
        "proto" :"static void rtw89_core_rx_process_mac_ppdu(struct rtw89_dev rtwdev, struct sk_buff skb, struct rtw89_rx_phy_ppdu phy_ppdu)",
        "pre": {
            "rtwdev": "!=null",
            "skb": "!=null",
            "phy_ppdu": "!=null"
        },
    }
},




{
    "kretprobe:rtw89_btc_set_policy": {
        "description": "Description of the function",
        "proto" :"static long (*rtw89_btc_set_policy)(struct rtw89_dev  rtwdev, u16 policy_type)",
        "pre": {
            "rtwdev": "!=null",
            "policy_type": "in [list of possible policy types]"
        },
    }
},
{
    "kprobe:rtw89_btc_set_policy": {
        "description": "Description of the function",
        "proto" :"static void (*rtw89_btc_set_policy)(struct rtw89_dev *rtwdev, u16 policy_type)",
        "pre": {
            "rtwdev": "!=null",
            "policy_type": "in [list of possible policy types]",
        },
    }
},
{
    "kretprobe:rtw89_btc_set_policy_v1": {
        "description": "Sets the policy for the rtw89 device.",
        "proto" :"static long (*rtw89_btc_set_policy_v1)(struct rtw89_dev  rtwdev, u16 policy_type)",
        "pre": {
            "rtwdev": "!=null",
            "policy_type": "in [BTC_CXP_MASK]"
        },
    }
},

{
    "kretprobe:rtl_init_rfkill": {
        "description": "Initialize the rfkill state of the rtl device.",
        "proto" :"static void (*rtl_init_rfkill)(struct ieee80211_hw *hw)",
        "pre": {
            "hw": "!=null"
        },
        "post": {
            "rtlpriv->rfkill.rfkill_state": "==true",
            "wiphy_rfkill_set_hw_state(hw->wiphy, 0)": "==0",
            "radio_state": "in [true, false]",
            "valid": "in [0, 1]"
        }
    }
},
{
    "kprobe:rtl_init_rfkill": {
        "description": "Initialize rfkill and set initial state to on.",
        "proto" :"static void (*rtl_init_rfkill)(struct ieee80211_hw *hw)",
        "pre": {
            "hw": "!=null"
        },
    },
    "kprobe:wiphy_rfkill_set_hw_state": {
        "description": "Set the rfkill hardware state.",
        "proto" :"static void (*wiphy_rfkill_set_hw_state)(struct wiphy *wiphy, int state)",
        "pre": {
            "wiphy": "!=null",
            "state": "==0"
        },
    },
    "kprobe:radio_onoff_checking": {
        "description": "Check the radio on/off state.",
        "proto" :"static bool (*radio_onoff_checking)(struct ieee80211_hw *hw, u8 *valid)",
        "pre": {
            "hw": "!=null",
            "valid": "!=null"
        },
    }
},
{
    "kretprobe:rtl_get_tcb_desc": {
        "description": "This function seems to be related to setting the data rate for specific data and management frames in a wireless network context. However, the exact functionality is not clear from the provided documentation.",
        "proto" :"rtl_get_tcb_desc(struct ieee80211_hw hw, struct ieee80211_tx_info info, struct ieee80211_sta sta, struct sk_buff skb, struct rtl_tcb_desc tcb_desc)",
        "pre": {
            "hw": "!=null",
            "info": "!=null",
            "sta": "!=null",
            "skb": "!=null",
            "tcb_desc": "!=null"
        },
    }
},

{
    "kretprobe:rtl_collect_scan_list": {
        "description": "Collects scan list for the rtl device.",
        "proto" :"rtl_collect_scan_list(struct ieee80211_hw  hw, struct sk_buff  skb)",
        "pre": {
            "hw": "!=null",
            "skb": "!=null"
        }
    }
},
{
    "kprobe:rtl_collect_scan_list": {
        "description": "Collects scan list for the rtl device.",
        "proto" :"static void (*rtl_collect_scan_list)(struct ieee80211_hw *hw, struct sk_buff *skb)",
        "pre": {
            "hw": "!=null",
            "skb": "!=null"
        },
    }
},
{
    "kretprobe:skb_queue_tail": {
        "description": "Your description here",
        "proto" :"static long (*skb_queue_tail)(struct rtl_priv *rtlpriv, struct sk_buff *skb)",
        "pre": {
            "rtlpriv": "Your condition here",
            "skb": "Your condition here"
        },
    }
},
{
    "kprobe:skb_queue_tail": {
        "description": "Description of the function",
        "proto" :"static long (*skb_queue_tail)(struct rtl_priv *rtlpriv, struct sk_buff *skb)",
        "pre": {
            "rtlpriv": "!=null",
            "skb": "!=null",
        },
    }
},
{
    "kretprobe:rtl_send_smps_action": {
        "description": "This function sends an SMPS (Spatial Multiplexing Power Save) action frame. It checks if the socket buffer (skb) is not null after it is assigned a value by the function rtl_make_smps_action.",
        "proto" :"static void (*rtl_send_smps_action)(struct ieee80211_hw  hw, struct ieee80211_sta  sta, enum ieee80211_smps_mode smps)",
        "pre": {
            "hw": "!=null",
            "sta": "!=null",
            "smps": "in [IEEE80211_SMPS_AUTOMATIC, IEEE80211_SMPS_OFF, IEEE80211_SMPS_STATIC, IEEE80211_SMPS_DYNAMIC, IEEE80211_SMPS_UNSPECIFIED, IEEE80211_SMPS_NUM_MODES]",
            "skb": "!=null"
        },
    }
},
{
    "kprobe:rtl_send_smps_action": {
        "description": "This function sends an SMPS (Spatial Multiplexing Power Save) action frame. It first checks if the system is currently scanning, if the station (sta) is not null, if the hardware is not stopped and the power state is ERFON, if the interface has started, and finally if the sk_buff (skb) is not null.",
        "proto" :"static void (*rtl_send_smps_action)(struct ieee80211_hw *hw, struct ieee80211_sta *sta, enum ieee80211_smps_mode smps)",
        "pre": {
            "hw": "!=null",
            "sta": "!=null",
            "smps": "in [IEEE80211_SMPS_AUTOMATIC, IEEE80211_SMPS_OFF, IEEE80211_SMPS_STATIC, IEEE80211_SMPS_DYNAMIC, IEEE80211_SMPS_UNSPECIFIED, IEEE80211_SMPS_NUM_MODES]",
            "rtlpriv->mac80211.act_scanning": "==false",
            "is_hal_stop(rtlhal)": "==false",
            "ppsc->rfpwr_state": "==ERFON",
            "test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status)": "==true",
            "skb": "!=null"
        },
    }
},
{
    "kretprobe:rtl_usb_probe": {
        "description": "Initializes the rtl_usb_probe function with various parameters.",
        "proto" :"rtl_usb_probe(struct usb_interface  intf,  const struct usb_device_id  id,  struct rtl_hal_cfg  rtl_hal_cfg)",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "rtl_hal_cfg": "!=null"
        },
        "post": {
            "rtlpriv->locks.usb_lock": "initialized",
            "rtlpriv->works.fill_h2c_cmd": "initialized",
            "rtlpriv->works.lps_change_work": "initialized",
            "rtlpriv->works.update_beacon_work": "initialized",
            "rtlpriv->usb_data_index": "=0",
            "rtlpriv->firmware_loading_complete": "initialized",
            "hw": "!=null",
            "udev": "!=null",
            "usb_priv": "initialized",
            "usb_priv->dev.intf": "=intf",
            "usb_priv->dev.udev": "=udev",
            "intf": "associated with hw"
        }
    }
},
{
    "rtl_usb_probe": {
        "description": "This function initializes the rtl_usb device.",
        "proto": "int rtl_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, struct rtl_hal_cfg *rtl_hal_cfg)",
        "pre": {
            "intf": "!=null",
            "id": "!=null",
            "rtl_hal_cfg": "!=null"
        },
        "post": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "udev": "!=null",
            "usb_priv": "!=null",
            "rtlpriv->usb_data": "!=null",
            "rtlpriv->locks.usb_lock": "initialized",
            "rtlpriv->works.fill_h2c_cmd": "initialized",
            "rtlpriv->works.lps_change_work": "initialized",
            "rtlpriv->works.update_beacon_work": "initialized",
            "rtlpriv->firmware_loading_complete": "initialized",
            "usb_priv->dev.intf": "intf",
            "usb_priv->dev.udev": "udev",
            "intf->dev": "hw"
        }
    }
},
{
    "kretprobe:rtl_usb_disconnect": {
        "description": "Disconnects the rtl_usb. Just in case driver is removed before firmware callback.",
        "proto" :"static void (*rtl_usb_disconnect)(struct usb_interface *intf)",
        "pre": {
            "intf": "!=null"
        },
    }
},



{
    "kretprobe:rtl_hal_pwrseqcmdparsing": {
        "description": "Reads the value from system register, applies bitwise operations and writes the value back to the system register.",
        "proto": "void rtl_hal_pwrseqcmdparsing(struct rtl_priv  rtlpriv, u8 cut_version, u8 faversion, u8 interface_type, struct wlan_pwr_cfg pwrcfgcmd[])",
        "pre": {
            "rtlpriv": "!=null",
            "cut_version": "is u8",
            "faversion": "is u8",
            "interface_type": "is u8",
            "pwrcfgcmd": "!=null"
        },
        "post": {
            "value": "is u8",
            "offset": "is u32",
            "polling_count": "is u32",
            "max_polling_cnt": "is u32",
            "cfg_cmd": "is struct wlan_pwr_cfg",
            "polling_bit": "is bool",
            "ary_idx": "is u32"
        }
    }
},
{
    "kprobe:rtl_hal_pwrseqcmdparsing": {
        "description": "Parse the power sequence command and perform the corresponding operation.",
        "proto": "void rtl_hal_pwrseqcmdparsing(struct rtl_priv  rtlpriv, u8 cut_version, u8 faversion, u8 interface_type, struct wlan_pwr_cfg pwrcfgcmd[])",
        "pre": {
            "rtlpriv": "!=null",
            "cut_version": "is u8",
            "faversion": "is u8",
            "interface_type": "is u8",
            "pwrcfgcmd": "!=null"
        },
        "post": {
            "value": "is u8",
            "offset": "is u32",
            "polling_count": "is u32",
            "max_polling_cnt": "is u32",
            "cfg_cmd": "is struct wlan_pwr_cfg",
            "polling_bit": "is bool",
            "ary_idx": "is u32"
        }
    }
},
{
    "kretprobe:rtl_cmd_send_packet": {
        "description": "Send a command packet to the hardware device.",
        "proto": "static bool (*rtl_cmd_send_packet)(struct ieee80211_hw *hw, struct sk_buff *skb)",
        "pre": {
            "hw": "!=null",
            "skb": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv->cfg": "!=null",
            "rtlpriv->cfg->ops": "!=null",
            "pdesc": "!=null"
        },
        "post": {
            "hardware_state": "specific_state"
        }
    }
},
{
    "kprobe:rtl_cmd_send_packet": {
        "description": "Your function description here",
        "proto" :"rtl_cmd_send_packet(struct ieee80211_hw hw, struct sk_buff skb)",
        "pre": {
            "hw": "Your hw constraints here",
            "skb": "Your skb constraints here"
        },
    }
},
{
    "kretprobe:rtl_ps_enable_nic": {
        "description": "Reset trx ring",
        "proto" :"static void (*rtl_ps_enable_nic)(struct ieee80211_hw *hw)",
        "pre": {
            "hw": "!=null"
        }
    }
},
{
    "kprobe:rtl_ps_enable_nic": {
        "description": "<1> reset trx ring",
        "proto" :"static void (*rtl_ps_enable_nic)(struct ieee80211_hw *hw)",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "ppsc": "!=null",
            "rtlhal": "!=null",
            "rtlmac": "!=null"
        },
    }
},
{
    "kretprobe:rtl_ps_disable_nic": {
        "description": "<1> Stop all timer",
        "proto": "void rtl_ps_disable_nic(struct ieee80211_hw *hw)",
        "pre": {
            "hw": "!=null"
        }
    }
},

{
    "kretprobe:rtl_pci_probe": {
        "description": "This function is used to probe the PCI device and initialize the rtl_priv and rtl_pci_priv structures.",
        "proto" :"int rtl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        },
        "post": {
            "return": "in [-ENOMEM, 0]"
        }
    }
},
{
    "kprobe:rtl_pci_probe": {
        "description": "This function is used to probe the PCI device and initialize the rtl_priv and rtl_pci_priv structures.",
        "proto" :"int rtl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)",
        "pre": {
            "pdev": "!=null",
            "id": "!=null"
        },
        "post": {
            "err": "in [0, -ENOMEM]"
        }
    }
},


{
    "kretprobe:your_function_name": {
        "description": "Your function description",
        "proto" :"Your function prototype",
        "pre": {
            "param1": "condition1",
            "param2": "condition2",
            "param3": "condition3",
            "param4": "condition4",
        },
    }
},
{
    "kprobe:kzalloc": {
        "description": "Allocates memory and returns a pointer to it, or NULL in case of failure.",
        "proto" :"void *kzalloc(size_t size, gfp_t flags)",
        "pre": {
            "size": ">0",
            "flags": "in [GFP_ATOMIC, GFP_KERNEL, ...]",
        },
    },
    "kprobe:kcalloc": {
        "description": "Allocates memory for an array of n elements of size bytes each and returns a pointer to the allocated memory.",
        "proto" :"void *kcalloc(size_t n, size_t size, gfp_t flags)",
        "pre": {
            "n": ">0",
            "size": ">0",
            "flags": "in [GFP_ATOMIC, GFP_KERNEL, ...]",
        },
    }
},

{
    "kprobe:rtl_cam_del_entry": {
        "description": "Delete an entry from the CAM table.",
        "proto" :"rtl_cam_del_entry(struct ieee80211_hw  hw, u8  sta_addr)",
        "pre": {
            "hw": "!=null",
            "sta_addr": "!=null && !is_zero_ether_addr(sta_addr)",
        },
    }
},
{
    "kretprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Please replace with the correct description",
        "proto" :"Please replace with the correct prototype",
        "pre": {
            "hw": "Please replace with the correct condition",
            "b_patha_ok": "Please replace with the correct condition",
            "result": "Please replace with the correct condition",
            "final_candidate": "Please replace with the correct condition",
            "reg_ea4": "Please replace with the correct condition",
            "rtlhal->version": "Please replace with the correct condition"
        },
    }
},
{
    "kprobe:_rtl92c_phy_path_a_fill_iqk_matrix": {
        "description": "Fill the IQK matrix for path A in RTL92C.",
        "proto" :"static void (*_rtl92c_phy_path_a_fill_iqk_matrix)(struct ieee80211_hw *hw, bool b_patha_ok, long result[4][8], u8 final_candidate, bool reg_ea4_zero)",
        "pre": {
            "hw": "!=null",
            "b_patha_ok": "!=null",
            "result": "!=null",
            "final_candidate": "!=null",
            "reg_ea4_zero": "==true",
            "IS_92C_SERIAL(rtlhal->version)": "==true"
        },
    }
},
{
    "kretprobe:rtl92c_dm_ctrl_initgain_by_fa": {
        "description": "Control the initial gain by false alarm counter. If the count of all false alarms is greater than 10000, the initial gain value is set to DM_DIG_FA_UPPER.",
        "proto": "static void rtl92c_dm_ctrl_initgain_by_fa(struct ieee80211_hw hw)",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv->falsealm_cnt.cnt_all": "> 10000"
        }
    }
},
{
    "kprobe:rtl92c_dm_ctrl_initgain_by_fa": {
        "description": "Control the initial gain by false alarm. If the count of all false alarms is greater than 10000, the initial gain value is set to DM_DIG_FA_UPPER.",
        "proto": "static void rtl92c_dm_ctrl_initgain_by_fa(struct ieee80211_hw hw)",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "rtlpriv->falsealm_cnt.cnt_all": "> 10000"
        }
    }
},

{
    "kprobe:rtl92c_dm_watchdog": {
        "description": "This function seems to be a watchdog function for the rtl92c device. It monitors and manages the power state of the device, among other things.",
        "proto" :"rtl92c_dm_watchdog(struct ieee80211_hw  hw)",
        "pre": {
            "hw": "!=null",
        },
    }
},
{
    "kretprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine HighPowerNormalPower state for BT coexistence.",
        "proto" :"u8 rtl92c_bt_rssi_state_change(struct ieee80211_hw hw)",
        "pre": {
            "hw": "!=null"
        },
        "post": {
            "return": "in [0x00, 0x01]"
        }
    }
},
{
    "kprobe:rtl92c_bt_rssi_state_change": {
        "description": "Check RSSI to determine HighPowerNormalPower state for BT coexistence.",
        "proto": "u8 rtl92c_bt_rssi_state_change(struct ieee80211_hw hw)",
        "pre": {
            "hw": "!=null",
            "rtlpriv": "!=null",
            "undec_sm_pwdb": "is long",
            "curr_bt_rssi_state": "== 0x00",
            "rtlpriv->mac80211.link_state": "in [MAC80211_LINKED, MAC80211_UNLINKED]",
            "rtlpriv->dm.entry_min_undec_sm_pwdb": "is long"
        },
        "post": {
            "undec_sm_pwdb": ">= 67 ? curr_bt_rssi_state &= (~BT_RSSI_STATE_NORMAL_POWER) : (undec_sm_pwdb < 62 ? curr_bt_rssi_state |= BT_RSSI_STATE_NORMAL_POWER : curr_bt_rssi_state)"
        }
    }
},



{
    "kprobe:stop_airo_card": {
        "description": "Stops the airo card, disables MAC and interrupts, takes down proc entry, unregisters netdev if FLAG_REGISTERED is set, and cleans out tx queue.",
        "proto" :"void stop_airo_card(struct net_device *dev, int freeres)",
        "pre": {
            "dev": "!=null",
            "freeres": "is an integer",
            "dev->ml_priv": "!=null",
            "ai->flags": "is a pointer to a bitfield",
            "ai->txq": "is a pointer to a sk_buff_head structure"
        },
        "post": {
            "ai->flags": "FLAG_RADIO_DOWN is set",
            "ai->flags": "FLAG_REGISTERED is cleared if it was set",
            "ai->wifidev": "is NULL if it was not NULL",
            "ai->txq": "is empty"
        }
    }
},
{
    "kretprobe:init_airo_card": {
        "description": "Create the network device object.",
        "proto" :"static struct net_device *(*alloc_netdev)(int sizeof_priv, const char *name, unsigned char name_assign_type, void (*setup)(struct net_device *))",
        "pre": {
            "sizeof_priv": ">= sizeof(struct airo_info)",
            "name": "== ''",
            "name_assign_type": "== NET_NAME_UNKNOWN",
            "setup": "== ether_setup"
        },
        "post": {
            "return": "!= null"
        }
    }
},
{
    "init_airo_card": {
        "description": "Create the network device object.",
        "proto" :"init_airo_card(unsigned short irq, int port, int is_pcmcia, struct pci_dev pci, struct device dmdev)",
        "pre": {
            "irq": ">=0",
            "port": ">=0",
            "is_pcmcia": "in [0, 1]",
            "pci": "!=null",
            "dmdev": "!=null"
        },
    }
},
{
    "kretprobe:reset_airo_card": {
        "description": "Reset the airo card and allocate the transmit buffers if needed.",
        "proto" :"int reset_airo_card(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": "in [-1, 0]"
    }
},
{
    "kprobe:reset_airo_card": {
        "description": "Reset the airo card and allocate the transmit buffers if needed.",
        "proto" :"int reset_airo_card(struct net_device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:cancel_work_sync": {
        "description": "Cancels a work and waits for it to finish.",
        "proto" :"void cancel_work_sync(struct work_struct *work)",
        "pre": {
            "work": "!=null"
        }
    }
},
{
    "kprobe:usbnet_link_change": {
        "description": "Change the link status of the usbnet device.",
        "proto" :"static void (*usbnet_link_change)(struct usbnet *dev, bool link, bool persist)",
        "pre": {
            "dev": "!=null",
            "link": "in [0, 1]",
            "persist": "in [0, 1]"
        },
    }
},
{
    "kretprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status",
        "proto": "void (*phy_print_status)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_print_status": {
        "description": "Convenience function to print out the current phy status",
        "proto" :"void (*phy_print_status)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from this @phydev. Returns > 0 on success or < 0 on error. 0 means that auto-negotiation is still pending.",
        "proto" :"int (*phy_aneg_done)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [-inf, inf]"
        }
    }
},
{
    "kprobe:phy_aneg_done": {
        "description": "Return the auto-negotiation status from this @phydev. Returns > 0 on success or < 0 on error. 0 means that auto-negotiation is still pending.",
        "proto" :"int (*phy_aneg_done)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [>0, <0, 0]"
        }
    }
},
{
    "kretprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask. Returns true if there is a valid setting, false otherwise.",
        "proto" :"bool (*phy_check_valid)(int speed, int duplex, unsigned long *features)",
        "pre": {
            "speed": ">=0",
            "duplex": "in [0, 1]",
            "features": "!=null"
        },
    }
},
{
    "kprobe:phy_check_valid": {
        "description": "Check if there is a valid PHY setting which matches speed, duplex, and feature mask. Returns true if there is a valid setting, false otherwise.",
        "proto" :"bool (*phy_check_valid)(int speed, int duplex, unsigned long *features)",
        "pre": {
            "speed": ">=0",
            "duplex": "in [0, 1]",
            "features": "!=null"
        }
    }
},
{
    "kretprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface. Note that this function is currently incompatible with the PHYCONTROL layer. It changes registers without regard to current state. Use at own risk.",
        "proto" :"int (*phy_mii_ioctl)(struct phy_device *phydev, struct ifreq *ifr, int cmd)",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "is a valid ioctl command"
        },
    }
},
{
    "kprobe:phy_mii_ioctl": {
        "description": "Generic PHY MII ioctl interface. Note that this function is currently incompatible with the PHYCONTROL layer. It changes registers without regard to current state. Use at own risk.",
        "proto" :"int (*phy_mii_ioctl)(struct phy_device *phydev, struct ifreq *ifr, int cmd)",
        "pre": {
            "phydev": "!=null",
            "ifr": "!=null",
            "cmd": "is a valid ioctl command"
        },
    }
},
{
    "kretprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation. Executes ioctl cmd for socket ioctl's in the net_device struct.",
        "proto" :"int (*phy_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd)",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "is integer"
        },
    }
},
{
    "kprobe:phy_do_ioctl": {
        "description": "Generic ndo_eth_ioctl implementation. Executes ioctl cmd for socket ioctl's.",
        "proto" :"int (*phy_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd)",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "in [SIOCSHWTSTAMP, ...]" // Please replace ... with the rest of the possible cmd values
        },
    }
},
{
    "kretprobe:phy_do_ioctl_running": {
        "description": "Generic ndo_eth_ioctl implementation but test first. Ensures that net_device is running before handling the ioctl.",
        "proto" :"int (*phy_do_ioctl_running)(struct net_device *dev, struct ifreq *ifr, int cmd)",
        "pre": {
            "dev": "!=null && dev->state == RUNNING",
            "ifr": "!=null",
            "cmd": "in [SIOCGIFFLAGS, SIOCSIFFLAGS, SIOCGIFADDR, SIOCSIFADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFMAP, SIOCSIFMAP, SIOCADDMULTI, SIOCDELMULTI, SIOCGIFHWADDR, SIOCSIFHWADDR, SIOCGIFENCAP, SIOCSIFENCAP, SIOCGIFSLAVE, SIOCSIFSLAVE, SIOCGIFINDEX, SIOGIFNAME, SIOCSIFLINK, SIOCGIFCONF, SIOCGIFMEM, SIOCSIFMEM, SIOCGIFDSTADDR, SIOCSIFDSTADDR, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFNAME, SIOCSIFNAME, SIOCSIFHWBROADCAST, SIOCGIFCOUNT, SIOCGIFBR, SIOCSIFBR, SIOCGIFTXQLEN, SIOCSIFTXQLEN, SIOCDIFADDR, SIOCSIFDSTADDR, SIOCGIFDSTADDR, SIOCAIFADDR, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFNAME, SIOCSIFNAME, SIOCSIFHWBROADCAST, SIOCGIFCOUNT, SIOCGIFBR, SIOCSIFBR, SIOCGIFTXQLEN, SIOCSIFTXQLEN, SIOCDIFADDR, SIOCGIFDEVCONF, SIOCSIFDEVCONF, SIOCGIFCONF, SIOCGIFFRAG, SIOCSIFFRAG, SIOCGIFSLAVE, SIOCSIFSLAVE, SIOCGIFINDEX, SIOGIFNAME, SIOCSIFLINK, SIOCGIFMEM, SIOCSIFMEM, SIOCGIFHWADDR, SIOCSIFHWADDR, SIOCGIFENCAP, SIOCSIFENCAP, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFMAP, SIOCSIFMAP, SIOCADDMULTI, SIOCDELMULTI, SIOCGIFINDEX, SIOGIFNAME, SIOCSIFLINK, SIOCGIFCONF, SIOCGIFMEM, SIOCSIFMEM, SIOCGIFDSTADDR, SIOCSIFDSTADDR, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFNAME, SIOCSIFNAME, SIOCSIFHWBROADCAST, SIOCGIFCOUNT, SIOCGIFBR, SIOCSIFBR, SIOCGIFTXQLEN, SIOCSIFTXQLEN, SIOCDIFADDR, SIOCGIFDEVCONF, SIOCSIFDEVCONF, SIOCGIFCONF, SIOCGIFFRAG, SIOCSIFFRAG, SIOCGIFSLAVE, SIOCSIFSLAVE, SIOCGIFINDEX, SIOGIFNAME, SIOCSIFLINK, SIOCGIFMEM, SIOCSIFMEM, SIOCGIFHWADDR, SIOCSIFHWADDR, SIOCGIFENCAP, SIOCSIFENCAP, SIOCGIFBRDADDR, SIOCSIFBRDADDR, SIOCGIFNETMASK, SIOCSIFNETMASK, SIOCGIFMETRIC, SIOCSIFMETRIC, SIOCGIFMTU, SIOCSIFMTU, SIOCGIFMAP, SIOCSIFMAP, SIOCADDMULTI, SIOCDELMULTI]"
        },
    }
},
{
    "kprobe:phy_do_ioctl_running": {
        "description": "Generic ndo_eth_ioctl implementation but test first. Ensures that net_device is running before handling the ioctl.",
        "proto" :"int (*phy_do_ioctl_running)(struct net_device *dev, struct ifreq *ifr, int cmd)",
        "pre": {
            "dev": "!=null",
            "ifr": "!=null",
            "cmd": "!=null"
        },
    }
},
{
    "kretprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon. @phydev: the phy_device struct. @jiffies: Run the state machine after these jiffies.",
        "proto" :"void (*phy_queue_state_machine)(struct phy_device *phydev, unsigned long jiffies)",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kprobe:phy_queue_state_machine": {
        "description": "Trigger the state machine to run soon. @phydev: the phy_device struct. @jiffies: Run the state machine after these jiffies.",
        "proto" :"void (*phy_queue_state_machine)(struct phy_device *phydev, unsigned long jiffies)",
        "pre": {
            "phydev": "!=null",
            "jiffies": ">=0"
        }
    }
},
{
    "kretprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "proto" :"void (*phy_trigger_machine)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_trigger_machine": {
        "description": "Trigger the state machine to run now",
        "proto" :"void (*phy_trigger_machine)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names. @phydev: the phy_device struct. @data: Where to put the strings.",
        "proto" :"int (*phy_ethtool_get_strings)(struct phy_device *phydev, u8 *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_strings": {
        "description": "Get the statistic counter names @phydev: the phy_device struct @data: Where to put the strings",
        "proto" :"int (*phy_ethtool_get_strings)(struct phy_device *phydev, u8 *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "proto" :"int (*phy_ethtool_get_sset_count)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_sset_count": {
        "description": "Get the number of statistic counters",
        "proto" :"int (*phy_ethtool_get_sset_count)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters. @phydev: the phy_device struct. @stats: What counters to get. @data: Where to store the counters.",
        "proto" :"int (*phy_ethtool_get_stats)(struct phy_device *phydev, struct ethtool_stats *stats, u64 *data)",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_stats": {
        "description": "Get the statistic counters. @phydev: the phy_device struct. @stats: What counters to get. @data: Where to store the counters.",
        "proto" :"int (*phy_ethtool_get_stats)(struct phy_device *phydev, struct ethtool_stats *stats, u64 *data)",
        "pre": {
            "phydev": "!=null",
            "stats": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test": {
        "description": "Start a cable test. @phydev: the phy_device struct. @extack: extack for reporting useful error messages.",
        "proto" :"int (*phy_start_cable_test)(struct phy_device *phydev, struct netlink_ext_ack *extack)",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test": {
        "description": "Start a cable test. @phydev: the phy_device struct. @extack: extack for reporting useful error messages.",
        "proto" :"int (*phy_start_cable_test)(struct phy_device *phydev, struct netlink_ext_ack *extack)",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null"
        }
    }
},
{
    "kretprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test. @phydev: the phy_device struct. @extack: extack for reporting useful error messages. @config: Configuration of the test to run.",
        "proto" :"int (*phy_start_cable_test_tdr)(struct phy_device *phydev, struct netlink_ext_ack *extack, const struct phy_tdr_config *config)",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        }
    }
},
{
    "kprobe:phy_start_cable_test_tdr": {
        "description": "Start a raw TDR cable test. @phydev: the phy_device struct. @extack: extack for reporting useful error messages. @config: Configuration of the test to run.",
        "proto" :"int (*phy_start_cable_test_tdr)(struct phy_device *phydev, struct netlink_ext_ack *extack, const struct phy_tdr_config *config)",
        "pre": {
            "phydev": "!=null",
            "extack": "!=null",
            "config": "!=null"
        },
    }
},
{
    "kretprobe:phy_config_aneg": {
        "description": "Configures auto-negotiation for the PHY device. Clause 45 PHYs that don't implement Clause 22 registers are not allowed to call genphy_config_aneg()",
        "proto" :"int phy_config_aneg(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null",
            "phydev->drv": "!=null",
            "phydev->drv->config_aneg": "!=null",
            "phydev->is_c45": "in [0, 1]",
            "phydev->c45_ids.devices_in_package & BIT(0)": "in [0, 1]"
        },
        "post": {
            "return": "in [genphy_c45_config_aneg(phydev), genphy_config_aneg(phydev)]"
        }
    }
},
{
    "kprobe:phy_config_aneg": {
        "description": "Configures auto-negotiation for the PHY device. If the PHY device is a Clause 45 PHY that doesn't implement Clause 22 registers, it is not allowed to call genphy_config_aneg().",
        "proto" :"int phy_config_aneg(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null",
            "phydev->drv": "!=null",
            "phydev->drv->config_aneg": "!=null",
            "phydev->is_c45": "in [0, 1]",
            "phydev->c45_ids.devices_in_package & BIT(0)": "in [0, 1]"
        },
    }
},
{
    "kretprobe:linkmode_and": {
        "description": "Performs a bitwise AND operation on the first two parameters and stores the result in the third parameter.",
        "proto" :"void (*linkmode_and)(void *advertising1, void *advertising2, void *supported)",
        "pre": {
            "advertising1": "!=null",
            "advertising2": "!=null",
            "supported": "!=null"
        },
    }
},
{
    "kprobe:linkmode_and": {
        "description": "Ensure that unsupported values are not passed into the PHY.",
        "proto" :"static void (*linkmode_and)(void *advertising, void *advertising, void *phydev->supported)",
        "pre": {
            "advertising": "!=null",
            "phydev->supported": "!=null",
        },
    }
},
{
    "kretprobe:phy_error": {
        "description": "Moves the PHY to the ERROR state in response to a read or write error, and tells the controller the link is down. Must not be called from interrupt context, or while the phydev->lock is held.",
        "proto": "void (*phy_error)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null && phydev->lock != held"
        }
    }
},
{
    "kprobe:phy_error": {
        "description": "Moves the PHY to the ERROR state in response to a read or write error, and tells the controller the link is down. Must not be called from interrupt context, or while the phydev->lock is held.",
        "proto" :"void (*phy_error)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_request_interrupt": {
        "description": "Request and enable the interrupt for the given PHY. If this fails, then we set irq to PHY_POLL. This should only be called with a valid IRQ number.",
        "proto" :"void (*phy_request_interrupt)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_request_interrupt": {
        "description": "Request and enable the interrupt for the given PHY. If this fails, then we set irq to PHY_POLL. This should only be called with a valid IRQ number.",
        "proto" :"void (*phy_request_interrupt)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_free_interrupt": {
        "description": "Disable and free the interrupt for the given PHY. This should only be called with a valid IRQ number.",
        "proto" :"void (*phy_free_interrupt)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null && phydev->irq != PHY_POLL"
        }
    }
},
{
    "kprobe:phy_free_interrupt": {
        "description": "Disable and free the interrupt for the given PHY. This should only be called with a valid IRQ number.",
        "proto" :"void (*phy_free_interrupt)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null",
            "phydev->irq": "is valid IRQ number"
        }
    }
},
{
    "kretprobe:phy_stop_machine": {
        "description": "Stops the PHY state machine delayed workqueue, sets the state to UP (unless it wasn't up yet). This function must be called BEFORE phy_detach.",
        "proto" :"void (*phy_stop_machine)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_stop_machine": {
        "description": "Stops the PHY state machine delayed workqueue, sets the state to UP (unless it wasn't up yet). This function must be called BEFORE phy_detach.",
        "proto" :"void (*phy_stop_machine)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:mutex_lock": {
        "description": "Locks the mutex pointed by *mutex*.",
        "proto" :"void mutex_lock(struct mutex *mutex)",
        "pre": {
            "mutex": "!=null"
        }
    }
},
{
    "kprobe:mutex_lock": {
        "description": "Acquire the mutex lock.",
        "proto" :"void mutex_lock(struct mutex *lock)",
        "pre": {
            "lock": "!=null",
        },
    }
},
{
    "kretprobe:phy_init_eee": {
        "description": "Init and check the EEE feature. It checks if the Energy-Efficient Ethernet (EEE) is supported by looking at the MMD registers 3.20 and 7.6061 and it programs the MMD register 3.0 setting the 'Clock stop enable' bit if required.",
        "proto" :"int (*phy_init_eee)(struct phy_device *phydev, bool clk_stop_enable)",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_init_eee": {
        "description": "Init and check the EEE feature. It checks if the Energy-Efficient Ethernet (EEE) is supported by looking at the MMD registers 3.20 and 7.6061 and it programs the MMD register 3.0 setting the 'Clock stop enable' bit if required.",
        "proto" :"int (*phy_init_eee)(struct phy_device *phydev, bool clk_stop_enable)",
        "pre": {
            "phydev": "!=null",
            "clk_stop_enable": "in [true, false]"
        }
    }
},
{
    "kretprobe:phy_get_eee_err": {
        "description": "Report the number of time where the PHY failed to complete its normal wake sequence.",
        "proto" :"int (*phy_get_eee_err)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_get_eee_err": {
        "description": "Report the number of times where the PHY failed to complete its normal wake sequence.",
        "proto" :"int (*phy_get_eee_err)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_eee": {
        "description": "Get EEE supported and status. It reports the SupportedAdvertisementLP Advertisement capabilities.",
        "proto" :"int (*phy_ethtool_get_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_eee": {
        "description": "Get EEE supported and status. It reports the SupportedAdvertisementLP Advertisement capabilities.",
        "proto" :"int (*phy_ethtool_get_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status. It is to program the Advertisement EEE register.",
        "proto" :"int (*phy_ethtool_set_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_set_eee": {
        "description": "Set EEE supported and status. It is to program the Advertisement EEE register.",
        "proto" :"int (*phy_ethtool_set_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_set_wol": {
        "description": "Configure Wake On LAN. @phydev: target phy_device struct. @wol: Configuration requested.",
        "proto" :"int (*phy_ethtool_set_wol)(struct phy_device *phydev, struct ethtool_wolinfo *wol)",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_set_wol": {
        "description": "Configure Wake On LAN",
        "proto" :"int (*phy_ethtool_set_wol)(struct phy_device *phydev, struct ethtool_wolinfo *wol)",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration. The target phy_device struct is stored in *phydev* and the current configuration is stored in *wol*.",
        "proto" :"static void (*phy_ethtool_get_wol)(struct phy_device *phydev, struct ethtool_wolinfo *wol)",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_get_wol": {
        "description": "Get the current Wake On LAN configuration. Store the current configuration in *wol*.",
        "proto" :"static void (*phy_ethtool_get_wol)(struct phy_device *phydev, struct ethtool_wolinfo *wol)",
        "pre": {
            "phydev": "!=null",
            "wol": "!=null"
        }
    }
},
{
    "kretprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation for the network device",
        "proto" :"int (*phy_ethtool_nway_reset)(struct net_device *ndev)",
        "pre": {
            "ndev": "!=null"
        }
    }
},
{
    "kprobe:phy_ethtool_nway_reset": {
        "description": "Restart auto negotiation for a network device",
        "proto" :"int (*phy_ethtool_nway_reset)(struct net_device *ndev)",
        "pre": {
            "ndev": "!=null",
        },
    }
},
{
    "kretprobe:mdio_device_create": {
        "description": "We allocate the device, and initialize the default values",
        "proto" :"struct mdio_device* (*mdio_device_create)(struct mii_bus *bus, int addr)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0 && <32"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mdio_device_create": {
        "description": "Allocate the device and initialize the default values.",
        "proto" :"struct mdio_device *(*mdio_device_create)(struct mii_bus *bus, int addr)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kretprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "proto" :"int (*mdio_device_register)(struct mdio_device *mdiodev)",
        "pre": {
            "mdiodev": "!=null"
        },
    }
},
{
    "kprobe:mdio_device_register": {
        "description": "Register the mdio device on the MDIO bus",
        "proto" :"int mdio_device_register(struct mdio_device *mdiodev)",
        "pre": {
            "mdiodev": "!=null"
        }
    }
},
{
    "kretprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer",
        "proto": "int mdio_driver_register(struct mdio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:mdio_driver_register": {
        "description": "Register an mdio_driver with the MDIO layer",
        "proto" :"int mdio_driver_register(struct mdio_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_eee_is_active": {
        "description": "This function will read local and link partner PHY advertisements. Compare them return current EEE state.",
        "proto" :"int genphy_c45_eee_is_active(struct phy_device *phydev, unsigned long *adv, unsigned long *lp, bool *is_enabled)",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        },
    }
},
{
    "kprobe:genphy_c45_eee_is_active": {
        "description": "This function will read local and link partner PHY advertisements. Compare them return current EEE state.",
        "proto" :"int (*genphy_c45_eee_is_active)(struct phy_device *phydev, unsigned long *adv, unsigned long *lp, bool *is_enabled)",
        "pre": {
            "phydev": "!=null",
            "adv": "!=null",
            "lp": "!=null",
            "is_enabled": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_ethtool_get_eee": {
        "description": "It reports the SupportedAdvertisementLP Advertisement capabilities.",
        "proto" :"int (*genphy_c45_ethtool_get_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:genphy_c45_ethtool_get_eee": {
        "description": "It reports the SupportedAdvertisementLP Advertisement capabilities.",
        "proto" :"int (*genphy_c45_ethtool_get_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c45_ethtool_set_eee": {
        "description": "Sets the SupportedAdvertisementLP Advertisement capabilities. If eee_enabled is false, no links modes are advertised, but the previously advertised link modes are retained. This allows EEE to be enabled/disabled in a non-destructive way.",
        "proto" :"int genphy_c45_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kprobe:genphy_c45_ethtool_set_eee": {
        "description": "Sets the SupportedAdvertisementLP Advertisement capabilities. If eee_enabled is false, no links modes are advertised, but the previously advertised link modes are retained. This allows EEE to be enabled/disabled in a non-destructive way.",
        "proto" :"int (*genphy_c45_ethtool_set_eee)(struct phy_device *phydev, struct ethtool_eee *data)",
        "pre": {
            "phydev": "!=null",
            "data": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_register_device": {
        "description": "Register a new mdio device. If the device is already registered or if there is an error during the registration process, it returns an error code. If the device has the MDIO_DEVICE_FLAG_PHY flag, it also registers the gpiod and reset signals.",
        "proto" :"int mdiobus_register_device(struct mdio_device *mdiodev)",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags": "in [MDIO_DEVICE_FLAG_PHY, ...]"
        },
        "post": {
            "return": "in [0, -EBUSY, ...]"
        }
    }
},
{
    "kprobe:mdiobus_register_device": {
        "description": "Registers a new mdio device. If the device is already registered or if there is an error during the registration process, it returns an error code.",
        "proto" :"static int (*mdiobus_register_device)(struct mdio_device *mdiodev)",
        "pre": {
            "mdiodev": "!=null",
            "mdiodev->bus": "!=null",
            "mdiodev->bus->mdio_map[mdiodev->addr]": "==null",
            "mdiodev->flags": "in [MDIO_DEVICE_FLAG_PHY, ...]"
        },
    }
},
{
    "kretprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure. If @size is non-zero, then bus->priv points to that memory. Called by a bus driver to allocate an mii_bus structure to fill in.",
        "proto" :"struct mii_bus *(*mdiobus_alloc_size)(size_t size)",
        "pre": {
            "size": ">=0"
        },
        "post": {
            "return": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_alloc_size": {
        "description": "Allocate a mii_bus structure. If size is non-zero, then bus->priv points to that memory.",
        "proto" :"struct mii_bus *(*mdiobus_alloc_size)(size_t size)",
        "pre": {
            "size": ">=0",
        },
    }
},
{
    "kretprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus. Returns a reference to the mii_bus, or NULL if none found. The embedded struct device will have its reference count incremented, and this must be put_deviced'ed once the bus is finished with.",
        "proto" :"struct mii_bus *(*mdio_find_bus)(const char *mdio_name)",
        "pre": {
            "mdio_name": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:mdio_find_bus": {
        "description": "Given the name of a mdiobus, find the mii_bus. Returns a reference to the mii_bus, or NULL if none found. The embedded struct device will have its reference count incremented, and this must be put_deviced'ed once the bus is finished with.",
        "proto" :"struct mii_bus *(*mdio_find_bus)(const char *mdio_name)",
        "pre": {
            "mdio_name": "!=null"
        }
    }
},
{
    "kretprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus. Returns a reference to the mii_bus, or NULL if none found. The embedded struct device will have its reference count incremented, and this must be put once the bus is finished with. Because the association of a device_node and mii_bus is made via of_mdiobus_register(), the mii_bus cannot be found before it is registered with of_mdiobus_register().",
        "proto" :"struct mii_bus *(*of_mdio_find_bus)(struct device_node *mdio_bus_np)",
        "pre": {
            "mdio_bus_np": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:of_mdio_find_bus": {
        "description": "Given an mii_bus node, find the mii_bus. Returns a reference to the mii_bus, or NULL if none found. The embedded struct device will have its reference count incremented, and this must be put once the bus is finished with. Because the association of a device_node and mii_bus is made via of_mdiobus_register(), the mii_bus cannot be found before it is registered with of_mdiobus_register().",
        "proto" :"struct mii_bus *(*of_mdio_find_bus)(struct device_node *mdio_bus_np)",
        "pre": {
            "mdio_bus_np": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices. This function scans one address on the MDIO bus, looking for devices which can be identified using a vendorproduct ID in registers 2 and 3. Not all MDIO devices have such registers, but PHY devices typically do. Hence this function assumes anything found is a PHY, or can be treated as a PHY. Other MDIO devices, such as switches, will probably not be found during the scan.",
        "proto" :"struct phy_device *(*mdiobus_scan_c22)(struct mii_bus *bus, int addr)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0 && <32"
        },
    }
},
{
    "kprobe:mdiobus_scan_c22": {
        "description": "Scan one address on a bus for C22 MDIO devices. This function scans one address on the MDIO bus, looking for devices which can be identified using a vendorproduct ID in registers 2 and 3. Not all MDIO devices have such registers, but PHY devices typically do. Hence this function assumes anything found is a PHY, or can be treated as a PHY. Other MDIO devices, such as switches, will probably not be found during the scan.",
        "proto" :"struct phy_device *(*mdiobus_scan_c22)(struct mii_bus *bus, int addr)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0 && <32"
        }
    }
},
{
    "kretprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus. Drivers should use mdiobus_register() rather than __mdiobus_register() unless they need to pass a specific owner module. MDIO devices which are not PHYs will not be brought up by this function. They are expected to be explicitly listed in DT and instantiated by of_mdiobus_register(). Returns 0 on success or < 0 on error.",
        "proto" :"int (*__mdiobus_register)(struct mii_bus *bus, struct module *owner)",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:__mdiobus_register": {
        "description": "Called by a bus driver to bring up all the PHYs on a given bus, and attach them to the bus. Drivers should use mdiobus_register() rather than __mdiobus_register() unless they need to pass a specific owner module. MDIO devices which are not PHYs will not be brought up by this function. They are expected to be explicitly listed in DT and instantiated by of_mdiobus_register(). Returns 0 on success or < 0 on error.",
        "proto" :"int (*__mdiobus_register)(struct mii_bus *bus, struct module *owner)",
        "pre": {
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:device_register": {
        "description": "Register a device with the system. If the system state is MDIOBUS_UNREGISTERED, the state will be updated later in this function in case of success.",
        "proto" :"int device_register(struct device *dev)",
        "pre": {
            "dev": "!=null",
            "bus->state": "==MDIOBUS_UNREGISTERED"
        },
        "post": {
            "return": "in [0, -ENOMEM, -EINVAL]",
            "bus->state": "in [MDIOBUS_REGISTERED, MDIOBUS_UNREGISTERED]"
        }
    }
},
{
    "kprobe:mdiobus_free": {
        "description": "State will be updated later in this function in case of success",
        "proto" :"static void (*mdiobus_free)(struct mii_bus *bus)",
        "pre": {
            "bus": "!=null"
        },
        "post": {
            "bus->state": "==MDIOBUS_UNREGISTERED",
            "err": ">=0"
        }
    },
    "kprobe:device_register": {
        "description": "Register a device with the system. If the system is not able to handle the device, it will return an error.",
        "proto" :"int (*device_register)(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
        "post": {
            "err": ">=0"
        }
    }
},
{
    "kretprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function. Read a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_read)(struct mii_bus *bus, int addr, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0"
        },
    }
},
{
    "kprobe:__mdiobus_read": {
        "description": "Unlocked version of the mdiobus_read function. Read a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_read)(struct mii_bus *bus, int addr, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0",
        },
    }
},
{
    "kretprobe:__mdiobus_write": {
        "description": "Write a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_write)(struct mii_bus *bus, int addr, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        },
    }
},
{
    "kprobe:__mdiobus_write": {
        "description": "Unlocked version of the mdiobus_write function. Write a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_write)(struct mii_bus *bus, int addr, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        },
    }
},
{
    "kretprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function. Read a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_c45_read)(struct mii_bus *bus, int addr, int devad, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0"
        }
    }
},
{
    "kprobe:__mdiobus_c45_read": {
        "description": "Unlocked version of the mdiobus_c45_read function. Read a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_c45_read)(struct mii_bus *bus, int addr, int devad, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0",
        },
    }
},
{
    "kretprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function. Write a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_c45_write)(struct mii_bus *bus, int addr, int devad, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:__mdiobus_c45_write": {
        "description": "Unlocked version of the mdiobus_write function. Write a MDIO bus register. Caller must hold the mdio bus lock. NOTE: MUST NOT be called from interrupt context.",
        "proto" :"int (*__mdiobus_c45_write)(struct mii_bus *bus, int addr, int devad, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        },
    }
},
{
    "kretprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_read_nested": {
        "description": "Nested version of the mdiobus_read function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0"
        }
    }
},
{
    "kretprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_c45_read_nested(struct mii_bus *bus, int addr, int devad, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_c45_read_nested": {
        "description": "Nested version of the mdiobus_c45_read function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int (*mdiobus_c45_read_nested)(struct mii_bus *bus, int addr, int devad, u32 regnum)",
        "pre": {
            "bus": "!=null",
            "addr": "is a valid phy address",
            "devad": "is a valid device address",
            "regnum": "is a valid register number"
        }
    }
},
{
    "kretprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_write_nested": {
        "description": "Nested version of the mdiobus_write function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kretprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_c45_write_nested(struct mii_bus *bus, int addr, int devad, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "devad": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:mdiobus_c45_write_nested": {
        "description": "Nested version of the mdiobus_c45_write function. In case of nested MDIO bus access avoid lockdep false positives by using mutex_lock_nested(). NOTE: MUST NOT be called from interrupt context, because the bus readwrite functions may wait for an interrupt to conclude the operation.",
        "proto" :"int mdiobus_c45_write_nested(struct mii_bus *bus, int addr, int devad, u32 regnum, u16 val)",
        "pre": {
            "bus": "!=null",
            "addr": "is a valid phy address",
            "devad": "is a valid device address",
            "regnum": "is a valid register number",
            "val": "is a valid value to write to @regnum",
            "context": "!=interrupt context"
        },
    }
},
{
    "kretprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device. Returns zero on success or non-zero on failure.",
        "proto" :"int (*register_mii_tstamp_controller)(struct device *device, struct mii_timestamping_ctrl *ctrl)",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:register_mii_tstamp_controller": {
        "description": "Registers an MII time stamping device. Returns zero on success or non-zero on failure.",
        "proto" :"int (*register_mii_tstamp_controller)(struct device *device, struct mii_timestamping_ctrl *ctrl)",
        "pre": {
            "device": "!=null",
            "ctrl": "!=null"
        }
    }
},
{
    "kretprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device. @device: A device previously passed to register_mii_tstamp_controller().",
        "proto" :"void (*unregister_mii_tstamp_controller)(struct device *device)",
        "pre": {
            "device": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_tstamp_controller": {
        "description": "Unregisters an MII time stamping device. The device should be previously passed to register_mii_tstamp_controller().",
        "proto" :"void (*unregister_mii_tstamp_controller)(struct device *device)",
        "pre": {
            "device": "!=null && previously passed to register_mii_tstamp_controller()"
        }
    }
},
{
    "kretprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper. Returns a valid interface on success or ERR_PTR otherwise.",
        "proto" :"struct mii_timestamper *(*register_mii_timestamper)(struct device_node *node, unsigned int port)",
        "pre": {
            "node": "!=null",
            "port": "is a valid port index"
        },
    }
},
{
    "kprobe:register_mii_timestamper": {
        "description": "Enables a given port of an MII time stamper. Returns a valid interface on success or ERR_PTR otherwise.",
        "proto" :"struct mii_timestamper *(*register_mii_timestamper)(struct device_node *node, unsigned int port)",
        "pre": {
            "node": "!=null",
            "port": ">=0"
        },
    }
},
{
    "kretprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper. An interface obtained via register_mii_timestamper().",
        "proto" :"void (*unregister_mii_timestamper)(struct mii_timestamper *mii_ts)",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kprobe:unregister_mii_timestamper": {
        "description": "Disables a given MII time stamper.",
        "proto" :"void (*unregister_mii_timestamper)(struct mii_timestamper *mii_ts)",
        "pre": {
            "mii_ts": "!=null"
        }
    }
},
{
    "kretprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support. The PHY might be more capable than the MAC. For example a Fast Ethernet is connected to a 1G PHY. This function allows the MAC to indicate its maximum speed, and so limit what the PHY will advertise.",
        "proto" :"void (*phy_set_max_speed)(struct phy_device *phydev, u32 max_speed)",
        "pre": {
            "phydev": "!=null",
            "max_speed": ">=0"
        }
    }
},
{
    "kprobe:phy_set_max_speed": {
        "description": "Set the maximum speed the PHY should support. The PHY might be more capable than the MAC. For example a Fast Ethernet is connected to a 1G PHY. This function allows the MAC to indicate its maximum speed, and so limit what the PHY will advertise.",
        "proto" :"void (*phy_set_max_speed)(struct phy_device *phydev, u32 max_speed)",
        "pre": {
            "phydev": "!=null",
            "max_speed": ">=0"
        }
    }
},
{
    "kretprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "proto" :"int (*__phy_read_mmd)(struct phy_device *phydev, int devad, u32 regnum)",
        "pre": {
            "phydev": "!=null",
            "devad": "in [0, 31]",
            "regnum": "in [0, 65535]"
        }
    }
},
{
    "kprobe:__phy_read_mmd": {
        "description": "Convenience function for reading a register from an MMD on a given PHY.",
        "proto" :"int (*__phy_read_mmd)(struct phy_device *phydev, int devad, u32 regnum)",
        "pre": {
            "phydev": "!=null",
            "devad": "in [0, 31]",
            "regnum": "in [0, 65535]"
        }
    }
},
{
    "kretprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "proto" :"int (*__phy_write_mmd)(struct phy_device *phydev, int devad, u32 regnum, u16 val)",
        "pre": {
            "phydev": "!=null",
            "devad": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:__phy_write_mmd": {
        "description": "Convenience function for writing a register on an MMD on a given PHY.",
        "proto" :"int (*__phy_write_mmd)(struct phy_device *phydev, int devad, u32 regnum, u16 val)",
        "pre": {
            "phydev": "!=null",
            "devad": "is an integer",
            "regnum": "is a u32",
            "val": "is a u16",
        },
    }
},
{
    "kretprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register. Same rules as for phy_read().",
        "proto" :"int (*phy_read_paged)(struct phy_device *phydev, int page, u32 regnum)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0"
        }
    }
},
{
    "kprobe:phy_read_paged": {
        "description": "Convenience function for reading a paged register. Same rules as for phy_read().",
        "proto" :"int (*phy_read_paged)(struct phy_device *phydev, int page, u32 regnum)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
        },
    }
},
{
    "kretprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register. Same rules as for phy_write().",
        "proto" :"int (*phy_write_paged)(struct phy_device *phydev, int page, u32 regnum, u16 val)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kprobe:phy_write_paged": {
        "description": "Convenience function for writing a paged register. Same rules as for phy_write().",
        "proto" :"int (*phy_write_paged)(struct phy_device *phydev, int page, u32 regnum, u16 val)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "val": ">=0"
        }
    }
},
{
    "kretprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register. Returns negative errno, 0 if there was no change, and 1 in case of change.",
        "proto" :"int (*phy_modify_paged_changed)(struct phy_device *phydev, int page, u32 regnum, u16 mask, u16 set)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "mask": ">=0",
            "set": ">=0"
        },
    }
},
{
    "kprobe:phy_modify_paged_changed": {
        "description": "Function for modifying a paged register. Returns negative errno, 0 if there was no change, and 1 in case of change.",
        "proto" :"int (*phy_modify_paged_changed)(struct phy_device *phydev, int page, u32 regnum, u16 mask, u16 set)",
        "pre": {
            "phydev": "!=null",
            "page": ">=0",
            "regnum": ">=0",
            "mask": ">=0",
            "set": ">=0"
        }
    }
},
{
    "kretprobe:phy_register_fixup": {
        "description": "Creates a new phy_fixup and adds it to the list. The function is run when a matching PHY is found.",
        "proto" :"int (*phy_register_fixup)(const char *bus_id, u32 phy_uid, u32 phy_uid_mask, int (*run)(struct phy_device *))",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "in [PHY_ANY_UID, specific PHY UID]",
            "phy_uid_mask": "applied to phydev->phy_id and fixup->phy_uid before comparison",
            "run": "!=null"
        },
    }
},
{
    "kprobe:phy_register_fixup": {
        "description": "Creates a new phy_fixup and adds it to the list. The function is run when a matching PHY is found.",
        "proto" :"int (*phy_register_fixup)(const char *bus_id, u32 phy_uid, u32 phy_uid_mask, int (*run)(struct phy_device *))",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "in [PHY_ANY_UID, specific PHY UID]",
            "phy_uid_mask": "applied to phydev->phy_id and fixup->phy_uid before comparison",
            "run": "!=null"
        },
    }
},
{
    "kretprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list. The parameters are used to match the fixup in the phy_fixup_list.",
        "proto" :"int (*phy_unregister_fixup)(const char *bus_id, u32 phy_uid, u32 phy_uid_mask)",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "in [PHY_ANY_UID, specific phy_uid]",
            "phy_uid_mask": "applied to phy_uid and fixup->phy_uid before comparison"
        },
    }
},
{
    "kprobe:phy_unregister_fixup": {
        "description": "Remove a phy_fixup from the list. The bus_id should match fixup->bus_id (or PHY_ANY_ID) in phy_fixup_list. The phy_uid should match fixup->phy_id (or PHY_ANY_UID) in phy_fixup_list. The phy_uid_mask is applied to phy_uid and fixup->phy_uid before comparison.",
        "proto" :"int (*phy_unregister_fixup)(const char *bus_id, u32 phy_uid, u32 phy_uid_mask)",
        "pre": {
            "bus_id": "!=null",
            "phy_uid": "in [PHY_ANY_UID, fixup->phy_id]",
            "phy_uid_mask": "applied to phy_uid and fixup->phy_uid before comparison"
        },
    }
},


{
    "kretprobe:get_phy_device": {
        "description": "Reads the specified PHY device and returns its @phy_device struct. Probe for a PHY at @addr on @bus. When probing for a clause 22 PHY, then read the ID registers. If we find a valid ID, allocate and return a &struct phy_device. When probing for a clause 45 PHY, read the 'devices in package' registers. If the 'devices in package' appears valid, read the ID registers for each MMD, allocate and return a &struct phy_device. Returns an allocated &struct phy_device on success, %-ENODEV if there is no PHY present, or %-EIO on bus access error.",
        "proto" :"struct phy_device *(*get_phy_device)(struct mii_bus *bus, int addr, bool is_c45)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
            "is_c45": "in [true, false]"
        },
        "post": {
            "return": "!=null || ==-ENODEV || ==-EIO"
        }
    }
},
{
    "kprobe:get_phy_device": {
        "description": "Probe for a PHY at @addr on @bus. When probing for a clause 22 PHY, then read the ID registers. If we find a valid ID, allocate and return a &struct phy_device. When probing for a clause 45 PHY, read the 'devices in package' registers. If the 'devices in package' appears valid, read the ID registers for each MMD, allocate and return a &struct phy_device. Returns an allocated &struct phy_device on success, %-ENODEV if there is no PHY present, or %-EIO on bus access error.",
        "proto" :"struct phy_device *(*get_phy_device)(struct mii_bus *bus, int addr, bool is_c45)",
        "pre": {
            "bus": "!=null",
            "addr": "is an integer",
            "is_c45": "is a boolean"
        }
    }
},
{
    "kretprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "proto" :"int (*phy_device_register)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_device_register": {
        "description": "Register the phy device on the MDIO bus",
        "proto" :"int (*phy_device_register)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_suspend": {
        "description": "phy_suspend() because the parent netdev might be the MDIO bus driver and clock gated at this point.",
        "proto" :"static long (*phy_suspend)(struct net_device *netdev)",
        "pre": {
            "netdev": "!=null"
        },
        "post": {
            "return": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_suspend": {
        "description": "phy_suspend() because the parent netdev might be the MDIO bus driver and clock gated at this point.",
        "proto" :"static long (*phy_suspend)(struct net_device *netdev)",
        "pre": {
            "netdev": "!=null",
            "netdev->wol_enabled": "==false"
        },
    }
},
{
    "kretprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device. Returns zero on success, %-EIO on bus access error, or %-ENODEV if the 'devices in package' is invalid.",
        "proto" :"int (*phy_get_c45_ids)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [0, -EIO, -ENODEV]"
        }
    }
},
{
    "kprobe:phy_get_c45_ids": {
        "description": "Read 802.3-c45 IDs for phy device. Returns zero on success, %-EIO on bus access error, or %-ENODEV if the 'devices in package' is invalid.",
        "proto" :"int (*phy_get_c45_ids)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
    }
},
{
    "kretprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "proto" :"struct phy_device *(*phy_find_first)(struct mii_bus *bus)",
        "pre": {
            "bus": "!=null"
        },
    }
},
{
    "kprobe:phy_find_first": {
        "description": "Finds the first PHY device on the bus.",
        "proto" :"struct phy_device *(*phy_find_first)(struct mii_bus *bus)",
        "pre": {
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device. @dev: the network device to connect. @phydev: the pointer to the phy device. @handler: callback function for state change notifications. @interface: PHY device's interface.",
        "proto" :"int (*phy_connect_direct)(struct net_device *dev, struct phy_device *phydev, void (*handler)(struct net_device *), phy_interface_t interface)",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_NA, PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_REVMII, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_NOCHANGE]"
        }
    }
},
{
    "kprobe:phy_connect_direct": {
        "description": "Connect an ethernet device to a specific phy_device. @dev: the network device to connect. @phydev: the pointer to the phy device. @handler: callback function for state change notifications. @interface: PHY device's interface.",
        "proto" :"int (*phy_connect_direct)(struct net_device *dev, struct phy_device *phydev, void (*handler)(struct net_device *), phy_interface_t interface)",
        "pre": {
            "dev": "!=null",
            "phydev": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_NA, PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_REVMII, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_RGMII_ID, PHY_INTERFACE_MODE_RGMII_RXID, PHY_INTERFACE_MODE_RGMII_TXID, PHY_INTERFACE_MODE_RTBI, PHY_INTERFACE_MODE_XGMII, PHY_INTERFACE_MODE_NONE, PHY_INTERFACE_MODE_1000BASEX, PHY_INTERFACE_MODE_10GKR, PHY_INTERFACE_MODE_USXGMII]"
        },
    }
},

{
    "kprobe:phydev->irq_rerun": {
        "description": "Rerun interrupts which were postponed by phy_interrupt() because they occurred during the system sleep transition.",
        "proto" :"if (phydev->irq_rerun)",
        "pre": {
            "phydev": "!=null",
            "irq_rerun": "is boolean",
        },
    }
},
{
    "kretprobe:phy_sfp_attach": {
        "description": "Attach the SFP bus to the PHY upstream network device. This is used to fill in the sfp_upstream_ops .attach member.",
        "proto" :"void (*phy_sfp_attach)(void *upstream, struct sfp_bus *bus)",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_attach": {
        "description": "Attach the SFP bus to the PHY upstream network device. This is used to fill in the sfp_upstream_ops .attach member.",
        "proto" :"void (*phy_sfp_attach)(void *upstream, struct sfp_bus *bus)",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kretprobe:phy_sfp_detach": {
        "description": "Detach the SFP bus from the PHY upstream network device. This is used to fill in the sfp_upstream_ops .detach member.",
        "proto" :"void (*phy_sfp_detach)(void *upstream, struct sfp_bus *bus)",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_detach": {
        "description": "Detach the SFP bus from the PHY upstream network device. This is used to fill in the sfp_upstream_ops .detach member.",
        "proto" :"void (*phy_sfp_detach)(void *upstream, struct sfp_bus *bus)",
        "pre": {
            "upstream": "!=null",
            "bus": "!=null"
        },
    }
},
{
    "kretprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "proto" :"int (*phy_sfp_probe)(struct phy_device *phydev, const struct sfp_upstream_ops *ops)",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kprobe:phy_sfp_probe": {
        "description": "Probe for a SFP cage attached to this PHY device",
        "proto" :"int (*phy_sfp_probe)(struct phy_device *phydev, const struct sfp_upstream_ops *ops)",
        "pre": {
            "phydev": "!=null",
            "ops": "!=null"
        }
    }
},
{
    "kretprobe:phy_connect": {
        "description": "Convenience function for connecting ethernet devices to PHY devices. The default behavior is for the PHY infrastructure to handle everything, and only notify the connected driver when the link status changes. If you don't want, or can't use the provided functionality, you may choose to call only the subset of functions which provide the desired functionality.",
        "proto" :"struct phy_device *(*phy_connect)(struct net_device *dev, const char *bus_id, void (*handler)(struct net_device *), phy_interface_t interface)",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_NA, PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_REVMII, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_RGMII_ID, PHY_INTERFACE_MODE_RGMII_RXID, PHY_INTERFACE_MODE_RGMII_TXID, PHY_INTERFACE_MODE_RTBI, PHY_INTERFACE_MODE_XGMII, PHY_INTERFACE_MODE_NONE, PHY_INTERFACE_MODE_1000BASEX, PHY_INTERFACE_MODE_10GKR, PHY_INTERFACE_MODE_USXGMII]"
        },
    }
},
{
    "kprobe:phy_connect": {
        "description": "Convenience function for connecting ethernet devices to PHY devices. The default behavior is for the PHY infrastructure to handle everything, and only notify the connected driver when the link status changes. If you don't want, or can't use the provided functionality, you may choose to call only the subset of functions which provide the desired functionality.",
        "proto" :"struct phy_device *(*phy_connect)(struct net_device *dev, const char *bus_id, void (*handler)(struct net_device *), phy_interface_t interface)",
        "pre": {
            "dev": "!=null",
            "bus_id": "!=null",
            "handler": "!=null",
            "interface": "in [PHY_INTERFACE_MODE_NA, PHY_INTERFACE_MODE_MII, PHY_INTERFACE_MODE_GMII, PHY_INTERFACE_MODE_SGMII, PHY_INTERFACE_MODE_TBI, PHY_INTERFACE_MODE_REVMII, PHY_INTERFACE_MODE_RMII, PHY_INTERFACE_MODE_RGMII, PHY_INTERFACE_MODE_RGMII_ID, PHY_INTERFACE_MODE_RGMII_RXID, PHY_INTERFACE_MODE_RGMII_TXID, PHY_INTERFACE_MODE_RTBI, PHY_INTERFACE_MODE_XGMII, PHY_INTERFACE_MODE_NONE, PHY_INTERFACE_MODE_1000BASEX, PHY_INTERFACE_MODE_10GKR, PHY_INTERFACE_MODE_USXGMII]"
        },
    }
},
{
    "kretprobe:phy_resume": {
        "description": "Resumes the PHY device if it was suspended by the MDIO bus. If the PHY state machine is in a state neither PHY_HALTED, PHY_READY nor PHY_UP, this is an indication that something went wrong and we should most likely be using MAC managed PM, but we are not.",
        "proto" :"int phy_resume(struct device *dev)",
        "pre": {
            "dev": "!=null"
        }
    }
},
{
    "kprobe:phy_resume": {
        "description": "Resumes a physical device. If the device's state is not PHY_HALTED, PHY_READY, or PHY_UP, it indicates that something went wrong.",
        "proto" :"int phy_resume(struct device *dev)",
        "pre": {
            "dev": "!=null"
        },
    }
},
{
    "kretprobe:phy_reset_after_clk_enable": {
        "description": "Some PHYs are known to need a reset after their refclk was enabled. This function evaluates the flags and perform the reset if it's needed. Returns < 0 on error, 0 if the phy wasn't reset and 1 if the phy was reset.",
        "proto" :"int (*phy_reset_after_clk_enable)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [-1, 0, 1]"
        }
    }
},
{
    "kprobe:phy_reset_after_clk_enable": {
        "description": "Some PHYs are known to need a reset after their refclk was enabled. This function evaluates the flags and perform the reset if it's needed. Returns < 0 on error, 0 if the phy wasn't reset and 1 if the phy was reset.",
        "proto" :"int (*phy_reset_after_clk_enable)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
    }
},
{
    "kretprobe:genphy_config_eee_advert": {
        "description": "Writes MDIO_AN_EEE_ADV after disabling unsupported energy efficent ethernet modes. Returns 0 if the PHY's advertisement hasn't changed, and 1 if it has changed.",
        "proto" :"int (*genphy_config_eee_advert)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [0, 1]"
        }
    }
},
{
    "kprobe:genphy_config_eee_advert": {
        "description": "Writes MDIO_AN_EEE_ADV after disabling unsupported energy efficient ethernet modes. Returns 0 if the PHY's advertisement hasn't changed, and 1 if it has changed.",
        "proto" :"int (*genphy_config_eee_advert)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_setup_forced": {
        "description": "Configures MII_BMCR to force speedduplex to the values in phydev. Assumes that the values are valid. Please see phy_sanitize_settings().",
        "proto" :"int (*genphy_setup_forced)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_setup_forced": {
        "description": "Configures MII_BMCR to force speedduplex to the values in phydev. Assumes that the values are valid. Please see phy_sanitize_settings().",
        "proto" :"int (*genphy_setup_forced)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_read_master_slave": {
        "description": "Reads the master-slave configuration and state from the phy device.",
        "proto" :"int genphy_read_master_slave(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN, MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE]"
        }
    }
},
{
    "kprobe:genphy_read_master_slave": {
        "description": "This function reads the master-slave configuration of a phy device.",
        "proto" :"int genphy_read_master_slave(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "phydev->master_slave_get": "in [MASTER_SLAVE_CFG_UNKNOWN, MASTER_SLAVE_CFG_MASTER_FORCE, MASTER_SLAVE_CFG_SLAVE_FORCE, MASTER_SLAVE_CFG_MASTER_PREFERRED, MASTER_SLAVE_CFG_SLAVE_PREFERRED]",
            "phydev->master_slave_state": "in [MASTER_SLAVE_STATE_UNKNOWN, MASTER_SLAVE_STATE_ERR, MASTER_SLAVE_STATE_MASTER, MASTER_SLAVE_STATE_SLAVE]"
        }
    }
},
{
    "kretprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "proto" :"int (*genphy_restart_aneg)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_restart_aneg": {
        "description": "Enable and Restart Autonegotiation",
        "proto" :"int (*genphy_restart_aneg)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_check_and_restart_aneg": {
        "description": "Check, and restart auto-negotiation if needed.",
        "proto" :"int (*genphy_check_and_restart_aneg)(struct phy_device *phydev, bool restart)",
        "pre": {
            "phydev": "!=null",
            "restart": "in [true, false]"
        }
    }
},
{
    "kprobe:genphy_check_and_restart_aneg": {
        "description": "Check, and restart auto-negotiation if needed.",
        "proto" :"int (*genphy_check_and_restart_aneg)(struct phy_device *phydev, bool restart)",
        "pre": {
            "phydev": "!=null",
            "restart": "in [true, false]"
        }
    }
},
{
    "kretprobe:__genphy_config_aneg": {
        "description": "If auto-negotiation is enabled, we configure the advertising, and then restart auto-negotiation. If it is not enabled, then we write the BMCR.",
        "proto" :"int (*__genphy_config_aneg)(struct phy_device *phydev, bool changed)",
        "pre": {
            "phydev": "!=null",
            "changed": "in [true, false]"
        }
    }
},
{
    "kprobe:__genphy_config_aneg": {
        "description": "If auto-negotiation is enabled, we configure the advertising, and then restart auto-negotiation. If it is not enabled, then we write the BMCR.",
        "proto" :"int (*__genphy_config_aneg)(struct phy_device *phydev, bool changed)",
        "pre": {
            "phydev": "!=null",
            "changed": "in [true, false]"
        }
    }
},
{
    "kretprobe:genphy_c37_config_aneg": {
        "description": "If auto-negotiation is enabled, we configure the advertising, and then restart auto-negotiation. If it is not enabled, then we write the BMCR. This function is intended for use with Clause 37 1000Base-X mode.",
        "proto" :"int (*genphy_c37_config_aneg)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_c37_config_aneg": {
        "description": "If auto-negotiation is enabled, we configure the advertising, and then restart auto-negotiation. If it is not enabled, then we write the BMCR. This function is intended for use with Clause 37 1000Base-X mode.",
        "proto" :"int (*genphy_c37_config_aneg)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_aneg_done": {
        "description": "Reads the status register and returns 0 either if auto-negotiation is incomplete, or if there was an error. Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.",
        "proto" :"int genphy_aneg_done(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [0, BMSR_ANEGCOMPLETE]"
        }
    }
},
{
    "kprobe:genphy_aneg_done": {
        "description": "Reads the status register and returns 0 either if auto-negotiation is incomplete, or if there was an error. Returns BMSR_ANEGCOMPLETE if auto-negotiation is done.",
        "proto" :"int (*genphy_aneg_done)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value. In order to do this, we need to read the status register twice, keeping the second value.",
        "proto" :"int (*genphy_update_link)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_update_link": {
        "description": "Update the value in phydev->link to reflect the current link value. In order to do this, we need to read the status register twice, keeping the second value.",
        "proto" :"int genphy_update_link(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_read_status_fixed": {
        "description": "Read the current duplex and speed state for a PHY operating with autonegotiation disabled.",
        "proto" :"int (*genphy_read_status_fixed)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_read_status_fixed": {
        "description": "Read the current duplex and speed state for a PHY operating with autonegotiation disabled.",
        "proto" :"int (*genphy_read_status_fixed)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_c37_read_status": {
        "description": "Check the link status and update current link state by comparing what we advertise with what the link partner advertises. This function is for Clause 37 1000Base-X mode.",
        "proto" :"int (*genphy_c37_read_status)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
    }
},
{
    "kprobe:genphy_c37_read_status": {
        "description": "Check the link, then figure out the current state by comparing what we advertise with what the link partner advertises. This function is for Clause 37 1000Base-X mode.",
        "proto" :"int (*genphy_c37_read_status)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_soft_reset": {
        "description": "genphy_soft_reset for an explanation",
        "proto" :"static int (*genphy_soft_reset)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_soft_reset": {
        "description": "genphy_soft_reset for an explanation",
        "proto" :"int (*genphy_soft_reset)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null",
        },
    }
},
{
    "kretprobe:genphy_handle_interrupt_no_ack": {
        "description": "There are cases where the interrupts are handled by another entity (ie an IRQ controller embedded inside the PHY) and do not need any other interaction from phylib. In this case, just trigger the state machine directly.",
        "proto" :"static long (*genphy_handle_interrupt_no_ack)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:genphy_handle_interrupt_no_ack": {
        "description": "Handles cases where the interrupts are handled by another entity (ie an IRQ controller embedded inside the PHY) and do not need any other interaction from phylib. In this case, just trigger the state machine directly.",
        "proto" :"static void (*genphy_handle_interrupt_no_ack)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:genphy_read_abilities": {
        "description": "Reads the PHY's abilities and populates phydev->supported accordingly.",
        "proto" :"int (*genphy_read_abilities)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kprobe:genphy_read_abilities": {
        "description": "Reads the PHY's abilities and populates phydev->supported accordingly.",
        "proto" :"int (*genphy_read_abilities)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        },
        "post": {
            "return": "in [0, <0]"
        }
    }
},
{
    "kretprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode. Some MACs don't support all link modes which the PHY does. e.g. a 1G MAC often does not support 1000Half. Add a helper to remove a link mode.",
        "proto" :"void (*phy_remove_link_mode)(struct phy_device *phydev, u32 link_mode)",
        "pre": {
            "phydev": "!=null",
            "link_mode": "in [10BaseT_Half, 10BaseT_Full, 100BaseT_Half, 100BaseT_Full, 1000BaseT_Half, 1000BaseT_Full]"
        }
    }
},
{
    "kprobe:phy_remove_link_mode": {
        "description": "Remove a supported link mode from a phy_device structure. Some MACs don't support all link modes which the PHY does. e.g. a 1G MAC often does not support 1000Half. Add a helper to remove a link mode.",
        "proto" :"void (*phy_remove_link_mode)(struct phy_device *phydev, u32 link_mode)",
        "pre": {
            "phydev": "!=null",
            "link_mode": "in [supported link modes]"
        }
    }
},
{
    "kretprobe:phy_advertise_supported": {
        "description": "Advertise all supported modes, doesn't touch pause mode advertising.",
        "proto" :"static void (*phy_advertise_supported)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},

{
    "kretprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause. Called by the MAC to indicate it supports symmetrical Pause, but not asym pause.",
        "proto" :"void (*phy_support_sym_pause)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_support_sym_pause": {
        "description": "Enable support of symmetrical pause. Called by the MAC to indicate it supports symmetrical Pause, but not asym pause.",
        "proto" :"void (*phy_support_sym_pause)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_support_asym_pause": {
        "description": "Enable support of asym pause. Called by the MAC to indicate it supports Asym Pause.",
        "proto" :"void (*phy_support_asym_pause)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kprobe:phy_support_asym_pause": {
        "description": "Enable support of asym pause. Called by the MAC to indicate it supports Asym Pause.",
        "proto" :"void (*phy_support_asym_pause)(struct phy_device *phydev)",
        "pre": {
            "phydev": "!=null"
        }
    }
},
{
    "kretprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported. Generally called from the set_pauseparam .ndo.",
        "proto" :"void (*phy_set_sym_pause)(struct phy_device *phydev, bool rx, bool tx, bool autoneg)",
        "pre": {
            "phydev": "!=null",
            "rx": "in [true, false]",
            "tx": "in [true, false]",
            "autoneg": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_set_sym_pause": {
        "description": "Configure advertised Pause support depending on if receiver pause and pause auto neg is supported. Generally called from the set_pauseparam .ndo.",
        "proto" :"void (*phy_set_sym_pause)(struct phy_device *phydev, bool rx, bool tx, bool autoneg)",
        "pre": {
            "phydev": "!=null",
            "rx": "in [true, false]",
            "tx": "in [true, false]",
            "autoneg": "in [true, false]"
        }
    }
},
{
    "kretprobe:phy_set_asym_pause": {
        "description": "Configure advertised Pause support depending on if transmit and receiver pause is supported. If there has been a change in adverting, trigger a new autoneg. Generally called from the set_pauseparam .ndo.",
        "proto" :"void (*phy_set_asym_pause)(struct phy_device *phydev, bool rx, bool tx)",
        "pre": {
            "phydev": "!=null",
            "rx": "in [true, false]",
            "tx": "in [true, false]"
        }
    }
},
{
    "kprobe:phy_set_asym_pause": {
        "description": "Configure advertised Pause support depending on if transmit and receiver pause is supported. If there has been a change in advertising, trigger a new autoneg. Generally called from the set_pauseparam .ndo.",
        "proto" :"void (*phy_set_asym_pause)(struct phy_device *phydev, bool rx, bool tx)",
        "pre": {
            "phydev": "!=null",
            "rx": "in [true, false]",
            "tx": "in [true, false]"
        }
    }
},
{
    "kretprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting. Returns True if it is supported, false otherwise.",
        "proto" :"bool (*phy_validate_pause)(struct phy_device *phydev, struct ethtool_pauseparam *pp)",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        },
    }
},
{
    "kprobe:phy_validate_pause": {
        "description": "Test if the PHYMAC combination supports the Pause configuration the user is requesting. Returns True if it is supported, false otherwise.",
        "proto" :"bool (*phy_validate_pause)(struct phy_device *phydev, struct ethtool_pauseparam *pp)",
        "pre": {
            "phydev": "!=null",
            "pp": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_pause": {
        "description": "Resolve and return the flow control modes according to the negotiation result. This includes checking that we are operating in full duplex mode. See linkmode_resolve_pause() for further details.",
        "proto" :"void (*phy_get_pause)(struct phy_device *phydev, bool *tx_pause, bool *rx_pause)",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kprobe:phy_get_pause": {
        "description": "Resolve and return the flow control modes according to the negotiation result. This includes checking that we are operating in full duplex mode. See linkmode_resolve_pause() for further details.",
        "proto" :"void (*phy_get_pause)(struct phy_device *phydev, bool *tx_pause, bool *rx_pause)",
        "pre": {
            "phydev": "!=null",
            "tx_pause": "!=null",
            "rx_pause": "!=null"
        }
    }
},
{
    "kretprobe:phy_get_internal_delay": {
        "description": "Returns the index within the array of internal delay passed in. If the device property is not present then the interface type is checked. If the interface defines use of internal delay then a 1 is returned otherwise a 0 is returned. The array must be in ascending order. If PHY does not have an ascending order array then size = 0 and the value of the delay property is returned. Return -EINVAL if the delay is invalid or cannot be found.",
        "proto" :"s32 (*phy_get_internal_delay)(struct phy_device *phydev, struct device *dev, const int *delay_values, int size, bool is_rx)",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "in [true, false]"
        },
        "post": {
            "return": "in [-EINVAL, 0, 1] or in range [0, size-1] if size > 0"
        }
    }
},
{
    "kprobe:phy_get_internal_delay": {
        "description": "Returns the index of the internal delay. If the device property is not present then the interface type is checked. If the interface defines use of internal delay then a 1 is returned otherwise a 0 is returned. The array must be in ascending order. If PHY does not have an ascending order array then size = 0 and the value of the delay property is returned. Return -EINVAL if the delay is invalid or cannot be found.",
        "proto" :"s32 (*phy_get_internal_delay)(struct phy_device *phydev, struct device *dev, const int *delay_values, int size, bool is_rx)",
        "pre": {
            "phydev": "!=null",
            "dev": "!=null",
            "delay_values": "!=null",
            "size": ">=0",
            "is_rx": "in [true, false]",
            "delay_values": "is an array of integers in ascending order or size = 0"
        },
    }
},
{
    "kretprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device. If successful, returns a pointer to the mdio_device with the embedded struct device refcount incremented by one, or NULL on failure. The caller should call put_device() on the mdio_device after its use.",
        "proto" :"struct mdio_device *(*fwnode_mdio_find_device)(struct fwnode_handle *fwnode)",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:fwnode_mdio_find_device": {
        "description": "Given a fwnode, find the mdio_device. If successful, returns a pointer to the mdio_device with the embedded struct device refcount incremented by one, or NULL on failure. The caller should call put_device() on the mdio_device after its use.",
        "proto" :"struct mdio_device *(*fwnode_mdio_find_device)(struct fwnode_handle *fwnode)",
        "pre": {
            "fwnode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kretprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device. If successful, returns a pointer to the phy_device with the embedded struct device refcount incremented by one, or NULL on failure.",
        "proto" :"struct phy_device *(*fwnode_phy_find_device)(struct fwnode_handle *phy_fwnode)",
        "pre": {
            "phy_fwnode": "!=null"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:fwnode_phy_find_device": {
        "description": "For provided phy_fwnode, find phy_device. If successful, returns a pointer to the phy_device with the embedded struct device refcount incremented by one, or NULL on failure.",
        "proto" :"struct phy_device *(*fwnode_phy_find_device)(struct fwnode_handle *phy_fwnode)",
        "pre": {
            "phy_fwnode": "!=null"
        },
    }
},
{
    "kretprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer. @new_driver: new phy_driver to register. @owner: module owning this PHY.",
        "proto" :"int (*phy_driver_register)(struct phy_driver *new_driver, struct module *owner)",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:phy_driver_register": {
        "description": "Register a phy_driver with the PHY layer",
        "proto" :"int (*phy_driver_register)(struct phy_driver *new_driver, struct module *owner)",
        "pre": {
            "new_driver": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size(). mii_bus allocated with this function is automatically freed on driver detach.",
        "proto" :"struct mii_bus *(*devm_mdiobus_alloc_size)(struct device *dev, int sizeof_priv)",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        },
        "post": {
            "return": "!=null || ==null"
        }
    }
},
{
    "kprobe:devm_mdiobus_alloc_size": {
        "description": "Resource-managed mdiobus_alloc_size(). mii_bus allocated with this function is automatically freed on driver detach. Returns pointer to allocated mii_bus on success, NULL on out-of-memory error.",
        "proto" :"struct mii_bus *(*devm_mdiobus_alloc_size)(struct device *dev, int sizeof_priv)",
        "pre": {
            "dev": "!=null",
            "sizeof_priv": ">=0"
        }
    }
},
{
    "kretprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register(). Registers a mii_bus for a device. Returns 0 on success, negative error number on failure.",
        "proto" :"int (*__devm_mdiobus_register)(struct device *dev, struct mii_bus *bus, struct module *owner)",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        },
        "post": {
            "return": "in [0, negative integer]"
        }
    }
},
{
    "kprobe:__devm_mdiobus_register": {
        "description": "Resource-managed variant of mdiobus_register(). Registers a device to mii_bus. Returns 0 on success, negative error number on failure.",
        "proto" :"int (*__devm_mdiobus_register)(struct device *dev, struct mii_bus *bus, struct module *owner)",
        "pre": {
            "dev": "!=null",
            "bus": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register() @dev:Device to register mii_bus for @mdio:MII bus structure to register @np:Device node to parse @owner:Owning module",
        "proto" :"int (*__devm_of_mdiobus_register)(struct device *dev, struct mii_bus *mdio, struct device_node *np, struct module *owner)",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kprobe:__devm_of_mdiobus_register": {
        "description": "Resource managed variant of of_mdiobus_register()",
        "proto" :"int (*__devm_of_mdiobus_register)(struct device *dev, struct mii_bus *mdio, struct device_node *np, struct module *owner)",
        "pre": {
            "dev": "!=null",
            "mdio": "!=null",
            "np": "!=null",
            "owner": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information. The function can sleep.",
        "proto" :"void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus, int (*cb)(struct mii_bus *bus, struct mdio_board_info *bi))",
        "pre": {
            "bus": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kprobe:mdiobus_setup_mdiodev_from_board_info": {
        "description": "Create and setup MDIO devices from pre-collected board specific MDIO information. The function can sleep.",
        "proto" :"void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus, int (*cb)(struct mii_bus *bus, struct mdio_board_info *bi))",
        "pre": {
            "bus": "!=null",
            "cb": "!=null"
        }
    }
},
{
    "kretprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board. The board info passed can be marked with __initdata but be pointers such as platform_data etc. are copied as-is",
        "proto" :"int (*mdiobus_register_board_info)(const struct mdio_board_info *info, unsigned int n)",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        },
    }
},
{
    "kprobe:mdiobus_register_board_info": {
        "description": "Register MDIO devices for a given board. The board info passed can be marked with __initdata but be pointers such as platform_data etc. are copied as-is.",
        "proto" :"int (*mdiobus_register_board_info)(const struct mdio_board_info *info, unsigned int n)",
        "pre": {
            "info": "!=null",
            "n": ">=0"
        }
    }
},
{
    "kretprobe:miic_create": {
        "description": "The PCS pdev is attached to the parent node",
        "proto" :"miic_create(struct device  dev, struct device_node  np)",
        "pre": {
            "dev": "!=null",
            "np": "!=null"
        },
        "post": {
            "pcs_np": "!=null",
            "of_device_is_available(pcs_np)": "==true",
            "port": "in [1, MIIC_MAX_NR_PORTS]"
        }
    }
},
{
    "kprobe:miic_create": {
        "description": "The PCS pdev is attached to the parent node",
        "proto" :"miic_create(struct device  dev, struct device_node  np)",
        "pre": {
            "dev": "!=null",
            "np": "!=null",
            "pcs_np": "!=null",
            "port": "in [1, MIIC_MAX_NR_PORTS]",
        },
    }
},
{
    "kretprobe:lynx_pcs_create_mdiodev": {
        "description": "Create a mdiodev and a phylink_pcs. If lynx_create() fails, this will free the mdio device here. In any case, we don't need to hold our reference anymore, and putting it here will allow mdio_device_put() in lynx_destroy() to automatically free the mdio device.",
        "proto" :"struct phylink_pcs *(*lynx_pcs_create_mdiodev)(struct mii_bus *bus, int addr)",
        "pre": {
            "bus": "!=null",
            "addr": ">=0"
        },
    }
},
{
    "kprobe:lynx_pcs_create_mdiodev": {
        "description": "Create an mdio device and a pcs object. If the creation of the mdio device fails, return an error. If the creation of the pcs object fails, release the mdio device. In any case, it doesn't need to hold the reference to the mdio device anymore.",
        "proto" :"struct mii_bus  bus, int addr",
        "pre": {
            "bus": "!=null",
            "addr": ">=0",
        },
    }
},


{
    "kretprobe:qede_rdma_unregister_driver": {
        "description": "If device has experienced recovery it was already removed",
        "proto" :"void qede_rdma_unregister_driver(struct qedr_driver *drv)",
        "pre": {
            "drv": "!=null"
        }
    }
},
{
    "kprobe:qede_rdma_unregister_driver": {
        "description": "If device has experienced recovery it was already removed",
        "proto" :"static void (*qede_rdma_unregister_driver)(struct qedr_driver *drv)",
        "pre": {
            "drv": "!=null",
            "edev": "!=null",
            "edev->rdma_info.qedr_dev": "!=null",
            "edev->rdma_info.exp_recovery": "==false"
        },
    }
},
{
    "kretprobe:mlx5_create_cq": {
        "description": "Create a completion queue (CQ) in the specified device, with the given input and output parameters.",
        "proto" :"int mlx5_create_cq(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq, u32 in, int inlen, u32 out, int outlen)",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": ">=0",
            "inlen": ">=0",
            "out": ">=0",
            "outlen": ">=0"
        },
    }
},
{
    "kprobe:mlx5_create_cq": {
        "description": "Initialize the tasklet context of a completion queue.",
        "proto": "void (*mlx5_create_cq)(struct mlx5_core_dev *dev, struct mlx5_core_cq *cq, u32 in, int inlen, u32 out, int outlen)",
        "pre": {
            "dev": "!=null",
            "cq": "!=null",
            "in": ">=0",
            "inlen": ">=0",
            "out": ">=0",
            "outlen": ">=0"
        }
    }
},
{
    "kretprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in the specified namespace with the given attributes, operation mode, and vport. The function also checks if the level of the flow table attribute is greater than or equal to the number of levels in the fs_prio.",
        "proto": "mlx5_create_flow_table(struct mlx5_flow_namespace *ns, struct mlx5_flow_table_attr *ft_attr, enum fs_flow_table_op_mod op_mod, u16 vport)",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->level": ">= fs_prio->num_levels",
            "op_mod": "in [FS_FT_OP_MOD_NORMAL, FS_FT_OP_MOD_LAG, FS_FT_OP_MOD_PORT]",
            "vport": ">= 0"
        }
    }
},
{
    "kprobe:mlx5_create_flow_table": {
        "description": "Create a flow table in the specified namespace with the given attributes, operation mode, and vport. The level is related to the priority level range.",
        "proto" :"static struct mlx5_flow_table *(*mlx5_create_flow_table)(struct mlx5_flow_namespace *ns, struct mlx5_flow_table_attr *ft_attr, enum fs_flow_table_op_mod op_mod, u16 vport)",
        "pre": {
            "ns": "!=null",
            "ft_attr": {
                "level": ">= fs_prio->num_levels",
                "flags": "in [MLX5_FLOW_TABLE_UNMANAGED]"
            },
            "op_mod": "is valid enum value",
            "vport": "is valid u16 value"
        },
    }
},
{
    "kretprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Align the number of groups according to the largest group size",
        "proto" :"static long (*mlx5_create_auto_grouped_flow_table)(struct mlx5_flow_namespace ns, struct mlx5_flow_table_attr ft_attr)",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": ">=0",
            "ft_attr->autogroup.max_num_groups": ">=0",
            "ft_attr->autogroup.max_fte": ">=0"
        },
    }
},
{
    "kprobe:mlx5_create_auto_grouped_flow_table": {
        "description": "Align the number of groups according to the largest group size.",
        "proto" :"struct mlx5_flow_table (*mlx5_create_auto_grouped_flow_table)(struct mlx5_flow_namespace ns, struct mlx5_flow_table_attr ft_attr)",
        "pre": {
            "ns": "!=null",
            "ft_attr": "!=null",
            "ft_attr->autogroup.num_reserved_entries": ">=0",
            "ft_attr->autogroup.max_num_groups": ">=0",
            "ft_attr->autogroup.max_num_groups": "<= (ft->max_fte - ft_attr->autogroup.num_reserved_entries)",
            "ft_attr->autogroup.num_reserved_entries": "<= ft->max_fte"
        },
    }
},
{
    "kretprobe:build_match_list": {
        "description": "Collect all fgs which has a matching match_criteria",
        "proto" :"int (*build_match_list)(struct match_list *match_head, struct mlx5_flow_table *ft, const struct mlx5_flow_spec *spec, struct mlx5_flow_group *fg, bool take_write)",
        "pre": {
            "match_head": "!=null",
            "ft": "!=null",
            "spec": "!=null",
            "fg": "!=null",
            "take_write": "in [true, false]"
        },
    }
},
{
    "kprobe:mlx5_add_flow_rules": {
        "description": "Collect all fgs which has a matching match_criteria",
        "proto" :"mlx5_add_flow_rules(struct mlx5_flow_table  ft, const struct mlx5_flow_spec  spec, struct mlx5_flow_act  flow_act, struct mlx5_flow_destination  dest, int dest_num)",
        "pre": {
            "ft": "!=null",
            "spec": "check_valid_spec(spec) == true",
            "flow_act": "!=null && (flow_act->fg == null || ft->autogroup.active == false)",
            "dest": "!=null && dest_num > 0 && dest_is_valid(&dest[i], flow_act, ft) == true for all i in [0, dest_num)",
            "dest_num": ">=0"
        },
    }
},

{
    "kprobe:mlx5_del_flow_rules": {
        "description": "Your description here",
        "proto" :"static long (*mlx5_del_flow_rules)(struct mlx5_flow_handle  handle)",
        "pre": {
            "handle": "Your condition here",
        },
    }
},


{
    "kretprobe:mlx5_get_flow_namespace": {
        "description": "This function is used to get the flow namespace based on the type.",
        "proto" :"struct mlx5_flow_namespace *(*mlx5_get_flow_namespace)(struct mlx5_core_dev *dev, enum mlx5_flow_namespace_type type)",
        "pre": {
            "dev": "!=null",
            "type": "in [MLX5_FLOW_NAMESPACE_FDB, MLX5_FLOW_NAMESPACE_PORT_SEL, MLX5_FLOW_NAMESPACE_SNIFFER_RX, MLX5_FLOW_NAMESPACE_SNIFFER_TX, MLX5_FLOW_NAMESPACE_FDB_BYPASS, MLX5_FLOW_NAMESPACE_EGRESS, MLX5_FLOW_NAMESPACE_EGRESS_IPSEC, MLX5_FLOW_NAMESPACE_EGRESS_MACSEC, MLX5_FLOW_NAMESPACE_RDMA_RX, MLX5_FLOW_NAMESPACE_RDMA_RX_KERNEL, MLX5_FLOW_NAMESPACE_RDMA_TX, MLX5_FLOW_NAMESPACE_RDMA_RX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_TX_COUNTERS, MLX5_FLOW_NAMESPACE_RDMA_RX_IPSEC, MLX5_FLOW_NAMESPACE_RDMA_TX_IPSEC]"
        }
    }
},

{
    "kretprobe:mlx5_eq_enable": {
        "description": "Enable EQ for receiving EQEs. Must be called after EQ is created in device.",
        "proto" :"int (*mlx5_eq_enable)(struct mlx5_core_dev *dev, struct mlx5_eq *eq, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        },
        "post": {
            "return": "in [0]"
        }
    }
},
{
    "kprobe:mlx5_eq_enable": {
        "description": "Enable EQ for receiving EQEs. Must be called after EQ is created in device.",
        "proto" :"int (*mlx5_eq_enable)(struct mlx5_core_dev *dev, struct mlx5_eq *eq, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        },
    }
},
{
    "kretprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs. Must be called before EQ is destroyed.",
        "proto" :"void (*mlx5_eq_disable)(struct mlx5_core_dev *dev, struct mlx5_eq *eq, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},
{
    "kprobe:mlx5_eq_disable": {
        "description": "Disable EQ for receiving EQEs. Must be called before EQ is destroyed.",
        "proto" :"void (*mlx5_eq_disable)(struct mlx5_core_dev *dev, struct mlx5_eq *eq, struct notifier_block *nb)",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "nb": "!=null"
        }
    }
},


{
    "kretprobe:mlx5_eq_update_ci": {
        "description": "Updates the consumer index of the event queue and writes the new value to the doorbell. The function also adds a barrier for ordering.",
        "proto" :"void mlx5_eq_update_ci(struct mlx5_eq *eq, u32 cc, bool arm)",
        "pre": {
            "eq": "!=null",
            "cc": "is a 32-bit unsigned integer",
            "arm": "is a boolean"
        }
    }
},


{
    "kprobe:vector2eqnirqn": {
        "description": "mlx5_vector2eqn to work",
        "proto" :"static int (*vector2eqnirqn)(struct mlx5_core_dev *dev, int vector, int *eqn, unsigned int *irqn)",
        "pre": {
            "dev": "!=null",
            "vector": "!=null",
            "eqn": "!=null",
            "irqn": "!=null"
        },
    }
},

{
    "kprobe:setup_async_eq": {
        "description": "Sets up an asynchronous event queue.",
        "proto" :"int setup_async_eq(struct mlx5_core_dev *dev, struct mlx5_eq *eq, struct mlx5_eq_param *param, const char *name)",
        "pre": {
            "dev": "!=null",
            "eq": "!=null",
            "param": "!=null",
            "name": "!=null",
        },
    }
},
{
    "kretprobe:mlx5_eq_create_generic": {
        "description": "Description of the function",
        "proto" :"struct mlx5_eq *(*mlx5_eq_create_generic)(struct mlx5_core_dev *dev, struct mlx5_eq_param *param)",
        "pre": {
            "dev": "!=null",
            "param": "in [range]"
        },
    }
},

{
    "kretprobe:mlx5_fc_counters_lookup_next": {
        "description": "Look up the next counter in the list.",
        "proto" :"static struct list_head *(*mlx5_fc_counters_lookup_next)(struct mlx5_core_dev *dev, u32 id)",
        "pre": {
            "dev": "!=null",
            "id": ">=0"
        }
    }
},
{
    "kprobe:mlx5_fc_counters_lookup_next": {
        "description": "The helper doc does not provide a clear description of this function. Please provide a clear description.",
        "proto" :"static struct list_head *mlx5_fc_counters_lookup_next(struct mlx5_core_dev *dev, u32 id)",
        "pre": {
            "dev": "!=null",
            "id": ">=0",
        },
    }
},
{
    "kretprobe:mlx5_msix_alloc": {
        "description": "Allocates an MSI-X vector and returns a map. The map is freed by mlx5_msix_free() if shutdown was initiated.",
        "proto" :"struct msi_map (*mlx5_msix_alloc)(struct mlx5_core_dev *dev, irqreturn_t (*handler)(int, void *), const struct irq_affinity_desc *affdesc, const char *name)",
        "pre": {
            "dev": "!=null",
            "handler": "!=null",
            "affdesc": "!=null",
            "name": "!=null"
        }
    }
}
]